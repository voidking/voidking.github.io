<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://www.voidking.com").hostname,root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1,cdn:{enable:!0,url:"//qiniu.cdn.voidking.com/doc/search.xml"}},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="Golang Context简介在Go语言中，context 是一个在Go语言程序中传递截止时间、取消信号以及其它请求作用域的值的包。context 包为并发操作提供了一种统一的方式来传递取消信号和元数据。经常用于控制不同Go协程之间的超时和取消操作，管理函数或方法的生命周期。 参考文档：上下文Context"><meta property="og:type" content="article"><meta property="og:title" content="好好学Golang：上下文Context"><meta property="og:url" content="https://www.voidking.com/dev-golang-context/index.html"><meta property="og:site_name" content="好好学习的郝"><meta property="og:description" content="Golang Context简介在Go语言中，context 是一个在Go语言程序中传递截止时间、取消信号以及其它请求作用域的值的包。context 包为并发操作提供了一种统一的方式来传递取消信号和元数据。经常用于控制不同Go协程之间的超时和取消操作，管理函数或方法的生命周期。 参考文档：上下文Context"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-08-08T20:00:00.000Z"><meta property="article:modified_time" content="2024-05-04T08:00:00.000Z"><meta property="article:author" content="好好学习的郝"><meta property="article:tag" content="golang"><meta property="article:tag" content="好好学Golang"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.voidking.com/dev-golang-context/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>好好学Golang：上下文Context | 好好学习的郝</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="好好学习的郝" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">好好学习的郝</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">一个计算机技术爱好者与学习者</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/voidking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.voidking.com/dev-golang-context/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="好好学习的郝"><meta itemprop="description" content="一个计算机技术爱好者与学习者"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="好好学习的郝"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> 好好学Golang：上下文Context</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-08 20:00:00" itemprop="dateCreated datePublished" datetime="2019-08-08T20:00:00+00:00">2019-08-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-05-04 08:00:00" itemprop="dateModified" datetime="2024-05-04T08:00:00+00:00">2024-05-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/" itemprop="url" rel="index"><span itemprop="name">engineering</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Golang-Context简介"><span class="post-title-index">1.</span><a href="#Golang-Context简介" class="headerlink" title="Golang Context简介"></a> Golang Context简介</h1><p>在Go语言中，<code>context</code> 是一个在Go语言程序中传递截止时间、取消信号以及其它请求作用域的值的包。<br><code>context</code> 包为并发操作提供了一种统一的方式来传递取消信号和元数据。经常用于控制不同Go协程之间的超时和取消操作，管理函数或方法的生命周期。</p><p>参考文档：<a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">上下文Context</a></p><span id="more"></span><h1 id="Context用途"><span class="post-title-index">2.</span><a href="#Context用途" class="headerlink" title="Context用途"></a> Context用途</h1><p><code>context</code> 的主要用途有以下几点：</p><p>1、超时控制：通过在 <code>context</code> 中设置超时来控制任务的执行时长，例如 HTTP 请求或数据库查询，以防止一些操作耗时过长影响系统性能。<br>2、取消操作：在多个协程之间同步取消信号，如一个用户请求的取消操作需要传递给所有相关的处理协程。<br>3、传递请求相关的数据：虽然不是 <code>context</code> 的主要用途，但它也可用于在API的调用链中传递请求特定的数据，如身份验证令牌等。</p><h1 id="Context关键概念"><span class="post-title-index">3.</span><a href="#Context关键概念" class="headerlink" title="Context关键概念"></a> Context关键概念</h1><h2 id="Context类型"><span class="post-title-index">3.1.</span><a href="#Context类型" class="headerlink" title="Context类型"></a> Context类型</h2><p><strong>Context 类型：</strong> <code>context</code> 包中定义了 <code>Context</code> 接口，它包括以下方法：</p><ul><li><code>Deadline()</code>：返回 <code>context</code> 截止时间。</li><li><code>Done()</code>：返回一个 <code>channel</code>，<code>context</code> 取消或者达截止时间时，<code>channel</code> 会被关闭。</li><li><code>Err()</code>：返回 <code>context</code> 结束的错误，如果 <code>context</code> 被取消就返回 <code>Canceled</code> 错误，如果超时则返回 <code>DeadlineExceeded</code> 错误。</li><li><code>Value(key interface&#123;&#125;)</code>：获取与 <code>key</code> 对应的值，用于传递请求特定的数据。</li></ul><h2 id="Context对象"><span class="post-title-index">3.2.</span><a href="#Context对象" class="headerlink" title="Context对象"></a> Context对象</h2><p><strong>创建 Context 对象：</strong></p><ul><li><code>context.Background()</code>：返回一个空的 <code>Context</code>，通常用于整个 <code>Context</code> 树的根节点。它不可以取消，也没有截止时间。我们并不需要，也不能主动去关闭它。它通常是用在main函数或顶层的初始化函数中，提供了一个基础的 Context，该Context通常被扩展为更复杂的 Context。</li><li><code>context.TODO()</code>：返回一个空的 <code>Context</code>，用于占位。通常在代码的某个部分还没有决定应该使用哪个 Context 时使用，或者在当前没有可用的 Context，但我们预计将来某个时间点需要向下传递一个实际的 Context 时使用。</li><li><code>context.WithCancel(parent Context)</code>：基于父 <code>Context</code> 创建新的可以主动取消的 <code>Context</code> 。</li><li><code>context.WithDeadline(parent Context, deadline time.Time)</code>：基于父 <code>Context</code> 创建新的带有截止时间的 <code>Context</code>，当达到截止时间时，<code>Context</code> 会自动取消，也可以主动取消。</li><li><code>context.WithTimeout(parent Context, timeout time.Duration)</code>：基于父 <code>Context</code> 和超时时间创建新的 <code>Context</code>。</li></ul><h2 id="Context树"><span class="post-title-index">3.3.</span><a href="#Context树" class="headerlink" title="Context树"></a> Context树</h2><p><code>Context</code> 树是指在Go的<code>context</code>包中通过<code>Context</code>对象的派生形成的层次结构。在这个层次结构中，每个<code>Context</code>对象都可能有父<code>Context</code>，同时也可以有一个或多个子<code>Context</code>。这种结构类似于一颗树，其中最顶层的<code>Context</code>通常是<code>context.Background()</code>或<code>context.TODO()</code>，它们通常作为所有<code>Context</code>层次结构的根节点。</p><p>创建子<code>Context</code>的过程一般通过<code>context.WithCancel</code>、<code>context.WithDeadline</code>、<code>context.WithTimeout</code>和<code>context.WithValue</code>四个函数实现。每个函数在创建子<code>Context</code>时都会复制父<code>Context</code>的行为（诸如超时、取消信号等），同时可以增加额外的行为或信息。</p><p>例如，如果我们有一个HTTP请求的处理逻辑，我们可能会在这个请求的开始处创建一个根<code>Context</code>（通过<code>context.WithTimeout</code>来设置整个请求的超时），然后随着我们的代码调用更深层的函数，或者启动新的goroutine来处理请求的不同部分，我们会从根<code>Context</code>派生子<code>Context</code>。</p><p>具体来说，如果一个数据库查询依赖于这个请求，我们可以再从这个根<code>Context</code>派生一个子<code>Context</code>（可能还会设置一个特定于数据库操作的超时时间），并将其传递给执行数据库操作的函数。如果需要取消整个请求处理，只需要取消最顶层的<code>Context</code>，整个<code>Context</code>树下所有的<code>Context</code>都会收到取消信号。</p><p>以下展示了<code>Context</code>树的简单结构示意：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Root <span class="built_in">Context</span> (<span class="keyword">Background </span><span class="keyword">or </span>TODO)</span><br><span class="line">│</span><br><span class="line">├── Child <span class="built_in">Context</span> A (WithCancel <span class="keyword">or </span>WithTimeout)</span><br><span class="line">│   ├── Grandchild <span class="built_in">Context</span> A.<span class="number">1</span> (WithCancel <span class="keyword">or </span>WithValue)</span><br><span class="line">│   └── Grandchild <span class="built_in">Context</span> A.<span class="number">2</span> (WithCancel)</span><br><span class="line">│</span><br><span class="line">└── Child <span class="built_in">Context</span> <span class="keyword">B </span>(WithDeadline)</span><br><span class="line">    └── Grandchild <span class="built_in">Context</span> <span class="keyword">B.1 </span>(WithCancel <span class="keyword">or </span>WithDeadline)</span><br><span class="line">        └── Great-Grandchild <span class="built_in">Context</span> <span class="keyword">B.1.1 </span>(WithCancel <span class="keyword">or </span>WithValue)</span><br></pre></td></tr></table></figure><p>在这个结构中：</p><ul><li>取消<code>Root Context</code>会导致整个树的<code>Context</code>都被取消。</li><li>取消<code>Child Context A</code>只会影响<code>A</code>的子树，即<code>Grandchild Context A.1</code>与<code>Grandchild Context A.2</code>，不会影响<code>Child Context B</code>子树。</li><li>子<code>Context</code>会继承父<code>Context</code>的截止时间和取消信号，并可以拓展自己的值与超时设置。</li></ul><p>在并发编程和复杂的应用逻辑中，管理<code>Context</code>树可以帮助开发者更有效地处理超时、取消操作以及传递关键的请求信息。</p><h1 id="Context最佳实践"><span class="post-title-index">4.</span><a href="#Context最佳实践" class="headerlink" title="Context最佳实践"></a> Context最佳实践</h1><ul><li>不要将 <code>Context</code> 存放在结构体中，而应明确地传递。</li><li>务必传递而非忽略 <code>Context</code>，即使代码还不需要它。</li><li>即使函数允许，也不要传递 <code>nil</code> <code>Context</code>，如果不确定使用哪个 <code>Context</code>，请使用 <code>context.TODO()</code>。</li><li><code>Context</code> 的 <code>Value</code> 应该用得极其谨慎，它不是传递可选参数的手段。</li></ul><p>一个典型的使用场景是在服务器处理请求时，使用 <code>context.WithCancel</code> 或 <code>context.WithTimeout</code> 在入口处产生一个 <code>Context</code>，然后将这个 <code>Context</code> 传递给每个涉及到的协程，让这些并发执行的操作都可以响应取消或超时事件。这样、单一请求的依赖操作可以被统一管理和控制。</p><h1 id="Context使用示例"><span class="post-title-index">5.</span><a href="#Context使用示例" class="headerlink" title="Context使用示例"></a> Context使用示例</h1><h2 id="创建可取消的Context"><span class="post-title-index">5.1.</span><a href="#创建可取消的Context" class="headerlink" title="创建可取消的Context"></a> 创建可取消的Context</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operation</span><span class="params">(ctx context.Context, duration time.Duration)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(duration):</span><br><span class="line">    fmt.Println(<span class="string">&quot;Operation finished successfully&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    fmt.Println(<span class="string">&quot;Operation canceled:&quot;</span>, ctx.Err())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个可取消的context</span></span><br><span class="line">  ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动一个协程执行任务</span></span><br><span class="line">  <span class="keyword">go</span> operation(ctx, <span class="number">5</span>*time.Second)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 假设1秒后我们想取消操作</span></span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">  cancel() <span class="comment">// 触发取消操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待足够长的时间以确保打印信息</span></span><br><span class="line">  time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过<code>context.WithCancel</code>创建了一个可取消的Context。在<code>operation</code>函数中，我们使用<code>select</code>监听Context的<code>Done</code>通道是否关闭。一秒后，执行<code>cancel()</code>函数，此时<code>Done</code>通道关闭，程序输出”Operation canceled”，而不会等到5秒的超时时间。</p><h2 id="创建带超时的Context"><span class="post-title-index">5.2.</span><a href="#创建带超时的Context" class="headerlink" title="创建带超时的Context"></a> 创建带超时的Context</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">operation</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-time.After(<span class="number">5</span> * time.Second): <span class="comment">// 假设操作需要5秒才能完成</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Operation finished successfully&quot;</span>)</span><br><span class="line">  <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">    fmt.Println(<span class="string">&quot;Operation failed:&quot;</span>, ctx.Err())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个超时未5秒的context</span></span><br><span class="line">  ctx, cancel := context.WithTimeout(context.Background(), <span class="number">2</span>*time.Second)</span><br><span class="line">  <span class="keyword">defer</span> cancel() <span class="comment">// 确保所有路径下都会调用cancel</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> operation(ctx)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待operation执行或超时</span></span><br><span class="line">  &lt;-ctx.Done()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ctx.Err() == context.DeadlineExceeded &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Operation timeout with deadline exceeded&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过<code>context.WithTimeout</code>创建了一个带有2秒超时的Context。由于<code>operation</code>函数中的模拟操作需要5秒才能完成，Context会在2秒后因超时而取消。<code>&lt;-ctx.Done()</code>等待Context的取消信号，打印出超时信息。</p><h2 id="Context传递值"><span class="post-title-index">5.3.</span><a href="#Context传递值" class="headerlink" title="Context传递值"></a> Context传递值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSomething</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 从Context中提取值</span></span><br><span class="line">  value := ctx.Value(<span class="string">&quot;key&quot;</span>).(<span class="type">string</span>)</span><br><span class="line">  fmt.Println(<span class="string">&quot;Value from context:&quot;</span>, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 设置一个包含值的context</span></span><br><span class="line">  ctx := context.WithValue(context.Background(), <span class="string">&quot;key&quot;</span>, <span class="string">&quot;go-12345&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用函数并传递context</span></span><br><span class="line">  doSomething(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>context.WithValue</code>向<code>context</code>添加了一个键值对。然后在<code>doSomething</code>函数中，我们从<code>context</code>中检索值并打印它。需要注意的是，如前所述，<code>WithValue</code>应该非常谨慎地使用，因为它不适合传递很多值，并且可能会导致依赖于context的代码变得难以理解和维护。</p><p>在实际应用中，<code>context</code>常常用于API调用链、数据库操作、HTTP请求处理等多级协程控制场景中。使用<code>context</code>能够优雅地管理多个协程间的超时、取消和信号传递。</p><h2 id="Context传递停止信号"><span class="post-title-index">5.4.</span><a href="#Context传递停止信号" class="headerlink" title="Context传递停止信号"></a> Context传递停止信号</h2><p><code>ctx.Done()</code> 返回只读chan类型的通道关闭信号。<br><code>&lt;-ctx.Done()</code> 用于等待ctx.Done方法返回的通道关闭信号。<br>当<code>context</code>被取消或超时的情况下，<code>Done</code>通道会被关闭，这表示相关的操作应该停止执行。</p><p>我们可以通过监听这个<code>Done</code>通道来优雅地处理取消信号和超时事件。我们通常会在长时间运行或涉及到并发的操作中使用这种方法。</p><p>Done()用法的基本示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performTask</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 监听context是否已被取消或超时</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Task was cancelled or has timed out:&quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 模拟正在进行的任务</span></span><br><span class="line">            fmt.Println(<span class="string">&quot;Task is running...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个将在3秒后超时的context</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel() <span class="comment">// 确保resources被释放</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在新的goroutine中启动任务</span></span><br><span class="line">    <span class="keyword">go</span> performTask(ctx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待ctx.Done()的信号，这表示context已被取消或者超时</span></span><br><span class="line">    &lt;-ctx.Done()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行善后工作</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Main function: Context has been cancelled, performing cleanup...&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时performTask的协程已退出，因为它监听到了ctx.Done()的关闭信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们通过<code>ctx.Done()</code>来监控一个长时间运行的任务是否应该停止。<br>当Context的超时时间到了（在本例中是3秒后），Done通道会关闭，同时<code>select</code>语句的<code>case &lt;-ctx.Done()</code>分支被选中，程序打印出取消或超时的信息，并且退出<code>for</code>循环，结束任务。<br>在主函数（<code>main</code>）中，我们也监听了<code>&lt;-ctx.Done()</code>，以便等待Context的取消信号，进行必要的清理工作。</p><p>这种做法使得并发程序在需要响应停止指令（如取消或超时）时能够及时安全地停止正在执行的操作。</p><h2 id="多个子任务并发执行"><span class="post-title-index">5.5.</span><a href="#多个子任务并发执行" class="headerlink" title="多个子任务并发执行"></a> 多个子任务并发执行</h2><p>下面是多个子函数并发执行的示例，每个子函数都通过监听<code>&lt;-ctx.Done()</code>来响应取消信号：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;context&quot;</span></span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// task 模拟一个简单的耗时任务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">task</span><span class="params">(ctx context.Context, wg *sync.WaitGroup, id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done() <span class="comment">// 等待组计数-1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模拟任务周期性执行某些操作</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">      <span class="comment">// 如果收到取消信号，打印取消信息并退出</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;Task %d is canceled: %v\n&quot;</span>, id, ctx.Err())</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">// 模拟周期性的工作</span></span><br><span class="line">      fmt.Printf(<span class="string">&quot;Task %d is running...\n&quot;</span>, id)</span><br><span class="line">      time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个带有取消功能的Context</span></span><br><span class="line">  ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">  <span class="comment">// 使用sync.WaitGroup等待所有子goroutine完成</span></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动多个并发的子函数（任务）</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>) <span class="comment">// 等待组计数+1</span></span><br><span class="line">    <span class="keyword">go</span> task(ctx, &amp;wg, i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定时3秒后，取消所有任务</span></span><br><span class="line">  time.AfterFunc(<span class="number">3</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Cancelling all tasks...&quot;</span>)</span><br><span class="line">    cancel()</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待所有任务结束</span></span><br><span class="line">  wg.Wait()</span><br><span class="line">  fmt.Println(<span class="string">&quot;All tasks have been cancelled.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个程序中:</p><p>1、我们首先使用 <code>context.WithCancel(context.Background())</code> 创建了一个可取消的父 <code>Context</code>，这个 <code>Context</code> 会被作为参数传给所有的任务（子函数）。</p><p>2、我们使用 <code>sync.WaitGroup</code> 确保主函数等待三个并发任务全部完成。每个任务的goroutine在开始时调用 <code>wg.Add(1)</code> 增加等待计数，当任务完成时调用 <code>wg.Done()</code> 递减计数。</p><p>3、<code>task</code> 函数表示需要执行的任务。它通过 <code>select</code> 语句监听两个事件：<code>ctx.Done()</code> 信号的关闭，表示任务应该取消；<code>default</code> 分支模拟正在进行的工作（这里简化为打印信息和等待1秒）。</p><p>4、在 <code>main</code> 函数中，我们使用 <code>time.AfterFunc</code> 设置了一个3秒后执行的定时器，在定时器触发时调用 <code>cancel()</code> 函数取消所有任务。</p><p>5、最后，<code>wg.Wait()</code> 阻塞主函数，直到所有goroutine执行 <code>wg.Done()</code>，这也就意味着所有任务都接收到取消信号并正常退出。</p><p>在上述示例中，当主函数中的定时器触发，所有任务都会因 <code>ctx.Done()</code> 的关闭而接收到取消信号并优雅地停止正在进行的工作。程序将输出”Task x is canceled”信息并退出。所有任务取消后，程序打印 “All tasks have been cancelled.”，然后结束。</p><h1 id="总结"><span class="post-title-index">6.</span><a href="#总结" class="headerlink" title="总结"></a> 总结</h1><p>Context的本质作用，其实是控制函数或方法的生命周期。<br>Context生命周期控制机制有两个关键概念：一个是ctx对象，一个是ctx对象的channel。</p><p>Context生命周期控制的流程可以概括为：<br>1、父函数中，创建一个ctx对象，并且把该对象传递给子函数<br>2、父函数中，可以通过定时或者手动取消，关闭ctx对象的channel<br>3、父函数中关闭ctx对象的channel时，子函数就收到了关闭信号，子函数可以选择结束自己的生命周期<br>4、如果子函数长时间运行，或者多个子函数并发，父函数中可以使用 <code>&lt;-ctx.Done()</code> 使主函数进入等待子函数执行</p><p>PS：多个子函数并发，还可以使用 <code>sync.WaitGroup</code> 等待子函数执行</p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 好好学习的郝</li><li class="post-copyright-link"> <strong>原文链接：</strong> <a href="https://www.voidking.com/dev-golang-context/" title="好好学Golang：上下文Context">https://www.voidking.com/dev-golang-context/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本文采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议，转载请注明出处！源站会即时更新知识点并修正错误，欢迎访问~</li><li> <img width="200" height="200" src="/images/avatar.jpg"><p style="text-align:center;margin-bottom:0">微信公众号同步更新，欢迎关注~</p></li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/golang/" rel="tag"># golang</a> <a href="/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Golang/" rel="tag"># 好好学Golang</a></div><div class="post-nav"><div class="post-nav-item"><a href="/dev-golang-goroutine/" rel="prev" title="好好学Golang：协程Goroutine"><i class="fa fa-chevron-left"></i> 好好学Golang：协程Goroutine</a></div><div class="post-nav-item"> <a href="/dev-golang-compile/" rel="next" title="好好学Golang：Golang中的编译">好好学Golang：Golang中的编译<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="footer-ads" style="margin-top:10px"><ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-3284447971731414" data-ad-slot="9697986181"></ins><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3284447971731414" crossorigin="anonymous"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang-Context%E7%AE%80%E4%BB%8B"><span class="nav-text">1. Golang Context简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Context%E7%94%A8%E9%80%94"><span class="nav-text">2. Context用途</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Context%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="nav-text">3. Context关键概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Context%E7%B1%BB%E5%9E%8B"><span class="nav-text">3.1. Context类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context%E5%AF%B9%E8%B1%A1"><span class="nav-text">3.2. Context对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context%E6%A0%91"><span class="nav-text">3.3. Context树</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Context%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="nav-text">4. Context最佳实践</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Context%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="nav-text">5. Context使用示例</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%8F%AF%E5%8F%96%E6%B6%88%E7%9A%84Context"><span class="nav-text">5.1. 创建可取消的Context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%B8%A6%E8%B6%85%E6%97%B6%E7%9A%84Context"><span class="nav-text">5.2. 创建带超时的Context</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context%E4%BC%A0%E9%80%92%E5%80%BC"><span class="nav-text">5.3. Context传递值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Context%E4%BC%A0%E9%80%92%E5%81%9C%E6%AD%A2%E4%BF%A1%E5%8F%B7"><span class="nav-text">5.4. Context传递停止信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E5%AD%90%E4%BB%BB%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C"><span class="nav-text">5.5. 多个子任务并发执行</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">6. 总结</span></a></li></ol></div></div><div class="sidecar-ads" style="margin-top:10px"><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="好好学习的郝" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">好好学习的郝</p><div class="site-description" itemprop="description">一个计算机技术爱好者与学习者</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">723</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">31</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">254</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:voidking@qq.com" title="E-Mail → mailto:voidking@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://github.com/voidking" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/voidking" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/voidking" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i> Zhihu</a></span></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 – <span itemprop="copyrightYear">2024</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">好好学习的郝</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="footer-beian"> <a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备14021030号</a>&nbsp;|&nbsp; <img src="/images/beian.png" alt=""> <a target="_blank" href="http://www.beian.gov.cn/">苏公网安备 32032202000223号</a></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '5a238b8c32b1e4dd2156',
      clientSecret: 'bfb5d518626f6fdc7da0351d1e0cd37ab75c6361',
      repo: 'gitalk-comments',
      owner: 'voidking',
      admin: ['voidking'],
      id: '538c557c4d48fbc4f5ca1afb5000a60e',
      title: '好好学Golang：上下文Context',
      body: '欢迎留言，互相交流学习~',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></body></html>