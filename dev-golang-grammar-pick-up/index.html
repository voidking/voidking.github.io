<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://www.voidking.com").hostname,root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1,cdn:{enable:!0,url:"//qiniu-cdn.voidking.com/doc/search.xml"}},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="前言本文记录使用Golang时遇到的一些语法问题，备忘。"><meta property="og:type" content="article"><meta property="og:title" content="好好学Golang：Golang语法拾贝"><meta property="og:url" content="https://www.voidking.com/dev-golang-grammar-pick-up/index.html"><meta property="og:site_name" content="好好学习的郝"><meta property="og:description" content="前言本文记录使用Golang时遇到的一些语法问题，备忘。"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-08-08T20:00:00.000Z"><meta property="article:modified_time" content="2024-05-04T08:00:00.000Z"><meta property="article:author" content="好好学习的郝"><meta property="article:tag" content="golang"><meta property="article:tag" content="好好学Golang"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.voidking.com/dev-golang-grammar-pick-up/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>好好学Golang：Golang语法拾贝 | 好好学习的郝</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="好好学习的郝" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">好好学习的郝</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">一个计算机技术爱好者与学习者</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/voidking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.voidking.com/dev-golang-grammar-pick-up/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="好好学习的郝"><meta itemprop="description" content="一个计算机技术爱好者与学习者"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="好好学习的郝"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> 好好学Golang：Golang语法拾贝</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-08 20:00:00" itemprop="dateCreated datePublished" datetime="2019-08-08T20:00:00+00:00">2019-08-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-05-04 08:00:00" itemprop="dateModified" datetime="2024-05-04T08:00:00+00:00">2024-05-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/" itemprop="url" rel="index"><span itemprop="name">engineering</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><span class="post-title-index">1.</span><a href="#前言" class="headerlink" title="前言"></a> 前言</h1><p>本文记录使用Golang时遇到的一些语法问题，备忘。</p><span id="more"></span><h1 id="结构体"><span class="post-title-index">2.</span><a href="#结构体" class="headerlink" title="结构体"></a> 结构体</h1><h2 id="结构体定义方法"><span class="post-title-index">2.1.</span><a href="#结构体定义方法" class="headerlink" title="结构体定义方法"></a> 结构体定义方法</h2><p>在Go语言中，结构体（struct）是一种定义复合数据类型的方式，非常适合用来封装和组织相关属性。</p><p>结构体定义了一组具有零个或多个不同类型的变量，这些变量集合在一起，表示一个实体。在Go中，结构体的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 结构体名称 <span class="keyword">struct</span> &#123;</span><br><span class="line">    字段<span class="number">1</span> 数据类型</span><br><span class="line">    字段<span class="number">2</span> 数据类型</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，我们可以创建一个代表人的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">    City <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个<code>Person</code>结构体中，有三个字段，分别存储着名字（<code>Name</code>）、年龄（<code>Age</code>）和城市信息（<code>City</code>）。</p><p>创建结构体实例的一个方法是按照字段的顺序提供字段值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;London&quot;</span>&#125;</span><br></pre></td></tr></table></figure><p>另外也可以通过字段名初始化结构体，这使得顺序不再重要，增加了代码的可读性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p := Person&#123;</span><br><span class="line">    Name: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    Age:  <span class="number">25</span>,</span><br><span class="line">    City: <span class="string">&quot;New York&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述两种初始化方式中，如果某些字段被省略，这些字段会被初始化为其类型的零值。</p><p>结构体是值类型，在函数调用时会复制相应的值。如果需要在函数间共享结构体数据，通常是通过指针来做的。在Go中，使用<code>&amp;</code>符号可以获取结构体实例的内存地址（指针），然后可以将该指针传递到函数中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateAge</span><span class="params">(p *Person, newAge <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    p.Age = newAge</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">p := Person&#123;Name: <span class="string">&quot;Charlie&quot;</span>, Age: <span class="number">20</span>, City: <span class="string">&quot;Paris&quot;</span>&#125;</span><br><span class="line">updateAge(&amp;p, <span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>结构体中也可以定义方法。方法是附加到结构体类型上的函数，它可以访问结构体中的字段。方法的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(接收器变量 结构体类型)</span></span> 方法名(参数列表) 返回参数 &#123;</span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，给<code>Person</code>结构体添加一个方法来打印个人信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> PrintInfo() &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Name: %s, Age: %d, City: %s\n&quot;</span>, p.Name, p.Age, p.City)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">p := Person&#123;Name: <span class="string">&quot;Dave&quot;</span>, Age: <span class="number">32</span>, City: <span class="string">&quot;Miami&quot;</span>&#125;</span><br><span class="line">p.PrintInfo()</span><br></pre></td></tr></table></figure><p>结构体类型可以嵌套。即，一个结构体的字段可以是另一个结构体类型，这允许构造更复杂的数据模型，例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    Street <span class="type">string</span></span><br><span class="line">    City   <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Employee <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="type">string</span></span><br><span class="line">    Age     <span class="type">int</span></span><br><span class="line">    Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">e := Employee&#123;</span><br><span class="line">    Name: <span class="string">&quot;Eve&quot;</span>,</span><br><span class="line">    Age:  <span class="number">28</span>,</span><br><span class="line">    Address: Address&#123;</span><br><span class="line">        Street: <span class="string">&quot;Main St&quot;</span>,</span><br><span class="line">        City:   <span class="string">&quot;Springfield&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Go中，结构体以及结构体上的字段和方法，如果首字母大写，则表示它们是导出的（即在包外部可见）。如果首字母小写，则它们是未导出的，只能在定义它们的包内部访问。</p><p>Go语言没有提供传统面向对象编程语言中的继承机制，而是通过接口（interface）和结构体嵌套（composition）来实现多态和代码复用。</p><h2 id="结构体转JSON（序列化）"><span class="post-title-index">2.2.</span><a href="#结构体转JSON（序列化）" class="headerlink" title="结构体转JSON（序列化）"></a> 结构体转JSON（序列化）</h2><p>在Go语言中，<code>encoding/json</code>标准库提供了处理JSON数据的功能，包括将结构体转换为JSON（序列化）以及将JSON转换为结构体（反序列化）。</p><p>要将一个Go结构体转换为JSON字符串，可以使用<code>json.Marshal</code>函数。下面是一个简单的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    City <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>, <span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line">    </span><br><span class="line">    jsonData, err := json.Marshal(p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="type">string</span>(jsonData))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出将是：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;Alice&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">30</span><span class="punctuation">,</span><span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;New York&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在此示例中，<code>Person</code>结构体定义了JSON字段名通过使结构体标签。当<code>json.Marshal</code>被调用时，它会检查每个结构体字段的这些标签，并使用它们作为JSON对象中的键名。</p><p>如果不想让某些字段出现在JSON中，可以使用<code>json:&quot;-&quot;</code>来排除这些字段，或者使字段名的首字母小写，这样在默认情况下它不会被序列化。</p><h2 id="JSON转结构体（反序列化）"><span class="post-title-index">2.3.</span><a href="#JSON转结构体（反序列化）" class="headerlink" title="JSON转结构体（反序列化）"></a> JSON转结构体（反序列化）</h2><p>将JSON数据转换为Go结构体的操作，是通过<code>json.Unmarshal</code>函数来完成的。首先让我们看一个如何实现的示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    City <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    jsonData := []<span class="type">byte</span>(<span class="string">`&#123;&quot;name&quot;:&quot;Bob&quot;,&quot;age&quot;:25,&quot;city&quot;:&quot;Los Angeles&quot;&#125;`</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> p Person</span><br><span class="line">    err := json.Unmarshal(jsonData, &amp;p)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出将是：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="title class_">Name</span><span class="symbol">:Bob</span> <span class="title class_">Age</span><span class="symbol">:</span><span class="number">25</span> <span class="title class_">City</span><span class="symbol">:Los</span> <span class="title class_">Angeles</span>&#125;</span><br></pre></td></tr></table></figure><p>在上面这个例子中，我们首先定义了一个JSON字符串，然后将其转换为字节切片（因为<code>json.Unmarshal</code>函数需要一个字节切片作为输入）。接下来创建了<code>Person</code>类型的变量<code>p</code>，并将其地址传递给<code>json.Unmarshal</code>，它将解析json数据，并填充到相应的结构体字段中。</p><p>值得注意的是，字段名在结构体标签中指定的JSON键必须与实际的JSON数据匹配。此外，如果JSON中的数据类型和结构体字段的数据类型不匹配，<code>json.Unmarshal</code>会报错。</p><p>使用结构体标签，我们可以控制序列化和反序列化的行为，例如忽略空值或者只在序列化时包含字段等：</p><ul><li><code>omitempty</code>选项会让字段在序列化JSON时，如果是空值，则忽略它。</li><li><code>omitempty</code>也可以用在反序列化JSON时，如果JSON中某个字段缺失，则会保持该字段的零值。</li></ul><p>下面的示例中，如果<code>City</code>字段为空，在序列化时它将不会出现在JSON中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="type">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">    City <span class="type">string</span> <span class="string">`json:&quot;city,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理结构体转换为JSON和JSON转换为结构体时，总是推荐进行错误检查，以防数据格式不正确或是类型不匹配，避免潜在的运行时问题。</p><h2 id="自定义结构体打印格式"><span class="post-title-index">2.4.</span><a href="#自定义结构体打印格式" class="headerlink" title="自定义结构体打印格式"></a> 自定义结构体打印格式</h2><p>使用 fmt.Println 或者 logrus.Info 来打印一个结构体，它将默认调用结构体的 String() 方法（结构体实现了 fmt.Stringer 接口）或者直接打印结构体的值，不会直接打印字段名（key）。<br>因此，如果想要自定义结构体的输出格式，那么需要重写 String() 方法。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="type">string</span></span><br><span class="line">    Age  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := Person&#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印结构体，只输出值</span></span><br><span class="line">fmt.Println(p)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Person)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Name: %s, Age: %d&quot;</span>, p.Name, p.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会调用 p.String() 并输出 &quot;Name: Alice, Age: 25&quot;</span></span><br><span class="line">fmt.Println(p)</span><br></pre></td></tr></table></figure><h2 id="结构体的替代"><span class="post-title-index">2.5.</span><a href="#结构体的替代" class="headerlink" title="结构体的替代"></a> 结构体的替代</h2><p>在Go语言中，结构体（<code>struct</code>）是一种自定义的数据类型，它允许我们组合不同的字段（属性），这些字段可以是不同的数据类型。使用结构体是一种强类型的方法来表示一组相关的数据。不过，在某些场景中，我们可能需要一种更灵活的数据结构来处理动态类型的数据或未知的数据模式。这时，可以使用<code>map[string]interface&#123;&#125;</code>和<code>unstructured</code>作为结构体的替代方案。</p><h3 id="map-string-interface"><span class="post-title-index">2.5.1.</span><a href="#map-string-interface" class="headerlink" title="map[string]interface{}"></a> map[string]interface{}</h3><p>使用这种类型的映射来存储键值对，其中键是字符串类型，代表属性的名称，而值是<code>interface&#123;&#125;</code>类型，可以接受任何类型的值。这种方式的好处是我们可以存储任何结构的数据，但缺点是失去了类型安全，需要在使用时进行类型断言。</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个map[string]interface&#123;&#125;的实例</span></span><br><span class="line">    person := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向map中添加数据</span></span><br><span class="line">    person[<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;张三&quot;</span></span><br><span class="line">    person[<span class="string">&quot;age&quot;</span>] = <span class="number">25</span></span><br><span class="line">    person[<span class="string">&quot;hobbies&quot;</span>] = []<span class="type">string</span>&#123;<span class="string">&quot;读书&quot;</span>, <span class="string">&quot;旅游&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印map的内容</span></span><br><span class="line">    fmt.Println(person)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取map中的特定值</span></span><br><span class="line">    name := person[<span class="string">&quot;name&quot;</span>].(<span class="type">string</span>) <span class="comment">// 类型断言</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;名字：&quot;</span>, name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个关于 person 的map，可以存储人名、年龄和爱好的数据。显然，这种方式比较灵活，但在读取<code>map</code>时，每次都需要对取出的值做类型断言，这样会带来运行时的风险。</p><h3 id="unstructured"><span class="post-title-index">2.5.2.</span><a href="#unstructured" class="headerlink" title="unstructured"></a> unstructured</h3><p><code>unstructured</code>是来自Kubernetes的<code>client-go</code>库的一个类型，专门用来处理Kubernetes的API资源。它也是建立在<code>map[string]interface&#123;&#125;</code>基础上的，但提供了一套更为丰富的API来方便地访问和修改这些非结构化的数据。</p><p>例子:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">   <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1/unstructured&quot;</span></span><br><span class="line">   <span class="string">&quot;k8s.io/apimachinery/pkg/runtime/schema&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 创建一个Unstructured对象</span></span><br><span class="line">   u := unstructured.Unstructured&#123;</span><br><span class="line">       Object: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">           <span class="string">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">           <span class="string">&quot;kind&quot;</span>:       <span class="string">&quot;Pod&quot;</span>,</span><br><span class="line">           <span class="string">&quot;metadata&quot;</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">               <span class="string">&quot;name&quot;</span>: <span class="string">&quot;example-pod&quot;</span>,</span><br><span class="line">           &#125;,</span><br><span class="line">           <span class="string">&quot;spec&quot;</span>: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">               <span class="string">&quot;containers&quot;</span>: []<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">                   <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">                       <span class="string">&quot;name&quot;</span>:  <span class="string">&quot;web&quot;</span>,</span><br><span class="line">                       <span class="string">&quot;image&quot;</span>: <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">                   &#125;,</span><br><span class="line">               &#125;,</span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;,</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取groupVersionKind信息</span></span><br><span class="line">   gvk := schema.GroupVersionKind&#123;</span><br><span class="line">       Version: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">       Kind:    <span class="string">&quot;Pod&quot;</span>,</span><br><span class="line">   &#125;</span><br><span class="line">   u.SetGroupVersionKind(gvk)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 打印Unstructured对象的内容</span></span><br><span class="line">   fmt.Printf(<span class="string">&quot;Unstructured对象: %+v\n&quot;</span>, u)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 获取和访问spec中的容器信息</span></span><br><span class="line">   containers, _, _ := unstructured.NestedSlice(u.Object, <span class="string">&quot;spec&quot;</span>, <span class="string">&quot;containers&quot;</span>)</span><br><span class="line">   <span class="keyword">for</span> _, container := <span class="keyword">range</span> containers &#123;</span><br><span class="line">       fmt.Printf(<span class="string">&quot;容器: %+v\n&quot;</span>, container)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个Kubernetes Pod资源的<code>unstructured.Unstructured</code>对象，并设置了它的API版本、资源类型和其他元信息。然后，我们通过特定的函数访问了<code>spec.containers</code>字段的内容。<code>unstructured.Unstructured</code>提供了一系列辅助函数来处理嵌套的字段，这使得访问和修改数据变得更加方便。</p><p>事实上，<code>unstructured</code>的核心仍然是一个<code>map[string]interface&#123;&#125;</code>，但是它提供了那些使得处理非结构化数据更易用的方法。而普通的<code>map[string]interface&#123;&#125;</code>则更为基础，适用于那些没有特殊库辅助方法的情况。</p><h1 id="函数与接口"><span class="post-title-index">3.</span><a href="#函数与接口" class="headerlink" title="函数与接口"></a> 函数与接口</h1><h2 id="函数与接口的定义方法"><span class="post-title-index">3.1.</span><a href="#函数与接口的定义方法" class="headerlink" title="函数与接口的定义方法"></a> 函数与接口的定义方法</h2><p>Go 语言中的函数和方法是两个不同的概念，虽然它们的声明语法很类似，但是它们在 Go 中的作用和使用方式有所不同。</p><p><strong>函数</strong><br>Go 语言定义函数使用关键字 <code>func</code>，下面是 Go 语言函数定义的通用语法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functionname</span><span class="params">(parametername <span class="keyword">type</span>)</span></span> returntype &#123;  </span><br><span class="line">    <span class="comment">// 函数体（具体的执行代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(x <span class="type">int</span>, y <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码片段中，函数 <code>add</code> 接收两个 <code>int</code> 类型的输入参数，返回一个 <code>int</code> 类型的值。</p><p><strong>方法</strong><br>方法是附加在一个给定类型的值上的一个函数，它能访问该类型的值的所有字段和方法。方法定义的语法如下：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t Type)</span></span> methodName(parametername <span class="keyword">type</span>) returntype &#123;  </span><br><span class="line">    <span class="comment">// 方法体（具体的执行代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Type</code> 是 Go 语言中的一个类型，可以是内置的类型，例如 <code>int</code>、<code>float32</code> 等，也可以是用户自定义的类型。</p><p>示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;  </span><br><span class="line">    length <span class="type">int</span></span><br><span class="line">    width  <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span></span> Area() <span class="type">int</span> &#123;  </span><br><span class="line">    <span class="keyword">return</span> r.length*r.width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码片段中，<code>Area</code> 是作用在 <code>Rectangle</code> 类型上的一个方法，它使用 <code>Rectangle</code> 类型的 <code>length</code> 和 <code>width</code> 字段计算矩形的面积。</p><p>当我们有一个类型的实例时，我们可以使用 <code>.</code> 来调用它的方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">r := Rectangle&#123;</span><br><span class="line">    length: <span class="number">10</span>,</span><br><span class="line">    width:  <span class="number">5</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(r.Area()) <span class="comment">// 输出 50</span></span><br></pre></td></tr></table></figure><h2 id="指针接收器"><span class="post-title-index">3.2.</span><a href="#指针接收器" class="headerlink" title="指针接收器"></a> 指针接收器</h2><p><code>(t Type)</code> 和 <code>(t *Type)</code> 都是 Go 语言方法的接收器（也称为接收者）类型，前者是值接收器，后者是指针接收器。</p><p>对于值接收器 <code>(t Type)</code>，在调用 t 的任何方法时，会将 t 的值复制一份，这意味着在方法体内对 t 的任何修改，只会影响复制的那份，不会影响原来的值。</p><p>示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myType <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t myType)</span></span> setValue(val <span class="type">int</span>) &#123;</span><br><span class="line">    t.value = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := myType&#123;value: <span class="number">10</span>&#125;</span><br><span class="line">    x.setValue(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(x.value) <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指针接收器 <code>(t *Type)</code> 时，不会复制原始值，而是直接获取到对象的内存地址，因此，在方法体内对 t 所做的任何修改，都会直接反映在原始值上。</p><p>示例：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myType <span class="keyword">struct</span> &#123;</span><br><span class="line">    value <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *myType)</span></span> setValue(val <span class="type">int</span>) &#123;</span><br><span class="line">    t.value = val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := &amp;myType&#123;value: <span class="number">10</span>&#125;</span><br><span class="line">    x.setValue(<span class="number">20</span>)</span><br><span class="line">    fmt.Println(x.value) <span class="comment">// 输出 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>选择使用值接收器还是指针接收器，主要取决于我们是否需要在方法内修改接收器的状态，以及我们是否希望避免复制（例如，当类型的值很大时，复制可能会很昂贵）。</p><h1 id="单元测试"><span class="post-title-index">4.</span><a href="#单元测试" class="headerlink" title="单元测试"></a> 单元测试</h1><h2 id="运行测试"><span class="post-title-index">4.1.</span><a href="#运行测试" class="headerlink" title="运行测试"></a> 运行测试</h2><p>假设 go.md 中的 module 为 pod-data-restorer ， xxx_test.go 中 package 为 podwebhook</p><p>1、测试运行整个包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> pod-data-restorer/podwebhook</span><br></pre></td></tr></table></figure><p>2、测试运行包中某个测试函数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go <span class="built_in">test</span> -run TestFunctionName pod-data-restorer/podwebhook</span><br></pre></td></tr></table></figure><h2 id="单元测试时输出日志"><span class="post-title-index">4.2.</span><a href="#单元测试时输出日志" class="headerlink" title="单元测试时输出日志"></a> 单元测试时输出日志</h2><p>在Go的单元测试中，标准的方式是使用来自 <code>testing</code> 包的 <code>T</code> 结构的 <code>Log</code> 方法和其变种如 <code>Logf</code>，<code>Error</code>，<code>Errorf</code>，<code>Fatal</code>，<code>Fatalf</code> 等。</p><p>这是一个例子：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExample</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Log(<span class="string">&quot;This is a log message during testing.&quot;</span>)</span><br><span class="line">    t.Logf(<span class="string">&quot;Formatted log message with value: %d&quot;</span>, <span class="number">42</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果用 <code>go test</code> 运行测试，正常的 <code>t.Log</code> 或 <code>t.Logf</code> 输出是不会被显示的，只有当测试失败或者我们用 <code>go test -v</code> 运行测试，<code>t.Log</code> 的输出才会被显示。</p><p>如果我们需要日志在任何情况下都显示，考虑使用 <code>t.Error</code> 或 <code>t.Errorf</code>。这会使当前的测试失败，并输出我们提供的日志信息。</p><p>例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExample</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Error(<span class="string">&quot;This is an error message. The test will fail.&quot;</span>)</span><br><span class="line">    t.Errorf(<span class="string">&quot;Formatted error message with value: %d&quot;</span>, <span class="number">42</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Fatal</code> 和 <code>Fatalf</code> 方法也会使测试失败，但是它们会立即停止当前的测试函数，不会执行后面的代码。而 <code>Error</code> 和 <code>Errorf</code> 不会停止测试函数的执行。</p><p>例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExample</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    t.Fatal(<span class="string">&quot;This is a fatal error message. The test will fail and stop.&quot;</span>)</span><br><span class="line">    t.Fatalf(<span class="string">&quot;This will not be displayed because the test already stopped.&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="协程Goroutine"><span class="post-title-index">5.</span><a href="#协程Goroutine" class="headerlink" title="协程Goroutine"></a> 协程Goroutine</h1><p>参考文档：<a href="https://www.voidking.com/dev-golang-goroutine/">《好好学Golang：协程Goroutine》</a></p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 好好学习的郝</li><li class="post-copyright-link"> <strong>原文链接：</strong> <a href="https://www.voidking.com/dev-golang-grammar-pick-up/" title="好好学Golang：Golang语法拾贝">https://www.voidking.com/dev-golang-grammar-pick-up/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本文采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议，转载请注明出处！源站会即时更新知识点并修正错误，欢迎访问~</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/golang/" rel="tag"># golang</a> <a href="/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Golang/" rel="tag"># 好好学Golang</a></div><div class="post-nav"><div class="post-nav-item"><a href="/dev-golang-mysql/" rel="prev" title="好好学Golang：Golang操作MySQL"><i class="fa fa-chevron-left"></i> 好好学Golang：Golang操作MySQL</a></div><div class="post-nav-item"> <a href="/dev-golang-goroutine/" rel="next" title="好好学Golang：协程Goroutine">好好学Golang：协程Goroutine<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="footer-ads" style="margin-top:10px"><ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-3284447971731414" data-ad-slot="9697986181"></ins><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3284447971731414" crossorigin="anonymous"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">1. 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">2. 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="nav-text">2.1. 结构体定义方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E8%BD%ACJSON%EF%BC%88%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89"><span class="nav-text">2.2. 结构体转JSON（序列化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JSON%E8%BD%AC%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%88%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%89"><span class="nav-text">2.3. JSON转结构体（反序列化）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93%E6%89%93%E5%8D%B0%E6%A0%BC%E5%BC%8F"><span class="nav-text">2.4. 自定义结构体打印格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%9B%BF%E4%BB%A3"><span class="nav-text">2.5. 结构体的替代</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#map-string-interface"><span class="nav-text">2.5.1. map[string]interface{}</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#unstructured"><span class="nav-text">2.5.2. unstructured</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8E%A5%E5%8F%A3"><span class="nav-text">3. 函数与接口</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E6%B3%95"><span class="nav-text">3.1. 函数与接口的定义方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E6%8E%A5%E6%94%B6%E5%99%A8"><span class="nav-text">3.2. 指针接收器</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="nav-text">4. 单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95"><span class="nav-text">4.1. 运行测试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%97%B6%E8%BE%93%E5%87%BA%E6%97%A5%E5%BF%97"><span class="nav-text">4.2. 单元测试时输出日志</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8BGoroutine"><span class="nav-text">5. 协程Goroutine</span></a></li></ol></div></div><div class="sidecar-ads" style="margin-top:10px"><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="好好学习的郝" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">好好学习的郝</p><div class="site-description" itemprop="description">一个计算机技术爱好者与学习者</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">748</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">259</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:voidking@qq.com" title="E-Mail → mailto:voidking@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://github.com/voidking" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/voidking" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/voidking" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i> Zhihu</a></span></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">好好学习的郝</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="footer-beian"> <a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备14021030号</a>&nbsp;|&nbsp; <img src="/images/beian.png" alt=""> <a target="_blank" href="http://www.beian.gov.cn/">苏公网安备 32032202000223号</a></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '5a238b8c32b1e4dd2156',
      clientSecret: 'bfb5d518626f6fdc7da0351d1e0cd37ab75c6361',
      repo: 'gitalk-comments',
      owner: 'voidking',
      admin: ['voidking'],
      id: 'ef9b73d614e08a890e92a3556d87fcd7',
      title: '好好学Golang：Golang语法拾贝',
      body: '欢迎留言，互相交流学习~',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></body></html>