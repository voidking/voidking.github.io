<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://www.voidking.com").hostname,root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1,cdn:{enable:!0,url:"//cdn.jsdelivr.net/gh/voidking/voidking.github.io/search.xml"}},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="前言Lisp是Fortran语言之后第二古老的高级编程语言，自成立之初已发生了很大变化。如今，最广为人知的通用的是Lisp方言：Common Lisp和Scheme。 Common Lisp和Scheme有什么不同呢？个人认为，Common Lisp和Scheme，就像狮子和家犬。狮子更加强大，难以驯服；家犬更加小巧，容易驯服。而选择哪一种，取决于实际需要。鉴于郝同学只是需要学习一下函数式编程的思"><meta property="og:type" content="article"><meta property="og:title" content="函数式编程之Scheme入门"><meta property="og:url" content="https://www.voidking.com/dev-scheme-start/index.html"><meta property="og:site_name" content="好好学习的郝"><meta property="og:description" content="前言Lisp是Fortran语言之后第二古老的高级编程语言，自成立之初已发生了很大变化。如今，最广为人知的通用的是Lisp方言：Common Lisp和Scheme。 Common Lisp和Scheme有什么不同呢？个人认为，Common Lisp和Scheme，就像狮子和家犬。狮子更加强大，难以驯服；家犬更加小巧，容易驯服。而选择哪一种，取决于实际需要。鉴于郝同学只是需要学习一下函数式编程的思"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.voidking.com//imgs/scheme-start/setup.jpg?imageView2/0/w/700"><meta property="og:image" content="http://cdn.voidking.com//imgs/scheme-start/config.jpg?imageView2/0/w/700"><meta property="og:image" content="http://cdn.voidking.com//imgs/scheme-start/run.jpg?imageView2/0/w/700"><meta property="article:published_time" content="2017-04-13T14:00:00.000Z"><meta property="article:modified_time" content="2017-04-13T14:00:00.000Z"><meta property="article:author" content="好好学习的郝"><meta property="article:tag" content="函数式编程"><meta property="article:tag" content="形式语义学"><meta property="article:tag" content="lisp"><meta property="article:tag" content="scheme"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://cdn.voidking.com//imgs/scheme-start/setup.jpg?imageView2/0/w/700"><link rel="canonical" href="https://www.voidking.com/dev-scheme-start/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>函数式编程之Scheme入门 | 好好学习的郝</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="好好学习的郝" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">好好学习的郝</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">好好学习，天天向上！</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/voidking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.voidking.com/dev-scheme-start/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="好好学习的郝"><meta itemprop="description" content="学而不思则罔，思而不学则殆！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="好好学习的郝"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> 函数式编程之Scheme入门</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2017-04-13 14:00:00" itemprop="dateCreated datePublished" datetime="2017-04-13T14:00:00+00:00">2017-04-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/" itemprop="url" rel="index"><span itemprop="name">engineering</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/uncategories/" itemprop="url" rel="index"><span itemprop="name">uncategories</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Lisp是Fortran语言之后第二古老的高级编程语言，自成立之初已发生了很大变化。如今，最广为人知的通用的是Lisp方言：Common Lisp和Scheme。</p><p>Common Lisp和Scheme有什么不同呢？个人认为，Common Lisp和Scheme，就像狮子和家犬。狮子更加强大，难以驯服；家犬更加小巧，容易驯服。而选择哪一种，取决于实际需要。鉴于郝同学只是需要学习一下函数式编程的思想，所以Scheme足够了。</p><p>PS：MIT 的两本著名教材 SICP（Structure and Interpretation of Computer Programs）和 HTDP（How to Design Programs）都是以Scheme为基础的。</p><span id="more"></span><h1 id="安装mit-scheme"><a href="#安装mit-scheme" class="headerlink" title="安装mit-scheme"></a>安装mit-scheme</h1><p>1、进入<a target="_blank" rel="noopener" href="https://www.gnu.org/software/mit-scheme/">mit-scheme官网</a>，下载对应平台的mit-scheme（下文以windows为例）。</p><p>2、安装下载的mit-scheme（下文简称scheme）。</p><p>3、双击scheme快捷方式，如果出现如下界面，表明安装成功。<br><img src="http://cdn.voidking.com//imgs/scheme-start/setup.jpg?imageView2/0/w/700"></p><p>PS：如果打开scheme的时候报错“Requested allocation is too large. Try with smaller argument to –heap”。那么，在程序的快捷方式上右键，属性，在“目标”里加上<code>--heap 512</code>。</p><p>4、把安装路径加入环境变量。<br>例如，我的scheme安装路径为<code>C:\Program Files (x86)\MIT-GNU Scheme</code>，那么，在path中加入<code>C:\Program Files (x86)\MIT-GNU Scheme\bin</code>。同时，新建系统变量MITSCHEME_LIBRARY_PATH，值为<code>C:\Program Files (x86)\MIT-GNU Scheme\lib</code>。</p><p>5、测试scheme。<br>打开命令行，输入<code>mit-scheme</code>，弹出如下界面，表明安装配置成功。<br><img src="http://cdn.voidking.com//imgs/scheme-start/config.jpg?imageView2/0/w/700"></p><p>6、退出scheme。<br>在scheme命令窗口输入<code>(exit)</code>，选择y，退出scheme命令窗口。</p><h1 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h1><p>在scheme命令窗口中输入代码非常麻烦，光标不能回退和上下移动，所以比较简单的方法就是运行已经写完的文件。</p><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>1、新建hello.scm文件，内容如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;The first program</span></span><br><span class="line">(<span class="name"><span class="built_in">begin</span></span></span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    (<span class="name"><span class="built_in">newline</span></span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>2、运行hello.scm。<br><code>mit-scheme -load hello.scm</code>，效果如下：<br><img src="http://cdn.voidking.com//imgs/scheme-start/run.jpg?imageView2/0/w/700"></p><p>PS：如果此时报错“Requested allocation is too large. Try with smaller argument to –heap”，那么，修改命令为<code>mit-scheme --heap 128 -load hello.scm</code>。</p><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>打开mit-scheme窗口后，<code>(cd &quot;e:\\temp&quot;)</code>，<code>(load &quot;hello.scm&quot;)</code>。</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Scheme中的简单数据类型包含 boolean（布尔类型），number（数字类型），character（字符类型） 和 symbol（标识符类型）。</p><p>复合数据类型是以组合的方式通过组合其它数据类型数据来获得。包括string、vector、dotted pair、list等。</p><p>数据类型详解：<br><a target="_blank" rel="noopener" href="http://www.kancloud.cn/wizardforcel/teach-yourself-scheme/147165">http://www.kancloud.cn/wizardforcel/teach-yourself-scheme/147165</a></p><h2 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h2><p>函数式编程只用“表达式”，不用“语句”。</p><p>“表达式”（expression）是一个单纯的运算过程，总是有返回值；“语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。</p><p>原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。<br>当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。</p><p>基本格式：<br><code>(function_name arg0,arg1,...)</code></p><p>示例：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">(<span class="name"><span class="built_in">newline</span></span>)</span><br><span class="line">(<span class="name">exit</span>)</span><br><span class="line">(<span class="name"><span class="built_in">number?</span></span> <span class="number">42</span>)</span><br><span class="line">(<span class="name"><span class="built_in">eqv?</span></span> <span class="number">42</span> <span class="number">42</span>)</span><br><span class="line">(<span class="name"><span class="built_in">&gt;=</span></span> <span class="number">4.5</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>迄今为止我们提供的Scheme示例程序都是s-表达式。这对所有的Scheme程序来说都适用：程序是数据。</p><p>Scheme运行一个列表形式的代码结构时，首先要检测列表第一个元素，或列表头。如果这个列表头是一个过程，则代码结构的其余部分则被当成将传递给这个过程的参数集，而这个过程将接收这些参数并运算。</p><p>如果这个代码结构的列表头是一个特殊的代码结构，则将会采用一种特殊的方式来运行。常见的特殊的代码结构有begin， define和 set!。</p><p>begin可以让它的子结构可以有序的运算，而最后一个子结构的结果将成为整个代码结构的运行结果。define会声明并会初始化一个变量。set! 可以给已经存在的变量重新赋值。</p><h2 id="过程（函数）定义"><a href="#过程（函数）定义" class="headerlink" title="过程（函数）定义"></a>过程（函数）定义</h2><h3 id="匿名过程"><a href="#匿名过程" class="headerlink" title="匿名过程"></a>匿名过程</h3><p>我们已经见过了许多系统过程，比如，cons， string-&gt;list等。用户可以使用代码结构lambda来创建自定义的过程。例如，下面定义了一个过程可以在它的参数上加上2：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">+</span></span> x <span class="number">2</span>))</span><br></pre></td></tr></table></figure><p>第一个子结构，(x)，是参数列表。其余的子结构则构成了这个过程执行体。这个过程可以像系统过程一样，通过传递一个参数完成调用：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">+</span></span> x <span class="number">2</span>)) <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="一般定义"><a href="#一般定义" class="headerlink" title="一般定义"></a>一般定义</h3><p>如果我们希望能够多次调用这个相同的过程，我们可以每次使用lambda重新创建一个复制品，但我们有更好的方式。我们可以使用一个变量来承载这个过程：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> add2</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">+</span></span> x <span class="number">2</span>)))</span><br></pre></td></tr></table></figure><p>只要需要，我们就可以反复使用add2为参数加上2：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(add2 <span class="number">4</span>) <span class="operator">=</span>&gt;  <span class="number">6</span></span><br><span class="line">(add2 <span class="number">9</span>) <span class="operator">=</span>&gt;  <span class="number">11</span></span><br></pre></td></tr></table></figure><p>定义过程还可以有另一种简单的方式，直接用define而不使用lambda来创建：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> (<span class="name">add2</span> x)</span><br><span class="line">       (<span class="name"><span class="built_in">+</span></span> x <span class="number">2</span>))</span><br></pre></td></tr></table></figure><h3 id="过程的参数"><a href="#过程的参数" class="headerlink" title="过程的参数"></a>过程的参数</h3><p>lambda 过程的参数由它的第一个子结构（紧跟着lambda标记的那个结构）来定义。add2是一个单参数或一元过程，所以它的参数列表是只有一个元素的列表(x)。标记x作为一个承载过程参数的变量而存在。在过程体中出现的所有x都是指代这个过程的参数。对这个过程体来说x是一个局部变量。</p><p>我们可以为两个参数的过程提供两个元素的列表做参数，通常都是为n个参数的过程提供n个元素的列表。下面是一个可以计算矩形面积的双参数过程。它的两个参数分别是矩形的长和宽。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> area</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (length breadth)</span><br><span class="line">    (<span class="name"><span class="built_in">*</span></span> length breadth)))</span><br></pre></td></tr></table></figure><p>我们看到area将它的参数进行相乘，系统过程*也可以实现相乘。我们可以简单的这样做：</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">define</span> <span class="section">area</span> *)</span><br></pre></td></tr></table></figure><h2 id="apply过程"><a href="#apply过程" class="headerlink" title="apply过程"></a>apply过程</h2><p>apply过程允许我们直接传递一个装有参数的list 给一个过程来完成对这个过程的批量操作。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> x &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">(<span class="name"><span class="built_in">apply</span></span> + x)</span><br></pre></td></tr></table></figure><p>通常，apply需要传递一个过程给它，后面紧接着是不定长参数，但最后一个参数值一定要是list。它会根据最后一个参数和中间其它的参数来构建参数列表。然后返回根据这个参数列表来调用过程得到的结果。例如:</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">apply</span></span> + <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> x)</span><br></pre></td></tr></table></figure><h2 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h2><p>我们使用begin这个特殊的结构来对一组需要有序执行的子结构来进行打包。许多Scheme的代码结构都隐含了begin。例如，我们定义一个三个参数的过程来输出它们，并用空格间格。一种正确的定义是：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> display3</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (arg1 arg2 arg3)</span><br><span class="line">    (<span class="name"><span class="built_in">begin</span></span></span><br><span class="line">      (<span class="name"><span class="built_in">display</span></span> arg1)</span><br><span class="line">      (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot; &quot;</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">display</span></span> arg2)</span><br><span class="line">      (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot; &quot;</span>)</span><br><span class="line">      (<span class="name"><span class="built_in">display</span></span> arg3)</span><br><span class="line">      (<span class="name"><span class="built_in">newline</span></span>))))</span><br></pre></td></tr></table></figure><p>在Scheme中，lambda的语句体都是隐式的begin代码结构。因此，display3语句体中的begin不是必须的，不写时也不会有什么影响。</p><p>display3更简化的写法是：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> display3</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (arg1 arg2 arg3)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> arg1)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot; &quot;</span>)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> arg2)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot; &quot;</span>)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> arg3)</span><br><span class="line">    (<span class="name"><span class="built_in">newline</span></span>)))</span><br></pre></td></tr></table></figure><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>最基本的结构就是if：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">if</span> 测试条件</span><br><span class="line">    then-分支</span><br><span class="line">    <span class="keyword">else</span>-分支)</span><br></pre></td></tr></table></figure><p>如果测试条件运算的结果是真(非#f的任何其它值)，then分支将会被运行(即满足条件时的运行分支)。否则，else分支会被运行。else分支是可选的。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> p <span class="number">80</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&gt;</span></span> p <span class="number">70</span>) </span><br><span class="line">    <span class="symbol">&#x27;safe</span></span><br><span class="line">    <span class="symbol">&#x27;unsafe</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&lt;</span></span> p <span class="number">90</span>)</span><br><span class="line">    <span class="symbol">&#x27;low-pressure</span>) <span class="comment">;no ``else&#x27;&#x27; branch</span></span><br></pre></td></tr></table></figure><h3 id="when-和-unless"><a href="#when-和-unless" class="headerlink" title="when 和 unless"></a>when 和 unless</h3><p>当我们只需要一个基本条件语句分支时（”then”分支或”else”分支），使用when 和 unless会更方便。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> a <span class="number">10</span>)</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> b <span class="number">20</span>)</span><br><span class="line">(<span class="name"><span class="built_in">when</span></span> (<span class="name"><span class="built_in">&lt;</span></span> a b)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;a是&quot;</span>)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> a)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;b是&quot;</span>)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> b)</span><br><span class="line">    (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;a小于b&quot;</span> ) )</span><br></pre></td></tr></table></figure><p>先判断a是否小于b，这个条件成立时会输出倒序的5条信息。</p><p>同样的功能还可以像下面这样用unless来写(unless和when的意思正好相反)：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> a <span class="number">10</span>)</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> b <span class="number">20</span>)</span><br><span class="line">(<span class="name"><span class="built_in">unless</span></span> (<span class="name"><span class="built_in">&gt;=</span></span> a b)</span><br><span class="line">   (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;a是&quot;</span>)</span><br><span class="line">   (<span class="name"><span class="built_in">display</span></span> a)</span><br><span class="line">   (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;b是&quot;</span>)</span><br><span class="line">   (<span class="name"><span class="built_in">display</span></span> b)</span><br><span class="line">   (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;a小于b&quot;</span> ) )</span><br></pre></td></tr></table></figure><p>并不是所有的Scheme环境都提供when和unless。<br>如果你的Scheme中没有，你可以用宏来自定义出when和unless。</p><p>使用if实现相同的程序会是这样：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> a <span class="number">10</span>)</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> b <span class="number">20</span>)</span><br><span class="line">(<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&lt;</span></span> a b)</span><br><span class="line">    (<span class="name"><span class="built_in">begin</span></span></span><br><span class="line">        (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;a是&quot;</span>)</span><br><span class="line">        (<span class="name"><span class="built_in">display</span></span> a)</span><br><span class="line">        (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;b是&quot;</span>)</span><br><span class="line">        (<span class="name"><span class="built_in">display</span></span> b)</span><br><span class="line">        (<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;a小于b&quot;</span> ) ))</span><br></pre></td></tr></table></figure><p>先判断a是否小于b，这个条件成立时会输出正序的5条信息。</p><p>在mit-scheme下，中文会显示乱码，为方便查看，建议修改成英文。</p><h3 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h3><p>多重if结构为：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> c <span class="literal">#\c</span>)</span><br><span class="line">(<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">char&lt;?</span></span> c <span class="literal">#\c</span>) <span class="number">-1</span></span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">char=?</span></span> c <span class="literal">#\c</span>) <span class="number">0</span></span><br><span class="line">        <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>这样的结构都可以使用cond来这样写：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">cond</span></span> ((<span class="name"><span class="built_in">char&lt;?</span></span> c <span class="literal">#\c</span>) <span class="number">-1</span>)</span><br><span class="line">    ((<span class="name"><span class="built_in">char=?</span></span> c <span class="literal">#\c</span>) <span class="number">0</span>)</span><br><span class="line">    (<span class="name"><span class="built_in">else</span></span> <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>cond就是这样的一种多分支条件结构。每个从句都包含一个判断条件和一个相关的操作。第一个判断成立的从句将会引发它相关的操作执行。如果任何一个分支的条件判断都不成立则最后一个else分支将会执行(else分支语句是可选的)。</p><p>cond的分支操作都是begin结构。</p><h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>当cond结构的每个测试条件是一个测试条件的分支条件时，可以缩减为一个case表达式。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> c <span class="literal">#\c</span>)</span><br><span class="line">(<span class="name"><span class="built_in">case</span></span> c</span><br><span class="line">    ((<span class="literal">#\a</span>) <span class="number">1</span>)</span><br><span class="line">    ((<span class="literal">#\b</span>) <span class="number">2</span>)</span><br><span class="line">    ((<span class="literal">#\c</span>) <span class="number">3</span>)</span><br><span class="line">    (<span class="name"><span class="built_in">else</span></span> <span class="number">4</span>))</span><br></pre></td></tr></table></figure><p>分支头值是#\c 的分支将被执行。</p><h3 id="and-和-or"><a href="#and-和-or" class="headerlink" title="and 和 or"></a>and 和 or</h3><p>Scheme提供了对boolean值进行逻辑与and和逻辑或or运算的结构。(我们已经见过了布尔类型的求反运算not过程。)</p><p>当所有子结构的值都是真时，and的返回值是真，实际上，and的运行结果是最后一个子结构的值。如果任何一个子结构的值都是假，则返回#f。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">and </span><span class="number">1</span> <span class="number">2</span>)  =&gt;  <span class="number">2</span></span><br><span class="line">(<span class="keyword">and </span><span class="comment">#f 1) =&gt;  #f</span></span><br></pre></td></tr></table></figure><p>而or会返回它第一个为值为真的子结构的结果。如果所有的子结构的值都为假，or则返回#f。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">or </span><span class="number">1</span> <span class="number">2</span>)  =&gt;  <span class="number">1</span></span><br><span class="line">(<span class="keyword">or </span><span class="comment">#f 1) =&gt;  1</span></span><br></pre></td></tr></table></figure><p>and和or都是从左向右运算。当某个子结构可以决定最终结果时，and和or会忽略剩余的子结构，即它们是“短路”的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">and</span> <span class="number">1</span> <span class="meta">#f expression-guaranteed-to-cause-<span class="keyword">error</span>)</span></span><br><span class="line"></span><br><span class="line">(<span class="keyword">or</span> <span class="number">1</span> <span class="meta">#f expression-guaranteed-to-cause-<span class="keyword">error</span>)</span></span><br></pre></td></tr></table></figure><h2 id="词法变量"><a href="#词法变量" class="headerlink" title="词法变量"></a>词法变量</h2><p>Scheme的变量有一定的词法作用域，即它们在程序代码中只对特定范围的代码结构可见。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> x <span class="number">9</span>)</span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> add2 (<span class="name"><span class="built_in">lambda</span></span> (x) (<span class="name"><span class="built_in">+</span></span> x <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">add2</span> <span class="number">3</span>)</span><br><span class="line">(<span class="name">add2</span> x) </span><br></pre></td></tr></table></figure><p>这里有一个全局变量x，值一直为9；还有一个局部变量x，就是在过程add2中那个字母x。</p><p>而set!代码结构可修改变量的赋值。</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">set!</span></span> x <span class="number">20</span>)</span><br></pre></td></tr></table></figure><p>上面代码将全局变量x的值9修改为20，因为对于set!全局变量是可见的。如果set!是在add2过程体内被调用，那修改的就是局部变量x：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> add2</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (x)</span><br><span class="line">    (<span class="name"><span class="built_in">set!</span></span> x (<span class="name"><span class="built_in">+</span></span> x <span class="number">2</span>))</span><br><span class="line">    x))</span><br></pre></td></tr></table></figure><p>这里set!在局部变量x上加上2，并且会返回局部变量x的新值。(从结果来看，我们无法区分这个过程和先前的add2过程)。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> counter <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> bump-counter</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> ()</span><br><span class="line">    (<span class="name"><span class="built_in">set!</span></span> counter (<span class="name"><span class="built_in">+</span></span> counter <span class="number">1</span>))</span><br><span class="line">    counter))</span><br></pre></td></tr></table></figure><p>bump-counter是一个没有参数的过程(没有参数的过程也称作thunk)。 它没有引入局部变量和参数，这样就不会隐藏任何值。在每次调用时，它会修改全局变量counter的值，让它增加1，然后返回它当前的值。下面是一些bump-counter的成功调用示例:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(bump-counter) =&gt;  <span class="number">1</span><span class="function"></span></span><br><span class="line"><span class="function">(<span class="params">bump</span>-<span class="params">counter</span>) =&gt;</span>  <span class="number">2</span><span class="function"></span></span><br><span class="line"><span class="function">(<span class="params">bump</span>-<span class="params">counter</span>) =&gt;</span>  <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="let-和-let"><a href="#let-和-let" class="headerlink" title="let 和 let*"></a>let 和 let*</h3><p>并不是一定要显式的创建过程才可以创建局部变量。有个特殊的代码结构let可以创建一列局部变量以便在其结构体中使用:</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(let ((x <span class="number">1</span>)</span><br><span class="line">      (y <span class="number">2</span>)</span><br><span class="line">      (z <span class="number">3</span>))</span><br><span class="line">    (list x y z))</span><br><span class="line">=&gt;  (<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>和lambda一样，在let结构体中，局部变量x（赋值为1）会暂时隐藏全局变量x（赋值为20）。</p><p>局部变量x、y、z分别被赋值为1、2、3，这个初始化的过程并不作为let过程结构体的一部分。因此，在初始化时对x的引用都指向了全局变量x，而不是局部变量x。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(let ((x <span class="number">1</span>)</span><br><span class="line">      (y x))</span><br><span class="line">  (+ x y))</span><br><span class="line">=&gt;  <span class="number">21</span></span><br></pre></td></tr></table></figure><p>在初始化区域中，可以用先创建的变量来为后创建的变量赋值，let*结构就可以这样做：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(let* ((x <span class="number">1</span>)</span><br><span class="line">       (y x))</span><br><span class="line">  (+ x y))</span><br><span class="line">=&gt;  <span class="number">2</span></span><br></pre></td></tr></table></figure><p>这个例子完全等价于下面这个let嵌套的程序，更深了说，实际上就是let嵌套的缩写。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(let ((x <span class="number">1</span>))</span><br><span class="line">  (let ((y x))</span><br><span class="line">    (+ x y)))</span><br><span class="line">=&gt;  <span class="number">2</span></span><br></pre></td></tr></table></figure><p>我们也可以把一个过程做为值赋给变量：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(let ((cons (lambda (x y) (+ x y))))</span><br><span class="line">  (cons <span class="number">1</span> <span class="number">2</span>))</span><br><span class="line">=&gt;  <span class="number">3</span></span><br></pre></td></tr></table></figure><p>在这个let构结体中，变量cons将它的参数进行相加。而在let结构的外面，cons还是用来创建点对。</p><h3 id="fluid-let"><a href="#fluid-let" class="headerlink" title="fluid-let"></a>fluid-let</h3><p>一个词法变量如果没有被隐藏，在它的作用域内一直都为可见状态。有时候，我们有必要将一个词法变量临时的设置为一个固定的值，为此我们可使用fluid-let结构。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">fluid-let</span> ((<span class="name">counter</span> <span class="number">99</span>))</span><br><span class="line">  (<span class="name"><span class="built_in">display</span></span> (<span class="name">bump-counter</span>)) (<span class="name"><span class="built_in">newline</span></span>)</span><br><span class="line">  (<span class="name"><span class="built_in">display</span></span> (<span class="name">bump-counter</span>)) (<span class="name"><span class="built_in">newline</span></span>)</span><br><span class="line">  (<span class="name"><span class="built_in">display</span></span> (<span class="name">bump-counter</span>)) (<span class="name"><span class="built_in">newline</span></span>))</span><br></pre></td></tr></table></figure><p>这和let看起来非常相像，但并不是暂时的隐藏了全局变量counter的值，而是在fluid-let执行体中临时的将全局变量counter的值设置为了99直到执行体结束。因此执行体中的三句display产生了结果</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">100 </span></span><br><span class="line"><span class="symbol">101 </span></span><br><span class="line"><span class="symbol">102 </span></span><br></pre></td></tr></table></figure><p>当fluid-let表达式计算结束后，全局变量counter会恢复成之前的的值。</p><p>注意fluid-let和let的效果完全不同。fluid-let不会和let一样产生一个新的变量。它会修改已经存的变量的值绑定，当fluid-let结束时这个修改也会结束。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>一个过程体中可以包含对其它过程的调用，特别的是也可以调用自己。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> factorial</span><br><span class="line"> (<span class="name"><span class="built_in">lambda</span></span> (n)</span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>) <span class="number">1</span></span><br><span class="line">        (<span class="name"><span class="built_in">*</span></span> n (<span class="name">factorial</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>))))))</span><br></pre></td></tr></table></figure><p>这个递归过程用来计算一个数的阶乘。如果这个数是0，则结果为1。对于任何其它的值n，这个过程会调用其自身来完成n-1阶乘的计算，然后将这个子结果乘上n并返回最终产生的结果。</p><p>互递归过程也是可以的。下面判断奇偶数的过程相互进行了调用。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> is-even?</span><br><span class="line"> (<span class="name"><span class="built_in">lambda</span></span> (n)</span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>) <span class="literal">#t</span></span><br><span class="line">        (<span class="name">is-odd?</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">define</span></span> is-odd?</span><br><span class="line"> (<span class="name"><span class="built_in">lambda</span></span> (n)</span><br><span class="line">    (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>) <span class="literal">#f</span></span><br><span class="line">        (<span class="name">is-even?</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure><p>这里提供的两个过程的定义仅作为简单的互递归示例。Scheme已经提供了简单的判断过程even?和odd?。</p><h3 id="letrec"><a href="#letrec" class="headerlink" title="letrec"></a>letrec</h3><p>如果希望将上面的过程定义为局部的，我们需要使用letrec结构。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">letrec</span></span> ((<span class="name">local-even?</span> (<span class="name"><span class="built_in">lambda</span></span> (n)</span><br><span class="line">                        (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>) <span class="literal">#t</span></span><br><span class="line">                            (<span class="name">local-odd?</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>)))))</span><br><span class="line">         (<span class="name">local-odd?</span> (<span class="name"><span class="built_in">lambda</span></span> (n)</span><br><span class="line">                       (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> n <span class="number">0</span>) <span class="literal">#f</span></span><br><span class="line">                           (<span class="name">local-even?</span> (<span class="name"><span class="built_in">-</span></span> n <span class="number">1</span>))))))</span><br><span class="line"> (<span class="name"><span class="built_in">list</span></span> (<span class="name">local-even?</span> <span class="number">23</span>) (<span class="name">local-odd?</span> <span class="number">23</span>)))</span><br></pre></td></tr></table></figure><p>用letrec创建的词法变量不仅可以在letrec执行体中可见而且在初始化中也可见。letrec是专门为局部的递归和互递归过程而设置的。(这里也可以使用define来创建两个子结构的方式来实现局部递归)</p><h3 id="命名let"><a href="#命名let" class="headerlink" title="命名let"></a>命名let</h3><p>使用letrec定义递归过程可以实现循环。如果我们想显示10到1的降数列，可以这样写：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">letrec</span></span> ((<span class="name">countdown</span> (<span class="name"><span class="built_in">lambda</span></span> (i)</span><br><span class="line">                      (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> i <span class="number">0</span>) <span class="symbol">&#x27;liftoff</span></span><br><span class="line">                          (<span class="name"><span class="built_in">begin</span></span></span><br><span class="line">                            (<span class="name"><span class="built_in">display</span></span> i)</span><br><span class="line">                            (<span class="name"><span class="built_in">newline</span></span>)</span><br><span class="line">                            (<span class="name">countdown</span> (<span class="name"><span class="built_in">-</span></span> i <span class="number">1</span>)))))))</span><br><span class="line"> (<span class="name">countdown</span> <span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>这会在控制台上输出10到1，并会返回结果liftoff。</p><p>Scheme允许使用一种叫“命名let”的let变体来更简洁的写出这样的循环:</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">let</span></span> countdown ((<span class="name">i</span> <span class="number">10</span>))</span><br><span class="line"> (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">=</span></span> i <span class="number">0</span>) <span class="symbol">&#x27;liftoff</span></span><br><span class="line">      (<span class="name"><span class="built_in">begin</span></span></span><br><span class="line">        (<span class="name"><span class="built_in">display</span></span> i)</span><br><span class="line">        (<span class="name"><span class="built_in">newline</span></span>)</span><br><span class="line">        (<span class="name">countdown</span> (<span class="name"><span class="built_in">-</span></span> i <span class="number">1</span>)))))</span><br></pre></td></tr></table></figure><p>注意在let的后面立即声明了一个变量用来表示这个循环。这个程序和先前用letrec写的程序是等价的，可以将“命名let”看成一个对letrec结构进行扩展的宏。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3><p>上面定义的countdown函数事实上是一个递归的过程。Scheme只有通过递归才能定义循环，不存在特殊的循环或迭代结构。</p><p>尽管如此，上述定义的循环是一个“真”循环，与其他语言实现它们的循环的方法完全相同。也就是说，Scheme十分注意确保上面使用过的递归类型不会产生过程调用/返回开销。</p><p>Scheme通过一种消除尾部调用（tail-call elimination）的过程完成这个功能。如果你注意观察countdown的步骤，你会注意到当递归调用出现在countdown主体内时，就变成了“尾部调用”，或者说是最后完成的事情——countdown的每次调用要么不调用它自身，要么当它调用自身时把这个动作留在最后。对于一个Scheme语言的实现来说（解释器），这会使递归不同于迭代。因此，尽管用递归去写循环吧，这是安全的。</p><p>这是又一个有用的尾递归程序的例子：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> list-position</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (o l)</span><br><span class="line">    (<span class="name"><span class="built_in">let</span></span> loop ((<span class="name">i</span> <span class="number">0</span>) (<span class="name">l</span> l))</span><br><span class="line">      (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> l) <span class="literal">#f</span></span><br><span class="line">          (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">eqv?</span></span> (<span class="name"><span class="built_in">car</span></span> l) o) i</span><br><span class="line">              (<span class="name">loop</span> (<span class="name"><span class="built_in">+</span></span> i <span class="number">1</span>) (<span class="name"><span class="built_in">cdr</span></span> l)))))))</span><br></pre></td></tr></table></figure><p>list-position发现了o对象在列表l中第一次出现的索引。如果在列表中没有发现对象，过程将会返回#f。</p><p>这又是一个尾部递归过程，它将自身的参数列表就地反转，也就是使现有的列表内容产生变异，而没有分配一个新的列表：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> reverse!</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (s)</span><br><span class="line">    (<span class="name"><span class="built_in">let</span></span> loop ((<span class="name">s</span> s) (<span class="name">r</span> &#x27;()))</span><br><span class="line">      (<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">null?</span></span> s) r</span><br><span class="line">      (<span class="name"><span class="built_in">let</span></span> ((<span class="name">d</span> (<span class="name"><span class="built_in">cdr</span></span> s)))</span><br><span class="line">            (<span class="name"><span class="built_in">set-cdr!</span></span> s r)</span><br><span class="line">        (<span class="name">loop</span> d s))))))</span><br></pre></td></tr></table></figure><p>reverse!是一个十分有用的过程，它在很多Scheme方言中都能使用。</p><h3 id="用自定义过程映射整个列表"><a href="#用自定义过程映射整个列表" class="headerlink" title="用自定义过程映射整个列表"></a>用自定义过程映射整个列表</h3><p>有一种特殊类型的迭代，对列表中每个元素，它都会重复相同的动作。Scheme为这种情况提供了两种程序：map和for-each。</p><p>map程序为给定列表中的每个元素提供了一种既定程序，并返回一个结果的列表。例如：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(map add2 &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>))</span><br><span class="line">=&gt;  (<span class="number">3</span> <span class="number">4</span> <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>for-each程序也为列表中的每个元素提供了一个程序，但返回值为空。</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">for-each</span></span> display</span><br><span class="line">  (<span class="name"><span class="built_in">list</span></span> <span class="string">&quot;one &quot;</span> <span class="string">&quot;two &quot;</span> <span class="string">&quot;buckle my shoe&quot;</span>))</span><br></pre></td></tr></table></figure><p>这个由map和for-each用在列表上的程序并不一定是单参数程序。举例来说，假设一个n参数的程序，map会接受n个列表，每个列表都是由一个参数所组成的集合，而map会从每个列表中取相应元素提供给程序。例如：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(map cons &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) &#x27;(<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>))</span><br><span class="line">=&gt;  ((<span class="number">1</span> . <span class="number">10</span>) (<span class="number">2</span> . <span class="number">20</span>) (<span class="number">3</span> . <span class="number">30</span>))</span><br><span class="line"></span><br><span class="line">(map + &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>) &#x27;(<span class="number">10</span> <span class="number">20</span> <span class="number">30</span>))</span><br><span class="line">=&gt;  (<span class="number">11</span> <span class="number">22</span> <span class="number">33</span>)</span><br></pre></td></tr></table></figure><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>Scheme的输入/输出程序，可以从输入端口读取或者写入到输出端口。端口可以关联到控制台，文件和字符串。</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>Scheme的读取程序带有一个可选的输入端口参数。如果端口没有特别指定，则默认为当前端口（一般是控制台）。</p><p>读取的内容可以是一个字符，一行数据或是S表达式。当每次执行读取时，端口的状态就会改变，因此下一次就会读取当前已读取内容后面的内容。如果没有更多的内容可读，读取程序将返回一个特殊的数据（文件结束符或EOF对象），这个对象只能用eof-object?函数来判断。</p><p>read-char程序会从端口读取下一个字符。read-line程序会读取下一行数据，并返回一个字符串（不包括最后的换行符），read程序则会读取下一个S表达式。</p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>Scheme的写入程序接受一个要被写入的对象和一个可选的输出端口参数。如果未指定端口，则默认为当前端口（一般为控制台）。</p><p>写入的对象可以是字符或是S表达式。</p><p>write-char程序可以向输出端口写入一个给定的字符（不包括#\）。<br>write和display程序都可以向端口写入一个给定的S表达式，唯一的区别是：write程序会使用机器可读型的格式而display程序却不用。例如，write用双引号表示字符串，用#\句法表示字符，但display却不这么做。</p><p>newline程序会在输出端口输出一个换行符。</p><h3 id="文件端口"><a href="#文件端口" class="headerlink" title="文件端口"></a>文件端口</h3><p>如果端口是标准的输入和输出端口，Scheme的I/O程序就不需要端口参数。但是，如果你明确需要这些端口，则current-input-port和current-output-port这些零参数程序会提供这个功能，例如：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">display</span></span> <span class="number">9</span>)</span><br><span class="line">(<span class="name"><span class="built_in">display</span></span> <span class="number">9</span> (<span class="name"><span class="built_in">current-output-port</span></span>))</span><br></pre></td></tr></table></figure><p>拥有相同的效果。</p><p>一个端口通过打开文件和这个文件关联在一起。open-input-file程序会接受一个文件名作为参数，并返回一个和这个文件关联的新的输入端口。open-output-file程序会接受一个文件名作为参数，并返回一个和这个文件关联的新的输出端口。如果打开一个不存在的输入文件，或者打开一个已经存在的输出文件，程序都会出错。</p><p>已经在一个端口执行完输入或输出后，需要使用close-input-port或close-output-port程序将它关闭。</p><p>在下述例子中，假如文件io.txt文件只包含一个单词hello。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(define i (<span class="keyword">open</span>-<span class="keyword">input</span>-<span class="keyword">file</span> <span class="string">&quot;io.txt&quot;</span>))</span><br><span class="line"></span><br><span class="line">(<span class="keyword">read</span>-<span class="keyword">char</span> i)</span><br><span class="line"></span><br><span class="line">(define j (<span class="keyword">read</span> i))</span><br><span class="line"></span><br><span class="line">j</span><br></pre></td></tr></table></figure><p>假如文件greeting.txt在下述程序运行前不存在：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> o (<span class="name"><span class="built_in">open-output-file</span></span> <span class="string">&quot;greeting.txt&quot;</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;hello&quot;</span> o)</span><br><span class="line">(<span class="name"><span class="built_in">write-char</span></span> <span class="literal">#\space</span> o)</span><br><span class="line">(<span class="name"><span class="built_in">display</span></span> <span class="symbol">&#x27;world</span> o)</span><br><span class="line">(<span class="name"><span class="built_in">newline</span></span> o)</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">close-output-port</span></span> o)</span><br></pre></td></tr></table></figure><p>现在greeting.txt文件将会包含“hello world”。</p><p><strong>文件端口的自动打开和关闭</strong></p><p>Scheme提供了call-with-input-file和call-with-output-file过程，这些过程会照顾好打开的端口并在你使用完后将端口关闭。</p><p>call-with-input-file程序接受一个文件名参数和一个过程。这个过程被应用在一个已打开的文件输入端口。当程序结束时，它的结果会在保证端口关闭后返回。</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">call</span>-with-input-file <span class="string">&quot;io.txt&quot;</span></span><br><span class="line">  (lambda (i)</span><br><span class="line">    (let* ((a (read-<span class="built_in">char</span> i))</span><br><span class="line">           (b (read-<span class="built_in">char</span> i))</span><br><span class="line">           (c (read-<span class="built_in">char</span> i)))</span><br><span class="line">      (list a b c))))</span><br><span class="line">=&gt;  (#\h #\e #\l)</span><br></pre></td></tr></table></figure><p>call-with-output-file程序会对输出文件提供类似的服务。</p><h3 id="字符串端口"><a href="#字符串端口" class="headerlink" title="字符串端口"></a>字符串端口</h3><p>一般来说将字符串与端口相关联是很方便的。因此，open-input-string程序将一个给定的字符串和一个端口关联起来。读取这个端口的程序将读出下述字符串：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(define i (open-input-string <span class="string">&quot;hello world&quot;</span>))</span><br><span class="line"></span><br><span class="line">(read-<span class="built_in">char</span> i)</span><br><span class="line">=&gt;  #\h</span><br><span class="line"></span><br><span class="line">(read i)</span><br><span class="line">=&gt;  ello</span><br><span class="line"></span><br><span class="line">(read i)</span><br><span class="line">=&gt;  world</span><br></pre></td></tr></table></figure><p>open-output-string创建了一个输出端口，最终可以用于创建一个字符串：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> o (<span class="name">open-output-string</span>))</span><br><span class="line"></span><br><span class="line">(<span class="name"><span class="built_in">write</span></span> <span class="symbol">&#x27;hello</span> o)</span><br><span class="line">(<span class="name"><span class="built_in">write-char</span></span> <span class="literal">#\,</span> o)</span><br><span class="line">(<span class="name"><span class="built_in">display</span></span> <span class="string">&quot; &quot;</span> o)</span><br><span class="line">(<span class="name"><span class="built_in">display</span></span> <span class="string">&quot;world&quot;</span> o)</span><br></pre></td></tr></table></figure><p>现在你可以使用get-output-string程序得到保留在字符串端口o中的字符串：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">get-output-string</span> <span class="string">o</span>)</span><br><span class="line">=&gt;  <span class="string">&quot;hello, world&quot;</span></span><br></pre></td></tr></table></figure><p>字符串端口不需要显式地去关闭。</p><h3 id="加载文件"><a href="#加载文件" class="headerlink" title="加载文件"></a>加载文件</h3><p>load程序可以加载包含Scheme代码的文件，load一个文件意味着按顺序求值文件中每一个Scheme表达式。load中的路径参数是相对当前Scheme工作目录计算的，该工作目录一般是调用Scheme可执行文件时的目录。</p><p>一个文件可以加载其他的文件，这在包含许多文件的大项目中十分有用。但是，除非使用绝对路径，否则load参数中的文件位置将依赖于执行Scheme的当前目录。而提供绝对路径名并不是很方便，因为我们更愿意把项目文件作为一个单元（保留它们的相对路径名）在很多不同机器中运行。</p><h2 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h2><p>在Scheme中，对宏的处理与C语言类似，也分为两步：第一步是宏展开，第二步则是编译展开之后的代码。这样，通过宏和基本的语言构造，可以对Scheme语言进行扩展——C语言的宏则不具备扩展语言的能力。</p><p>宏通过define-macro来定义。例如，如果你的Scheme缺少条件表达式when，你就可以以下述宏定义when：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-macro</span> when</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (test . branch)</span><br><span class="line">    (<span class="name"><span class="built_in">list</span></span> <span class="symbol">&#x27;if</span> test</span><br><span class="line">      (<span class="name"><span class="built_in">cons</span></span> <span class="symbol">&#x27;begin</span> branch))))</span><br></pre></td></tr></table></figure><p>这样定义的when转换器能够把一个when表达式转换为等价的if表达式。</p><figure class="highlight hy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">when</span></span> (<span class="name"><span class="built_in">&lt;</span></span> (<span class="name">pressure</span> tube) <span class="number">60</span>)</span><br><span class="line">   (<span class="name">open-valve</span> tube)</span><br><span class="line">   (<span class="name">attach</span> floor-pump tube)</span><br><span class="line">   (<span class="name">depress</span> floor-pump <span class="number">5</span>)</span><br><span class="line">   (<span class="name">detach</span> floor-pump tube)</span><br><span class="line">   (<span class="name">close-valve</span> tube))</span><br></pre></td></tr></table></figure><p>上面的when表达式，在宏展开后为：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">apply</span></span></span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (test . branch)</span><br><span class="line">    (<span class="name"><span class="built_in">list</span></span> <span class="symbol">&#x27;if</span> test</span><br><span class="line">      (<span class="name"><span class="built_in">cons</span></span> <span class="symbol">&#x27;begin</span> branch)))</span><br><span class="line">  &#x27;((&lt; (pressure tube) <span class="number">60</span>)</span><br><span class="line">      (open-valve tube)</span><br><span class="line">      (attach floor-pump tube)</span><br><span class="line">      (depress floor-pump <span class="number">5</span>)</span><br><span class="line">      (detach floor-pump tube)</span><br><span class="line">      (close-valve tube)))</span><br></pre></td></tr></table></figure><p>这个转换产生了一个列表：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">if</span></span> (<span class="name"><span class="built_in">&lt;</span></span> (<span class="name">pressure</span> tube) <span class="number">60</span>)</span><br><span class="line">    (<span class="name"><span class="built_in">begin</span></span></span><br><span class="line">      (<span class="name">open-valve</span> tube)</span><br><span class="line">      (<span class="name">attach</span> floor-pump tube)</span><br><span class="line">      (<span class="name">depress</span> floor-pump <span class="number">5</span>)</span><br><span class="line">      (<span class="name">detach</span> floor-pump tube)</span><br><span class="line">      (<span class="name">close-valve</span> tube)))</span><br></pre></td></tr></table></figure><p>Scheme将会对这个表达式进行求值，就像它对其他表达式所做的一样。</p><p>再来看unless的宏定义：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-macro</span> unless</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (test . branch)</span><br><span class="line">    (<span class="name"><span class="built_in">list</span></span> <span class="symbol">&#x27;if</span></span><br><span class="line">          (<span class="name"><span class="built_in">list</span></span> <span class="symbol">&#x27;not</span> test)</span><br><span class="line">          (<span class="name"><span class="built_in">cons</span></span> <span class="symbol">&#x27;begin</span> branch)))) </span><br></pre></td></tr></table></figure><p>另外，我们可以调用when放进unless定义中：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">define-macro</span> unless</span><br><span class="line">  (<span class="name"><span class="built_in">lambda</span></span> (test . branch)</span><br><span class="line">    (<span class="name"><span class="built_in">cons</span></span> <span class="symbol">&#x27;when</span></span><br><span class="line">          (<span class="name"><span class="built_in">cons</span></span> (<span class="name"><span class="built_in">list</span></span> <span class="symbol">&#x27;not</span> test) branch))))</span><br></pre></td></tr></table></figure><p>宏表达式可以引用其他的宏。</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>我们可以使用Scheme提供的复合数据结构（如向量和列表），来表示一种“结构”。例如：我们正在处理与树木相关的一组数据。数据中的元素包括：高度，周长，年龄，树叶形状和树叶颜色共5个字段。这样的数据可以表示为5元向量，这些字段可以利用vector-ref访问，或使用vector-set!修改。</p><p>我们使用Scheme的宏defstruct去定义一个结构，基本上你可以把它当作一种向量，不过它提供了很多方法诸如创建结构实例、访问或修改它的字段等等。因此，我们的树结构应这样定义：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">defstruct</span> tree <span class="built_in">height</span> <span class="built_in">girth</span> age leaf-shape leaf-<span class="built_in">color</span>)</span><br></pre></td></tr></table></figure><p>这样它自动生成了一个名为make-tree的构造过程，以及每个字段的访问方法，命名为tree.height，tree.girth等等。构造方法的使用方法如下：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name"><span class="built_in">define</span></span> coconut </span><br><span class="line">  (<span class="name">make-tree</span> <span class="symbol">&#x27;height</span> <span class="number">30</span></span><br><span class="line">             <span class="symbol">&#x27;leaf-shape</span> <span class="symbol">&#x27;frond</span></span><br><span class="line">             <span class="symbol">&#x27;age</span> <span class="number">5</span>))</span><br></pre></td></tr></table></figure><p>这个构造函数的参数以成对的形式出现，字段名后面紧跟着其初始值。这些字段能以任意顺序出现，或者不出现——如果字段的值没有定义的话。</p><p>访问过程的调用如下所示：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(tree.height coconut) =&gt;  <span class="number">30</span><span class="function"></span></span><br><span class="line"><span class="function">(<span class="params">tree</span>.<span class="params">leaf</span>-<span class="params">shape</span> <span class="params">coconut</span>) =&gt;</span>  frond<span class="function"></span></span><br><span class="line"><span class="function">(<span class="params">tree</span>.<span class="params">girth</span> <span class="params">coconut</span>) =&gt;</span>  &lt;undefined&gt;</span><br></pre></td></tr></table></figure><p>tree.girth存取程序返回一个未定义的值，因为我们没有为coconut这个tree结构指定girth的值。</p><p>修改过程的调用如下所示：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">set</span>!<span class="built_in">tree</span>.height coconut <span class="number">40</span>)</span><br><span class="line">(<span class="built_in">set</span>!<span class="built_in">tree</span>.girth coconut <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>如果我们现在重新调用访问过程去访问这些字段，我们会得到新的值：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(tree.height coconut) =&gt;  <span class="number">40</span><span class="function"></span></span><br><span class="line"><span class="function">(<span class="params">tree</span>.<span class="params">girth</span> <span class="params">coconut</span>) =&gt;</span>  <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>我们可以在定义结构时进行一些初始化的设置，而不是在每个实例中都进行初始化。因此，我们假定leaf-shape和leaf-color在默认情况下分别为frond和green。我们可以在调用make-tree时通过显式的初始化来覆盖掉这些默认值，或者在创建一个结构实例后使用上面提到的字段修改过程：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(defstruct tree height girth age</span><br><span class="line">                (leaf-shape &#x27;frond)</span><br><span class="line">                (leaf-color &#x27;green))</span><br><span class="line"></span><br><span class="line">(define palm (make-tree &#x27;height <span class="number">60</span>))</span><br><span class="line"></span><br><span class="line">(tree.height palm) </span><br><span class="line">=&gt;  <span class="number">60</span></span><br><span class="line"></span><br><span class="line">(tree.leaf-shape palm) </span><br><span class="line">=&gt;  frond</span><br><span class="line"></span><br><span class="line">(define plantain </span><br><span class="line">  (make-tree &#x27;height <span class="number">7</span></span><br><span class="line">             &#x27;leaf-shape &#x27;<span class="built_in">sheet</span>))</span><br><span class="line"></span><br><span class="line">(tree.height plantain) </span><br><span class="line">=&gt;  <span class="number">7</span></span><br><span class="line"></span><br><span class="line">(tree.leaf-shape plantain) </span><br><span class="line">=&gt;  <span class="built_in">sheet</span></span><br><span class="line"></span><br><span class="line">(tree.leaf-color plantain) </span><br><span class="line">=&gt;  green</span><br></pre></td></tr></table></figure><h2 id="关联表"><a href="#关联表" class="headerlink" title="关联表"></a>关联表</h2><p>关联表是Scheme一种特殊形式的列表。列表的每一个元素都是一个点对，其中的car（左边的元素）被称为键，cdr（右边的元素）被称为和该键关联的值。例如：</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="name">a</span> . <span class="number">1</span>) (<span class="name">b</span> . <span class="number">2</span>) (<span class="name">c</span> . <span class="number">3</span>))</span><br></pre></td></tr></table></figure><h2 id="系统接口"><a href="#系统接口" class="headerlink" title="系统接口"></a>系统接口</h2><p>Scheme程序经常需要与底层操作系统进行交互。</p><h3 id="检查和删除文件"><a href="#检查和删除文件" class="headerlink" title="检查和删除文件"></a>检查和删除文件</h3><p>file-exists?会检查它的参数字符串是否是一个文件。delete-file接受一个文件名字符串作为参数并删除相应的文件。这些程序并不是Scheme标准的一部分，但是在大多数Scheme实现中都能找到它们。用这些过程操作目录（而不是文件）并不是很可靠，操作结果与具体的Scheme实现有关。</p><p>file-or-directory-modify-seconds过程接受一个文件名或目录名为参数，并返回这个目录或文件的最后修改时间。时间是从格林威治标准时间1970年1月1日0点开始记时的。例如：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(file-<span class="built_in">or</span>-directory-modify-seconds <span class="string">&quot;hello.scm&quot;</span>)</span><br><span class="line">=&gt;  <span class="number">893189629</span></span><br></pre></td></tr></table></figure><p>假定hello.scm文件最后一次修改的时间是1998年4月21日的某个时间。</p><h3 id="调用操作系统命令"><a href="#调用操作系统命令" class="headerlink" title="调用操作系统命令"></a>调用操作系统命令</h3><p>system函数把它的参数字符串当作操作系统命令来执行。如果命令成功执行并返回0，则它会返回真，如果命令执行失败并返回某非0值，则它会返回假。命令产生的任何输出都会进入标准的输出。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">system</span> <span class="string">&quot;ls&quot;</span>)</span><br><span class="line">;lists current <span class="built_in">directory</span></span><br><span class="line"></span><br><span class="line">(<span class="built_in">define</span> fname <span class="string">&quot;spot&quot;</span>)</span><br><span class="line"></span><br><span class="line">(<span class="built_in">system</span> (<span class="built_in">string</span>-<span class="built_in">append</span> <span class="string">&quot;test -f &quot;</span> fname)) </span><br><span class="line">;tests <span class="keyword">if</span> file `spot&#x27; exists</span><br><span class="line"></span><br><span class="line">(<span class="built_in">system</span> (<span class="built_in">string</span>-<span class="built_in">append</span> <span class="string">&quot;rm -f &quot;</span> fname)) </span><br><span class="line">;removes `spot&#x27;</span><br></pre></td></tr></table></figure><p>最后两个命令等价于：</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">file-exists</span>? <span class="string">fname</span>)</span><br><span class="line"></span><br><span class="line">(<span class="built_in">delete-file</span> <span class="string">fname</span>)</span><br></pre></td></tr></table></figure><h3 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h3><p>过程getenv返回操作系统环境变量的设定值，如：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(getenv <span class="string">&quot;HOME&quot;</span>)</span><br><span class="line">=&gt;  <span class="string">&quot;/home/dorai&quot;</span></span><br><span class="line"></span><br><span class="line">(getenv <span class="string">&quot;SHELL&quot;</span>)</span><br><span class="line">=&gt;  <span class="string">&quot;/bin/bash&quot;</span></span><br></pre></td></tr></table></figure><h2 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h2><p><a target="_blank" rel="noopener" href="http://www.kancloud.cn/wizardforcel/teach-yourself-scheme/147175">http://www.kancloud.cn/wizardforcel/teach-yourself-scheme/147175</a></p><h1 id="源码分享"><a href="#源码分享" class="headerlink" title="源码分享"></a>源码分享</h1><p><a target="_blank" rel="noopener" href="https://github.com/voidking/scheme-start.git">https://github.com/voidking/scheme-start.git</a></p><h1 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h1><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html">函数式编程初探</a></p><p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/02/fp-tutorial.html">函数式编程入门教程</a></p><p><a target="_blank" rel="noopener" href="http://www.yiibai.com/lisp/">Lisp教程</a></p><p><a target="_blank" rel="noopener" href="http://www.kancloud.cn/wizardforcel/teach-yourself-scheme/147161">Scheme语言简明教程</a></p><p><a target="_blank" rel="noopener" href="http://www.math.pku.edu.cn/teachers/qiuzy/progtech/scheme/MIT_Scheme_doc/index.html">MIT/GNU Scheme Documentation</a></p><p><a target="_blank" rel="noopener" href="http://racket-lang.org/">Racket官网</a></p><p><a target="_blank" rel="noopener" href="http://mp.weixin.qq.com/s/EeP9lggM5GKNF-UmvkTEqA">符号: 抽象、语义</a></p><p><a target="_blank" rel="noopener" href="http://liujiacai.net/blog/lambda-calculus-introduction/">编程语言的基石——Lambda calculus</a></p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 好好学习的郝</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.voidking.com/dev-scheme-start/" title="函数式编程之Scheme入门">https://www.voidking.com/dev-scheme-start/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！源站会及时更新知识点及修正错误，阅读体验也更好。欢迎分享，欢迎收藏~</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/" rel="tag"># 函数式编程</a> <a href="/tags/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E5%AD%A6/" rel="tag"># 形式语义学</a> <a href="/tags/lisp/" rel="tag"># lisp</a> <a href="/tags/scheme/" rel="tag"># scheme</a></div><div class="post-nav"><div class="post-nav-item"><a href="/dev-matlab-ga-tsp/" rel="prev" title="遗传算法解决TSP问题"><i class="fa fa-chevron-left"></i> 遗传算法解决TSP问题</a></div><div class="post-nav-item"> <a href="/dev-computer-network/" rel="next" title="计算机网络摘要（杨鲲教授）">计算机网络摘要（杨鲲教授）<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODU3Mi8xNTEwMA=="></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%89%E8%A3%85mit-scheme"><span class="nav-number">2.</span> <span class="nav-text">安装mit-scheme</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#hello-world"><span class="nav-number">3.</span> <span class="nav-text">hello world</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80"><span class="nav-number">3.1.</span> <span class="nav-text">方法一</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C"><span class="nav-number">3.2.</span> <span class="nav-text">方法二</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">4.</span> <span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">4.1.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="nav-number">4.2.</span> <span class="nav-text">代码结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.</span> <span class="nav-text">过程（函数）定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8C%BF%E5%90%8D%E8%BF%87%E7%A8%8B"><span class="nav-number">4.3.1.</span> <span class="nav-text">匿名过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E8%88%AC%E5%AE%9A%E4%B9%89"><span class="nav-number">4.3.2.</span> <span class="nav-text">一般定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8F%82%E6%95%B0"><span class="nav-number">4.3.3.</span> <span class="nav-text">过程的参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#apply%E8%BF%87%E7%A8%8B"><span class="nav-number">4.4.</span> <span class="nav-text">apply过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="nav-number">4.5.</span> <span class="nav-text">顺序执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="nav-number">4.6.</span> <span class="nav-text">条件语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#if"><span class="nav-number">4.6.1.</span> <span class="nav-text">if</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#when-%E5%92%8C-unless"><span class="nav-number">4.6.2.</span> <span class="nav-text">when 和 unless</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#cond"><span class="nav-number">4.6.3.</span> <span class="nav-text">cond</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#case"><span class="nav-number">4.6.4.</span> <span class="nav-text">case</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#and-%E5%92%8C-or"><span class="nav-number">4.6.5.</span> <span class="nav-text">and 和 or</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%8D%E6%B3%95%E5%8F%98%E9%87%8F"><span class="nav-number">4.7.</span> <span class="nav-text">词法变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#let-%E5%92%8C-let"><span class="nav-number">4.7.1.</span> <span class="nav-text">let 和 let*</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fluid-let"><span class="nav-number">4.7.2.</span> <span class="nav-text">fluid-let</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92"><span class="nav-number">4.8.</span> <span class="nav-text">递归</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#letrec"><span class="nav-number">4.8.1.</span> <span class="nav-text">letrec</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%91%BD%E5%90%8Dlet"><span class="nav-number">4.8.2.</span> <span class="nav-text">命名let</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3"><span class="nav-number">4.8.3.</span> <span class="nav-text">迭代</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E8%BF%87%E7%A8%8B%E6%98%A0%E5%B0%84%E6%95%B4%E4%B8%AA%E5%88%97%E8%A1%A8"><span class="nav-number">4.8.4.</span> <span class="nav-text">用自定义过程映射整个列表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="nav-number">4.9.</span> <span class="nav-text">输入输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%BB%E5%8F%96"><span class="nav-number">4.9.1.</span> <span class="nav-text">读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%99%E5%85%A5"><span class="nav-number">4.9.2.</span> <span class="nav-text">写入</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%AB%AF%E5%8F%A3"><span class="nav-number">4.9.3.</span> <span class="nav-text">文件端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AB%AF%E5%8F%A3"><span class="nav-number">4.9.4.</span> <span class="nav-text">字符串端口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6"><span class="nav-number">4.9.5.</span> <span class="nav-text">加载文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%8F"><span class="nav-number">4.10.</span> <span class="nav-text">宏</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">4.11.</span> <span class="nav-text">结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.11.1.</span> <span class="nav-text">默认初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E8%81%94%E8%A1%A8"><span class="nav-number">4.12.</span> <span class="nav-text">关联表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3"><span class="nav-number">4.13.</span> <span class="nav-text">系统接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A3%80%E6%9F%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="nav-number">4.13.1.</span> <span class="nav-text">检查和删除文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4"><span class="nav-number">4.13.2.</span> <span class="nav-text">调用操作系统命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="nav-number">4.13.3.</span> <span class="nav-text">环境变量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB"><span class="nav-number">4.14.</span> <span class="nav-text">对象和类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E4%BA%AB"><span class="nav-number">5.</span> <span class="nav-text">源码分享</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%A6%E7%AD%BE"><span class="nav-number">6.</span> <span class="nav-text">书签</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="好好学习的郝" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">好好学习的郝</p><div class="site-description" itemprop="description">学而不思则罔，思而不学则殆！</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">627</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">29</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">232</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:voidking@qq.com" title="E-Mail → mailto:voidking@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://github.com/voidking" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/voidking" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/voidking" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i> Zhihu</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 – <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">好好学习的郝</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="footer-beian"> <a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备14021030号</a>&nbsp;|&nbsp; <img src="/images/beian.png" alt=""> <a target="_blank" href="http://www.beian.gov.cn/">苏公网安备 32032202000223号</a></div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={iconStyle:"box",boxForm:"horizontal",position:"bottomCenter",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={iconStyle:"box",boxForm:"horizontal",position:"topRight",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-float",flOptions)</script><script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  // window.livereOptions = {
  //   refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  // };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>