<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://www.voidking.com").hostname,root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1,cdn:{enable:!0,url:"//qiniu-cdn.voidking.com/doc/search.xml"}},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="前言OpenStack中共享存储和非共享存储的虚拟机迁移环境都已经搭建完成，接下来可以进行实验了。对于不同的宿主机、不同的实例、不同的负载，虚拟机迁移的性能也会有所不同。那么，虚拟机迁移的性能指标有哪些？又该怎样统计呢？本文就来研究一下。"><meta property="og:type" content="article"><meta property="og:title" content="好好学OpenStack：虚拟机在线迁移的性能统计"><meta property="og:url" content="https://www.voidking.com/dev-openstack-vm-live-migration-performance/index.html"><meta property="og:site_name" content="好好学习的郝"><meta property="og:description" content="前言OpenStack中共享存储和非共享存储的虚拟机迁移环境都已经搭建完成，接下来可以进行实验了。对于不同的宿主机、不同的实例、不同的负载，虚拟机迁移的性能也会有所不同。那么，虚拟机迁移的性能指标有哪些？又该怎样统计呢？本文就来研究一下。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.voidking.com/img/openstack-vm-live-migration-performance/set.jpg?imageView2/0/h/800"><meta property="article:published_time" content="2018-11-18T09:30:00.000Z"><meta property="article:modified_time" content="2018-11-18T09:30:00.000Z"><meta property="article:author" content="好好学习的郝"><meta property="article:tag" content="linux"><meta property="article:tag" content="docker"><meta property="article:tag" content="ubuntu"><meta property="article:tag" content="openstack"><meta property="article:tag" content="测试"><meta property="article:tag" content="好好学OpenStack"><meta property="article:tag" content="iperf"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://cdn.voidking.com/img/openstack-vm-live-migration-performance/set.jpg?imageView2/0/h/800"><link rel="canonical" href="https://www.voidking.com/dev-openstack-vm-live-migration-performance/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>好好学OpenStack：虚拟机在线迁移的性能统计 | 好好学习的郝</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="好好学习的郝" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">好好学习的郝</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">一个计算机技术爱好者与学习者</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/voidking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.voidking.com/dev-openstack-vm-live-migration-performance/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="好好学习的郝"><meta itemprop="description" content="一个计算机技术爱好者与学习者"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="好好学习的郝"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> 好好学OpenStack：虚拟机在线迁移的性能统计</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2018-11-18 09:30:00" itemprop="dateCreated datePublished" datetime="2018-11-18T09:30:00+00:00">2018-11-18</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/" itemprop="url" rel="index"><span itemprop="name">engineering</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/devops/" itemprop="url" rel="index"><span itemprop="name">devops</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/testing/" itemprop="url" rel="index"><span itemprop="name">testing</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/openstack/" itemprop="url" rel="index"><span itemprop="name">openstack</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><span class="post-title-index">1.</span><a href="#前言" class="headerlink" title="前言"></a> 前言</h1><p>OpenStack中共享存储和非共享存储的虚拟机迁移环境都已经搭建完成，接下来可以进行实验了。对于不同的宿主机、不同的实例、不同的负载，虚拟机迁移的性能也会有所不同。那么，虚拟机迁移的性能指标有哪些？又该怎样统计呢？本文就来研究一下。</p><span id="more"></span><h1 id="性能指标"><span class="post-title-index">2.</span><a href="#性能指标" class="headerlink" title="性能指标"></a> 性能指标</h1><p>参考论文<a target="_blank" rel="noopener" href="http://delivery.acm.org/10.1145/1960000/1958790/p307-huang.pdf">《Virt-LM: a benchmark for live migration of virtual machine》</a>，可以得知，虚拟机迁移过程中的主要性能指标有四个：</p><ul><li>整体迁移时间：从迁移开始到迁移结束的时间。</li><li>虚拟机停机时间：迁移过程中虚拟机停机（停止服务）的时间。</li><li>迁移数据量：在虚拟机迁移期间传输的数据总量。</li><li>应用程序的性能：迁移过程中对虚拟机中应用程序产生的影响。</li></ul><h1 id="测量方法"><span class="post-title-index">3.</span><a href="#测量方法" class="headerlink" title="测量方法"></a> 测量方法</h1><h2 id="监控"><span class="post-title-index">3.1.</span><a href="#监控" class="headerlink" title="监控"></a> 监控</h2><p>既然是实验，那么肯定要收集实验过程中的数据。郝同学给这个四个节点的OpenStack集群安装了ganglia，用来监控各种指标。但是，ganglia更适合监控实时数据和观察变化，不适合进行统计。</p><h2 id="迁移时间"><span class="post-title-index">3.2.</span><a href="#迁移时间" class="headerlink" title="迁移时间"></a> 迁移时间</h2><p>整体迁移时间怎么测出来？通过观察图表？不靠谱。叶可江老师提供了思路，整体迁移时间的话，可以通过日志来获取：<br><code>tail -n 40 /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log</code></p><p>通过查看迁出宿主机的日志，然后对比ganglia图表，可以找到两个关键节点：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">09</span>:<span class="number">59</span>:<span class="number">42.442</span> <span class="number">5</span> INFO nova.virt.libvirt.migration [req-d9849256-eaa8-<span class="number">4446</span>-9cec-9545b74df126 202e7852a6074540a70638eed185538e eb83bf3b057f45e1b386cbc8c0702ae1 - default default] [instance: eebe068a-ba85-<span class="number">4905</span>-a39b-f003a7480b14] Increasing downtime to <span class="number">50</span> ms after <span class="number">0</span> <span class="built_in">sec</span> elapsed <span class="built_in">time</span></span><br><span class="line">......</span><br><span class="line"><span class="number">2018</span>-<span class="number">11</span>-<span class="number">22</span> <span class="number">10</span>:<span class="number">00</span>:<span class="number">02.984</span> <span class="number">5</span> INFO nova.compute.manager [req-<span class="number">4b409237</span>-6c82-<span class="number">4b56</span>-ae4c-9f905a4f932e b2edc935f89d4d2684ec4039c02a21cc ab7e3eb8c00d4299afd8572e1ec437bf - default default] [instance: eebe068a-ba85-<span class="number">4905</span>-a39b-f003a7480b14] VM Stopped (Lifecycle Event)</span><br></pre></td></tr></table></figure><p>但是，依然需要手动来计算迁移时间，很麻烦，那就写一个脚本来搞定吧！参考<a target="_blank" rel="noopener" href="http://www.cnblogs.com/chengmo/archive/1776473.html">linux shell 时间运算以及时间差计算方法</a>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">time1=`grep nova.virt.libvirt.migration /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log | <span class="built_in">tail</span> -n 1 |awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`;</span><br><span class="line">time2=`grep <span class="string">&#x27;VM Stopped&#x27;</span> /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log | <span class="built_in">tail</span> -n 1 | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`;</span><br><span class="line"><span class="comment"># 计算时间差</span></span><br><span class="line"><span class="keyword">time</span>=$(($(date +%s -d <span class="variable">$time2</span>) - $(date +%s -d <span class="variable">$time1</span>)));</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$time</span> s&quot;</span>;</span><br></pre></td></tr></table></figure><p>以上脚本，保存为time.sh，并添加执行权限。</p><p>另外，还可以通过<code>nova migration-list &gt; list.log</code>查看到迁移的开始时间和结束时间。然后通过脚本计算迁移时间：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">time1=`grep <span class="string">&#x27;live-migration&#x27;</span> list.log | <span class="built_in">head</span> -n 1 | awk <span class="string">&#x27;&#123;print $24&#125;&#x27;</span>`</span><br><span class="line">time2=`grep <span class="string">&#x27;live-migration&#x27;</span> list.log | <span class="built_in">head</span> -n 1 | awk <span class="string">&#x27;&#123;print $26&#125;&#x27;</span>`</span><br><span class="line"><span class="keyword">time</span>=$(($(date +%s -d <span class="variable">$time2</span>) - $(date +%s -d <span class="variable">$time1</span>)));</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$time</span> s&quot;</span>;</span><br></pre></td></tr></table></figure><p>不过，这种方法测出的迁移时间，比我们从nova-compute.log日志中测出的迁移时间，要多出7秒左右。这种方法应该更准确一些，毕竟是OpenStack自己记录的。</p><h2 id="停机时间"><span class="post-title-index">3.3.</span><a href="#停机时间" class="headerlink" title="停机时间"></a> 停机时间</h2><p>参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43912496/how-to-measure-migration-time-and-down-time">How to measure Migration time and Down time</a>，使用ping命令来测量停机时间。</p><p>我们的虚拟机有两个IP，一个是内网IP，一个是浮动IP。外部机器可以直连的，一般是浮动IP，所以在迁移过程中，建议ping浮动IP，比如<code>sudo ping 10.0.2.159 -i 0.01 &gt;&gt; ping.log</code>。ping.log中的信息为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PING 10.0.2.159 (10.0.2.159) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.2.159: icmp_seq=1 ttl=63 time=3.40 ms</span><br><span class="line">64 bytes from 10.0.2.159: icmp_seq=2 ttl=63 time=1.15 ms</span><br><span class="line">64 bytes from 10.0.2.159: icmp_seq=3 ttl=63 time=1.17 ms</span><br><span class="line">64 bytes from 10.0.2.159: icmp_seq=4 ttl=63 time=1.33 ms</span><br><span class="line">......</span><br><span class="line">64 bytes from 10.0.2.159: icmp_seq=4139 ttl=63 time=1.17 ms</span><br><span class="line">64 bytes from 10.0.2.159: icmp_seq=4140 ttl=63 time=1.05 ms</span><br><span class="line">64 bytes from 10.0.2.159: icmp_seq=4141 ttl=63 time=1.12 ms</span><br><span class="line">64 bytes from 10.0.2.159: icmp_seq=4142 ttl=63 time=1.06 ms</span><br><span class="line"></span><br><span class="line">--- 10.0.2.159 ping statistics ---</span><br><span class="line">4142 packets transmitted, 3668 received, 11% packet loss, time 44127ms</span><br><span class="line">rtt min/avg/max/mdev = 0.580/1.412/36.648/1.407 ms, pipe 3</span><br></pre></td></tr></table></figure><p>由统计信息可以求出停机时间：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 方法一：(缺失的icmp_seq总数)*(时间间隔)</span><br><span class="line">(4142-3668)*0.01=4.74s</span><br><span class="line"># 方法二：(总时间)*(icmp_seq缺失百分比)</span><br><span class="line">(44127/1000)*0.11 = 4.85s</span><br></pre></td></tr></table></figure><p>两种方法相差0.1s，方法一更精确一些。如果想要更加精确，还可以把ping命令的时间间隔调整为1ms。</p><p>方法一写成脚本为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">transmitted=`grep <span class="string">&#x27;packets transmitted&#x27;</span> ping.log | <span class="built_in">tail</span> -n 1 | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">received=`grep <span class="string">&#x27;packets transmitted&#x27;</span> ping.log | <span class="built_in">tail</span> -n 1 | awk <span class="string">&#x27;&#123;print $4&#125;&#x27;</span>`</span><br><span class="line">lost=`<span class="built_in">expr</span> <span class="variable">$transmitted</span> - <span class="variable">$received</span>`</span><br><span class="line"><span class="comment"># echo &quot;downtime is $lost ms&quot;</span></span><br><span class="line">downtime=$(<span class="built_in">echo</span> <span class="string">&quot;scale=3; <span class="variable">$lost</span> / 1000&quot;</span> | bc)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;downtime is <span class="variable">$downtime</span> s&quot;</span></span><br></pre></td></tr></table></figure><p>方法二写成脚本为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">time_str=`grep <span class="string">&#x27;packets transmitted&#x27;</span> ping.log | <span class="built_in">tail</span> -n 1 | awk <span class="string">&#x27;&#123;print $10&#125;&#x27;</span>`</span><br><span class="line">loss_str=`grep <span class="string">&#x27;packets transmitted&#x27;</span> ping.log | <span class="built_in">tail</span> -n 1 | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span>`</span><br><span class="line">time_num=`<span class="built_in">echo</span> <span class="variable">$&#123;time_str%ms&#125;</span>`</span><br><span class="line">loss_percent=`<span class="built_in">echo</span> <span class="variable">$&#123;loss_str%\%&#125;</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment"># downtime = (time_num)*(loss_percent/100)/1000</span></span><br><span class="line">num=`<span class="built_in">expr</span> <span class="variable">$time_num</span> \* <span class="variable">$loss_percent</span>`</span><br><span class="line">downtime=$(<span class="built_in">echo</span> <span class="string">&quot;scale=3; <span class="variable">$num</span> / 100000&quot;</span> | bc)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;downtime is <span class="variable">$downtime</span> s&quot;</span></span><br></pre></td></tr></table></figure><p>以上方法求出的停机时间，是总的停机时间，无论迁移过程中有几次停机，该方法都是适用的。我们会好奇，实际迁移过程中，停机是否只有一次？我们写一个脚本来寻求答案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># 去掉头部和尾部，保留第五列</span></span><br><span class="line"><span class="built_in">cat</span> ping.log | sed <span class="string">&#x27;1d&#x27;</span> | <span class="built_in">tac</span> | sed <span class="string">&#x27;1,4d&#x27;</span> | <span class="built_in">tac</span> | awk <span class="string">&#x27;&#123;print $5&#125;&#x27;</span> &gt; seq.log &amp;&amp;</span><br><span class="line"><span class="comment"># 得到最后一行的序列号</span></span><br><span class="line">max=`<span class="built_in">tail</span> -n 1 seq.log | awk -F <span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line"><span class="comment"># 所有序列号赋值给数组</span></span><br><span class="line">array_str=`<span class="built_in">cat</span> seq.log | awk -F <span class="string">&#x27;=&#x27;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>`</span><br><span class="line">IPS=<span class="string">&#x27; &#x27;</span></span><br><span class="line">array=(<span class="variable">$array_str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印没有响应的序列号</span></span><br><span class="line">COUNTER=0</span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$COUNTER</span> -lt <span class="variable">$max</span> ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    COUNTER=`<span class="built_in">expr</span> <span class="variable">$COUNTER</span> + 1`</span><br><span class="line">    <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$&#123;array[@]&#125;</span>&quot;</span> =~ <span class="variable">$COUNTER</span> ]]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$COUNTER</span>  &gt;&gt; result.log</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span> &amp;&amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对比seq数量</span></span><br><span class="line">start=`<span class="built_in">head</span> -n 1 result.log`</span><br><span class="line">end=`<span class="built_in">tail</span> -n 1 result.log`</span><br><span class="line">num=`<span class="built_in">expr</span> <span class="variable">$end</span> - <span class="variable">$start</span> + 1`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;if continuous, num should be <span class="variable">$num</span>&quot;</span></span><br><span class="line"></span><br><span class="line">result_str=`<span class="built_in">cat</span> result.log`</span><br><span class="line">IPS=<span class="string">&#x27;\n&#x27;</span></span><br><span class="line">result=(<span class="variable">$result_str</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;real num is <span class="variable">$&#123;#result[@]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure><p>脚本输出两个474，说明实例没有响应的序列号是连续的，证明了停机只有一次。比如result.log中为{3,4,5,6,7}，那么7-3+1=5，集合中元素个数也为5，证明连续。比如result.log中为{3,4,5,10,11}，那么11-3+1=9，集合中元素个数为5，证明不连续。</p><h2 id="带宽"><span class="post-title-index">3.4.</span><a href="#带宽" class="headerlink" title="带宽"></a> 带宽</h2><p>测量出的downtime为4.74s，很不合理，因为虚拟机迁移理论上的停机时间是毫秒级的！是因为带宽太低导致停机时间过长吗？可以用如下方法进行测试：<br>1、compute1和compute2上都安装iperf<br><code>sudo apt install iperf</code></p><p>2、compute1上启动iperf服务<br><code>iperf -s</code></p><p>3、compute2上启动iperf客户端<br><code>iperf -c 192.168.56.112 -i 1</code></p><h2 id="迁移数据量"><span class="post-title-index">3.5.</span><a href="#迁移数据量" class="headerlink" title="迁移数据量"></a> 迁移数据量</h2><p>对于迁移数据量，可以使用iptables对端口进行监控，参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/34e846b8b8ac">Linux下对端口流量进行统计</a>和<a target="_blank" rel="noopener" href="http://www.zengwei.top/index.php/archives/8.html">Linux 使用iptables进行shadowsocks流量统计</a>。但是，计算节点网络非常复杂，郝同学不想对其进行修改，所以采用另外一种方案，iptraf，参考<a target="_blank" rel="noopener" href="http://www.ha97.com/4806.html">使用iptraf查看TCP/UDP某个特定端口的带宽与流量</a>。</p><p>1、两个计算节点安装iptraf<br><code>sudo apt install iptraf</code></p><p>需要注意的是，iptraf只支持名为ethX的网卡。想要显示enoX、enp0sX网卡，要么网卡重命名，要么安装使用iptraf-ng。<br><code>sudo apt install iptraf-ng</code></p><p>2、启动iptraf<br><code>sudo iptraf</code><br>启动后，进入到一个字符界面。</p><p>3、设置<br>Configure… -&gt; Additional ports…-&gt; 22 -&gt; Exit Configuration -&gt; Statistical breakdowns… -&gt; By TCP/UDP port -&gt; eth0 -&gt; statistic view<br><img src="http://cdn.voidking.com/img/openstack-vm-live-migration-performance/set.jpg?imageView2/0/h/800"></p><p>参考<a target="_blank" rel="noopener" href="https://docs.openstack.org/nova/pike/admin/configuring-migrations.html">Configure live migrations</a>，可以得知：</p><blockquote><p>By default, libvirt uses the TCP port range from 49152 to 49261 for copying memory and disk contents. Compute hosts must accept connections in this range.</p></blockquote><p>所以在实际使用的时候，端口设置为49152 to 49261。重新进入统计页面，之前的统计数据会清零。</p><h2 id="应用性能"><span class="post-title-index">3.6.</span><a href="#应用性能" class="headerlink" title="应用性能"></a> 应用性能</h2><p>Web应用的性能，主要包括执行时间、传输速度、吞吐量、资源占用率。</p><p>基准测试（benchmarking）是一种测量和评估软件性能指标的活动。你可以在某个时候通过基准测试建立一个已知的性能水平（称为基准线），当系统的软硬件环境发生变化之后再进行一次基准测试以确定那些变化对性能的影响。这是基准测试最常见的用途。其他用途包括测定某种负载水平下的性能极限、管理系统或环境的变化、发现可能导致性能问题的条件，等等。详情参考<a target="_blank" rel="noopener" href="http://www.blogjava.net/qileilove/archive/382241.html">什么是基准测试？</a>。</p><p>对于性能的监控，最简单的思路是Apache Benchmark。使用ab来监控Web服务的性能，检查迁移过程中会发生哪些变化。但是，ab什么时候运行？什么时候停止？请求多少次？怎么计算迁移过程中的平均性能？这些都不能确定。<br>如果使用cAdvisor+prometheus呢？参考<a target="_blank" rel="noopener" href="http://bbotte.com/monitor-safe/docker-monitor-with-cadvisor-and-prometheus/">linux工匠之docker和kubernetes的监控(cadvisor+prometheus)</a>。不行，因为这种方法监控的是docker容器，收集的是CPU、内存等数据，而不是Web性能数据。<br>使用<a target="_blank" rel="noopener" href="https://www.spec.org/web2009/">SPEC</a>？也不好，收费，安装使用复杂。</p><p>很绝望，前辈们都是怎么进行测试的？不管了，先不考虑应用性能指标。</p><h1 id="书签"><span class="post-title-index">4.</span><a href="#书签" class="headerlink" title="书签"></a> 书签</h1><ul><li><a target="_blank" rel="noopener" href="https://blog.zhaw.ch/icclab/an-analysis-of-the-performance-of-live-migration-in-openstack/">An analysis of the performance of live migration in Openstack</a></li><li><a target="_blank" rel="noopener" href="https://blog.zhaw.ch/icclab/an-analysis-of-the-performance-of-block-live-migration-in-openstack/">An analysis of the performance of block live migration in Openstack</a></li><li><a target="_blank" rel="noopener" href="https://blog.zhaw.ch/icclab/performance-analysis-of-post-copy-live-migration-in-openstack/">Performance analysis of “post-copy” live migration in Openstack</a></li></ul></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 好好学习的郝</li><li class="post-copyright-link"> <strong>原文链接：</strong> <a href="https://www.voidking.com/dev-openstack-vm-live-migration-performance/" title="好好学OpenStack：虚拟机在线迁移的性能统计">https://www.voidking.com/dev-openstack-vm-live-migration-performance/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本文采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议，转载请注明出处！源站会即时更新知识点并修正错误，欢迎访问~</li><li> <img width="200" height="200" src="/images/avatar.jpg"><p style="text-align:center;margin-bottom:0">微信公众号同步更新，欢迎关注~</p></li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/linux/" rel="tag"># linux</a> <a href="/tags/docker/" rel="tag"># docker</a> <a href="/tags/ubuntu/" rel="tag"># ubuntu</a> <a href="/tags/openstack/" rel="tag"># openstack</a> <a href="/tags/%E6%B5%8B%E8%AF%95/" rel="tag"># 测试</a> <a href="/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6OpenStack/" rel="tag"># 好好学OpenStack</a> <a href="/tags/iperf/" rel="tag"># iperf</a></div><div class="post-nav"><div class="post-nav-item"><a href="/dev-virtualbox-ubuntu-extend-storage/" rel="prev" title="VirtualBox中Ubuntu扩容"><i class="fa fa-chevron-left"></i> VirtualBox中Ubuntu扩容</a></div><div class="post-nav-item"> <a href="/dev-openstack-vm-live-migration-fault-injection/" rel="next" title="好好学OpenStack：虚拟机在线迁移过程中的故障注入">好好学OpenStack：虚拟机在线迁移过程中的故障注入<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="footer-ads" style="margin-top:10px"><ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-3284447971731414" data-ad-slot="9697986181"></ins><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3284447971731414" crossorigin="anonymous"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">1. 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="nav-text">2. 性能指标</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%B5%8B%E9%87%8F%E6%96%B9%E6%B3%95"><span class="nav-text">3. 测量方法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E6%8E%A7"><span class="nav-text">3.1. 监控</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%81%E7%A7%BB%E6%97%B6%E9%97%B4"><span class="nav-text">3.2. 迁移时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%81%9C%E6%9C%BA%E6%97%B6%E9%97%B4"><span class="nav-text">3.3. 停机时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E5%AE%BD"><span class="nav-text">3.4. 带宽</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E9%87%8F"><span class="nav-text">3.5. 迁移数据量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%94%E7%94%A8%E6%80%A7%E8%83%BD"><span class="nav-text">3.6. 应用性能</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%A6%E7%AD%BE"><span class="nav-text">4. 书签</span></a></li></ol></div></div><div class="sidecar-ads" style="margin-top:10px"><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="好好学习的郝" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">好好学习的郝</p><div class="site-description" itemprop="description">一个计算机技术爱好者与学习者</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">748</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">259</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:voidking@qq.com" title="E-Mail → mailto:voidking@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://github.com/voidking" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/voidking" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/voidking" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i> Zhihu</a></span></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">好好学习的郝</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="footer-beian"> <a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备14021030号</a>&nbsp;|&nbsp; <img src="/images/beian.png" alt=""> <a target="_blank" href="http://www.beian.gov.cn/">苏公网安备 32032202000223号</a></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '5a238b8c32b1e4dd2156',
      clientSecret: 'bfb5d518626f6fdc7da0351d1e0cd37ab75c6361',
      repo: 'gitalk-comments',
      owner: 'voidking',
      admin: ['voidking'],
      id: 'f3ec32b0433b989005f8c5a5699a5f6c',
      title: '好好学OpenStack：虚拟机在线迁移的性能统计',
      body: '欢迎留言，互相交流学习~',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></body></html>