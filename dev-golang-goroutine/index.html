<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://www.voidking.com").hostname,root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1,cdn:{enable:!0,url:"//qiniu-cdn.voidking.com/doc/search.xml"}},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="Golang协程简介在Go语言中，协程（coroutine）是通过goroutine实现的。goroutine是Go运行时管理的轻量级线程，由Go运行时环境调度，不是操作系统层面的线程。goroutine使得并发编程变得简洁易懂。 参考文档：  Golang 调度器设计思想、GMP 协程调度模型详解 调度器 Channel 同步原语与锁 Golang中Channel的实现原理"><meta property="og:type" content="article"><meta property="og:title" content="好好学Golang：协程Goroutine"><meta property="og:url" content="https://www.voidking.com/dev-golang-goroutine/index.html"><meta property="og:site_name" content="好好学习的郝"><meta property="og:description" content="Golang协程简介在Go语言中，协程（coroutine）是通过goroutine实现的。goroutine是Go运行时管理的轻量级线程，由Go运行时环境调度，不是操作系统层面的线程。goroutine使得并发编程变得简洁易懂。 参考文档：  Golang 调度器设计思想、GMP 协程调度模型详解 调度器 Channel 同步原语与锁 Golang中Channel的实现原理"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-08-08T20:00:00.000Z"><meta property="article:modified_time" content="2024-05-04T08:00:00.000Z"><meta property="article:author" content="好好学习的郝"><meta property="article:tag" content="golang"><meta property="article:tag" content="好好学Golang"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.voidking.com/dev-golang-goroutine/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>好好学Golang：协程Goroutine | 好好学习的郝</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="好好学习的郝" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">好好学习的郝</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">一个计算机技术爱好者与学习者</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/voidking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.voidking.com/dev-golang-goroutine/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="好好学习的郝"><meta itemprop="description" content="一个计算机技术爱好者与学习者"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="好好学习的郝"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> 好好学Golang：协程Goroutine</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-08-08 20:00:00" itemprop="dateCreated datePublished" datetime="2019-08-08T20:00:00+00:00">2019-08-08</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i></span> <span class="post-meta-item-text">更新于</span> <time title="修改时间：2024-05-04 08:00:00" itemprop="dateModified" datetime="2024-05-04T08:00:00+00:00">2024-05-04</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/" itemprop="url" rel="index"><span itemprop="name">engineering</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="Golang协程简介"><span class="post-title-index">1.</span><a href="#Golang协程简介" class="headerlink" title="Golang协程简介"></a> Golang协程简介</h1><p>在Go语言中，协程（coroutine）是通过<code>goroutine</code>实现的。<br><code>goroutine</code>是Go运行时管理的轻量级线程，由Go运行时环境调度，不是操作系统层面的线程。<code>goroutine</code>使得并发编程变得简洁易懂。</p><p>参考文档：</p><ul><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/617420622">Golang 调度器设计思想、GMP 协程调度模型详解</a></li><li><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/">调度器</a></li><li><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-channel/">Channel</a></li><li><a target="_blank" rel="noopener" href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-sync-primitives/">同步原语与锁</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/skh2015java/article/details/87921666">Golang中Channel的实现原理</a></li></ul><span id="more"></span><h1 id="创建goroutine"><span class="post-title-index">2.</span><a href="#创建goroutine" class="headerlink" title="创建goroutine"></a> 创建goroutine</h1><p>当一个程序启动时，它仅仅是一个单独的goroutine（即主goroutine）。</p><p>创建一个新的<code>goroutine</code>非常简单，只需要在函数调用前加上关键字<code>go</code>。一旦<code>goroutine</code>被创建，它将与创建它的<code>goroutine</code>（简单理解为线程）并发（或并行）执行。</p><p>下面是一个<code>goroutine</code>的简单示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// printNumbers 打印数字，它会在一个单独的goroutine中执行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%d &quot;</span>, i)</span><br><span class="line">    time.Sleep(<span class="number">50</span> * time.Millisecond) <span class="comment">// 等待一小段时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> printNumbers() <span class="comment">// 开启一个新的goroutine</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// main函数也做一些打印工作</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;%c &quot;</span>, <span class="string">&#x27;a&#x27;</span>+i)</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond) <span class="comment">// 等待一段比printNumbers更长的时间</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>main</code>函数中的<code>go printNumbers()</code>语句启动了一个新的<code>goroutine</code>，而<code>main</code>函数自身也在执行打印操作。这两组打印操作会异步执行。这意味着<code>main</code>函数不会等待<code>printNumbers</code>函数完成，而是会立即开始它的循环和打印操作。在这个简单的程序中，我们可能会看到这两个循环的输出（数字和字母）交错在一起。</p><p>值得注意的是，<code>main</code>函数（主协程）必须运行足够长的时间，以允许别的<code>goroutine</code>有机会开始执行和完成它们的任务。如果<code>main</code>函数过早地结束，程序则会退出，并且所有在运行中的<code>goroutine</code>也会同时终止。在实际应用程序中，这通常通过等待组（<code>sync.WaitGroup</code>）、通道（<code>channel</code>）或其他同步机制来确保<code>goroutine</code>可以完成它们的任务。</p><h1 id="通道channel"><span class="post-title-index">3.</span><a href="#通道channel" class="headerlink" title="通道channel"></a> 通道channel</h1><h2 id="基础概念"><span class="post-title-index">3.1.</span><a href="#基础概念" class="headerlink" title="基础概念"></a> 基础概念</h2><p>在Go语言中，<code>channel</code>是一种内置的数据结构，可以让多个goroutines之间安全地进行数据通信。<code>channel</code>被用来在goroutines间进行通信和同步，它的设计理念来源于CSP（Communicating Sequential Processes）- 一种消息传递模型。</p><p>channel操作：</p><ul><li>创建：使用<code>make()</code>函数创建channel，可以指定channel可存储的元素类型。例如，<code>make(chan int)</code>创建了一个可以传输整数类型的channel。</li><li>发送操作：使用<code>channel &lt;- value</code>语法向channel发送值。</li><li>接收操作：使用<code>&lt;-channel</code>语法从channel接收值。</li><li>关闭：使用内置的<code>close()</code>函数来关闭channel。关闭后不可再向其中发送数据，但仍可接收缓冲中剩余的数据。</li></ul><p>channel类型：</p><ul><li>无缓冲Channel（非缓冲Channel）： 在发送者和接受者准备好之前，不储存任何值。发送操作会阻塞，直到另一个goroutine在对应的channel上执行接收操作。</li><li>有缓冲Channel：可以存储一个或多个值，仅当缓冲满时，向channel发送数据才会阻塞；当缓冲为空时，接收操作才会阻塞。</li></ul><h2 id="无缓冲channel示例"><span class="post-title-index">3.2.</span><a href="#无缓冲channel示例" class="headerlink" title="无缓冲channel示例"></a> 无缓冲channel示例</h2><p>在Go中，无缓冲的channel（或称作同步channel）是在没有空间保持任何元素的情况下进行通信的。一个goroutine在无缓冲channel上发送操作会阻塞，直到另一个goroutine执行接收操作，这样发送者和接收者必须同时准备好进行通信。</p><p>以下是一个使用无缓冲channel的示例。在这个例子中，有一个主goroutine和一个worker goroutine。它们将使用无缓冲channel来同步工作：主goroutine发送工作到channel，worker接收工作，执行，然后通知主goroutine工作已完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(done <span class="keyword">chan</span> <span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">  fmt.Print(<span class="string">&quot;Working...&quot;</span>)</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">  fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送一个值来通知工作已经完成</span></span><br><span class="line">  done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个无缓冲的channel</span></span><br><span class="line">  done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动worker goroutine并传递‘done’channel</span></span><br><span class="line">  <span class="keyword">go</span> worker(done)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 阻塞直到在channel上收到worker的完成通知</span></span><br><span class="line">  &lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>worker</code>函数接受一个类型为<code>bool</code>的无缓冲channel <code>done</code>，它用于向主goroutine发送完成信号。在执行了一些工作（本例中模拟为一秒钟的<code>Sleep</code>调用）后，<code>worker</code>将<code>true</code>发送到<code>done</code> channel。对于<code>done &lt;- true</code>这个语句，在发送完成信号之前，这个<code>worker</code> goroutine 会阻塞，直到主goroutine执行<code>&lt;-done</code>接收操作。</p><p>同样，主程序中的<code>&lt;-done</code>将阻塞直到从<code>done</code> channel接收到值。这样，主程序就会等待<code>worker</code> goroutine完成它的工作并发送完成信号。一旦收到信号，主程序继续执行，程序结束。</p><p>这个过程演示了无缓冲channel在goroutine间同步执行的用法，确保<code>main</code>函数在工作完成之前不会退出。</p><h2 id="有缓冲channel示例"><span class="post-title-index">3.3.</span><a href="#有缓冲channel示例" class="headerlink" title="有缓冲channel示例"></a> 有缓冲channel示例</h2><p>下面是一个有缓冲channel的使用示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, jobs &lt;-<span class="keyword">chan</span> <span class="type">int</span>, results <span class="keyword">chan</span>&lt;- <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> j := <span class="keyword">range</span> jobs &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;worker&quot;</span>, id, <span class="string">&quot;processing job&quot;</span>, j)</span><br><span class="line">    results &lt;- j * <span class="number">2</span> <span class="comment">// 假设的工作是将job值翻倍</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  jobs := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">  results := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建3个worker协程。</span></span><br><span class="line">  <span class="keyword">for</span> w := <span class="number">1</span>; w &lt;= <span class="number">3</span>; w++ &#123;</span><br><span class="line">    <span class="keyword">go</span> worker(w, jobs, results)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送5个jobs然后关闭jobs channel。</span></span><br><span class="line">  <span class="keyword">for</span> j := <span class="number">1</span>; j &lt;= <span class="number">5</span>; j++ &#123;</span><br><span class="line">    jobs &lt;- j</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">close</span>(jobs)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 收集所有的处理结果。</span></span><br><span class="line">  <span class="keyword">for</span> a := <span class="number">1</span>; a &lt;= <span class="number">5</span>; a++ &#123;</span><br><span class="line">    &lt;-results</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了两个channel：<code>jobs</code>用于发送工作项到各个<code>worker</code>协程，<code>results</code>用于从<code>worker</code>协程收集处理结果。我们启动了3个<code>worker</code>协程，在它们中间分配工作项，并从<code>jobs</code> channel读取。每个<code>worker</code>处理一个工作项，然后将结果发送到<code>results</code> channel。</p><p>在<code>main</code>函数中，我们向<code>jobs</code>发送了5个工作项，并关闭了它，表示不会再发送新工作了。然后我们从<code>results</code> channel接收每个worker的计算结果。需要注意的是，我们不需要显式关闭<code>results</code> channel，因为当<code>main</code>函数结束时，程序会自动结束，所有channel将随之关闭。</p><p>在缓冲channel中，只有在尝试发送更多数据而channel已满时，发送操作才会阻塞；同样，只有channel为空时，接收操作才会阻塞。<br>因为我们的channel缓冲区可存100个信号，而程序中只使用了5个信号，因此不会被阻塞。</p><h1 id="上下文Context"><span class="post-title-index">4.</span><a href="#上下文Context" class="headerlink" title="上下文Context"></a> 上下文Context</h1><p>参考文档：<a href="https://www.voidking.com/dev-golang-context/">好好学Golang：上下文Context</a></p><h1 id="同步原语"><span class="post-title-index">5.</span><a href="#同步原语" class="headerlink" title="同步原语"></a> 同步原语</h1><h2 id="基础概念-1"><span class="post-title-index">5.1.</span><a href="#基础概念-1" class="headerlink" title="基础概念"></a> 基础概念</h2><p>在Go语言中，同步原语（Synchronization primitives）是一组用于协调多个协程（goroutines）之间访问共享资源或执行顺序的工具。<br>Go语言的标准库<code>sync</code>为程序员提供了该领域的多个工具，其中包括互斥锁（Mutexes）、读写锁（RWMutexes）、WaitGroup、Cond等。</p><h2 id="同步原语工具概述"><span class="post-title-index">5.2.</span><a href="#同步原语工具概述" class="headerlink" title="同步原语工具概述"></a> 同步原语工具概述</h2><h3 id="Mutex（互斥锁）"><span class="post-title-index">5.2.1.</span><a href="#Mutex（互斥锁）" class="headerlink" title="Mutex（互斥锁）"></a> Mutex（互斥锁）</h3><p>Mutex用于保护共享资源，防止同时进行的多个协程同时读写导致竞态条件（Race Condition）。</p><ul><li><code>Lock()</code>：锁定Mutex，任何其他试图锁定该Mutex的协程都将阻塞直到Mutex被解锁。</li><li><code>Unlock()</code>：解锁Mutex，如果有其他协程在等待锁定这个Mutex，它们中的一个将能够锁定它并继续执行。</li></ul><h3 id="RWMutex（读写锁）"><span class="post-title-index">5.2.2.</span><a href="#RWMutex（读写锁）" class="headerlink" title="RWMutex（读写锁）"></a> RWMutex（读写锁）</h3><p>RWMutex是一种特殊类型的Mutex，它允许多个协程同时读取资源，但只能有一个协程写入资源。</p><ul><li><code>RLock()</code>：锁定读锁，其他协程可以同时锁定读锁，但写锁在此状态下是无法被锁定的。</li><li><code>RUnlock()</code>：解锁读锁。</li><li><code>Lock()</code>：锁定写锁，需要等待直到所有的读锁被解锁。</li><li><code>Unlock()</code>：解锁写锁。</li></ul><h3 id="WaitGroup"><span class="post-title-index">5.2.3.</span><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a> WaitGroup</h3><p>WaitGroup用于等待协程集合完成执行。我们可以用它来确保程序在继续执行之前，一组相关的协程已经运行完毕。</p><ul><li><code>Add(delta int)</code>：增加WaitGroup的计数器。</li><li><code>Done()</code>：减少WaitGroup的计数器，相当于<code>Add(-1)</code>。</li><li><code>Wait()</code>：阻塞，直到计数器归零。</li></ul><h3 id="Cond（条件变量）"><span class="post-title-index">5.2.4.</span><a href="#Cond（条件变量）" class="headerlink" title="Cond（条件变量）"></a> Cond（条件变量）</h3><p>Cond实现了条件变量的功能，它可以让一组协程等待某个条件为真。Cond常与Mutex或RWMutex一同使用。</p><ul><li><code>NewCond(*sync.Locker)</code>：创建Cond的新实例。</li><li><code>Wait()</code>：等待条件变量满足，它在内部调用<code>Unlock()</code>并挂起当前协程，直到<code>Signal()</code>或<code>Broadcast()</code>被调用，然后重新锁定。</li><li><code>Signal()</code>：唤醒一个等待该条件的协程。</li><li><code>Broadcast()</code>：唤醒所有等待该条件的协程。</li></ul><h2 id="同步原语工具示例"><span class="post-title-index">5.3.</span><a href="#同步原语工具示例" class="headerlink" title="同步原语工具示例"></a> 同步原语工具示例</h2><h3 id="WaitGroup示例"><span class="post-title-index">5.3.1.</span><a href="#WaitGroup示例" class="headerlink" title="WaitGroup示例"></a> WaitGroup示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// worker 模拟一个执行任务的function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done() <span class="comment">// 在函数退出之前，调用wg的Done()通知已完成</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;Worker %d starting\n&quot;</span>, id)</span><br><span class="line">  time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟耗时任务</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;Worker %d done\n&quot;</span>, id)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动多个worker协程</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>) <span class="comment">// 添加一个计数</span></span><br><span class="line">    <span class="keyword">go</span> worker(i, &amp;wg)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait() <span class="comment">// 阻塞，直到wg计数器回到0</span></span><br><span class="line">  fmt.Println(<span class="string">&quot;All workers completed&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WaitGroup</code>用于等待一组协程完成各自的工作。上面的代码中，每个协程在开始时调用<code>wg.Add(1)</code>，在工作完成时调用<code>wg.Done()</code>。<code>main</code>函数调用<code>wg.Wait()</code>等待所有协程完成。</p><h3 id="Mutex示例"><span class="post-title-index">5.3.2.</span><a href="#Mutex示例" class="headerlink" title="Mutex示例"></a> Mutex示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> balance <span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deposit</span><span class="params">(value <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">  mutex.Lock() <span class="comment">// 获取互斥锁</span></span><br><span class="line">  balance += value</span><br><span class="line">  mutex.Unlock() <span class="comment">// 释放互斥锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">withdraw</span><span class="params">(value <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">  mutex.Lock() <span class="comment">// 获取互斥锁</span></span><br><span class="line">  balance -= value</span><br><span class="line">  mutex.Unlock() <span class="comment">// 释放互斥锁</span></span><br><span class="line">  wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  balance = <span class="number">100</span> <span class="comment">// 初始化账户余额</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行多个存款和取款操作</span></span><br><span class="line">  wg.Add(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">go</span> deposit(<span class="number">50</span>, &amp;wg)</span><br><span class="line">  <span class="keyword">go</span> withdraw(<span class="number">30</span>, &amp;wg)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待所有操作完成</span></span><br><span class="line">  wg.Wait()</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="string">&quot;New Balance:&quot;</span>, balance)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>balance</code>代表一个银行账户的余额，多个协程尝试进行存款或取款操作。由于所有的存取款操作都通过互斥锁<code>mutex</code>来同步，因此无论协程的执行顺序如何，最终的账户余额都将是一致且正确的。使用<code>sync.WaitGroup</code>保证<code>main</code>函数会等待两个协程操作完成后才打印最终余额。</p><h3 id="RWMutex示例"><span class="post-title-index">5.3.3.</span><a href="#RWMutex示例" class="headerlink" title="RWMutex示例"></a> RWMutex示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  counter <span class="type">int</span></span><br><span class="line">  rwMutex sync.RWMutex</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// reader 模拟一个读取操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reader</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  rwMutex.RLock() <span class="comment">// 获取读锁</span></span><br><span class="line">  fmt.Printf(<span class="string">&quot;Reader %d: %d\n&quot;</span>, id, counter)</span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Millisecond) <span class="comment">// 读取过程耗时</span></span><br><span class="line">  rwMutex.RUnlock()                <span class="comment">// 释放读锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// writer 模拟一个写入操作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writer</span><span class="params">(id <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  rwMutex.Lock() <span class="comment">// 获取写锁</span></span><br><span class="line">  counter++</span><br><span class="line">  fmt.Printf(<span class="string">&quot;Writer %d: %d\n&quot;</span>, id, counter)</span><br><span class="line">  time.Sleep(<span class="number">1</span> * time.Millisecond) <span class="comment">// 写入过程耗时</span></span><br><span class="line">  rwMutex.Unlock()                 <span class="comment">// 释放写锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动读者</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> reader(i, &amp;wg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动写者</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> writer(i, &amp;wg)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait() <span class="comment">// 等待所有读者和写者结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们使用<code>sync.RWMutex</code>维护对<code>counter</code>读写操作的同步，允许多个读操作并行执行，但对写操作互斥访问。</p><h3 id="Cond示例"><span class="post-title-index">5.3.4.</span><a href="#Cond示例" class="headerlink" title="Cond示例"></a> Cond示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">&quot;fmt&quot;</span></span><br><span class="line">  <span class="string">&quot;sync&quot;</span></span><br><span class="line">  <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> mu sync.Mutex              <span class="comment">// 锁，用于保护条件</span></span><br><span class="line">  cond := sync.NewCond(&amp;mu)     <span class="comment">// 创建条件变量cond</span></span><br><span class="line">  <span class="keyword">var</span> ready <span class="type">bool</span>                <span class="comment">// 条件：表示工作是否就绪</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 广播启动工作的协程</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    time.Sleep(<span class="number">2</span> * time.Second) <span class="comment">// 模拟一些准备工作耗时</span></span><br><span class="line">    mu.Lock()                   <span class="comment">// 获取锁，准备改变条件</span></span><br><span class="line">    ready = <span class="literal">true</span>                <span class="comment">// 设置工作就绪</span></span><br><span class="line">    cond.Broadcast()            <span class="comment">// 广播通知给所有等待的协程</span></span><br><span class="line">    mu.Unlock()                 <span class="comment">// 释放锁</span></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建多个工作者协程等待条件变量</span></span><br><span class="line">  <span class="keyword">const</span> nWorkers = <span class="number">3</span></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(nWorkers)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; nWorkers; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="keyword">defer</span> wg.Done()</span><br><span class="line">      mu.Lock()                  <span class="comment">// 获取锁以检查条件</span></span><br><span class="line">      <span class="keyword">for</span> !ready &#123;               <span class="comment">// 循环，直到工作就绪为止</span></span><br><span class="line">        cond.Wait()           <span class="comment">// 等待条件变量的信号</span></span><br><span class="line">      &#125;</span><br><span class="line">      fmt.Printf(<span class="string">&quot;Worker %d started\n&quot;</span>, id)</span><br><span class="line">      mu.Unlock()                <span class="comment">// 释放锁，让其他协程进入临界区</span></span><br><span class="line">    &#125;(i)</span><br><span class="line">  &#125;</span><br><span class="line">  wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们创建了一个条件变量<code>cond</code>。所有的协程启动时都会通过使用<code>cond.Wait()</code>等待（阻塞），直到条件准备就绪。一旦条件满足，我们用<code>cond.Broadcast()</code>通知所有等待中的协程。<br>注意，在调用<code>Wait</code>和<code>Broadcast</code>之前和之后，我们都需要手动获取和释放相关的锁。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 好好学习的郝</li><li class="post-copyright-link"> <strong>原文链接：</strong> <a href="https://www.voidking.com/dev-golang-goroutine/" title="好好学Golang：协程Goroutine">https://www.voidking.com/dev-golang-goroutine/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本文采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议，转载请注明出处！源站会即时更新知识点并修正错误，欢迎访问~</li><li> <img width="200" height="200" src="/images/avatar.jpg"><p style="text-align:center;margin-bottom:0">微信公众号同步更新，欢迎关注~</p></li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/golang/" rel="tag"># golang</a> <a href="/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Golang/" rel="tag"># 好好学Golang</a></div><div class="post-nav"><div class="post-nav-item"><a href="/dev-golang-grammar-pick-up/" rel="prev" title="好好学Golang：Golang语法拾贝"><i class="fa fa-chevron-left"></i> 好好学Golang：Golang语法拾贝</a></div><div class="post-nav-item"> <a href="/dev-golang-context/" rel="next" title="好好学Golang：上下文Context">好好学Golang：上下文Context<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="footer-ads" style="margin-top:10px"><ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-3284447971731414" data-ad-slot="9697986181"></ins><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3284447971731414" crossorigin="anonymous"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Golang%E5%8D%8F%E7%A8%8B%E7%AE%80%E4%BB%8B"><span class="nav-text">1. Golang协程简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAgoroutine"><span class="nav-text">2. 创建goroutine</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%80%9A%E9%81%93channel"><span class="nav-text">3. 通道channel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-text">3.1. 基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2channel%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.2. 无缓冲channel示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2channel%E7%A4%BA%E4%BE%8B"><span class="nav-text">3.3. 有缓冲channel示例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87Context"><span class="nav-text">4. 上下文Context</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD"><span class="nav-text">5. 同步原语</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5-1"><span class="nav-text">5.1. 基础概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0"><span class="nav-text">5.2. 同步原语工具概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex%EF%BC%88%E4%BA%92%E6%96%A5%E9%94%81%EF%BC%89"><span class="nav-text">5.2.1. Mutex（互斥锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RWMutex%EF%BC%88%E8%AF%BB%E5%86%99%E9%94%81%EF%BC%89"><span class="nav-text">5.2.2. RWMutex（读写锁）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WaitGroup"><span class="nav-text">5.2.3. WaitGroup</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cond%EF%BC%88%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%EF%BC%89"><span class="nav-text">5.2.4. Cond（条件变量）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E5%B7%A5%E5%85%B7%E7%A4%BA%E4%BE%8B"><span class="nav-text">5.3. 同步原语工具示例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#WaitGroup%E7%A4%BA%E4%BE%8B"><span class="nav-text">5.3.1. WaitGroup示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Mutex%E7%A4%BA%E4%BE%8B"><span class="nav-text">5.3.2. Mutex示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RWMutex%E7%A4%BA%E4%BE%8B"><span class="nav-text">5.3.3. RWMutex示例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cond%E7%A4%BA%E4%BE%8B"><span class="nav-text">5.3.4. Cond示例</span></a></li></ol></li></ol></li></ol></div></div><div class="sidecar-ads" style="margin-top:10px"><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="好好学习的郝" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">好好学习的郝</p><div class="site-description" itemprop="description">一个计算机技术爱好者与学习者</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">748</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">32</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">259</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:voidking@qq.com" title="E-Mail → mailto:voidking@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://github.com/voidking" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/voidking" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/voidking" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i> Zhihu</a></span></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 – <span itemprop="copyrightYear">2025</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">好好学习的郝</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="footer-beian"> <a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备14021030号</a>&nbsp;|&nbsp; <img src="/images/beian.png" alt=""> <a target="_blank" href="http://www.beian.gov.cn/">苏公网安备 32032202000223号</a></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><link rel="stylesheet" href="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('https://lf6-cdn-tos.bytecdntp.com/cdn/expire-1-M/gitalk/1.7.2/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '5a238b8c32b1e4dd2156',
      clientSecret: 'bfb5d518626f6fdc7da0351d1e0cd37ab75c6361',
      repo: 'gitalk-comments',
      owner: 'voidking',
      admin: ['voidking'],
      id: '1aead244a097c4a34b9df5781b11eadc',
      title: '好好学Golang：协程Goroutine',
      body: '欢迎留言，互相交流学习~',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></body></html>