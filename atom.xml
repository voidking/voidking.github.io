<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好好学习的郝</title>
  
  <subtitle>一个计算机技术爱好者与学习者</subtitle>
  <link href="https://www.voidking.com/atom.xml" rel="self"/>
  
  <link href="https://www.voidking.com/"/>
  <updated>2023-12-23T08:00:00.000Z</updated>
  <id>https://www.voidking.com/</id>
  
  <author>
    <name>好好学习的郝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MacOS安装配置Mermaid</title>
    <link href="https://www.voidking.com/dev-macos-mermaid/"/>
    <id>https://www.voidking.com/dev-macos-mermaid/</id>
    <published>2023-12-23T08:00:00.000Z</published>
    <updated>2023-12-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mermaid简介"><span class="post-title-index">1. </span><a href="#Mermaid简介" class="headerlink" title="Mermaid简介"></a>Mermaid简介</h1><blockquote><p>Mermaid: JavaScript based diagramming and charting tool that renders Markdown-inspired text definitions to create and modify diagrams dynamically.</p></blockquote><p>参考文档：<a href="https://mermaid.js.org/">Mermaid</a></p><span id="more"></span><h1 id="安装Node"><span class="post-title-index">2. </span><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h1><p>1、安装nvm<br>nvm安装方法参考文档<a href="https://www.voidking.com/hobby-macos-settings/">《MacOS上软件配置》</a></p><p>2、安装v20版本node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v20.10.0</span><br></pre></td></tr></table></figure><p>node版本要大于v14，更低版本的node会报错 SyntaxError ，详情参考 <a href="https://github.com/mermaid-js/mermaid-cli/issues/572">Client does not start</a></p><p>3、使用v20版本node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm use v20.10.0</span><br><span class="line">nvm <span class="built_in">alias</span> default v20.10.0</span><br><span class="line">nvm list</span><br></pre></td></tr></table></figure><h1 id="安装Mermaid"><span class="post-title-index">3. </span><a href="#安装Mermaid" class="headerlink" title="安装Mermaid"></a>安装Mermaid</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PUPPETEER_SKIP_DOWNLOAD=<span class="string">&quot;true&quot;</span> </span><br><span class="line">npm install -g @mermaid-js/mermaid-cli</span><br></pre></td></tr></table></figure><h1 id="安装Chromium（可选）"><span class="post-title-index">4. </span><a href="#安装Chromium（可选）" class="headerlink" title="安装Chromium（可选）"></a>安装Chromium（可选）</h1><p>1、下载<a href="https://download-chromium.appspot.com/">chromium</a></p><p>2、放置chromium到指定路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip chrome-mac.zip</span><br><span class="line"><span class="built_in">mv</span> chrome-mac <span class="variable">$HOME</span>/.cache/puppeteer/chrome</span><br></pre></td></tr></table></figure><h1 id="使用mmdc"><span class="post-title-index">5. </span><a href="#使用mmdc" class="headerlink" title="使用mmdc"></a>使用mmdc</h1><h2 id="mmdc简介"><span class="post-title-index">5.1. </span><a href="#mmdc简介" class="headerlink" title="mmdc简介"></a>mmdc简介</h2><p>mmdc是Mermaid CLI（命令行接口）的核心命令，用于把Mermaid图表代码转换为图像文件（如SVG、PNG、PDF）。</p><p>mmdc语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmdc -i input -o output</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-i 参数后接输入文件路径，对应的是包含 Mermaid 代码的文件。</li><li>-o 参数后接输出文件路径，对应的是转换后的图像文件。</li><li>-p 参数用于指定Puppeteer配置文件的路径，Puppeteer是一个Node库，提供了控制Chromium、Chrome或Firefox的高级API。</li><li>-w 和 -H 控制浏览器视窗的尺寸（不是生成的图像的尺寸）</li><li>-t 参数用于指定主题样式，比如default、forest、neutral等。</li></ul><h2 id="mmdc使用示例"><span class="post-title-index">5.2. </span><a href="#mmdc使用示例" class="headerlink" title="mmdc使用示例"></a>mmdc使用示例</h2><p>1、创建 pupeteer 配置文件 puppeteer-config.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;executablePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Users/vk/.cache/puppeteer/chrome/chrome-mac/Chromium.app/Contents/MacOS/Chromium&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果使用Chrome的话，配置内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;executablePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>2、创建一个 mmd 文件 flowchart.mmd</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br></pre></td></tr></table></figure><p>3、生成图表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmdc -i flowchart.mmd -o flowchart.png -p puppeteer-config.json</span><br></pre></td></tr></table></figure><h1 id="Python调用Mermaid"><span class="post-title-index">6. </span><a href="#Python调用Mermaid" class="headerlink" title="Python调用Mermaid"></a>Python调用Mermaid</h1><p>参考代码：<a href="https://github.com/geekan/MetaGPT/blob/main/metagpt/utils/mermaid.py">MetaGPT - metagpt/utils/mermaid.py</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Mermaid简介&quot;&gt;&lt;a href=&quot;#Mermaid简介&quot; class=&quot;headerlink&quot; title=&quot;Mermaid简介&quot;&gt;&lt;/a&gt;Mermaid简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Mermaid: JavaScript based diagramming and charting tool that renders Markdown-inspired text definitions to create and modify diagrams dynamically.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://mermaid.js.org/&quot;&gt;Mermaid&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="frontend" scheme="https://www.voidking.com/categories/engineering/frontend/"/>
    
    <category term="shell" scheme="https://www.voidking.com/categories/engineering/shell/"/>
    
    <category term="computer" scheme="https://www.voidking.com/categories/computer/"/>
    
    
    <category term="macos" scheme="https://www.voidking.com/tags/macos/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Python单元测试框架之pytest</title>
    <link href="https://www.voidking.com/dev-python-pytest/"/>
    <id>https://www.voidking.com/dev-python-pytest/</id>
    <published>2023-12-23T08:00:00.000Z</published>
    <updated>2023-12-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pytest简介"><span class="post-title-index">1. </span><a href="#pytest简介" class="headerlink" title="pytest简介"></a>pytest简介</h1><blockquote><p>The pytest framework makes it easy to write small, readable tests, and can scale to support complex functional testing for applications and libraries.</p></blockquote><p>pytest是一种卓越的Python测试框架，它提供了简单、高效的方式来编写可以扩展的测试用例。</p><p>本文学习pytest的测试用例写法，内容整理自 chatgpt gpt-4-0613 。</p><p>相关文档：</p><ul><li><a href="https://docs.pytest.org/en/7.4.x/">pytest官网</a></li><li><a href="https://www.voidking.com/dev-python-unittest/">《Python单元测试》</a></li></ul><span id="more"></span><h1 id="pytest基本测试"><span class="post-title-index">2. </span><a href="#pytest基本测试" class="headerlink" title="pytest基本测试"></a>pytest基本测试</h1><h2 id="准备一个模块"><span class="post-title-index">2.1. </span><a href="#准备一个模块" class="headerlink" title="准备一个模块"></a>准备一个模块</h2><p>准备一个mathlib模块，包含一个求和函数add()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mathlib.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><h2 id="编写测试用例"><span class="post-title-index">2.2. </span><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h2><p>Python中编写测试用例，一种常见的方式是创建一个以<code>test_</code>为前缀的函数，这个函数应包含测试用例的名字和内部执行逻辑。</p><p>我们想要创建一个测试用例来检验 add 函数，我们可以创建一个 test_mathlib.py 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_mathlib.py</span></span><br><span class="line"><span class="keyword">import</span> mathlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_add</span>():</span><br><span class="line">    res = mathlib.add(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span> res == <span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="执行测试"><span class="post-title-index">2.3. </span><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_mathlib.py</span><br></pre></td></tr></table></figure><h2 id="丰富测试用例"><span class="post-title-index">2.4. </span><a href="#丰富测试用例" class="headerlink" title="丰富测试用例"></a>丰富测试用例</h2><p>为了使测试更丰富，我们可以使用 <code>@pytest.mark.parametrize</code> 装饰器为函数参数提供多组值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_mathlib.py</span></span><br><span class="line"><span class="keyword">import</span> mathlib</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;a, b, expected&quot;</span>, [</span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params"><span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span></span>), </span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params"><span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span></span>), </span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params"><span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span></span>)</span></span></span><br><span class="line"><span class="params"><span class="meta">]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">a, b, expected</span>):</span><br><span class="line">    res = mathlib.add(a, b)</span><br><span class="line">    <span class="keyword">assert</span> res == expected</span><br></pre></td></tr></table></figure><h1 id="pytest进阶测试"><span class="post-title-index">3. </span><a href="#pytest进阶测试" class="headerlink" title="pytest进阶测试"></a>pytest进阶测试</h1><h2 id="Fixture"><span class="post-title-index">3.1. </span><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h2><p>Fixture（预置） 是 pytest 提供的一种特殊的函数，它将测试前的准备工作和解除步骤打包成一个函数，以供测试用例调用。这样做可以提高测试的可重用性和代码的可读性。</p><p>例如，我们要为数据库相关的测试都创建一个测试数据库，并在测试结束后清理掉，可以写个fixture如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db</span>():</span><br><span class="line">    db = setup_database()</span><br><span class="line">    <span class="keyword">yield</span> db</span><br><span class="line">    teardown_database(db)</span><br></pre></td></tr></table></figure><p>然后在测试函数中使用这个 db fixture：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_database</span>(<span class="params">db</span>):</span><br><span class="line">    <span class="comment"># Now you can interact with the db object, which is set up </span></span><br><span class="line">    <span class="comment"># at the beginning of the test and will be torn down at the end.</span></span><br></pre></td></tr></table></figure><h2 id="Mocking"><span class="post-title-index">3.2. </span><a href="#Mocking" class="headerlink" title="Mocking"></a>Mocking</h2><p>Mocking（模拟） 是一种强大的技术，它可以模拟我们在测试中所依赖的部分的行为。例如，我们的函数可能依赖于一个第三方服务或者数据库，在测试环境中，很可能无法启动这些服务。这时，就可以用 Mock 对象替代这些服务或者数据库。pytest 提供了 unittest.mock 作为内置的 mocking 框架。</p><p>下面是一个简单的 mocking 例子，假设我们有一个打印函数 <code>print_content()</code>，我们并不希望在测试的时候真的打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> MagicMock</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_print_content</span>():</span><br><span class="line">    print_content = MagicMock()</span><br><span class="line">    print_content(<span class="string">&quot;hello&quot;</span>) </span><br><span class="line">    print_content.assert_called_with(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Marker"><span class="post-title-index">3.3. </span><a href="#Marker" class="headerlink" title="Marker"></a>Marker</h2><p>在 pytest 中，Marker（标记）用于给测试用例添加元数据。比如最常见的 skip 和 xfail，它们会让 pytest 跳过或者期望失败的测试用例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.skip(<span class="params">reason=<span class="string">&quot;No way to test this&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_the_unknown</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.xfail</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_feature_x</span>():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>@pytest.mark.asyncio</code> 也是一个常用的内置装饰器，用于标记需要异步执行的函数。</p><p>Python3.5 版本引入了 async / await 关键字支持原生协程，它允许我们编写异步的代码，而不需要依赖于特定的包或者复杂的回调链。然而，pytest 是同步的，它不能原生支持 async / await 式的测试。这就是 pytest.mark.asyncio 装饰器的作用: 它让我们能够以同步的方式来测试异步的代码。</p><p>我们也可以自定义 marker。然后我们可以在运行 pytest 的时候指定参数 <code>-m</code> 来只运行有特定标记的测试用例，从而帮助我们更好地管理和运行我们的测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.my_marker</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_function</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the test</span></span><br><span class="line">pytest -m my_marker</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;pytest简介&quot;&gt;&lt;a href=&quot;#pytest简介&quot; class=&quot;headerlink&quot; title=&quot;pytest简介&quot;&gt;&lt;/a&gt;pytest简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;The pytest framework makes it easy to write small, readable tests, and can scale to support complex functional testing for applications and libraries.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pytest是一种卓越的Python测试框架，它提供了简单、高效的方式来编写可以扩展的测试用例。&lt;/p&gt;
&lt;p&gt;本文学习pytest的测试用例写法，内容整理自 chatgpt gpt-4-0613 。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.pytest.org/en/7.4.x/&quot;&gt;pytest官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-python-unittest/&quot;&gt;《Python单元测试》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="testing" scheme="https://www.voidking.com/categories/engineering/testing/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
    <category term="测试" scheme="https://www.voidking.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Git LFS</title>
    <link href="https://www.voidking.com/dev-git-lfs/"/>
    <id>https://www.voidking.com/dev-git-lfs/</id>
    <published>2023-12-16T08:00:00.000Z</published>
    <updated>2023-12-16T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-LFS-简介"><span class="post-title-index">1. </span><a href="#Git-LFS-简介" class="headerlink" title="Git LFS 简介"></a>Git LFS 简介</h1><blockquote><p>Git LFS: An open source Git extension for versioning large files<br>Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.</p></blockquote><p>Git LFS (Large File Storage）是一个开源的Git大文件版本控制的解决方案和工具集，工具自身是基于Golang进行实现，并在Github上开源。原理上是通过对Git客户端进行扩展的方式，从而集成并兼容了原生的Git客户端。Git LFS良好的设计，让用户感觉在对大文件处理过程中，与普通Git的使用方式上没有任何差别，也就是说，在使用方式上Git LFS对用户是完全透明的。</p><p>参考文档：</p><ul><li><a href="https://git-lfs.com/">GIT Large File Storage</a></li><li><a href="https://github.com/git-lfs/git-lfs">github - git-lfs/git-lfs</a></li><li><a href="https://docs.github.com/zh/repositories/working-with-files/managing-large-files/about-git-large-file-storage">关于 Git Large File Storage</a></li><li><a href="https://help.aliyun.com/document_detail/206887.html">什么是Git LFS大文件存储?</a></li><li><a href="https://help.aliyun.com/document_detail/206889.html">如何使用 Git LFS</a></li></ul><span id="more"></span><h1 id="下载和安装Git-LFS"><span class="post-title-index">2. </span><a href="#下载和安装Git-LFS" class="headerlink" title="下载和安装Git LFS"></a>下载和安装Git LFS</h1><h2 id="官方脚本安装"><span class="post-title-index">2.1. </span><a href="#官方脚本安装" class="headerlink" title="官方脚本安装"></a>官方脚本安装</h2><p>1、下载适合系统的 <a href="https://github.com/git-lfs/git-lfs/releases">git-lfs/releases</a></p><p>2、解压安装<br>解压后，执行 <code>install.sh</code> 脚本，这个脚本会做两个事情：</p><ul><li>在<code>$PATH</code>中安装Git LFS的二进制可执行文件</li><li>执行<code>git lfs install</code>命令，让当前环境支持全局的LFS配置</li></ul><p>安装成功，会输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git LFS initialized.</span><br></pre></td></tr></table></figure><h2 id="Linux"><span class="post-title-index">2.2. </span><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>参考文档：<a href="https://packagecloud.io/github/git-lfs/install">Git LFS - Installation instructions</a></p><p>Linux Debian：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s http://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure><p>RPM packages：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s http://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><h2 id="MacOS"><span class="post-title-index">2.3. </span><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git-lfs</span><br></pre></td></tr></table></figure><h2 id="Windows"><span class="post-title-index">2.4. </span><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>目前lfs已经集成在了Git for Windows 中，直接下载和使用最新版本的Windows Git即可。</p><h1 id="让仓库支持Git-LFS"><span class="post-title-index">3. </span><a href="#让仓库支持Git-LFS" class="headerlink" title="让仓库支持Git LFS"></a>让仓库支持Git LFS</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><p>如果官方脚本安装，那么不需要执行这条命令。</p><h1 id="使用Git-LFS"><span class="post-title-index">4. </span><a href="#使用Git-LFS" class="headerlink" title="使用Git LFS"></a>使用Git LFS</h1><p>1、设置LFS追踪 mp4 类型的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs track <span class="string">&quot;*.mp4&quot;</span></span><br></pre></td></tr></table></figure><p>track 命令实际上是修改了仓库中的 <code>.gitattributes</code> 文件。</p><p>2、查看LFS追踪的文件类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs track</span><br></pre></td></tr></table></figure><p>3、提交 <code>.gitattributes</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .gitattributes</span><br><span class="line">git commit -m <span class="string">&quot;Add LFS config&quot;</span></span><br></pre></td></tr></table></figure><p>4、放入一个 mp4 类型的文件到仓库中</p><p>5、提交并推送 mp4 类型文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add test.mp4</span><br><span class="line">git commit -m <span class="string">&quot;Add a bigfile&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>推送后，查看该mp4文件，会显示 Stored with Git LFS 。</p><p>注意：github中fork的仓库是不支持LFS上传大文件的，详情参考：<a href="https://github.com/git-lfs/git-lfs/issues/1906">can not upload new objects to public fork</a>。如果想要上传大文件，需要源仓库管理员授权push的权限。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git-LFS-简介&quot;&gt;&lt;a href=&quot;#Git-LFS-简介&quot; class=&quot;headerlink&quot; title=&quot;Git LFS 简介&quot;&gt;&lt;/a&gt;Git LFS 简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Git LFS: An open source Git extension for versioning large files&lt;br&gt;Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git LFS (Large File Storage）是一个开源的Git大文件版本控制的解决方案和工具集，工具自身是基于Golang进行实现，并在Github上开源。原理上是通过对Git客户端进行扩展的方式，从而集成并兼容了原生的Git客户端。Git LFS良好的设计，让用户感觉在对大文件处理过程中，与普通Git的使用方式上没有任何差别，也就是说，在使用方式上Git LFS对用户是完全透明的。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://git-lfs.com/&quot;&gt;GIT Large File Storage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/git-lfs/git-lfs&quot;&gt;github - git-lfs/git-lfs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/zh/repositories/working-with-files/managing-large-files/about-git-large-file-storage&quot;&gt;关于 Git Large File Storage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/206887.html&quot;&gt;什么是Git LFS大文件存储?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/206889.html&quot;&gt;如何使用 Git LFS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="github" scheme="https://www.voidking.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>git pre-commit 代码质量检查</title>
    <link href="https://www.voidking.com/dev-git-pre-commit/"/>
    <id>https://www.voidking.com/dev-git-pre-commit/</id>
    <published>2023-12-16T08:00:00.000Z</published>
    <updated>2023-12-16T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pre-commit-简介"><span class="post-title-index">1. </span><a href="#pre-commit-简介" class="headerlink" title="pre-commit 简介"></a>pre-commit 简介</h1><p>Git 提供了一种称为钩子（hook）的特性，帮助我们在关键时刻自动执行自定义脚本。<br>其中，名为 <code>pre-commit</code> 的钩子会在每次 commit 之前运行，能够作为保障代码质量的工具。</p><span id="more"></span><h1 id="使用-pre-commit"><span class="post-title-index">2. </span><a href="#使用-pre-commit" class="headerlink" title="使用 pre-commit"></a>使用 pre-commit</h1><p>在项目的根目录下，找到 <code>.git/hooks</code> 文件夹，这个文件夹中存放的就是各种钩子脚本。</p><p>创建一个新文件命名为 pre-commit ，务必不要添加后缀，如 .sh 或 .py。</p><p>在 pre-commit 文件中，我们可以添加任何可以执行的脚本。<br>例如，如果我们针对 Python 的 .py 文件进行检查，则我们可能的 pre-commit 内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br><span class="line">FILES_PATTERN=<span class="string">&#x27;\.(py)(\..+)?$&#x27;</span></span><br><span class="line">FORBIDDEN=<span class="string">&#x27;pdb.set_trace()&#x27;</span></span><br><span class="line">git diff --cached --name-only | \</span><br><span class="line">    <span class="keyword">while</span> read FILE; do</span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;$&#123;FILE&#125;&quot;</span> =~ $&#123;FILES_PATTERN&#125; ]]; then</span><br><span class="line">            <span class="keyword">if</span> grep --quiet <span class="string">&quot;$&#123;FORBIDDEN&#125;&quot;</span> <span class="string">&quot;$&#123;FILE&#125;&quot;</span>; then</span><br><span class="line">                echo <span class="string">&quot;$&#123;FILE&#125; contains $&#123;FORBIDDEN&#125;&quot;</span></span><br><span class="line">                exit <span class="number">1</span></span><br><span class="line">            fi</span><br><span class="line">        fi</span><br><span class="line">    done || exit $?</span><br></pre></td></tr></table></figure><p>这个检查脚本的意思是，如果我们的 .py 文件中含有 pdb.set_trace()，那么拒绝该次 commit。</p><p>设置完后，我们需要使脚本具有执行权限，使用 <code>chmod +x .git/hooks/pre-commit</code> 命令即可。</p><p>之后，每一次的 git commit，在提交之前，都会执行我们定义好的 pre-commit 脚本，保证代码符合我们设置的规范，从而提升代码质量。</p><h1 id="pre-commit-框架"><span class="post-title-index">3. </span><a href="#pre-commit-框架" class="headerlink" title="pre-commit 框架"></a>pre-commit 框架</h1><p>当我们有大量项目时，pre-commit 脚本的管理维护就变成了一件痛苦的事情。<br>此时，就需要 pre-commit 框架出马了。pre-commit 框架是一个支持多语言的 pre-commit 脚本的管理器，能够简化我们的 pre-commit 脚本配置。<br>使用 pre-commit 框架时，在 <code>.pre-commit-config.yaml</code> 配置文件指定所需的linter列表（脚本列表），然后 pre-commit 框架会自动下载这些linter并运行。</p><p>需要特别说明的是：一些最好的 linter 可能是项目中不使用的语言编写的。例如 scss-lint 是一个用于检查SCSS的 linter，但是它是用Ruby编写的。而我们使用 pre-commit 框架时，完全不用关心 scss-lint 的安装配置，只要在linter列表中指定使用它即可。</p><p>参考文档：</p><ul><li><a href="https://pre-commit.com/">pre-commit 框架</a></li><li><a href="https://github.com/pre-commit/pre-commit">github - pre-commit/pre-commit</a></li><li><a href="https://www.voidking.com/dev-python-code-quality-check/">《Python代码质量检查》</a></li></ul><h1 id="安装-pre-commit-框架"><span class="post-title-index">4. </span><a href="#安装-pre-commit-框架" class="headerlink" title="安装 pre-commit 框架"></a>安装 pre-commit 框架</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pre-commit</span><br></pre></td></tr></table></figure><h1 id="使用-pre-commit-框架"><span class="post-title-index">5. </span><a href="#使用-pre-commit-框架" class="headerlink" title="使用 pre-commit 框架"></a>使用 pre-commit 框架</h1><p>1、创建 pre-commit 框架配置文件 <code>.pre-commit-config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_stages:</span> [ <span class="string">commit</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install</span></span><br><span class="line"><span class="comment"># 1. pip install pre-commit</span></span><br><span class="line"><span class="comment"># 2. pre-commit install(the first time you download the repo, it will be cached for future use)</span></span><br><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pycqa/isort</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.11</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">isort</span></span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&#x27;--profile&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">&gt;-</span></span><br><span class="line"><span class="string">            (?x)^(</span></span><br><span class="line"><span class="string">            .*__init__\.py$</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/astral-sh/ruff-pre-commit</span></span><br><span class="line">    <span class="comment"># Ruff version.</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v0.0.284</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/psf/black</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">23.3</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">black</span></span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&#x27;--line-length&#x27;</span>, <span class="string">&#x27;120&#x27;</span>]</span><br></pre></td></tr></table></figure><p>2、运行pre-commit框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-commit run --all-files</span><br></pre></td></tr></table></figure><p>3、配置commit前自动调用pre-commit框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF  &gt; .git/hooks/pre-commit</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">source $HOME/.bash_profile</span></span><br><span class="line"><span class="string">pre-commit run --all-files</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> a+x .git/hooks/pre-commit</span><br></pre></td></tr></table></figure><p>4、测试commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modify something</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;something&quot;</span></span><br></pre></td></tr></table></figure><h1 id="github-配置使用-pre-commit-框架"><span class="post-title-index">6. </span><a href="#github-配置使用-pre-commit-框架" class="headerlink" title="github 配置使用 pre-commit 框架"></a>github 配置使用 pre-commit 框架</h1><p>github actions 中，也可以配置使用 pre-commit 框架，用于检查代码规范。</p><p>项目根目录中，新建 <code>.github/workflows/pre-commit.yaml</code>，内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pre-commit</span> <span class="string">checks</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">          </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pre-commit-check:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Source</span> <span class="string">Code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Python</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">&#x27;3.9.17&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pre-commit</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">pre-commit</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Initialize</span> <span class="string">pre-commit</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">pre-commit</span> <span class="string">install</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">pre-commit</span> <span class="string">hooks</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">pre-commit</span> <span class="string">run</span> <span class="string">--all-files</span></span><br></pre></td></tr></table></figure><p>提交到github，就OK了。</p><h1 id="扩展阅读：git-hooks"><span class="post-title-index">7. </span><a href="#扩展阅读：git-hooks" class="headerlink" title="扩展阅读：git hooks"></a>扩展阅读：git hooks</h1><p>Git钩子是一些在Git执行特定操作时触发的脚本，可以用于自定义和自动化工作流程，不同的Git钩子有不同的调用时间。</p><p>客户端钩子：</p><ul><li>pre-commit：在每次提交之前运行。</li><li>pre-push：在git push之前运行。</li><li>post-commit：在每次提交之后运行。</li><li>post-checkout：在切换分支或检出文件后运行。</li><li>post-merge：在合并操作完成后运行。</li></ul><p>服务器端钩子：</p><ul><li>pre-receive：在远程仓库接收到推送前运行。</li><li>update：在远程仓库接收到推送后，对每个要更新的引用（分支或标签）运行一次。</li><li>post-receive：在远程仓库接收到推送后，对所有要更新的引用运行一次。</li></ul><p>每个项目的<code>.git/hooks</code>的目录中，看到这些钩子的官方示例。<br>示例文件以<code>.sample</code>结尾，去掉<code>.sample</code>后缀可激活该钩子脚本。</p><p>参考文档：</p><ul><li><a href="https://git-scm.com/docs/githooks">githooks - Hooks used by Git</a></li><li><a href="https://pre-commit.com/">pre-commit</a></li><li><a href="https://amos-x.com/index.php/amos/archives/pre-commit/">Git项目管理，代码规范pre-commit使用详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/65820736">用 pre-commit hook 解决 Python 项目编码规范</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;pre-commit-简介&quot;&gt;&lt;a href=&quot;#pre-commit-简介&quot; class=&quot;headerlink&quot; title=&quot;pre-commit 简介&quot;&gt;&lt;/a&gt;pre-commit 简介&lt;/h1&gt;&lt;p&gt;Git 提供了一种称为钩子（hook）的特性，帮助我们在关键时刻自动执行自定义脚本。&lt;br&gt;其中，名为 &lt;code&gt;pre-commit&lt;/code&gt; 的钩子会在每次 commit 之前运行，能够作为保障代码质量的工具。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    <category term="testing" scheme="https://www.voidking.com/categories/engineering/testing/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="测试" scheme="https://www.voidking.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions配置代码质量检查</title>
    <link href="https://www.voidking.com/dev-github-actions-code-quality-check/"/>
    <id>https://www.voidking.com/dev-github-actions-code-quality-check/</id>
    <published>2023-12-16T08:00:00.000Z</published>
    <updated>2024-01-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Gitlab CI中可以配置代码质量检查，同样的，GitHub Actions中也可以配置代码质量检查。<br>本文中，我们学习在GitHub Actions中配置Python的编码规范检查和运行单元测试。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-gitlab-ci-code-quality-check/">《GitLab CI配置代码质量检查》</a></li><li><a href="https://docs.github.com/zh/actions/automating-builds-and-tests/building-and-testing-python">GitHub Actions - 构建和测试 Python</a></li><li><a href="https://juejin.cn/s/github%20python%20coverage%20badge">github python coverage badge</a></li></ul><span id="more"></span><h1 id="Python编码规范检查"><span class="post-title-index">2. </span><a href="#Python编码规范检查" class="headerlink" title="Python编码规范检查"></a>Python编码规范检查</h1><p>详情参考 <a href="https://www.voidking.com/dev-git-pre-commit/">《git pre-commit 代码质量检查》</a>。</p><h1 id="Python单元测试"><span class="post-title-index">3. </span><a href="#Python单元测试" class="headerlink" title="Python单元测试"></a>Python单元测试</h1><h2 id="Python通用单元测试"><span class="post-title-index">3.1. </span><a href="#Python通用单元测试" class="headerlink" title="Python通用单元测试"></a>Python通用单元测试</h2><p>使用多个Python版本运行单元测试。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Python</span> <span class="string">application</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">python-version:</span> [<span class="string">&#x27;3.9&#x27;</span>, <span class="string">&#x27;3.10&#x27;</span>, <span class="string">&#x27;3.11&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">        pip install -e.</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Test</span> <span class="string">with</span> <span class="string">pytest</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        pip install pytest</span></span><br><span class="line"><span class="string">        # export OPENAI_API_KEY=&quot;$&#123;&#123; secrets.OPENAI_API_KEY &#125;&#125;&quot; OPENAI_API_MODEL=&quot;gpt-3.5-turbo-1106&quot;</span></span><br><span class="line"><span class="string">        pytest tests/ --doctest-modules --junitxml=junit/test-results-$&#123;&#123; matrix.python-version &#125;&#125;.xml</span></span><br><span class="line"><span class="string"></span>      <span class="comment"># continue-on-error: true</span></span><br></pre></td></tr></table></figure><h2 id="单测并上传单测结果"><span class="post-title-index">3.2. </span><a href="#单测并上传单测结果" class="headerlink" title="单测并上传单测结果"></a>单测并上传单测结果</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Python</span> <span class="string">application</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">python-version:</span> [<span class="string">&#x27;3.9&#x27;</span>, <span class="string">&#x27;3.10&#x27;</span>, <span class="string">&#x27;3.11&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">        pip install -e.</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Test</span> <span class="string">with</span> <span class="string">pytest</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        pip install pytest</span></span><br><span class="line"><span class="string">        pytest tests/ --doctest-modules --junitxml=junit/test-results-$&#123;&#123; matrix.python-version &#125;&#125;.xml</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">pytest</span> <span class="string">test</span> <span class="string">results</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">pytest-results-$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">junit/test-results-$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;.xml</span></span><br><span class="line">        <span class="attr">retention-days:</span> <span class="number">3</span></span><br><span class="line">      <span class="comment"># Use always() to always run this step to publish test results when there are test failures</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">always()</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Python单元测试覆盖率"><span class="post-title-index">4. </span><a href="#Python单元测试覆盖率" class="headerlink" title="Python单元测试覆盖率"></a>Python单元测试覆盖率</h1><h2 id="生成单测覆盖率并展示"><span class="post-title-index">4.1. </span><a href="#生成单测覆盖率并展示" class="headerlink" title="生成单测覆盖率并展示"></a>生成单测覆盖率并展示</h2><p>1、安装单测依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest pytest-cov coverage-badge</span><br></pre></td></tr></table></figure><p>2、生成单测覆盖率结果文件 <code>.coverage</code> 和 html 格式报告</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest tests/ --doctest-modules --cov=. --cov-report=html</span><br></pre></td></tr></table></figure><p>pytest参数说明：</p><ul><li><code>tests/</code> 指定测试文件的路径</li><li><code>--doctest-modules</code> 运行所有发现的doctest模块</li><li><code>--junitxml=junit/test-results.xml</code> 指定生成junitxml格式的测试报告</li><li><code>--cov=.</code> 生成单测覆盖率结果文件 <code>.coverage</code> 必须的参数，指定要收集哪些代码的覆盖率信息，<code>.</code> 表示收集当前目录下所有代码的覆盖率信息</li><li><code>--cov-report=html</code> 指定生成 html 格式的测试覆盖率报告，存到 htmlcov 目录中，等同于单独运行 <code>coverage html -i</code></li><li><code>--cov-report=xml</code> 指定生成 xml 格式的测试覆盖率报告，存储为 coverage.xml ，等同于单独运行 <code>coverage xml -i</code></li></ul><p>3、查看测试覆盖率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coverage report -m</span><br></pre></td></tr></table></figure><p>4、生成badge svg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coverage-badge -o coverage.svg</span><br></pre></td></tr></table></figure><p>5、github README 引用 badge</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Coverage Status</span>](<span class="link">/path/to/coverage.svg</span>)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Coverage Status</span>](<span class="link">/path/to/coverage.svg</span>)](<span class="link">https://your-badge-link</span>)</span><br></pre></td></tr></table></figure><h2 id="单测覆盖率整合到github-actions"><span class="post-title-index">4.2. </span><a href="#单测覆盖率整合到github-actions" class="headerlink" title="单测覆盖率整合到github actions"></a>单测覆盖率整合到github actions</h2><p>1、github actions配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Python</span> <span class="string">application</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">python-version:</span> [<span class="string">&#x27;3.9&#x27;</span>, <span class="string">&#x27;3.10&#x27;</span>, <span class="string">&#x27;3.11&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">        pip install -e.</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Test</span> <span class="string">with</span> <span class="string">pytest</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        pip install pytest pytest-cov pytest-html coverage-badge</span></span><br><span class="line"><span class="string">        # export OPENAI_API_KEY=&quot;$&#123;&#123; secrets.OPENAI_API_KEY &#125;&#125;&quot; OPENAI_API_MODEL=&quot;gpt-3.5-turbo-1106&quot;</span></span><br><span class="line"><span class="string">        pytest tests/ --doctest-modules --junitxml=junit/test-results-$&#123;&#123; matrix.python-version &#125;&#125;.xml --cov=. --cov-report=xml:cov.xml --cov-report=html:htmlcov</span></span><br><span class="line"><span class="string">        coverage report -m</span></span><br><span class="line"><span class="string">        coverage-badge -o coverage.svg</span></span><br><span class="line"><span class="string">        # upload coverage.svg to a object storage</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">pytest</span> <span class="string">test</span> <span class="string">results</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">pytest-results-$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          ./junit/test-results-$&#123;&#123; matrix.python-version &#125;&#125;.xml</span></span><br><span class="line"><span class="string">          ./htmlcov/</span></span><br><span class="line"><span class="string"></span>        <span class="attr">retention-days:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">always()</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>2、github README 引用 badge</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Coverage Status</span>](<span class="link">https://object-storage-domain/path/to/coverage.svg</span>)</span><br></pre></td></tr></table></figure><h2 id="忽略指定目录"><span class="post-title-index">4.3. </span><a href="#忽略指定目录" class="headerlink" title="忽略指定目录"></a>忽略指定目录</h2><p>项目更目录中，创建 coverage 配置文件 <code>.coveragerc</code> </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[run]</span><br><span class="line">omit =</span><br><span class="line">    */tests/*</span><br><span class="line">    */migrations/*</span><br><span class="line">exclude_lines =</span><br><span class="line">    # 忽略异常抛出代码</span><br><span class="line">    raise NotImplementedError</span><br><span class="line">    # 忽略抽象基类中的函数定义</span><br><span class="line">    @abstractmethod</span><br><span class="line">    # 忽略带有pragma: no cover注释的行</span><br><span class="line">    pragma: no cover</span><br></pre></td></tr></table></figure><p>omit 用于指定不应该包含在覆盖率统计中的文件或目录，exclude_lines 用于指定不应该包含在覆盖率统计中的代码行。</p><h2 id="使用Codecov"><span class="post-title-index">4.4. </span><a href="#使用Codecov" class="headerlink" title="使用Codecov"></a>使用Codecov</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">coverage</span> <span class="string">to</span> <span class="string">Codecov</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">codecov/codecov-action@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.CODECOV_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">file:</span> <span class="string">./cov.xml</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">always()</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="PR单测审批"><span class="post-title-index">5. </span><a href="#PR单测审批" class="headerlink" title="PR单测审批"></a>PR单测审批</h1><p>用户提交PR后，想要触发审批，配置是很简单的，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br></pre></td></tr></table></figure><p>但是，如果我们在workflow中用到了secret，那配置就没有这么简单了。<br>因为github限制了<code>pull_request</code>触发的workflow读取secret的权限，所以副本仓库提交到主仓库的pr，读取不到主仓库secret。<br>这是一种对主仓库secret的保护，详情参考文档<a href="https://stackoverflow.com/questions/73866908/github-actions-main-repository-secret-not-picked-up-from-pull-request-build">github actions main repository secret not picked up from pull request build</a></p><p>如果确实需要让pr的workflow读取到secret，该怎么处理？<a href="https://securitylab.github.com/research/github-actions-preventing-pwn-requests/">Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests</a> 这篇文章提供了两种方法可供参考。<br>方法一：pr事件触发workflow1，workflow1结束事件触发workflow2，此时workflow2就有权限读取secret了。但是，这种方法中，workflow1和workflow2之间缺少直观的关联，在pr页面和github actions页面上都看不出来联系，不友好。<br>方法二：使用 <code>pull_request_target</code> 代替 <code>pull_request</code> ，此时触发的workflow有权限读取secret。配置简单，页面也能直观看到，但是，这种方法降低了安全性。</p><p>方法一和方法二各有优劣，个人更推荐方法二，因为方法二可以配合<code>environment</code>加一道审批，增强安全性，弥补缺陷。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request_target:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">unittest</span></span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure><p><code>pull_request</code> 和 <code>pull_request_target</code> 是有很大区别的，<a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target">Events that trigger workflows - pull_request_target</a> 文档中说：</p><blockquote><p>This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. </p></blockquote><p>个人理解为：<code>pull_request</code> 的workflow是根据pr合并后的workflow yaml运行，而<code>pull_request_target</code> 的workflow是根据pr合并前的workflow yaml运行的，详情参考文档：<a href="https://stackoverflow.com/questions/74957218/what-is-the-difference-between-pull-request-and-pull-request-target-event-in-git">What is the difference between pull_request and pull_request_target event in GitHubActions</a></p><p>注意：如果一个pr中修改了 workflow ，那么在github actions页面看到的 workflow yaml 就是修改后的。但是如果是<code>pull_request_target</code> 事件触发的workflow，那么虽然看到了修改后的yaml，实际执行会按照修改前的yaml执行。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Gitlab CI中可以配置代码质量检查，同样的，GitHub Actions中也可以配置代码质量检查。&lt;br&gt;本文中，我们学习在GitHub Actions中配置Python的编码规范检查和运行单元测试。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-gitlab-ci-code-quality-check/&quot;&gt;《GitLab CI配置代码质量检查》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/zh/actions/automating-builds-and-tests/building-and-testing-python&quot;&gt;GitHub Actions - 构建和测试 Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/s/github%20python%20coverage%20badge&quot;&gt;github python coverage badge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    <category term="testing" scheme="https://www.voidking.com/categories/engineering/testing/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="github" scheme="https://www.voidking.com/tags/github/"/>
    
    <category term="测试" scheme="https://www.voidking.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker安装配置青龙面板</title>
    <link href="https://www.voidking.com/dev-docker-qinglong/"/>
    <id>https://www.voidking.com/dev-docker-qinglong/</id>
    <published>2023-12-09T08:00:00.000Z</published>
    <updated>2023-12-16T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="青龙面板简介"><span class="post-title-index">1. </span><a href="#青龙面板简介" class="headerlink" title="青龙面板简介"></a>青龙面板简介</h1><blockquote><p>青龙面板是一个支持 Python3、JavaScript、Shell、Typescript 的定时任务管理平台</p></blockquote><p>Linux自带的crontab可以配置定时任务，但是并不方便。而使用青龙面板，能够可视化配置定时任务，简单快捷。<br>本文中，我们学习一下青龙面板的安装配置，试一试签到薅羊毛。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-linux-crontab/">《Linux设置定时任务》</a></li><li><a href="https://github.com/whyour/qinglong">github - whyour/qinglong</a></li><li><a href="https://zhuanlan.zhihu.com/p/664671254">利用拾光坞开启青龙面板薅羊毛（保姆级教程）</a></li></ul><span id="more"></span><h1 id="安装青龙版面"><span class="post-title-index">2. </span><a href="#安装青龙版面" class="headerlink" title="安装青龙版面"></a>安装青龙版面</h1><p>1、下载<a href="https://hub.docker.com/r/whyour/qinglong">青龙面板Docker镜像</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull whyour/qinglong:debian</span><br></pre></td></tr></table></figure><p>2、启动青龙面板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name qinglong -d \</span><br><span class="line">  -p 5700:5700 \</span><br><span class="line">  -v /opt/ql/data:/ql/data \</span><br><span class="line">  -e QlBaseUrl=<span class="string">&quot;/&quot;</span> \</span><br><span class="line">  -e QlPort=<span class="string">&quot;5700&quot;</span> \</span><br><span class="line">  --hostname qinglong \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  whyour/qinglong:debian</span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为qinglong，后台运行</li><li>映射宿主机5700端口到容器的5700</li><li>挂载宿主机文件 /opt/ql/data 到容器目录 /ql/data</li><li>设置环境变量 QlBaseUrl 和 QlPort，青龙面板服务启动时使用</li><li>设置容器主机名为 qinglong</li><li>设置容器随docker启动自动启动</li></ul><p>3、验证安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker logs qinglong</span><br></pre></td></tr></table></figure><p>4、登录进容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it qinglong /bin/bash</span><br></pre></td></tr></table></figure><p>5、web访问青龙面板<br>浏览器访问 <code>http:&lt;ip&gt;:5700</code><br>初次访问时，会提示进行初始化配置。</p><h1 id="内置命令"><span class="post-title-index">3. </span><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h1><h2 id="task"><span class="post-title-index">3.1. </span><a href="#task" class="headerlink" title="task"></a>task</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依次执行，如果设置了随机延迟，将随机延迟一定秒数</span></span><br><span class="line">task &lt;file_path&gt;                                             </span><br><span class="line"><span class="comment"># 依次执行，无论是否设置了随机延迟，均立即运行，前台会输出日，同时记录在日志文件中</span></span><br><span class="line">task &lt;file_path&gt; now                                         </span><br><span class="line"><span class="comment"># 并发执行，无论是否设置了随机延迟，均立即运行，前台不产生日，直接记录在日志文件中，且可指定账号执行</span></span><br><span class="line">task &lt;file_path&gt; conc &lt;env_name&gt; &lt;account_number&gt;(可选的) </span><br><span class="line"><span class="comment"># 指定账号执行，无论是否设置了随机延迟，均立即运行 </span></span><br><span class="line">task &lt;file_path&gt; desi &lt;env_name&gt; &lt;account_number&gt;      </span><br><span class="line"><span class="comment"># 设置任务超时时间   </span></span><br><span class="line">task -m &lt;max_time&gt; &lt;file_path&gt;</span><br><span class="line"><span class="comment"># 使用 -- 分割，-- 后面的参数会传给脚本，下面的例子，脚本就可接收到参数 -u whyour -p password</span></span><br><span class="line">task &lt;file_path&gt; -- -u whyour -p password</span><br></pre></td></tr></table></figure><h2 id="ql"><span class="post-title-index">3.2. </span><a href="#ql" class="headerlink" title="ql"></a>ql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新并重启青龙</span></span><br><span class="line">ql update</span><br><span class="line"><span class="comment"># 运行自定义脚本extra.sh</span></span><br><span class="line">ql extra</span><br><span class="line"><span class="comment"># 添加单个脚本文件</span></span><br><span class="line">ql raw &lt;file_url&gt;</span><br><span class="line"><span class="comment"># 添加单个仓库的指定脚本</span></span><br><span class="line">ql repo &lt;repo_url&gt; &lt;whitelist&gt; &lt;blacklist&gt; &lt;dependence&gt; &lt;branch&gt; &lt;extensions&gt;</span><br><span class="line"><span class="comment"># 删除旧日志</span></span><br><span class="line">ql rmlog &lt;days&gt;</span><br><span class="line"><span class="comment"># 启动tg-bot</span></span><br><span class="line">ql bot</span><br><span class="line"><span class="comment"># 检测青龙环境并修复</span></span><br><span class="line">ql check</span><br><span class="line"><span class="comment"># 重置登录错误次数</span></span><br><span class="line">ql resetlet                                                  </span><br><span class="line"><span class="comment"># 禁用两步登录</span></span><br><span class="line">ql resettfa</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>file_url: 脚本地址</li><li>repo_url: 仓库地址</li><li>whitelist: 拉取仓库时的白名单，即就是需要拉取的脚本的路径包含的字符串，多个竖线分割</li><li>blacklist: 拉取仓库时的黑名单，即就是需要拉取的脚本的路径不包含的字符串，多个竖线分割</li><li>dependence: 拉取仓库需要的依赖文件，会直接从仓库拷贝到scripts下的仓库目录，不受黑名单影响，多个竖线分割</li><li>extensions: 拉取仓库的文件后缀，多个竖线分割</li><li>branch: 拉取仓库的分支</li><li>days: 需要保留的日志的天数</li><li>file_path: 任务执行时的文件路径</li><li>env_name: 任务执行时需要并发或者指定时的环境变量名称</li><li>account_number: 任务执行时指定某个环境变量需要执行的账号序号</li><li>max_time: 超时时间，后缀”s”代表秒(默认值), “m”代表分, “h”代表小时, “d”代表天</li></ul><h1 id="配置青龙面板"><span class="post-title-index">4. </span><a href="#配置青龙面板" class="headerlink" title="配置青龙面板"></a>配置青龙面板</h1><h2 id="配置支持更多脚本类型"><span class="post-title-index">4.1. </span><a href="#配置支持更多脚本类型" class="headerlink" title="配置支持更多脚本类型"></a>配置支持更多脚本类型</h2><p>点击左侧配置文件，找到 <code>RepoFileExtensions=&quot;js py&quot;</code> ，修改为 <code>RepoFileExtensions=&quot;js py sh ts&quot;</code>，右上角保存。</p><p>点击左侧对比工具，对比修改前后的变化。</p><h2 id="安装脚本需要的依赖"><span class="post-title-index">4.2. </span><a href="#安装脚本需要的依赖" class="headerlink" title="安装脚本需要的依赖"></a>安装脚本需要的依赖</h2><p>点击左侧依赖管理，创建依赖，名称一栏中输入脚本可能需要的依赖，多个依赖换行输入，点击确定即可下载安装依赖。</p><h2 id="配置面板通知"><span class="post-title-index">4.3. </span><a href="#配置面板通知" class="headerlink" title="配置面板通知"></a>配置面板通知</h2><p>点击左侧通知设置，选择一个通知方式，根据提示填入必要的信息，保存。<br>建议使用飞书机器人，配置最简单：飞书群里新建一个自定义机器人，把webhook地址的最后一段粘贴到larkKey即可。</p><h2 id="配置脚本通知"><span class="post-title-index">4.4. </span><a href="#配置脚本通知" class="headerlink" title="配置脚本通知"></a>配置脚本通知</h2><p>青龙面板设置里的那个只是用来面板级别的通知，比如订阅更新。而脚本里的通知，需要在配置文件里去配置的。详情参考文档<a href="https://github.com/mrabit/aliyundriveDailyCheck/issues/141">如何设置任务执行完毕后发送通知</a></p><p>1、微信登录 <a href="https://sct.ftqq.com/sendkey">Server酱</a>，获取一个SendKey，测试通知</p><p>2、点击左侧配置文件，找到 <code>PUSH_KEY</code> ，填入上一步获取到的 SendKey，保存</p><h2 id="配置代理"><span class="post-title-index">4.5. </span><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>点击左侧环境变量，添加两个关于代理的环境变量。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://192.168.5.233:20171</span><br><span class="line">https_proxy=http://192.168.5.233:20171</span><br></pre></td></tr></table></figure><p>之所以要配置代理，是因为很多订阅是从github拉取的，而github从国内访问是需要科学上网的，因此最好配置一下代理。<br>这两个代理变量，平时禁用，拉取订阅时启用。</p><h1 id="配置签到任务"><span class="post-title-index">5. </span><a href="#配置签到任务" class="headerlink" title="配置签到任务"></a>配置签到任务</h1><h2 id="阿里云盘签到"><span class="post-title-index">5.1. </span><a href="#阿里云盘签到" class="headerlink" title="阿里云盘签到"></a>阿里云盘签到</h2><p>参考文档：<a href="https://github.com/mrabit/aliyundriveDailyCheck">github - mrabit/aliyundriveDailyCheck</a></p><p>1、获取阿里云盘 refresh_token<br>web登录阿里云盘后，控制台粘贴</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">copy</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="property">token</span>).<span class="property">refresh_token</span>); <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="property">token</span>).<span class="property">refresh_token</span>);</span><br></pre></td></tr></table></figure><p>2、青龙面板添加环境变量 refreshToken<br>如果有多个账号要签到，那就添加多个refreshToken。</p><p>3、安装js依赖</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br></pre></td></tr></table></figure><p>4、添加订阅</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/mrabit/aliyundriveDailyCheck.git <span class="string">&quot;autoSignin&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;qlApi&quot;</span></span><br></pre></td></tr></table></figure><p>添加订阅后，点击运行，即可从github拉取定时任务。拉取成功之后，建议禁用订阅。</p><p>5、配置定时任务<br>点击定时任务页面，找到 autoSignin.js 任务，点击运行，测试运行。<br>测试没有问题，编辑定时任务，设置一个合适的运行时间。</p><p>6、配置自动更新 refreshToken<br>系统设置，应用设置，创建一个应用 autoSignin（名称随意）。<br>autoSignin 应用的 CLIENT_ID 和 CLIENT_SECRET 配置到环境变量中。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;青龙面板简介&quot;&gt;&lt;a href=&quot;#青龙面板简介&quot; class=&quot;headerlink&quot; title=&quot;青龙面板简介&quot;&gt;&lt;/a&gt;青龙面板简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;青龙面板是一个支持 Python3、JavaScript、Shell、Typescript 的定时任务管理平台&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux自带的crontab可以配置定时任务，但是并不方便。而使用青龙面板，能够可视化配置定时任务，简单快捷。&lt;br&gt;本文中，我们学习一下青龙面板的安装配置，试一试签到薅羊毛。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-linux-crontab/&quot;&gt;《Linux设置定时任务》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/whyour/qinglong&quot;&gt;github - whyour/qinglong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/664671254&quot;&gt;利用拾光坞开启青龙面板薅羊毛（保姆级教程）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>个人电脑作为Ubuntu服务器</title>
    <link href="https://www.voidking.com/dev-pc-as-ubuntu-server/"/>
    <id>https://www.voidking.com/dev-pc-as-ubuntu-server/</id>
    <published>2023-12-02T08:00:00.000Z</published>
    <updated>2023-12-02T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近买了个85寸电视，就想搞个NAS。<br>看了看价格，绿联NAS DX4600 2000左右，蜗牛星际NAS 1000左右，硬盘还需要另外购买。贫穷，让我想到了废弃已久的华为荣耀笔记本电脑。<br>要不然，用它作为NAS？还可以作为软路由？还可以部署Nginx、Jupyter、ChatGPT代理等常用服务，还可以参考 <a href="https://github.com/awesome-selfhosted/awesome-selfhosted">Awesome-Selfhosted</a> 部署更多有趣的项目，想想还挺不错。搞起来！</p><span id="more"></span><h1 id="NAS与软路由简介"><span class="post-title-index">2. </span><a href="#NAS与软路由简介" class="headerlink" title="NAS与软路由简介"></a>NAS与软路由简介</h1><blockquote><p>NAS，全称为网络附属存储(Network Attached Storage)，是一种专门的网络存储设备。NAS 设备通过网络直接连接到其他设备，用户可以随时随地通过网络存取NAS中的数据。<br>NAS设备的主要功能是提供数据存储和备份，同时还可能有流媒体服务、打印服务等其他功能。NAS设备可用于家庭和企业，帮助实现数据共享和存储管理，特别在企业场景下，NAS可以优化数据备份、共享和远程访问等业务流程。</p></blockquote><blockquote><p>软路由是指使用普通计算机和路由软件实现的具有路由功能的设备。与一般的硬件路由器不同，软路由器可以运行在商用操作系统上，并由用户自定义和配置，以满足特定网络环境和应用的需求。软路由可以提供诸如路由转发、防火墙、VPN、流量管理等多种功能。</p></blockquote><p>NAS和软路由一体化设备，就是同时实现网络路由和数据存储功能的设备。它既能提供网络路由和防火墙等网络服务，又能提供文件共享和数据备份等存储服务。以下是几种常见的一体化方案：</p><ul><li>在通用Linux系统中安装NAS软件和路由软件。通用Linux系统中（如Ubuntu、CentOS），安装NAS软件来实现存储功能，安装路由软件来实现路由功能。</li><li>在NAS系统中安装路由软件。NAS系统中（如FreeNAS、OpenMediaVault），安装路由软件来实现路由功能。</li><li>在软路由系统中安装NAS软件。软路由系统中（如OpenWrt、pfSense、OPNsense），安装NAS软件来实现存储功能。</li><li>虚拟化技术。在主机上创建两个虚拟机，分别安装软路由系统和NAS系统；或者使用Docker，运行软路由系统和NAS系统。</li><li>商业一体化设备。一些厂商推出了一体化的软路由NAS设备，如华硕的RT-AC86U、群晖的DS216j等。这些设备可以同时实现软路由和NAS的功能，方便用户快速搭建家庭网络。</li></ul><p>参考文档：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/592292837">软路由/NAS - All in one(非虚拟化)方案</a></li><li><a href="https://nas.xiaosiseo.com/post/12295.html">软路由NAS一体方案：打造智能物联网家庭网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/411161467">NFS、FTP、SMB、WebDav、DLNA协议，傻傻分不清？</a></li><li><a href="https://zhuanlan.zhihu.com/p/104639279">从听说到上手，人人都能看懂的软路由入门指南</a></li><li><a href="https://zh.wikipedia.org/wiki/OpenWrt">Wikipedia - OpenWrt</a></li></ul><h1 id="安装Ubuntu系统"><span class="post-title-index">3. </span><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h1><p>参考文档：<a href="https://ubuntu.com/tutorials/create-a-usb-stick-on-macos#1-overview">Create a bootable USB stick on macOS</a></p><p>1、服务器系统选择 <a href="https://releases.ubuntu.com/18.04.6/">ubuntu-18.04.6-desktop-amd64.iso</a><br>之所以选择desktop版，是因为desktop版是图形化界面，初始化配置很方便。后期不想要desktop的话，可以卸载掉。</p><p>2、使用<a href="https://etcher.balena.io/">balenaEtcher</a>制作一个U盘启动盘</p><p>3、笔记本插入U盘，开机选择从U盘启动</p><p>4、根据提示安装Ubuntu系统</p><h1 id="初始化Ubuntu系统"><span class="post-title-index">4. </span><a href="#初始化Ubuntu系统" class="headerlink" title="初始化Ubuntu系统"></a>初始化Ubuntu系统</h1><h2 id="配置固定IP"><span class="post-title-index">4.1. </span><a href="#配置固定IP" class="headerlink" title="配置固定IP"></a>配置固定IP</h2><p>图形界面配置。</p><p>或者参考<a href="https://www.voidking.com/dev-ubuntu18-static-ip/">《Ubuntu18配置静态IP》</a>，使用命令行配置。</p><h2 id="配置合上屏幕不休眠"><span class="post-title-index">4.2. </span><a href="#配置合上屏幕不休眠" class="headerlink" title="配置合上屏幕不休眠"></a>配置合上屏幕不休眠</h2><p>1、编辑logind配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure><p>修改其中的配置为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandleLidSwitch=ignore</span><br></pre></td></tr></table></figure><p>HandleLidSwitch是指笔记本屏幕合起来，设置为ignore，也就是笔记本屏幕合起来时不进行任何改变。</p><p>2、重启 systemd-logind</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart systemd-logind</span><br></pre></td></tr></table></figure><h1 id="安装配置Samba"><span class="post-title-index">5. </span><a href="#安装配置Samba" class="headerlink" title="安装配置Samba"></a>安装配置Samba</h1><h2 id="安装Samba"><span class="post-title-index">5.1. </span><a href="#安装Samba" class="headerlink" title="安装Samba"></a>安装Samba</h2><p>1、安装Samba</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install samba</span><br></pre></td></tr></table></figure><p>2、查看Samba服务状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nmbd</span><br></pre></td></tr></table></figure><h2 id="配置Samba"><span class="post-title-index">5.2. </span><a href="#配置Samba" class="headerlink" title="配置Samba"></a>配置Samba</h2><p>1、创建共享目录并设置权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /data/samba/video</span><br><span class="line"><span class="built_in">chgrp</span> sambashare /data/samba</span><br><span class="line"><span class="built_in">chgrp</span> sambashare /data/samba/video</span><br><span class="line"><span class="built_in">chmod</span> 2770 /data/samba/video</span><br></pre></td></tr></table></figure><p>用户组sambashare是在安装Samba过程中自动创建的。</p><p>3、创建samba用户并授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -s /usr/sbin/nologin -G sambashare samba</span><br><span class="line">smbpasswd -a samba</span><br></pre></td></tr></table></figure><p>Samba权限控制使用Linux用户和组的权限系统，但具有自己的身份验证机制，与标准Linux身份验证分开。</p><p>4、配置共享目录和用户<br>编辑samba配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在文件最后添加：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[video]</span><br><span class="line">    path = /data/samba/video</span><br><span class="line">    browseable = yes</span><br><span class="line">    read only = no</span><br><span class="line">    force create mode = 0660</span><br><span class="line">    force directory mode = 2770</span><br><span class="line">    valid users = @sambashare @sadmin</span><br><span class="line"></span><br><span class="line">#[doc]</span><br><span class="line">#    path = /data/samba/doc</span><br><span class="line">#    browseable = no</span><br><span class="line">#    read only = yes</span><br><span class="line">#    force create mode = 0660</span><br><span class="line">#    force directory mode = 2770</span><br><span class="line">#    valid users = samba @sambashare</span><br></pre></td></tr></table></figure><p>配置说明：</p><ul><li><code>[video]</code> 和 <code>[doc]</code> 表示登录时使用的共享名称。</li><li><code>path</code> 表示共享的目录。</li><li><code>browseable</code> 表示可浏览，是否可在共享列表中列出此共享。如果设置为no，其他用户将看不到共享目录。</li><li><code>read only</code> 表示valid users列表中指定的用户是否设置仅允许读，如果值yes，则仅允许读。</li><li><code>force create mode</code> 表示此共享创建文件时设置的文件权限模式。</li><li><code>force directory mode</code> 表示此共享创建目录时设置目录权限的模式。</li><li><code>valid users</code> 表示允许访问共享的用户和组的列表。群组以<code>@</code>符号为前缀。</li></ul><p>更多配置选项，请参考文档 <a href="https://www.samba.org/samba/docs/current/man-html/smb.conf.5.html">smb.conf — The configuration file for the Samba suite</a></p><p>5、重启samba</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nmbd</span><br><span class="line">systemctl status nmbd</span><br></pre></td></tr></table></figure><h2 id="测试使用Samba"><span class="post-title-index">5.3. </span><a href="#测试使用Samba" class="headerlink" title="测试使用Samba"></a>测试使用Samba</h2><p>1、安装 samba client</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install smbclient</span><br></pre></td></tr></table></figure><p>2、创建测试文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> test.txt</span><br></pre></td></tr></table></figure><p>3、连接samba server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient //192.168.5.233/users -U samba</span><br></pre></td></tr></table></figure><p>4、上传下载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smb: \&gt; <span class="built_in">ls</span></span><br><span class="line">smb: \&gt; put test.txt test.txt</span><br><span class="line">smb: \&gt; get test.txt test2.txt</span><br><span class="line">smb: \&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>下载文件时，还可以使用smbget工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbget -U samba smb://192.168.5.233/video/test.txt -o test3.txt</span><br></pre></td></tr></table></figure><h2 id="配置防火墙"><span class="post-title-index">5.4. </span><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw allow <span class="string">&#x27;Samba&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="本地挂载阿里云盘"><span class="post-title-index">6. </span><a href="#本地挂载阿里云盘" class="headerlink" title="本地挂载阿里云盘"></a>本地挂载阿里云盘</h1><h2 id="安装Docker"><span class="post-title-index">6.1. </span><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>参考文档：<a href="https://www.voidking.com/dev-docker-start/">《Docker入门篇》</a></p><h2 id="获取阿里云盘refresh-token"><span class="post-title-index">6.2. </span><a href="#获取阿里云盘refresh-token" class="headerlink" title="获取阿里云盘refresh token"></a>获取阿里云盘refresh token</h2><p>参考文档<a href="https://hub.docker.com/r/messense/aliyundrive-webdav">dockerhub - messense/aliyundrive-webdav</a>，<a href="https://messense-aliyundrive-webdav-backendrefresh-token-ucs0wn.streamlit.app/">通过在线工具获取 refresh token</a>。</p><p>以前通过浏览器自行获取refresh token的方法已失效，详情参考 <a href="https://github.com/messense/aliyundrive-webdav/discussions/900">Error: Invalid refresh token value found in –refresh-token argument</a>。</p><h2 id="启动阿里云盘webdav容器"><span class="post-title-index">6.3. </span><a href="#启动阿里云盘webdav容器" class="headerlink" title="启动阿里云盘webdav容器"></a>启动阿里云盘webdav容器</h2><p>1、拉取webdav镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull messense/aliyundrive-webdav:2.3.3</span><br></pre></td></tr></table></figure><p>2、启动webdav容器（本地文件服务器）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=aliyundrive-webdav \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -e REFRESH_TOKEN=<span class="string">&#x27;your token&#x27;</span> \</span><br><span class="line">  -e WEBDAV_AUTH_USER=admin \</span><br><span class="line">  -e WEBDAV_AUTH_PASSWORD=admin\</span><br><span class="line">  messense/aliyundrive-webdav:2.3.3</span><br></pre></td></tr></table></figure><p>3、查看webdav容器状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker logs aliyundrive-webdav</span><br></pre></td></tr></table></figure><h2 id="挂载阿里云盘"><span class="post-title-index">6.4. </span><a href="#挂载阿里云盘" class="headerlink" title="挂载阿里云盘"></a>挂载阿里云盘</h2><p>1、安装webdav驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y davfs2</span><br></pre></td></tr></table></figure><p>2、创建挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /data/aliyundrive</span><br></pre></td></tr></table></figure><p>3、挂载阿里云盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t davfs http://192.168.5.233:8080/ /data/aliyundrive</span><br></pre></td></tr></table></figure><p>4、查看挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/aliyundrive</span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><h2 id="通过samba共享"><span class="post-title-index">6.5. </span><a href="#通过samba共享" class="headerlink" title="通过samba共享"></a>通过samba共享</h2><p>本地目录挂载阿里云盘后，和其他普通目录一样，也可以通过samba共享给其他主机。<br>samba配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[aliyundrive]</span><br><span class="line">    path = /data/aliyundrive</span><br><span class="line">    browseable = yes</span><br><span class="line">    read only = yes</span><br><span class="line">    valid users = @sambashare @sadmin</span><br></pre></td></tr></table></figure><h2 id="拷贝阿里云盘中的文件到本地"><span class="post-title-index">6.6. </span><a href="#拷贝阿里云盘中的文件到本地" class="headerlink" title="拷贝阿里云盘中的文件到本地"></a>拷贝阿里云盘中的文件到本地</h2><p>如果担心访问阿里云盘时候的网络不稳定，可以把一部分文件下载到本地磁盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen rsync -P -azv <span class="string">&#x27;爱情公寓&#x27;</span> /data/samba/video</span><br></pre></td></tr></table></figure><p>下载速度很快，家庭千兆宽带大概平均 10MB/s，峰值 30MB/s。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近买了个85寸电视，就想搞个NAS。&lt;br&gt;看了看价格，绿联NAS DX4600 2000左右，蜗牛星际NAS 1000左右，硬盘还需要另外购买。贫穷，让我想到了废弃已久的华为荣耀笔记本电脑。&lt;br&gt;要不然，用它作为NAS？还可以作为软路由？还可以部署Nginx、Jupyter、ChatGPT代理等常用服务，还可以参考 &lt;a href=&quot;https://github.com/awesome-selfhosted/awesome-selfhosted&quot;&gt;Awesome-Selfhosted&lt;/a&gt; 部署更多有趣的项目，想想还挺不错。搞起来！&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="ubuntu" scheme="https://www.voidking.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>CentOS救援模式使用说明</title>
    <link href="https://www.voidking.com/dev-centos-rescue-mode/"/>
    <id>https://www.voidking.com/dev-centos-rescue-mode/</id>
    <published>2023-10-14T08:00:00.000Z</published>
    <updated>2023-10-14T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当CentOS系统崩溃无法正常启动时，往往需要进入救援模式进行恢复。<br>本文中，我们学习一下CentOS救援模式的使用方法。</p><p>参考文档：</p><ul><li><a href="https://blog.csdn.net/hdyebd/article/details/83754257">Linux紧急救援模式(Centos7) </a></li><li><a href="https://blog.csdn.net/hp_log/article/details/126967463">centos 8 进入紧急救援模式</a></li><li><a href="https://docs.centos.org/en-US/centos/install-guide/Rescue_Mode/">Basic System Recovery</a></li></ul><span id="more"></span><h1 id="进入救援模式"><span class="post-title-index">2. </span><a href="#进入救援模式" class="headerlink" title="进入救援模式"></a>进入救援模式</h1><h2 id="自带救援模式"><span class="post-title-index">2.1. </span><a href="#自带救援模式" class="headerlink" title="自带救援模式"></a>自带救援模式</h2><p>1、开机启动，在出现内核选项时按下 <code>e</code> 进入编辑</p><p>2、添加内核参数<br>centos7找到 <code>linux16</code> 开头的行并在行尾添加内核参数 <code>rd.break</code><br>centos8找到 <code>linux</code> 开头的行并在行尾添加内核参数 <code>rd.break</code></p><p>3、并按 <code>ctrl+x</code> 进入单用户模式 </p><p>4、挂载并更改根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount –o remount,rw /sysroot </span><br><span class="line"><span class="built_in">chroot</span> /sysroot </span><br></pre></td></tr></table></figure><h2 id="第三方系统救援模式"><span class="post-title-index">2.2. </span><a href="#第三方系统救援模式" class="headerlink" title="第三方系统救援模式"></a>第三方系统救援模式</h2><p>1、插入包含CentOS系统的光盘或者U盘</p><p>2、开机启动，按下F12，选择从光盘或者U盘启动</p><p>3、启动后选择 Troubleshooting，Rescue a CentOS system</p><h1 id="更改root密码"><span class="post-title-index">3. </span><a href="#更改root密码" class="headerlink" title="更改root密码"></a>更改root密码</h1><p>1、进入自带救援模式</p><p>2、操作修改root密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">passwd root </span><br><span class="line"><span class="built_in">touch</span> /.autorelabel </span><br><span class="line"><span class="built_in">exit</span> </span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="修复grub"><span class="post-title-index">4. </span><a href="#修复grub" class="headerlink" title="修复grub"></a>修复grub</h1><p>问题原因：<code>rm /boot/grub* -rf</code><br>问题表现：启动时出现报错 error: file ‘/grub2/i386-pc/normal.mod’ not found.</p><p>1、进入第三方系统救援模式</p><p>2、更改根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mnt/sysimage</span><br><span class="line"><span class="built_in">rm</span> /boot/grub* -rf</span><br><span class="line"><span class="built_in">ls</span> /boot</span><br><span class="line"><span class="built_in">mkdir</span> /boot/grub2</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">grub2-install /dev/sda</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="修复-boot"><span class="post-title-index">5. </span><a href="#修复-boot" class="headerlink" title="修复/boot"></a>修复/boot</h1><p>问题原因：<code>rm /boot/* -rf</code><br>问题表现：启动时出现报错 error: file ‘/grub2/i386-pc/normal.mod’ not found.</p><p>1、进入第三方系统救援模式</p><p>2、更改根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mnt/sysimage</span><br><span class="line"><span class="built_in">ls</span> /boot</span><br><span class="line">mount /dev/sr0 /mnt </span><br><span class="line">rpm -ivh /mnt/Packages/kernel-3.10.0-693.e17.x86_64.rpm.rpm --force</span><br><span class="line"><span class="built_in">ls</span> /boot</span><br><span class="line">grub2-install /dev/sda</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;当CentOS系统崩溃无法正常启动时，往往需要进入救援模式进行恢复。&lt;br&gt;本文中，我们学习一下CentOS救援模式的使用方法。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hdyebd/article/details/83754257&quot;&gt;Linux紧急救援模式(Centos7) &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hp_log/article/details/126967463&quot;&gt;centos 8 进入紧急救援模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.centos.org/en-US/centos/install-guide/Rescue_Mode/&quot;&gt;Basic System Recovery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="centos" scheme="https://www.voidking.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>网络排查工具MTR入门篇</title>
    <link href="https://www.voidking.com/dev-mtr-start/"/>
    <id>https://www.voidking.com/dev-mtr-start/</id>
    <published>2023-10-05T08:00:00.000Z</published>
    <updated>2023-10-05T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MTR简介"><span class="post-title-index">1. </span><a href="#MTR简介" class="headerlink" title="MTR简介"></a>MTR简介</h1><p>网络排查工程常常包含了诊断网络中断和稳定性问题。在这些场合下，网络工程师们通常会使用一些有效的网络工具来帮助他们准确地查找问题所在。其中，MTR是一款极其实用的网络诊断工具。</p><p>MTR，全名为My Traceroute，是一款网络诊断工具，结合了traceoute和ping两种常见工具的功能。通过源自源主机到目标主机的网络连接的持续跟踪，MTR能提供每个路由节点的响应速度和系统稳定性情况。</p><p>参考文档：</p><ul><li><a href="https://www.starcto.com/nettool/306.html">关于网络排查工具MTR那些你必须了解的事情</a></li><li><a href="https://cloud.tencent.com/document/product/213/14638">使用 MTR 分析网络延迟及丢包</a></li><li><a href="https://cloud.tencent.com/document/product/213/57336">云服务器网络访问丢包</a></li></ul><span id="more"></span><h1 id="安装MTR"><span class="post-title-index">2. </span><a href="#安装MTR" class="headerlink" title="安装MTR"></a>安装MTR</h1><p>MTR是开源的，我们可以在大多数的Linux发行版中找到它。</p><p>在Ubuntu或Debian系统中，我们可以通过下列命令来进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mtr</span><br></pre></td></tr></table></figure><p>如果我们正在使用CentOS或者Fedora，可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mtr</span><br></pre></td></tr></table></figure><h1 id="运行MTR"><span class="post-title-index">3. </span><a href="#运行MTR" class="headerlink" title="运行MTR"></a>运行MTR</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr 192.168.56.101</span><br></pre></td></tr></table></figure><p>运行后，MTR将运行统计报告，展示当前主机到目标主机的每一跳联网情况。</p><p>运行结果的主要信息如下：</p><ul><li>Hostname：到目的服务器要经过的每个主机 IP 或名称。</li><li>Nr：经过节点的数量。</li><li>Loss%：对应节点的丢包率。</li><li>Sent：发送的数据包数量。</li><li>Recv：接收到响应的数量。</li><li>Best：最短的响应时间。</li><li>Avrg：平均响应时间。</li><li>Worst：最长的响应时间。</li><li>Last：最近一次的响应时间。</li></ul><p>在MTR运行时，我们能看到各路由节点的丢包率，如果某一跳的丢包率很高，那么这就可能是网络问题的所在。<br>大多数情况，只需要关注最后一跳（目的地址）是否有丢包即可。</p><p>此外，MTR并不仅仅提供实时的网络连接状态，还可以通过生成报告的方式保存网络状态。<br>通过在命令后添加”–report”，MTR将在运行一定时间后生成一个报告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr --report 192.168.56.101</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MTR简介&quot;&gt;&lt;a href=&quot;#MTR简介&quot; class=&quot;headerlink&quot; title=&quot;MTR简介&quot;&gt;&lt;/a&gt;MTR简介&lt;/h1&gt;&lt;p&gt;网络排查工程常常包含了诊断网络中断和稳定性问题。在这些场合下，网络工程师们通常会使用一些有效的网络工具来帮助他们准确地查找问题所在。其中，MTR是一款极其实用的网络诊断工具。&lt;/p&gt;
&lt;p&gt;MTR，全名为My Traceroute，是一款网络诊断工具，结合了traceoute和ping两种常见工具的功能。通过源自源主机到目标主机的网络连接的持续跟踪，MTR能提供每个路由节点的响应速度和系统稳定性情况。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.starcto.com/nettool/306.html&quot;&gt;关于网络排查工具MTR那些你必须了解的事情&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/document/product/213/14638&quot;&gt;使用 MTR 分析网络延迟及丢包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/document/product/213/57336&quot;&gt;云服务器网络访问丢包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    <category term="shell" scheme="https://www.voidking.com/categories/engineering/shell/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="网络" scheme="https://www.voidking.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7内核升级</title>
    <link href="https://www.voidking.com/dev-centos7-kernal-upgrade/"/>
    <id>https://www.voidking.com/dev-centos7-kernal-upgrade/</id>
    <published>2023-09-09T08:00:00.000Z</published>
    <updated>2023-10-05T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文学习并实践CentOS7内核升级方法，备忘。</p><p>参考文档：</p><ul><li><a href="https://www.zhihu.com/tardis/zm/art/368879345?source_id=1003">CentOS-7 升级内核</a></li><li><a href="http://elrepo.org/tiki/HomePage">ELRepo官网</a></li></ul><span id="more"></span><h1 id="查看系统版本和当前内核版本"><span class="post-title-index">2. </span><a href="#查看系统版本和当前内核版本" class="headerlink" title="查看系统版本和当前内核版本"></a>查看系统版本和当前内核版本</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/redhat-release</span><br><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure><h1 id="导入ELRepo项目"><span class="post-title-index">3. </span><a href="#导入ELRepo项目" class="headerlink" title="导入ELRepo项目"></a>导入ELRepo项目</h1><p>1、导入public key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y update</span><br><span class="line">rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org</span><br></pre></td></tr></table></figure><p>2、安装ELRepo仓库的yum源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y https://www.elrepo.org/elrepo-release-7.el7.elrepo.noarch.rpm</span><br></pre></td></tr></table></figure><p>3、查看可用内核包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo=<span class="string">&quot;*&quot;</span> --enablerepo=<span class="string">&quot;elrepo-kernel&quot;</span> list available</span><br></pre></td></tr></table></figure><p>输出内容示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Available Packages</span><br><span class="line">kernel-lt.x86_64                       5.4.256-1.el7.elrepo            elrepo-kernel</span><br><span class="line">kernel-lt-devel.x86_64                 5.4.256-1.el7.elrepo            elrepo-kernel</span><br><span class="line">kernel-lt-doc.noarch                   5.4.256-1.el7.elrepo            elrepo-kernel</span><br><span class="line">kernel-lt-headers.x86_64               5.4.256-1.el7.elrepo            elrepo-kernel</span><br><span class="line">kernel-lt-tools.x86_64                 5.4.256-1.el7.elrepo            elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs.x86_64            5.4.256-1.el7.elrepo            elrepo-kernel</span><br><span class="line">kernel-lt-tools-libs-devel.x86_64      5.4.256-1.el7.elrepo            elrepo-kernel</span><br><span class="line">kernel-ml.x86_64                       6.5.2-1.el7.elrepo              elrepo-kernel</span><br><span class="line">kernel-ml-devel.x86_64                 6.5.2-1.el7.elrepo              elrepo-kernel</span><br><span class="line">kernel-ml-doc.noarch                   6.5.2-1.el7.elrepo              elrepo-kernel</span><br><span class="line">kernel-ml-headers.x86_64               6.5.2-1.el7.elrepo              elrepo-kernel</span><br><span class="line">kernel-ml-tools.x86_64                 6.5.2-1.el7.elrepo              elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs.x86_64            6.5.2-1.el7.elrepo              elrepo-kernel</span><br><span class="line">kernel-ml-tools-libs-devel.x86_64      6.5.2-1.el7.elrepo              elrepo-kernel</span><br><span class="line">perf.x86_64                            5.4.256-1.el7.elrepo            elrepo-kernel</span><br><span class="line">python-perf.x86_64                     5.4.256-1.el7.elrepo            elrepo-kernel</span><br></pre></td></tr></table></figure><p>长期维护版本为 kernal-lt ，最新主线稳定版为 kernal-ml ，这里选择 kernal-lt</p><h1 id="安装新版内核"><span class="post-title-index">4. </span><a href="#安装新版内核" class="headerlink" title="安装新版内核"></a>安装新版内核</h1><p>1、安装新版内核 kernal-lt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum  --enablerepo=elrepo-kernel  install  -y  kernel-lt</span><br></pre></td></tr></table></figure><p>安装成功会输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Running transaction</span><br><span class="line">  Installing : kernel-lt-5.4.256-1.el7.elrepo.x86_64                                                                                                                          1/1</span><br><span class="line"></span><br><span class="line">  Verifying  : kernel-lt-5.4.256-1.el7.elrepo.x86_64                                                                                                                          1/1</span><br><span class="line"></span><br><span class="line">Installed:</span><br><span class="line">  kernel-lt.x86_64 0:5.4.256-1.el7.elrepo</span><br></pre></td></tr></table></figure><p>2、查看可用内核版本及启动顺序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F\&#x27; <span class="string">&#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27;</span> /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p>输出内容示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0 : CentOS Linux 7 Rescue 05110432cb69b45d6c089de56b266fed (5.4.258-1.el7.elrepo.x86_64)</span><br><span class="line">1 : CentOS Linux (5.4.256-1.el7.elrepo.x86_64) 7 (Core)</span><br><span class="line">2 : CentOS Linux (4.19.188-10.el7.ucloud.x86_64) 7 (Core)</span><br><span class="line">3 : CentOS Linux (0-rescue-05110432cb69b45d6c089de56b266fed) 7 (Core)</span><br><span class="line">4 : CentOS Linux (0-rescue-8e8ed229018f0a9cfe91d03b023e4f67) 7 (Core)</span><br></pre></td></tr></table></figure><h1 id="设置内核启动顺序"><span class="post-title-index">5. </span><a href="#设置内核启动顺序" class="headerlink" title="设置内核启动顺序"></a>设置内核启动顺序</h1><p>1、安装内核升级辅助工具 grub2-pc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y grub2-pc</span><br></pre></td></tr></table></figure><p>2、设置默认内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grub2-set-default 1</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">grub2-set-default <span class="string">&#x27;CentOS Linux (5.4.256-1.el7.elrepo.x86_64) 7 (Core)&#x27;</span></span><br></pre></td></tr></table></figure><p>3、生成 grub 配置文件，重新创建内核配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p>4、再次查看可用内核版本及启动顺序</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F\&#x27; <span class="string">&#x27;$1==&quot;menuentry &quot; &#123;print i++ &quot; : &quot; $2&#125;&#x27;</span> /boot/grub2/grub.cfg</span><br></pre></td></tr></table></figure><p>此时，<code>CentOS Linux (5.4.256-1.el7.elrepo.x86_64) 7 (Core)</code>的排序号会变成0。</p><p>5、修改grub配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure><p>修改 <code>GRUB_DEFAULT</code> 的值为 <code>0</code> （默认为<code>saved</code>），其他参数不用变。</p><h1 id="重启系统"><span class="post-title-index">6. </span><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h1><p>1、重启系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><p>2、查看当前内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure><p>以上，内核升级完成。</p><h1 id="删除旧内核（可选）"><span class="post-title-index">7. </span><a href="#删除旧内核（可选）" class="headerlink" title="删除旧内核（可选）"></a>删除旧内核（可选）</h1><p>1、查看可用内核列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep kernel</span><br></pre></td></tr></table></figure><p>输出示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kernel-tools-libs-4.19.188-10.el7.ucloud.x86_64</span><br><span class="line">kernel-4.19.188-10.el7.ucloud.x86_64</span><br><span class="line">kernel-tools-4.19.188-10.el7.ucloud.x86_64</span><br><span class="line">kernel-headers-4.19.188-10.el7.ucloud.x86_64</span><br><span class="line">kernel-devel-4.19.188-10.el7.ucloud.x86_64</span><br><span class="line">kernel-lt-5.4.256-1.el7.elrepo.x86_64</span><br><span class="line">kernel-tools-libs-devel-4.19.188-10.el7.ucloud.x86_64</span><br></pre></td></tr></table></figure><p>2、删除旧内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove -y kernel-4.19.188 kernel-devel-4.19.188 kernel-headers-4.19.188</span><br></pre></td></tr></table></figure><p>3、删除旧版本工具包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove kernel-tools-libs-devel-4.19.188-10 kernel-tools-4.19.188-10</span><br></pre></td></tr></table></figure><p>PS：安装yum-utils 工具，当系统安装的内核大于3个时，会自动删除旧的内核版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y  yum-utils</span><br></pre></td></tr></table></figure><h1 id="安装新版本工具包（可选）"><span class="post-title-index">8. </span><a href="#安装新版本工具包（可选）" class="headerlink" title="安装新版本工具包（可选）"></a>安装新版本工具包（可选）</h1><p>1、安装新版本工具包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64</span><br></pre></td></tr></table></figure><p>2、查看已安装内核和工具包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep kernel</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文学习并实践CentOS7内核升级方法，备忘。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhihu.com/tardis/zm/art/368879345?source_id=1003&quot;&gt;CentOS-7 升级内核&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://elrepo.org/tiki/HomePage&quot;&gt;ELRepo官网&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="centos" scheme="https://www.voidking.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>Hexo本地搜索加速（七牛版）</title>
    <link href="https://www.voidking.com/dev-hexo-local-search-accelerate-qiniu/"/>
    <id>https://www.voidking.com/dev-hexo-local-search-accelerate-qiniu/</id>
    <published>2023-09-02T08:00:00.000Z</published>
    <updated>2023-09-02T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-hexo-local-search-accelerate/">《Hexo本地搜索加速》</a>一文中，给 search.xml 文件配置了 jsdelivr CDN。但是，jsdelivr CDN 目前国内已经无法访问了，只能另外寻找一个替代。</p><p>可选的替代包括：</p><ul><li>statically.io</li><li>githack.com</li></ul><p>配置方法可以参考<a href="https://github.com/voidking/hexo-theme-next/commit/2ff6c110f914c02c3b4acc9791b6a6df7131aca0">hexo-theme-next/commit/2ff6c11</a>，但是，这些替代CDN，国内也无法访问。找来找去，最终锁定了七牛，一直用它作为图床，其实用做 search.xml 文件的存储仓库，也很合适。</p><p>本文就来学习一下使用七牛作为 search.xml 存储仓库的方法。</p><span id="more"></span><h1 id="准备工作"><span class="post-title-index">2. </span><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="安装配置hexo环境"><span class="post-title-index">2.1. </span><a href="#安装配置hexo环境" class="headerlink" title="安装配置hexo环境"></a>安装配置hexo环境</h2><p>参考文档<a href="https://www.voidking.com/dev-hexo-build-environment-2021-08/">《Hexo环境搭建2021年8月版》</a>，安装配置hexo环境。</p><p>执行 <code>hexo g</code> 命令，在 public 目录中生成要部署的静态文件，其中包含 search.xml 。</p><h2 id="获取七牛api-key"><span class="post-title-index">2.2. </span><a href="#获取七牛api-key" class="headerlink" title="获取七牛api key"></a>获取七牛api key</h2><p>访问<a href="https://portal.qiniu.com/user/key">七牛密钥管理页面</a>，创建一个密钥对（AccessKey/SecretKey）。</p><h2 id="安装七牛依赖"><span class="post-title-index">2.3. </span><a href="#安装七牛依赖" class="headerlink" title="安装七牛依赖"></a>安装七牛依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install qiniu --save</span><br></pre></td></tr></table></figure><h1 id="上传-search-xml"><span class="post-title-index">3. </span><a href="#上传-search-xml" class="headerlink" title="上传 search.xml"></a>上传 search.xml</h1><p>参考文档：<a href="https://developer.qiniu.com/kodo/1289/nodejs">对象存储 - Node.js SDK</a></p><p>1、实现上传脚本 upload-qiniu.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> qiniu = <span class="built_in">require</span>(<span class="string">&#x27;qiniu&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 七牛配置</span></span><br><span class="line"><span class="keyword">const</span> accessKey = <span class="string">&#x27;您的七牛Access Key&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> secretKey = <span class="string">&#x27;您的七牛Secret Key&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> bucketName = <span class="string">&#x27;您的存储空间名称&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;doc/search.xml&#x27;</span>; <span class="comment">// 如果需要覆盖之前文件/图片，使用相同的key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mac = <span class="keyword">new</span> qiniu.<span class="property">auth</span>.<span class="property">digest</span>.<span class="title class_">Mac</span>(accessKey, secretKey);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = <span class="keyword">new</span> qiniu.<span class="property">conf</span>.<span class="title class_">Config</span>();</span><br><span class="line">config.<span class="property">zone</span> = qiniu.<span class="property">zone</span>.<span class="property">Zone_z0</span>; <span class="comment">// 华东地区，根据需要选择合适的地区</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> formUploader = <span class="keyword">new</span> qiniu.<span class="property">form_up</span>.<span class="title class_">FormUploader</span>(config);</span><br><span class="line"><span class="keyword">const</span> putExtra = <span class="keyword">new</span> qiniu.<span class="property">form_up</span>.<span class="title class_">PutExtra</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">uploadImage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 读取本地文件</span></span><br><span class="line">  <span class="keyword">const</span> localFile = <span class="string">&#x27;./public/search.xml&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> readStream = fs.<span class="title function_">createReadStream</span>(localFile);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成上传凭证</span></span><br><span class="line">  <span class="keyword">const</span> options = &#123;</span><br><span class="line">    <span class="attr">scope</span>: <span class="string">`<span class="subst">$&#123;bucketName&#125;</span>:<span class="subst">$&#123;key&#125;</span>`</span>,</span><br><span class="line">    <span class="attr">force</span>: <span class="literal">true</span>, <span class="comment">// 强制覆盖同名文件</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> putPolicy = <span class="keyword">new</span> qiniu.<span class="property">rs</span>.<span class="title class_">PutPolicy</span>(options);</span><br><span class="line">  <span class="keyword">const</span> uploadToken = putPolicy.<span class="title function_">uploadToken</span>(mac);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始上传</span></span><br><span class="line">  formUploader.<span class="title function_">putStream</span>(uploadToken, key, readStream, putExtra, <span class="function">(<span class="params">respErr, respBody, respInfo</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (respErr) &#123;</span><br><span class="line">      <span class="keyword">throw</span> respErr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (respInfo.<span class="property">statusCode</span> === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上传成功&#x27;</span>, respBody);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上传失败&#x27;</span>, respInfo.<span class="property">statusCode</span>, respBody);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">uploadImage</span>();</span><br></pre></td></tr></table></figure><p>2、测试上传脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node upload-qiniu.js</span><br></pre></td></tr></table></figure><p>上传成功后出现提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上传成功 &#123; hash: &#x27;FkYxkyrsSytBGvgYgEvPs28lVI40&#x27;, key: &#x27;doc/search.xml&#x27; &#125;</span><br></pre></td></tr></table></figure><h1 id="主题中配置使用七牛CDN"><span class="post-title-index">4. </span><a href="#主题中配置使用七牛CDN" class="headerlink" title="主题中配置使用七牛CDN"></a>主题中配置使用七牛CDN</h1><p>Next主题中，配置使用七牛CDN中的 search.xml。<br>具体配置方法参考<a href="https://github.com/voidking/hexo-theme-next/commit/2ff6c110f914c02c3b4acc9791b6a6df7131aca0">hexo-theme-next/commit/2ff6c11</a></p><h1 id="整合到自动部署"><span class="post-title-index">5. </span><a href="#整合到自动部署" class="headerlink" title="整合到自动部署"></a>整合到自动部署</h1><p>参考<a href="https://www.voidking.com/dev-hexo-github-actions/">《Hexo配置GitHub Actions自动构建发布》</a>，配置自动部署。<br>具体配置方法参考<a href="https://github.com/voidking/hexo-deploy/commit/0e3503d6f5fd43f2c37ed55858449fa6e67ac1e0">hexo-deploy/commit/0e3503d</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-hexo-local-search-accelerate/&quot;&gt;《Hexo本地搜索加速》&lt;/a&gt;一文中，给 search.xml 文件配置了 jsdelivr CDN。但是，jsdelivr CDN 目前国内已经无法访问了，只能另外寻找一个替代。&lt;/p&gt;
&lt;p&gt;可选的替代包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;statically.io&lt;/li&gt;
&lt;li&gt;githack.com&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;配置方法可以参考&lt;a href=&quot;https://github.com/voidking/hexo-theme-next/commit/2ff6c110f914c02c3b4acc9791b6a6df7131aca0&quot;&gt;hexo-theme-next/commit/2ff6c11&lt;/a&gt;，但是，这些替代CDN，国内也无法访问。找来找去，最终锁定了七牛，一直用它作为图床，其实用做 search.xml 文件的存储仓库，也很合适。&lt;/p&gt;
&lt;p&gt;本文就来学习一下使用七牛作为 search.xml 存储仓库的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="hexo" scheme="https://www.voidking.com/categories/engineering/hexo/"/>
    
    
    <category term="hexo" scheme="https://www.voidking.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Docker和Makefile结合：简化构建部署流程</title>
    <link href="https://www.voidking.com/dev-docker-makefile/"/>
    <id>https://www.voidking.com/dev-docker-makefile/</id>
    <published>2023-08-05T08:00:00.000Z</published>
    <updated>2023-08-05T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在现代软件开发中，Docker 已经成为一项极为重要的技术，而 Makefile 则是构建和自动化流程的有力工具。将 Docker 和 Makefile 结合起来，可以显著简化应用程序的构建、测试和部署流程，提高开发效率和可维护性。</p><span id="more"></span><h1 id="Docker简介"><span class="post-title-index">2. </span><a href="#Docker简介" class="headerlink" title="Docker简介"></a>Docker简介</h1><p>Docker 是一种容器化技术，允许开发者将应用程序及其依赖项打包成一个独立的容器。这个容器包含了运行应用所需的所有组件，包括操作系统、库、环境变量等。这使得应用在不同的环境中能够一致地运行，避免了“在我的机器上能运行”的问题。</p><p>Docker 的主要概念包括镜像（Image）和容器（Container）：</p><p>镜像：一个镜像是一个只读的模板，包含了运行应用所需的文件系统、代码和配置。镜像是构建容器的基础。<br>容器：容器是基于镜像创建的一个运行实例，它隔离了应用及其依赖项，使得应用可以在一个隔离的环境中运行。</p><h1 id="Makefile简介"><span class="post-title-index">3. </span><a href="#Makefile简介" class="headerlink" title="Makefile简介"></a>Makefile简介</h1><p>Makefile 是一个文本文件，其中定义了一系列规则，用于自动化构建过程。通过 Makefile，开发者可以定义源代码的依赖关系，以及如何编译、链接和构建最终的应用程序。</p><p>Makefile 的基本结构如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">target: prerequisites</span><br><span class="line">    recipe</span><br></pre></td></tr></table></figure><ul><li>目标（Target）：表示要生成的文件或执行的操作。</li><li>依赖项（Prerequisites）：指定目标所依赖的文件或其他目标。</li><li>命令（Recipe）：在目标和依赖项之间，定义了如何生成目标的操作。</li></ul><p>以下是一个简单的示例 Makefile，用于编译一个包含两个源文件的 C 程序：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"></span><br><span class="line">all: myprogram</span><br><span class="line"></span><br><span class="line">myprogram: main.o utils.o</span><br><span class="line">    $(CC) $(CFLAGS) -o myprogram main.o utils.o</span><br><span class="line"></span><br><span class="line">main.o: main.c utils.h</span><br><span class="line">    $(CC) $(CFLAGS) -c main.c</span><br><span class="line"></span><br><span class="line">utils.o: utils.c utils.h</span><br><span class="line">    $(CC) $(CFLAGS) -c utils.c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -f *.o myprogram</span><br></pre></td></tr></table></figure><p>在这个示例中，有三个目标：</p><ul><li>all：默认目标，运行 myprogram 目标，生成最终的可执行文件。</li><li>myprogram：生成可执行文件 myprogram，依赖于 main.o 和 utils.o。</li><li>clean：删除生成的目标文件和可执行文件。</li></ul><p>通过在命令行中运行 make 命令，Make 工具会查找当前目录下的 Makefile 文件，并根据定义的规则执行构建操作。例如，运行 make 将会编译源文件并生成可执行文件。</p><p><code>.PHONY</code> 是一个特殊的目标，用于声明一组伪目标（Phony Targets）。伪目标是那些并不代表真实文件的目标，而是代表一些操作或动作。使用 .PHONY 可以告诉 Make 工具，这些目标不应该被当作文件名进行比较，而是始终会执行对应的命令，无论文件是否已经存在。</p><p>带有 <code>.PHONY</code> 的示例 Makefile：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean build run</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf *.o</span><br><span class="line"></span><br><span class="line">build: clean</span><br><span class="line">    gcc -o myprogram main.c</span><br><span class="line"></span><br><span class="line">run: build</span><br><span class="line">    ./myprogram</span><br></pre></td></tr></table></figure><p>在这个示例中，<code>.PHONY</code> 声明了三个伪目标：clean, build, 和 run。当你运行 <code>make clean</code>，<code>make build</code>，或 <code>make run</code> 时，Make 工具将会执行与这些目标关联的命令，而不会考虑文件名的存在与否。</p><p>Makefile 可以更加复杂，支持条件语句、循环、变量等功能，使其能够适应各种项目的构建需求。使用 Makefile 可以提高开发效率，确保代码在不同环境下能够正确地构建。</p><h1 id="Docker和Makefile结合示例"><span class="post-title-index">4. </span><a href="#Docker和Makefile结合示例" class="headerlink" title="Docker和Makefile结合示例"></a>Docker和Makefile结合示例</h1><p>参考项目：<a href="https://github.com/voidking/python-wechaty-template">github - voidking/python-wechaty-template</a></p><p>项目中Makefile内容为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">P=$(shell pwd)</span><br><span class="line"></span><br><span class="line">.PHONY: build</span><br><span class="line">build:</span><br><span class="line">        docker build -t py-wechaty-template-bot:latest .</span><br><span class="line"></span><br><span class="line">.PHONY: dockerrun</span><br><span class="line">dockerrun:</span><br><span class="line">        docker stop bot &amp;&amp; docker rm bot</span><br><span class="line">        docker run -it -d -v $(P):/bot --name bot -p 8004:8004 py-wechaty-template-bot:latest</span><br><span class="line"></span><br><span class="line">.PHONY: bot</span><br><span class="line">bot:</span><br><span class="line">        make build</span><br><span class="line">        make dockerrun</span><br><span class="line"></span><br><span class="line">.PHONY: install</span><br><span class="line">install:</span><br><span class="line">        pip install -r requirements.txt</span><br><span class="line"></span><br><span class="line">.PHONY: run</span><br><span class="line">run:</span><br><span class="line">        python bot.py</span><br></pre></td></tr></table></figure><p>项目中Dockerfile内容为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM python:3.9</span><br><span class="line"></span><br><span class="line">WORKDIR /bot</span><br><span class="line"></span><br><span class="line">COPY requirements.txt requirements.txt</span><br><span class="line"></span><br><span class="line">COPY Makefile Makefile</span><br><span class="line"></span><br><span class="line">RUN make install</span><br><span class="line"></span><br><span class="line">COPY . .</span><br><span class="line"></span><br><span class="line">CMD [ <span class="string">&quot;make&quot;</span>, <span class="string">&quot;run&quot;</span>]</span><br></pre></td></tr></table></figure><p>宿主机上执行 <code>make bot</code> ，调用流程如下：</p><p>1、从Makefile中找到目标bot对应的命令，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make build</span><br><span class="line">make dockerrun</span><br></pre></td></tr></table></figure><p>2、从Makefile中找到build和dockerrun对应的命令，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker build -t py-wechaty-template-bot:latest .</span><br><span class="line"></span><br><span class="line">docker stop bot &amp;&amp; docker <span class="built_in">rm</span> bot</span><br><span class="line">docker run -it -d -v $(P):/bot --name bot -p 8004:8004 py-wechaty-template-bot:latest</span><br></pre></td></tr></table></figure><p>3、执行<code>docker build</code>时，当前目录中的Makefile和其他文件一起被拷贝到了容器中</p><p>4、执行<code>docker build</code>中的<code>make install</code>时，从Makefile中找到install对应的命令，容器中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><p>5、执行<code>docker build</code>结束时，指定镜像的启动命令为<code>make run</code>，从Makefile中找到run对应的命令为<code>python bot.py</code></p><p>6、执行<code>docker run</code>时，因为没有指定启动命令，所以执行默认启动命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python bot.py</span><br></pre></td></tr></table></figure><h1 id="优势和总结"><span class="post-title-index">5. </span><a href="#优势和总结" class="headerlink" title="优势和总结"></a>优势和总结</h1><p>将 Docker 和 Makefile 结合，为开发者带来了许多优势：</p><ul><li>自动化流程：通过 Makefile，可以定义一系列自动化的构建、测试和部署流程，减少手动操作的需要。</li><li>一致性：Docker 容器保证了应用在不同环境中的一致运行，而 Makefile 确保了构建过程的一致性。</li><li>可维护性：将构建和部署步骤定义在 Makefile 中，使得团队成员可以轻松了解和执行这些操作。</li></ul><p>综上所述，结合 Docker 和 Makefile 可以使得容器化应用的构建和部署变得更加高效、可靠，并且易于维护。这种结合为现代软件开发提供了一种强大的工具，能够帮助开发者更好地管理复杂的构建流程。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在现代软件开发中，Docker 已经成为一项极为重要的技术，而 Makefile 则是构建和自动化流程的有力工具。将 Docker 和 Makefile 结合起来，可以显著简化应用程序的构建、测试和部署流程，提高开发效率和可维护性。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Markdown使用Mermaid绘图入门篇</title>
    <link href="https://www.voidking.com/dev-markdown-mermaid-start/"/>
    <id>https://www.voidking.com/dev-markdown-mermaid-start/</id>
    <published>2023-08-05T08:00:00.000Z</published>
    <updated>2023-08-05T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Mermaid是一种用于描述图表的文本语言，它支持多种图表类型，如流程图、序列图、甘特图等。通过简单的文本描述，就可以生成复杂的图表，而不需要手动绘制。</p><p>Mermaid可以与Markdown结合使用，方便快捷地在文档中插入图表。本文将介绍如何使用Mermaid语言在Markdown文档中绘制各种类型的图表。</p><p>参考文档：</p><ul><li><a href="https://github.com/mermaid-js/mermaid">github - mermaid-js/mermaid</a></li><li><a href="https://mermaid.js.org/intro/">Mermaid官方文档</a></li><li><a href="https://juejin.cn/post/7038144693867118629">使用 markdown 画流程图、时序图</a></li><li><a href="https://rstyro.github.io/blog/2021/06/28/Markdown%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B/">Markdown流程图语法示例</a></li></ul><span id="more"></span><h1 id="安装与配置"><span class="post-title-index">2. </span><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h1><p>Mermaid通常不需要额外的安装，因为它是在浏览器中渲染的。<br>想要在Markdown中使用Mermaid语言，需要Markdown编辑器支持Mermaid语法，并启用了Mermaid渲染插件。</p><h1 id="在Markdown中插入Mermaid图表"><span class="post-title-index">3. </span><a href="#在Markdown中插入Mermaid图表" class="headerlink" title="在Markdown中插入Mermaid图表"></a>在Markdown中插入Mermaid图表</h1><p>在Markdown文档中插入Mermaid图表非常简单。只需使用三个反引号（```）将Mermaid代码块括起来，并在反引号后指定Mermaid语言。</p><p><img src="https://cdn.voidking.com/imgs/markdown-mermaid-start/mermaid.png?imageView2/0/w/500"></p><h1 id="Hexo-Next主题启用Mermaid"><span class="post-title-index">4. </span><a href="#Hexo-Next主题启用Mermaid" class="headerlink" title="Hexo Next主题启用Mermaid"></a>Hexo Next主题启用Mermaid</h1><p>参考文档：</p><ul><li><a href="https://theme-next.js.org/docs/tag-plugins/mermaid">Next - Mermaid</a></li><li><a href="https://www.techgrow.cn/posts/e6e0cad5.html">Hexo NexT 主题渲染 Mermaid 绘图</a></li></ul><p>1、安装 hexo-filter-mermaid-diagrams 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-filter-mermaid-diagrams --save</span><br></pre></td></tr></table></figure><p>2、Next主题启用Mermaid</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure><p>具体修改参考next主题修改<a href="https://github.com/voidking/hexo-theme-next/commit/0790595d0603eeefcbd507f356eb4191fb6fd0e4">commit/0790595d</a>。</p><h1 id="绘制图表"><span class="post-title-index">5. </span><a href="#绘制图表" class="headerlink" title="绘制图表"></a>绘制图表</h1><h2 id="绘制流程图"><span class="post-title-index">5.1. </span><a href="#绘制流程图" class="headerlink" title="绘制流程图"></a>绘制流程图</h2><p>流程图是描述流程、决策和步骤的图表。以下是一个简单的流程图示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    A[开始] --&gt; B[中间步骤]</span><br><span class="line">    B --&gt; C[结束]</span><br></pre></td></tr></table></figure><p>上述代码使用Mermaid语法绘制了一个由三个节点组成的流程图。</p><pre class="mermaid">graph LR    A[开始] --> B[中间步骤]    B --> C[结束]</pre><h2 id="绘制序列图"><span class="post-title-index">5.2. </span><a href="#绘制序列图" class="headerlink" title="绘制序列图"></a>绘制序列图</h2><p>序列图用于展示多个参与者之间的交互过程。以下是一个简单的序列图示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">    participant Alice</span><br><span class="line">    participant Bob</span><br><span class="line">    Alice -&gt;&gt; Bob: 你好，Bob！</span><br><span class="line">    Bob --&gt;&gt; Alice: 你好，Alice！</span><br></pre></td></tr></table></figure><p>上述代码使用Mermaid语法绘制了Alice和Bob之间的简单交互过程。</p><pre class="mermaid">sequenceDiagram    participant Alice    participant Bob    Alice ->> Bob: 你好，Bob！    Bob -->> Alice: 你好，Alice！</pre><h2 id="绘制甘特图"><span class="post-title-index">5.3. </span><a href="#绘制甘特图" class="headerlink" title="绘制甘特图"></a>绘制甘特图</h2><p>甘特图用于展示任务的时间轴和进度。以下是一个简单的甘特图示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">    title 项目计划</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    section 项目A</span><br><span class="line">    任务1      :a1, 2023-08-01, 7d</span><br><span class="line">    任务2      :after a1, 3d</span><br><span class="line">    section 项目B</span><br><span class="line">    任务3      :2023-08-10, 5d</span><br><span class="line">    任务4      :2023-08-15, 4d</span><br></pre></td></tr></table></figure><p>上述代码使用Mermaid语法绘制了一个包含两个项目的甘特图，每个项目有多个任务。</p><pre class="mermaid">gantt    title 项目计划    dateFormat  YYYY-MM-DD    section 项目A    任务1      :a1, 2023-08-01, 7d    任务2      :after a1, 3d    section 项目B    任务3      :2023-08-10, 5d    任务4      :2023-08-15, 4d</pre><h2 id="高级用法与样式"><span class="post-title-index">5.4. </span><a href="#高级用法与样式" class="headerlink" title="高级用法与样式"></a>高级用法与样式</h2><p>Mermaid支持许多高级用法和样式设置，例如节点样式、连接线样式、图表方向等。更多信息请参考<a href="https://mermaid.js.org/intro/">Mermaid官方文档</a>。</p><h1 id="小结"><span class="post-title-index">6. </span><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过Mermaid语言，我们可以在Markdown文档中轻松绘制流程图、序列图、甘特图等各种类型的图表。只需按照本教程的指导，使用Mermaid语法编写图表代码，并确保我们的Markdown编辑器支持Mermaid渲染，即可轻松创建复杂的图表内容。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Mermaid是一种用于描述图表的文本语言，它支持多种图表类型，如流程图、序列图、甘特图等。通过简单的文本描述，就可以生成复杂的图表，而不需要手动绘制。&lt;/p&gt;
&lt;p&gt;Mermaid可以与Markdown结合使用，方便快捷地在文档中插入图表。本文将介绍如何使用Mermaid语言在Markdown文档中绘制各种类型的图表。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mermaid-js/mermaid&quot;&gt;github - mermaid-js/mermaid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mermaid.js.org/intro/&quot;&gt;Mermaid官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7038144693867118629&quot;&gt;使用 markdown 画流程图、时序图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rstyro.github.io/blog/2021/06/28/Markdown%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B/&quot;&gt;Markdown流程图语法示例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="hexo" scheme="https://www.voidking.com/categories/engineering/hexo/"/>
    
    
    <category term="markdown" scheme="https://www.voidking.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Python调用OpenAI API</title>
    <link href="https://www.voidking.com/dev-python-openai-api/"/>
    <id>https://www.voidking.com/dev-python-openai-api/</id>
    <published>2023-08-05T08:00:00.000Z</published>
    <updated>2023-12-16T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文学习使用Python调用OpenAI API的方法，基于openai python库 <code>openai==0.27.8</code><br>注意：openai python库版本更新很快，本文并不适用更高版本openai python库。</p><p>参考文档：</p><ul><li><a href="https://platform.openai.com/docs/introduction">OpenAI - Introduction</a></li><li><a href="https://platform.openai.com/docs/libraries/python-library">OpenAI - Python library</a></li><li><a href="https://github.com/openai/openai-python">github - openai/openai-python</a></li><li><a href="https://www.voidking.com/dev-docker-openai-api-proxy/">《使用Docker安装配置OPANAI API代理》</a></li></ul><span id="more"></span><h1 id="安装OpenAI客户端"><span class="post-title-index">2. </span><a href="#安装OpenAI客户端" class="headerlink" title="安装OpenAI客户端"></a>安装OpenAI客户端</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openai==0.27.8</span><br></pre></td></tr></table></figure><h1 id="命令行访问OpenAI"><span class="post-title-index">3. </span><a href="#命令行访问OpenAI" class="headerlink" title="命令行访问OpenAI"></a>命令行访问OpenAI</h1><h2 id="命令行参数"><span class="post-title-index">3.1. </span><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">usage: openai [-h] [-V] [-v] [-b API_BASE] [-k API_KEY] [-p PROXY [PROXY ...]] [-o ORGANIZATION] &#123;api,tools,wandb&#125; ...</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  &#123;api,tools,wandb&#125;</span><br><span class="line">    api                 Direct API calls</span><br><span class="line">    tools               Client side tools for convenience</span><br><span class="line">    wandb               Logging with Weights &amp; Biases</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --help            show this help message and exit</span><br><span class="line">  -V, --version         show program&#x27;s version number and exit</span><br><span class="line">  -v, --verbose         Set verbosity.</span><br><span class="line">  -b API_BASE, --api-base API_BASE</span><br><span class="line">                        What API base url to use.</span><br><span class="line">  -k API_KEY, --api-key API_KEY</span><br><span class="line">                        What API key to use.</span><br><span class="line">  -p PROXY [PROXY ...], --proxy PROXY [PROXY ...]</span><br><span class="line">                        What proxy to use.</span><br><span class="line">  -o ORGANIZATION, --organization ORGANIZATION</span><br><span class="line">                        Which organization to run as (will use your default organization if not specified)</span><br></pre></td></tr></table></figure><h2 id="Hello-world"><span class="post-title-index">3.2. </span><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> OPENAI_API_KEY=<span class="string">&quot;sk-xxx&quot;</span></span><br><span class="line"></span><br><span class="line">openai api chat_completions.create -m gpt-3.5-turbo -g user <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/python-openai-api/helloworld.png?imageView2/0/w/800"></p><h2 id="测试OPENAI-API是否畅通"><span class="post-title-index">3.3. </span><a href="#测试OPENAI-API是否畅通" class="headerlink" title="测试OPENAI API是否畅通"></a>测试OPENAI API是否畅通</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 测试官方OPENAI API</span></span><br><span class="line">openai api chat_completions.create -m gpt-3.5-turbo -g user <span class="string">&quot;Hello world&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试OPENAI API代理</span></span><br><span class="line">openai -b <span class="string">&quot;https://api.openai-forward.com/v1&quot;</span> api chat_completions.create -m gpt-3.5-turbo -g user <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><h2 id="可能的问题"><span class="post-title-index">3.4. </span><a href="#可能的问题" class="headerlink" title="可能的问题"></a>可能的问题</h2><h3 id="配置KEY问题"><span class="post-title-index">3.4.1. </span><a href="#配置KEY问题" class="headerlink" title="配置KEY问题"></a>配置KEY问题</h3><p>执行openai命令前，需要先配置KEY，否则会报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: No API key provided. You can set your API key in code using &#x27;openai.api_key = &lt;API-KEY&gt;&#x27;, or you can set the environment variable OPENAI_API_KEY=&lt;API-KEY&gt;). If your API key is stored in a file, you can point the openai module at it with &#x27;openai.api_key_path = &lt;PATH&gt;&#x27;. You can generate API keys in the OpenAI web interface. See https://platform.openai.com/account/api-keys for details.</span><br></pre></td></tr></table></figure><p>或者，执行openai命令时，使用参数<code>-k</code>配置KEY。</p><h3 id="网络问题"><span class="post-title-index">3.4.2. </span><a href="#网络问题" class="headerlink" title="网络问题"></a>网络问题</h3><p>执行可能会卡住一段时间后报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2023-08-05 08:55:26,852] Retrying (Retry(total=1, connect=None, read=None, redirect=None, status=None)) after connection broken by &#x27;NewConnectionError(&#x27;&lt;urllib3.connection.HTTPSConnection object at 0x7f94afde5d30&gt;: Failed to establish a new connection: [Errno 110] Connection timed out&#x27;)&#x27;: /v1/chat/completions</span><br></pre></td></tr></table></figure><p>也可能会直接报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: Error communicating with OpenAI: (&#x27;Connection aborted.&#x27;, ConnectionResetError(54, &#x27;Connection reset by peer&#x27;))</span><br></pre></td></tr></table></figure><p><strong>解决办法一：配置全局代理（推荐）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line">openai api chat_completions.create -m gpt-3.5-turbo -g user <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><p><strong>解决方法二：使用OPENAI API代理</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openai -b <span class="string">&quot;https://api.openai-forward.com/v1&quot;</span> api chat_completions.create -m gpt-3.5-turbo -g user <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><p><strong>解决办法三：执行命令时指定代理（验证时没有生效）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openai -p http://127.0.0.1:7890 -k sk-xxx api chat_completions.create -m gpt-3.5-turbo -g user <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><p>使用<code>-p</code>参数时，必须配合使用<code>-k</code>参数，否则报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: openai [-h] [-V] [-v] [-b API_BASE] [-k API_KEY] [-p PROXY [PROXY ...]] [-o ORGANIZATION] &#123;api,tools,wandb&#125; ...</span><br><span class="line">openai: error: argument &#123;api,tools,wandb&#125;: invalid choice: &#x27;gpt-3.5-turbo&#x27; (choose from &#x27;api&#x27;, &#x27;tools&#x27;, &#x27;wandb&#x27;)</span><br></pre></td></tr></table></figure><h1 id="Python访问OpenAI"><span class="post-title-index">4. </span><a href="#Python访问OpenAI" class="headerlink" title="Python访问OpenAI"></a>Python访问OpenAI</h1><h2 id="Hello-world-1"><span class="post-title-index">4.1. </span><a href="#Hello-world-1" class="headerlink" title="Hello world"></a>Hello world</h2><p>1、新建文件 hello.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"></span><br><span class="line"><span class="comment"># openai.api_base = os.getenv(&quot;OPENAI_API_BASE&quot;)</span></span><br><span class="line"><span class="comment"># openai.api_key = os.getenv(&quot;OPENAI_API_KEY&quot;)</span></span><br><span class="line">openai.api_base = <span class="string">&#x27;https://api.openai.com/v1&#x27;</span></span><br><span class="line">openai.api_key = <span class="string">&#x27;sk-xxx&#x27;</span></span><br><span class="line"></span><br><span class="line">chat_completion = openai.ChatCompletion.create(model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>, messages=[&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Hello world&quot;</span>&#125;])</span><br><span class="line"><span class="built_in">print</span>(chat_completion)</span><br></pre></td></tr></table></figure><p>2、执行 hello.py</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python hello.py</span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/python-openai-api/helloworld2.png?imageView2/0/w/800"></p><p>返回值json结构：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chatcmpl-7ksejsnNZEmq7Q0YPGQ1iRa1x5LHf&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;object&quot;</span><span class="punctuation">:</span> <span class="string">&quot;chat.completion&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;created&quot;</span><span class="punctuation">:</span> <span class="number">1691407541</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;model&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gpt-3.5-turbo-0613&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;choices&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;role&quot;</span><span class="punctuation">:</span> <span class="string">&quot;assistant&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;content&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello! How can I assist you today?&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;finish_reason&quot;</span><span class="punctuation">:</span> <span class="string">&quot;stop&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;usage&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prompt_tokens&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;completion_tokens&quot;</span><span class="punctuation">:</span> <span class="number">9</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;total_tokens&quot;</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="可能的问题-1"><span class="post-title-index">4.2. </span><a href="#可能的问题-1" class="headerlink" title="可能的问题"></a>可能的问题</h2><h3 id="文件名问题"><span class="post-title-index">4.2.1. </span><a href="#文件名问题" class="headerlink" title="文件名问题"></a>文件名问题</h3><p>测试文件，不要命名为 openai.py ，否则会报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AttributeError: partially initialized module &#x27;openai&#x27; has no attribute &#x27;ChatCompletion&#x27; (most likely due to a circular import)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文学习使用Python调用OpenAI API的方法，基于openai python库 &lt;code&gt;openai==0.27.8&lt;/code&gt;&lt;br&gt;注意：openai python库版本更新很快，本文并不适用更高版本openai python库。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://platform.openai.com/docs/introduction&quot;&gt;OpenAI - Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://platform.openai.com/docs/libraries/python-library&quot;&gt;OpenAI - Python library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/openai/openai-python&quot;&gt;github - openai/openai-python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-docker-openai-api-proxy/&quot;&gt;《使用Docker安装配置OPANAI API代理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
  </entry>
  
  <entry>
    <title>Wechaty入门篇</title>
    <link href="https://www.voidking.com/dev-wechaty-start/"/>
    <id>https://www.voidking.com/dev-wechaty-start/</id>
    <published>2023-08-05T08:00:00.000Z</published>
    <updated>2023-08-05T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Wechaty简介"><span class="post-title-index">1. </span><a href="#Wechaty简介" class="headerlink" title="Wechaty简介"></a>Wechaty简介</h1><blockquote><p>Wechaty 是一个开源聊天机器人框架SDK，具有高度封装、高可用的特性，支持NodeJs, Python, Go 和Java 等多语言版本。在过去的4年中，服务了数万名开发者，收获了 Github 的 1w+ Star。同时配置了完整的 DevOps 体系并持续按照 Apache 的方式管理技术社区。</p></blockquote><p>参考文档：</p><ul><li><a href="https://github.com/wechaty/getting-started">github - wechaty/getting-started</a></li><li><a href="https://github.com/Wechaty/python-wechaty">github - Wechaty/python-wechaty</a></li><li><a href="https://github.com/wechaty/python-wechaty-template">github - wechaty/python-wechaty-template</a></li><li><a href="https://github.com/wechaty/python-wechaty-getting-started/">github - wechaty/python-wechaty-getting-started</a></li><li><a href="https://github.com/wechaty/docker-getting-started">github - wechaty/docker-getting-started</a></li><li><a href="https://github.com/juzibot/Welcome/wiki/Everything-about-Wechaty">Everything about Wechaty</a></li><li><a href="https://wechaty.readthedocs.io/zh_CN/latest/">python-wechaty首页</a></li><li><a href="https://wechaty.readthedocs.io/zh_CN/latest/introduction/use-padlocal-protocol/">使用Padlocal协议</a></li><li><a href="https://github.com/wechaty/puppet-padlocal">github - wechaty/puppet-padlocal</a></li><li><a href="https://wechaty.readthedocs.io/zh_CN/latest/introduction/use-paimon-protocol/">使用Paimon协议</a></li></ul><span id="more"></span><h1 id="Wechaty核心概念"><span class="post-title-index">2. </span><a href="#Wechaty核心概念" class="headerlink" title="Wechaty核心概念"></a>Wechaty核心概念</h1><h2 id="协议"><span class="post-title-index">2.1. </span><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>运行微信机器人有多种协议可以使用，有以下几种不同的协议方式：</p><ul><li>Padlocal协议(推荐使用)</li><li>Paimon协议(最简单)</li><li>免费Web协议(目前已不可用)</li><li>puppet-xp协议（仅windows下可用）</li></ul><p>每个协议都有不用的特点，如果不知道选什么，那么建议使用Padlocal协议。</p><h2 id="Token"><span class="post-title-index">2.2. </span><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>Token 是 Wechaty 开放源代码项目中，所设计和支持的一种认证技术，可以使用第三方的 <a href="https://wechaty.js.org/docs/puppet-servies/">Wechaty Puppet Service</a> 服务。Wechaty 社区中，提供 Puppet Service 的第三方，称之为 Wechaty Puppet Service Provider 。句子互动公司是 Wechaty PadPlus, WxWork, Donut 等 Puppet Service 的 Provider，提供对应 Puppet Service 的 Token ，实现开发者可以使用对应的协议服务。</p><p>在设置 Token 后，每个 Token 将可以使得一个微信号以 iPad 或 Mac 登录的方式进行登录，避免了既有网页端登录受限的问题。</p><p>每个 Token 可以使得一个微信号登录，如果希望多个号同时登录，需要获取多个 Token 。 但 Token 不与微信号绑定，即可以多个号不同时段轮流使用一个 Token 进行登录。</p><h2 id="Puppet"><span class="post-title-index">2.3. </span><a href="#Puppet" class="headerlink" title="Puppet"></a>Puppet</h2><p>Wechaty 中的术语 Puppet 是用于实现协议插件的抽象类。插件是帮助控制 微信/Whatspp/TikTok 的组件，这就是我们称之为Puttet（傀儡）的原因。</p><h1 id="Padlocal-Getting-Started"><span class="post-title-index">3. </span><a href="#Padlocal-Getting-Started" class="headerlink" title="Padlocal Getting Started"></a>Padlocal Getting Started</h1><p>参考文档：</p><ul><li><a href="https://github.com/voidking/python-wechaty-template">github - voidking/python-wechaty-template</a></li><li><a href="https://wechaty.readthedocs.io/zh_CN/latest/introduction/use-padlocal-protocol/">使用Padlocal协议</a></li><li><a href="https://wechaty.js.org/2021/02/03/python-wechaty-for-padlocal-puppet-service/">Python Wechaty如何使用PadLocal Puppet Service</a></li><li><a href="https://wechaty.js.org/2022/06/23/wechaty-gateway-use/">Wechaty Gateway 使用教程</a></li></ul><h2 id="申请Token"><span class="post-title-index">3.1. </span><a href="#申请Token" class="headerlink" title="申请Token"></a>申请Token</h2><p>申请 Padlocal Token 链接：<a href="http://pad-local.com/#/login">Padlocal</a><br>免费试用Token可以使用7天，续费200元/月。建议成为Wechaty开发者，可以免费续期Token，参考文档<a href="https://github.com/juzibot/Welcome/wiki/How-to-be-a-Wechaty-Contributor">How to be a Wechaty Contributor</a>。</p><h2 id="启动Gateway"><span class="post-title-index">3.2. </span><a href="#启动Gateway" class="headerlink" title="启动Gateway"></a>启动Gateway</h2><p>1、启动Gateway Docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/voidking/python-wechaty-template.git</span><br><span class="line"><span class="built_in">cd</span> python-wechaty-template/</span><br><span class="line">./start_gateway_docker.sh puppet_padlocal_xxx</span><br></pre></td></tr></table></figure><p>其中 <code>puppet_padlocal_xxx</code> 要替换成自己的Token。</p><p><img src="https://cdn.voidking.com/imgs/wechaty-start/gateway.png?imageView2/0/w/800"></p><p>最后一行的链接，是一个微信登录的二维码，python-wechaty连接gateway之后能够自动获取到这个链接并展示，以便我们登录。<br>当然，直接在浏览器中也能访问这个二维码，微信扫码可以登录，不过没什么用。</p><p>Gateway启动时，会生成一个<code>WECHATY_TOKEN</code>，Gateway使用；同时会填入到 <code>.env</code> 文件中，给机器人使用。<br>运行自己的机器人代码时，也要用到这个 <code>WECHATY_TOKEN</code>。</p><p>2、验证Gateway是否启动成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.chatie.io/v0/hosties/<span class="variable">$WECHATY_TOKEN</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/wechaty-start/check-gateway.png?imageView2/0/w/800"></p><h2 id="运行机器人"><span class="post-title-index">3.3. </span><a href="#运行机器人" class="headerlink" title="运行机器人"></a>运行机器人</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make bot</span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/wechaty-start/error.png?imageView2/0/w/800"></p><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/local/lib/python3.9/site-packages/wechaty/wechaty.py&quot;, line 445, in start</span><br><span class="line">    await self.puppet.start()</span><br><span class="line">  File &quot;/usr/local/lib/python3.9/site-packages/wechaty_puppet_service/puppet.py&quot;, line 911, in start</span><br><span class="line">    self._init_puppet()</span><br><span class="line">  File &quot;/usr/local/lib/python3.9/site-packages/wechaty_puppet_service/puppet.py&quot;, line 894, in _init_puppet</span><br><span class="line">    raise WechatyPuppetConfigurationError(</span><br><span class="line">wechaty_puppet.exceptions.WechatyPuppetConfigurationError: WechatyPuppetConfigurationError(&quot;can&#x27;t not ping endpoint: 42.194.xxx.xxx:8080&quot;, None, None)</span><br></pre></td></tr></table></figure><p>这是因为，机器人连接Gateway Docker时，使用了外网IP，而外网IP的8080端口并未开放。<br>有两个解决办法：（1）开放外网IP的8080端口；（2）配置使用 <code>WECHATY_PUPPET_SERVICE_ENDPOINT</code> 变量。</p><p>这里选择第二种方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name bot -d \</span><br><span class="line">    -v $(<span class="built_in">pwd</span>):/bot \</span><br><span class="line">    -p 8004:8004 \</span><br><span class="line">    -e WECHATY_PUPPET_SERVICE_ENDPOINT=<span class="string">&quot;192.168.56.101:8080&quot;</span> \</span><br><span class="line">    py-wechaty-template-bot:latest</span><br><span class="line"></span><br><span class="line">docker logs -f bot</span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/wechaty-start/qrcode.png?imageView2/0/w/800"><br>这里有个错误：<code>Wechaty - ERROR - internal error &lt;&gt;</code><br>参考<a href="https://github.com/wechaty/python-wechaty-getting-started/issues/63">Wechaty - ERROR - internal error and failed to scan</a>，忽略即可。</p><p>扫描登录，第一次登录时，会询问你登录的是 mac、windows还是ipad，这里要选择ipad。</p><p>登录成功后，半分钟左右，会自动退出，提示<code>为了你的账号安全，请重新登录。</code><br><img src="https://cdn.voidking.com/imgs/wechaty-start/logout.png?imageView2/0/w/800"></p><p>然后，再扫描登录，登录成功后还是会退出，后来再扫描二维码就没有反应了。。。</p><p>Padlocal Get Started，以失败告终。</p><h1 id="Paimon-Get-Started"><span class="post-title-index">4. </span><a href="#Paimon-Get-Started" class="headerlink" title="Paimon Get Started"></a>Paimon Get Started</h1><p>Paimon相对于Padlocal，缺点很多：发送/接收图片、文件较慢；不支持接收/转发动图；不支持接收/发送语音消息；不支持转发音频/视频等。<br>不过，Paimon最大的优点就是简单，这就够了，关键是能用。</p><p>参考文档：</p><ul><li><a href="https://github.com/wechaty/python-wechaty-getting-started/">github - wechaty/python-wechaty-getting-started</a></li><li><a href="https://wechaty.readthedocs.io/zh_CN/latest/introduction/use-paimon-protocol/">使用Paimon协议</a></li></ul><h2 id="申请Token-1"><span class="post-title-index">4.1. </span><a href="#申请Token-1" class="headerlink" title="申请Token"></a>申请Token</h2><p>申请Token链接：<a href="https://wechaty.js.org/docs/puppet-services/paimon#how-to-buy">Puppet Service: Paimon</a><br>免费试用Token可以使用7天，续费200元/月。建议成为Wechaty开发者，可以免费续期Token，参考文档<a href="https://github.com/juzibot/Welcome/wiki/How-to-be-a-Wechaty-Contributor">How to be a Wechaty Contributor</a>。</p><h2 id="运行机器人-1"><span class="post-title-index">4.2. </span><a href="#运行机器人-1" class="headerlink" title="运行机器人"></a>运行机器人</h2><p>1、安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install wechaty -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure><p>2、编写脚本 test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio, os</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span>, <span class="type">Optional</span>, <span class="type">Union</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> wechaty_puppet <span class="keyword">import</span> FileBox  <span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> wechaty <span class="keyword">import</span> Wechaty, Contact</span><br><span class="line"><span class="keyword">from</span> wechaty.user <span class="keyword">import</span> Message, Room</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBot</span>(<span class="title class_ inherited__">Wechaty</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">on_message</span>(<span class="params">self, msg: Message</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        listen for message event</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        from_contact: <span class="type">Optional</span>[Contact] = msg.talker()</span><br><span class="line">        text = msg.text()</span><br><span class="line">        room: <span class="type">Optional</span>[Room] = msg.room()</span><br><span class="line">        <span class="keyword">if</span> text == <span class="string">&#x27;ding&#x27;</span>:</span><br><span class="line">            conversation: <span class="type">Union</span>[</span><br><span class="line">                Room, Contact] = from_contact <span class="keyword">if</span> room <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">else</span> room</span><br><span class="line">            <span class="keyword">await</span> conversation.ready()</span><br><span class="line">            <span class="keyword">await</span> conversation.say(<span class="string">&#x27;dong&#x27;</span>)</span><br><span class="line">            <span class="comment"># file_box = FileBox.from_url(</span></span><br><span class="line">            <span class="comment">#     &#x27;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/&#x27;</span></span><br><span class="line">            <span class="comment">#     &#x27;u=1116676390,2305043183&amp;fm=26&amp;gp=0.jpg&#x27;,</span></span><br><span class="line">            <span class="comment">#     name=&#x27;ding-dong.jpg&#x27;)</span></span><br><span class="line">            file_box = FileBox.from_url(</span><br><span class="line">                <span class="string">&#x27;https://cdn.voidking.com/@/imgs/about/about.png?imageView2/0/w/1000&#x27;</span>,</span><br><span class="line">                name=<span class="string">&#x27;ding-dong.jpg&#x27;</span>)</span><br><span class="line">            <span class="keyword">await</span> conversation.say(file_box)</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">&#x27;TOKEN&#x27;</span>] = <span class="string">&quot;puppet_paimon_1fe5f846-3cfb-401d-b20c-XXXXX&quot;</span></span><br><span class="line">asyncio.run(MyBot().start())</span><br></pre></td></tr></table></figure><p>3、启动脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python test.py</span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/wechaty-start/paimon-login.png?imageView2/0/w/800"><br>使用微信号B扫码登录微信。</p><p>4、测试 ding dong<br>使用微信号A给微信号B发送一个<code>ding</code>，可以收到自动回复的<code>dong</code>，但是并没有接收到图片消息。<br>代码出现了报错：<br><img src="https://cdn.voidking.com/imgs/wechaty-start/ding.png?imageView2/0/w/800"></p><p>经查，是因为教程中给的图片地址过期了，换成可用的地址后，可以正常接收到图片消息了。<br><img src="https://cdn.voidking.com/imgs/wechaty-start/result.png?imageView2/0/w/800"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Wechaty简介&quot;&gt;&lt;a href=&quot;#Wechaty简介&quot; class=&quot;headerlink&quot; title=&quot;Wechaty简介&quot;&gt;&lt;/a&gt;Wechaty简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Wechaty 是一个开源聊天机器人框架SDK，具有高度封装、高可用的特性，支持NodeJs, Python, Go 和Java 等多语言版本。在过去的4年中，服务了数万名开发者，收获了 Github 的 1w+ Star。同时配置了完整的 DevOps 体系并持续按照 Apache 的方式管理技术社区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/wechaty/getting-started&quot;&gt;github - wechaty/getting-started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Wechaty/python-wechaty&quot;&gt;github - Wechaty/python-wechaty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/wechaty/python-wechaty-template&quot;&gt;github - wechaty/python-wechaty-template&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/wechaty/python-wechaty-getting-started/&quot;&gt;github - wechaty/python-wechaty-getting-started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/wechaty/docker-getting-started&quot;&gt;github - wechaty/docker-getting-started&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/juzibot/Welcome/wiki/Everything-about-Wechaty&quot;&gt;Everything about Wechaty&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wechaty.readthedocs.io/zh_CN/latest/&quot;&gt;python-wechaty首页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wechaty.readthedocs.io/zh_CN/latest/introduction/use-padlocal-protocol/&quot;&gt;使用Padlocal协议&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/wechaty/puppet-padlocal&quot;&gt;github - wechaty/puppet-padlocal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wechaty.readthedocs.io/zh_CN/latest/introduction/use-paimon-protocol/&quot;&gt;使用Paimon协议&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="微信" scheme="https://www.voidking.com/tags/%E5%BE%AE%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker安装配置OPANAI API代理</title>
    <link href="https://www.voidking.com/dev-docker-openai-api-proxy/"/>
    <id>https://www.voidking.com/dev-docker-openai-api-proxy/</id>
    <published>2023-07-16T08:00:00.000Z</published>
    <updated>2023-12-16T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OPENAI API代理，顾名思义，是一种用于代理OPENAI API的专用代理。<br>目前OPENAI API代理中，做的比较好的是 openai-forward。本文中，我们基于Docker安装配置一下openai-forward。</p><p>参考文档：</p><ul><li><a href="https://github.com/KenyonY/openai-forward">github - KenyonY/openai-forward</a></li><li><a href="https://www.voidking.com/dev-python-openai-api/">《Python调用OpenAI API》</a></li></ul><span id="more"></span><h1 id="使用openai-forward代理"><span class="post-title-index">2. </span><a href="#使用openai-forward代理" class="headerlink" title="使用openai-forward代理"></a>使用openai-forward代理</h1><p><a href="https://github.com/KenyonY/openai-forward">KenyonY/openai-forward</a>项目作者提供了三个公开的代理服务。</p><ul><li>原始 OpenAI 服务地址1：<a href="https://api.openai-forward.com/">https://api.openai-forward.com</a></li><li>原始 OpenAI 服务地址2：<a href="https://render.openai-forward.com/">https://render.openai-forward.com</a></li><li>开启缓存的服务地址（用户请求结果将被保存一段时间）：<a href="https://smart.openai-forward.com/">https://smart.openai-forward.com</a></li></ul><p>命令行使用OPENAI API代理的方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openai -b <span class="string">&quot;https://api.openai-forward.com/v1&quot;</span> api chat_completions.create -m gpt-3.5-turbo -g user <span class="string">&quot;Hello world&quot;</span></span><br></pre></td></tr></table></figure><p>Python使用OPEANAI API代理的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> openai</span><br><span class="line"></span><br><span class="line">openai.api_base = <span class="string">&#x27;https://api.openai-forward.com/v1&#x27;</span></span><br><span class="line">openai.api_key = <span class="string">&#x27;sk-xxx&#x27;</span></span><br><span class="line"></span><br><span class="line">chat_completion = openai.ChatCompletion.create(model=<span class="string">&quot;gpt-3.5-turbo&quot;</span>, messages=[&#123;<span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>, <span class="string">&quot;content&quot;</span>: <span class="string">&quot;Hello world&quot;</span>&#125;])</span><br><span class="line"><span class="built_in">print</span>(chat_completion)</span><br></pre></td></tr></table></figure><h1 id="自建openai-forward代理"><span class="post-title-index">3. </span><a href="#自建openai-forward代理" class="headerlink" title="自建openai-forward代理"></a>自建openai-forward代理</h1><h2 id="机器准备"><span class="post-title-index">3.1. </span><a href="#机器准备" class="headerlink" title="机器准备"></a>机器准备</h2><p>如果打算自建 openai-forward 服务，那么首先要准备一台海外的可以访问 OPENAI API 的主机。</p><p>主机测试方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://api.openai.com/v1</span><br></pre></td></tr></table></figure><p>正常响应：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;invalid_request_error&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="string">&quot;unknown_url&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Unknown request URL: GET /v1. Please check the URL for typos, or see the docs at https://platform.openai.com/docs/api-reference/.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;param&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">null</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果有正常响应，那么说明这台主机是满足需求的。</p><h2 id="安装配置openai-forward"><span class="post-title-index">3.2. </span><a href="#安装配置openai-forward" class="headerlink" title="安装配置openai-forward"></a>安装配置openai-forward</h2><p>1、下载openai-forward镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull beidongjiedeguang/openai-forward:latest</span><br></pre></td></tr></table></figure><p>2、启动openai-forward容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name openai-forward -d \</span><br><span class="line">    --restart=always \</span><br><span class="line">    -p 8000:8000 \</span><br><span class="line">    beidongjiedeguang/openai-forward:latest </span><br></pre></td></tr></table></figure><p>3、检查容器状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker logs openai-forward</span><br></pre></td></tr></table></figure><h1 id="配置Nginx"><span class="post-title-index">4. </span><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h1><p>http配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    map $http_upgrade $connection_upgrade &#123;</span><br><span class="line">      default upgrade;</span><br><span class="line">      &#x27;&#x27;      close;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>server配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name openai-forward.voidking.com;</span><br><span class="line">    rewrite ^(.*) https://openai-forward.voidking.com$1 permanent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name openai-forward.voidking.com;</span><br><span class="line">    access_log off;</span><br><span class="line">    error_log off;</span><br><span class="line"></span><br><span class="line">    ssl_certificate /etc/nginx/ssl/openai-forward.voidking.com/openai-forward.voidking.com_bundle.crt;</span><br><span class="line">    ssl_certificate_key /etc/nginx/ssl/openai-forward.voidking.com/openai-forward.voidking.com.key;</span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass http://127.0.0.1:8000;</span><br><span class="line">        proxy_redirect off;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">        proxy_set_header Connection $connection_upgrade;</span><br><span class="line">        proxy_max_temp_file_size 0;</span><br><span class="line">        client_max_body_size 10m;</span><br><span class="line">        client_body_buffer_size 128k;</span><br><span class="line">        proxy_connect_timeout 90;</span><br><span class="line">        proxy_send_timeout 90;</span><br><span class="line">        proxy_read_timeout 90;</span><br><span class="line">        proxy_temp_file_write_size 64k;</span><br><span class="line">        proxy_buffering off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;OPENAI API代理，顾名思义，是一种用于代理OPENAI API的专用代理。&lt;br&gt;目前OPENAI API代理中，做的比较好的是 openai-forward。本文中，我们基于Docker安装配置一下openai-forward。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/KenyonY/openai-forward&quot;&gt;github - KenyonY/openai-forward&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-python-openai-api/&quot;&gt;《Python调用OpenAI API》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="nginx" scheme="https://www.voidking.com/tags/nginx/"/>
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
  </entry>
  
  <entry>
    <title>MetaGPT快速体验</title>
    <link href="https://www.voidking.com/dev-metagpt-quickstart/"/>
    <id>https://www.voidking.com/dev-metagpt-quickstart/</id>
    <published>2023-07-16T08:00:00.000Z</published>
    <updated>2023-07-29T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>MetaGPT是一个多智能体编程框架。我们提出需求，MetaGPT能够通过模拟出公司里的各种角色，把产品做出来。</p><p>例如，我们提出需求“写一个命令行贪吃蛇游戏”。那么当MetaGPT程序运行完成之后，会生成设计文档、图片、代码文件等交付给我们。然后，运行MetaGPT生成的代码，就可以愉快地玩游戏了！</p><p>github仓库：<a href="https://github.com/geekan/MetaGPT">geekan/MetaGPT</a></p><p>而很多同学想要体验MetaGPT的同学，都卡在了第一步：安装配置基础环境。<br>本文的目标就是为了弱化环境限制，让大家快速体验到MetaGPT的魅力。在不依赖任何本地环境的基础上（只要你有一个浏览器），让MetaGPT开始工作，整个操作大概需要5到10分钟。</p><span id="more"></span><h1 id="Step-1：准备云端环境"><span class="post-title-index">2. </span><a href="#Step-1：准备云端环境" class="headerlink" title="Step 1：准备云端环境"></a>Step 1：准备云端环境</h1><p>不依赖本地环境，那么我们需要一个云端环境。这里我们选择使用<a href="https://labs.play-with-docker.com/">Docker Playground</a>，因为这个环境具备Docker，同时可以访问 <code>https://api.openai.com/v1</code>，关键还免费。</p><p>具体操作：</p><ol><li>访问<a href="https://labs.play-with-docker.com/">Docker Playground</a>，使用docker hub账号登录。没有账号的话先注册一个，也是免费的。</li></ol><p><img src="https://cdn.voidking.com/imgs/metagpt-quickstart/docker-playground.png?imageView2/0/w/800"></p><p>注意：因为资源有限，所以有时候可能登录失败，报错：We are really sorry but we are out of capacity and cannot create your session at the moment. Please try again later.</p><p>如果出现上面的提示，可以等待一会儿后再次登录，也可以改用<a href="https://labs.play-with-k8s.com/">Kubernetes Playground</a>。当然，如果你有更合适的云端环境，也是可以的。</p><ol start="2"><li>登录到Docker Playground后，点击 <code>ADD NEW INSTANCE</code>，启动一个虚拟机。<br><img src="https://cdn.voidking.com/imgs/metagpt-quickstart/add-instance.png?imageView2/0/w/800"></li></ol><h1 id="Step-2：准备MetaGPT配置"><span class="post-title-index">3. </span><a href="#Step-2：准备MetaGPT配置" class="headerlink" title="Step 2：准备MetaGPT配置"></a>Step 2：准备MetaGPT配置</h1><p>参考文档 <a href="https://github.com/geekan/MetaGPT/blob/main/README.md">MetaGPT README</a> 的 Installation by Docker 部分，执行操作：</p><p>1、 下载镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull metagpt/metagpt:v0.3.1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/metagpt-quickstart/docker-pull.png?imageView2/0/w/800"></p><p>2、 准备挂载目录和配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /opt/metagpt/&#123;config,workspace&#125;</span><br><span class="line">docker run --<span class="built_in">rm</span> metagpt/metagpt:v0.3.1 <span class="built_in">cat</span> /app/metagpt/config/config.yaml &gt; /opt/metagpt/config/key.yaml</span><br><span class="line">vim /opt/metagpt/config/key.yaml <span class="comment"># Change the config</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/metagpt-quickstart/config.png?imageView2/0/w/800"></p><p>编辑 key.yaml 时，如果使用的是OPENAI的API，那么只需要修改 <code>OPENAI_API_MODEL</code> 和 <code>OPENAI_API_KEY</code>，这两个值需要对应，<code>gpt-4</code>要对应 gpt-4 的KEY，<code>gpt-3.5-turbo</code>要对应 gpt-3.5 的KEY。</p><h1 id="Step-3：让MetaGPT工作"><span class="post-title-index">4. </span><a href="#Step-3：让MetaGPT工作" class="headerlink" title="Step 3：让MetaGPT工作"></a>Step 3：让MetaGPT工作</h1><p>1、 运行一个MetaGPT容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name metagpt -d \</span><br><span class="line">    --privileged \</span><br><span class="line">    -v /opt/metagpt/config/key.yaml:/app/metagpt/config/key.yaml \</span><br><span class="line">    -v /opt/metagpt/workspace:/app/metagpt/workspace \</span><br><span class="line">    metagpt/metagpt:v0.3.1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/metagpt-quickstart/start-container.png?imageView2/0/w/800"></p><p>2、 进入容器内部执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it metagpt /bin/bash</span><br><span class="line">$ python startup.py <span class="string">&quot;write a cli snake game&quot;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.voidking.com/imgs/metagpt-quickstart/metagpt-run.png?imageView2/0/w/800"></p><p>容器内生成的文件会存放在目录 <code>/app/metagpt/workspace</code> ，对应宿主机目录 <code>/opt/metagpt/workspace</code> 。</p><h1 id="Step-4：下载项目"><span class="post-title-index">5. </span><a href="#Step-4：下载项目" class="headerlink" title="Step 4：下载项目"></a>Step 4：下载项目</h1><p>1、 打包workspace</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 宿主机中执行</span></span><br><span class="line"><span class="built_in">cd</span> /opt/metagpt</span><br><span class="line">tar -czvf workspace.tgz workspace</span><br></pre></td></tr></table></figure><p>2、 启动web服务以便下载项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m http.server 9999</span><br></pre></td></tr></table></figure><p>3、 Docker Playground开放端口<br>点击页面上的 <code>OPEN PORT</code>，输入 <code>9999</code>，点击确定，即可打开Web页面。</p><p><img src="https://cdn.voidking.com/imgs/metagpt-quickstart/openport.png?imageView2/0/w/800"></p><p>4、 下载项目<br>在Web页面上，点击 <code>workspace.tgz</code> ，即可下载MetaGTP生成的项目。<br><img src="https://cdn.voidking.com/imgs/metagpt-quickstart/download.png?imageView2/0/w/600"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;MetaGPT是一个多智能体编程框架。我们提出需求，MetaGPT能够通过模拟出公司里的各种角色，把产品做出来。&lt;/p&gt;
&lt;p&gt;例如，我们提出需求“写一个命令行贪吃蛇游戏”。那么当MetaGPT程序运行完成之后，会生成设计文档、图片、代码文件等交付给我们。然后，运行MetaGPT生成的代码，就可以愉快地玩游戏了！&lt;/p&gt;
&lt;p&gt;github仓库：&lt;a href=&quot;https://github.com/geekan/MetaGPT&quot;&gt;geekan/MetaGPT&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;而很多同学想要体验MetaGPT的同学，都卡在了第一步：安装配置基础环境。&lt;br&gt;本文的目标就是为了弱化环境限制，让大家快速体验到MetaGPT的魅力。在不依赖任何本地环境的基础上（只要你有一个浏览器），让MetaGPT开始工作，整个操作大概需要5到10分钟。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
  </entry>
  
  <entry>
    <title>K8S Dashboard</title>
    <link href="https://www.voidking.com/dev-k8s-dashboard/"/>
    <id>https://www.voidking.com/dev-k8s-dashboard/</id>
    <published>2023-06-17T08:00:00.000Z</published>
    <updated>2023-06-22T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K8S-Dashboard简介"><span class="post-title-index">1. </span><a href="#K8S-Dashboard简介" class="headerlink" title="K8S Dashboard简介"></a>K8S Dashboard简介</h1><p>K8S Dashboard 是基于网页的 Kubernetes 用户界面。使用 Dashboard 可以将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群资源。 可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源 （如 Deployment，Job，DaemonSet 等等）。例如，可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。</p><p>Dashboard 同时展示了 Kubernetes 集群中的资源状态信息和所有报错信息。</p><p>参考文档：</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/">部署和访问 Kubernetes 仪表板（Dashboard）</a></li><li><a href="https://todoit.tech/k8s/dashboard/">安装 Kubernetes Dashboard</a></li></ul><span id="more"></span><h1 id="安装K8S-Dashboard"><span class="post-title-index">2. </span><a href="#安装K8S-Dashboard" class="headerlink" title="安装K8S Dashboard"></a>安装K8S Dashboard</h1><p>1、执行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.7.0/aio/deploy/recommended.yaml</span><br><span class="line">kubectl apply -f recommended.yaml</span><br></pre></td></tr></table></figure><p>2、查看安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get all -n kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>3、开放外部访问<br>方法一：修改servcie类型为NodePort<br>方法二：添加ingress<br>方法三：代理K8S API <code>kubectl proxy --port=6880</code><br>方法四：代理服务端口 <code>kubectl port-forward service/kubernetes-dashboard --address 0.0.0.0 10443:443</code></p><p>4、访问Dashboard<br>浏览器访问Dashboard，提示输入Token或者选择Kubeconfig文件进行登录。（Token的获取方法下一节有说明）<br>登录后，就可以看到K8S中的资源对象，并且对它们进行操作。</p><h1 id="获取Token"><span class="post-title-index">3. </span><a href="#获取Token" class="headerlink" title="获取Token"></a>获取Token</h1><p>1、创建sa</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create sa admin-user -n kubernetes-dashboard</span><br></pre></td></tr></table></figure><p>2、添加sa到clusterrolebinding</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit clusterrolebinding cluster-admin</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure><p>3、获取token</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create token admin-user -n kubernetes-dashboard --duration=8760h</span><br></pre></td></tr></table></figure><p>更多关于sa的知识，参考文档<a href="https://www.voidking.com/dev-k8s-useraccount-serviceaccount/">《K8S中创建用户账户和服务账户》</a></p><h1 id="开启统计"><span class="post-title-index">4. </span><a href="#开启统计" class="headerlink" title="开启统计"></a>开启统计</h1><p>参考文档<a href="https://www.voidking.com/dev-k8s-problem/">《K8S问题记录》</a>的【kubectl top命令执行报错】部分。</p><h1 id="扩展"><span class="post-title-index">5. </span><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="Grafana"><span class="post-title-index">5.1. </span><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h2><p>Grafana是一个开源的可视化和监控平台，支持与Kubernetes集成。</p><p>安装使用方法参考文档：<a href="https://www.voidking.com/dev-docker-grafana/">《使用Docker安装配置Grafana》</a></p><h2 id="KubeView"><span class="post-title-index">5.2. </span><a href="#KubeView" class="headerlink" title="KubeView"></a>KubeView</h2><p>KubeView是一个基于Web的Kubernetes资源可视化工具，可以以图形方式显示Kubernetes集群中的资源关系和拓扑。</p><p>KubeView功能较单一，只能显示资源拓扑。</p><p>参考文档：</p><ul><li><a href="https://github.com/benc-uk/kubeview">benc-uk/kubeview</a></li><li><a href="https://zhuanlan.zhihu.com/p/400013270">Kubernetes 监控：Kubeview</a></li></ul><p>【安装KubeView】</p><p>1、 下载helm chart</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/benc-uk/kubeview</span><br><span class="line"><span class="built_in">cd</span> kubeview/charts/</span><br></pre></td></tr></table></figure><p>2、修改配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim kubeview/values.yaml</span><br></pre></td></tr></table></figure><p>如下修改：</p><ul><li>image.repository: ghcr.dockerproxy.com/benc-uk/kubeview</li><li>loadBalancer.enabled: false</li></ul><p>3、安装kubeview</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm install kubeview kubeview -n kubeview --create-namespace</span><br><span class="line">kubectl get all -n kubeview</span><br></pre></td></tr></table></figure><p>4、暴露服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch service/kubeview -n kubeview -p <span class="string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;type&quot;: &quot;NodePort&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="Weave-Scope"><span class="post-title-index">5.3. </span><a href="#Weave-Scope" class="headerlink" title="Weave Scope"></a>Weave Scope</h2><p>Weave Scope是一个开源工具，提供了对Kubernetes集群的实时可视化和监控功能。</p><p>Weave Scope除了可以查看同层资源的关系和拓扑，还可以查看资源使用情况。</p><p>注意：Weave Scope已经停止更新。</p><p>参考文档：</p><ul><li><a href="https://github.com/weaveworks/scope">weaveworks/scope</a></li><li><a href="https://www.weave.works/blog/weave-cloud-end-of-service">Weave Cloud: End of Service Announcement</a></li><li><a href="https://www.weave.works/docs/scope/latest/installing/#k8s">Installing Weave Scope</a></li></ul><p>【安装Weave Scope】</p><p>1、安装Weave Scope</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/weaveworks/scope/releases/download/v1.13.2/k8s-scope.yaml</span><br><span class="line">kubectl apply -f k8s-scope.yaml</span><br><span class="line">kubectl get all -n weave</span><br></pre></td></tr></table></figure><p>2、暴露服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch service/weave-scope-app -n weave -p <span class="string">&#x27;&#123;&quot;spec&quot;: &#123;&quot;type&quot;: &quot;NodePort&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;K8S-Dashboard简介&quot;&gt;&lt;a href=&quot;#K8S-Dashboard简介&quot; class=&quot;headerlink&quot; title=&quot;K8S Dashboard简介&quot;&gt;&lt;/a&gt;K8S Dashboard简介&lt;/h1&gt;&lt;p&gt;K8S Dashboard 是基于网页的 Kubernetes 用户界面。使用 Dashboard 可以将容器应用部署到 Kubernetes 集群中，也可以对容器应用排错，还能管理集群资源。 可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源 （如 Deployment，Job，DaemonSet 等等）。例如，可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。&lt;/p&gt;
&lt;p&gt;Dashboard 同时展示了 Kubernetes 集群中的资源状态信息和所有报错信息。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/access-application-cluster/web-ui-dashboard/&quot;&gt;部署和访问 Kubernetes 仪表板（Dashboard）&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://todoit.tech/k8s/dashboard/&quot;&gt;安装 Kubernetes Dashboard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="monitoring" scheme="https://www.voidking.com/categories/engineering/monitoring/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    
    <category term="监控" scheme="https://www.voidking.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Helm官方文档摘录</title>
    <link href="https://www.voidking.com/dev-helm-doc-extract/"/>
    <id>https://www.voidking.com/dev-helm-doc-extract/</id>
    <published>2023-05-27T08:00:00.000Z</published>
    <updated>2023-05-27T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Helm官方文档写的很棒，本文会摘录Helm官方文档中的一些基础知识和最佳实践，备忘。<br>更细致全面的内容，请移步阅读<a href="https://helm.sh/zh/docs/">Helm官方文档</a>。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-helm-start/">《Helm入门篇》</a></li><li><a href="https://helm.sh/zh/docs/chart_template_guide/getting_started/">Helm - Getting Started</a></li></ul><span id="more"></span><h1 id="Helm三大概念"><span class="post-title-index">2. </span><a href="#Helm三大概念" class="headerlink" title="Helm三大概念"></a>Helm三大概念</h1><p>Chart 代表着 Helm 包。它包含在 Kubernetes 集群内部运行应用程序，工具或服务所需的所有资源定义。你可以把它看作是 Homebrew formula，Apt dpkg，或 Yum RPM 在Kubernetes 中的等价物。</p><p>Repository（仓库） 是用来存放和共享 charts 的地方。它就像 Perl 的 CPAN 档案库网络 或是 Fedora 的 软件包仓库，只不过它是供 Kubernetes 包所使用的。</p><p>Release 是运行在 Kubernetes 集群中的 chart 的实例。一个 chart 通常可以在同一个集群中安装多次。每一次安装都会创建一个新的 release。以 MySQL chart为例，如果你想在你的集群中运行两个数据库，你可以安装该chart两次。每一个数据库都会拥有它自己的 release 和 release name。</p><p>在了解了上述这些概念以后，我们就可以这样来解释 Helm：<br>Helm 安装 charts 到 Kubernetes 集群中，每次安装都会创建一个新的 release。你可以在 Helm 的 chart repositories 中寻找新的 chart。</p><h1 id="Helm安装资源的顺序"><span class="post-title-index">3. </span><a href="#Helm安装资源的顺序" class="headerlink" title="Helm安装资源的顺序"></a>Helm安装资源的顺序</h1><p>Helm按照以下顺序安装资源：</p><ul><li>Namespace</li><li>NetworkPolicy</li><li>ResourceQuota</li><li>LimitRange</li><li>PodSecurityPolicy</li><li>PodDisruptionBudget</li><li>ServiceAccount</li><li>Secret</li><li>SecretList</li><li>ConfigMap</li><li>StorageClass</li><li>PersistentVolume</li><li>PersistentVolumeClaim</li><li>CustomResourceDefinition</li><li>ClusterRole</li><li>ClusterRoleList</li><li>ClusterRoleBinding</li><li>ClusterRoleBindingList</li><li>Role</li><li>RoleList</li><li>RoleBinding</li><li>RoleBindingList</li><li>Service</li><li>DaemonSet</li><li>Pod</li><li>ReplicationController</li><li>ReplicaSet</li><li>Deployment</li><li>HorizontalPodAutoscaler</li><li>StatefulSet</li><li>Job</li><li>CronJob</li><li>Ingress</li><li>APIService</li></ul><h1 id="Chart模板指南"><span class="post-title-index">4. </span><a href="#Chart模板指南" class="headerlink" title="Chart模板指南"></a>Chart模板指南</h1><p>内容太多，建议直接阅读<a href="https://helm.sh/zh/docs/chart_template_guide/getting_started/">Helm官方文档 - Chart模板指南</a>，了解基础概念和语法。</p><p>本节只简单说明几个概念和语法。</p><h2 id="模板"><span class="post-title-index">4.1. </span><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><code>templates/</code>目录中的<code>.yaml</code>文件和<code>.tpl</code>文件，就是模板。<br>当Helm评估chart时，会通过模板渲染引擎将所有文件发送到templates/目录中。 然后收集模板的结果并发送给Kubernetes。</p><p>values.yaml 文件也导入到了模板。这个文件包含了chart的 默认值 。这些值会在用户执行helm install 或 helm upgrade时被覆盖。</p><p>Chart.yaml 文件包含了该chart的描述。你可以从模板中访问它。charts/目录 可以 包含其他的chart(称之为 子chart)。</p><p>模板中横线的作用：</p><ul><li><code>&#123;&#123;-`：表示在模板渲染时要去掉前面的空白字符和换行符。- `-&#125;&#125;</code>：表示在模板渲染时要去掉后面的空白字符和换行符。</li></ul><h2 id="变量和作用域"><span class="post-title-index">4.2. </span><a href="#变量和作用域" class="headerlink" title="变量和作用域"></a>变量和作用域</h2><p>Helm模板中，变量是对另一个对象的命名引用。</p><p>变量的作用域一般不是全局的，而是其声明所在的块。所谓块，是指<code>if/else</code>、<code>with</code>、<code>range</code>、<code>define</code>、<code>template</code>、<code>block</code>定义的范围。</p><p><code>.</code>代表对当前作用域的引用，<code>.Values</code>表示在当前作用域查找Values对象。<br>每个模板中，默认可以访问到的内置对象有Release、Values、Chart、Files、Capabilities和Template。<br>如果定义了块，那么在块中不可以通过<code>.Values</code>找到Values对象。</p><p><code>$</code>代表对根作用域的引用，<code>$.Values</code>表示在根作用域查找Values对象。<br>如果定义了块，那么在块中可以通过<code>$.Values</code>找到Values对象。</p><p>变量定义格式示例：<code>&#123;&#123;- $name := .Release.Name -&#125;&#125;</code><br>在模板顶层定义变量，变量的作用域会是整个模板；在块中定义变量，变量的作用域只在块内。</p><h2 id="变量类型"><span class="post-title-index">4.3. </span><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>Helm 模板语言是用强类型Go编程语言实现的。 因此，模板中的变量是 有类型的。大多数情况下，变量将作为以下类型之一显示：</p><ul><li>string: 文本字符串</li><li>bool: true 或 false</li><li>int: 整型值（包含8位，16位，32位，和64有符号和无符号整数）</li><li>float64: 64位浮点数(也有8位，16位，32位类型)</li><li>字节切片([]byte)，一般用于保存（可能的）二进制数据</li><li>struct: 有属性和方法的对象</li><li>上述某种类型的切片(索引列表)</li><li>字符串键map (<code>map[string]interface&#123;&#125;</code>) 值是上述某种类型</li></ul><p>Go里面有很多其他类型，有时你需要在模板里转换。调试对象类型最简便的方式是在模板中传递给printf “%t”，这样会打印类型。 也可以使用 typeOf 和 kindOf 函数。</p><h2 id="命名模板"><span class="post-title-index">4.4. </span><a href="#命名模板" class="headerlink" title="命名模板"></a>命名模板</h2><p>命名模板（也被称作一个 部分 或一个 子模板）名称是全局的。<br>一个常见的命名惯例是用chart名称作为模板前缀。使用特定chart名称作为前缀可以避免可能因为 两个不同chart使用了相同名称的模板而引起的冲突。</p><p>用define和template声明和使用模板。<br>按照惯例，define声明的命名模板一般放在<code>_helpers.tpl</code>文件中。因为是模板名称是全局的，因此可以被<code>.yaml</code>文件引用。</p><p>template渲染时，一般传入<code>.</code>作为命名模板可以访问的范围。<br>include是template的替代，只是为了更好地处理YAML文档的输出格式，方便缩进。</p><h2 id="NOTES-txt文件"><span class="post-title-index">4.5. </span><a href="#NOTES-txt文件" class="headerlink" title="NOTES.txt文件"></a>NOTES.txt文件</h2><p>在helm install 或 helm upgrade命令的最后，Helm会打印出对用户有用的信息。 使用模板可以高度自定义这部分信息。<br>要在chart添加安装说明，只需创建 templates/NOTES.txt 文件即可。该文件是纯文本，但会像模板一样处理， 所有正常的模板函数和对象都是可用的。</p><h2 id="helmignore-文件"><span class="post-title-index">4.6. </span><a href="#helmignore-文件" class="headerlink" title=".helmignore 文件"></a>.helmignore 文件</h2><p><code>.helmignore</code> 文件用来指定你不想包含在你的helm chart中的文件。<br>如果该文件存在，helm package 命令会在打包应用时忽略所有在 <code>.helmignore</code> 文件中匹配的文件。</p><p>一些值得注意的和.gitignore不同之处：</p><ul><li>不支持<code>**</code>语法。</li><li>globbing库是Go的 ‘filepath.Match’，不是fnmatch(3)</li><li>末尾空格总会被忽略(不支持转义序列)</li><li>不支持<code>!</code>作为特殊的引导序列</li><li>默认不会排除自身，需要显式添加 .helmignore</li></ul><h2 id="YAML技术"><span class="post-title-index">4.7. </span><a href="#YAML技术" class="headerlink" title="YAML技术"></a>YAML技术</h2><p>参考文档：<a href="https://www.voidking.com/dev-yaml/">《YAML语言》</a></p><h1 id="Chart开发技巧"><span class="post-title-index">5. </span><a href="#Chart开发技巧" class="headerlink" title="Chart开发技巧"></a>Chart开发技巧</h1><h2 id="模板方法"><span class="post-title-index">5.1. </span><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>Helm使用<a href="https://pkg.go.dev/text/template">Go模板</a>，同时增加了两个特殊模板方法：<code>include</code>和<code>required</code>。</p><p>include方法允许你引入另一个模板，并将结果传递给其他模板方法。<br>比如，这个模板片段包含了一个叫mytpl的模板，然后将其转成小写，并使用双引号括起来。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value: &#123;&#123; include &quot;mytpl&quot; . | lower | quote &#125;&#125;</span><br></pre></td></tr></table></figure><p>required方法可以让你声明模板渲染所需的特定值。如果这个值是空的，模板渲染会出错并打印用户提交的错误信息。<br>下面这个required方法的例子声明了一个.Values.who需要的条目，并且当这个条目不存在时会打印错误信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value: &#123;&#123; required &quot;A valid .Values.who entry required!&quot; .Values.who &#125;&#125;</span><br></pre></td></tr></table></figure><p>tpl方法允许开发者在模板中使用字符串作为模板。将模板字符串作为值传给chart或渲染额外的配置文件时会很有用。<br>语法： <code>&#123;&#123; tpl TEMPLATE_STRING VALUES &#125;&#125;</code></p><h2 id="使用Partials和模板引用"><span class="post-title-index">5.2. </span><a href="#使用Partials和模板引用" class="headerlink" title="使用Partials和模板引用"></a>使用Partials和模板引用</h2><p>有时你想在chart中创建可以重复利用的部分，不管是块还是局部模板。通常将这些文件保存在自己的文件中会更干净。</p><p>在 <code>templates/</code> 目录中，任何以下划线(<code>_</code>)开始的文件不希望输出到Kubernetes清单文件中。<br>因此按照惯例，辅助模板和局部模板会被放在<code>_helpers.tpl</code>文件中。</p><h2 id="创建镜像拉取密钥"><span class="post-title-index">5.3. </span><a href="#创建镜像拉取密钥" class="headerlink" title="创建镜像拉取密钥"></a>创建镜像拉取密钥</h2><p>1、定义 values.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">imageCredentials:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="string">quay.io</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">someone</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">sillyness</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">someone@host.com</span></span><br></pre></td></tr></table></figure><p>2、定义辅助模板（写在 <code>_helpers.tpl</code> 文件里）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;imagePullSecret&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- with .Values.imageCredentials &#125;&#125;</span><br><span class="line">&#123;&#123;- printf &quot;&#123;\&quot;auths\&quot;:&#123;\&quot;%s\&quot;:&#123;\&quot;username\&quot;:\&quot;%s\&quot;,\&quot;password\&quot;:\&quot;%s\&quot;,\&quot;email\&quot;:\&quot;%s\&quot;,\&quot;auth\&quot;:\&quot;%s\&quot;&#125;&#125;&#125;&quot; .registry .username .password .email (printf &quot;%s:%s&quot; .username .password | b64enc) | b64enc &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p>3、模板中使用辅助模板</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myregistrykey</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/dockerconfigjson</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">.dockerconfigjson:</span> &#123;&#123; <span class="string">template</span> <span class="string">&quot;imagePullSecret&quot;</span> <span class="string">.</span> &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="YAML是JSON的超集"><span class="post-title-index">5.4. </span><a href="#YAML是JSON的超集" class="headerlink" title="YAML是JSON的超集"></a>YAML是JSON的超集</h2><p>根据YAML规范，YAML是JSON的超集。这意味着任意的合法JSON结构在YAML中应该是合法的。</p><p>这有个优势：有时候模板开发者会发现使用类JSON语法更容易表达数据结构而不是处理YAML的空白敏感度。</p><p>作为最佳实践，模板应遵循类YAML语法 除非 JSON语法大大降低了格式问题的风险。</p><h2 id="构建复杂Chart"><span class="post-title-index">5.5. </span><a href="#构建复杂Chart" class="headerlink" title="构建复杂Chart"></a>构建复杂Chart</h2><p>在CNCF的 Artifact Hub 中的很多chart是创建更先进应用的“组成部分”。但是chart可能被用于创建大规模应用实例。 在这种场景中，一个总的chart会有很多子chart，每一个是整体功能的一部分。</p><p>当前从离散组件组成一个复杂应用的最佳实践是创建一个顶层总体chart构建全局配置，然后使用charts子目录嵌入每个组件。</p><h1 id="最佳实践"><span class="post-title-index">6. </span><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="一般惯例"><span class="post-title-index">6.1. </span><a href="#一般惯例" class="headerlink" title="一般惯例"></a>一般惯例</h2><h3 id="chart名称"><span class="post-title-index">6.1.1. </span><a href="#chart名称" class="headerlink" title="chart名称"></a>chart名称</h3><p>chart名称必须是小写字母和数字。单词之间可以使用横杠分隔(-)。</p><h3 id="版本号"><span class="post-title-index">6.1.2. </span><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>Helm尽可能使用 <a href="https://semver.org/">SemVer 2</a>来表示版本号。（注意Docker镜像的tag不一定遵循SemVer， 因此被认为是一个不幸的例外规则。）</p><p>当SemVer版本存储在Kubernetes标签中时，我们通常把+字符改成_，因为标签不允许使用+作为值进行签名。</p><h3 id="格式化YAML"><span class="post-title-index">6.1.3. </span><a href="#格式化YAML" class="headerlink" title="格式化YAML"></a>格式化YAML</h3><p>YAML 文件应该按照 双空格 缩进(绝不要使用tab键)。</p><h3 id="Helm-和-Chart的用法"><span class="post-title-index">6.1.4. </span><a href="#Helm-和-Chart的用法" class="headerlink" title="Helm 和 Chart的用法"></a>Helm 和 Chart的用法</h3><p>以下是几个 Helm 和 helm 的惯用方法。</p><ul><li>Helm 是指整个项目</li><li>helm 是指客户端命令</li><li>chart 不是专有名词，不需要首字母大写</li><li>Chart.yaml 需要首字母大写，因为文件名大小写敏感</li></ul><p>若有疑问，使用 Helm (‘H’大写)。</p><h2 id="Values"><span class="post-title-index">6.2. </span><a href="#Values" class="headerlink" title="Values"></a>Values</h2><h3 id="命名规范"><span class="post-title-index">6.2.1. </span><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>变量名称以小写字母开头，单词按驼峰区分</p><h3 id="扁平或嵌套的Value"><span class="post-title-index">6.2.2. </span><a href="#扁平或嵌套的Value" class="headerlink" title="扁平或嵌套的Value"></a>扁平或嵌套的Value</h3><p>YAML是一种灵活格式，值可以嵌套得很深，也可以是扁平的。<br>大多数场景中，扁平的优于嵌套的。因为对模板开发者和用户来说更加简单。</p><h3 id="类型清楚"><span class="post-title-index">6.2.3. </span><a href="#类型清楚" class="headerlink" title="类型清楚"></a>类型清楚</h3><p>YAML的类型强制规则有时候是很反常的。比如，foo: false 和 foo: “false” 是不一样的。大整型数如：foo: 12345678 有时会被转换成科学计数法。</p><p>避免类型强制规则错误最简单的方式是字符串明确定义，其他都是不明确的。或者，简单来讲， 给所有字符串打引号。</p><p>通常，为了避免整数转换问题，将整型存储为字符串更好，并用 <code>&#123;&#123; int $value &#125;&#125;</code> 在模板中将字符串转回整型。</p><p>在大多数场景中，显式的类型标记更好，所以 <code>foo: !!string 1234</code> 会将1234作为字符串对待。 但是，YAML解析器会消耗标记，因此类型数据在一次解析后会丢失。</p><h3 id="考虑用户使用value"><span class="post-title-index">6.2.4. </span><a href="#考虑用户使用value" class="headerlink" title="考虑用户使用value"></a>考虑用户使用value</h3><p>有三种value来源:</p><ul><li>chart的values.yaml文件</li><li>由<code>helm install -f</code>提供的values文件</li><li>在执行<code>helm install</code> 时传递给–set 或 –set-string 参数的values</li></ul><p>当设计values的结构时，记得你的chart用户可能会通过-f 参数或–set选项覆盖他们。<br>由于–set在表现上更有限，编写你values.yaml文件的第一指导原则是确保它容易被–set覆盖。因此使用map构建values文件更好。</p><h3 id="给values-yaml写文档"><span class="post-title-index">6.2.5. </span><a href="#给values-yaml写文档" class="headerlink" title="给values.yaml写文档"></a>给values.yaml写文档</h3><p>values.yaml中每个定义的属性都应该文档化。文档字符串应该以它要描述的属性开头，并至少给出一句描述。</p><h2 id="模板-1"><span class="post-title-index">6.3. </span><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><h3 id="templates-结构"><span class="post-title-index">6.3.1. </span><a href="#templates-结构" class="headerlink" title="templates 结构"></a>templates 结构</h3><p><code>templates/</code>目录结构应该如下：</p><ul><li>如果生成YAML输出，模板文件应该有扩展名.yaml。 扩展名是.tpl可用于生成非格式化内容的模板文件。</li><li>模板文件名称应该使用横杠符号(my-example-configmap.yaml)，不用驼峰记法。</li><li>每个资源的定义应该在它自己的模板文件中。</li><li>模板文件的名称应该反映名称中的资源类型。比如：foo-pod.yaml， bar-svc.yaml</li></ul><h3 id="定义模板的名称"><span class="post-title-index">6.3.2. </span><a href="#定义模板的名称" class="headerlink" title="定义模板的名称"></a>定义模板的名称</h3><p>定义的模板(在<code>&#123;&#123; define &#125;&#125;</code>命令中定义的模板)是可全局访问的。这就意味着chart和所有的子chart都可以访问用<code>&#123;&#123; define &#125;&#125;</code>创建的所有模板。</p><p>因此， 所有定义的模板名称应该被命名空间化。</p><p>正确的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;nginx.fullname&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;/* ... */&#125;&#125;</span><br><span class="line">&#123;&#123; end -&#125;&#125;</span><br></pre></td></tr></table></figure><p>不正确的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;fullname&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;/* ... */&#125;&#125;</span><br><span class="line">&#123;&#123; end -&#125;&#125;</span><br></pre></td></tr></table></figure><p>强烈建议通过<code>helm create</code>命令创建新chart，因为模板名称是根据此最佳实践自动定义的。</p><h3 id="格式化模板"><span class="post-title-index">6.3.3. </span><a href="#格式化模板" class="headerlink" title="格式化模板"></a>格式化模板</h3><p>模板应该使用两个 空格 缩进（永远不要用tab）。<br>模板命令的大括号前后应该使用空格。<br>正确的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; .foo &#125;&#125;</span><br><span class="line">&#123;&#123; print &quot;foo&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- print &quot;bar&quot; -&#125;&#125;</span><br></pre></td></tr></table></figure><p>不正确的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;.foo&#125;&#125;</span><br><span class="line">&#123;&#123;print &quot;foo&quot;&#125;&#125;</span><br><span class="line">&#123;&#123;-print &quot;bar&quot;-&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="生成模板中的空格"><span class="post-title-index">6.3.4. </span><a href="#生成模板中的空格" class="headerlink" title="生成模板中的空格"></a>生成模板中的空格</h3><p>最好在生成的模板中将空格量保持在最小值。尤其是大量的空行不应该相邻出现。但偶尔有空行（尤其在逻辑块之间）是没问题的。</p><h3 id="注释"><span class="post-title-index">6.3.5. </span><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>YAML和Helm模板都有注释标记符。<br>YAML注释：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># This is a comment</span><br><span class="line">type: sprocket</span><br></pre></td></tr></table></figure><p>模板注释：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- /*</span><br><span class="line">This is a comment.</span><br><span class="line">*/&#125;&#125;</span><br><span class="line">type: frobnitz</span><br></pre></td></tr></table></figure><h3 id="在模板和模板输出中使用JSON"><span class="post-title-index">6.3.6. </span><a href="#在模板和模板输出中使用JSON" class="headerlink" title="在模板和模板输出中使用JSON"></a>在模板和模板输出中使用JSON</h3><p>YAML是JSON的超集。在某些情况下，使用JSON语法比其他YAML表示更具可读性。</p><p>比如，这个YAML更接近表示列表的普通YAML方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">arguments:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;--dirname&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;/foo&quot;</span></span><br></pre></td></tr></table></figure><p>但是折叠成JSON列表样式时会更易阅读:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">arguments:</span> [<span class="string">&quot;--dirname&quot;</span>, <span class="string">&quot;/foo&quot;</span>]</span><br></pre></td></tr></table></figure><p>使用JSON可以很好地提高易读性。然而，JSON语法不应用于表示更复杂的结构。</p><h2 id="标签和注释"><span class="post-title-index">6.4. </span><a href="#标签和注释" class="headerlink" title="标签和注释"></a>标签和注释</h2><p>建议使用 <code>helm.sh/chart: NAME-VERSION</code> 作为标签，以便操作员可以找到特定chart的所有实例。</p><p>如果元数据项不是用于查询，就应该设置为注释。</p><p>标准标签参考文档：<a href="https://helm.sh/zh/docs/chart_best_practices/labels/">标签和注释</a></p><h2 id="Pod和Pod模板"><span class="post-title-index">6.5. </span><a href="#Pod和Pod模板" class="headerlink" title="Pod和Pod模板"></a>Pod和Pod模板</h2><p>Pod指的是Pod，Pod模板指的是Deployment、ReplicationController、ReplicaSet、DaemonSet、StatefulSet等。</p><p>容器镜像应该使用固定的tag或镜像SHA。不应该使用latest, head, canary等标签或其他被设计为“浮动的”标签。</p><p>所有的Pod模板部分应该指定一个selector。比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyName</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyName</span></span><br></pre></td></tr></table></figure><h2 id="基于角色的访问控制"><span class="post-title-index">6.6. </span><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h2><p>RBAC 资源有：</p><ul><li>ServiceAccount (namespaced)</li><li>Role (namespaced)</li><li>ClusterRole</li><li>RoleBinding (namespaced)</li><li>ClusterRoleBinding</li></ul><p>RBAC和服务账户配置应该使用独立的key。它们是独立的内容。在YAML中将这两个概念分开可以消除歧义使其更加清晰。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rbac:</span></span><br><span class="line">  <span class="comment"># Specifies whether RBAC resources should be created</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">serviceAccount:</span></span><br><span class="line">  <span class="comment"># Specifies whether a ServiceAccount should be created</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># The name of the ServiceAccount to use.</span></span><br><span class="line">  <span class="comment"># If not set and create is true, a name is generated using the fullname template</span></span><br><span class="line">  <span class="attr">name:</span></span><br></pre></td></tr></table></figure><p>rbac.create 应该是布尔值，用于控制RBAC资源是否被创建。默认是 true。用户想自己管理RBAC访问控制时可以设置为false (示例如下)。</p><p>serviceAccount.name 要设置为由chart创建的访问控制资源的ServiceAccount的名称。 如果serviceAccount.create是true，则使用该名称的ServiceAccount会被创建。如果没有设置名称， 则会使用fullname模板生成一个名称。如果serviceAccount.create是false，则不会被创建，但仍然会与相同的资源关联， 以便后续手动创建的引用它的RBAC资源可以正常工作。如果serviceAccount.create是false且没有指定名称， 会使用默认的ServiceAccount。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;/*</span><br><span class="line">Create the name of the service account to use</span><br><span class="line">*/&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;mychart.serviceAccountName&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- if .Values.serviceAccount.create -&#125;&#125;</span><br><span class="line">    &#123;&#123; default (include &quot;mychart.fullname&quot; .) .Values.serviceAccount.name &#125;&#125;</span><br><span class="line">&#123;&#123;- else -&#125;&#125;</span><br><span class="line">    &#123;&#123; default &quot;default&quot; .Values.serviceAccount.name &#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="调试"><span class="post-title-index">7. </span><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="语法检查"><span class="post-title-index">7.1. </span><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm lint</span><br></pre></td></tr></table></figure><h2 id="测试本地渲染"><span class="post-title-index">7.2. </span><a href="#测试本地渲染" class="headerlink" title="测试本地渲染"></a>测试本地渲染</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm template --debug</span><br></pre></td></tr></table></figure><h2 id="测试服务器渲染"><span class="post-title-index">7.3. </span><a href="#测试服务器渲染" class="headerlink" title="测试服务器渲染"></a>测试服务器渲染</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --dry-run --debug</span><br></pre></td></tr></table></figure><h2 id="忽略检查测试服务器渲染"><span class="post-title-index">7.4. </span><a href="#忽略检查测试服务器渲染" class="headerlink" title="忽略检查测试服务器渲染"></a>忽略检查测试服务器渲染</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --dry-run --disable-openapi-validation</span><br></pre></td></tr></table></figure><h2 id="查看安装在服务上的模板"><span class="post-title-index">7.5. </span><a href="#查看安装在服务上的模板" class="headerlink" title="查看安装在服务上的模板"></a>查看安装在服务上的模板</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm get manifest</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Helm官方文档写的很棒，本文会摘录Helm官方文档中的一些基础知识和最佳实践，备忘。&lt;br&gt;更细致全面的内容，请移步阅读&lt;a href=&quot;https://helm.sh/zh/docs/&quot;&gt;Helm官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-helm-start/&quot;&gt;《Helm入门篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://helm.sh/zh/docs/chart_template_guide/getting_started/&quot;&gt;Helm - Getting Started&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="helm" scheme="https://www.voidking.com/tags/helm/"/>
    
  </entry>
  
  <entry>
    <title>搭建Spark on Yarn集群</title>
    <link href="https://www.voidking.com/dev-spark-on-yarn/"/>
    <id>https://www.voidking.com/dev-spark-on-yarn/</id>
    <published>2023-05-14T08:00:00.000Z</published>
    <updated>2023-05-14T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计划在三台Linux主机中搭建Spark on Yarn集群，Spark版本3.2.3，Hadoop版本3.2.3。</p><p>主机配置为4C8G，操作系统为CentOS7，hosts配置为：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168.56.101</span> spark-master</span><br><span class="line"><span class="number">192.168.56.102</span> spark-slave1</span><br><span class="line"><span class="number">192.168.56.103</span> spark-slave2</span><br></pre></td></tr></table></figure><p>选择101作为master节点，另外两个作为worker节点。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-install-hadoop-on-linux/">《Linux中安装配置Hadoop》</a></li><li><a href="https://www.voidking.com/dev-install-spark-on-linux/">《Linux中搭建Spark集群》</a></li><li><a href="https://blog.csdn.net/u011374856/article/details/119869602">Hadoop 3.2.2 安装与使用文档超详细图文步骤</a></li><li><a href="https://zhuanlan.zhihu.com/p/487572725">spark3.2+hadoop3.3.2三节点分布式部署初体验</a></li><li><a href="https://juejin.cn/post/7095277036868436004">搭建Spark on Yarn集群</a></li><li><a href="https://blog.csdn.net/m0_61022929/article/details/126403124">spark3.3.0安装&amp;部署过程</a></li></ul><span id="more"></span><h1 id="安装Java"><span class="post-title-index">2. </span><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h1><p>参考文档<a href="https://www.voidking.com/dev-install-jdk-on-all-platforms/">《全平台安装JDK》</a></p><h1 id="安装Hadoop"><span class="post-title-index">3. </span><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h1><h2 id="下载Hadoop安装包"><span class="post-title-index">3.1. </span><a href="#下载Hadoop安装包" class="headerlink" title="下载Hadoop安装包"></a>下载Hadoop安装包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://dlcdn.apache.org/hadoop/common/hadoop-3.2.3/hadoop-3.2.3.tar.gz --no-check-certificate</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/hadoop/</span><br><span class="line">tar -xzvf hadoop-3.2.3.tar.gz -C /usr/local/hadoop/</span><br></pre></td></tr></table></figure><h2 id="修改Hadoop配置"><span class="post-title-index">3.2. </span><a href="#修改Hadoop配置" class="headerlink" title="修改Hadoop配置"></a>修改Hadoop配置</h2><p>1、修改hadoop-env.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop/hadoop-3.2.3</span><br><span class="line">vim etc/hadoop/hadoop-env.sh</span><br></pre></td></tr></table></figure><p>修改JAVA_HOME为绝对路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/jdk1.8.0_161</span><br></pre></td></tr></table></figure><p>2、验证环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hadoop version</span><br></pre></td></tr></table></figure><h2 id="单机测试运行"><span class="post-title-index">3.3. </span><a href="#单机测试运行" class="headerlink" title="单机测试运行"></a>单机测试运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ./input</span><br><span class="line"><span class="built_in">cp</span> ./etc/hadoop/*.xml ./input</span><br><span class="line">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output <span class="string">&#x27;dfs[a-z.]+&#x27;</span></span><br><span class="line"><span class="built_in">cat</span> ./output/*</span><br></pre></td></tr></table></figure><p>看到结果<code>1  dfsadmin</code>表明运行成功。</p><h2 id="master节点配置HDFS"><span class="post-title-index">3.4. </span><a href="#master节点配置HDFS" class="headerlink" title="master节点配置HDFS"></a>master节点配置HDFS</h2><p>1、修改etc/hadoop/core-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定hdfs中nomenode的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://spark-master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/hadoop-3.2.3/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置参考文档：<a href="https://hadoop.apache.org/docs/r3.2.3/hadoop-project-dist/hadoop-common/core-default.xml">hadoop3.2.3 core-default.xml</a></p><p>2、修改etc/hadoop/hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置dfs副本数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hdfs的web管理页面的端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.http.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.0.0.0:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置secondnamenode的端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-master:9001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- namenode目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/hadoop-3.2.3/data/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- datanode目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/hadoop-3.2.3/data/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置参考文档：<a href="https://hadoop.apache.org/docs/r3.2.3/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml">hadoop3.2.3 hdfs-default.xml</a></p><p>3、修改etc/hadoop/workers</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark-master</span><br><span class="line">spark-slave1</span><br><span class="line">spark-slave2</span><br></pre></td></tr></table></figure><h2 id="master节点配置配置Yarn"><span class="post-title-index">3.5. </span><a href="#master节点配置配置Yarn" class="headerlink" title="master节点配置配置Yarn"></a>master节点配置配置Yarn</h2><p>1、编辑 etc/hadoop/mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定mr运行在yarn上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、编辑 etc/hadoop/yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- reducer 获取数据的方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定 YARN 的 ResourceManager 的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 该节点上YARN可使用的物理内存总量，默认是 8192（MB）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意，如果你的节点内存资源不够8GB，则需要调减小这个值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 单个任务可申请最少内存，默认 1024 MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.minimum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 单个任务可申请最大内存，默认 8192 MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.maximum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><span class="post-title-index">3.6. </span><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/local/hadoop/hadoop-3.2.3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="拷贝配置到slave节点"><span class="post-title-index">3.7. </span><a href="#拷贝配置到slave节点" class="headerlink" title="拷贝配置到slave节点"></a>拷贝配置到slave节点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rsync -P -avz /usr/local/hadoop 192.168.56.102:/usr/local/</span><br><span class="line">rsync -P -avz /usr/local/hadoop 192.168.56.103:/usr/local/</span><br><span class="line">rsync -P -avz /etc/profile 192.168.56.102:/etc/profile</span><br><span class="line">rsync -P -avz /etc/profile 192.168.56.103:/etc/profile</span><br></pre></td></tr></table></figure><h2 id="master节点启动HDFS"><span class="post-title-index">3.8. </span><a href="#master节点启动HDFS" class="headerlink" title="master节点启动HDFS"></a>master节点启动HDFS</h2><p>1、格式化namenode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>执行完成，没有报错，当前目录中出现了tmp目录，表明格式化成功。slave节点不会出现tmp目录。</p><p>2、添加HDFS用户环境变量<br>/etc/profile中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HDFS_DATANODE_USER=root</span><br><span class="line"><span class="built_in">export</span> HDFS_DATANODE_SECURE_USER=hdfs</span><br><span class="line"><span class="built_in">export</span> HDFS_NAMENODE_USER=root</span><br><span class="line"><span class="built_in">export</span> HDFS_SECONDARYNAMENODE_USER=root</span><br></pre></td></tr></table></figure><p>或者sbin/start-dfs.sh 和 sbin/stop-dfs.sh，文件顶部添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HDFS_DATANODE_USER=root</span><br><span class="line">HDFS_DATANODE_SECURE_USER=hdfs</span><br><span class="line">HDFS_NAMENODE_USER=root</span><br><span class="line">HDFS_SECONDARYNAMENODE_USER=root</span><br></pre></td></tr></table></figure><p>否则执行可能报错：<br>Starting namenodes on [spark-master]<br>ERROR: Attempting to operate on hdfs namenode as root<br>ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation.<br>Starting datanodes<br>ERROR: Attempting to operate on hdfs datanode as root<br>ERROR: but there is no HDFS_DATANODE_USER defined. Aborting operation.<br>Starting secondary namenodes [spark-master]<br>ERROR: Attempting to operate on hdfs secondarynamenode as root<br>ERROR: but there is no HDFS_SECONDARYNAMENODE_USER defined. Aborting operation.</p><p>3、启动hdfs服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p>这条命令会在master和slave节点同时启动hdfs，会提示输入密码，最好提前配置好免密登录。</p><p>4、查看hdfs进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p>master节点可以看到：</p><ul><li>org.apache.hadoop.hdfs.server.namenode.NameNode</li><li>org.apache.hadoop.hdfs.server.datanode.DataNode</li><li>org.apache.hadoop.hdfs.server.namenode.SecondaryNameNode</li></ul><p>slave节点可以看到：</p><ul><li>org.apache.hadoop.hdfs.server.datanode.DataNode</li></ul><p>5、浏览器访问<br>浏览器访问 <a href="http://192.168.56.101:50070/">http://192.168.56.101:50070</a><br>可以看到 NameNode 和 Datanode 的信息。</p><h2 id="master节点启动Yarn"><span class="post-title-index">3.9. </span><a href="#master节点启动Yarn" class="headerlink" title="master节点启动Yarn"></a>master节点启动Yarn</h2><p>1、修改 sbin/start-yarn.sh 和 sbin/stop-yarn.sh，文件顶部添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YARN_RESOURCEMANAGER_USER=root</span><br><span class="line">HADOOP_SECURE_DN_USER=yarn</span><br><span class="line">YARN_NODEMANAGER_USER=root</span><br></pre></td></tr></table></figure><p>2、启动yarn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><p>3、查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p>master可以看到：</p><ul><li>org.apache.hadoop.yarn.server.nodemanager.NodeManager</li><li>org.apache.hadoop.yarn.server.resourcemanager.ResourceManager</li></ul><p>slave节点可以看到：</p><ul><li>org.apache.hadoop.yarn.server.nodemanager.NodeManager</li></ul><p>4、浏览器访问<br>浏览器访问 <a href="http://192.168.56.101:8088/">http://192.168.56.101:8088</a><br>可以看到 Yarn ResourceManager的信息。</p><h1 id="安装Spark"><span class="post-title-index">4. </span><a href="#安装Spark" class="headerlink" title="安装Spark"></a>安装Spark</h1><h2 id="master节点配置"><span class="post-title-index">4.1. </span><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h2><p>1、下载spark并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/spark/spark-3.2.3/spark-3.2.3-bin-hadoop3.2-scala2.13.tgz</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/spark</span><br><span class="line">tar -xzvf spark-3.2.3-bin-hadoop3.2-scala2.13.tgz -C /usr/local/spark</span><br></pre></td></tr></table></figure><p>更多版本的spark，可以在<a href="https://archive.apache.org/dist/spark/">Spark release archives</a>页面找到。</p><p>2、创建配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/spark-3.2.3-bin-hadoop3.2-scala2.13/conf</span><br><span class="line"><span class="built_in">cp</span> workers.template workers</span><br><span class="line"><span class="built_in">cp</span> spark-defaults.conf.template spark-defaults.conf</span><br><span class="line"><span class="built_in">cp</span> spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure><p>3、修改配置<br>（1）workers中删除localhost，添加</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark-master</span><br><span class="line">spark-slave1</span><br><span class="line">spark-slave2</span><br></pre></td></tr></table></figure><p>（2）spark-defaults.conf暂时不变</p><p>（3）spark-env.sh中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/jdk1.8.0_161</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_HOST=spark-master</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_PORT=7077</span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/local/spark/spark-3.2.3-bin-hadoop3.2-scala2.13</span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/local/hadoop/hadoop-3.2.3</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/usr/local/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line"><span class="built_in">export</span> YARN_CONF_DIR=/usr/local/hadoop/hadoop-3.2.3/etc/hadoop/</span><br></pre></td></tr></table></figure><p>4、/etc/profile中添加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/local/spark/spark-3.2.3-bin-hadoop3.2-scala2.13</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$SPARK_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>5、使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="master配置同步到worker"><span class="post-title-index">4.2. </span><a href="#master配置同步到worker" class="headerlink" title="master配置同步到worker"></a>master配置同步到worker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rsync -P -avz /usr/local/spark 192.168.56.102:/usr/local/</span><br><span class="line">rsync -P -avz /usr/local/spark 192.168.56.103:/usr/local/</span><br><span class="line">rsync -P -avz /etc/profile 192.168.56.102:/etc/profile</span><br><span class="line">rsync -P -avz /etc/profile 192.168.56.103:/etc/profile</span><br></pre></td></tr></table></figure><h2 id="运行Spark"><span class="post-title-index">4.3. </span><a href="#运行Spark" class="headerlink" title="运行Spark"></a>运行Spark</h2><p>1、启动spark（在master节点上执行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/spark-3.2.3-bin-hadoop3.2-scala2.13/sbin</span><br><span class="line">./start-all.sh</span><br></pre></td></tr></table></figure><p>根据提示，依次输入两台worker节点的密码。（这里最好配置上免密登录）<br>这样，三个节点上的spark就都可以启动起来。</p><p>2、验证安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p>master节点看到Master和Worker进程，worker节点看到Worker进程。</p><p>3、浏览器访问<br>浏览器访问 <a href="http://192.168.56.101:8080/">http://192.168.56.101:8080</a><br>可以看到spark master信息。<br>浏览器访问 <a href="http://192.168.56.102:8081/">http://192.168.56.102:8081</a><br>可以看到spark slave节点信息。</p><h1 id="测试使用Spark-on-Yarn"><span class="post-title-index">5. </span><a href="#测试使用Spark-on-Yarn" class="headerlink" title="测试使用Spark on Yarn"></a>测试使用Spark on Yarn</h1><p>1、spark-submit提交任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit \</span><br><span class="line">  --class org.apache.spark.examples.SparkPi \</span><br><span class="line">  --master yarn \</span><br><span class="line">  ./examples/jars/spark-examples_2.13-3.2.3.jar 1000</span><br></pre></td></tr></table></figure><p>3、浏览器查看进度<br>浏览器访问 <a href="http://192.168.50.105:8088/">http://192.168.50.105:8088</a><br>在Yarn ResourceManager页面，可以查看到任务详情。</p><h1 id="vcore数量不对问题"><span class="post-title-index">6. </span><a href="#vcore数量不对问题" class="headerlink" title="vcore数量不对问题"></a>vcore数量不对问题</h1><h2 id="问题描述"><span class="post-title-index">6.1. </span><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>理论上：<code>vcores使用数 = executor-cores * num-executors + 1</code><br>但是实际提交任务后，配置的executor-cores并没有起作用。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit --class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--driver-memory 2g \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--num-executors 4 \</span><br><span class="line">--executor-cores 2 \</span><br><span class="line">./examples/jars/spark-examples_2.13-3.2.3.jar 10</span><br></pre></td></tr></table></figure><p>上面的提交，理论上应该使用<code>2 * 4 + 1 = 9</code>核，实际上从Yarn ResourceManager页面查看Allocated CPU VCores，只分配了5核。<br>也就是说executor-cores没有生效，使用了默认值1。</p><h2 id="解决办法"><span class="post-title-index">6.2. </span><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>1、编辑 capacity-scheduler.xml </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop/hadoop-3.2.3</span><br><span class="line">vim etc/hadoop/capacity-scheduler.xml</span><br></pre></td></tr></table></figure><p>如下修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.resource-calculator<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;value&gt;org.apache.hadoop.yarn.util.resource.DefaultResourceCalculator&lt;/value&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.util.resource.DominantResourceCalculator<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">    The ResourceCalculator implementation to be used to compare</span><br><span class="line">    Resources in the scheduler.</span><br><span class="line">    The default i.e. DefaultResourceCalculator only uses Memory while</span><br><span class="line">    DominantResourceCalculator uses dominant-resource to compare</span><br><span class="line">    multi-dimensional resources such as Memory, CPU etc.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、同步到slave节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -P -avz /usr/local/hadoop/hadoop-3.2.3/etc/hadoop/ 192.168.56.102:/usr/local/hadoop/hadoop-3.2.3/etc/hadoop</span><br><span class="line">rsync -P -avz /usr/local/hadoop/hadoop-3.2.3/etc/hadoop/ 192.168.56.103:/usr/local/hadoop/hadoop-3.2.3/etc/hadoop</span><br></pre></td></tr></table></figure><p>3、重启yarn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./sbin/stop-yarn.sh</span><br><span class="line">./sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://www.cnblogs.com/yesecangqiong/p/10125333.html">spark on yarn提交后vcore数不对</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;计划在三台Linux主机中搭建Spark on Yarn集群，Spark版本3.2.3，Hadoop版本3.2.3。&lt;/p&gt;
&lt;p&gt;主机配置为4C8G，操作系统为CentOS7，hosts配置为：&lt;/p&gt;
&lt;figure class=&quot;highlight accesslog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;192.168.56.101&lt;/span&gt; spark-master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;192.168.56.102&lt;/span&gt; spark-slave1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;192.168.56.103&lt;/span&gt; spark-slave2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;选择101作为master节点，另外两个作为worker节点。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-install-hadoop-on-linux/&quot;&gt;《Linux中安装配置Hadoop》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-install-spark-on-linux/&quot;&gt;《Linux中搭建Spark集群》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u011374856/article/details/119869602&quot;&gt;Hadoop 3.2.2 安装与使用文档超详细图文步骤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/487572725&quot;&gt;spark3.2+hadoop3.3.2三节点分布式部署初体验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7095277036868436004&quot;&gt;搭建Spark on Yarn集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/m0_61022929/article/details/126403124&quot;&gt;spark3.3.0安装&amp;amp;部署过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="java" scheme="https://www.voidking.com/categories/engineering/java/"/>
    
    <category term="bigdata" scheme="https://www.voidking.com/categories/engineering/bigdata/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="java" scheme="https://www.voidking.com/tags/java/"/>
    
    <category term="spark" scheme="https://www.voidking.com/tags/spark/"/>
    
    <category term="hadoop" scheme="https://www.voidking.com/tags/hadoop/"/>
    
  </entry>
  
</feed>
