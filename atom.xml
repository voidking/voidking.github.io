<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>VoidKing</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.voidking.com/"/>
  <updated>2020-02-09T02:22:14.051Z</updated>
  <id>https://www.voidking.com/</id>
  
  <author>
    <name>VoidKing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo配置Travis CI自动发布</title>
    <link href="https://www.voidking.com/dev-hexo-travis-ci/"/>
    <id>https://www.voidking.com/dev-hexo-travis-ci/</id>
    <published>2020-02-02T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CI-CD-and-CD"><a href="#CI-CD-and-CD" class="headerlink" title="CI, CD and CD"></a>CI, CD and CD</h1><p>CI，CONTINUOUS INTEGRATION，持续集成。<br>在持续集成环境中，开发人员将会频繁的提交代码到主干。这些新提交在最终合并到主线之前，都需要通过编译和自动化测试流进行验证。</p><p>CD，CONTINUOUS DELIVERY，持续交付。<br>持续交付就是应用发布出去的过程。这个过程可以确保我们尽可能快的实现交付。这就意味着除了自动化测试，我们还需要有自动化的发布流，以及通过一个按键就可以随时随地实现应用的部署上线。为了发挥持续交付的优势，一般需要先进行小批量发布，尽快部署到生产线，以便在出现问题时方便进行故障排除。</p><p>CD，CONTINUOUS DEPLOYMENT，持续部署。<br>持续部署是持续集成和持续交付的合并。当开发人员在主分支中合并一个提交时，会触发工作流，包括构建、单元测试、预发布、验收测试、生产发布、冒烟测试等。如果一切顺利，则成功部署到生产环境中。如果某个工作流失败，则不会部署到生产环境。</p><p>更多关于CI/CD内容参考<a href="http://www.ttlsa.com/news/ci-cd-cd/" target="_blank" rel="noopener">详解CI、CD &amp; CD</a>和<a href="https://linux.cn/article-9926-1.html" target="_blank" rel="noopener">什么是 CI/CD？</a>，关于发布环境的划分参考<a href="https://en.wikipedia.org/wiki/Deployment_environment" target="_blank" rel="noopener">Deployment environment</a>。</p><p>在gitlab中，无论是CI、CD还是CD，都可以通过配置gitlab-ci.yml来实现。而github，在2019年8月8日也支持内置的CI/CD了。但是本文中，并不是使用github内置的CI/CD，而是使用Travis CI来实现hexo的自动发布。</p><p><a href="https://www.voidking.com/hexo-multi-git/">《Hexo配置多个git仓库》</a>一文中已经学习了hexo配置多个git仓库的方法，发布项目也很简单。为什么还需要hexo的自动发布？因为发布流程还可以更简单。而且，现在的发布方式，如果想要多台电脑同时使用，那么每台电脑都需要配置hexo环境，很麻烦。如果本地只负责写写markdown文件，而构建发布都放到云端，是不是更加美好？本文要做的，就是这样一件事。</p><a id="more"></a><h1 id="安装配置本地hexo"><a href="#安装配置本地hexo" class="headerlink" title="安装配置本地hexo"></a>安装配置本地hexo</h1><p>参考<a href="https://www.voidking.com/dev-hexo-build-environment-2018-05/">《Hexo环境搭建2018年5月版》</a>，安装v10.16.3版本的node，创建hexo项目，然后把需要的依赖写入package.json：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm <span class="keyword">install</span> hexo-generator-feed <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-sitemap <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-baidu-sitemap <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-deployer-git <span class="comment">--save</span></span><br><span class="line">npm <span class="keyword">install</span> hexo-generator-searchdb <span class="comment">--save</span></span><br></pre></td></tr></table></figure><p>接下来改造hexo配置，用于Travis CI发布。</p><p>1、创建hexo-deploy项目<br>在github创建public项目hexo-deploy，git clone到本地，然后把hexo项目里的内容剪切到hexo-deploy目录。</p><p>2、配置config.yml<br>编辑config.yml，根据自己的需要进行配置。</p><p>3、清理文件<br>hexo-deploy目录里只需要保留：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.git</span></span><br><span class="line"><span class="selector-class">.gitignore</span></span><br><span class="line"><span class="selector-tag">package</span><span class="selector-class">.json</span></span><br><span class="line">_<span class="selector-tag">config</span><span class="selector-class">.yml</span></span><br><span class="line"><span class="selector-tag">README</span><span class="selector-class">.md</span></span><br></pre></td></tr></table></figure><h1 id="配置travis-yml"><a href="#配置travis-yml" class="headerlink" title="配置travis.yml"></a>配置travis.yml</h1><p>主要参考<a href="https://www.jianshu.com/p/5691815b81b6" target="_blank" rel="noopener">使用Travis CI持续部署Hexo博客</a>和<a href="https://hexo.io/zh-tw/docs/github-pages" target="_blank" rel="noopener">將 Hexo 部署到 GitHub Pages</a>。<br>已知 voidking.github.io 和 voidking 是hexo发布后的git仓库（public），hexo-backup是存储markdown文件的git仓库（private）。</p><p>1、安装Travis CI插件<br>在github添加<a href="https://github.com/marketplace/travis-ci" target="_blank" rel="noopener">Travis CI插件</a>，并且在<a href="https://github.com/settings/installations" target="_blank" rel="noopener">Applications settings</a>配置Travis CI的权限。</p><p>2、生成access token<br>访问github的<a href="https://github.com/settings/tokens" target="_blank" rel="noopener">Personal access tokens</a>页面，Generate new token。Note输入travis，Select scope选择repo，然后点击Generate token。生成了一个token，保存它。<br><img src="http://cdn.voidking.com/@/imgs/hexo-travis-ci/newtoken.jpg?imageView2/0/w/700" alt=""></p><p>3、添加access token<br>访问<a href="https://travis-ci.com/" target="_blank" rel="noopener">Travis CI Pro</a>，找到hexo-deploy项目，Settings，在Environment Variables一栏填入Name为<code>GITHUB_TOKEN</code>，VALUE为github的access token。<br><img src="http://cdn.voidking.com/@/imgs/hexo-travis-ci/env.jpg?imageView2/0/w/700" alt=""></p><p>3、在hexo-deploy目录下添加<code>.travis.yml</code>文件，内容为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">sudo: false</span><br><span class="line"><span class="keyword">language</span>: node_js</span><br><span class="line">node_j<span class="variable">s:</span></span><br><span class="line">  - <span class="number">10.16</span>.<span class="number">3</span></span><br><span class="line">cache: npm</span><br><span class="line">branche<span class="variable">s:</span></span><br><span class="line">  <span class="keyword">only</span>:</span><br><span class="line">    - master # build master branch <span class="keyword">only</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">en</span><span class="variable">v:</span></span><br><span class="line"> globa<span class="variable">l:</span></span><br><span class="line">   - HEXO_BACKUP_REPO: github.<span class="keyword">com</span>/voidking/hexo-backup.git</span><br><span class="line">   - HEXO_THEME_REPO: github.<span class="keyword">com</span>/voidking/hexo-theme-<span class="keyword">next</span>.git</span><br><span class="line">   - GITHUB_PAGES_REPO: github.<span class="keyword">com</span>/voidking/voidking.github.io.git</span><br><span class="line">   - VOIDKING_REPO: github.<span class="keyword">com</span>/voidking/voidking.git</span><br><span class="line"></span><br><span class="line">before_instal<span class="variable">l:</span></span><br><span class="line">  - npm install hexo -g</span><br><span class="line"></span><br><span class="line">instal<span class="variable">l:</span></span><br><span class="line">  - npm install</span><br><span class="line"></span><br><span class="line"><span class="keyword">scrip</span><span class="variable">t:</span></span><br><span class="line">  - git clone http<span class="variable">s:</span>//$&#123;HEXO_THEME_REPO&#125; themes/<span class="keyword">next</span></span><br><span class="line">  - git clone http<span class="variable">s:</span>//$&#123;GITHUB_TOKEN&#125;@$&#123;HEXO_BACKUP_REPO&#125; hexo-backup</span><br><span class="line">  - mv hexo-backup/<span class="keyword">source</span> .</span><br><span class="line">  - rm -rf <span class="keyword">source</span>/private</span><br><span class="line">  - hexo g</span><br><span class="line"></span><br><span class="line">after_succes<span class="variable">s:</span></span><br><span class="line">  - git config --<span class="keyword">global</span> user.name <span class="string">"voidking"</span></span><br><span class="line">  - git config --<span class="keyword">global</span> user.email <span class="string">"voidking@qq.com"</span></span><br><span class="line">  - <span class="keyword">cd</span> ./public</span><br><span class="line">  - git init</span><br><span class="line">  - git <span class="built_in">add</span> .</span><br><span class="line">  - git commit -<span class="keyword">m</span> <span class="string">"Travis CI Auto Builder"</span></span><br><span class="line">  - git push --force --quiet <span class="string">"https://$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_PAGES_REPO&#125;"</span> master</span><br><span class="line">  - git push --force --quiet <span class="string">"https://$&#123;GITHUB_TOKEN&#125;@$&#123;VOIDKING_REPO&#125;"</span> master</span><br></pre></td></tr></table></figure><h1 id="hexo发布"><a href="#hexo发布" class="headerlink" title="hexo发布"></a>hexo发布</h1><p>在hexo-deploy项目中，修改README.md（建议添加日期信息），然后提交代码，触发发布。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span> .</span><br><span class="line">git commit -m <span class="string">"20200202deploy"</span></span><br><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure><p>然后打开<a href="https://travis-ci.com/voidking/hexo-deploy" target="_blank" rel="noopener">Travis CI - hexo-deploy</a>，即可看到构建发布的日志。<br><img src="http://cdn.voidking.com/@/imgs/hexo-travis-ci/log.jpg?imageView2/0/w/800" alt=""><br>如果构建发布出错，根据提示修改发布脚本或者markdown文件即可。</p><p>至此，Hexo配置Travis CI自动发布完成！</p><h1 id="域名404问题"><a href="#域名404问题" class="headerlink" title="域名404问题"></a>域名404问题</h1><p>发布完成，出现了一个神奇的问题，<a href="http://www.voidking.com">www.voidking.com</a> 域名404。<br>查看github pages配置，发现自定义域名变回了 voidking.github.io 。<br><img src="http://cdn.voidking.com/@/imgs/hexo-travis-ci/pages.jpg?imageView2/0/w/700" alt=""><br>神奇了！莫非，是因为force push刷掉了git仓库的commit？那就保留commit试试。<br>修改.travis.yml的aftersuccess部分：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">after_success:</span><br><span class="line">  -<span class="ruby"> git config --global user.name <span class="string">"voidking"</span></span></span><br><span class="line"><span class="ruby">  - git config --global user.email <span class="string">"voidking@qq.com"</span></span></span><br><span class="line"><span class="ruby">  - git clone <span class="symbol">https:</span>/<span class="regexp">/$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_PAGES_REPO&#125; voidking</span></span></span><br><span class="line"><span class="ruby">  - unalias cp &amp;&amp; cp -rf public/* voidking</span></span><br><span class="line"><span class="ruby">  - cd voidking</span></span><br><span class="line"><span class="ruby">  - git add .</span></span><br><span class="line"><span class="ruby">  - git commit -m <span class="string">"Travis CI Auto Builder"</span></span></span><br><span class="line"><span class="ruby">  - git push --force --quiet <span class="string">"https://$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_PAGES_REPO&#125;"</span> master</span></span><br><span class="line"><span class="ruby">  - cd ../public</span></span><br><span class="line"><span class="ruby">  - git init</span></span><br><span class="line"><span class="ruby">  - git add .</span></span><br><span class="line"><span class="ruby">  - git commit -m <span class="string">"Travis CI Auto Builder"</span></span></span><br><span class="line"><span class="ruby">  - git push --force --quiet <span class="string">"https://$&#123;GITHUB_TOKEN&#125;@$&#123;VOIDKING_REPO&#125;"</span> master</span></span><br></pre></td></tr></table></figure><p>保留commit之后，自定义域名果然不会再变化，nice。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CI-CD-and-CD&quot;&gt;&lt;a href=&quot;#CI-CD-and-CD&quot; class=&quot;headerlink&quot; title=&quot;CI, CD and CD&quot;&gt;&lt;/a&gt;CI, CD and CD&lt;/h1&gt;&lt;p&gt;CI，CONTINUOUS INTEGRATION，持续集成。&lt;br&gt;在持续集成环境中，开发人员将会频繁的提交代码到主干。这些新提交在最终合并到主线之前，都需要通过编译和自动化测试流进行验证。&lt;/p&gt;
&lt;p&gt;CD，CONTINUOUS DELIVERY，持续交付。&lt;br&gt;持续交付就是应用发布出去的过程。这个过程可以确保我们尽可能快的实现交付。这就意味着除了自动化测试，我们还需要有自动化的发布流，以及通过一个按键就可以随时随地实现应用的部署上线。为了发挥持续交付的优势，一般需要先进行小批量发布，尽快部署到生产线，以便在出现问题时方便进行故障排除。&lt;/p&gt;
&lt;p&gt;CD，CONTINUOUS DEPLOYMENT，持续部署。&lt;br&gt;持续部署是持续集成和持续交付的合并。当开发人员在主分支中合并一个提交时，会触发工作流，包括构建、单元测试、预发布、验收测试、生产发布、冒烟测试等。如果一切顺利，则成功部署到生产环境中。如果某个工作流失败，则不会部署到生产环境。&lt;/p&gt;
&lt;p&gt;更多关于CI/CD内容参考&lt;a href=&quot;http://www.ttlsa.com/news/ci-cd-cd/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;详解CI、CD &amp;amp; CD&lt;/a&gt;和&lt;a href=&quot;https://linux.cn/article-9926-1.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;什么是 CI/CD？&lt;/a&gt;，关于发布环境的划分参考&lt;a href=&quot;https://en.wikipedia.org/wiki/Deployment_environment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Deployment environment&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在gitlab中，无论是CI、CD还是CD，都可以通过配置gitlab-ci.yml来实现。而github，在2019年8月8日也支持内置的CI/CD了。但是本文中，并不是使用github内置的CI/CD，而是使用Travis CI来实现hexo的自动发布。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/hexo-multi-git/&quot;&gt;《Hexo配置多个git仓库》&lt;/a&gt;一文中已经学习了hexo配置多个git仓库的方法，发布项目也很简单。为什么还需要hexo的自动发布？因为发布流程还可以更简单。而且，现在的发布方式，如果想要多台电脑同时使用，那么每台电脑都需要配置hexo环境，很麻烦。如果本地只负责写写markdown文件，而构建发布都放到云端，是不是更加美好？本文要做的，就是这样一件事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="前端" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="hexo" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%89%8D%E7%AB%AF/hexo/"/>
    
      <category term="基础" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="hexo" scheme="https://www.voidking.com/tags/hexo/"/>
    
      <category term="ci" scheme="https://www.voidking.com/tags/ci/"/>
    
      <category term="cd" scheme="https://www.voidking.com/tags/cd/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置多个git仓库</title>
    <link href="https://www.voidking.com/dev-hexo-multi-git/"/>
    <id>https://www.voidking.com/dev-hexo-multi-git/</id>
    <published>2020-02-01T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h1><p>在经历过域名被封之后，今天又经历了搬瓦工服务器IP被封，我太难了。。。o(╥﹏╥)o<br>服务器IP被封，带来了三个问题：第一个是不能愉快地科学上网了；第二个是内网穿透不能使用了；第三个是自己的 <a href="http://www.voidking.com">www.voidking.com</a> 域名无法访问了。</p><p>对于问题一，暂时使用免费的公共飞机场。对于问题二，暂时使用百度服务器，但是因为没有备案，所以不能进行域名解析。对于问题三，就是本文要解决的问题之一。</p><a id="more"></a><h1 id="回到github"><a href="#回到github" class="headerlink" title="回到github"></a>回到github</h1><p>那么，因为服务器IP被封，域名无法访问怎么办？</p><p>方法一：再购买一个新的搬瓦工IP，或者再购买一个新的国外服务器。但是因为不想再花钱（就是这么抠），所以这个方法被否定了。<br>方法二：使用免费的git pages服务，比如github pages、gitlab pages、gitee pages等，并且把域名解析到git pages服务器。这里我选择最开始搭建hexo就使用的github pages，它支持免费的自定义域名和https。</p><p>参考<a href="https://www.voidking.com/dev-hexo-build-environment/">《Hexo环境搭建》</a>和<a href="https://www.voidking.com/dev-hexo-build-environment-2018-05/">《Hexo环境搭建2018年5月版》</a>，配置好github pages服务，并且配置域名的CNAME解析到 voidking.github.io ，开启强制https（github会自动申请ssl证书，点个赞）。</p><h1 id="百度收录问题"><a href="#百度收录问题" class="headerlink" title="百度收录问题"></a>百度收录问题</h1><p>除了访问速度慢一点之外，现在我的域名已经正常了，nice。但是，另外的问题出现了：百度搜索不到我的域名了！</p><p>使用<a href="https://ziyuan.baidu.com/crawltools/index?site=http://www.voidking.com/" target="_blank" rel="noopener">百度抓取诊断工具</a>诊断，发现抓取异常信息是拒绝访问，403 Forbidden。这是因为github屏蔽了百度蜘蛛，所以百度无法收录解析到github的域名。</p><p>浏览了一些文章，找到了解决办法：在DNSPod配置两个www的域名解析，线路类型“默认”解析到 voidking.github.io ，线路类型“百度”解析到一个百度可以抓取的地址，如下图。<br><img src="http://cdn.voidking.com/@/imgs/hexo-multi-git/type.jpg?imageView2/0/w/600" alt=""><br>也就是说，需要维护两个站点，两个站点分别处理来自不同线路的流量。其中一个站点建立在github，另外一个站点建立在哪儿呢？这里我选择<a href="https://zeit.co/" target="_blank" rel="noopener">ZEIT Now</a>。</p><p>理想是美好的，现实是残酷的！因为无论是github还是zeit，都需要验证域名解析，而它们都是境外服务器，所以都需要线路类型“境外”的CNAME解析，否则无法通过验证！尴尬了。。。只能选择其一。</p><p>为了百度的收录，看起来只能选择zeit了，不过zeit每个月只有20G的流量。为了在zeit流量用光后方便地切到github，因此还是需要维护两个站点。</p><h1 id="hexo配置多个git仓库"><a href="#hexo配置多个git仓库" class="headerlink" title="hexo配置多个git仓库"></a>hexo配置多个git仓库</h1><p>为了维护两个站点，所以每次更新，需要发布github pages和zeit。github pages的发布很方便，上传代码后直接就发布了；而zeit的发布有多种方式，其中一种方式是通过<a href="https://zeit.co/voidking/voidking/settings" target="_blank" rel="noopener">Deploy Hooks</a>触发。</p><p>如果github和zeit都使用 voidking.github.io 这一个git仓库，那么问题很简单。<code>hexo d</code>后，再访问一个url触发 Deploy Hooks就可以了。而zeit，不支持 voidking.github.io 这种项目名称，因此稍微麻烦一点。</p><p>1、新建git仓库<br>在github上再创建一个git仓库叫做voidking，import voidking.github.io仓库。</p><p>2、配置zeit关联<br>把voidking这个仓库和zeit做关联，并且发布项目，配置生成一个Deploy Hooks。</p><p>3、配置域名<br>按照提示绑定 <a href="http://www.voidking.com">www.voidking.com</a> 这个域名到zeit站点。</p><p>4、修改config.yml文件<br>修改hexo的config.yml文件中的deploy部分为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># github</span></span><br><span class="line"><span class="symbol">deploy:</span></span><br><span class="line">- type: git</span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//voidking.com/voidking/voidking.github.io.git</span></span><br><span class="line"><span class="symbol">  branch:</span> master</span><br><span class="line">- type: git</span><br><span class="line"><span class="symbol">  repo:</span> https:<span class="comment">//voidking.com/voidking/voidking.git</span></span><br><span class="line"><span class="symbol">  branch:</span> master</span><br></pre></td></tr></table></figure><p>以上配置参考<a href="https://hexo.io/docs/one-command-deployment" target="_blank" rel="noopener">Hexo一键发布</a>。</p><p>5、发布项目<br>正常执行<code>hexo d</code>，静态资源代码会上传到两个git仓库中。<br>其中，voidking.github.io这个仓库就直接发布了。而voidking这个仓库想要发布到zeit上，还需要手动触发一下（访问Deploy Hooks的url）。</p><p>至此，hexo多个git仓库，多个站点配置完成。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>如果zeit上的流量用完了，可以在DNSPod上修改域名解析到github。虽然有延迟，但是对于个人使用来说足够了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h1&gt;&lt;p&gt;在经历过域名被封之后，今天又经历了搬瓦工服务器IP被封，我太难了。。。o(╥﹏╥)o&lt;br&gt;服务器IP被封，带来了三个问题：第一个是不能愉快地科学上网了；第二个是内网穿透不能使用了；第三个是自己的 &lt;a href=&quot;http://www.voidking.com&quot;&gt;www.voidking.com&lt;/a&gt; 域名无法访问了。&lt;/p&gt;
&lt;p&gt;对于问题一，暂时使用免费的公共飞机场。对于问题二，暂时使用百度服务器，但是因为没有备案，所以不能进行域名解析。对于问题三，就是本文要解决的问题之一。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="前端" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="hexo" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%89%8D%E7%AB%AF/hexo/"/>
    
    
      <category term="hexo" scheme="https://www.voidking.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>m3u8视频下载方法</title>
    <link href="https://www.voidking.com/love-m3u8-download/"/>
    <id>https://www.voidking.com/love-m3u8-download/</id>
    <published>2020-01-31T19:10:00.000Z</published>
    <updated>2020-02-09T02:22:14.075Z</updated>
    
    <content type="html"><![CDATA[<h1 id="m3u8格式"><a href="#m3u8格式" class="headerlink" title="m3u8格式"></a>m3u8格式</h1><p>M3U是一种播放多媒体列表的文件格式，它的设计初衷是为了播放音频文件，比如MP3，但是越来越多的软件现在用来播放视频文件列表，M3U也可以指定在线流媒体音频源。很多播放器和软件都支持M3U文件格式。</p><p>M3U8是Unicode版本的M3U，用UTF-8编码。”M3U”和”M3U8”文件都是苹果公司使用的HTTP Live Streaming格式的基础，这种格式可以在iPhone和Macbook等设备播放。</p><p>HTTP Live Streaming（缩写是HLS）是由苹果公司提出基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。</p><p>综上，m3u8是一种文件格式。下载m3u8格式的文件时，会下载一个m3u8文件（文件列表），以及一个包含了很多ts文件（视频片段）的隐藏文件夹。</p><p>更多内容参考<a href="https://zh.wikipedia.org/wiki/M3U" target="_blank" rel="noopener">M3U</a>和<a href="https://zh.wikipedia.org/wiki/HTTP_Live_Streaming" target="_blank" rel="noopener">HTTP Live Streaming</a>。</p><a id="more"></a><h1 id="怎样下载m3u8格式视频？"><a href="#怎样下载m3u8格式视频？" class="headerlink" title="怎样下载m3u8格式视频？"></a>怎样下载m3u8格式视频？</h1><h2 id="获取下载地址"><a href="#获取下载地址" class="headerlink" title="获取下载地址"></a>获取下载地址</h2><p>1、安装chrome插件，<a href="https://chrome.google.com/webstore/detail/stream-video-downloader/imkngaibigegepnlckfcbecjoilcjbhf" target="_blank" rel="noopener">Stream Video Downloader</a>。</p><p>2、打开一个包含m3u8视频的页面，比如<a href="https://huaweicloud.bizconf.cn/watch/2234943" target="_blank" rel="noopener">云原生技术的前世今生</a>。点击播放，Stream Video Downloader就可以嗅探到m3u8文件。<br><img src="http://cdn.voidking.com/@/imgs/m3u8-download/copy.jpg?imageView2/0/w/600" alt=""></p><p>3、复制下载地址并保存，此处的下载地址为：<br><a href="https://myun-hw-s3.myun.tv/melj80jz/5a3ydjj0/1551265736611296603.m3u8" target="_blank" rel="noopener">https://myun-hw-s3.myun.tv/melj80jz/5a3ydjj0/1551265736611296603.m3u8</a></p><h2 id="FFmpeg"><a href="#FFmpeg" class="headerlink" title="FFmpeg"></a>FFmpeg</h2><p>FFmpeg是一个m3u8格式下载工具，并且可以把m3u8格式视频合并成mp4格式。</p><p>1、访问<a href="https://github.com/FFmpeg/FFmpeg/releases" target="_blank" rel="noopener">github-FFmpeg</a>或者<a href="https://ffmpeg.org/" target="_blank" rel="noopener">FFmpeg官网</a>，下载FFmpeg，本文中下载ffmpeg-4.2.2-win64-static.zip。</p><p>2、解压重命名文件夹为ffmpeg，进入ffmpeg/bin目录。</p><p>3、右键加+Shift，打开Powershell，输入下载合并命令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.\ffmpeg.exe -i <span class="string">"https://myun-hw-s3.myun.tv/melj80jz/5a3ydjj0/1551265736611296603.m3u8"</span> -c <span class="keyword">copy</span><span class="bash"> 01-云原生技术的前世今生.mp4</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.voidking.com/@/imgs/m3u8-download/download.jpg?imageView2/0/w/700" alt=""></p><p>耐心等待，下载完成即可在ffmpeg/bin目录中看到下载好的mp4视频文件。</p><h2 id="m3u8转mp4"><a href="#m3u8转mp4" class="headerlink" title="m3u8转mp4"></a>m3u8转mp4</h2><p>手机QQ浏览器的视频下载功能确实强大，大部分能看到的视频都可以下线，包括<a href="https://huaweicloud.bizconf.cn/watch/2234943" target="_blank" rel="noopener">云原生技术的前世今生</a>这个页面中的视频。</p><p>下载好的文件，是m3u8格式视频。正如上文所说，这个视频文件实际上是一个视频列表和一个隐藏文件夹组成。想要给它合并转换成mp4格式视频，怎么办？同样可以使用FFmpeg。</p><p>1、把视频列表和隐藏文件夹都拷贝到PC。</p><p>2、使用sublime打开m3u8文件，批量替换路径。<br>替换前为：</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#EXTM3U</span></span><br><span class="line"><span class="meta">#EXT-X-TARGETDURATION:11</span></span><br><span class="line"><span class="meta">#EXTINF:10.000000,</span></span><br><span class="line">file:<span class="comment">///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/0.ts</span></span><br><span class="line"><span class="meta">#EXTINF:10.000000,</span></span><br><span class="line">file:<span class="comment">///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/1.ts</span></span><br><span class="line"><span class="meta">#EXTINF:10.000000,</span></span><br><span class="line">file:<span class="comment">///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/2.ts</span></span><br><span class="line"><span class="meta">#EXTINF:10.000000,</span></span><br><span class="line">file:<span class="comment">///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/3.ts</span></span><br><span class="line"><span class="meta">#EXTINF:10.000000,</span></span><br><span class="line">file:<span class="comment">///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/4.ts</span></span><br><span class="line"><span class="meta">#EXTINF:10.000000,</span></span><br><span class="line">file:<span class="comment">///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/5.ts</span></span><br></pre></td></tr></table></figure><p>转换后为：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#EXTM3U</span><br><span class="line">#EXT-X-TARGETDURATION:<span class="number">11</span></span><br><span class="line">#EXTINF:<span class="number">10.000000</span>,</span><br><span class="line"><span class="number">.820</span>a585fc4f1a85d4875007aff5ba7a5/<span class="number">0.</span>ts</span><br><span class="line">#EXTINF:<span class="number">10.000000</span>,</span><br><span class="line"><span class="number">.820</span>a585fc4f1a85d4875007aff5ba7a5/<span class="number">1.</span>ts</span><br><span class="line">#EXTINF:<span class="number">10.000000</span>,</span><br><span class="line"><span class="number">.820</span>a585fc4f1a85d4875007aff5ba7a5/<span class="number">2.</span>ts</span><br><span class="line">#EXTINF:<span class="number">10.000000</span>,</span><br><span class="line"><span class="number">.820</span>a585fc4f1a85d4875007aff5ba7a5/<span class="number">3.</span>ts</span><br><span class="line">#EXTINF:<span class="number">10.000000</span>,</span><br><span class="line"><span class="number">.820</span>a585fc4f1a85d4875007aff5ba7a5/<span class="number">4.</span>ts</span><br><span class="line">#EXTINF:<span class="number">10.000000</span>,</span><br><span class="line"><span class="number">.820</span>a585fc4f1a85d4875007aff5ba7a5/<span class="number">5.</span>ts</span><br></pre></td></tr></table></figure><p>3、打开Powershell，执行转换命令：</p><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 直接合并转换（速度快）</span><br><span class="line">.\ffmpeg.exe -i <span class="meta">input</span>-<span class="meta">filename</span>.m3u8 -c copy <span class="meta">output</span>-<span class="meta">filename</span>.mp4</span><br><span class="line"># 合并转码压缩（速度慢）</span><br><span class="line">.\ffmpeg.exe -i <span class="meta">input</span>-<span class="meta">filename</span>.m3u8 <span class="meta">output</span>-<span class="meta">filename</span>.mp4</span><br></pre></td></tr></table></figure><p><img src="http://cdn.voidking.com/@/imgs/m3u8-download/transform.jpg?imageView2/0/w/700" alt=""><br>执行完成，即可看到转换好的mp4文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;m3u8格式&quot;&gt;&lt;a href=&quot;#m3u8格式&quot; class=&quot;headerlink&quot; title=&quot;m3u8格式&quot;&gt;&lt;/a&gt;m3u8格式&lt;/h1&gt;&lt;p&gt;M3U是一种播放多媒体列表的文件格式，它的设计初衷是为了播放音频文件，比如MP3，但是越来越多的软件现在用来播放视频文件列表，M3U也可以指定在线流媒体音频源。很多播放器和软件都支持M3U文件格式。&lt;/p&gt;
&lt;p&gt;M3U8是Unicode版本的M3U，用UTF-8编码。”M3U”和”M3U8”文件都是苹果公司使用的HTTP Live Streaming格式的基础，这种格式可以在iPhone和Macbook等设备播放。&lt;/p&gt;
&lt;p&gt;HTTP Live Streaming（缩写是HLS）是由苹果公司提出基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。&lt;/p&gt;
&lt;p&gt;综上，m3u8是一种文件格式。下载m3u8格式的文件时，会下载一个m3u8文件（文件列表），以及一个包含了很多ts文件（视频片段）的隐藏文件夹。&lt;/p&gt;
&lt;p&gt;更多内容参考&lt;a href=&quot;https://zh.wikipedia.org/wiki/M3U&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;M3U&lt;/a&gt;和&lt;a href=&quot;https://zh.wikipedia.org/wiki/HTTP_Live_Streaming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP Live Streaming&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爱好" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/"/>
    
      <category term="电脑" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/%E7%94%B5%E8%84%91/"/>
    
    
      <category term="chrome" scheme="https://www.voidking.com/tags/chrome/"/>
    
      <category term="下载" scheme="https://www.voidking.com/tags/%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>Django开发微信公众平台管理系统——第1章</title>
    <link href="https://www.voidking.com/dev-django-wechat-1/"/>
    <id>https://www.voidking.com/dev-django-wechat-1/</id>
    <published>2020-01-20T21:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>紧接着<a href="https://www.voidking.com/dev-django-wechat-0/">《Django开发微信公众平台管理系统——第0章》</a>，本文学习一下微信公众平台各种消息的接收和回复，主要参考<a href="https://werobot.readthedocs.io/zh_CN/latest/index.html" target="_blank" rel="noopener">WeRoBot文档</a>。</p><p>消息类型包括：TextMessage、ImageMessage、LinkMessage、LocationMessage、VoiceMessage、VideoMessage、UnknownMessage；<br>事件类型包括：SubscribeEvent、UnSubscribeEvent、ScanEvent、ScanCodePushEvent、ScanCodeWaitMsgEvent、PicSysphotoEvent、PicPhotoOrAlbumEvent、PicWeixinEvent、LocationSelectEvent、ClickEvent、ViewEvent、LocationEvent、TemplateSendJobFinishEvent、UserScanProductEvent、UserScanProductEnterSessionEvent、UserScanProductAsyncEvent、UserScanProductVerifyActionEvent、CardPassCheckEvent、CardNotPassCheckEvent、UserGetCardEvent、UserGiftingCardEvent、UserDelCardEvent、UserConsumeCardEvent、UserPayFromPayCellEvent、UserViewCardEvent、UserEnterSessionFromCardEvent、UpdateMemberCardEvent、CardSkuRemindEvent、CardPayOrderEvent、SubmitMembercardUserInfoEvent、UnknownEvent；<br>回复类型包括：TextReply、ImageReply、VoiceReply、VideoReply、ArticlesReply、MusicReply、TransferCustomerServiceReply、SuccessReply。</p><a id="more"></a><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>微信发给 /main/wechat/ 接口的信息（message），都传给了robot对象，robot对象根据消息类型调用自己的handler，处理后返回结果给微信。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="根据消息类型返回信息"><a href="#根据消息类型返回信息" class="headerlink" title="根据消息类型返回信息"></a>根据消息类型返回信息</h2><p>修改 wecms/main/views_wechat.py ，内容为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> werobot</span><br><span class="line">robot = werobot.WeRoBot(token=<span class="string">'vkwechat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Today is wonderful day!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.text</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'您发送了文本消息，内容为：'</span> + message.content</span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.image</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">image</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'您发送了图片消息，图片为：'</span> + message.img</span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.link</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">link</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'您发送了链接消息，链接为：'</span> + message.url</span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.location</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">location</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'您发送了位置消息，位置为：'</span> + message.label</span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.voice</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">voice</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'您发送了声音消息，media_id为：'</span> + message.media_id</span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.video</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">video</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'您发送了视频消息，media_id为：'</span> + message.media_id</span><br></pre></td></tr></table></figure><p>此时给公众号发送不同类型的消息，返回的内容也是不同的。</p><h2 id="返回图片消息"><a href="#返回图片消息" class="headerlink" title="返回图片消息"></a>返回图片消息</h2><p>1、登录微信公众平台，查看“公众号开发信息”中的“开发者ID(AppID)”和“开发者密码(AppSecret)”，并记录下来。</p><p>2、修改 wecms/main/views_wechat.py ，添加AppID和AppSecret的配置，添加media函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> werobot</span><br><span class="line"><span class="keyword">from</span> werobot.replies <span class="keyword">import</span> ImageReply</span><br><span class="line"></span><br><span class="line">robot = werobot.WeRoBot(token=<span class="string">'vkwechat'</span>)</span><br><span class="line">robot.config[<span class="string">'APP_ID'</span>] = <span class="string">'app_id'</span></span><br><span class="line">robot.config[<span class="string">'APP_SECRET'</span>] = <span class="string">'app_secret'</span></span><br><span class="line">client = robot.client</span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Today is wonderful day!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.filter('image')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">media</span><span class="params">(message)</span>:</span></span><br><span class="line">    media_id = client.upload_permanent_media(<span class="string">'image'</span>, open(<span class="string">r'C:\Users\haojin\Desktop\favicon.png'</span>, <span class="string">'rb'</span>))[<span class="string">'media_id'</span>]</span><br><span class="line">    reply = ImageReply(message=message, media_id=media_id)</span><br><span class="line">    <span class="keyword">return</span> reply</span><br><span class="line"></span><br><span class="line"><span class="comment"># other code</span></span><br></pre></td></tr></table></figure><p>需要注意的是，robot.filter(‘image’)需要放在robot.text的前面。因为werobot是链式匹配的，如果robot.text在前，匹配上了“image”，就会被text()函数处理。</p><p>2、查看本机的出口IP，修改“公众号开发信息”中的“IP白名单”，把出口IP填进去。</p><p>此时给公众号发送“image”，会返回一张图片。</p><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>以订阅事件和取消事件为例，添加事件处理：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@robot.subscribe</span><br><span class="line">def subscribe(<span class="keyword">event</span>):</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">'用户'</span> + <span class="keyword">event</span>.<span class="keyword">source</span> + <span class="string">'关注了公众号'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'感谢关注voidking，您的ID为：'</span> + <span class="keyword">event</span>.<span class="keyword">source</span></span><br><span class="line"></span><br><span class="line">@robot.unsubscribe</span><br><span class="line">def unsubscribe(<span class="keyword">event</span>):</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">'用户'</span> + <span class="keyword">event</span>.<span class="keyword">source</span> + <span class="string">'取消了关注'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br></pre></td></tr></table></figure><p>此时关注公众号，会收到自己的OpenID。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>前面的开发中，用到了token、APP_ID和APP_SECRET。这些信息应该写在配置文件中，而不是代码中，因此需要调整。</p><p>1、编辑 wecms/wecms/settings.py，添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Wechat Config</span></span><br><span class="line"><span class="attr">TOKEN</span> = <span class="string">'vkwechat'</span></span><br><span class="line"><span class="attr">APP_ID</span> = <span class="string">'app_id'</span></span><br><span class="line"><span class="attr">APP_SECRET</span> = <span class="string">'app_secret'</span></span><br></pre></td></tr></table></figure><p>2、编辑 wecms/main/views_wechat.py ，修改为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf import settings</span><br><span class="line">import werobot</span><br><span class="line"><span class="keyword">from</span> werobot.replies import ImageReply</span><br><span class="line"></span><br><span class="line">robot = werobot.WeRoBot(<span class="attribute">token</span>=settings.TOKEN)</span><br><span class="line">robot.config[<span class="string">'APP_ID'</span>] = settings.APP_ID</span><br><span class="line">robot.config[<span class="string">'APP_SECRET'</span>] = settings.APP_SECRET</span><br><span class="line">client = robot.client</span><br><span class="line"></span><br><span class="line"><span class="comment"># other code</span></span><br></pre></td></tr></table></figure><h1 id="源码分享"><a href="#源码分享" class="headerlink" title="源码分享"></a>源码分享</h1><p><a href="https://github.com/voidking/wecms/releases/tag/v0.1.0" target="_blank" rel="noopener">https://github.com/voidking/wecms/releases/tag/v0.1.0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;紧接着&lt;a href=&quot;https://www.voidking.com/dev-django-wechat-0/&quot;&gt;《Django开发微信公众平台管理系统——第0章》&lt;/a&gt;，本文学习一下微信公众平台各种消息的接收和回复，主要参考&lt;a href=&quot;https://werobot.readthedocs.io/zh_CN/latest/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WeRoBot文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;消息类型包括：TextMessage、ImageMessage、LinkMessage、LocationMessage、VoiceMessage、VideoMessage、UnknownMessage；&lt;br&gt;事件类型包括：SubscribeEvent、UnSubscribeEvent、ScanEvent、ScanCodePushEvent、ScanCodeWaitMsgEvent、PicSysphotoEvent、PicPhotoOrAlbumEvent、PicWeixinEvent、LocationSelectEvent、ClickEvent、ViewEvent、LocationEvent、TemplateSendJobFinishEvent、UserScanProductEvent、UserScanProductEnterSessionEvent、UserScanProductAsyncEvent、UserScanProductVerifyActionEvent、CardPassCheckEvent、CardNotPassCheckEvent、UserGetCardEvent、UserGiftingCardEvent、UserDelCardEvent、UserConsumeCardEvent、UserPayFromPayCellEvent、UserViewCardEvent、UserEnterSessionFromCardEvent、UpdateMemberCardEvent、CardSkuRemindEvent、CardPayOrderEvent、SubmitMembercardUserInfoEvent、UnknownEvent；&lt;br&gt;回复类型包括：TextReply、ImageReply、VoiceReply、VideoReply、ArticlesReply、MusicReply、TransferCustomerServiceReply、SuccessReply。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="后端" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/python/"/>
    
      <category term="django" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/django/"/>
    
    
      <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
      <category term="django" scheme="https://www.voidking.com/tags/django/"/>
    
      <category term="微信公众平台" scheme="https://www.voidking.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Django开发微信公众平台管理系统——发布篇</title>
    <link href="https://www.voidking.com/dev-django-wechat-deploy/"/>
    <id>https://www.voidking.com/dev-django-wechat-deploy/</id>
    <published>2020-01-19T21:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-django-wechat-0/">《Django开发微信公众平台管理系统——第0章》</a>一文中完成了<a href="https://github.com/voidking/wecms" target="_blank" rel="noopener">wecms项目</a>初始框架的搭建，并且绑定了微信公众号，实现了回复用户的任意消息。<br>但是，wecms项目是运行在本地的，关机后服务就不可用了，因此需要把项目部署到线上。本文中会使用docker搭建django环境，并且部署wecms项目。</p><a id="more"></a><h1 id="安装django"><a href="#安装django" class="headerlink" title="安装django"></a>安装django</h1><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/_/django" target="_blank" rel="noopener">Django - Docker Official Images</a>。<br>wecms依赖django2.1.7，但是没有对应版本，因此需要采用Plan B，自己安装Django。</p><p>2、登录dockerhub查看需要的<a href="https://hub.docker.com/_/python" target="_blank" rel="noopener">Python - Docker Official Images</a>。</p><p>3、下载python镜像（wecms依赖python3.6.3）<br><code>docker pull python:3.6.3</code></p><p>4、导出本地依赖信息</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">freeze</span> &gt; requirements.txt</span><br></pre></td></tr></table></figure><p>导出后把requirements.txt上传到服务器。</p><p>5、编写Dockerfile<br>安装django2.1.7，指定工作目录，添加启动命令</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.6</span>.<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt /tmp</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install --no-cache-dir -i https://pypi.doubanio.com/simple/ -r /tmp/requirements.txt</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt/wecms</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"python"</span>, <span class="string">"manage.py"</span>, <span class="string">"runserver"</span>, <span class="string">"0.0.0.0:8000"</span>]</span></span><br></pre></td></tr></table></figure><p>6、生成wecms镜像并上传</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t <span class="built_in">void</span>king/wecms:v1<span class="number">.0</span> .</span><br><span class="line">docker login</span><br><span class="line">docker push <span class="built_in">void</span>king/wecms:v1<span class="number">.0</span></span><br></pre></td></tr></table></figure><p>7、下载项目源码</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span></span><br><span class="line">git clone http<span class="variable">s:</span>//github.<span class="keyword">com</span>/voidking/wecms.git</span><br><span class="line"><span class="keyword">cd</span> wecms</span><br><span class="line">git checkout v0.<span class="number">0.0</span></span><br></pre></td></tr></table></figure><p>8、启动wecms服务</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name vk-wecms -d \</span><br><span class="line">-p <span class="number">8000</span>:<span class="number">8000</span> \</span><br><span class="line">-v /opt/wecms:/opt/wecms \</span><br><span class="line"><span class="built_in">void</span>king/wecms:v1<span class="number">.0</span></span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为vk-wecms，后台运行</li><li>映射宿主机8000端口到容器的8000端口</li><li>挂载宿主机目录/opt/wecms到容器目录/opt/wecms</li></ul><p>更多启动命令参数可以参考<a href="https://hub.docker.com/_/python?tab=description" target="_blank" rel="noopener">python - How to use this image</a>和<a href="https://hub.docker.com/_/django?tab=description" target="_blank" rel="noopener">django - How to use this image</a>。</p><p>9、验证安装<br><code>docker ps</code>，nginx启动正常的话就可以看到vk-wecms容器。<br><code>curl localhost:8000</code>，可以看到welcome to wecms!</p><p>浏览器访问 <a href="http://hostip:8000/" target="_blank" rel="noopener">http://hostip:8000/</a> ，提示You may need to add ‘hostip’ to ALLOWED_HOSTS.<br>因此修改 wecms/wecms/settings.py ，添加：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ALLOWED_HOSTS</span> = [<span class="string">'*'</span>]</span><br></pre></td></tr></table></figure><p>修改后的tag为v0.0.1。</p><h1 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h1><p>当前项目还没有使用到数据库，而且默认使用sqlite3，不过后期会改成mysql，所以这里做个铺垫。<br>mysql安装配置参考<a href="https://www.voidking.com/dev-docker-mysql/">《使用Docker安装配置Mysql》</a>。</p><h1 id="域名配置"><a href="#域名配置" class="headerlink" title="域名配置"></a>域名配置</h1><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>dnspod添加A记录，wecms记录值解析到hostip。</p><h2 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>创建 /etc/nginx/conf.d/wecms.voidking.com.conf ，内容为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> wecms.voidking.com; </span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:8000/; </span><br><span class="line"><span class="attribute">proxy_set_header</span> X-Forward-For <span class="variable">$remote_addr</span>;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-django-wechat-0/&quot;&gt;《Django开发微信公众平台管理系统——第0章》&lt;/a&gt;一文中完成了&lt;a href=&quot;https://github.com/voidking/wecms&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;wecms项目&lt;/a&gt;初始框架的搭建，并且绑定了微信公众号，实现了回复用户的任意消息。&lt;br&gt;但是，wecms项目是运行在本地的，关机后服务就不可用了，因此需要把项目部署到线上。本文中会使用docker搭建django环境，并且部署wecms项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="后端" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="python" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/python/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
      <category term="django" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/django/"/>
    
    
      <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
      <category term="django" scheme="https://www.voidking.com/tags/django/"/>
    
      <category term="微信公众平台" scheme="https://www.voidking.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0/"/>
    
      <category term="dokcer" scheme="https://www.voidking.com/tags/dokcer/"/>
    
  </entry>
  
  <entry>
    <title>Django开发微信公众平台管理系统——第0章</title>
    <link href="https://www.voidking.com/dev-django-wechat-0/"/>
    <id>https://www.voidking.com/dev-django-wechat-0/</id>
    <published>2020-01-18T21:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>两年前，学习了Django的开发，整理了一个系列的文档，《Django入门》、《Django开发简单Blog系统》、《Django部署到线上》等。半年前，使用Django和图像处理方法完成了毕业设计。</p><p>最近，打算空闲时间打造一下自己的微信公众号，于是安装了微擎系统。但是发现微擎系统存在很多问题，最不能忍受的是添加自动回复，添加完成没有报错，但是数据库根本没有记录！<br>找客服？对不起咱不是付费用户，没人给咱服务。看文档？对不起文档不涉及咱这个具体问题。找社区？对不起社区不活跃，没人遇到过咱这个问题，无人解答。学完微擎框架自己解决？有这个闲工夫，咱就自己写一个了！。。。行吧，拜拜了您哪！</p><p>找了一圈，没有找到特别满意的其他微信公众平台管理系统，那就，自己写一个吧！基于<a href="https://github.com/django/django" target="_blank" rel="noopener">Django</a>和<a href="https://github.com/offu/WeRoBot" target="_blank" rel="noopener">WeRoBot</a>，参考文档<a href="https://werobot.readthedocs.io/zh_CN/latest/contrib.html#django" target="_blank" rel="noopener">WeRoBot与其他 Web 框架集成</a>。</p><a id="more"></a><h1 id="开发环境准备"><a href="#开发环境准备" class="headerlink" title="开发环境准备"></a>开发环境准备</h1><p>1、Python版本3.6.3</p><p>2、Django版本2.1.7</p><p>3、PyCharm版本2018.1.4(Community Edition)</p><p>4、安装WeRoBot<br><code>pip install werobot</code></p><h1 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h1><p>首先给项目起个好名字吧，万一以后火了呢！就叫wecms吧，没错就是这么随意。</p><p>1、创建项目<br><code>django-admin startproject wecms</code></p><p>2、运行wecms</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cd</span> <span class="selector-tag">wecms</span></span><br><span class="line"><span class="selector-tag">python</span> <span class="selector-tag">manage</span><span class="selector-class">.py</span> <span class="selector-tag">runserver</span></span><br><span class="line"># <span class="selector-tag">or</span></span><br><span class="line"><span class="selector-tag">python</span> <span class="selector-tag">manage</span><span class="selector-class">.py</span> <span class="selector-tag">runserver</span> 0<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-pseudo">:8080</span></span><br></pre></td></tr></table></figure><p>3、测试访问<br>浏览器访问 <a href="http://localhost:8000/" target="_blank" rel="noopener">http://localhost:8000/</a> ，即可看到项目首页。</p><h1 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h1><p>1、创建应用<br>前期所有的模块都放在一起，以后再进行拆分优化，因此创建应用名为main。<br><code>python manage.py startapp main</code></p><p>2、注册应用<br>编辑 wecms/wecms/settings.py，添加：</p><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="type">Application</span> definition</span><br><span class="line"></span><br><span class="line"><span class="type">INSTALLED_APPS</span> = [</span><br><span class="line">    <span class="symbol">'django</span>.contrib.admin',</span><br><span class="line">    <span class="symbol">'django</span>.contrib.auth',</span><br><span class="line">    <span class="symbol">'django</span>.contrib.contenttypes',</span><br><span class="line">    <span class="symbol">'django</span>.contrib.sessions',</span><br><span class="line">    <span class="symbol">'django</span>.contrib.messages',</span><br><span class="line">    <span class="symbol">'django</span>.contrib.staticfiles',</span><br><span class="line">    <span class="symbol">'main'</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>3、第一个函数<br>编辑 wecms/main/views.py，如下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your views here.</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">'welcome to wecms!'</span>)</span><br></pre></td></tr></table></figure><p>4、添加路由<br>编辑 wecms/wecms/urls.py，如下修改：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> <span class="keyword">admin</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> <span class="type">path</span>, <span class="keyword">include</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, <span class="keyword">admin</span>.site.urls),</span><br><span class="line">    path(<span class="string">''</span>, <span class="keyword">include</span>(<span class="string">'main.urls'</span>)),</span><br><span class="line">    path(<span class="string">'main/'</span>, <span class="keyword">include</span>(<span class="string">'main.urls'</span>)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>创建 wecms/main/urls.py，内容如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> <span class="type">path</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>,views.<span class="keyword">index</span>, <span class="type">name</span>=<span class="string">'index'</span>),</span><br><span class="line">    path(<span class="string">'index/'</span>,views.<span class="keyword">index</span>, <span class="type">name</span>=<span class="string">'index'</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>5、启动服务<br><code>python manage.py runserver</code></p><p>6、测试访问<br>浏览器访问<br><a href="http://127.0.0.1:8000/" target="_blank" rel="noopener">http://127.0.0.1:8000/</a><br><a href="http://127.0.0.1:8000/main/" target="_blank" rel="noopener">http://127.0.0.1:8000/main/</a><br><a href="http://127.0.0.1:8000/main/index/" target="_blank" rel="noopener">http://127.0.0.1:8000/main/index/</a><br>都可以看到welcome to wecms!</p><h1 id="引入WeRoBot"><a href="#引入WeRoBot" class="headerlink" title="引入WeRoBot"></a>引入WeRoBot</h1><p>1、创建 wecms/main/views_wechat.py，内容为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> werobot</span><br><span class="line">robot = werobot.WeRoBot(token=<span class="string">'vkwechat'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@robot.handler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">(message)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Today is wonderful day!'</span></span><br></pre></td></tr></table></figure><p>收到的所有信息返回Today is wonderful day!</p><p>2、wecms/main/urls.py修改为：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> <span class="type">path</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views_wechat</span><br><span class="line"><span class="keyword">from</span> werobot.contrib.django <span class="keyword">import</span> make_view</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>,views.<span class="keyword">index</span>),</span><br><span class="line">    path(<span class="string">'index/'</span>,views.<span class="keyword">index</span>),</span><br><span class="line">    path(<span class="string">'wechat/'</span>,make_view(views_wechat.robot)),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注意，make_views函数中的参数并不是函数，而是robot对象。</p><p>3、测试访问<br>浏览器访问 <a href="http://127.0.0.1:8000/main/wechat/" target="_blank" rel="noopener">http://127.0.0.1:8000/main/wechat/</a><br><img src="http://cdn.voidking.com/@/imgs/django-wechat/werobot.jpg?imageView2/0/w/700" alt=""></p><h1 id="微信配置"><a href="#微信配置" class="headerlink" title="微信配置"></a>微信配置</h1><p>1、使用内网穿透，把本地8000端口代理到 wecms-dev.voidking.com 域名。</p><p>2、测试访问<br><a href="http://wecms-dev.voidking.com/main/wechat/" target="_blank" rel="noopener">http://wecms-dev.voidking.com/main/wechat/</a></p><p>3、配置微信公众号<br>登录微信公众平台，开发，基本配置，服务器配置，修改配置。<br>填入URL和代码中定义的Token，随机生成EncodingAESKey，消息加解密方式选择明文，提交。<br><img src="http://cdn.voidking.com/@/imgs/django-wechat/wechatconfig.jpg?imageView2/0/w/700" alt=""><br>提交成功，就完成了微信公众号和服务器的绑定。用户发送给微信公众号的消息，会转发给我们的服务器；服务器处理完成后的信息返回给微信公众号，微信公众号再把消息转发给用户。</p><p>4、测试<br><img src="http://cdn.voidking.com/@/imgs/django-wechat/voidking.jpg?imageView2/0/w/300" alt=""><br>扫码关注自己的公众号，然后发送任意信息，看看返回了啥？Today is wonderful day!</p><h1 id="源码分享"><a href="#源码分享" class="headerlink" title="源码分享"></a>源码分享</h1><p><a href="https://github.com/voidking/wecms/releases/tag/v0.0.0" target="_blank" rel="noopener">https://github.com/voidking/wecms/releases/tag/v0.0.0</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;两年前，学习了Django的开发，整理了一个系列的文档，《Django入门》、《Django开发简单Blog系统》、《Django部署到线上》等。半年前，使用Django和图像处理方法完成了毕业设计。&lt;/p&gt;
&lt;p&gt;最近，打算空闲时间打造一下自己的微信公众号，于是安装了微擎系统。但是发现微擎系统存在很多问题，最不能忍受的是添加自动回复，添加完成没有报错，但是数据库根本没有记录！&lt;br&gt;找客服？对不起咱不是付费用户，没人给咱服务。看文档？对不起文档不涉及咱这个具体问题。找社区？对不起社区不活跃，没人遇到过咱这个问题，无人解答。学完微擎框架自己解决？有这个闲工夫，咱就自己写一个了！。。。行吧，拜拜了您哪！&lt;/p&gt;
&lt;p&gt;找了一圈，没有找到特别满意的其他微信公众平台管理系统，那就，自己写一个吧！基于&lt;a href=&quot;https://github.com/django/django&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Django&lt;/a&gt;和&lt;a href=&quot;https://github.com/offu/WeRoBot&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WeRoBot&lt;/a&gt;，参考文档&lt;a href=&quot;https://werobot.readthedocs.io/zh_CN/latest/contrib.html#django&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WeRoBot与其他 Web 框架集成&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="后端" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="python" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/python/"/>
    
      <category term="django" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/django/"/>
    
    
      <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
      <category term="django" scheme="https://www.voidking.com/tags/django/"/>
    
      <category term="微信公众平台" scheme="https://www.voidking.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%B9%B3%E5%8F%B0/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus入门篇</title>
    <link href="https://www.voidking.com/dev-prometheus-start/"/>
    <id>https://www.voidking.com/dev-prometheus-start/</id>
    <published>2020-01-13T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prometheus简介"><a href="#Prometheus简介" class="headerlink" title="Prometheus简介"></a>Prometheus简介</h1><blockquote><p>Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud. Since its inception in 2012, many companies and organizations have adopted Prometheus, and the project has a very active developer and user community. It is now a standalone open source project and maintained independently of any company. To emphasize this, and to clarify the project’s governance structure, Prometheus joined the Cloud Native Computing Foundation in 2016 as the second hosted project, after Kubernetes.</p></blockquote><p>特性、组件和架构等更多信息，参考<a href="https://prometheus.io/docs/introduction/overview/" target="_blank" rel="noopener">Prometheus官方文档</a>。</p><a id="more"></a><h1 id="安装Prometheus-server"><a href="#安装Prometheus-server" class="headerlink" title="安装Prometheus server"></a>安装Prometheus server</h1><p>本节在CentOS7虚拟机上安装Prometheus server，虚拟机IP为192.168.56.130，安装流程主要参考<a href="https://prometheus.io/docs/prometheus/latest/getting_started/" target="_blank" rel="noopener">Prometheus - GETTING STARTED</a>。</p><p>1、下载Prometheus server<br>访问<a href="https://prometheus.io/download/" target="_blank" rel="noopener">Prometheus官网下载页</a>，这里选择下载prometheus-2.15.2.linux-amd64.tar.gz</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span></span><br><span class="line">wget http<span class="variable">s:</span>//github.<span class="keyword">com</span>/prometheus/prometheus/releases/download/v2.<span class="number">15.2</span>/prometheus-<span class="number">2.15</span>.<span class="number">2</span>.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure><p>2、解压并进行配置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-xzvf</span> <span class="selector-tag">prometheus-2</span><span class="selector-class">.15</span><span class="selector-class">.2</span><span class="selector-class">.linux-amd64</span><span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line"><span class="selector-tag">mv</span> <span class="selector-tag">prometheus-2</span><span class="selector-class">.15</span><span class="selector-class">.2</span><span class="selector-class">.linux-amd64</span> <span class="selector-tag">prometheus</span></span><br><span class="line"><span class="selector-tag">cd</span> <span class="selector-tag">prometheus</span></span><br><span class="line"><span class="selector-tag">vim</span> <span class="selector-tag">prometheus</span><span class="selector-class">.yml</span></span><br></pre></td></tr></table></figure><p>修改targets为0.0.0.0:9090，修改后的prometheus.yml如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># my global config</span></span><br><span class="line">global:</span><br><span class="line">  scrape_interval:     15s # <span class="builtin-name">Set</span> the scrape interval <span class="keyword">to</span> every 15 seconds.<span class="built_in"> Default </span>is every 1 minute.</span><br><span class="line">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The<span class="built_in"> default </span>is every 1 minute.</span><br><span class="line">  # scrape_timeout is <span class="builtin-name">set</span> <span class="keyword">to</span> the global<span class="built_in"> default </span>(10s).</span><br><span class="line"></span><br><span class="line"><span class="comment"># Alertmanager configuration</span></span><br><span class="line">alerting:</span><br><span class="line">  alertmanagers:</span><br><span class="line">  - static_configs:</span><br><span class="line">    - targets:</span><br><span class="line">      # - alertmanager:9093</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load rules once and periodically evaluate them according to the global 'evaluation_interval'.</span></span><br><span class="line">rule_files:</span><br><span class="line">  # - <span class="string">"first_rules.yml"</span></span><br><span class="line">  # - <span class="string">"second_rules.yml"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A scrape configuration containing exactly one endpoint to scrape:</span></span><br><span class="line"><span class="comment"># Here it's Prometheus itself.</span></span><br><span class="line">scrape_configs:</span><br><span class="line">  # The job name is added as a label `<span class="attribute">job</span>=&lt;job_name&gt;` <span class="keyword">to</span> any timeseries scraped <span class="keyword">from</span> this config.</span><br><span class="line">  - job_name: <span class="string">'prometheus'</span></span><br><span class="line"></span><br><span class="line">    # metrics_path defaults <span class="keyword">to</span> <span class="string">'/metrics'</span></span><br><span class="line">    # scheme defaults <span class="keyword">to</span> <span class="string">'http'</span>.</span><br><span class="line"></span><br><span class="line">    static_configs:</span><br><span class="line">    - targets: [<span class="string">'0.0.0.0:9090'</span>]</span><br></pre></td></tr></table></figure><p>3、启动prometheus<br><code>./prometheus --config.file=prometheus.yml</code></p><p>除了上面的安装方法，还可以下载Prometheus的<a href="https://hub.docker.com/u/prom" target="_blank" rel="noopener">Docker images</a>，使用Docker安装。</p><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>1、访问metrics<br>浏览器访问 <a href="http://192.168.56.130:9090/metrics" target="_blank" rel="noopener">http://192.168.56.130:9090/metrics</a><br>可以看到prometheus的一些信息：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HELP go_gc_duration_seconds A summary of the GC invocation durations.</span></span><br><span class="line"><span class="comment"># TYPE go_gc_duration_seconds summary</span></span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0"</span>&#125; 6.078e-06</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.25"</span>&#125; 9.877e-06</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.5"</span>&#125; 9.9e-06</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"0.75"</span>&#125; 1.1475e-05</span><br><span class="line">go_gc_duration_seconds&#123;<span class="attribute">quantile</span>=<span class="string">"1"</span>&#125; 1.2132e-05</span><br><span class="line">go_gc_duration_seconds_sum 4.9462e-05</span><br><span class="line">go_gc_duration_seconds_count 5</span><br><span class="line"><span class="comment"># HELP go_goroutines Number of goroutines that currently exist.</span></span><br><span class="line"><span class="comment"># TYPE go_goroutines gauge</span></span><br><span class="line">go_goroutines 35</span><br></pre></td></tr></table></figure><p>2、查看图表<br>浏览器访问 <a href="http://192.168.56.130:9090/graph" target="_blank" rel="noopener">http://192.168.56.130:9090/graph</a><br>在Expression输入框中输入：<code>prometheus_target_interval_length_seconds</code>，然后点击Execute，再点击下面Tab中的Graph。<br>可以看到一个图表，图表的含义是，emm，不知道。</p><p>3、收集其他metrics<br>想要收集metrics，首先要安装配置好exporter。<br>比如想要收集jmx metrics，那么需要安装<a href="https://github.com/prometheus/jmx_exporter" target="_blank" rel="noopener">prometheus/jmx_exporter</a>。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>Prometheus也有不少问题，比如数据量大的时候需要拆分集群，聚合数据很难数据去重，可用性较低等。因此出现了Thanos，能够解决Prometheus的很多问题，详情参考<a href="https://www.jianshu.com/p/b1f74d552b12" target="_blank" rel="noopener">分布式 Promethues 之 Thanos</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Prometheus简介&quot;&gt;&lt;a href=&quot;#Prometheus简介&quot; class=&quot;headerlink&quot; title=&quot;Prometheus简介&quot;&gt;&lt;/a&gt;Prometheus简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud. Since its inception in 2012, many companies and organizations have adopted Prometheus, and the project has a very active developer and user community. It is now a standalone open source project and maintained independently of any company. To emphasize this, and to clarify the project’s governance structure, Prometheus joined the Cloud Native Computing Foundation in 2016 as the second hosted project, after Kubernetes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;特性、组件和架构等更多信息，参考&lt;a href=&quot;https://prometheus.io/docs/introduction/overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Prometheus官方文档&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="基础" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="prometheus" scheme="https://www.voidking.com/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Docker中使用定时任务</title>
    <link href="https://www.voidking.com/dev-docker-crontab/"/>
    <id>https://www.voidking.com/dev-docker-crontab/</id>
    <published>2020-01-12T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-linux-crontab/">《Linux设置定时任务》</a>一文中学习了crontab的使用方法，但是同样的配置方法，在Docker中是不会生效的。因为Docker中默认只会启动一个进程，crond并不会启动。本文研究一下在Docker中配置定时任务的方法，踩踩坑。</p><a id="more"></a><h1 id="启动crond"><a href="#启动crond" class="headerlink" title="启动crond"></a>启动crond</h1><p>要想在容器中使用定时任务，有三个办法：</p><ul><li>把crond作为一号进程启动。</li><li>supervisor作为一号进程启动，使用supervisor启动crond。</li><li>进入容器手动启动crond。</li></ul><p>本文使用第一个方法启动crond，启动命令为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> run --name vkcrond -d -<span class="keyword">it </span>voidking/crond:<span class="built_in">v1</span>.<span class="number">0</span> <span class="string">"/bin/bash"</span> <span class="string">"-c"</span> <span class="string">"/usr/sbin/crond &gt; start.log &amp;&amp; tail -f start.log"</span></span><br></pre></td></tr></table></figure><h1 id="crond日志"><a href="#crond日志" class="headerlink" title="crond日志"></a>crond日志</h1><p>1、查看crond日志<br><code>tail /var/log/cron</code><br>报错没有这个文件，这是因为没有打开rsyslog。</p><p>2、打开rsyslog</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># centos</span></span><br><span class="line">/etc/init.d/rsyslog start</span><br><span class="line"><span class="comment"># centos7</span></span><br><span class="line">systemctl restart rsyslog.service</span><br><span class="line"><span class="comment"># centos6</span></span><br><span class="line">service rsyslog restart</span><br></pre></td></tr></table></figure><p>再次查看，crond日志文件就存在了。</p><h1 id="使用crond"><a href="#使用crond" class="headerlink" title="使用crond"></a>使用crond</h1><p>crond启动后，其他的配置参考<a href="https://www.voidking.com/dev-linux-crontab/">《Linux设置定时任务》</a>即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-linux-crontab/&quot;&gt;《Linux设置定时任务》&lt;/a&gt;一文中学习了crontab的使用方法，但是同样的配置方法，在Docker中是不会生效的。因为Docker中默认只会启动一个进程，crond并不会启动。本文研究一下在Docker中配置定时任务的方法，踩踩坑。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
      <category term="基础" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
      <category term="crontab" scheme="https://www.voidking.com/tags/crontab/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker安装配置Apache和PHP环境（微擎环境）</title>
    <link href="https://www.voidking.com/dev-docker-apache-php/"/>
    <id>https://www.voidking.com/dev-docker-apache-php/</id>
    <published>2019-12-30T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-centos-php-envirenment/">《在CentOS7上配置PHP运行环境》</a>一文中学习了安装配置LNMP环境，<a href="https://www.voidking.com/dev-centos-apache-php/">《CentOS安装Apache和PHP环境》</a>一文中学习了安装配置Apache和PHP环境。</p><p>本文学习使用Docker安装配置Apache和PHP，与Mysql结合，搭建一个容器化的LAMP环境，部署微擎服务。</p><p>前置条件是安装配置好了docker环境，安装方法参考<a href="https://www.voidking.com/dev-docker-start/">《Docker入门》</a>。已知docker宿主机IP为192.168.56.130。</p><a id="more"></a><h1 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h1><p>参考<a href="https://www.voidking.com/dev-docker-mysql/">《使用Docker安装配置Mysql》</a>，安装好mysql server和mysql client。</p><p>1、登录mysql server<br><code>mysql -h 127.0.0.1 -u root -p</code></p><p>2、创建数据库</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database `w7`<span class="built_in"> default </span>character <span class="builtin-name">set</span> utf8 collate utf8_general_ci;</span><br></pre></td></tr></table></figure><h1 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h1><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/_/php" target="_blank" rel="noopener">PHP - Docker Official Images</a>。</p><p>2、下载php镜像（以7.2-apache为例）<br><code>docker pull php:7.2-apache</code></p><p>选择带有apache的版本，省去了安装apache的步骤。</p><p>3、启动php和apache服务</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name vk-php -d \</span><br><span class="line">-p <span class="number">8080</span>:<span class="number">80</span> \</span><br><span class="line">-v <span class="regexp">/opt/</span>php<span class="regexp">/w7:/</span>var<span class="regexp">/www/</span>html \</span><br><span class="line"><span class="string">php:</span><span class="number">7.2</span>-apache</span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为vk-php，后台运行</li><li>映射宿主机8080端口到容器的80端口</li><li>挂载宿主机目录/opt/php/w7到容器目录/var/www/html</li></ul><p>更多启动命令参数可以参考<a href="https://hub.docker.com/_/php?tab=description" target="_blank" rel="noopener">How to use this image</a>。</p><p>4、创建测试文件<br><code>vim /opt/php/w7/index.php</code>，内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?php</span></span></span><br><span class="line"><span class="php">    <span class="keyword">echo</span> <span class="string">'hello php7.2'</span>;</span></span><br><span class="line"><span class="php"><span class="meta">?&gt;</span></span></span><br></pre></td></tr></table></figure><p>5、验证安装<br><code>curl localhost:8080</code>，可以看到hello php7.2。<br>浏览器访问 <a href="http://192.168.56.130:8080" target="_blank" rel="noopener">http://192.168.56.130:8080</a> ，可以看到hello php7.2。</p><p>以上，apache和php环境安装配置完成。</p><h1 id="安装微擎"><a href="#安装微擎" class="headerlink" title="安装微擎"></a>安装微擎</h1><h2 id="初始尝试"><a href="#初始尝试" class="headerlink" title="初始尝试"></a>初始尝试</h2><p>主要参考<a href="voidking.com/dev-we7-start/">《微擎系统搭建》</a>和<a href="https://www.kancloud.cn/we7pengpeng/weengine/1369873" target="_blank" rel="noopener">微擎linux服务器安装</a>。<br>1、下载微擎安装引导文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/php/w7</span><br><span class="line">wget http<span class="variable">s:</span>//cdn.w7.<span class="keyword">cc</span>/download/WeEngine-Laster-Online.zip</span><br><span class="line">unzip WeEngine-Laster-Online.zip</span><br></pre></td></tr></table></figure><p>2、浏览器访问安装页面<br><a href="http://192.168.56.130:8080/install.php" target="_blank" rel="noopener">http://192.168.56.130:8080/install.php</a><br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/install.jpg?imageView2/0/w/600" alt=""><br>填入用户名密码后，点击验证后安装微擎。没有通过验证，如下图：<br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/check.jpg?imageView2/0/w/800" alt=""><br>由报错看，主要是目录权限问题和缺少扩展问题。</p><h2 id="重做镜像"><a href="#重做镜像" class="headerlink" title="重做镜像"></a>重做镜像</h2><p>1、修改sources.list<br>在容器中查看/etc/apt/sources.list，发现镜像版本是debian buster，因此新建一个sources.list为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/debian/</span> buster main non-free contrib</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/debian/</span> buster main non-free contrib</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/debian-security buster/u</span>pdates main</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/debian-security buster/u</span>pdates main</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/debian/</span> buster-updates main non-free contrib</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/debian/</span> buster-updates main non-free contrib</span><br><span class="line">deb http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/debian/</span> buster-backports main non-free contrib</span><br><span class="line">deb-src http:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/debian/</span> buster-backports main non-free contrib</span><br></pre></td></tr></table></figure><p>2、编写Dockerfile</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> php:7.2-apache</span><br><span class="line"></span><br><span class="line">COPY sources.list /etc/apt/sources.list</span><br><span class="line"><span class="builtin-name">RUN</span> apt-<span class="builtin-name">get</span> update &amp;&amp; apt-<span class="builtin-name">get</span> install -y libpng-dev libzip-dev \</span><br><span class="line">    &amp;&amp; docker-php-ext-install zip gd pdo pdo_mysql</span><br><span class="line"><span class="builtin-name">RUN</span> chmod 777 /var/www/html</span><br></pre></td></tr></table></figure><p>3、生成新镜像<br><code>docker build -t voidking/w7:v1.0 .</code><br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/success.jpg?imageView2/0/w/600" alt=""></p><h2 id="再次尝试"><a href="#再次尝试" class="headerlink" title="再次尝试"></a>再次尝试</h2><p>1、删除原有容器</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">stop vk-php</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">rm vk-php</span></span><br></pre></td></tr></table></figure><p>2、启动新的容器</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name vk-php -d \</span><br><span class="line">-p <span class="number">8080</span>:<span class="number">80</span> \</span><br><span class="line">-v /opt/php/w7:/var/www/html \</span><br><span class="line"><span class="built_in">void</span>king/w7:v1<span class="number">.0</span></span><br></pre></td></tr></table></figure><p>3、再次安装，再次验证<br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/check2.jpg?imageView2/0/w/800" alt=""><br>可以看到，这次还剩一个问题：外网不可访问。这就奇怪了，在容器内明明是可以正常访问外网的，为啥报这个错？既然没错，那就忽略它好了。但是这个错存在，就无法进行下一步，因此这里我们换一种安装方式：源码安装。</p><h2 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h2><p>1、下载源码</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">/opt/php/w7</span></span><br><span class="line">rm -rf <span class="string">./</span>*</span><br><span class="line"><span class="keyword">cd</span> <span class="string">..</span></span><br><span class="line">git clone https:<span class="string">//gitee.com/we7coreteam/pros.git</span> w7</span><br></pre></td></tr></table></figure><p>2、再次安装，再次验证<br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/check2.jpg?imageView2/0/w/800" alt=""><br>nice，完美跳过了外网不可访问这个坑。然后，data目录权限报错。<br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/data.jpg?imageView2/0/w/700" alt=""><br>修改data目录权限，<code>chmod 777 /opt/php/w7/data/</code>，问题解决。</p><p>3、填入数据库连接信息，以及管理员用户名密码<br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/mysql.jpg?imageView2/0/w/800" alt=""></p><p>4、然后，安装完成。<br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/finish.jpg?imageView2/0/w/800" alt=""></p><p>5、测试访问<br>浏览器访问首页 <a href="http://192.168.56.130:8080/index.php" target="_blank" rel="noopener">http://192.168.56.130:8080/index.php</a> ，即会跳转到微擎登录页。<br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/login.jpg?imageView2/0/w/700" alt=""></p><p>以上，微擎系统安装配置完成，可以愉快地使用了。</p><h1 id="百度云解析"><a href="#百度云解析" class="headerlink" title="百度云解析"></a>百度云解析</h1><h2 id="备案失败"><a href="#备案失败" class="headerlink" title="备案失败"></a>备案失败</h2><p>百度智能云年终盛典，全场云服务器一折起，于是151块钱入手了一台1C2G2M的百度云BCC主机。但是，没有想到的是，网站需要新增接入备案，否则无法使用域名！！！这个不怪百度，如果使用百度云备案成功，以后想要接入阿里云或者腾讯云，也需要新增接入备案。</p><p>不过百度云比较坑的有两点：第一点是备案期间域名不能解析，而阿里云备案期间可以正常解析。第二点是无法通过百度云的备案审核，提交备案后百度云给出了六条不符合审核条件的理由，而同样的审核材料，一个月前在阿里云通过了备案审核。</p><p>真的是没有对比就没有伤害，第一个念头是退货，然而退货失败。不能退货，那该怎样使用这台服务器呢？那该怎样在这台服务器上部署服务，然后通过域名访问呢？</p><p>在github找到了一些项目，<a href="https://github.com/awesome-selfhosted/awesome-selfhosted" target="_blank" rel="noopener">awesome-selfhosted</a>，想要部署一些不需要域名的服务，好歹给利用起来了。但是，依然不甘心，想要给这些服务加上域名！然后，真的找到了办法！前提是你还有一台可以进行域名接入的主机，无论是备案过的阿里云主机，还是不需要备案的海外主机，都可以。</p><h2 id="解析方案"><a href="#解析方案" class="headerlink" title="解析方案"></a>解析方案</h2><p>已知两台主机：可以域名接入的主机（主机A），百度云主机（主机B）。<br>我们在主机B上部署好了微擎服务，想要给这个服务添加一个域名：w7.voidking.com </p><p>1、安装frp<br>参考<a href="https://www.voidking.com/dev-frp/">《使用frp进行内网穿透》</a>，在主机A上安装配置好frp server，在主机B上安装配置好frp client。主机B上的8080端口，映射为主机A上的3480端口。</p><p>2、nginx配置<br>在主机A上，添加nginx解析 w7.voidking.com.conf ，内容为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">server_name</span> w7.voidking.com;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://127.0.0.1:3480/;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，不用多加其他参数，不然会出现502等错误。</p><p>3、域名解析<br>在dnspod上添加A记录解析到主机A。</p><p>以上，可以通过域名访问百度云上的微擎服务了。</p><h1 id="微擎后续问题"><a href="#微擎后续问题" class="headerlink" title="微擎后续问题"></a>微擎后续问题</h1><h2 id="站点URL问题"><a href="#站点URL问题" class="headerlink" title="站点URL问题"></a>站点URL问题</h2><p>确实可以通过域名访问微擎服务了，但是站点的很多请求地址为 127.0.0.1:3480 ，因为微擎服务使用proxy_pass里的URL作为了站点URL。我们想让微擎服务把域名作为站点URL，解决办法很简单，添加：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;</span><br></pre></td></tr></table></figure><p>但是，添加完这个参数，就会出现502错误，尴尬了吧。。。<br>nginx层没法进行修复，看来这个问题只能通过修改微擎源码来修复了。<br>编辑/opt/php/w7/framework/bootstrap.inc.php，如下修改：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># line 90, change</span></span><br><span class="line"><span class="regexp">//</span> <span class="variable">$_W</span>[<span class="string">'siteroot'</span>] = htmlspecialchars(<span class="variable">$_W</span>[<span class="string">'sitescheme'</span>] . (isset(<span class="variable">$_SERVER</span>[<span class="string">'HTTP_HOST'</span>]) ? <span class="variable">$_SERVER</span>[<span class="string">'HTTP_HOST'</span>] : <span class="string">''</span>) . <span class="variable">$sitepath</span>);</span><br><span class="line"><span class="variable">$_W</span>[<span class="string">'siteroot'</span>] = <span class="string">'w7.voidking.com'</span>;</span><br></pre></td></tr></table></figure><p>然后，请求地址就全部变成 w7.voidking.com ，nice。</p><h2 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h2><p>但是，一些请求报错：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Access</span> <span class="keyword">to</span> XMLHttpRequest at <span class="string">'javascript:;'</span> <span class="keyword">from</span> origin <span class="string">'http://w7.voidking.com'</span> has been blocked <span class="keyword">by</span> CORS <span class="keyword">policy</span>: <span class="keyword">Cross</span> origin requests are <span class="keyword">only</span> supported <span class="keyword">for</span> protocol schemes: http, data, chrome, chrome-<span class="keyword">extension</span>, https.</span><br></pre></td></tr></table></figure><p>明明都是同一个url，居然还是跨域错误，没有找到解决办法。</p><h2 id="重装微擎"><a href="#重装微擎" class="headerlink" title="重装微擎"></a>重装微擎</h2><p>既然自己安装微擎问题这么多，那就使用官网给的docker镜像好了，参考<a href="https://www.kancloud.cn/we7pengpeng/weengine/1369875" target="_blank" rel="noopener">docker安装微擎</a>。</p><p>1、删除原有环境</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">stop vk-php</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">rm vk-php</span></span><br></pre></td></tr></table></figure><p>2、启动新的容器</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --name vk-php -d \</span><br><span class="line">-p <span class="number">8080</span>:<span class="number">80</span> \</span><br><span class="line">-v /opt/w7/<span class="symbol">mysql:</span>/var/<span class="class"><span class="keyword">lib</span>/<span class="title">mysql</span> \</span></span><br><span class="line">-v /opt/w7/<span class="symbol">html:</span>/var/www/html \</span><br><span class="line">-e MYSQL\_ROOT\_PASSWORD=<span class="number">123456</span> -d \</span><br><span class="line">--restart=always \</span><br><span class="line">ccr.ccs.tencentyun.com/weiqing/<span class="symbol">nginxphpmysql:</span><span class="number">1.0</span></span><br></pre></td></tr></table></figure><p>3、重新安装微擎<br><a href="http://ip:8080/install.php" target="_blank" rel="noopener">http://ip:8080/install.php</a><br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/newinstall.jpg?imageView2/0/w/700" alt=""></p><p>4、设置用户名密码<br><img src="http://cdn.voidking.com/@/imgs/docker-apache-php/setting.jpg?imageView2/0/w/700" alt=""></p><p>5、同样修改微擎源码，修改站点URL。</p><p>然后，同样有跨域问题，但是站点已经可以正常使用了，就先这么滴吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-centos-php-envirenment/&quot;&gt;《在CentOS7上配置PHP运行环境》&lt;/a&gt;一文中学习了安装配置LNMP环境，&lt;a href=&quot;https://www.voidking.com/dev-centos-apache-php/&quot;&gt;《CentOS安装Apache和PHP环境》&lt;/a&gt;一文中学习了安装配置Apache和PHP环境。&lt;/p&gt;
&lt;p&gt;本文学习使用Docker安装配置Apache和PHP，与Mysql结合，搭建一个容器化的LAMP环境，部署微擎服务。&lt;/p&gt;
&lt;p&gt;前置条件是安装配置好了docker环境，安装方法参考&lt;a href=&quot;https://www.voidking.com/dev-docker-start/&quot;&gt;《Docker入门》&lt;/a&gt;。已知docker宿主机IP为192.168.56.130。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="后端" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
      <category term="php" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/php/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
      <category term="apache" scheme="https://www.voidking.com/tags/apache/"/>
    
      <category term="php" scheme="https://www.voidking.com/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker安装配置Nginx</title>
    <link href="https://www.voidking.com/dev-docker-nginx/"/>
    <id>https://www.voidking.com/dev-docker-nginx/</id>
    <published>2019-12-29T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-centos-nginx-autostart/">《CentOS7设置nginx开机自启动》</a>一文中学习了在CentOS7中安装配置Nginx的方法，本文学习一下使用Docker安装配置Nginx的方法。</p><p>前置条件是安装配置好了docker环境，安装方法参考<a href="https://www.voidking.com/dev-docker-start/">《Docker入门》</a>。已知docker宿主机IP为192.168.56.130。</p><a id="more"></a><h1 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h1><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/_/nginx" target="_blank" rel="noopener">Nginx - Docker Official Images</a>。</p><p>2、下载nginx镜像（以1.17.7为例）<br><code>docker pull nginx:1.17.7</code></p><p>3、拷贝nginx镜像中的文件到宿主机</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name tmp-nginx -d <span class="string">nginx:</span><span class="number">1.17</span><span class="number">.7</span></span><br><span class="line">mkdir -p <span class="regexp">/opt/</span>nginx</span><br><span class="line">docker cp tmp-<span class="string">nginx:</span><span class="regexp">/etc/</span>nginx<span class="regexp">/conf.d /</span>opt<span class="regexp">/nginx/</span></span><br><span class="line">docker cp tmp-<span class="string">nginx:</span><span class="regexp">/usr/</span>share<span class="regexp">/nginx/</span>html <span class="regexp">/opt/</span>nginx/</span><br><span class="line">docker stop tmp-nginx</span><br><span class="line">docker rm tmp-nginx</span><br></pre></td></tr></table></figure><p>4、启动nginx服务</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name vk-nginx -d \</span><br><span class="line">-p <span class="number">80</span>:<span class="number">80</span> -p <span class="number">443</span>:<span class="number">443</span> \</span><br><span class="line">-v <span class="regexp">/opt/</span>nginx<span class="regexp">/conf.d:/</span>etc<span class="regexp">/nginx/</span>conf.<span class="string">d:</span>ro \</span><br><span class="line">-v <span class="regexp">/opt/</span>nginx<span class="regexp">/html:/</span>usr<span class="regexp">/share/</span>nginx/<span class="string">html:</span>ro \</span><br><span class="line"><span class="string">nginx:</span><span class="number">1.17</span><span class="number">.7</span></span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为vk-nginx，后台运行</li><li>映射宿主机80、443端口到容器的80、443端口</li><li>挂载宿主机目录/opt/nginx/conf.d到容器目录/etc/nginx/conf.d，挂载宿主机目录/opt/nginx/html到容器/usr/share/nginx/html目录</li></ul><p>更多启动命令参数可以参考<a href="https://hub.docker.com/_/nginx?tab=description" target="_blank" rel="noopener">How to use this image</a>。</p><p>5、验证安装<br><code>docker ps</code>，nginx启动正常的话就可以看到vk-nginx容器。<br><code>curl localhost</code>，可以看到html文本。<br>浏览器访问 <a href="http://192.168.56.130" target="_blank" rel="noopener">http://192.168.56.130</a> ，可以看到Welcome to nginx!</p><h1 id="配置使用Nginx"><a href="#配置使用Nginx" class="headerlink" title="配置使用Nginx"></a>配置使用Nginx</h1><p>以添加 <a href="http://www.voidking.com">www.voidking.com</a> 域名为例，参考<a href="https://www.voidking.com/dev-hexo-https/">《Hexo启用https加密连接》</a>和<a href="https://www.voidking.com/dev-hexo-accelerate/">《Hexo加速访问》</a>。</p><p>1、下载博客项目</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/nginx/html</span><br><span class="line">git clone http<span class="variable">s:</span>//gitee.<span class="keyword">com</span>/voidking/voidking.github.io.git voidking</span><br></pre></td></tr></table></figure><p>2、上传证书<br>上传 1_<a href="http://www.voidking.com_bundle.crt" target="_blank" rel="noopener">www.voidking.com_bundle.crt</a> 和 2_<a href="http://www.voidking.com.key" target="_blank" rel="noopener">www.voidking.com.key</a> 到/opt/nginx/conf.d/ssl目录</p><p>3、创建配置文件</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span>/nginx/<span class="keyword">conf</span>.d</span><br><span class="line">www.voidking.<span class="keyword">com</span>.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure><p>内容为：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span> www.voidking.com;</span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$server_name</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="comment"># SSL configuration</span></span><br><span class="line">    <span class="attribute">listen</span> <span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">listen</span> [::]:<span class="number">443</span> ssl;</span><br><span class="line">    <span class="attribute">ssl</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">server_name</span> www.voidking.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span> /etc/nginx/conf.d/ssl/1_www.voidking.com_bundle.crt; </span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /etc/nginx/conf.d/ssl/2_www.voidking.com.key; </span><br><span class="line">    <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;  </span><br><span class="line">    <span class="attribute">ssl_protocols</span> SSLv3 TLSv1 TLSv1.<span class="number">1</span> TLSv1.<span class="number">2</span>;</span><br><span class="line">    <span class="attribute">ssl_ciphers</span>  HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM;</span><br><span class="line">    <span class="attribute">ssl_prefer_server_ciphers</span> <span class="literal">on</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span> /usr/share/nginx/html/voidking/;</span><br><span class="line">        <span class="attribute">index</span> index.html;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、重启nginx<br><code>docker restart vk-nginx</code></p><p>5、查看是否启动成功</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">ps</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">logs vk-nginx</span></span><br></pre></td></tr></table></figure><p>发现nginx服务已经正常启动，但是存在一个警告：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[warn] <span class="number">1</span>#<span class="number">1</span>: the <span class="string">"ssl"</span> directive <span class="keyword">is</span> deprecated, use the <span class="string">"listen ... ssl"</span> directive instead in /etc/nginx/<span class="keyword">conf</span>.d/www.voidking.<span class="keyword">com</span>.<span class="keyword">conf</span>:<span class="number">11</span></span><br></pre></td></tr></table></figure><p>可以选择去掉第11行的配置，警告就会消失。</p><p>至此， <a href="http://www.voidking.com">www.voidking.com</a> 域名配置完成，在dnspod添加好解析即可访问，nice。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-centos-nginx-autostart/&quot;&gt;《CentOS7设置nginx开机自启动》&lt;/a&gt;一文中学习了在CentOS7中安装配置Nginx的方法，本文学习一下使用Docker安装配置Nginx的方法。&lt;/p&gt;
&lt;p&gt;前置条件是安装配置好了docker环境，安装方法参考&lt;a href=&quot;https://www.voidking.com/dev-docker-start/&quot;&gt;《Docker入门》&lt;/a&gt;。已知docker宿主机IP为192.168.56.130。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
      <category term="nginx" scheme="https://www.voidking.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker安装配置Jenkins</title>
    <link href="https://www.voidking.com/dev-docker-jenkins/"/>
    <id>https://www.voidking.com/dev-docker-jenkins/</id>
    <published>2019-12-28T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-centos7-install-jenkins/">《CentOS7安装部署Jenkins》</a>一文中学习了Jenkins的安装方法，如果使用Docker来安装Jenkins，同样可以简单很多。</p><p>前置条件是安装配置好了docker环境，安装方法参考<a href="https://www.voidking.com/dev-docker-start/">《Docker入门》</a>。已知docker宿主机IP为192.168.56.130。</p><a id="more"></a><h1 id="安装Jenkins"><a href="#安装Jenkins" class="headerlink" title="安装Jenkins"></a>安装Jenkins</h1><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/_/jenkins" target="_blank" rel="noopener">jenkins-Docker Official Images</a>。<br>需要注意，官方的jenkins最新版本是2.60.3，版本太低！如果安装该版本，安装后会出现各种插件使用不了的情况。因此，这里真正需要使用的<a href="https://hub.docker.com/r/jenkins/jenkins" target="_blank" rel="noopener">jenkins命名空间下的jenkins</a>。</p><p>2、下载jenkins镜像（以2.210为例）<br><code>docker pull jenkins/jenkins:2.210</code></p><p>3、启动jenkins服务</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run --name vk-jenkins -d \</span><br><span class="line">-p <span class="number">8080</span>:<span class="number">8080</span> -p <span class="number">50000</span>:<span class="number">50000</span> \</span><br><span class="line">-v /opt/jenkins_home:/var/jenkins_home \</span><br><span class="line">jenkins/jenkins:<span class="number">2.210</span></span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为vk-jenkins，后台运行</li><li>映射宿主机8080、50000端口到容器8080、50000端口</li><li>挂载宿主机目录/opt/jenkins_home到容器目录/var/jenkins_home</li></ul><p>更多启动命令参数可以参考<a href="https://hub.docker.com/_/jenkins?tab=description" target="_blank" rel="noopener">How to use this image</a>。</p><p>启动报错：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker: <span class="builtin-name">Error</span> response <span class="keyword">from</span> daemon: driver failed programming external connectivity on endpoint vk-jenkins (d95f7502bb87d6795547061a2f13b5e2ba44648977399fcde1c05640f678554a):  (iptables failed: iptables --wait -t<span class="built_in"> nat </span>-A DOCKER -p tcp -d 0/0 --dport 50000 -j DNAT --to-destination 172.17.0.2:50000 ! -i docker0: iptables: <span class="literal">No</span> chain/target/match by that name.</span><br><span class="line"> (exit status 1)).</span><br></pre></td></tr></table></figure><p>解决办法：重启docker，然后重新执行启动命令。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">restart docker</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">rm vk-jenkins</span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker</span> <span class="string">run --name vk-jenkins -d \</span></span><br><span class="line"><span class="meta">-p</span> <span class="string">8080:8080 -p 50000:50000 \</span></span><br><span class="line"><span class="meta">-v</span> <span class="string">/opt/jenkins_home:/var/jenkins_home \</span></span><br><span class="line"><span class="meta">jenkins/jenkins</span>:<span class="string">2.210</span></span><br></pre></td></tr></table></figure><p>4、验证安装<br><code>docker ps</code><br>jenkins启动正常的话就可以看到vk-jenkins容器。<br>如果启动失败，可以使用<code>docker logs vk-jenkins</code>查看失败原因并进行解决。本例中确实报错了，提示目录权限问题：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">touch: cannot touch '/var/jenkins_home/copy_reference_file.<span class="built_in">log</span>': Permission denied</span><br><span class="line">Can <span class="keyword">not</span> <span class="built_in">write</span> <span class="keyword">to</span> /var/jenkins_home/copy_reference_file.<span class="built_in">log</span>. Wrong volume permissions?</span><br></pre></td></tr></table></figure><p>这是因为/opt/jenkins_home目录的拥有者为root用户，而容器中jenkins user的uid为1000，因此需要修改目录权限。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R <span class="number">1000</span>:<span class="number">1000</span> /opt/jenkins_home</span><br><span class="line">docker start vk-jenkins</span><br></pre></td></tr></table></figure><h1 id="配置使用Jenkins"><a href="#配置使用Jenkins" class="headerlink" title="配置使用Jenkins"></a>配置使用Jenkins</h1><p>1、加速插件安装（推荐）<br>参考<a href="https://www.cnblogs.com/hellxz/p/jenkins_install_plugins_faster.html" target="_blank" rel="noopener">Jenkins安装插件提速</a>，修改/opt/jenkins_home/updates/default.json。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i 's/http:<span class="symbol">\/</span><span class="symbol">\/</span>updates.jenkins-ci.org<span class="symbol">\/</span>download/https:<span class="symbol">\/</span><span class="symbol">\/</span>mirrors.tuna.tsinghua.edu.cn<span class="symbol">\/</span>jenkins/g' default.json</span><br><span class="line">sed -i 's/http:<span class="symbol">\/</span><span class="symbol">\/</span>www.google.com/https:<span class="symbol">\/</span><span class="symbol">\/</span>www.baidu.com/g' default.json</span><br></pre></td></tr></table></figure><p>修改完成重启vk-jenkins，正常进入安装流程，直观感觉就是“安装推荐的插件”这一步速度能够提高一百倍。</p><p>2、查看初始密码<br><code>cat /opt/jenkins_home/secrets/initialAdminPassword</code></p><p>3、jenkins配置<br>浏览器访问：<a href="http://192.168.56.130:8080/" target="_blank" rel="noopener">http://192.168.56.130:8080/</a><br>初始密码填入页面，开始进行jenkins配置。</p><p>4、后续<br>接下来的配置和使用参考<a href="https://www.voidking.com/dev-centos7-install-jenkins/">《CentOS7安装部署Jenkins》</a>即可。</p><p>至此，docker安装配置jenkins完成。因为第一次使用的是官方的jenkins2.60.3镜像，所以遇到了一些坑，下面一节中进行记录。</p><h1 id="jenkins2-60-3问题解决"><a href="#jenkins2-60-3问题解决" class="headerlink" title="jenkins2.60.3问题解决"></a>jenkins2.60.3问题解决</h1><p>1、安装推荐的插件，会卡在Getting Started。<br>。这是因为安装插件前会尝试连接 <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a> ，来判断网络是否连通。国内用户需要改成 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> ，<code>vim /opt/jenkins_home/updates/default.json</code>，找到google，修改为baidu。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 修改前</span></span><br><span class="line"><span class="string">"connectionCheckUrl"</span>:<span class="string">"http://www.google.com/"</span>,</span><br><span class="line"><span class="meta"># 修改后</span></span><br><span class="line"><span class="string">"connectionCheckUrl"</span>:<span class="string">"http://www.baidu.com/"</span>,</span><br></pre></td></tr></table></figure><p>2、重启jenkins特别慢<br><code>docker restart vk-jenkins</code><br>发现重启特别特别慢，大概要10分钟左右才能重启成功。而且，重启后connectionCheckUrl中的baidu又变成了google！！！</p><p>3、修改updatecenter<br>怀疑在jenkins启动时会根据其他地方的配置更改default.json，但是没有找到。查找资料发现了一篇<a href="https://gist.github.com/jedi4ever/898114" target="_blank" rel="noopener">update jenkins Updatecenter from CLI</a>，其中一行：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O <span class="keyword">default</span>.json http://updates.jenkins-ci.org/<span class="keyword">update</span>-center.json</span><br></pre></td></tr></table></figure><p>那么，如果修改updatecenter为中国的镜像站，是不是就会使用中国的update-center.json代替default.json？试一试，<code>vim /opt/jenkins_home/hudson.model.UpdateCenter.xml</code>，原文为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://updates.jenkins-ci.org/update-center.json<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sites</span>&gt;</span></span><br></pre></td></tr></table></figure><p>中国镜像站去哪里找呢？可以在<a href="http://mirrors.jenkins-ci.org/status.html#cn" target="_blank" rel="noopener">the status of Jenkins mirrors</a>网站上选择。<br>hudson.model.UpdateCenter.xml修改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sites</span>&gt;</span></span><br></pre></td></tr></table></figure><p>删除/opt/jenkins_home/updates目录，再次重启vk-jenkins。<br>重启速度飞快，10秒左右，但是default.json中依然是google，因为镜像站里的update-center.json和jenkins源站里的update-center.json相同。既然jenkins启动时都会使用远端的update-center.json替代本地的default.json，那么解决该问题的方法就是给hudson.model.UpdateCenter.xml一个远端的修改后的update-center.json，或者不让jenkins获取到远端update-center.json。</p><p>4、填写假的updatecenter<br>修改hudson.model.UpdateCenter.xml为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sites</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">site</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>default<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://localhost<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">site</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sites</span>&gt;</span></span><br></pre></td></tr></table></figure><p>因为获取不到update-center.json，然后就可以跳过安装插件的步骤。</p><p>5、更换新版jenkins镜像<br>jenkins安装成功，但是在jenkins的系统配置页面，可以看到很多插件报错，而且无法修复，系统建议进行jenkins升级。<br>此时，小编才意识到，官方jenkins镜像不是最新版！！！需要改用jenkins命名空间下的新版jenkins镜像，但是“安装推荐的插件”这一步依然很慢，几个小时甚至更久才能安装成功。加速方法可以参考本文 配置使用Jenkins 一节中的 加速插件安装。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-centos7-install-jenkins/&quot;&gt;《CentOS7安装部署Jenkins》&lt;/a&gt;一文中学习了Jenkins的安装方法，如果使用Docker来安装Jenkins，同样可以简单很多。&lt;/p&gt;
&lt;p&gt;前置条件是安装配置好了docker环境，安装方法参考&lt;a href=&quot;https://www.voidking.com/dev-docker-start/&quot;&gt;《Docker入门》&lt;/a&gt;。已知docker宿主机IP为192.168.56.130。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker安装配置GitLab</title>
    <link href="https://www.voidking.com/dev-docker-gitlab/"/>
    <id>https://www.voidking.com/dev-docker-gitlab/</id>
    <published>2019-12-28T17:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-centos7-install-gitlab/">《CentOS7安装配置GitLab》</a>一文中学习了GitLab的安装方法，如果使用Docker来安装GitLab，可以简单很多。</p><p>前置条件是安装配置好了docker环境，安装方法参考<a href="https://www.voidking.com/dev-docker-start/">《Docker入门》</a>。已知docker宿主机IP为192.168.56.130。</p><a id="more"></a><h1 id="安装GitLab"><a href="#安装GitLab" class="headerlink" title="安装GitLab"></a>安装GitLab</h1><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/r/gitlab/gitlab-ce/" target="_blank" rel="noopener">GitLab Docker images</a>。</p><p>2、下载gitlab镜像（以12.6.1-ce.0版本为例）<br><code>docker pull gitlab/gitlab-ce:12.6.1-ce.0</code></p><p>3、启动gitlab服务</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name vk-gitlab -d  \</span><br><span class="line">-<span class="keyword">p</span> <span class="number">80</span>:<span class="number">80</span> -<span class="keyword">p</span> <span class="number">443</span>:<span class="number">443</span> -<span class="keyword">p</span> <span class="number">3422</span>:<span class="number">22</span>  \</span><br><span class="line">--restart always \</span><br><span class="line">-v /<span class="keyword">opt</span>/gitlab/confi<span class="variable">g:</span>/etc/gitlab \</span><br><span class="line">-v /<span class="keyword">opt</span>/gitlab/<span class="built_in">log</span><span class="variable">s:</span>/var/<span class="built_in">log</span>/gitlab \</span><br><span class="line">-v /<span class="keyword">opt</span>/gitlab/dat<span class="variable">a:</span>/var/<span class="keyword">opt</span>/gitlab \</span><br><span class="line">gitlab/gitlab-<span class="keyword">ce</span>:<span class="number">12.6</span>.<span class="number">1</span>-<span class="keyword">ce</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为vk-gitlab，后台运行</li><li>映射宿主机80、443、3422端口到容器80、443、22端口</li><li>意外关闭后自动重启</li><li>挂载三个宿主机目录到容器</li></ul><p>4、验证安装<br><code>docker ps</code><br>gitlab启动正常的话就可以看到vk-gitlab容器。<br>如果启动失败，可以使用<code>docker logs vk-gitlab</code>查看失败原因并进行解决。</p><h1 id="验证GitLab"><a href="#验证GitLab" class="headerlink" title="验证GitLab"></a>验证GitLab</h1><h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd <span class="params">--add-port=80/tcp</span> <span class="params">--permanent</span></span><br><span class="line">firewall-cmd <span class="params">--add-port=443/tcp</span> <span class="params">--permanent</span></span><br><span class="line">firewall-cmd <span class="params">--add-port=3422/tcp</span> <span class="params">--permanent</span></span><br><span class="line">systemctl <span class="keyword">reload</span> firewalld</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h2 id="端口验证"><a href="#端口验证" class="headerlink" title="端口验证"></a>端口验证</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nc -v localhost <span class="number">22</span></span><br><span class="line">nc -v localhost <span class="number">3422</span></span><br></pre></td></tr></table></figure><p>可以看到两个端口的返回结果不同：<br>SSH-2.0-OpenSSH_7.4<br>SSH-2.0-OpenSSH_7.2p2 Ubuntu-4ubuntu2.8</p><h2 id="服务验证"><a href="#服务验证" class="headerlink" title="服务验证"></a>服务验证</h2><p>宿主机测试：<code>curl localhost -L</code><br>浏览器测试：<a href="http://192.168.56.130" target="_blank" rel="noopener">http://192.168.56.130</a></p><h1 id="配置GitLab"><a href="#配置GitLab" class="headerlink" title="配置GitLab"></a>配置GitLab</h1><h2 id="http域名访问"><a href="#http域名访问" class="headerlink" title="http域名访问"></a>http域名访问</h2><p>1、配置url和ssh协议端口<br><code>vim /opt/gitlab/config/gitlab.rb</code>，如下修改：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">line</span> 23, uncomment and change</span></span><br><span class="line">external_url <span class="string">'http://gitlab.voidking.com'</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">line</span> 56, uncomment and change</span></span><br><span class="line">gitlab_rails[<span class="string">'gitlab_ssh_host'</span>] = <span class="string">'gitlab.voidking.com'</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">line</span> 456, uncomment and change</span></span><br><span class="line">gitlab_rails[<span class="string">'gitlab_shell_ssh_port'</span>] = <span class="number">3422</span></span><br></pre></td></tr></table></figure><p>该配置的效果是，当用户在gitlab项目页面点击Clone时，Clone with HTTP和Clone with SSH的结果类似于：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http:<span class="regexp">//gi</span>tlab.voidking.com<span class="regexp">/root/</span>voidking.git</span><br><span class="line">ssh:<span class="regexp">//gi</span>t@gitlab.voidking.com:<span class="number">3422</span><span class="regexp">/root/</span>voidking.git</span><br></pre></td></tr></table></figure><p>2、重启vk-gitlab<br><code>docker restart vk-gitlab</code></p><p>3、修改主机hosts</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168.56.130</span>  gitlab.voidking.com</span><br></pre></td></tr></table></figure><p>4、测试访问<br>浏览器访问：<a href="http://gitlab.voidking.com" target="_blank" rel="noopener">http://gitlab.voidking.com</a></p><h2 id="https域名访问"><a href="#https域名访问" class="headerlink" title="https域名访问"></a>https域名访问</h2><p>参考<a href="https://www.voidking.com/dev-centos7-install-gitlab/">《CentOS7安装配置GitLab》</a>添加SSL一节，生成证书，配置gitlab使用证书，并且添加到浏览器。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-centos7-install-gitlab/&quot;&gt;《CentOS7安装配置GitLab》&lt;/a&gt;一文中学习了GitLab的安装方法，如果使用Docker来安装GitLab，可以简单很多。&lt;/p&gt;
&lt;p&gt;前置条件是安装配置好了docker环境，安装方法参考&lt;a href=&quot;https://www.voidking.com/dev-docker-start/&quot;&gt;《Docker入门》&lt;/a&gt;。已知docker宿主机IP为192.168.56.130。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
      <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker安装配置Mysql</title>
    <link href="https://www.voidking.com/dev-docker-mysql/"/>
    <id>https://www.voidking.com/dev-docker-mysql/</id>
    <published>2019-12-28T12:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-centos-mysql-autostart/">《CentOS7设置mysql开机自启动》</a>和<a href="https://www.voidking.com/dev-centos-multiple-mysql/">《CentOS安装多版本MySQL》</a>中都涉及了Mysql的安装方法，本文中会提供一个更好的Mysql安装方法。</p><p>前置条件是安装配置好了docker环境，安装方法参考<a href="https://www.voidking.com/dev-docker-start/">《Docker入门》</a>。已知docker宿主机IP为192.168.56.130。</p><a id="more"></a><h1 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h1><h2 id="安装mysql-server"><a href="#安装mysql-server" class="headerlink" title="安装mysql-server"></a>安装mysql-server</h2><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/_/mysql" target="_blank" rel="noopener">mysql版本</a>。</p><p>2、下载mysql镜像（以mysql5.6为例）<br><code>docker pull mysql:5.6</code></p><p>3、启动mysql服务</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name vk-mysql -d \</span><br><span class="line">-p <span class="number">3306</span>:<span class="number">3306</span> \</span><br><span class="line">-v /opt/data/<span class="symbol">mysql:</span>/var/<span class="class"><span class="keyword">lib</span>/<span class="title">mysql</span> \</span></span><br><span class="line">-e MYSQL_ROOT_PASSWORD=voidking \</span><br><span class="line"><span class="symbol">mysql:</span><span class="number">5.6</span></span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为vk-mysql，后台运行</li><li>映射宿主机3306端口到容器3306端口</li><li>映射宿主机/opt/data/mysql目录（不需要提前创建目录）到容器/var/lib/mysql，用于存储mysql数据到宿主机</li><li>设置数据库密码为voidking</li></ul><p>更高级的启动命令参考<a href="https://hub.docker.com/_/mysql?tab=description" target="_blank" rel="noopener">How to use this image</a>。</p><p>4、验证安装<br><code>docker ps</code><br>mysql启动正常的话就可以看到vk-mysql容器。<br>如果启动失败，可以使用<code>docker logs vk-mysql</code>查看失败原因并进行解决。</p><h2 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd <span class="params">--add-port=3306/tcp</span> <span class="params">--permanent</span></span><br><span class="line">systemctl <span class="keyword">reload</span> firewalld</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h2 id="安装mysql-client"><a href="#安装mysql-client" class="headerlink" title="安装mysql-client"></a>安装mysql-client</h2><p>1、在宿主机或者其他机器上，安装mysql-client<br><code>yum install -y mariadb.x86_64 mariadb-libs.x86_64</code></p><p>2、连接mysql-server<br><code>mysql -h 192.168.56.130 -P 3306 -u root -p</code><br>输入密码，即可连接到vk-mysql容器服务。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-centos-mysql-autostart/&quot;&gt;《CentOS7设置mysql开机自启动》&lt;/a&gt;和&lt;a href=&quot;https://www.voidking.com/dev-centos-multiple-mysql/&quot;&gt;《CentOS安装多版本MySQL》&lt;/a&gt;中都涉及了Mysql的安装方法，本文中会提供一个更好的Mysql安装方法。&lt;/p&gt;
&lt;p&gt;前置条件是安装配置好了docker环境，安装方法参考&lt;a href=&quot;https://www.voidking.com/dev-docker-start/&quot;&gt;《Docker入门》&lt;/a&gt;。已知docker宿主机IP为192.168.56.130。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="后端" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
      <category term="mysql" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/mysql/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用LastPass管理密码</title>
    <link href="https://www.voidking.com/dev-manage-pwd-by-lastpass/"/>
    <id>https://www.voidking.com/dev-manage-pwd-by-lastpass/</id>
    <published>2019-12-07T14:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前整理过一篇<a href="https://www.voidking.com/dev-manage-pwd-by-keepass/">《使用KeePass管理密码》</a>，也实际使用了一段时间的KeePass，但是发现这个工具并不能很好地满足自己的需求。因为KeePass适合用来本地存储密码，但是用来自动填充密码，还是不够好用。</p><p>本文中，将会学习使用更加方便的LastPass，用来存储管理安全级别为商密和普密的密码。</p><a id="more"></a><h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>1、访问<a href="https://www.lastpass.com/zh" target="_blank" rel="noopener">LastPass官网</a>，创建账号，然后在chrome安装<a href="https://chrome.google.com/webstore/detail/lastpass-free-password-ma/hdokiejnpimakedhajhdlcegeplioahd" target="_blank" rel="noopener">LastPass插件</a>。</p><p>2、在chrome登录lastpass账号。</p><p>3、正常访问网站，登录后会提示保存密码到lastpass，下次登录即可自动填充密码。</p><h1 id="导出导入密码"><a href="#导出导入密码" class="headerlink" title="导出导入密码"></a>导出导入密码</h1><h2 id="keepass导出密码"><a href="#keepass导出密码" class="headerlink" title="keepass导出密码"></a>keepass导出密码</h2><p>假设之前使用keepass管理密码，需要进行导出。<br>1、使用keepass打开数据库文件</p><p>2、File，Export，KeePass XML，Export to，OK。</p><h2 id="lastpass导入密码"><a href="#lastpass导入密码" class="headerlink" title="lastpass导入密码"></a>lastpass导入密码</h2><p>1、点击lastpass图标，Account Options，Advance，Import，Other。</p><p>2、Source选择KeePass</p><p>3、使用打开xml密码文件，复制，粘贴到Centent。</p><p>4、UPLOAD，IMPORT SELECTED或者IMPORT ALL。</p><h2 id="lastpass导出密码"><a href="#lastpass导出密码" class="headerlink" title="lastpass导出密码"></a>lastpass导出密码</h2><p>1、点击lastpass图标，Account Options，Advance，Export，LastPass CSV File。</p><p>2、复制页面的文本，保存为csv文件。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>和keepass相比，lastpass确实更加实用。<br>个人经验是使用lastpass代替chrome的密码管理，保存管理商密和普密；使用keepass或者其他方法保存核密。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前整理过一篇&lt;a href=&quot;https://www.voidking.com/dev-manage-pwd-by-keepass/&quot;&gt;《使用KeePass管理密码》&lt;/a&gt;，也实际使用了一段时间的KeePass，但是发现这个工具并不能很好地满足自己的需求。因为KeePass适合用来本地存储密码，但是用来自动填充密码，还是不够好用。&lt;/p&gt;
&lt;p&gt;本文中，将会学习使用更加方便的LastPass，用来存储管理安全级别为商密和普密的密码。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爱好" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/"/>
    
      <category term="电脑" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/%E7%94%B5%E8%84%91/"/>
    
    
      <category term="chrome" scheme="https://www.voidking.com/tags/chrome/"/>
    
      <category term="windows" scheme="https://www.voidking.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>当K8S遇到PM2</title>
    <link href="https://www.voidking.com/dev-k8s-pm2/"/>
    <id>https://www.voidking.com/dev-k8s-pm2/</id>
    <published>2019-11-20T21:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.055Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>某个前端项目使用PM2进行node进程的管理，把该项目打包放到了docker镜像中，使用docker run命令可以正常启动。但是，把docker镜像放入K8S集群后，启动报错，<code>[PM2][ERROR] Process failed to launch spawn E2BIG</code>。</p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>查阅资料发现，上面的问题，是因为环境变量过多引起的。K8S启动时会给容器注入环境变量，K8S集群中的项目数越多，环境变量也就越多。而pm2在启动时会导入系统中的环境变量，当环境变量数量过多时，就会报错<code>[PM2][ERROR] Process failed to launch spawn E2BIG</code>。</p><p>使用<code>env</code>或者<code>printenv</code>命令查看容器中的变量，果然环境变量特别多。解决方案也就明确了：减少环境变量。</p><h2 id="修改pm2源码"><a href="#修改pm2源码" class="headerlink" title="修改pm2源码"></a>修改pm2源码</h2><p>第一个解决方案是修改pm2源码，过滤掉环境变量。<br>编辑/usr/local/lib/node_modules/pm2/lib/Common.js，修改process.env部分。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterDockerEnv</span></span>(envObj)&#123;</span><br><span class="line">let keys = Object.keys(envObj);</span><br><span class="line">let <span class="keyword">new</span><span class="type">_env</span> = &#123;&#125;;</span><br><span class="line">let allowKeys = keys.filter(item =&gt; !item.startsWith(<span class="string">"ENV_HOST_"</span>));</span><br><span class="line">allowKeys.forEach(key =&gt; &#123;</span><br><span class="line"><span class="keyword">new</span><span class="type">_env</span>[key] = envObj[key];</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span><span class="type">_env</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">new</span><span class="type">Env</span> = filterDockerEnv(env);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Change to double check  (dropped , &#123;pm_cwd: cwd&#125;)</span></span><br><span class="line">app.env = [&#123;&#125;, <span class="keyword">new</span><span class="type">Env</span>, app.env || &#123;&#125;].reduce(<span class="function"><span class="keyword">function</span></span>(e1, e2)&#123;</span><br><span class="line"><span class="keyword">return</span> util._extend(e1, e2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="清除环境变量"><a href="#清除环境变量" class="headerlink" title="清除环境变量"></a>清除环境变量</h2><p>第二个方案是在pm2启动前清除系统中的环境变量。<br>正常启动命令前，先执行一段清除系统变量的脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `env | grep -E -i <span class="string">'SERVICE|HOST|ADDR|PORT'</span> | sed <span class="string">'s/=.*//'</span>` ; <span class="keyword">do</span> <span class="built_in">unset</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>第二种方案更加灵活，推荐使用这种方式。</p><h1 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h1><p><a href="https://zhuanlan.zhihu.com/p/74056339" target="_blank" rel="noopener">一次NodeJS测试集群全线瘫痪的解决思路</a><br><a href="https://zhuanlan.zhihu.com/p/89679565" target="_blank" rel="noopener">一次环境变量引发的血案</a><br><a href="https://github.com/Unitech/pm2/issues/3271" target="_blank" rel="noopener">[PM2][ERROR] Process failed to launch spawn E2BIG</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;某个前端项目使用PM2进行node进程的管理，把该项目打包放到了docker镜像中，使用docker run命令可以正常启动。但是，把docker镜像放入K8S集群后，启动报错，&lt;code&gt;[PM2][ERROR] Process failed to launch spawn E2BIG&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
      <category term="node" scheme="https://www.voidking.com/tags/node/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="pm2" scheme="https://www.voidking.com/tags/pm2/"/>
    
  </entry>
  
  <entry>
    <title>Docker内部使用Supervisor</title>
    <link href="https://www.voidking.com/dev-docker-supervisor/"/>
    <id>https://www.voidking.com/dev-docker-supervisor/</id>
    <published>2019-11-18T21:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>使用docker run启动一个beego服务，命令为：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> run --name <span class="keyword">bservice </span>-d -p <span class="number">8080</span>:<span class="number">8080</span> voidking/<span class="keyword">bservice:v1 </span><span class="string">"/bin/bash"</span> <span class="string">"-c"</span> <span class="string">"cd /opt/bservice &amp;&amp; nohup ./bservice"</span></span><br></pre></td></tr></table></figure><p>启动后，beego服务是容器内PID为1的前台进程。假设该服务不是那么健壮，出了bug会停止服务，那么容器也会随之停止。<br>如果想要服务停止后自动启动，那么就需要supervisor出马了。</p><a id="more"></a><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>参考<a href="https://www.voidking.com/dev-centos-supervisor/">《CentOS安装配置Supervisor》</a>，在容器中安装supervisor。</p><p>1、在/etc/supervisor中新建bservice.conf文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:bservice]</span></span><br><span class="line"><span class="attr">directory</span>=/opt/bservice</span><br><span class="line"><span class="attr">command</span>=/opt/bservice/bservice</span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/var/log/supervisor/%(program_name)s.log</span><br><span class="line"><span class="attr">stderr_logfile</span>=/var/log/supervisor/%(program_name)s.log</span><br></pre></td></tr></table></figure><p>2、测试启动</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">retart supervisord</span></span><br><span class="line"><span class="attr">supervisorctl</span> <span class="string">status</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">aux | grep bservice</span></span><br></pre></td></tr></table></figure><p>3、编辑/etc/supervisord.conf，设置supervisor为前台进程</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nodaemon</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>4、把容器保存为镜像</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit container_id <span class="built_in">void</span>king/bservice:v2</span><br></pre></td></tr></table></figure><p>5、修改启动命令为</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> run --name <span class="keyword">bservice </span>-d -p <span class="number">8080</span>:<span class="number">8080</span> voidking/<span class="keyword">bservice:v2 </span><span class="string">"/bin/bash"</span> <span class="string">"-c"</span> <span class="string">"supervisord -c /etc/supervisord.conf"</span></span><br></pre></td></tr></table></figure><p>使用这种启动方式，哪怕服务因为意外停止，也会马上被supervisor拉起，提高了服务的可用性。</p><h1 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h1><p>再来看另外一个场景：<br><code>npm run start</code>原本可以正常启动node服务进入后台运行，容器化后通过docker run启动，命令为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> --name fservice -d -p 80:80 voidking/fservice:v1 <span class="string">"/bin/bash"</span> <span class="string">"-c"</span> <span class="string">"cd /opt/fservice &amp;&amp; npm run start"</span></span></span><br></pre></td></tr></table></figure><p>尴尬的是，容器启动后就会自动退出，这是因为容器运行必须要一个前台进程。因此一个简单的解决办法是修改启动命令，添加tail -f：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> --name fservice -d -p 80:80 voidking/fservice:v1 <span class="string">"/bin/bash"</span> <span class="string">"-c"</span> <span class="string">"cd /opt/fservice &amp;&amp; npm run start &gt; ./start.log &amp;&amp; tail -f ./start.log"</span></span></span><br></pre></td></tr></table></figure><p>但是，更好的办法还是使用supervisor进行node服务的管理。同样需要在容器中安装supervisor，然后进行配置。</p><p>1、在/etc/supervisor中新建fservice.conf文件</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:fservice]</span></span><br><span class="line"><span class="attr">directory</span>=/opt/fservice</span><br><span class="line"><span class="attr">command</span>=npm run start</span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"><span class="attr">autostart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/var/log/supervisor/%(program_name)s.log</span><br><span class="line"><span class="attr">stderr_logfile</span>=/var/log/supervisor/%(program_name)s.log</span><br></pre></td></tr></table></figure><p>2、测试启动</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">retart supervisord</span></span><br><span class="line"><span class="attr">supervisorctl</span> <span class="string">status</span></span><br><span class="line"><span class="attr">ps</span> <span class="string">aux | grep fservice</span></span><br></pre></td></tr></table></figure><p>3、编辑/etc/supervisord.conf，设置supervisor为前台进程</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nodaemon</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure><p>4、把容器保存为镜像</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit container_id <span class="built_in">void</span>king/fservice:v2</span><br></pre></td></tr></table></figure><p>5、修改启动命令为</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">docker</span> run --name <span class="keyword">bservice </span>-d -p <span class="number">8080</span>:<span class="number">8080</span> voidking/fservice:<span class="built_in">v2</span> <span class="string">"/bin/bash"</span> <span class="string">"-c"</span> <span class="string">"supervisord -c /etc/supervisord.conf"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;使用docker run启动一个beego服务，命令为：&lt;/p&gt;
&lt;figure class=&quot;highlight armasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;docker&lt;/span&gt; run --name &lt;span class=&quot;keyword&quot;&gt;bservice &lt;/span&gt;-d -p &lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;8080&lt;/span&gt; voidking/&lt;span class=&quot;keyword&quot;&gt;bservice:v1 &lt;/span&gt;&lt;span class=&quot;string&quot;&gt;&quot;/bin/bash&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;-c&quot;&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;cd /opt/bservice &amp;amp;&amp;amp; nohup ./bservice&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;启动后，beego服务是容器内PID为1的前台进程。假设该服务不是那么健壮，出了bug会停止服务，那么容器也会随之停止。&lt;br&gt;如果想要服务停止后自动启动，那么就需要supervisor出马了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>CentOS6.8上Python2.6.6升级Python2.7.15</title>
    <link href="https://www.voidking.com/dev-centos68-python26-to-python27/"/>
    <id>https://www.voidking.com/dev-centos68-python26-to-python27/</id>
    <published>2019-11-18T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Python 2.6 is no longer supported by the Python core team, please upgrade your Python.</p></blockquote><p>虽然Python2.6已经不再维护，但是CentOS6.8系统里默认的Python版本依然是2.6.6。<br>这就很尴尬了，要么凑合用，但是没有pip命令，常规安装pip的方法还会失败。要么进行升级，但是整个过程很麻烦。<br>本文记录一下2.6.6凑合用的方法，以及升级2.7.15的方法。</p><a id="more"></a><h1 id="凑合用"><a href="#凑合用" class="headerlink" title="凑合用"></a>凑合用</h1><p>参考<a href="https://zj-john.github.io/tips/cjm68jlig009w1of0oiup5zw7.html" target="_blank" rel="noopener">python2.6安装pip</a>。</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">curl </span><span class="string">https:</span>//<span class="string">bootstrap.</span><span class="string">pypa.</span><span class="string">io/</span>2.6/<span class="built_in">get-pip.py</span> -o <span class="built_in">get-pip.py</span></span><br><span class="line"><span class="built_in">python</span> <span class="built_in">get-pip.py</span></span><br></pre></td></tr></table></figure><h1 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h1><p>参考<a href="https://www.jianshu.com/p/ccf3ba6f6d1f" target="_blank" rel="noopener">centos6.5升级到python2.7</a>。</p><p>1、安装编译依赖</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y <span class="keyword">install</span> gcc openssl-devel bzip2-devel</span><br></pre></td></tr></table></figure><p>2、下载安装包并解压</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span></span><br><span class="line">wget http<span class="variable">s:</span>//www.<span class="keyword">python</span>.org/ftp/<span class="keyword">python</span>/<span class="number">2.7</span>.<span class="number">15</span>/Python-<span class="number">2.7</span>.<span class="number">15</span>.tgz</span><br><span class="line">tar xvzf Python-<span class="number">2.7</span>.<span class="number">15</span>.tgz</span><br></pre></td></tr></table></figure><p>3、安装</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd Python<span class="number">-2.7</span><span class="number">.15</span></span><br><span class="line">./configure --<span class="keyword">enable</span>-optimizations</span><br><span class="line"><span class="built_in">make</span> &amp;&amp; <span class="built_in">make</span> altinstall</span><br></pre></td></tr></table></figure><p>configure时加上enable-optimizations，启用PGO优化，让Python在运行时能变得更快。make 加altinstall参数，避免覆盖原来安装在/usr/bin/python 的版本。</p><p>4、检查安装<br><code>/usr/local/bin/python2.7 -V</code></p><p>5、修改系统默认python</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv <span class="regexp">/usr/</span>bin<span class="regexp">/python /u</span>sr<span class="regexp">/bin/</span>python2.<span class="number">6.6</span> </span><br><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>python2.<span class="number">7</span> <span class="regexp">/usr/</span>bin<span class="regexp">/python</span></span><br></pre></td></tr></table></figure><p>6、解决yum不支持python2.7的问题<br><code>sed -i &#39;s/python/python2.6.6/&#39; /usr/bin/yum</code></p><p>7、安装pip</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">python</span> <span class="string">-m ensurepip</span></span><br><span class="line"><span class="attr">pip</span> <span class="string">-V</span></span><br></pre></td></tr></table></figure><p>以上，升级完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Python 2.6 is no longer supported by the Python core team, please upgrade your Python.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然Python2.6已经不再维护，但是CentOS6.8系统里默认的Python版本依然是2.6.6。&lt;br&gt;这就很尴尬了，要么凑合用，但是没有pip命令，常规安装pip的方法还会失败。要么进行升级，但是整个过程很麻烦。&lt;br&gt;本文记录一下2.6.6凑合用的方法，以及升级2.7.15的方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="centos" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/centos/"/>
    
    
      <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
      <category term="centos" scheme="https://www.voidking.com/tags/centos/"/>
    
      <category term="pip" scheme="https://www.voidking.com/tags/pip/"/>
    
  </entry>
  
  <entry>
    <title>Docker-Compose入门篇</title>
    <link href="https://www.voidking.com/dev-docker-compose/"/>
    <id>https://www.voidking.com/dev-docker-compose/</id>
    <published>2019-11-03T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-Compose简介"><a href="#Docker-Compose简介" class="headerlink" title="Docker-Compose简介"></a>Docker-Compose简介</h1><p>Compose是用于定义和运行多容器Docker应用程序的工具。通过Compose，可以使用YAML文件来配置应用程序的服务。然后使用一个命令，就可以从配置中创建并启动所有服务。Compose可在所有环境中工作：生产、模拟、开发、测试以及CI工作流。</p><p>使用Compose基本上是三步流程：</p><ul><li>使用Dockerfile定义应用程序的环境，以便可以在任何地方复制它。</li><li>在docker-compose.yml中定义组成您的应用程序的服务，以便它们可以在隔离的环境中一起运行。</li><li>运行docker-compose up，然后Compose启动并运行整个应用程序。</li></ul><p>Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。</p><a id="more"></a><h1 id="安装Compose"><a href="#安装Compose" class="headerlink" title="安装Compose"></a>安装Compose</h1><p>在CentOS7机器上，假设已经了Docker，参考<a href="https://docs.docker.com/compose/install/" target="_blank" rel="noopener">Install Docker Compose</a>安装Compose-Docker。如果没有安装Docker，那么参考<a href="https://www.voidking.com/dev-docker-start/">Docker入门</a>进行安装。</p><p>1、安装docker-compose</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><p>2、添加执行权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose</span><br><span class="line">sudo ln -s <span class="regexp">/usr/</span>local<span class="regexp">/bin/</span>docker-compose <span class="regexp">/usr/</span>bin<span class="regexp">/docker-compose</span></span><br></pre></td></tr></table></figure><p>3、验证安装<br><code>docker-compose --version</code></p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>1、创建测试目录</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> composetest</span><br><span class="line"><span class="built_in">cd</span> composetest</span><br></pre></td></tr></table></figure><p>2、在项目目录中创建一个名为app.py的文件，内容为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span><span class="params">()</span>:</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br></pre></td></tr></table></figure><p>在此示例中，redis是应用程序网络上的redis容器的主机名，使用默认端口6379。</p><p>3、创建requirements.txt文件，内容为：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flask</span></span><br><span class="line"><span class="attribute">redis</span></span><br></pre></td></tr></table></figure><p>4、创建Dockerfile，内容为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span>-alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">ENV</span> FLASK_APP app.py</span><br><span class="line"><span class="keyword">ENV</span> FLASK_RUN_HOST <span class="number">0.0</span>.<span class="number">0.0</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk add --no-cache gcc musl-dev linux-headers</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> requirements.txt requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r requirements.txt</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"flask"</span>, <span class="string">"run"</span>]</span></span><br></pre></td></tr></table></figure><p>该文件说明：</p><ul><li>从Python 3.7映像开始构建映像。</li><li>将工作目录设置为/code。</li><li>设置flask命令使用的环境变量。</li><li>安装gcc，以便诸如MarkupSafe和SQLAlchemy之类的Python包可以编译加速。</li><li>复制requirements.txt并安装Python依赖项。</li><li>复制当前目录。</li><li>在项目到工作目录。</li><li>将容器的默认命令设置为flask run。</li></ul><p>有关如何编写Dockerfile的更多信息，参考<a href="https://docs.docker.com/engine/tutorials/dockerimages/#building-an-image-from-a-dockerfile" target="_blank" rel="noopener">Docker用户指南</a>和<a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile参考</a>。</p><p>5、创建docker-compose.yml，内容为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="symbol">services:</span></span><br><span class="line"><span class="symbol">  web:</span></span><br><span class="line"><span class="symbol">    build:</span> .</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="string">"15000:5000"</span></span><br><span class="line"><span class="symbol">  redis:</span></span><br><span class="line"><span class="symbol">    image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><p>该Compose文件定义了两个服务：Web和Redis。<br>Web服务从Dockerfile构建镜像，启动后容器在5000端口提供服务，然后将容器端口5000绑定到主机端口15000。</p><p>6、使用Compose构建和运行应用<br><code>docker-compose up</code></p><p>7、测试应用<br><code>curl http://127.0.0.1:15000</code></p><h1 id="Hello-World-2-0"><a href="#Hello-World-2-0" class="headerlink" title="Hello World 2.0"></a>Hello World 2.0</h1><p>1、编辑docker-compose.yml，挂载当前目录到/code</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">version:</span> <span class="string">'3'</span></span><br><span class="line"><span class="symbol">services:</span></span><br><span class="line"><span class="symbol">  web:</span></span><br><span class="line"><span class="symbol">    build:</span> .</span><br><span class="line"><span class="symbol">    ports:</span></span><br><span class="line">      - <span class="string">"5000:5000"</span></span><br><span class="line"><span class="symbol">    volumes:</span></span><br><span class="line">      - .:/code</span><br><span class="line"><span class="symbol">    environment:</span></span><br><span class="line"><span class="symbol">      FLASK_ENV:</span> development</span><br><span class="line"><span class="symbol">  redis:</span></span><br><span class="line"><span class="symbol">    image:</span> <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><p>2、运行应用<br><code>docker-compose up</code></p><p>3、修改app.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span><span class="params">()</span>:</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World 2.0! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br></pre></td></tr></table></figure><p>4、测试应用<br><code>curl http://127.0.0.1:15000</code></p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># 构建和运行应用</span></span><br><span class="line">docker-compose up</span><br><span class="line"></span><br><span class="line"><span class="meta"># 构建和后台运行应用</span></span><br><span class="line">docker-compose up -d</span><br><span class="line"></span><br><span class="line"><span class="meta"># 关闭应用</span></span><br><span class="line">docker-compose down</span><br><span class="line"></span><br><span class="line"><span class="meta"># 关闭应用，并删除Redis容器内数据</span></span><br><span class="line">docker-compose down --volumes</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看容器</span></span><br><span class="line">docker-compose ps</span><br><span class="line"></span><br><span class="line"><span class="meta"># 查看web服务的环境变量</span></span><br><span class="line">docker-compose run web env</span><br></pre></td></tr></table></figure><h1 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h1><p><a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">Overview of Docker Compose</a></p><p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html" target="_blank" rel="noopener">Docker 入门教程</a></p><p><a href="https://github.com/docker/compose" target="_blank" rel="noopener">docker/compose</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-Compose简介&quot;&gt;&lt;a href=&quot;#Docker-Compose简介&quot; class=&quot;headerlink&quot; title=&quot;Docker-Compose简介&quot;&gt;&lt;/a&gt;Docker-Compose简介&lt;/h1&gt;&lt;p&gt;Compose是用于定义和运行多容器Docker应用程序的工具。通过Compose，可以使用YAML文件来配置应用程序的服务。然后使用一个命令，就可以从配置中创建并启动所有服务。Compose可在所有环境中工作：生产、模拟、开发、测试以及CI工作流。&lt;/p&gt;
&lt;p&gt;使用Compose基本上是三步流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Dockerfile定义应用程序的环境，以便可以在任何地方复制它。&lt;/li&gt;
&lt;li&gt;在docker-compose.yml中定义组成您的应用程序的服务，以便它们可以在隔离的环境中一起运行。&lt;/li&gt;
&lt;li&gt;运行docker-compose up，然后Compose启动并运行整个应用程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Alpine修改时区</title>
    <link href="https://www.voidking.com/dev-alpine-timezone/"/>
    <id>https://www.voidking.com/dev-alpine-timezone/</id>
    <published>2019-11-03T14:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.043Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Alpine简介"><a href="#Alpine简介" class="headerlink" title="Alpine简介"></a>Alpine简介</h1><p><a href="https://www.alpinelinux.org/" target="_blank" rel="noopener">Alpine Linux</a>是基于musl libc和busybox的面向安全的轻量级Linux发行版。Alpine镜像113M，不稀奇，毕竟<a href="http://download.cirros-cloud.net/" target="_blank" rel="noopener">CirrOS</a>镜像只有12M。但是<a href="https://hub.docker.com/_/alpine/" target="_blank" rel="noopener">Alpine的Docker镜像</a>大小只有5M！而<a href="https://hub.docker.com/_/cirros" target="_blank" rel="noopener">CirrOS的Docker镜像</a>大小为10M。</p><p>Alpine由非商业组织维护的，支持广泛场景的Linux发行版，它特别为资深/重度Linux用户而优化，关注安全，性能和资源效能。Alpine 镜像可以适用于更多常用场景，并且是一个优秀的可以适用于生产的基础系统/环境。</p><p>第一次接触alpine，是使用它跑单测。gitlab设置代码提交后触发单测，而这个单测，可以使用alpine来进行。但是因为时区问题，跑出的单测结果和预期不同。因此，本文以修改Alpine时区为引子，简单学习了解一下Alpine。</p><a id="more"></a><h1 id="Alpine包管理"><a href="#Alpine包管理" class="headerlink" title="Alpine包管理"></a>Alpine包管理</h1><p>Alpine采用了 musl libc 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine还提供了自己的<a href="https://pkgs.alpinelinux.org/packages" target="_blank" rel="noopener">包管理工具apk</a>。更多参考<a href="https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management" target="_blank" rel="noopener">Alpine Linux package management</a>和<a href="https://wangchujiang.com/linux-command/c/apk.html" target="_blank" rel="noopener">Alpine Linux下的包管理工具</a>。</p><p>常用命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新最新本地镜像源</span></span><br><span class="line">apk update </span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级软件</span></span><br><span class="line">apk<span class="built_in"> upgrade </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定升级部分软件包</span></span><br><span class="line">apk <span class="builtin-name">add</span> --upgrade xxx </span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装包</span></span><br><span class="line">apk <span class="builtin-name">add</span> xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索包，支持正则</span></span><br><span class="line">apk search xxx</span><br><span class="line">apk search -v <span class="string">'xx*'</span></span><br><span class="line">apk search -v -d <span class="string">'xxx'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看包详细信息</span></span><br><span class="line">apk <span class="builtin-name">info</span> -a xxx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看包列表</span></span><br><span class="line">apk show</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载并删除包</span></span><br><span class="line">apk del xxx</span><br></pre></td></tr></table></figure><h1 id="修改时区"><a href="#修改时区" class="headerlink" title="修改时区"></a>修改时区</h1><p>Alpine修改时区，主要参考<a href="https://www.jianshu.com/p/cd1636c94f9f" target="_blank" rel="noopener">修改使用Alpine Linux的Docker容器的时区</a>。</p><p>1、下载镜像<br><code>docker pull alpine</code></p><p>2、启动镜像<br><code>docker run --name alpine_timezone -it alpine:latest /bin/sh</code></p><p>3、安装timezone</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apk <span class="keyword">add</span><span class="bash"> -U tzdata</span></span><br><span class="line">ls /usr/share/zoneinfo</span><br></pre></td></tr></table></figure><p>4、拷贝需要的时区文件到localtime<br><code>cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></p><p>5、验证时区<br><code>date</code></p><p>6、精简镜像<br><code>apk del tzdata</code></p><p>7、保存镜像</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br><span class="line">docker <span class="keyword">commit</span> alpine_timezone voidking/alpine:v1<span class="number">.0</span></span><br><span class="line">docker <span class="keyword">login</span></span><br><span class="line">docker push</span><br></pre></td></tr></table></figure><p>以上，完成了Alpine镜像时区的修改。此外，还有一种更简单的方法，在启动Alpine容器时映射宿主机的时区文件。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name alpine -it -d -v <span class="regexp">/etc/</span><span class="string">localtime:</span><span class="regexp">/etc/</span>localtime <span class="string">alpine:</span>lastest</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Alpine简介&quot;&gt;&lt;a href=&quot;#Alpine简介&quot; class=&quot;headerlink&quot; title=&quot;Alpine简介&quot;&gt;&lt;/a&gt;Alpine简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.alpinelinux.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alpine Linux&lt;/a&gt;是基于musl libc和busybox的面向安全的轻量级Linux发行版。Alpine镜像113M，不稀奇，毕竟&lt;a href=&quot;http://download.cirros-cloud.net/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CirrOS&lt;/a&gt;镜像只有12M。但是&lt;a href=&quot;https://hub.docker.com/_/alpine/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alpine的Docker镜像&lt;/a&gt;大小只有5M！而&lt;a href=&quot;https://hub.docker.com/_/cirros&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CirrOS的Docker镜像&lt;/a&gt;大小为10M。&lt;/p&gt;
&lt;p&gt;Alpine由非商业组织维护的，支持广泛场景的Linux发行版，它特别为资深/重度Linux用户而优化，关注安全，性能和资源效能。Alpine 镜像可以适用于更多常用场景，并且是一个优秀的可以适用于生产的基础系统/环境。&lt;/p&gt;
&lt;p&gt;第一次接触alpine，是使用它跑单测。gitlab设置代码提交后触发单测，而这个单测，可以使用alpine来进行。但是因为时区问题，跑出的单测结果和预期不同。因此，本文以修改Alpine时区为引子，简单学习了解一下Alpine。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>CentOS7部署beego项目</title>
    <link href="https://www.voidking.com/dev-centos7-beego-env/"/>
    <id>https://www.voidking.com/dev-centos7-beego-env/</id>
    <published>2019-11-02T20:00:00.000Z</published>
    <updated>2020-02-09T02:22:14.047Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-beego-start-0/">《beego入门篇——上、中、下》</a>三篇文章中，记录了beego的基本用法。假设已经完成了beego项目的代码，此时我们需要把项目部署到服务器上，本文就研究一下怎样在CentOS7环境里部署beego服务。</p><a id="more"></a><h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><p>安装golang，主要参考<a href="https://www.cnblogs.com/reboot777/p/10985731.html" target="_blank" rel="noopener">centos7安装golang环境</a>。</p><p>1、<a href="https://golang.org/dl/" target="_blank" rel="noopener">golang官网</a>查找安装包</p><p>2、安装golang<br><code>wget https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz</code></p><p>3、解压至/usr/local目录<br><code>tar -C /usr/local -xzf go1.12.7.linux-amd64.tar.gz</code></p><p>4、配置环境变量<br><code>vim /etc/profile</code>，添加：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOROOT</span>=/usr/local/go</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOPATH</span>=<span class="variable">$HOME</span>/go</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">PATH</span>=<span class="variable">$PATH</span>:$GOROOT/bin:$GOPATH/bin</span><br></pre></td></tr></table></figure><p><code>source /etc/profile</code>使修改生效。</p><p>5、查看安装</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="keyword">version</span></span><br><span class="line"><span class="keyword">go</span> env</span><br></pre></td></tr></table></figure><h2 id="beego安装"><a href="#beego安装" class="headerlink" title="beego安装"></a>beego安装</h2><p>1、安装beego<br><code>go get -v github.com/astaxie/beego</code></p><p>如果下载缓慢，可以设置GOPROXY。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">GOPROXY</span>=https://goproxy.io</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">GO111MODULE</span>=on</span><br></pre></td></tr></table></figure><p>2、安装bee工具<br><code>go get -v github.com/beego/bee</code></p><p>3、创建测试项目test<br><code>bee new test</code></p><p>4、运行项目</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="variable">$GOPATH</span>/src/<span class="keyword">test</span></span><br><span class="line">bee <span class="keyword">run</span></span><br></pre></td></tr></table></figure><p>5、访问项目<br><code>curl http://localhost:8080</code></p><h2 id="数据库依赖"><a href="#数据库依赖" class="headerlink" title="数据库依赖"></a>数据库依赖</h2><p>1、安装go-sqlite3</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> -v github.<span class="keyword">com</span>/mattn/<span class="keyword">go</span>-sqlite3</span><br></pre></td></tr></table></figure><h1 id="部署项目"><a href="#部署项目" class="headerlink" title="部署项目"></a>部署项目</h1><h2 id="测试项目"><a href="#测试项目" class="headerlink" title="测试项目"></a>测试项目</h2><p>1、下载vkbeego</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd <span class="variable">$GOPATH</span><span class="regexp">/src/</span></span><br><span class="line">git clone https:<span class="regexp">//gi</span>thub.com<span class="regexp">/voidking/</span>vkbeego.git</span><br></pre></td></tr></table></figure><p>2、运行项目</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd vkbeego</span><br><span class="line">bee <span class="keyword">run</span></span><br></pre></td></tr></table></figure><p>第一次运行后会在项目下生成db.sqlite3文件，里面是user表。如果已经有了db.sqlite3文件，则会进行校验。<br>或者使用<code>bee migrate</code>命令生成表结构，具体参考<a href="https://beego.me/docs/install/bee.md#bee-%E5%B7%A5%E5%85%B7%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener">bee 工具命令详解</a>。</p><p>3、访问项目<br><code>curl http://localhost:8080</code></p><p>其他机器如果无法访问，就先关闭防火墙。<br><code>systemctl stop firewalld</code></p><h2 id="编译部署"><a href="#编译部署" class="headerlink" title="编译部署"></a>编译部署</h2><p>1、编译命令<br><code>go build</code><br>项目下生成名为vkbeego的二进制文件。</p><p>2、运行项目<br><code>./vkbeego</code></p><p>3、后台运行<br><code>nohup ./vkbeego &gt; nohup.out 2&gt;&amp;1 &amp;</code></p><p>4、关闭<br><code>fg</code>，然后Ctrl+C。</p><p>以上，就在CentOS7上部署好了beego项目。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-beego-start-0/&quot;&gt;《beego入门篇——上、中、下》&lt;/a&gt;三篇文章中，记录了beego的基本用法。假设已经完成了beego项目的代码，此时我们需要把项目部署到服务器上，本文就研究一下怎样在CentOS7环境里部署beego服务。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="后端" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="centos" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/centos/"/>
    
      <category term="go" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E5%90%8E%E7%AB%AF/go/"/>
    
    
      <category term="golang" scheme="https://www.voidking.com/tags/golang/"/>
    
      <category term="beego" scheme="https://www.voidking.com/tags/beego/"/>
    
  </entry>
  
</feed>
