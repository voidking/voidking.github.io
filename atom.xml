<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好好学习的郝</title>
  
  <subtitle>一个计算机技术爱好者与学习者</subtitle>
  <link href="https://www.voidking.com/atom.xml" rel="self"/>
  
  <link href="https://www.voidking.com/"/>
  <updated>2025-10-01T08:00:00.000Z</updated>
  <id>https://www.voidking.com/</id>
  
  <author>
    <name>好好学习的郝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程辅助工具 Codex 入门篇</title>
    <link href="https://www.voidking.com/dev-codex-start/"/>
    <id>https://www.voidking.com/dev-codex-start/</id>
    <published>2025-10-01T08:00:00.000Z</published>
    <updated>2025-10-01T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Codex-简介"><span class="post-title-index">1. </span><a href="#Codex-简介" class="headerlink" title="Codex 简介"></a>Codex 简介</h2><p>Codex 是一个辅助编程的命令行工具，借助GPT系列模型提高编码的速度和质量。<br>Codex的安装配置方法和Claude Code很像（几乎一模一样），本文会对Codex的基础配置和用法进行说明，方便大家入手使用。</p><p>相关文档：</p><ul><li><a href="https://openai.com/codex/">Codex官网</a></li><li><a href="https://github.com/openai/codex">github - openai/codex</a></li></ul><span id="more"></span><h2 id="安装Codex"><span class="post-title-index">2. </span><a href="#安装Codex" class="headerlink" title="安装Codex"></a>安装Codex</h2><h3 id="安装node-js-18"><span class="post-title-index">2.1. </span><a href="#安装node-js-18" class="headerlink" title="安装node.js 18+"></a>安装node.js 18+</h3><ol><li><p>安装nvm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash</span><br></pre></td></tr></table></figure></li><li><p>安装node.js 20</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install v20.19.4</span><br><span class="line">nvm use v20.19.4</span><br><span class="line">nvm <span class="built_in">alias</span> default v20.19.4</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装Codex-1"><span class="post-title-index">2.2. </span><a href="#安装Codex-1" class="headerlink" title="安装Codex"></a>安装Codex</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @openai/codex</span><br></pre></td></tr></table></figure><h3 id="初始化Codex"><span class="post-title-index">2.3. </span><a href="#初始化Codex" class="headerlink" title="初始化Codex"></a>初始化Codex</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codex</span><br></pre></td></tr></table></figure><p>出现提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  Welcome to Codex, OpenAI&#x27;s command-line coding agent</span><br><span class="line"></span><br><span class="line">  Sign in with ChatGPT to use Codex as part of your paid plan</span><br><span class="line">  or connect an API key for usage-based billing</span><br><span class="line"></span><br><span class="line">&gt; 1. Sign in with ChatGPT</span><br><span class="line">     Usage included with Plus, Pro, and Team plans</span><br><span class="line"></span><br><span class="line">  2. Provide your own API key</span><br><span class="line">     Pay for what you use</span><br><span class="line"></span><br><span class="line">  Press Enter to continue</span><br></pre></td></tr></table></figure><p>这里不用再继续配置，直接 ctrl+C 退出。</p><h2 id="安装配置OpenAI-API代理"><span class="post-title-index">3. </span><a href="#安装配置OpenAI-API代理" class="headerlink" title="安装配置OpenAI API代理"></a>安装配置OpenAI API代理</h2><p>Codex依赖OpenAI API，但是因为国内无法访问OpenAI，所以我们需要一些访问OpenAI API的替代方案。<br>推荐使用<a href="https://github.com/QuantumNous/new-api">NewAPI</a>，它是<a href="https://github.com/songquanpeng/one-api">OneAPI</a>停止更新后的更强继承者。</p><h2 id="配置Codex"><span class="post-title-index">4. </span><a href="#配置Codex" class="headerlink" title="配置Codex"></a>配置Codex</h2><ol><li>创建codex配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.codex/config.toml</span><br></pre></td></tr></table></figure></li></ol><p>假设使用的Claude API代理是NewAPI，那么填入如下内容：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">model</span> = <span class="string">&quot;gpt-5&quot;</span></span><br><span class="line"><span class="attr">model_provider</span> = <span class="string">&quot;new-api&quot;</span></span><br><span class="line"><span class="attr">model_reasoning_effort</span> = <span class="string">&quot;medium&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[model_providers.new-api]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;New Api OpenAI&quot;</span></span><br><span class="line"><span class="attr">base_url</span> = <span class="string">&quot;https://newapi.voidking.com/v1&quot;</span></span><br><span class="line"><span class="attr">env_key</span> = <span class="string">&quot;NEW_OPENAI_API_KEY&quot;</span></span><br><span class="line"><span class="attr">wire_api</span> = <span class="string">&quot;chat&quot;</span></span><br></pre></td></tr></table></figure><p>特别注意的是不能将 api_key 作为字符串直接传递给 env_key。 env_key 必须指向环境变量。</p><ol start="2"><li>配置key环境变量<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export NEW_OPENAI_API_KEY=&quot;xxx&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"><span class="comment">#echo &#x27;export NEW_OPENAI_API_KEY=&quot;xxx&quot;&#x27; &gt;&gt; ~/.bash_profile</span></span><br><span class="line"><span class="comment">#source ~/.bash_profile</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="命令行使用Codex"><span class="post-title-index">5. </span><a href="#命令行使用Codex" class="headerlink" title="命令行使用Codex"></a>命令行使用Codex</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-project</span><br><span class="line">codex</span><br></pre></td></tr></table></figure><h2 id="VSCode-Cursor使用Codex"><span class="post-title-index">6. </span><a href="#VSCode-Cursor使用Codex" class="headerlink" title="VSCode/Cursor使用Codex"></a>VSCode/Cursor使用Codex</h2><ol><li><p>安装插件 <code>Codex – OpenAI’s coding agent</code><br>插件安装完成，VSCode右上角会出现OpenAI图标</p></li><li><p>点击VSCode右上角会OpenAI图标，启动Codex<br>首次启动会比较慢（半分钟左右），请耐心等待。</p></li><li><p>输入需求，辅助编程</p></li></ol><h2 id="Codex基础用法"><span class="post-title-index">7. </span><a href="#Codex基础用法" class="headerlink" title="Codex基础用法"></a>Codex基础用法</h2><p>参考文档：</p><ul><li><a href="https://github.com/Ivesfsy/Codex">Codex CLI 快速入门指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/1952169109400842799">Codex &amp; Codex CLI 国内使用教程，手把手教你如何支付、安装 Codex！</a></li><li><a href="https://www.cnblogs.com/javastack/p/19113665">再见 Claude Code！玩转 CodeX CLI 的 16 个实用小技巧，效率拉满！！</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Codex-简介&quot;&gt;&lt;a href=&quot;#Codex-简介&quot; class=&quot;headerlink&quot; title=&quot;Codex 简介&quot;&gt;&lt;/a&gt;Codex 简介&lt;/h2&gt;&lt;p&gt;Codex 是一个辅助编程的命令行工具，借助GPT系列模型提高编码的速度和质量。&lt;br&gt;Codex的安装配置方法和Claude Code很像（几乎一模一样），本文会对Codex的基础配置和用法进行说明，方便大家入手使用。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://openai.com/codex/&quot;&gt;Codex官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/openai/codex&quot;&gt;github - openai/codex&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="golang" scheme="https://www.voidking.com/categories/engineering/golang/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="golang" scheme="https://www.voidking.com/tags/golang/"/>
    
    <category term="aigc" scheme="https://www.voidking.com/tags/aigc/"/>
    
    <category term="llm" scheme="https://www.voidking.com/tags/llm/"/>
    
    <category term="vscode" scheme="https://www.voidking.com/tags/vscode/"/>
    
    <category term="编辑器" scheme="https://www.voidking.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="java" scheme="https://www.voidking.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>编程辅助工具 Claude Code 入门篇</title>
    <link href="https://www.voidking.com/dev-claude-code-start/"/>
    <id>https://www.voidking.com/dev-claude-code-start/</id>
    <published>2025-08-23T08:00:00.000Z</published>
    <updated>2025-08-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Claude-Code-简介"><span class="post-title-index">1. </span><a href="#Claude-Code-简介" class="headerlink" title="Claude Code 简介"></a>Claude Code 简介</h2><p>Claude Code 是一个辅助编程的命令行工具，借助Claude模型提高编码的速度和质量。<br>当前 Claude Code 风评远高于 Cursor。本文会对Claude Code的基础配置和用法进行说明，方便大家入手使用。</p><p>相关文档：</p><ul><li><a href="https://www.anthropic.com/claude-code">Claude Code官网</a></li><li><a href="https://docs.anthropic.com/en/docs/claude-code/overview">Claude Code文档</a></li><li><a href="https://www.bilibili.com/video/BV1VkMTzjEhy">用了 ClaudeCode 开发后，我再也不想碰 Cursor 了</a></li></ul><span id="more"></span><h2 id="安装Claude-Code"><span class="post-title-index">2. </span><a href="#安装Claude-Code" class="headerlink" title="安装Claude Code"></a>安装Claude Code</h2><h3 id="安装node-js-18"><span class="post-title-index">2.1. </span><a href="#安装node-js-18" class="headerlink" title="安装node.js 18+"></a>安装node.js 18+</h3><ol><li><p>安装nvm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.3/install.sh | bash</span><br></pre></td></tr></table></figure></li><li><p>安装node.js 20</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm install v20.19.4</span><br><span class="line">nvm use v20.19.4</span><br><span class="line">nvm <span class="built_in">alias</span> default v20.19.4</span><br></pre></td></tr></table></figure></li></ol><h3 id="安装Claude-Code-1"><span class="post-title-index">2.2. </span><a href="#安装Claude-Code-1" class="headerlink" title="安装Claude Code"></a>安装Claude Code</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @anthropic-ai/claude-code</span><br></pre></td></tr></table></figure><h3 id="初始化Claude-Code"><span class="post-title-index">2.3. </span><a href="#初始化Claude-Code" class="headerlink" title="初始化Claude Code"></a>初始化Claude Code</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-project</span><br><span class="line">claude</span><br></pre></td></tr></table></figure><p>这里不用再继续配置，直接 ctrl+C 退出。</p><h2 id="安装配置Claude-API代理"><span class="post-title-index">3. </span><a href="#安装配置Claude-API代理" class="headerlink" title="安装配置Claude API代理"></a>安装配置Claude API代理</h2><p>Claude Code依赖Claude API，但是因为国内无法访问 Claude，所以我们需要一些访问Claude API的替代方案。</p><ul><li>方案一：<a href="https://github.com/songquanpeng/one-api">OneAPI</a> + <a href="https://github.com/BerriAI/litellm">litellm</a></li><li>方案二：<a href="https://github.com/QuantumNous/new-api">NewAPI</a></li><li>方案三：<a href="https://github.com/Wei-Shaw/claude-relay-service">claude-relay-service</a></li></ul><h2 id="配置Claude-Code"><span class="post-title-index">4. </span><a href="#配置Claude-Code" class="headerlink" title="配置Claude Code"></a>配置Claude Code</h2><p>创建claude code配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.claude/settings.json</span><br></pre></td></tr></table></figure><p>假设使用的Claude API代理是NewAPI，那么填入如下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ANTHROPIC_BASE_URL&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://newapi.voidking.com&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ANTHROPIC_AUTH_TOKEN&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sk-xxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ANTHROPIC_MODEL&quot;</span><span class="punctuation">:</span> <span class="string">&quot;claude-sonnet-4-20250514&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="命令行使用Claude-Code"><span class="post-title-index">5. </span><a href="#命令行使用Claude-Code" class="headerlink" title="命令行使用Claude Code"></a>命令行使用Claude Code</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-project</span><br><span class="line">claude</span><br></pre></td></tr></table></figure><h2 id="VSCode-Cursor使用Claude-Code"><span class="post-title-index">6. </span><a href="#VSCode-Cursor使用Claude-Code" class="headerlink" title="VSCode/Cursor使用Claude Code"></a>VSCode/Cursor使用Claude Code</h2><ol><li><p>安装插件 Claude Code for VSCode<br>插件安装完成，VSCode右上角会出现claude图标</p></li><li><p>点击VSCode右上角会claude图标，启动claude code</p></li><li><p>输入需求，辅助编程</p></li></ol><h2 id="Claude-Code基础用法"><span class="post-title-index">7. </span><a href="#Claude-Code基础用法" class="headerlink" title="Claude Code基础用法"></a>Claude Code基础用法</h2><p>参考文档：</p><ul><li><a href="https://blog.axiaoxin.com/post/claude-code-full-guide/">Claude Code完全指南：使用教程详解，看这一篇就够了！</a></li><li><a href="https://blog.axiaoxin.com/post/claude-code-usages/">Claude Code 实用教程——使用方法详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/1920263182062163086">最强Coding Agent: Claude Code权威实践指南</a></li><li><a href="https://zhuanlan.zhihu.com/p/1928918331810886674">Claude Code 用法全面拆解！26 项核心功能 + 实战技巧</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Claude-Code-简介&quot;&gt;&lt;a href=&quot;#Claude-Code-简介&quot; class=&quot;headerlink&quot; title=&quot;Claude Code 简介&quot;&gt;&lt;/a&gt;Claude Code 简介&lt;/h2&gt;&lt;p&gt;Claude Code 是一个辅助编程的命令行工具，借助Claude模型提高编码的速度和质量。&lt;br&gt;当前 Claude Code 风评远高于 Cursor。本文会对Claude Code的基础配置和用法进行说明，方便大家入手使用。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.anthropic.com/claude-code&quot;&gt;Claude Code官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.anthropic.com/en/docs/claude-code/overview&quot;&gt;Claude Code文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1VkMTzjEhy&quot;&gt;用了 ClaudeCode 开发后，我再也不想碰 Cursor 了&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="golang" scheme="https://www.voidking.com/categories/engineering/golang/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="golang" scheme="https://www.voidking.com/tags/golang/"/>
    
    <category term="aigc" scheme="https://www.voidking.com/tags/aigc/"/>
    
    <category term="llm" scheme="https://www.voidking.com/tags/llm/"/>
    
    <category term="vscode" scheme="https://www.voidking.com/tags/vscode/"/>
    
    <category term="编辑器" scheme="https://www.voidking.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="java" scheme="https://www.voidking.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Claude API 中转服务 Claude Relay Service</title>
    <link href="https://www.voidking.com/dev-claude-relay/"/>
    <id>https://www.voidking.com/dev-claude-relay/</id>
    <published>2025-08-23T08:00:00.000Z</published>
    <updated>2025-08-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Claude-Relay-Service简介"><span class="post-title-index">1. </span><a href="#Claude-Relay-Service简介" class="headerlink" title="Claude Relay Service简介"></a>Claude Relay Service简介</h2><p>Claude Relay Service 是一个 Claude API中转服务，支持多账户管理。<br>试用场景：</p><ul><li>找朋友拼车: 三五好友一起分摊Claude Code Max订阅，Opus爽用</li><li>隐私敏感: 不想让第三方镜像看到你的对话内容</li><li>技术折腾: 有基本的技术基础，愿意自己搭建和维护</li><li>稳定需求: 需要长期稳定的Claude访问，不想受制于镜像站</li><li>地区受限: 无法直接访问Claude官方服务</li></ul><p>相关文档：</p><ul><li><a href="https://github.com/Wei-Shaw/claude-relay-service">github - Wei-Shaw/claude-relay-service</a></li></ul><span id="more"></span><h2 id="部署Claude-Relay-Service"><span class="post-title-index">2. </span><a href="#部署Claude-Relay-Service" class="headerlink" title="部署Claude Relay Service"></a>部署Claude Relay Service</h2><p>Claude Relay Service 提供了多种部署方式，包括脚本部署、手动部署、Docker部署等，本文中选择Docker部署方式。</p><p>前置条件：安装配置好Docker和Docker Compose。</p><p>1、准备项目目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /data/claude-relay</span><br><span class="line"><span class="built_in">cd</span> /data/claude-relay</span><br></pre></td></tr></table></figure><p>2、创建 docker-compose 配置文件 <code>docker-compose.yml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.8&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">claude-relay:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">weishaw/claude-relay-service:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">claude-relay-service</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3000:3000&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">JWT_SECRET=$&#123;JWT_SECRET&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ENCRYPTION_KEY=$&#123;ENCRYPTION_KEY&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">REDIS_HOST=redis</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADMIN_USERNAME=$&#123;ADMIN_USERNAME:-&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">ADMIN_PASSWORD=$&#123;ADMIN_PASSWORD:-&#125;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./logs:/app/logs</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data:/app/data</span></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis:7-alpine</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">claude-relay-redis</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redis_data:/data</span></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span></span><br><span class="line">  <span class="attr">redis_data:</span></span><br></pre></td></tr></table></figure><p>3、创建配置文件 <code>.env</code><br>内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 必填：安全密钥（请修改为随机值）</span><br><span class="line">JWT_SECRET=your-random-secret-key-at-least-32-chars</span><br><span class="line">ENCRYPTION_KEY=your-32-character-encryption-key</span><br><span class="line"></span><br><span class="line"># 可选：管理员凭据</span><br><span class="line">ADMIN_USERNAME=cr_admin</span><br><span class="line">ADMIN_PASSWORD=your-secure-password</span><br></pre></td></tr></table></figure><p>4、拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose pull</span><br></pre></td></tr></table></figure><p>5、启动claude-relay</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>6、查看claude-relay状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br><span class="line">docker logs -f claude-relay-service</span><br></pre></td></tr></table></figure><h2 id="配置域名（可选）"><span class="post-title-index">3. </span><a href="#配置域名（可选）" class="headerlink" title="配置域名（可选）"></a>配置域名（可选）</h2><p>1、配置DNS域名解析</p><p>2、配置Nginx</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name cc.voidking.com;</span><br><span class="line">    charset utf-8;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        client_body_timeout 3600s;</span><br><span class="line">        keepalive_timeout 3600s;</span><br><span class="line">        client_max_body_size  64m;</span><br><span class="line">        proxy_http_version 1.1;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        proxy_cache_bypass $http_upgrade;</span><br><span class="line">        proxy_set_header Accept-Encoding gzip;</span><br><span class="line">        proxy_read_timeout 3600s;  </span><br><span class="line"></span><br><span class="line">        proxy_pass http://127.0.0.1:3000;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="购买claude-code账号"><span class="post-title-index">4. </span><a href="#购买claude-code账号" class="headerlink" title="购买claude code账号"></a>购买claude code账号</h2><p>1、访问claude code<br><a href="https://www.anthropic.com/claude-code">https://www.anthropic.com/claude-code</a></p><p>2、采购max 200刀的套餐</p><p>3、获取到key</p><h2 id="配置Claude-Relay-Service"><span class="post-title-index">5. </span><a href="#配置Claude-Relay-Service" class="headerlink" title="配置Claude Relay Service"></a>配置Claude Relay Service</h2><h3 id="登录Claude-Relay-Service"><span class="post-title-index">5.1. </span><a href="#登录Claude-Relay-Service" class="headerlink" title="登录Claude Relay Service"></a>登录Claude Relay Service</h3><p>浏览器访问 claude relay service，<code>http://你的服务器IP:3000/web</code><br>点击页面右上角“管理后台”，输入安装时配置的管理员账密登录。</p><h3 id="配置Claude账户"><span class="post-title-index">5.2. </span><a href="#配置Claude账户" class="headerlink" title="配置Claude账户"></a>配置Claude账户</h3><p>1、点击账户管理，添加账户</p><p>2、账户配置</p><ul><li>平台选择 Claude</li><li>添加方式选择 Setup Token</li><li>账户名称 随意</li><li>其他配置项保持默认</li></ul><p>3、配置授权<br>（1）下一步，进入授权配置页面<br>（2）点击 生成授权链接，会打开一个新页面，在新页面完成Claude登录和授权<br>（3）复制返回的Authorization Code，粘贴到页面完成添加</p><h3 id="创建API-Key"><span class="post-title-index">5.3. </span><a href="#创建API-Key" class="headerlink" title="创建API Key"></a>创建API Key</h3><p>给每个使用者分配一个Key：</p><p>1、点击 API Keys</p><p>2、点击 创建新Key</p><p>3、给Key起个名字，比如「张三的Key」</p><p>4、设置使用限制（可选）</p><ul><li>速率限制: 限制每个时间窗口的请求次数和Token使用量</li><li>并发限制: 限制同时处理的请求数</li><li>模型限制: 限制可访问的模型列表</li><li>客户端限制: 限制只允许特定客户端使用（如ClaudeCode、Gemini-CLI等）</li></ul><p>5、保存，记下生成的Key</p><h2 id="Claude-Code-使用-Claude-Relay-Service"><span class="post-title-index">6. </span><a href="#Claude-Code-使用-Claude-Relay-Service" class="headerlink" title="Claude Code 使用 Claude Relay Service"></a>Claude Code 使用 Claude Relay Service</h2><p>Claude Code 设置环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ANTHROPIC_BASE_URL=<span class="string">&quot;http://127.0.0.1:3000/api/&quot;</span> <span class="comment"># 根据实际填写你服务器的ip地址或者域名</span></span><br><span class="line"><span class="built_in">export</span> ANTHROPIC_AUTH_TOKEN=<span class="string">&quot;后台创建的API密钥&quot;</span></span><br></pre></td></tr></table></figure><p>或者修改 Claude Code 配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.claude/settings.json</span><br></pre></td></tr></table></figure><p>填入如下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;env&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;ANTHROPIC_BASE_URL&quot;</span><span class="punctuation">:</span> <span class="string">&quot;http://127.0.0.1:3000/api/&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ANTHROPIC_AUTH_TOKEN&quot;</span><span class="punctuation">:</span> <span class="string">&quot;后台创建的API密钥&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;ANTHROPIC_MODEL&quot;</span><span class="punctuation">:</span> <span class="string">&quot;claude-sonnet-4-20250514&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Claude-Relay-Service简介&quot;&gt;&lt;a href=&quot;#Claude-Relay-Service简介&quot; class=&quot;headerlink&quot; title=&quot;Claude Relay Service简介&quot;&gt;&lt;/a&gt;Claude Relay Service简介&lt;/h2&gt;&lt;p&gt;Claude Relay Service 是一个 Claude API中转服务，支持多账户管理。&lt;br&gt;试用场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;找朋友拼车: 三五好友一起分摊Claude Code Max订阅，Opus爽用&lt;/li&gt;
&lt;li&gt;隐私敏感: 不想让第三方镜像看到你的对话内容&lt;/li&gt;
&lt;li&gt;技术折腾: 有基本的技术基础，愿意自己搭建和维护&lt;/li&gt;
&lt;li&gt;稳定需求: 需要长期稳定的Claude访问，不想受制于镜像站&lt;/li&gt;
&lt;li&gt;地区受限: 无法直接访问Claude官方服务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Wei-Shaw/claude-relay-service&quot;&gt;github - Wei-Shaw/claude-relay-service&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
    <category term="aigc" scheme="https://www.voidking.com/tags/aigc/"/>
    
    <category term="llm" scheme="https://www.voidking.com/tags/llm/"/>
    
    <category term="newapi" scheme="https://www.voidking.com/tags/newapi/"/>
    
  </entry>
  
  <entry>
    <title>LLM 接口管理和分发系统 New API</title>
    <link href="https://www.voidking.com/dev-newapi-start/"/>
    <id>https://www.voidking.com/dev-newapi-start/</id>
    <published>2025-08-23T08:00:00.000Z</published>
    <updated>2025-08-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="New-API简介"><span class="post-title-index">1. </span><a href="#New-API简介" class="headerlink" title="New API简介"></a>New API简介</h1><p>New API是一个LLM代理系统，支持LLM接口管理和消息分发。使得用户可以通过标准的 OpenAI API 格式访问所有的大模型，开箱即用。</p><p>New API是在<a href="https://github.com/songquanpeng/one-api">One API</a>基础上二次开发的项目，因为 One API 已经不再维护，所以更推荐使用 New API。</p><p>相关文档：</p><ul><li><a href="https://github.com/QuantumNous/new-api">github - QuantumNous/new-api</a></li></ul><span id="more"></span><h1 id="New-API核心功能"><span class="post-title-index">2. </span><a href="#New-API核心功能" class="headerlink" title="New API核心功能"></a>New API核心功能</h1><p>One API具备的功能，New API都有，并且比One API支持更多大模型、界面更友好。</p><p>New API核心功能如下：</p><ul><li>支持多种大模型：OpenAI、Claude、Gemini、Mistral、豆包、文心一言、通义千问、腾讯混元、SiliconCloud等等等等。</li><li>支持 stream 模式，可以通过流式传输实现打字机效果</li><li>支持绘图接口</li><li>支持失败自动重试</li><li>支持多机部署，提高并发</li><li>支持渠道管理，批量创建渠道，支持渠道设置模型列表，支持通过负载均衡访问多个渠道</li><li>支持多用户管理，支持用户额度配置，支持充值，支持用户分组以及渠道分组，支持为不同分组设置不同的倍率</li><li>支持令牌管理，设置令牌的过期时间、额度、允许的 IP 范围以及允许的模型访问</li></ul><h1 id="安装配置-New-API"><span class="post-title-index">3. </span><a href="#安装配置-New-API" class="headerlink" title="安装配置 New API"></a>安装配置 New API</h1><h2 id="安装配置-New-API-概述"><span class="post-title-index">3.1. </span><a href="#安装配置-New-API-概述" class="headerlink" title="安装配置 New API 概述"></a>安装配置 New API 概述</h2><p>New API 提供了多种安装部署方式，推荐Docker部署或者Docker Compose部署。<br>本文中选择使用Docker部署，数据库选择MySQL，不使用Redis。</p><h2 id="安装MySQL（可选）"><span class="post-title-index">3.2. </span><a href="#安装MySQL（可选）" class="headerlink" title="安装MySQL（可选）"></a>安装MySQL（可选）</h2><p>1、安装MySQL8，参考文档<a href="https://www.voidking.com/dev-docker-mysql/">好好学MySQL：使用Docker安装配置MySQL</a></p><p>2、创建一个数据库，名称为 newapi</p><h2 id="安装-New-API"><span class="post-title-index">3.3. </span><a href="#安装-New-API" class="headerlink" title="安装 New API"></a>安装 New API</h2><p>1、下载 new-api 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull calciumion/new-api:v0.9.0-alpha.16</span><br></pre></td></tr></table></figure><p>2、运行 new-api 容器<br>使用SQLite数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name new-api -d \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 3000:3000 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -v /opt/data/new-api:/data \</span><br><span class="line">  calciumion/new-api:v0.9.0-alpha.16</span><br></pre></td></tr></table></figure><p>使用MySQL数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name new-api -d \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 3000:3000 \</span><br><span class="line">  -e SQL_DSN=<span class="string">&quot;root:123456@tcp(localhost:3306)/newapi&quot;</span> \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -v /opt/data/new-api:/data \</span><br><span class="line">  calciumion/calciumion/new-api:v0.9.0-alpha.16</span><br></pre></td></tr></table></figure><p>其中，SQL_DSN的值要改成自己的MySQL配置。</p><p>3、查看容器状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep new-api</span><br><span class="line">docker logs new-api</span><br></pre></td></tr></table></figure><h2 id="配置Nginx"><span class="post-title-index">3.4. </span><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>参考配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  server_name newapi.voidking.com;  # 请根据实际情况修改你的域名</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    client_max_body_size  64m;</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_pass http://localhost:3000;  # 请根据实际情况修改你的端口</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">    proxy_cache_bypass $http_upgrade;</span><br><span class="line">    proxy_set_header Accept-Encoding gzip;</span><br><span class="line">    proxy_read_timeout 300s;  # GPT-4 需要较长的超时时间，请自行调整</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-New-API"><span class="post-title-index">4. </span><a href="#使用-New-API" class="headerlink" title="使用 New API"></a>使用 New API</h1><h2 id="登录-New-API"><span class="post-title-index">4.1. </span><a href="#登录-New-API" class="headerlink" title="登录 New API"></a>登录 New API</h2><p>使用 <code>IP+端口</code> 或者 <code>域名</code> 访问 New API 首页</p><p>首次访问时，会自动引导到初始化页面。按照页面指引手动设置管理员账号和密码（仅首次安装需要），完成后即可使用新设置的管理员账号登录系统。</p><h2 id="配置与使用"><span class="post-title-index">4.2. </span><a href="#配置与使用" class="headerlink" title="配置与使用"></a>配置与使用</h2><p>因为New API基于One API二次开发，核心功能基本相同，所以配置和使用方法可以参考<a href="https://www.voidking.com/dev-one-api-start/">《LLM 接口管理和分发系统 One API》</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;New-API简介&quot;&gt;&lt;a href=&quot;#New-API简介&quot; class=&quot;headerlink&quot; title=&quot;New API简介&quot;&gt;&lt;/a&gt;New API简介&lt;/h1&gt;&lt;p&gt;New API是一个LLM代理系统，支持LLM接口管理和消息分发。使得用户可以通过标准的 OpenAI API 格式访问所有的大模型，开箱即用。&lt;/p&gt;
&lt;p&gt;New API是在&lt;a href=&quot;https://github.com/songquanpeng/one-api&quot;&gt;One API&lt;/a&gt;基础上二次开发的项目，因为 One API 已经不再维护，所以更推荐使用 New API。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/QuantumNous/new-api&quot;&gt;github - QuantumNous/new-api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
    <category term="aigc" scheme="https://www.voidking.com/tags/aigc/"/>
    
    <category term="llm" scheme="https://www.voidking.com/tags/llm/"/>
    
    <category term="newapi" scheme="https://www.voidking.com/tags/newapi/"/>
    
  </entry>
  
  <entry>
    <title>好好学Git：Git Submodule详解</title>
    <link href="https://www.voidking.com/dev-git-submodule/"/>
    <id>https://www.voidking.com/dev-git-submodule/</id>
    <published>2025-06-01T08:00:00.000Z</published>
    <updated>2025-06-01T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Git-Submodule？"><span class="post-title-index">1. </span><a href="#什么是Git-Submodule？" class="headerlink" title="什么是Git Submodule？"></a>什么是Git Submodule？</h2><p>Git Submodule（子模块）是Git版本控制系统中的一个功能，它允许我们将一个Git仓库作为另一个Git仓库的子目录。这在我们需要将一个项目作为另一个项目的依赖项，同时又希望保持它们作为独立项目时非常有用。</p><p>子模块的主要特点包括：</p><ul><li>保持子项目的独立版本控制</li><li>允许主项目和子项目独立开发</li><li>可以跟踪子项目的特定提交，而不是分支</li></ul><span id="more"></span><h2 id="使用场景"><span class="post-title-index">2. </span><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>Git Submodule通常适用于以下场景：</p><ul><li>项目依赖第三方库，且需要对该库进行定制修改</li><li>大型项目被拆分为多个独立部分，由不同团队维护</li><li>需要在多个项目中共享通用组件或库</li><li>需要精确控制依赖项的版本</li></ul><h2 id="基本操作"><span class="post-title-index">3. </span><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="添加子模块"><span class="post-title-index">3.1. </span><a href="#添加子模块" class="headerlink" title="添加子模块"></a>添加子模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add &lt;repository_url&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/example/lib.git libs/external</span><br></pre></td></tr></table></figure><p>这会在当前仓库中添加一个名为<code>libs/external</code>的子模块，指向指定的仓库。</p><h3 id="克隆包含子模块的项目"><span class="post-title-index">3.2. </span><a href="#克隆包含子模块的项目" class="headerlink" title="克隆包含子模块的项目"></a>克隆包含子模块的项目</h3><p>当克隆一个包含子模块的项目时，子模块的目录会是空的。我们需要执行以下命令来初始化和更新子模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> &lt;repository_url&gt;</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br></pre></td></tr></table></figure><p>或者使用组合命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules &lt;repository_url&gt;</span><br></pre></td></tr></table></figure><h3 id="更新子模块"><span class="post-title-index">3.3. </span><a href="#更新子模块" class="headerlink" title="更新子模块"></a>更新子模块</h3><p>要更新子模块到其远程仓库的最新提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule update --remote</span><br></pre></td></tr></table></figure><h3 id="提交子模块变更"><span class="post-title-index">3.4. </span><a href="#提交子模块变更" class="headerlink" title="提交子模块变更"></a>提交子模块变更</h3><p>如果我们在子模块中做了修改并提交，需要在父仓库中记录这些变更：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> submodule_directory</span><br><span class="line">git commit -am <span class="string">&quot;Update submodule&quot;</span></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line">git add submodule_directory</span><br><span class="line">git commit -m <span class="string">&quot;Update submodule reference&quot;</span></span><br></pre></td></tr></table></figure><h2 id="高级用法"><span class="post-title-index">4. </span><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="遍历所有子模块"><span class="post-title-index">4.1. </span><a href="#遍历所有子模块" class="headerlink" title="遍历所有子模块"></a>遍历所有子模块</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach <span class="string">&#x27;&lt;command&gt;&#x27;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule foreach <span class="string">&#x27;git checkout main&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="查看子模块状态"><span class="post-title-index">4.2. </span><a href="#查看子模块状态" class="headerlink" title="查看子模块状态"></a>查看子模块状态</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule status</span><br></pre></td></tr></table></figure><h3 id="删除子模块"><span class="post-title-index">4.3. </span><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h3><p>删除子模块需要几个步骤：</p><ol><li><p>删除子模块目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached &lt;submodule_path&gt;</span><br><span class="line"><span class="built_in">rm</span> -rf &lt;submodule_path&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除.gitmodules文件中的相关部分</p></li><li><p>删除.git/config中的相关配置</p></li><li><p>提交这些变更</p></li></ol><h2 id="注意事项"><span class="post-title-index">5. </span><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li><strong>权限问题</strong>：确保我们对子模块仓库有适当的访问权限</li><li><strong>递归子模块</strong>：一些项目可能有嵌套的子模块，使用<code>--recursive</code>选项可以处理这种情况</li><li><strong>分支管理</strong>：子模块默认不跟踪分支，而是指向特定提交。要跟踪分支，需要在子模块目录中显式检出分支</li><li><strong>协作问题</strong>：团队成员需要知道如何初始化和更新子模块</li><li><strong>路径问题</strong>：移动包含子模块的项目时要小心，可能需要更新相关路径</li></ol><h2 id="替代方案"><span class="post-title-index">6. </span><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p>虽然子模块很有用，但在某些情况下，我们可能需要考虑其他方案：</p><ol><li><strong>Git Subtree</strong>：将外部项目合并到主项目中，作为普通目录</li><li><strong>包管理器</strong>：如npm、pip等语言特定的依赖管理工具</li><li><strong>Monorepo</strong>：将所有相关项目放在一个大的仓库中</li></ol><h2 id="最佳实践"><span class="post-title-index">7. </span><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><ol><li>为子模块使用明确的版本（提交哈希）</li><li>在文档中记录子模块的使用方法</li><li>定期更新子模块以获取安全修复和新功能</li><li>考虑使用<code>.gitmodules</code>文件来配置子模块的默认分支</li><li>在CI/CD流程中加入子模块初始化步骤</li></ol><h2 id="总结"><span class="post-title-index">8. </span><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Git Submodule是一个强大的工具，可以帮助我们管理项目依赖关系，同时保持各个组件的独立性，可以极大地提高多项目协作的效率。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是Git-Submodule？&quot;&gt;&lt;a href=&quot;#什么是Git-Submodule？&quot; class=&quot;headerlink&quot; title=&quot;什么是Git Submodule？&quot;&gt;&lt;/a&gt;什么是Git Submodule？&lt;/h2&gt;&lt;p&gt;Git Submodule（子模块）是Git版本控制系统中的一个功能，它允许我们将一个Git仓库作为另一个Git仓库的子目录。这在我们需要将一个项目作为另一个项目的依赖项，同时又希望保持它们作为独立项目时非常有用。&lt;/p&gt;
&lt;p&gt;子模块的主要特点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保持子项目的独立版本控制&lt;/li&gt;
&lt;li&gt;允许主项目和子项目独立开发&lt;/li&gt;
&lt;li&gt;可以跟踪子项目的特定提交，而不是分支&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="好好学Git" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Git/"/>
    
  </entry>
  
  <entry>
    <title>编程辅助工具Cursor入门篇</title>
    <link href="https://www.voidking.com/dev-cursor-start/"/>
    <id>https://www.voidking.com/dev-cursor-start/</id>
    <published>2025-05-10T08:00:00.000Z</published>
    <updated>2025-06-01T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Cursor简介"><span class="post-title-index">1. </span><a href="#Cursor简介" class="headerlink" title="Cursor简介"></a>Cursor简介</h2><p>Cursor 是一款AI代码编辑器（IDE），目标是借助AI提高编码的速度和质量。</p><p>相关文档：</p><ul><li><a href="https://www.cursor.com/cn">Cursor官网</a></li><li><a href="https://docs.cursor.com/get-started/introduction">Cursor官方文档</a></li><li><a href="https://docs.cursor.com/guides/migration/vscode">Migration from VS Code</a></li><li><a href="https://www.voidking.com/dev-vscode-shortcut-and-config/">《VSCode常用快捷键和配置》</a></li></ul><span id="more"></span><h2 id="Cursor基础知识"><span class="post-title-index">2. </span><a href="#Cursor基础知识" class="headerlink" title="Cursor基础知识"></a>Cursor基础知识</h2><h3 id="Cursor与VSCode"><span class="post-title-index">2.1. </span><a href="#Cursor与VSCode" class="headerlink" title="Cursor与VSCode"></a>Cursor与VSCode</h3><p>Cursor 是基于 VSCode 构建的编辑器，包含 VSCode 的全部功能。<br>对于习惯使用 VSCode 的开发者，从 VSCode 迁移到 Cursor，几乎没有什么成本。</p><p>VSCode的活动栏默认是垂直的，Cursor 的活动栏是水平的，这是为了使AI聊天界面空间更大。<br>如果想要和VSCode一样使用垂直的活动栏，那么可以在 settings.json 中添加配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;workbench.activityBar.orientation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vertical&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="Cursor核心功能"><span class="post-title-index">2.2. </span><a href="#Cursor核心功能" class="headerlink" title="Cursor核心功能"></a>Cursor核心功能</h3><p>Cursor的核心功能包括：</p><ul><li>代码补全：理解代码库并提供基于上下文的代码补全建议</li><li>部分代码编辑：选中部分代码，让大模型按照需求在文件级别小范围增删改代码</li><li>聊天编程：在统一的AI对话界面，通过聊天让大模型在仓库级别增删改代码</li></ul><h2 id="聊天模式"><span class="post-title-index">3. </span><a href="#聊天模式" class="headerlink" title="聊天模式"></a>聊天模式</h2><p>AI对话界面提供了三种聊天模式：Agent、Ask和Manual</p><ul><li>Agent：允许Cursor自主学习代码库，并代表用户进行代码库范围的更改</li><li>Ask：获取有关代码库的解释和答案，并使用AI规划功能</li><li>Manual：仅使用用户提供的上下文进行有针对性的编辑</li></ul><h2 id="上下文说明"><span class="post-title-index">4. </span><a href="#上下文说明" class="headerlink" title="上下文说明"></a>上下文说明</h2><p>AI对话界面可以自行选择上下文：</p><ul><li>@Files：引用整个文件作为上下文。支持文件路径预览和分块处理。适用于需要引用特定文件内容时，如代码文件、文档等。</li><li>@Folders：引用整个文件夹作为上下文。适用于需要提供大量文件作为上下文，例如项目目录。</li><li>@Code：引用特定代码片段作为上下文。适用于需要针对特定代码片段进行查询或操作。</li><li>@Docs：引用预设的第三方文档或自定义文档。支持添加自定义文档。适用于需要引用外部文档或自定义知识库。</li><li>@Git：扫描 Git 提交、差异或拉取请求，帮助查找问题。适用于需要分析 Git 相关信息，如提交记录、代码差异等。</li><li>@Past Chats：将历史聊天消息添加为上下文。适用于在聊天中需要引用之前的对话内容。</li><li>@Cursor Rules：引用项目规则作为上下文。规则文件存储在 .cursor/rules 目录下，支持 MDC 格式，可以包含元数据和内容。适用于需要为项目提供持久化指导、编码规范或工作流程时。</li><li>@Terminals：引用终端输出作为上下文。适用于需要分析命令执行结果、日志输出或调试信息时。</li><li>@Web：搜索网络信息作为附加上下文。适用于需要获取最新网络信息或外部资源。</li><li>@Recent Changes：引用最近的文件变更作为上下文。适用于需要了解最近的代码修改、文件更新或项目变动时。</li></ul><h2 id="安装Cursor"><span class="post-title-index">5. </span><a href="#安装Cursor" class="headerlink" title="安装Cursor"></a>安装Cursor</h2><ol><li><p>访问 <a href="https://cursor.com/">cursor.com</a> 并点击“下载”按钮</p></li><li><p>运行安装程序并等待安装完成</p></li><li><p>通过桌面快捷方式或从应用程序菜单启动 Cursor</p></li></ol><h2 id="登录Cursor"><span class="post-title-index">6. </span><a href="#登录Cursor" class="headerlink" title="登录Cursor"></a>登录Cursor</h2><ol><li><p>首次打开Cursor，会提示登录Cursor账号</p></li><li><p>根据提示，注册一个Cursor账号并登录</p></li></ol><h2 id="使用Cursor"><span class="post-title-index">7. </span><a href="#使用Cursor" class="headerlink" title="使用Cursor"></a>使用Cursor</h2><p>Cursor的核心功能可以通过快捷键调用：</p><ul><li>代码补全：按下 <code>Tab</code> ，使用智能代码补全</li><li>代码编辑：按下 <code>CMD+K</code>，使用内联代码编辑</li><li>聊天编程：按下 <code>CMD+L</code>，打开AI对话界面</li></ul><h3 id="代码补全"><span class="post-title-index">7.1. </span><a href="#代码补全" class="headerlink" title="代码补全"></a>代码补全</h3><p>代码补全基础用法：</p><ol><li>鼠标放在代码中想要代码补全的位置</li><li>输入或者不输入字符，等待Cursor提示</li><li>当出现满意的提示时，按下<code>Tab</code></li></ol><p>代码补全TODO引导：</p><ol><li>在代码中使用注释描述清楚TODO</li><li>鼠标放在注释的下方，等待Cursor提示</li><li>当出现满意的提示时，按下<code>Tab</code></li></ol><h3 id="部分代码编辑"><span class="post-title-index">7.2. </span><a href="#部分代码编辑" class="headerlink" title="部分代码编辑"></a>部分代码编辑</h3><p>部分代码编辑：</p><ol><li>鼠标光标选中一部分代码</li><li>按下<code>CMD+K</code> 打开 Prompt Bars（提示词弹窗），输入代码需求</li></ol><p>命令行编辑：</p><ol><li>鼠标光标位于Terminal</li><li>按下<code>CMD+K</code> 打开 Prompt Bars（提示词弹窗），输入命令行需求</li></ol><h3 id="聊天编程"><span class="post-title-index">7.3. </span><a href="#聊天编程" class="headerlink" title="聊天编程"></a>聊天编程</h3><p>聊天编程创建新文件：</p><ol><li>新建一个空的代码文件</li><li>按下 <code>CMD+L</code> 打开AI对话界面</li><li>对话界面中，输入需求</li><li>接受或者拒绝代码修改</li></ol><p>需求示例：请编写一段python代码，连接mysql并执行 select id,username from users</p><p>聊天编程修改老文件：</p><ol><li>打开一个代码文件</li><li>按下 <code>CMD+L</code> 打开AI对话界面</li><li>对话界面中，选择本次修改涉及到的所有文件</li><li>对话界面中，输入需求</li><li>接受或者拒绝修改代码</li></ol><p>需求示例：请改为使用pymysql</p><h2 id="Cursor安全注意事项"><span class="post-title-index">8. </span><a href="#Cursor安全注意事项" class="headerlink" title="Cursor安全注意事项"></a>Cursor安全注意事项</h2><ol><li>在使用Cursor开发的代码仓库中，不要使用明文账密，避免账密被携带提交给大模型</li><li>使用npm软件包时注意安全，比如 sw-cur 、sw-cur1 和 aiide-cur 这三个包都是被标记的恶意软件。参考文档<a href="https://mp.weixin.qq.com/s/jADkvI5aBE2flEhM9iQ26A">3200+ Cursor 用户被恶意“劫持”！贪图“便宜API”却惨遭收割， AI 开发者们要小心了</a></li></ol><h2 id="Cursor远程连接Linux主机"><span class="post-title-index">9. </span><a href="#Cursor远程连接Linux主机" class="headerlink" title="Cursor远程连接Linux主机"></a>Cursor远程连接Linux主机</h2><p>Cursor连接Linux主机，与VSCode方法相同。<br>如果报错：无法与 “xxx” 建立连接: 未能下载VSCode服务器(Server returned 404).<br>解决办法：安装使用 1.0.0 版本的<code>Anysphere Remote SSH</code>插件。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Cursor简介&quot;&gt;&lt;a href=&quot;#Cursor简介&quot; class=&quot;headerlink&quot; title=&quot;Cursor简介&quot;&gt;&lt;/a&gt;Cursor简介&lt;/h2&gt;&lt;p&gt;Cursor 是一款AI代码编辑器（IDE），目标是借助AI提高编码的速度和质量。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cursor.com/cn&quot;&gt;Cursor官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.cursor.com/get-started/introduction&quot;&gt;Cursor官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.cursor.com/guides/migration/vscode&quot;&gt;Migration from VS Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-vscode-shortcut-and-config/&quot;&gt;《VSCode常用快捷键和配置》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="golang" scheme="https://www.voidking.com/categories/engineering/golang/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="golang" scheme="https://www.voidking.com/tags/golang/"/>
    
    <category term="aigc" scheme="https://www.voidking.com/tags/aigc/"/>
    
    <category term="llm" scheme="https://www.voidking.com/tags/llm/"/>
    
    <category term="vscode" scheme="https://www.voidking.com/tags/vscode/"/>
    
    <category term="编辑器" scheme="https://www.voidking.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="java" scheme="https://www.voidking.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>好好学Golang：Golang问题记录</title>
    <link href="https://www.voidking.com/dev-golang-problem/"/>
    <id>https://www.voidking.com/dev-golang-problem/</id>
    <published>2025-04-26T08:00:00.000Z</published>
    <updated>2025-04-26T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文记录Golang开发时遇到的问题，备忘。</p><p>相关文档：</p><ul><li><a href="https://www.voidking.com/categories/engineering/golang/">Golang文档汇总</a></li><li><a href="https://www.voidking.com/dev-golang-start/">《好好学Golang：Golang入门篇》</a></li><li><a href="https://www.voidking.com/dev-vscode-golang-debug/">《好好学Golang：VSCode配置Golang Debug》</a></li></ul><span id="more"></span><h2 id="编译报错问题"><span class="post-title-index">2. </span><a href="#编译报错问题" class="headerlink" title="编译报错问题"></a>编译报错问题</h2><h3 id="问题描述"><span class="post-title-index">2.1. </span><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>macos运行命令 <code>go run main.go</code>，报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># internal/godebugs</span><br><span class="line">compile: version &quot;go1.23.8&quot; does not match go tool version &quot;go1.24.2&quot;</span><br><span class="line"># internal/byteorder</span><br><span class="line">compile: version &quot;go1.23.8&quot; does not match go tool version &quot;go1.24.2&quot;</span><br><span class="line"># internal/goos</span><br><span class="line">compile: version &quot;go1.23.8&quot; does not match go tool version &quot;go1.24.2&quot;</span><br></pre></td></tr></table></figure><h3 id="解决办法"><span class="post-title-index">2.2. </span><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>参考文档：<a href="https://blog.csdn.net/zhanglu_1024/article/details/126631917">compile: version goX does not match go tool version goY</a></p><p>可能原因：大概率是因为brew安装软件时，软件依赖包含golang，部分覆盖了原本的glang版本。<br>解决办法：卸载brew安装的golang，重新安装原本的golang版本。</p><ol><li>卸载brew安装的golang<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew uninstall golang</span><br><span class="line">go versino</span><br></pre></td></tr></table></figure></li></ol><p>执行完步骤1，如果已经恢复，就不再需要步骤2。</p><ol start="2"><li>下载golang软件包，并重新安装<br>golang下载链接：<a href="https://go.dev/dl/">All releases</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文记录Golang开发时遇到的问题，备忘。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/categories/engineering/golang/&quot;&gt;Golang文档汇总&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-golang-start/&quot;&gt;《好好学Golang：Golang入门篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-vscode-golang-debug/&quot;&gt;《好好学Golang：VSCode配置Golang Debug》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="golang" scheme="https://www.voidking.com/categories/engineering/golang/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="golang" scheme="https://www.voidking.com/tags/golang/"/>
    
    <category term="好好学Golang" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Golang/"/>
    
    <category term="vscode" scheme="https://www.voidking.com/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>One API配置自定义渠道</title>
    <link href="https://www.voidking.com/dev-one-api-custom-channel/"/>
    <id>https://www.voidking.com/dev-one-api-custom-channel/</id>
    <published>2025-02-09T08:00:00.000Z</published>
    <updated>2025-02-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><a href="https://www.voidking.com/dev-one-api-start/">《LLM 接口管理和分发系统 One API》</a>一文中，我们学习了One API的安装和基础配置。</p><p>随着One API项目不断更新，支持的渠道也越来越多。但是，有些新的渠道暂未支持或者不会支持，这时我们可以使用自定义渠道。<br>本文中，我们来学习一下One API自定义渠道的配置方法。</p><p>相关文档：</p><ul><li><a href="https://github.com/songquanpeng/one-api/">github - one-api</a></li></ul><span id="more"></span><h2 id="配置并测试LLM-API"><span class="post-title-index">2. </span><a href="#配置并测试LLM-API" class="headerlink" title="配置并测试LLM API"></a>配置并测试LLM API</h2><p>以配置并测试 UCloud DeepSeek 为例，整个流程如下。</p><p>1、申请UCloud DeepSeek的使用权限</p><p>2、<a href="https://console.ucloud.cn/uapi/detail?id=GetUMInferService">获取模型名称和Key</a></p><p>3、调用测试<br>参考文档：<a href="https://docs.ucloud.cn/modelverse/API">模型服务平台 UModelVerse API说明</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">curl --location <span class="string">&#x27;https://deepseek.modelverse.cn/v1/chat/completions&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Authorization: Bearer &lt;你的API Key&gt;&#x27;</span> \</span><br><span class="line">--header <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">--data <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">    &quot;reasoning_effort&quot;: &quot;low&quot;,</span></span><br><span class="line"><span class="string">    &quot;stream&quot;: true,</span></span><br><span class="line"><span class="string">    &quot;model&quot;: &quot;models/DeepSeek-V3&quot;,</span></span><br><span class="line"><span class="string">    &quot;messages&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            &quot;role&quot;: &quot;user&quot;,</span></span><br><span class="line"><span class="string">            &quot;content&quot;: &quot;say hello to ucloud&quot;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">    ]</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="配置自定义渠道"><span class="post-title-index">3. </span><a href="#配置自定义渠道" class="headerlink" title="配置自定义渠道"></a>配置自定义渠道</h2><p>配置自定义渠道，与配置其他渠道最主要的差别，在于 <code>代理</code>（老版本中是 <code>Base URL</code>）需要填写自己渠道的 URL。</p><p>以配置 UCloud DeepSeek 渠道为例，整个配置如下：</p><ul><li>类型：自定义渠道</li><li>名称：ucloud-deepseek</li><li>分组：default</li><li>代理：<a href="https://deepseek.modelverse.cn/">https://deepseek.modelverse.cn</a></li><li>模型：deepseek-chat</li><li>模型重定向：<code>&#123;&quot;deepseek-chat&quot;: &quot;models/DeepSeek-V3&quot;&#125;</code></li><li>密钥：自己的密钥</li></ul><p>配置完成后，点击测试，验证渠道是否可以正常调用。</p><h2 id="调用自定义渠道"><span class="post-title-index">4. </span><a href="#调用自定义渠道" class="headerlink" title="调用自定义渠道"></a>调用自定义渠道</h2><p>使用curl命令测试调用自定义的 deepseek-chat 模型：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&quot;https://oneapi.voidking.com/v1/chat/completions&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Authorization: Bearer &lt;ONE_API_KEY&gt;&quot;</span> \</span><br><span class="line">    -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">        &quot;model&quot;: &quot;deepseek-chat&quot;,</span></span><br><span class="line"><span class="string">        &quot;messages&quot;: [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &quot;role&quot;: &quot;user&quot;,</span></span><br><span class="line"><span class="string">                &quot;content&quot;: &quot;hello!&quot;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    &#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>如果想要使用 python 测试调用自定义的 deepseek-chat 模型，那么可以参考文档<a href="https://www.voidking.com/dev-one-api-start/">《LLM 接口管理和分发系统 One API》</a></p><h2 id="自定义渠道-Nginx代理"><span class="post-title-index">5. </span><a href="#自定义渠道-Nginx代理" class="headerlink" title="自定义渠道 + Nginx代理"></a>自定义渠道 + Nginx代理</h2><p>在配置 UCloud DeepSeek时，比较简单，代理直接填写 UCloud 官方给的域名就可以了。<br>这是因为UCloud官方的 LLM API 路径刚好和 OneAPI 的规范匹配，是 <code>/v1/chat/completions</code><br>如果某个渠道的 LLM API 路径不是 <code>/v1/chat/completions</code>，那么就需要配合 Nginx代理 来进行配置了。</p><p>已知<a href="https://cloud.luchentech.com/maas/modelMarket">潞晨云</a>的LLM API URL为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cloud.luchentech.com/api/maas/chat/completions</span><br></pre></td></tr></table></figure><p>那么在OneAPI中自定义渠道配置代理时，是不能直接填入 <code>https://cloud.luchentech.com</code> 这个地址的，需要借助Nginx。</p><p>原理：通过Nginx代理，将 <code>/api/maas/chat/completions</code> 转换成 <code>/v1/chat/completions</code></p><p>Nginx配置示例：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  listen 443 ssl;</span><br><span class="line">  server_name luchen.voidking.com;</span><br><span class="line">  charset utf-8;</span><br><span class="line"></span><br><span class="line">  ssl_certificate /etc/letsencrypt/live/voidking.com/fullchain.pem;</span><br><span class="line">  ssl_certificate_key  /etc/letsencrypt/live/voidking.com/privkey.pem;</span><br><span class="line">  ssl_session_timeout  5m;</span><br><span class="line">  ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">  ssl_ciphers  HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM;</span><br><span class="line">  ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">  if ($ssl_protocol = &quot;&quot;) &#123;</span><br><span class="line">    return 301 https://$host$request_uri;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /v1/chat/completions &#123;</span><br><span class="line">    proxy_pass https://cloud.luchentech.com/api/maas/chat/completions;</span><br><span class="line">    proxy_set_header Host cloud.luchentech.com;</span><br><span class="line">    proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line"></span><br><span class="line">    proxy_connect_timeout 60s;</span><br><span class="line">    proxy_send_timeout 60s;</span><br><span class="line">    proxy_read_timeout 60s;</span><br><span class="line"></span><br><span class="line">    # WebSocket support</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">    proxy_set_header Connection &quot;upgrade&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完成后，在OneAPI中自定义渠道配置代理时，填入 <code>https://luchen.voidking.com</code></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-one-api-start/&quot;&gt;《LLM 接口管理和分发系统 One API》&lt;/a&gt;一文中，我们学习了One API的安装和基础配置。&lt;/p&gt;
&lt;p&gt;随着One API项目不断更新，支持的渠道也越来越多。但是，有些新的渠道暂未支持或者不会支持，这时我们可以使用自定义渠道。&lt;br&gt;本文中，我们来学习一下One API自定义渠道的配置方法。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/songquanpeng/one-api/&quot;&gt;github - one-api&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
    <category term="aigc" scheme="https://www.voidking.com/tags/aigc/"/>
    
    <category term="llm" scheme="https://www.voidking.com/tags/llm/"/>
    
    <category term="deepseek" scheme="https://www.voidking.com/tags/deepseek/"/>
    
    <category term="one-api" scheme="https://www.voidking.com/tags/one-api/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置AList</title>
    <link href="https://www.voidking.com/dev-docker-alist/"/>
    <id>https://www.voidking.com/dev-docker-alist/</id>
    <published>2024-11-30T08:00:00.000Z</published>
    <updated>2024-11-30T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AList简介"><span class="post-title-index">1. </span><a href="#AList简介" class="headerlink" title="AList简介"></a>AList简介</h1><blockquote><p>AList是一个支持多种存储介质的文件列表程序，基于 Gin 和 Solidjs 实现。</p></blockquote><p>相关文档：</p><ul><li><a href="https://github.com/AlistGo/alist">github - AlistGo/alist</a></li><li><a href="https://alist.nn.ci/">AList Docs</a></li><li><a href="https://www.voidking.com/dev-docker-filebrowser/">《好好学Docker：使用Docker安装配置FileBrowser》</a></li></ul><span id="more"></span><h1 id="AList优点"><span class="post-title-index">2. </span><a href="#AList优点" class="headerlink" title="AList优点"></a>AList优点</h1><ul><li>部署方便，开箱即用；支持Docker部署</li><li>支持多种存储介质，包括：本地存储、FTP、WebDAV、S3、阿里云盘、夸克网盘、百度网盘、天翼云盘等等。</li><li>支持作为<a href="https://alist.nn.ci/zh/guide/webdav.html">WebDav</a>服务器</li><li>支持LDAP</li><li>文件预览（PDF、markdown、代码、纯文本等）</li><li>画廊模式下的图像预览</li><li>视频和音频预览，支持歌词和字幕</li><li>Office 文档预览（docx、pptx、xlsx等）</li><li>受保护的路由（密码保护和身份验证）</li><li>文件永久链接复制和直接文件下载</li><li>文件/文件夹打包下载</li><li>网页上传(可以允许访客上传)，删除，新建文件夹，重命名，移动，复制</li><li>跨存储复制文件</li><li>离线下载</li><li>单线程下载/串流的多线程下载加速</li></ul><h1 id="安装AList"><span class="post-title-index">3. </span><a href="#安装AList" class="headerlink" title="安装AList"></a>安装AList</h1><p>参考文档：<a href="https://alist.nn.ci/guide/install/docker.html">AList Install - Use Docker</a></p><p>1、下载 alist 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull xhofe/alist:v3.40.0-ffmpeg</span><br></pre></td></tr></table></figure><p>2、启动 alist 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run --name alist -d \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  -v /opt/alist/data:/opt/alist/data \</span><br><span class="line">  -v /opt/alist/root:/opt/alist/root \</span><br><span class="line">  -p 5244:5244 \</span><br><span class="line">  -e PUID=0 \</span><br><span class="line">  -e PGID=0 \</span><br><span class="line">  -e UMASK=022 \</span><br><span class="line">  -e <span class="string">&quot;TZ=Asia/Shanghai&quot;</span> \</span><br><span class="line">  xhofe/alist:v3.40.0-ffmpeg </span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>/opt/alist/data 目录，用于存储alist程序本身的数据</li><li>/opt/alist/root 目录，用于对外共享数据</li></ul><p>3、检查运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep alist</span><br><span class="line">docker logs alist</span><br></pre></td></tr></table></figure><h1 id="使用AList"><span class="post-title-index">4. </span><a href="#使用AList" class="headerlink" title="使用AList"></a>使用AList</h1><h2 id="设置密码"><span class="post-title-index">4.1. </span><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><p>3.25.0以上版本将密码改成加密方式存储的hash值，无法直接反算出密码，如果忘记了密码只能通过重新 随机生成 或者 手动设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机生成一个密码</span></span><br><span class="line">docker <span class="built_in">exec</span> -it alist ./alist admin random</span><br><span class="line"><span class="comment"># 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码</span></span><br><span class="line">docker <span class="built_in">exec</span> -it alist ./alist admin <span class="built_in">set</span> NEW_PASSWORD</span><br></pre></td></tr></table></figure><h2 id="访问alist"><span class="post-title-index">4.2. </span><a href="#访问alist" class="headerlink" title="访问alist"></a>访问alist</h2><p>1、浏览器访问 alist<br>假设主机IP为 192.168.56.101，那么浏览器访问 <a href="http://192.168.56.101:5244/">http://192.168.56.101:5244</a></p><p>2、登录 alist<br>用户名 admin，密码是上一节中设置的密码。</p><h2 id="配置存储介质"><span class="post-title-index">4.3. </span><a href="#配置存储介质" class="headerlink" title="配置存储介质"></a>配置存储介质</h2><p>1、点击管理，存储，添加</p><p>2、添加本机存储</p><ul><li>驱动选择本机存储</li><li>根文件夹路径填入 <code>/opt/alist/root/</code></li><li>挂载路径填入 <code>/</code></li><li>启用缩略图</li><li>其他选项保持默认</li></ul><p>3、查看文件<br>浏览器访问 <a href="http://192.168.56.101:5244/">http://192.168.56.101:5244</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AList简介&quot;&gt;&lt;a href=&quot;#AList简介&quot; class=&quot;headerlink&quot; title=&quot;AList简介&quot;&gt;&lt;/a&gt;AList简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;AList是一个支持多种存储介质的文件列表程序，基于 Gin 和 Solidjs 实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AlistGo/alist&quot;&gt;github - AlistGo/alist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://alist.nn.ci/&quot;&gt;AList Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-docker-filebrowser/&quot;&gt;《好好学Docker：使用Docker安装配置FileBrowser》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：容器指标查看工具ctop</title>
    <link href="https://www.voidking.com/dev-docker-ctop/"/>
    <id>https://www.voidking.com/dev-docker-ctop/</id>
    <published>2024-11-23T08:00:00.000Z</published>
    <updated>2024-11-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ctop简介"><span class="post-title-index">1. </span><a href="#ctop简介" class="headerlink" title="ctop简介"></a>ctop简介</h1><p>ctop 是一个类似于 top 的容器指标查看工具。<br>ctop 提供了查询多个容器实时指标的视图，以及查询特定容器实时指标的视图。ctop 内置对 Docker 和 runC 的支持；未来版本计划支持其他容器和集群系统的连接器。</p><p>相关文档：</p><ul><li><a href="https://github.com/bcicen/ctop">github - bcicen/ctop</a></li><li><a href="https://mp.weixin.qq.com/s/BXLZq2lc3OdRAeY551tTmg">容器的top工具：ctop</a></li></ul><span id="more"></span><h1 id="安装ctop"><span class="post-title-index">2. </span><a href="#安装ctop" class="headerlink" title="安装ctop"></a>安装ctop</h1><p>推荐使用二进制安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/bcicen/ctop/releases/download/v0.7.3/ctop-0.7.3-linux-amd64 -O /usr/local/bin/ctop</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/ctop</span><br></pre></td></tr></table></figure><h1 id="使用ctop"><span class="post-title-index">3. </span><a href="#使用ctop" class="headerlink" title="使用ctop"></a>使用ctop</h1><h2 id="查看全部容器指标"><span class="post-title-index">3.1. </span><a href="#查看全部容器指标" class="headerlink" title="查看全部容器指标"></a>查看全部容器指标</h2><p>1、启动 ctop，默认界面查看全部容器指标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctop</span><br></pre></td></tr></table></figure><p>2、退出 ctop<br>按下 <code>q</code>，退出 ctop</p><h2 id="容器排序"><span class="post-title-index">3.2. </span><a href="#容器排序" class="headerlink" title="容器排序"></a>容器排序</h2><p>ctop界面中，按下 <code>s</code> ，选择排序字段。<br>支持的字段包括：cpu，io，mem，mem %，name，pids，net，state</p><h2 id="查看单个容器指标"><span class="post-title-index">3.3. </span><a href="#查看单个容器指标" class="headerlink" title="查看单个容器指标"></a>查看单个容器指标</h2><p>ctop界面中，选中容器后，按下 <code>o</code></p><h2 id="查看单个容器日志"><span class="post-title-index">3.4. </span><a href="#查看单个容器日志" class="headerlink" title="查看单个容器日志"></a>查看单个容器日志</h2><p>ctop页面中，选中容器后，按下 <code>l</code></p><h2 id="进入容器内部"><span class="post-title-index">3.5. </span><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h2><p>ctop页面中，选中容器后，按下 <code>e</code></p><h2 id="查找容器"><span class="post-title-index">3.6. </span><a href="#查找容器" class="headerlink" title="查找容器"></a>查找容器</h2><p>查找：ctop界面中，按下 <code>f</code>，输入关键词筛选容器，回车<br>退出查找：ctop界面中，按下 <code>f</code>，删除所有关键词，回车</p><h2 id="更多操作"><span class="post-title-index">3.7. </span><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h2><p>ctop界面中，选中容器后回车，出现菜单<br>此时可以选择查看单个容器指标、查看单个容器日志，还可以停止、暂停、重启、进入容器内部。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ctop简介&quot;&gt;&lt;a href=&quot;#ctop简介&quot; class=&quot;headerlink&quot; title=&quot;ctop简介&quot;&gt;&lt;/a&gt;ctop简介&lt;/h1&gt;&lt;p&gt;ctop 是一个类似于 top 的容器指标查看工具。&lt;br&gt;ctop 提供了查询多个容器实时指标的视图，以及查询特定容器实时指标的视图。ctop 内置对 Docker 和 runC 的支持；未来版本计划支持其他容器和集群系统的连接器。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bcicen/ctop&quot;&gt;github - bcicen/ctop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BXLZq2lc3OdRAeY551tTmg&quot;&gt;容器的top工具：ctop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：自建RustDesk Server</title>
    <link href="https://www.voidking.com/dev-docker-install-rustdesk-server/"/>
    <id>https://www.voidking.com/dev-docker-install-rustdesk-server/</id>
    <published>2024-11-09T08:00:00.000Z</published>
    <updated>2024-11-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RustDesk简介"><span class="post-title-index">1. </span><a href="#RustDesk简介" class="headerlink" title="RustDesk简介"></a>RustDesk简介</h1><p>RustDesk 是一款开源的远程桌面软件，是 TeamViewer、向日葵的替代软件，提供了高效、安全的远程访问解决方案。</p><p>相关文档：</p><ul><li><a href="https://github.com/rustdesk/rustdesk">github - rustdesk/rustdesk</a></li><li><a href="https://rustdesk.com/zh-cn/">RustDesk官网</a></li><li><a href="https://rustdesk.com/docs/zh-cn/">RustDesk官方文档</a></li><li><a href="https://www.cnblogs.com/ryanyangcs/p/18186163">RustDesk 自建服务器部署和使用教程</a></li><li><a href="https://bbs.deepin.org/zh/post/253836">远程桌面软件 RustDesk</a></li></ul><span id="more"></span><h1 id="安装RustDesk-Client"><span class="post-title-index">2. </span><a href="#安装RustDesk-Client" class="headerlink" title="安装RustDesk Client"></a>安装RustDesk Client</h1><h2 id="Ubuntu22中安装RustDesk-Client"><span class="post-title-index">2.1. </span><a href="#Ubuntu22中安装RustDesk-Client" class="headerlink" title="Ubuntu22中安装RustDesk Client"></a>Ubuntu22中安装RustDesk Client</h2><p>本节中，我们在 Ubuntu22 中安装支持 Wayland 的 RustDesk Client。</p><p>1、下载 RustDesk Client 安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/rustdesk/rustdesk/releases/download/nightly/rustdesk-1.3.3-x86_64.deb</span><br></pre></td></tr></table></figure><p>2、安装 RustDesk Client</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -fy ./rustdesk-1.3.3-x86_64.deb</span><br></pre></td></tr></table></figure><p>3、启动 RustDesk Client<br>在图形化界面中，启动RustDesk Client，记录下ID和密码用于远程控制。<br>建议设置一个固定的密码，并设置开机自动启动。</p><h2 id="MacOS中安装-RustDesk-Client"><span class="post-title-index">2.2. </span><a href="#MacOS中安装-RustDesk-Client" class="headerlink" title="MacOS中安装 RustDesk Client"></a>MacOS中安装 RustDesk Client</h2><p>1、下载 RustDesk Client 安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/rustdesk/rustdesk/releases/download/nightly/rustdesk-1.3.3-x86_64.dmg</span><br></pre></td></tr></table></figure><p>2、安装 RustDesk Client<br>双击 dmg 文件，拖拽安装</p><p>3、启动 RustDesk Client</p><h1 id="使用RustDesk进行远程操作"><span class="post-title-index">3. </span><a href="#使用RustDesk进行远程操作" class="headerlink" title="使用RustDesk进行远程操作"></a>使用RustDesk进行远程操作</h1><p>在两台设备上安装并启动 RustDesk Client，然后就可以像Teamviewer一样，输入对方的ID和密码，进行远程控制了。</p><p>RustDesk首次建立连接后会提示 <code>请选择要分享的画面（对端操作）</code> ，也就是说必须要求对端操作才能开始远程。<br>对端选择屏幕并记住选择后，后续再建立连接就不需要对端操作了。</p><p>注意：使用RustDesk远程时，哪怕对端已经锁屏息屏，也可以唤醒并进行远程，相当于本地操作远程屏幕。</p><p>重启主机后再次连接，会提示 <code>不支持使用 Wayland 登录界面</code> ，说明RustDesk对 Wayland 的支持并不好。详情参考：<a href="https://rustdesk.com/docs/en/client/linux/#login-screen">Login screen using Wayland is not supported yet.</a></p><h1 id="自建RustDesk-Server"><span class="post-title-index">4. </span><a href="#自建RustDesk-Server" class="headerlink" title="自建RustDesk Server"></a>自建RustDesk Server</h1><h2 id="为什么需要自建RustDesk-Server？"><span class="post-title-index">4.1. </span><a href="#为什么需要自建RustDesk-Server？" class="headerlink" title="为什么需要自建RustDesk Server？"></a>为什么需要自建RustDesk Server？</h2><p>以上，我们已经可以使用RustDesk Client，为什么还需要自建RustDesk Server？<br>两个原因：</p><ul><li>由于被诈骗分子频繁使用，该项目现已暂停国内服务。</li><li>使用默认的RustDesk Server，稳定性和隐私性不能保证。</li></ul><p>因此，自建RustDesk Server还是有必要的。</p><h2 id="基于Docker搭建RustDesk-Server"><span class="post-title-index">4.2. </span><a href="#基于Docker搭建RustDesk-Server" class="headerlink" title="基于Docker搭建RustDesk Server"></a>基于Docker搭建RustDesk Server</h2><p>参考文档：</p><ul><li><a href="https://rustdesk.com/docs/zh-cn/self-host/">RustDesk 自建服务器</a></li><li><a href="https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/docker/">Install your own server with Docker</a></li></ul><p>1、准备软件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /opt/rustdesk/data</span><br></pre></td></tr></table></figure><p>2、准备 docker-compose.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/rustdesk/</span><br><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>写入如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hbbs:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:1.1.12</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/rustdesk/data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">hbbr:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:1.1.12</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/rustdesk/data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><p>3、启动 RustDesk Server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>4、查看 RustDesk Server 状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br><span class="line">docker ps | grep rustdesk</span><br><span class="line">docker logs hbbs</span><br><span class="line">docker logs hbbr</span><br></pre></td></tr></table></figure><p>5、获取服务器Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs hbbs</span><br></pre></td></tr></table></figure><p>可以在日志中看到一个Key，记录下来。</p><h2 id="开放端口"><span class="post-title-index">4.3. </span><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><p>hbbs默认监听端口：</p><ul><li>21114（TCP）：用于 Web 控制台，仅在 Pro 版本中可用</li><li>21115（TCP）：用于 NAT 类型测试</li><li>21116（TCP/UDP）：UDP 用于 ID 注册和心跳服务，TCP 用于 TCP 打孔和连接服务</li><li>21118（TCP）：用于支持Web客户端，可选禁用</li></ul><p>hbbr默认监听端口：</p><ul><li>21117（TCP）：用于 Relay 服务</li><li>21119（TCP）：用于支持Web客户端，可选禁用</li></ul><h1 id="配置使用Rust-Server"><span class="post-title-index">5. </span><a href="#配置使用Rust-Server" class="headerlink" title="配置使用Rust Server"></a>配置使用Rust Server</h1><p>假设 Rust Server 的IP地址为 <code>8.136.12.13</code></p><p>1、打开Rust Client设置页面</p><p>2、网络，解锁网络设置</p><ul><li>ID服务器：填入 <code>8.136.13.58:21116</code></li><li>中继服务器：填入 <code>8.136.13.58:21117</code></li><li>Key：填入【基于Docker搭建RustDesk Server】一节中获取到的Key。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RustDesk简介&quot;&gt;&lt;a href=&quot;#RustDesk简介&quot; class=&quot;headerlink&quot; title=&quot;RustDesk简介&quot;&gt;&lt;/a&gt;RustDesk简介&lt;/h1&gt;&lt;p&gt;RustDesk 是一款开源的远程桌面软件，是 TeamViewer、向日葵的替代软件，提供了高效、安全的远程访问解决方案。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rustdesk/rustdesk&quot;&gt;github - rustdesk/rustdesk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustdesk.com/zh-cn/&quot;&gt;RustDesk官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustdesk.com/docs/zh-cn/&quot;&gt;RustDesk官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ryanyangcs/p/18186163&quot;&gt;RustDesk 自建服务器部署和使用教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bbs.deepin.org/zh/post/253836&quot;&gt;远程桌面软件 RustDesk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="linux" scheme="https://www.voidking.com/categories/engineering/linux/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="ubuntu" scheme="https://www.voidking.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>好好学Linux：Ubuntu18 升级到 Ubuntu22</title>
    <link href="https://www.voidking.com/dev-upgrade-ubuntu18-to-ubuntu22/"/>
    <id>https://www.voidking.com/dev-upgrade-ubuntu18-to-ubuntu22/</id>
    <published>2024-11-09T08:00:00.000Z</published>
    <updated>2024-11-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要升级Ubuntu？"><span class="post-title-index">1. </span><a href="#为什么要升级Ubuntu？" class="headerlink" title="为什么要升级Ubuntu？"></a>为什么要升级Ubuntu？</h1><p>Ubuntu18 的常规支持已于2023年4月结束，而 Ubuntu22 有更长的常规支持周期，这意味着在未来几年内，用户将持续获得包括功能更新、安全更新和错误修复在内的全面支持，确保系统的稳定性和安全性。</p><p>Ubuntu22 采用了较新的 Linux 内核版本，新内核通常会带来更好的硬件支持、性能优化和安全性增强。</p><p>此外，最重要的是，很多Ubuntu中的软件仅支持最新版本的Ubuntu，比如Waydroid，比如麟卓卓懿。</p><p>因此，虽然升级Ubuntu比较麻烦，并且存在一定的风险，但是是值得的。</p><p>参考文档：</p><ul><li><a href="https://ubuntu.com/tutorials/upgrading-ubuntu-desktop#1-before-you-start">Upgrade Ubuntu desktop</a></li><li><a href="https://askubuntu.com/questions/1454762/18-04-22-04-upgrade">18.04 -&gt; 22.04 upgrade</a></li><li><a href="https://www.reddit.com/r/Ubuntu/comments/x3z08c/upgrade_ubuntu_1804_to_2204/">Upgrade ubuntu 18.04 to 22.04</a></li><li><a href="https://blog.csdn.net/liufangaliya/article/details/134132836">ubuntu18.04如何更新到22.04</a></li></ul><span id="more"></span><h1 id="Ubuntu18升级Ubuntu20"><span class="post-title-index">2. </span><a href="#Ubuntu18升级Ubuntu20" class="headerlink" title="Ubuntu18升级Ubuntu20"></a>Ubuntu18升级Ubuntu20</h1><p>Ubuntu不能跨版本升级，只能逐个版本升级，或者逐个LTS版本升级。因此需要先从Ubuntu18升级到Ubuntu20，再从Ubuntu20升级到Ubuntu22。</p><h2 id="升级前准备"><span class="post-title-index">2.1. </span><a href="#升级前准备" class="headerlink" title="升级前准备"></a>升级前准备</h2><p>0、关闭一些软件（可选）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl <span class="built_in">disable</span> docker</span><br><span class="line">systemctl stop v2raya</span><br><span class="line">systemctl <span class="built_in">disable</span> v2raya</span><br><span class="line">vncserver -<span class="built_in">kill</span> :1</span><br></pre></td></tr></table></figure><p>1、修改软件源配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>添加如下配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic main restricted</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates main restricted</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic-security main restricted</span><br></pre></td></tr></table></figure><p>2、更新软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade</span><br><span class="line">apt dist-upgrade</span><br></pre></td></tr></table></figure><p>3、删除无用软件包（可选）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt autoremove</span><br></pre></td></tr></table></figure><p>4、安装 update-manager-core</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install update-manager-core</span><br></pre></td></tr></table></figure><p>5、重启系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="执行升级"><span class="post-title-index">2.2. </span><a href="#执行升级" class="headerlink" title="执行升级"></a>执行升级</h2><p>1、配置使用lts升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/update-manager/release-upgrades</span><br></pre></td></tr></table></figure><p>如下修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Prompt=lts</span><br></pre></td></tr></table></figure><p>注意：如果配置了 <code>Prompt=never</code> ，那么说明禁用了Ubuntu更新。更新时会提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Checking for a new Ubuntu release</span><br><span class="line">In /etc/update-manager/release-upgrades Prompt</span><br><span class="line">is set to never so upgrading is not possible.</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://askubuntu.com/questions/1315484/cant-upgrade-from-18-04-server-to-20-04">Can’t upgrade from 18.04 server to 20.04</a></p><p>2、执行升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do-release-upgrade</span><br></pre></td></tr></table></figure><p>升级过程会有交互提示，根据提示选择即可。</p><p>整个升级过程大约1-2小时。升级完成需要重启一次系统。</p><p>3、查看当前版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h1 id="Ubuntu20升级到Ubuntu22"><span class="post-title-index">3. </span><a href="#Ubuntu20升级到Ubuntu22" class="headerlink" title="Ubuntu20升级到Ubuntu22"></a>Ubuntu20升级到Ubuntu22</h1><p>不用再次进行升级前准备，直接执行升级命令即可。</p><p>1、执行升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do-release-upgrade</span><br></pre></td></tr></table></figure><p>升级过程会有交互提示，根据提示选择即可。</p><p>Ubuntu20升级Ubuntu22过程中，在 Upgrade to the firefox snap 时会卡住半个小时以上，请耐心等待。详情参考<a href="https://askubuntu.com/questions/1445771/upgrade-ubuntu-20-04-to-22-04-stuck-on-installing-the-firefox-snap">Upgrade Ubuntu 20.04 to 22.04 stuck on ‘’installing the firefox snap’’</a></p><p>2、查看当前版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么要升级Ubuntu？&quot;&gt;&lt;a href=&quot;#为什么要升级Ubuntu？&quot; class=&quot;headerlink&quot; title=&quot;为什么要升级Ubuntu？&quot;&gt;&lt;/a&gt;为什么要升级Ubuntu？&lt;/h1&gt;&lt;p&gt;Ubuntu18 的常规支持已于2023年4月结束，而 Ubuntu22 有更长的常规支持周期，这意味着在未来几年内，用户将持续获得包括功能更新、安全更新和错误修复在内的全面支持，确保系统的稳定性和安全性。&lt;/p&gt;
&lt;p&gt;Ubuntu22 采用了较新的 Linux 内核版本，新内核通常会带来更好的硬件支持、性能优化和安全性增强。&lt;/p&gt;
&lt;p&gt;此外，最重要的是，很多Ubuntu中的软件仅支持最新版本的Ubuntu，比如Waydroid，比如麟卓卓懿。&lt;/p&gt;
&lt;p&gt;因此，虽然升级Ubuntu比较麻烦，并且存在一定的风险，但是是值得的。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ubuntu.com/tutorials/upgrading-ubuntu-desktop#1-before-you-start&quot;&gt;Upgrade Ubuntu desktop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/1454762/18-04-22-04-upgrade&quot;&gt;18.04 -&amp;gt; 22.04 upgrade&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/Ubuntu/comments/x3z08c/upgrade_ubuntu_1804_to_2204/&quot;&gt;Upgrade ubuntu 18.04 to 22.04&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/liufangaliya/article/details/134132836&quot;&gt;ubuntu18.04如何更新到22.04&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="linux" scheme="https://www.voidking.com/categories/engineering/linux/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="好好学Linux" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Linux/"/>
    
    <category term="ubuntu" scheme="https://www.voidking.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置FileBrowser</title>
    <link href="https://www.voidking.com/dev-docker-filebrowser/"/>
    <id>https://www.voidking.com/dev-docker-filebrowser/</id>
    <published>2024-10-26T08:00:00.000Z</published>
    <updated>2024-10-26T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FileBrowser简介"><span class="post-title-index">1. </span><a href="#FileBrowser简介" class="headerlink" title="FileBrowser简介"></a>FileBrowser简介</h1><p>FileBrowser 提供了一个在指定目录内的文件管理界面，功能包括上传、删除、预览、重命名和编辑文件。<br>它允许创建多个用户，每个用户可以拥有自己的目录。</p><p>相关文档：</p><ul><li><a href="https://github.com/filebrowser/filebrowser">github - filebrowser/filebrowser</a></li><li><a href="https://filebrowser.org/installation">FileBrowser Installation</a></li><li><a href="https://www.voidking.com/dev-docker-alist/">《好好学Docker：使用Docker安装配置AList》</a></li></ul><span id="more"></span><h1 id="安装FileBrowser"><span class="post-title-index">2. </span><a href="#安装FileBrowser" class="headerlink" title="安装FileBrowser"></a>安装FileBrowser</h1><p>1、下载 filebrowser 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull filebrowser/filebrowser:v2.31.2-s6</span><br></pre></td></tr></table></figure><p>2、准备持久化目录和文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name tmp -d \</span><br><span class="line">    filebrowser/filebrowser:v2.31.2-s6</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/filebrowser/</span><br><span class="line">docker <span class="built_in">cp</span> tmp:/database/filebrowser.db /opt/filebrowser/</span><br><span class="line">docker <span class="built_in">cp</span> tmp:/config/settings.json /opt/filebrowser/</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">rm</span> tmp -f</span><br></pre></td></tr></table></figure><p>3、启动 filebrowser 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name filebrowser -d \</span><br><span class="line">    -v /opt/filebrowser/srv:/srv \</span><br><span class="line">    -v /opt/filebrowser/filebrowser.db:/database/filebrowser.db \</span><br><span class="line">    -v /opt/filebrowser/settings.json:/config/settings.json \</span><br><span class="line">    -e PUID=$(<span class="built_in">id</span> -u) \</span><br><span class="line">    -e PGID=$(<span class="built_in">id</span> -g) \</span><br><span class="line">    -p 8889:80 \</span><br><span class="line">    filebrowser/filebrowser:v2.31.2-s6</span><br></pre></td></tr></table></figure><p>4、检查运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker logs filebrowser</span><br></pre></td></tr></table></figure><h1 id="使用FileBrowser"><span class="post-title-index">3. </span><a href="#使用FileBrowser" class="headerlink" title="使用FileBrowser"></a>使用FileBrowser</h1><p>1、浏览器访问 filebrowser<br>假设主机IP为 192.168.56.101，那么浏览器访问 <a href="http://192.168.56.101:8889/">http://192.168.56.101:8889</a></p><p>2、登录 filebrowser<br>默认用户名和密码都是 <code>admin</code>，首次登录后建议修改密码。</p><h1 id="后记"><span class="post-title-index">4. </span><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>FileBrowser配合Jupyter，绝了！让主机变得触手可及。<br>FileBrowser负责界面管理文件，Jupyter负责界面执行脚本，无线可能。比如笔记系统，比如影音系统，比如加解密系统。。。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;FileBrowser简介&quot;&gt;&lt;a href=&quot;#FileBrowser简介&quot; class=&quot;headerlink&quot; title=&quot;FileBrowser简介&quot;&gt;&lt;/a&gt;FileBrowser简介&lt;/h1&gt;&lt;p&gt;FileBrowser 提供了一个在指定目录内的文件管理界面，功能包括上传、删除、预览、重命名和编辑文件。&lt;br&gt;它允许创建多个用户，每个用户可以拥有自己的目录。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/filebrowser/filebrowser&quot;&gt;github - filebrowser/filebrowser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://filebrowser.org/installation&quot;&gt;FileBrowser Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-docker-alist/&quot;&gt;《好好学Docker：使用Docker安装配置AList》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>邮箱配置中的SPF、DKIM、DMARC记录</title>
    <link href="https://www.voidking.com/dev-mail-spf-dkim-dmarc/"/>
    <id>https://www.voidking.com/dev-mail-spf-dkim-dmarc/</id>
    <published>2024-10-26T08:00:00.000Z</published>
    <updated>2024-11-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在现代电子邮件系统中，确保邮件的安全性和可靠性至关重要。SPF、DKIM和DMARC是三种主要的电子邮件身份验证机制，它们共同工作以防止垃圾邮件、钓鱼攻击和其他形式的邮件欺诈。</p><p>SPF、DKIM和DMARC机制在配置DNS时，记录类型都是TXT类型，在配置记录值时请注意DNS平台是否需要双引号。</p><p>本文将学习这三种机制及其在邮箱配置中的作用。</p><p>参考文档：</p><ul><li><a href="https://jovialchap.com/spf-dkim-dmarc-explained/">详解 SPF、DKIM、DMARC 记录与工作原理</a></li><li><a href="https://powerdmarc.com/fix-this-mail-is-unauthenticated-gmail-error/">550-5.7.26 Gmail Error: Email Blocked Because Sender is Unauthenticated</a></li><li><a href="https://powerdmarc.com/zh/what-is-a-dns-txt-record/">POWERDMARC - 什么是DNS TXT记录？</a></li><li><a href="https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-txt-record/">CloudFlare - 什么是 DNS TXT 记录？</a></li></ul><span id="more"></span><h1 id="SPF"><span class="post-title-index">2. </span><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h1><h2 id="SPF简介"><span class="post-title-index">2.1. </span><a href="#SPF简介" class="headerlink" title="SPF简介"></a>SPF简介</h2><p>SPF全称为发件人策略框架，SPF是一种用于验证发送电子邮件的服务器是否被授权代表域名发送邮件的机制。<br>通过在DNS中添加SPF记录，域名所有者可以指定哪些IP地址可以发送该域名的邮件。</p><h2 id="SPF工作原理"><span class="post-title-index">2.2. </span><a href="#SPF工作原理" class="headerlink" title="SPF工作原理"></a>SPF工作原理</h2><p>当接收邮件服务器收到一封来自某个域名的邮件时，它会查找该域名的SPF记录，验证发件服务器的IP地址是否在授权列表中。如果匹配，邮件将被接受；如果不匹配，邮件可能会被标记为垃圾邮件或拒绝。</p><h2 id="SPF记录示例"><span class="post-title-index">2.3. </span><a href="#SPF记录示例" class="headerlink" title="SPF记录示例"></a>SPF记录示例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机记录：@</span><br><span class="line">记录类型：TXT</span><br><span class="line">记录值：&quot;v=spf1 ip4:192.0.2.0/24 include:_spf.example.com -all&quot;</span><br></pre></td></tr></table></figure><p>记录值字段说明：</p><ul><li><code>v=spf1</code>：表示使用SPF版本1。</li><li><code>ip4:192.0.2.0/24</code>：允许该IP地址范围发送邮件。</li><li><code>include:_spf.example.com</code>：允许其他域名的SPF记录。</li><li><code>-all</code>：表示不允许其他IP地址发送邮件。</li></ul><p>腾讯企业邮推荐记录值：<code>&quot;v=spf1 include:spf.mail.qq.com ~all&quot;</code> </p><p>参考文档：</p><ul><li><a href="https://open.work.weixin.qq.com/help2/pc/20047?person_id=1">550 SPF check failed</a></li><li><a href="https://open.work.weixin.qq.com/help2/pc/19817?person_id=1">如何设置企业邮箱的SPF记录值？</a></li></ul><h2 id="SPF语法解释"><span class="post-title-index">2.4. </span><a href="#SPF语法解释" class="headerlink" title="SPF语法解释"></a>SPF语法解释</h2><p>SPF记录定义了多种不同的 mechanism，这些 mechanism 规定了哪些 IP 是被允许的，哪些 IP 是被禁止的。</p><p>这一些mechanism包含以下几类：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all | ip4 | ip6 | a | mx | ptr | exists | include</span><br><span class="line">同时还支持以下四种前缀：</span><br><span class="line">&quot;+&quot; -&gt; Pass (通过/同时这也是默认值) -&gt; 发件IP合法，接收</span><br><span class="line">&quot;-&quot; -&gt; Fail (拒绝) -&gt; 发件IP非法，退信</span><br><span class="line">&quot;~&quot; -&gt; Soft Fail (软拒绝) -&gt; 发件IP非法，接收</span><br><span class="line">&quot;?&quot; -&gt; Neutral (中立) -&gt; SPF记录中没有该IP信息，接收</span><br></pre></td></tr></table></figure><p>all 表示命中所有的 IP，通常放在 SPF 记录的尾部作为 fallback，结合上面提到的前缀举几个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 -all&quot; 拒绝所有</span><br><span class="line">&quot;v=spf1 +all&quot; 接受所有</span><br></pre></td></tr></table></figure><p>ip4/ip6 的格式相近，具体的配置举例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 ip4:192.168.0.1/16 -all&quot;</span><br><span class="line">只允许在 192.168.0.1 ~ 192.168.255.255 范围内的 IP</span><br><span class="line">&quot;v=spf1 ip6:1080::8:800:200C:417A/96 -all&quot;</span><br><span class="line">只允许在 1080::8:800:0000:0000 ~ 1080::8:800:FFFF:FFFF 范围内的 IP</span><br><span class="line">如果没有指定前缀长度，则默认只表示记录中所填写的IP（1个IP）</span><br></pre></td></tr></table></figure><p>a/mx 这两个 mechanism 会命中相应域名的 a 记录和 mx 记录，a语法mx的语法一致，如果没有填写域名则默认值为当前域名：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 mx -all&quot; 允许当前域名的 mx 记录对应的 IP 地址。</span><br><span class="line">&quot;v=spf1 mx mx:deferrals.example.com -all&quot; 允许当前域名和 deferrals.example.com 的 mx 记录对应的 IP 地址。</span><br><span class="line">&quot;v=spf1 a/24 -all&quot; 这个配置允许一个地址段</span><br></pre></td></tr></table></figure><p>include 用于引入某个域名下的SPF记录，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 include:example.com -all&quot; 采用和 example.com 完全一样的 SPF 记录</span><br></pre></td></tr></table></figure><h1 id="DKIM"><span class="post-title-index">3. </span><a href="#DKIM" class="headerlink" title="DKIM"></a>DKIM</h1><h2 id="DKIM简介"><span class="post-title-index">3.1. </span><a href="#DKIM简介" class="headerlink" title="DKIM简介"></a>DKIM简介</h2><p>DKIM全称为域名密钥识别邮件，DKIM是一种电子邮件身份验证方法，它通过数字签名确保邮件内容在传输过程中未被篡改。<br>发件人使用私钥对邮件进行签名，而接收方则使用公钥进行验证。</p><h2 id="DKIM工作原理"><span class="post-title-index">3.2. </span><a href="#DKIM工作原理" class="headerlink" title="DKIM工作原理"></a>DKIM工作原理</h2><p>当接收服务器收到一封带有DKIM签名的邮件时，它会提取签名并查找相应的公钥。如果公钥验证成功，表明邮件未被篡改且确实来自声称的发件人。</p><h2 id="DKIM记录示例"><span class="post-title-index">3.3. </span><a href="#DKIM记录示例" class="headerlink" title="DKIM记录示例"></a>DKIM记录示例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主机记录：&lt;selector&gt;._domainkey</span><br><span class="line">记录类型：TXT</span><br><span class="line">记录值：&quot;v=DKIM1; k=rsa; p=MIGfMA0GCS...&quot;</span><br><span class="line">记录值中的k=rsa</span><br></pre></td></tr></table></figure><p>记录值字段说明：</p><ul><li><code>v=DKIM1</code>：表示使用DKIM版本1。</li><li><code>k=rsa</code>：表示公钥是以RSA方式进行加密的。</li><li><code>p=MIGfMA0GCS...</code>：公钥部分。</li></ul><p>主机记录和记录值通常由电子邮件服务商提供，比如使用腾讯企业邮箱或网易企业邮箱，就登录管理员查看DKIM配置。</p><h1 id="DMARC"><span class="post-title-index">4. </span><a href="#DMARC" class="headerlink" title="DMARC"></a>DMARC</h1><h2 id="DMARC简介"><span class="post-title-index">4.1. </span><a href="#DMARC简介" class="headerlink" title="DMARC简介"></a>DMARC简介</h2><p>DMARC全称为基于域名的消息身份验证、报告和一致性，DMARC是建立在SPF和DKIM之上的一种机制，允许域名所有者指定如何处理未通过身份验证的邮件，并提供报告功能。</p><h2 id="DMARC工作原理"><span class="post-title-index">4.2. </span><a href="#DMARC工作原理" class="headerlink" title="DMARC工作原理"></a>DMARC工作原理</h2><p>接收服务器根据DMARC策略处理未通过SPF或DKIM验证的邮件。根据设置，它可以选择拒绝、隔离或无操作。同时，发送报告给域名所有者，以便他们监控和分析身份验证结果。</p><h2 id="DMARC记录示例"><span class="post-title-index">4.3. </span><a href="#DMARC记录示例" class="headerlink" title="DMARC记录示例"></a>DMARC记录示例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机记录：_dmarc</span><br><span class="line">记录类型：TXT</span><br><span class="line">记录值：&quot;v=DMARC1; p=reject; rua=mailto:dmarc-reports@example.com&quot;</span><br></pre></td></tr></table></figure><p>记录字段说明：</p><ul><li><code>v=DMARC1</code>：表示使用DMARC版本1。</li><li><code>p=reject</code>：指示接收方拒绝未通过身份验证的邮件。</li><li><code>rua=mailto:dmarc-reports@example.com</code>：指定接收报告的电子邮件地址。</li></ul><p>腾讯企业邮推荐记录值：<code>&quot;v=DMARC1; p=none; rua=mailto:mailauth-reports@qq.com&quot;</code> </p><p>参考文档：<a href="https://open.work.weixin.qq.com/help2/pc/19820">企业邮箱如何设置DMARC（TXT记录）</a></p><h1 id="发送邮件给Gmail报错问题"><span class="post-title-index">5. </span><a href="#发送邮件给Gmail报错问题" class="headerlink" title="发送邮件给Gmail报错问题"></a>发送邮件给Gmail报错问题</h1><h2 id="问题描述"><span class="post-title-index">5.1. </span><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>发送邮件给Gmail邮箱时，报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">550-5.7.26 Your email has been blocked because the sender is unauthenticated. </span><br><span class="line">550-5.7.26 Gmail requires all senders to authenticate with either SPF or DKIM. 550-5.7.26</span><br><span class="line">550-5.7.26 Authentication results: 550-5.7.26 DKIM = did not pass</span><br><span class="line">550-5.7.26 SPF [fuzhi.ai] with ip: [128.x.x.x] = did not pass</span><br></pre></td></tr></table></figure><h2 id="解决办法"><span class="post-title-index">5.2. </span><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>报错很清晰，发送邮件的服务器被Gmail拒绝了，Gmail怀疑这是伪造的发件人，因为邮件没能通过SPF或DKIM验证。</p><p>解决办法：检查并配置SPF和DKIM。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在现代电子邮件系统中，确保邮件的安全性和可靠性至关重要。SPF、DKIM和DMARC是三种主要的电子邮件身份验证机制，它们共同工作以防止垃圾邮件、钓鱼攻击和其他形式的邮件欺诈。&lt;/p&gt;
&lt;p&gt;SPF、DKIM和DMARC机制在配置DNS时，记录类型都是TXT类型，在配置记录值时请注意DNS平台是否需要双引号。&lt;/p&gt;
&lt;p&gt;本文将学习这三种机制及其在邮箱配置中的作用。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jovialchap.com/spf-dkim-dmarc-explained/&quot;&gt;详解 SPF、DKIM、DMARC 记录与工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://powerdmarc.com/fix-this-mail-is-unauthenticated-gmail-error/&quot;&gt;550-5.7.26 Gmail Error: Email Blocked Because Sender is Unauthenticated&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://powerdmarc.com/zh/what-is-a-dns-txt-record/&quot;&gt;POWERDMARC - 什么是DNS TXT记录？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-txt-record/&quot;&gt;CloudFlare - 什么是 DNS TXT 记录？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>One API 开发环境配置</title>
    <link href="https://www.voidking.com/dev-one-api-develop/"/>
    <id>https://www.voidking.com/dev-one-api-develop/</id>
    <published>2024-10-26T08:00:00.000Z</published>
    <updated>2025-04-04T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有些情况下，我们需要基于 One API 进行二次开发，以满足特定的需求。</p><p>本文中，我们会学习 One API 的开发环境配置。</p><p>相关文档：</p><ul><li><a href="https://github.com/songquanpeng/one-api/">github - one-api</a></li><li><a href="https://www.voidking.com/dev-one-api-start/">《LLM 接口管理和分发系统 One API》</a></li><li><a href="https://www.voidking.com/dev-gin-start/">《好好学Golang：Gin框架入门篇》</a></li></ul><span id="more"></span><h2 id="获取-One-API-代码"><span class="post-title-index">2. </span><a href="#获取-One-API-代码" class="headerlink" title="获取 One API 代码"></a>获取 One API 代码</h2><h3 id="方法一：直接从源仓库获取代码"><span class="post-title-index">2.1. </span><a href="#方法一：直接从源仓库获取代码" class="headerlink" title="方法一：直接从源仓库获取代码"></a>方法一：直接从源仓库获取代码</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/songquanpeng/one-api.git</span><br></pre></td></tr></table></figure><h3 id="方法二：fork后再获取代码（推荐）"><span class="post-title-index">2.2. </span><a href="#方法二：fork后再获取代码（推荐）" class="headerlink" title="方法二：fork后再获取代码（推荐）"></a>方法二：fork后再获取代码（推荐）</h3><p>fork后再获取代码的优点，是更加容易维护。每次修改后提交到自己的仓库进行存档，还可以往源仓库中提交PR。</p><ol><li><p>fork oneapi 代码<br>浏览器访问 <a href="https://github.com/songquanpeng/one-api/">github - one-api</a> ，fork oneapi 到自己的 github 仓库。</p></li><li><p>克隆 oneapi 代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/voidking/one-api.git</span><br></pre></td></tr></table></figure></li><li><p>配置多个远程仓库（可选）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> one-api</span><br><span class="line">git remote add upstream https://github.com/songquanpeng/one-api.git</span><br></pre></td></tr></table></figure></li></ol><h2 id="本地运行-One-API"><span class="post-title-index">3. </span><a href="#本地运行-One-API" class="headerlink" title="本地运行 One API"></a>本地运行 One API</h2><h3 id="安装依赖"><span class="post-title-index">3.1. </span><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h3><ol><li><p>安装前端依赖（node版本 v20.10.0）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> one-api/web/default</span><br><span class="line">npm install</span><br><span class="line">npm run build</span><br></pre></td></tr></table></figure></li><li><p>安装后端依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> one-api</span><br><span class="line"><span class="comment"># export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890</span></span><br><span class="line">go mod tidy</span><br></pre></td></tr></table></figure></li></ol><h3 id="运行代码"><span class="post-title-index">3.2. </span><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h3><ol><li><p>运行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>运行成功的话，控制台会输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[INFO] 2025/04/08 - 17:36:38 | main.go:32 [main] One API v0.0.0 started</span><br><span class="line">[INFO] 2025/04/08 - 17:36:38 | model/main.go:103 [openSQLite] SQL_DSN not set, using SQLite as database</span><br><span class="line">[INFO] 2025/04/08 - 17:36:38 | model/main.go:129 [InitDB] database migration started</span><br><span class="line">[INFO] 2025/04/08 - 17:36:38 | model/main.go:134 [InitDB] database migrated</span><br><span class="line"></span><br><span class="line">2025/04/08 17:36:38 /path/to/one-api/model/main.go:27 record not found</span><br><span class="line">[0.437ms] [rows:0] SELECT * FROM `users` ORDER BY `users`.`id` LIMIT 1</span><br><span class="line">[INFO] 2025/04/08 - 17:36:38 | model/main.go:28 [CreateRootAccountIfNeed] no user exists, creating a root user for you: username is root, password is 123456</span><br><span class="line">[INFO] 2025/04/08 - 17:36:39 | common/redis.go:20 [InitRedisClient] REDIS_CONN_STRING not set, Redis is not enabled</span><br><span class="line">[INFO] 2025/04/08 - 17:36:39 | main.go:65 [main] using theme default</span><br><span class="line">[INFO] 2025/04/08 - 17:36:39 | relay/adaptor/openai/token.go:23 [InitTokenEncoders] initializing token encoders</span><br><span class="line">[INFO] 2025/04/08 - 17:36:40 | relay/adaptor/openai/token.go:49 [InitTokenEncoders] token encoders initialized</span><br><span class="line">[INFO] 2025/04/08 - 17:36:40 | main.go:119 [main] server started on http://localhost:3000</span><br></pre></td></tr></table></figure></li><li><p>测试访问<br>浏览器访问 <a href="http://localhost:3000/">http://localhost:3000</a><br>测试登录，默认用户名为<code>root</code>，密码为 <code>123456</code>。</p></li></ol><p>若登录成功，则证明One API本地运行环境配置完成了。</p><h2 id="VSCode中配置调试环境"><span class="post-title-index">4. </span><a href="#VSCode中配置调试环境" class="headerlink" title="VSCode中配置调试环境"></a>VSCode中配置调试环境</h2><p>参考文档：<a href="https://www.voidking.com/dev-vscode-golang-debug/">《好好学Golang：VSCode配置Golang Debug》</a></p><h2 id="One-API核心逻辑"><span class="post-title-index">5. </span><a href="#One-API核心逻辑" class="headerlink" title="One API核心逻辑"></a>One API核心逻辑</h2><p>One-API 的核心功能是将客户端的 OpenAI 格式请求转发到不同的大模型服务商，其处理流程如下：</p><ol><li><p>客户端请求：客户端发送符合 OpenAI API 格式的请求到 One-API 端点</p></li><li><p>认证与鉴权：通过中间件验证 API Key 的有效性和权限</p></li><li><p>模型映射：根据请求中的模型名称确定要使用的渠道</p></li><li><p>请求转换：将 OpenAI 格式的请求转换为目标服务商的API格式</p></li><li><p>转发请求：将转换后的请求发送到目标服务商</p></li><li><p>响应转换：将服务商的响应转换回 OpenAI 格式</p></li><li><p>返回客户端：将标准化响应返回给客户端</p></li></ol><h2 id="支持新的大模型"><span class="post-title-index">6. </span><a href="#支持新的大模型" class="headerlink" title="支持新的大模型"></a>支持新的大模型</h2><h3 id="实现思路"><span class="post-title-index">6.1. </span><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>新出现的大模型，One API并不能保证可以在第一时间支持。如果比较着急使用，那么我们可以自己进行二次开发。</p><p>实现思路如下：</p><ol><li><p>获取模型的API Key，并且通过curl验证可以正常访问该模型的API</p></li><li><p>One API 新增渠道，配置该模型的API和Key</p></li><li><p>测试新增的渠道，根据报错搜索代码，定位到报错的位置</p></li><li><p>报错的代码，打断点；请求和响应的代码，打断点；可疑的代码，打断点</p></li><li><p>测试新增的渠道，触发调试模式，跳转到断点，单步调试</p></li><li><p>修改代码以支持新的大模型，同时输出更多日志</p></li><li><p>重复4-6，直到调通整个流程</p></li></ol><h3 id="支持新的Gemini模型"><span class="post-title-index">6.2. </span><a href="#支持新的Gemini模型" class="headerlink" title="支持新的Gemini模型"></a>支持新的Gemini模型</h3><p>以支持新的 <code>gemini-2.5-pro-exp-03-25</code> 模型为例，整个实现过程遵循实现思路，需要特别说明的是curl验证方法和获取关键信息的方法。</p><h4 id="curl验证"><span class="post-title-index">6.2.1. </span><a href="#curl验证" class="headerlink" title="curl验证"></a>curl验证</h4><p>One API 渠道可用，最基础的前提是模型的API可用，<code>gemini-2.5-pro-exp-03-25</code> 模型的API验证方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&quot;https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro-exp-03-25:generateContent?key=xxx&quot;</span> \</span><br><span class="line">-H <span class="string">&#x27;Content-Type: application/json&#x27;</span> \</span><br><span class="line">-X POST \</span><br><span class="line">-d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">  &quot;contents&quot;: [&#123;</span></span><br><span class="line"><span class="string">    &quot;parts&quot;:[&#123;&quot;text&quot;: &quot;hello&quot;&#125;]</span></span><br><span class="line"><span class="string">    &#125;]</span></span><br><span class="line"><span class="string">   &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="获取关键信息"><span class="post-title-index">6.2.2. </span><a href="#获取关键信息" class="headerlink" title="获取关键信息"></a>获取关键信息</h4><p>以发送请求并获得响应为分界点，整个系统可以分为三个部分：请求头和请求体处理，发送请求并获得响应，响应内容处理。</p><p>如果有了请求相关的关键信息，那么就可以定位解决很多问题了。举个例子，假设获取到的响应不符合预期，那么我们可以直接定位到请求头和请求体处理部分有问题。<br>因此，在开发调试过程中，必须要获取到四个请求相关的关键信息：请求的URL、请求头、请求体、响应的内容。</p><p>经过单步调试，我们会发现，在 <code>relay/adaptor/common.go</code> 中的<code>DoRequestHelper</code> 和 <code>DoRequest</code> 函数中，我们可以获取到请求相关的关键信息。</p><p>打印请求体的方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// req 类型为 http.Request</span></span><br><span class="line">requestBody, err := io.ReadAll(req.Body)</span><br><span class="line">fmt.Println(<span class="string">&quot;Request Body:&quot;</span>, <span class="type">string</span>(requestBody))</span><br><span class="line"><span class="comment">// 读取Body会消耗掉Body，如果需要后续使用，需要重新赋值</span></span><br><span class="line">req.Body = io.NopCloser(bytes.NewBuffer(body))</span><br></pre></td></tr></table></figure><p>打印响应内容的方法：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// resp 类型为 http.Response </span></span><br><span class="line">responseBody, err := io.ReadAll(resp.Body)</span><br><span class="line">fmt.Println(<span class="string">&quot;Response Body:&quot;</span>, <span class="type">string</span>(responseBody))</span><br></pre></td></tr></table></figure><p>获取到请求的URL、请求头、请求体后，就可以通过curl直接发送请求了。<br>正确的curl与不正确的curl进行对比，就可以定位到问题出现在系统的哪一部分。</p><p>同样的道理，One API系统的三个部分还可以根据其他关键信息进一步细分，这样就可以达到类似于二分法定位问题的效果。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有些情况下，我们需要基于 One API 进行二次开发，以满足特定的需求。&lt;/p&gt;
&lt;p&gt;本文中，我们会学习 One API 的开发环境配置。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/songquanpeng/one-api/&quot;&gt;github - one-api&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-one-api-start/&quot;&gt;《LLM 接口管理和分发系统 One API》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-gin-start/&quot;&gt;《好好学Golang：Gin框架入门篇》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="golang" scheme="https://www.voidking.com/categories/engineering/golang/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
    <category term="aigc" scheme="https://www.voidking.com/tags/aigc/"/>
    
    <category term="llm" scheme="https://www.voidking.com/tags/llm/"/>
    
    <category term="one-api" scheme="https://www.voidking.com/tags/one-api/"/>
    
  </entry>
  
  <entry>
    <title>LLM 接口管理和分发系统 One API</title>
    <link href="https://www.voidking.com/dev-one-api-start/"/>
    <id>https://www.voidking.com/dev-one-api-start/</id>
    <published>2024-10-26T08:00:00.000Z</published>
    <updated>2025-06-01T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="One-API简介"><span class="post-title-index">1. </span><a href="#One-API简介" class="headerlink" title="One API简介"></a>One API简介</h1><p>One API是一个LLM代理系统，支持LLM接口管理和消息分发。使得用户可以通过标准的 OpenAI API 格式访问所有的大模型，开箱即用。</p><p>One API 比 <a href="https://github.com/KenyonY/openai-forward">openai-forword</a> 更强大，因为 One API 除了作为LLM代理，还可以作为LLM一个中间商系统。</p><p>相关文档：</p><ul><li><a href="https://github.com/songquanpeng/one-api/">github - one-api</a></li><li><a href="https://www.voidking.com/dev-docker-openai-api-proxy/">《好好学Docker：使用Docker安装配置OPANAI API代理》</a></li></ul><span id="more"></span><h1 id="One-API核心功能"><span class="post-title-index">2. </span><a href="#One-API核心功能" class="headerlink" title="One API核心功能"></a>One API核心功能</h1><ul><li>支持多种大模型：OpenAI、Claude、Gemini、Mistral、豆包、文心一言、通义千问、腾讯混元、SiliconCloud等等等等。</li><li>支持 stream 模式，可以通过流式传输实现打字机效果</li><li>支持绘图接口</li><li>支持失败自动重试</li><li>支持多机部署，提高并发</li><li>支持渠道管理，批量创建渠道，支持渠道设置模型列表，支持通过负载均衡访问多个渠道</li><li>支持多用户管理，支持用户额度配置，支持充值，支持用户分组以及渠道分组，支持为不同分组设置不同的倍率</li><li>支持令牌管理，设置令牌的过期时间、额度、允许的 IP 范围以及允许的模型访问</li></ul><h1 id="安装配置-One-API"><span class="post-title-index">3. </span><a href="#安装配置-One-API" class="headerlink" title="安装配置 One API"></a>安装配置 One API</h1><h2 id="安装配置-One-API-概述"><span class="post-title-index">3.1. </span><a href="#安装配置-One-API-概述" class="headerlink" title="安装配置 One API 概述"></a>安装配置 One API 概述</h2><p>One API 提供了多种安装部署方式，包括Docker部署、裸机编译部署、多机部署、宝塔部署、第三方平台一键部署等。<br>本文中选择使用Docker部署，数据库选择MySQL，不使用Redis。</p><h2 id="安装MySQL（可选）"><span class="post-title-index">3.2. </span><a href="#安装MySQL（可选）" class="headerlink" title="安装MySQL（可选）"></a>安装MySQL（可选）</h2><p>1、安装MySQL8，参考文档<a href="https://www.voidking.com/dev-docker-mysql/">好好学MySQL：使用Docker安装配置MySQL</a></p><p>2、创建一个数据库，名称为 oneapi</p><h2 id="安装-One-API"><span class="post-title-index">3.3. </span><a href="#安装-One-API" class="headerlink" title="安装 One API"></a>安装 One API</h2><p>1、下载 one-api 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull justsong/one-api:v0.6.10-alpha.1</span><br></pre></td></tr></table></figure><p>2、运行 one-api 容器<br>使用SQLite数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name one-api -d \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 3000:3000 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -v /opt/one-api/data:/data \</span><br><span class="line">  justsong/one-api:v0.6.11-alpha.8</span><br></pre></td></tr></table></figure><p>备用镜像地址：<code>ghcr.io/songquanpeng/one-api:v0.6.11-alpha.8</code></p><p>使用MySQL数据库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name one-api -d \</span><br><span class="line">  --restart always \</span><br><span class="line">  -p 3000:3000 \</span><br><span class="line">  -e SQL_DSN=<span class="string">&quot;root:123456@tcp(localhost:3306)/oneapi&quot;</span> \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -v /opt/one-api/data:/data \</span><br><span class="line">  justsong/one-api:v0.6.11-alpha.8</span><br></pre></td></tr></table></figure><p>其中，SQL_DSN的值要改成自己的MySQL配置。</p><p>3、查看容器状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep one-api</span><br><span class="line">docker logs one-api</span><br></pre></td></tr></table></figure><h2 id="配置Nginx"><span class="post-title-index">3.4. </span><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h2><p>参考配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  server_name oneapi.voidking.com;  # 请根据实际情况修改你的域名</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    client_max_body_size  64m;</span><br><span class="line">    proxy_http_version 1.1;</span><br><span class="line">    proxy_pass http://localhost:3000;  # 请根据实际情况修改你的端口</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class="line">    proxy_cache_bypass $http_upgrade;</span><br><span class="line">    proxy_set_header Accept-Encoding gzip;</span><br><span class="line">    proxy_read_timeout 300s;  # GPT-4 需要较长的超时时间，请自行调整</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用-One-API"><span class="post-title-index">4. </span><a href="#使用-One-API" class="headerlink" title="使用 One API"></a>使用 One API</h1><h2 id="登录-One-API"><span class="post-title-index">4.1. </span><a href="#登录-One-API" class="headerlink" title="登录 One API"></a>登录 One API</h2><p>1、使用 <code>IP+端口</code> 或者 <code>域名</code> 访问 One API 首页</p><p>2、点击页面右上角 登录，登录进入管理页面<br>默认用户名为 <code>root</code> ，密码为 <code>123456</code>，登录后请先修改密码</p><h2 id="系统配置"><span class="post-title-index">4.2. </span><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h2><h3 id="配置服务器地址"><span class="post-title-index">4.2.1. </span><a href="#配置服务器地址" class="headerlink" title="配置服务器地址"></a>配置服务器地址</h3><p>1、点击设置</p><p>2、配置服务器地址<br>该地址要和配置的域名一致。</p><h3 id="配置用户登录和注册方式"><span class="post-title-index">4.2.2. </span><a href="#配置用户登录和注册方式" class="headerlink" title="配置用户登录和注册方式"></a>配置用户登录和注册方式</h3><p>1、点击设置</p><p>2、配置登录注册部分，选择登录和注册方式</p><p>3、配置邮箱域名白名单</p><h2 id="配置渠道"><span class="post-title-index">4.3. </span><a href="#配置渠道" class="headerlink" title="配置渠道"></a>配置渠道</h2><p>1、点击渠道，添加新的渠道</p><p>2、填入渠道信息</p><ul><li>选择类型</li><li>填入名称</li><li>选择分组</li><li>选择模型或者填入模型</li><li>填入密钥</li><li>部分类型需要填入 base_url</li><li>填入模型重定向（可选）</li></ul><p>填入的模型，其实是oneapi中的模型名，默认与真实模型名相同。如果oneapi中的模型名，与真实模型名不同，那么可以配置模型重定向。<br>例如：oneapi中模型名是 gpt3.5-test，真实模型名是 gpt-3.5-turbo-16k ，那么模型重定向配置如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;gpt3.5-test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gpt-3.5-turbo-16k&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>3、提交，并点击测试</p><p>注意：根据个人经验，添加渠道并且测试成功后，并不能立刻通过API调用。<br>如果立刻调用，会报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openai.InternalServerError: Error code: 503 - &#123;&#x27;error&#x27;: &#123;&#x27;message&#x27;: &#x27;当前分组 default 下对于模型 xxx 无可用渠道 (request id: xxx)&#x27;, &#x27;type&#x27;: &#x27;one_api_error&#x27;&#125;&#125;</span><br></pre></td></tr></table></figure><p>需要等待2到3分钟，再进行API调用才会正常，也许是oneapi的什么机制。</p><h2 id="配置额度"><span class="post-title-index">4.4. </span><a href="#配置额度" class="headerlink" title="配置额度"></a>配置额度</h2><p>1、点击用户，选择某一个用户，编辑</p><p>2、剩余额度填入 token 数，会自动显示等价金额<br>100000 token，等价金额 0.2 刀</p><p>3、提交</p><h2 id="配置令牌"><span class="post-title-index">4.5. </span><a href="#配置令牌" class="headerlink" title="配置令牌"></a>配置令牌</h2><p>1、用户登录 One API</p><p>2、点击令牌，添加新的令牌</p><p>3、填入令牌信息</p><ul><li>名称</li><li>模型范围</li><li>IP限制</li><li>过期时间</li><li>额度</li></ul><p>4、提交</p><p>5、复制 token<br>找到新创建的令牌，点击复制，就可以获取到 token<br>注意：该 token 对应的 base_url 是我们配置的域名 <code>https://oneapi.voidking.com/v1</code></p><p>6、聊天<br>找到新创建的令牌，点击聊天，会自动跳转到 <a href="https://app.nextchat.dev/#/">NextChat</a>，同时提示自动填入 base_url 和 token，点击确定，就可以使用 One API 代理进行聊天了。</p><h1 id="模型价格与倍率"><span class="post-title-index">5. </span><a href="#模型价格与倍率" class="headerlink" title="模型价格与倍率"></a>模型价格与倍率</h1><p>参考文档：</p><ul><li><a href="https://github.com/songquanpeng/one-api/?tab=readme-ov-file#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">one-api 常见问题</a></li><li><a href="https://linux.do/t/topic/79867">oneapi倍率讨论</a></li><li><a href="https://shabi.uk/">倍率计算器</a></li></ul><p>模型倍率和补全倍率算法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">基准价格：0.002 $ /1k tokens</span><br><span class="line">模型倍率 = 输入价格 / 基准价格</span><br><span class="line">补全倍率 = 输出价格 / 输入价格</span><br></pre></td></tr></table></figure><p>假设X模型的价格为 <code>$0.18/M input tokens</code> 和 <code>$0.72/M output tokens</code>，那么它的模型倍率和补全倍率如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">模型倍率 = 输入价格 / 基准价格 = (0.18/1000) / 0.002 = 0.09</span><br><span class="line">补全倍率 = 输出价格 / 输入价格 = 0.72 / 0.18 = 4</span><br></pre></td></tr></table></figure><p>在oneapi代码中，在计算费用时，涉及到变量包括：</p><ul><li>model_name：模型名（针对模型名配置模型倍率和补全倍率）</li><li>base_price：基准价格，<code>0.002 $ /1k tokens</code></li><li>prompt_tokens：提示词token数</li><li>completion_tokens：返回token数</li><li>model_ratio：模型倍率</li><li>completion_ratio：补全倍率</li><li>group_ratio：分组倍率（针对不同用户类型，控制打折或溢价）</li><li>quota：某个大模型的提示词token数和返回token数，换算成基准价格token数</li></ul><p>变量关系如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quota = ((prompt_tokens * model_ratio) + (completion_ratio * model_ratio * completion_ratio)) * group_ratio</span><br></pre></td></tr></table></figure><p>最终费用为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cost = quota * base_price = quota * (0.002/1000)</span><br></pre></td></tr></table></figure><h1 id="API-调用-One-API"><span class="post-title-index">6. </span><a href="#API-调用-One-API" class="headerlink" title="API 调用 One API"></a>API 调用 One API</h1><p>参考文档：</p><ul><li><a href="https://platform.openai.com/docs/quickstart">OpenAI - Developer quickstart</a></li><li><a href="https://openrouter.ai/docs/quickstart">OpenRouter - Quickstart</a></li></ul><h2 id="curl调用测试"><span class="post-title-index">6.1. </span><a href="#curl调用测试" class="headerlink" title="curl调用测试"></a>curl调用测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">&quot;https://oneapi.voidking.com/v1/chat/completions&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Authorization: Bearer &lt;ONE_API_KEY&gt;&quot;</span> \</span><br><span class="line">    -d <span class="string">&#x27;&#123;</span></span><br><span class="line"><span class="string">        &quot;model&quot;: &quot;gpt-3.5-turbo-16k&quot;,</span></span><br><span class="line"><span class="string">        &quot;messages&quot;: [</span></span><br><span class="line"><span class="string">            &#123;</span></span><br><span class="line"><span class="string">                &quot;role&quot;: &quot;user&quot;,</span></span><br><span class="line"><span class="string">                &quot;content&quot;: &quot;hello!&quot;</span></span><br><span class="line"><span class="string">            &#125;</span></span><br><span class="line"><span class="string">        ]</span></span><br><span class="line"><span class="string">    &#125;&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="python调用测试"><span class="post-title-index">6.2. </span><a href="#python调用测试" class="headerlink" title="python调用测试"></a>python调用测试</h2><p>1、编写测试脚本 test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> openai <span class="keyword">import</span> OpenAI</span><br><span class="line"></span><br><span class="line">client = OpenAI(</span><br><span class="line">  base_url=<span class="string">&quot;https://oneapi.voidking.com/v1&quot;</span>,</span><br><span class="line">  api_key=<span class="string">&quot;&lt;ONE_API_KEY&gt;&quot;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">completion = client.chat.completions.create(</span><br><span class="line">  model=<span class="string">&quot;gpt-3.5-turbo-16k&quot;</span>,</span><br><span class="line">  messages=[</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;role&quot;</span>: <span class="string">&quot;user&quot;</span>,</span><br><span class="line">      <span class="string">&quot;content&quot;</span>: <span class="string">&quot;hello!&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(completion.choices[<span class="number">0</span>].message.content)</span><br></pre></td></tr></table></figure><p>2、运行脚本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python test.py</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;One-API简介&quot;&gt;&lt;a href=&quot;#One-API简介&quot; class=&quot;headerlink&quot; title=&quot;One API简介&quot;&gt;&lt;/a&gt;One API简介&lt;/h1&gt;&lt;p&gt;One API是一个LLM代理系统，支持LLM接口管理和消息分发。使得用户可以通过标准的 OpenAI API 格式访问所有的大模型，开箱即用。&lt;/p&gt;
&lt;p&gt;One API 比 &lt;a href=&quot;https://github.com/KenyonY/openai-forward&quot;&gt;openai-forword&lt;/a&gt; 更强大，因为 One API 除了作为LLM代理，还可以作为LLM一个中间商系统。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/songquanpeng/one-api/&quot;&gt;github - one-api&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-docker-openai-api-proxy/&quot;&gt;《好好学Docker：使用Docker安装配置OPANAI API代理》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
    <category term="aigc" scheme="https://www.voidking.com/tags/aigc/"/>
    
    <category term="llm" scheme="https://www.voidking.com/tags/llm/"/>
    
    <category term="one-api" scheme="https://www.voidking.com/tags/one-api/"/>
    
  </entry>
  
  <entry>
    <title>好好学K8S：K8S中的Leader Election机制</title>
    <link href="https://www.voidking.com/dev-k8s-leader-election/"/>
    <id>https://www.voidking.com/dev-k8s-leader-election/</id>
    <published>2024-10-19T08:00:00.000Z</published>
    <updated>2024-10-19T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求描述"><span class="post-title-index">1. </span><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>假设有一个基于client-go的程序，叫做watcher，会监听k8s集群中pod被删除的消息，当pod被删除时，会触发执行一个动作。<br>当watcher只有一个副本时，程序运行符合预期。但是当watcher有多个副本时，多个watcher副本都监听到pod被删除的消息，都会触发执行一个动作。而这个动作，我们希望只执行一次。<br>有什么办法，可以让多个watcher具备多个副本，但是当监听到pod被删除时，只会触发一次执行动作？</p><span id="more"></span><h1 id="实现思路"><span class="post-title-index">2. </span><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>要实现这个需求，有三个思路：</p><ul><li>思路一：基于K8S ValidatingAdmissionWebhook机制。实现一个ValidatingAdmissionWebhook，限制watcher服务只能有一个副本。watcher服务只有一个副本，自然就只会执行一次动作，但是，与需求不相符，不能高可用。</li><li>思路二：基于分布式锁。常见的实现方式包括使用 redis、zookeeper 或 etcd 等工具。这种实现方式简单，但是需要额外维护一个中间件，不够优雅。</li><li>思路三：基于K8S Leader Election机制。K8S 提供了 Leader Election 机制，可以通过 client-go 库实现，只有被选为 Leader 的 watcher 才会处理 pod 删除事件。</li></ul><p>本文中选择思路三（K8S Leader Election机制）来实现需求：服务多个副本但是只执行一次动作。</p><p>参考文档：</p><ul><li><a href="https://isekiro.com/kubernetes%E6%BA%90%E7%A0%81-%E6%8E%A7%E5%88%B6%E5%99%A8-leader-%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/">kubernetes源码-控制器 leader 选举机制</a></li><li><a href="https://juejin.cn/post/7157648925078323207">k8s(kubernetes) 使用leader election实现选举</a></li></ul><h1 id="Leader-Election机制简介"><span class="post-title-index">3. </span><a href="#Leader-Election机制简介" class="headerlink" title="Leader Election机制简介"></a>Leader Election机制简介</h1><h2 id="Leader-Election原理"><span class="post-title-index">3.1. </span><a href="#Leader-Election原理" class="headerlink" title="Leader Election原理"></a>Leader Election原理</h2><p>Leader Election 是一种分布式系统中的机制，旨在确保在多个候选者中选出一个“领导者”进程，以负责执行特定的操作。</p><p>1、候选者识别：在 Leader Election 中，首先需要识别出一组候选者，这些候选者可能是运行在同一集群中的多个实例（如 Pods）。这些候选者会竞争成为领导者。</p><p>2、竞选过程：候选者通过某种方式（如心跳信号）宣告自己为领导者。通常，所有候选者会尝试同时声明自己为领导者。其中一个候选者成功地获得领导权，而其他候选者则进入待命状态，准备在当前领导者失效时进行新的竞选。</p><p>3、心跳机制：一旦某个实例成为领导者，它会定期发送心跳信号以维持其领导地位。如果领导者未能在预定时间内发送心跳信号，其他候选者将启动新的竞选过程，以确保始终有一个活跃的领导者。</p><p>4、故障恢复：当当前领导者发生故障或被终止时，其他候选者会迅速重新进行竞选，以确定新的领导者。这种机制保证了系统的高可用性。</p><h1 id="K8S-中的-Leader-Election-实现"><span class="post-title-index">4. </span><a href="#K8S-中的-Leader-Election-实现" class="headerlink" title="K8S 中的 Leader Election 实现"></a>K8S 中的 Leader Election 实现</h1><p>Kubernetes 提供了一种简化的方式来实现 Leader Election，相关概念包括资源锁和Lease API。</p><ul><li>资源锁：Kubernetes 使用 <code>ConfigMap</code> 或 <code>Lease</code> 等资源作为锁来管理领导权。每个候选者尝试更新这个资源以声明自己为领导者。例如，通过更新 <code>ConfigMap</code> 中的某个字段来表示当前的领导者。</li><li>Lease API：Kubernetes 从 v1.14 开始引入了 <code>coordination.k8s.io</code> API，允许更高效地管理领导权。使用 Lease 对象可以减少对 API 的调用频率，并避免过多的事件通知。</li></ul><p>选举过程：<br>1、候选者创建或获取 Lease 对象，并尝试更新其内容以表明其身份。<br>2、只有第一个成功更新 Lease 的实例能够获得领导权。<br>3、其他实例在发现 Lease 被更新后，将停止尝试并进入待命状态。</p><p>选举机制保证了控制器的高可用，同时只有一个控制器为主，其他为从，防止同个事件被多次重复监听，重复执行相关的业务逻辑。</p><h1 id="Leader-Election示例代码"><span class="post-title-index">5. </span><a href="#Leader-Election示例代码" class="headerlink" title="Leader Election示例代码"></a>Leader Election示例代码</h1><p>示例代码地址：<a href="https://github.com/kubernetes/client-go/tree/master/examples/leader-election">examples - leader-election</a></p><p>1、创建示例项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> leader-election-demo &amp;&amp; <span class="built_in">cd</span> leader-election-demo</span><br><span class="line">go mod init leader-election-demo</span><br></pre></td></tr></table></figure><p>2、粘贴示例代码<br>创建文件 main.go ，并且把示例代码粘贴进去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright 2018 The Kubernetes Authors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/google/uuid&quot;</span></span><br><span class="line">    metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line">    clientset <span class="string">&quot;k8s.io/client-go/kubernetes&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/client-go/rest&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/client-go/tools/leaderelection&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/client-go/tools/leaderelection/resourcelock&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/klog/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildConfig</span><span class="params">(kubeconfig <span class="type">string</span>)</span></span> (*rest.Config, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> kubeconfig != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        cfg, err := clientcmd.BuildConfigFromFlags(<span class="string">&quot;&quot;</span>, kubeconfig)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cfg, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cfg, err := rest.InClusterConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cfg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    klog.InitFlags(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> kubeconfig <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> leaseLockName <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> leaseLockNamespace <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> id <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    flag.StringVar(&amp;kubeconfig, <span class="string">&quot;kubeconfig&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;absolute path to the kubeconfig file&quot;</span>)</span><br><span class="line">    flag.StringVar(&amp;id, <span class="string">&quot;id&quot;</span>, uuid.New().String(), <span class="string">&quot;the holder identity name&quot;</span>)</span><br><span class="line">    flag.StringVar(&amp;leaseLockName, <span class="string">&quot;lease-lock-name&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;the lease lock resource name&quot;</span>)</span><br><span class="line">    flag.StringVar(&amp;leaseLockNamespace, <span class="string">&quot;lease-lock-namespace&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;the lease lock resource namespace&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> leaseLockName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        klog.Fatal(<span class="string">&quot;unable to get lease lock resource name (missing lease-lock-name flag).&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> leaseLockNamespace == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        klog.Fatal(<span class="string">&quot;unable to get lease lock resource namespace (missing lease-lock-namespace flag).&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leader election uses the Kubernetes API by writing to a</span></span><br><span class="line">    <span class="comment">// lock object, which can be a LeaseLock object (preferred),</span></span><br><span class="line">    <span class="comment">// a ConfigMap, or an Endpoints (deprecated) object.</span></span><br><span class="line">    <span class="comment">// Conflicting writes are detected and each client handles those actions</span></span><br><span class="line">    <span class="comment">// independently.</span></span><br><span class="line">    config, err := buildConfig(kubeconfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    client := clientset.NewForConfigOrDie(config)</span><br><span class="line"></span><br><span class="line">    run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// complete your controller loop here</span></span><br><span class="line">        klog.Info(<span class="string">&quot;Controller loop...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use a Go context so we can tell the leaderelection code when we</span></span><br><span class="line">    <span class="comment">// want to step down</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for interrupts or the Linux SIGTERM signal and cancel</span></span><br><span class="line">    <span class="comment">// our context, which the leader election code will observe and</span></span><br><span class="line">    <span class="comment">// step down</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(ch, os.Interrupt, syscall.SIGTERM)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">        klog.Info(<span class="string">&quot;Received termination, signaling shutdown&quot;</span>)</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we use the Lease lock type since edits to Leases are less common</span></span><br><span class="line">    <span class="comment">// and fewer objects in the cluster watch &quot;all Leases&quot;.</span></span><br><span class="line">    lock := &amp;resourcelock.LeaseLock&#123;</span><br><span class="line">        LeaseMeta: metav1.ObjectMeta&#123;</span><br><span class="line">            Name:      leaseLockName,</span><br><span class="line">            Namespace: leaseLockNamespace,</span><br><span class="line">        &#125;,</span><br><span class="line">        Client: client.CoordinationV1(),</span><br><span class="line">        LockConfig: resourcelock.ResourceLockConfig&#123;</span><br><span class="line">            Identity: id,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the leader election code loop</span></span><br><span class="line">    leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;</span><br><span class="line">        Lock: lock,</span><br><span class="line">        <span class="comment">// IMPORTANT: you MUST ensure that any code you have that</span></span><br><span class="line">        <span class="comment">// is protected by the lease must terminate **before**</span></span><br><span class="line">        <span class="comment">// you call cancel. Otherwise, you could have a background</span></span><br><span class="line">        <span class="comment">// loop still running and another process could</span></span><br><span class="line">        <span class="comment">// get elected before your background loop finished, violating</span></span><br><span class="line">        <span class="comment">// the stated goal of the lease.</span></span><br><span class="line">        ReleaseOnCancel: <span class="literal">true</span>,</span><br><span class="line">        LeaseDuration:   <span class="number">60</span> * time.Second,</span><br><span class="line">        RenewDeadline:   <span class="number">15</span> * time.Second,</span><br><span class="line">        RetryPeriod:     <span class="number">5</span> * time.Second,</span><br><span class="line">        Callbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class="line">            OnStartedLeading: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">                <span class="comment">// we&#x27;re notified when we start - this is where you would</span></span><br><span class="line">                <span class="comment">// usually put your code</span></span><br><span class="line">                run(ctx)</span><br><span class="line">            &#125;,</span><br><span class="line">            OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// we can do cleanup here</span></span><br><span class="line">                klog.Infof(<span class="string">&quot;leader lost: %s&quot;</span>, id)</span><br><span class="line">                os.Exit(<span class="number">0</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            OnNewLeader: <span class="function"><span class="keyword">func</span><span class="params">(identity <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// we&#x27;re notified when new leader elected</span></span><br><span class="line">                <span class="keyword">if</span> identity == id &#123;</span><br><span class="line">                    <span class="comment">// I just got the lock</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                klog.Infof(<span class="string">&quot;new leader elected: %s&quot;</span>, identity)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>4、运行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># first terminal</span></span><br><span class="line">go run main.go -kubeconfig=/path/to/kubeconfig -logtostderr=<span class="literal">true</span> -lease-lock-name=example -lease-lock-namespace=default -<span class="built_in">id</span>=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># second terminal</span></span><br><span class="line">go run main.go -kubeconfig=/path/to/kubeconfig -logtostderr=<span class="literal">true</span> -lease-lock-name=example -lease-lock-namespace=default -<span class="built_in">id</span>=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># third terminal</span></span><br><span class="line">go run main.go -kubeconfig=/path/to/kubeconfig -logtostderr=<span class="literal">true</span> -lease-lock-name=example -lease-lock-namespace=default -<span class="built_in">id</span>=3</span><br></pre></td></tr></table></figure><p>5、查看lease</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get lease</span><br></pre></td></tr></table></figure><p>看到如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME      HOLDER   AGE</span><br><span class="line">example   1        104s</span><br></pre></td></tr></table></figure><p>6、结束1号进程，再次查看lease<br>看到如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME      HOLDER   AGE</span><br><span class="line">example   3        3m12s</span><br></pre></td></tr></table></figure><p>上面的示例，可以证明Leader Election机制已经生效了。当1号进程不可用时，另外的两个进程其中之一会成为领导者。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h1&gt;&lt;p&gt;假设有一个基于client-go的程序，叫做watcher，会监听k8s集群中pod被删除的消息，当pod被删除时，会触发执行一个动作。&lt;br&gt;当watcher只有一个副本时，程序运行符合预期。但是当watcher有多个副本时，多个watcher副本都监听到pod被删除的消息，都会触发执行一个动作。而这个动作，我们希望只执行一次。&lt;br&gt;有什么办法，可以让多个watcher具备多个副本，但是当监听到pod被删除时，只会触发一次执行动作？&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="golang" scheme="https://www.voidking.com/categories/engineering/golang/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    
    <category term="golang" scheme="https://www.voidking.com/tags/golang/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="好好学K8S" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6K8S/"/>
    
    <category term="client-go" scheme="https://www.voidking.com/tags/client-go/"/>
    
    <category term="kubectl" scheme="https://www.voidking.com/tags/kubectl/"/>
    
  </entry>
  
  <entry>
    <title>好好学Golang：Viper库</title>
    <link href="https://www.voidking.com/dev-golang-viper/"/>
    <id>https://www.voidking.com/dev-golang-viper/</id>
    <published>2024-10-06T08:00:00.000Z</published>
    <updated>2024-10-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Viper库简介"><span class="post-title-index">1. </span><a href="#Viper库简介" class="headerlink" title="Viper库简介"></a>Viper库简介</h1><p>Viper是一个功能强大的Go语言配置管理库，旨在简化应用程序的配置处理。它支持多种配置文件格式，并能够从多种来源读取配置，适合现代应用程序的需求。Viper使得开发者能够专注于业务逻辑，而不必过多担心配置管理的问题。</p><p>参考文档：</p><ul><li><a href="https://github.com/spf13/viper">github - spf13/viper</a></li><li><a href="https://juejin.cn/post/7096416508054044685">配置解析神器viper使用详解</a></li><li><a href="https://www.jiguiquan.com/?p=3902">Go语言功能齐全的配置管理库-Viper</a></li></ul><span id="more"></span><h1 id="Viper的特性"><span class="post-title-index">2. </span><a href="#Viper的特性" class="headerlink" title="Viper的特性"></a>Viper的特性</h1><ul><li>多种配置格式支持: Viper可以读取JSON、TOML、YAML、HCL、INI、envfile和Java properties等格式的配置文件。</li><li>环境变量支持: Viper可以从环境变量中读取配置。</li><li>命令行参数: 通过与<code>pflag</code>等库结合，Viper能够处理命令行参数，并优先覆盖其他配置来源。</li><li>实时监控: Viper支持实时监控配置文件的变动，并能在文件变化时自动重新加载配置。</li><li>远程配置系统: Viper可以从远程配置系统（如etcd或Consul）读取和监控配置变化。</li><li>默认值设置: 可以为不同的配置选项设置默认值，以确保应用在没有提供特定配置时仍能正常运行。</li><li>别名系统: Viper允许为参数设置别名，以便在不破坏现有代码的情况下重命名参数。</li></ul><h1 id="Viper读取配置的优先级"><span class="post-title-index">3. </span><a href="#Viper读取配置的优先级" class="headerlink" title="Viper读取配置的优先级"></a>Viper读取配置的优先级</h1><p>Viper支持从多个数据源读取配置值，因此当同一个配置key在多个数据源有值时，Viper读取配置的优先级从高到低如下：</p><ul><li>set：显示使用Set函数设置值</li><li>flag：命令行参数</li><li>env：环境变量</li><li>config：配置文件</li><li>key/value store：key/value存储系统，如 etcd</li><li>default：默认值</li></ul><h1 id="Viper读取环境变量"><span class="post-title-index">4. </span><a href="#Viper读取环境变量" class="headerlink" title="Viper读取环境变量"></a>Viper读取环境变量</h1><p>Viper读取环境变量，和读取配置文件中的变量，有很大不同：</p><ul><li>Viper的key不区分大小写，内部会统一转为小写</li><li>配置文件中的变量名，对应到环境变量中，全部大写</li><li>环境变量不方便表示层级，因此在层级key和环境变量对应时，通常把点和中划线替换为下划线</li></ul><h1 id="安装Viper"><span class="post-title-index">5. </span><a href="#安装Viper" class="headerlink" title="安装Viper"></a>安装Viper</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure><h1 id="Viper简单示例"><span class="post-title-index">6. </span><a href="#Viper简单示例" class="headerlink" title="Viper简单示例"></a>Viper简单示例</h1><p>以下是一个简单的示例，展示如何使用Viper加载YAML配置文件并从环境变量中覆盖某些值。</p><p>1、初始化一个golang项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> viper-demo &amp;&amp; <span class="built_in">cd</span> viper-demo</span><br><span class="line">go mod init viper-demo</span><br><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure><p>2、创建配置文件 config.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">addr:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>3、编写代码 main.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="type">string</span> </span><br><span class="line">    Port <span class="type">int</span>   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置读取的配置文件名和路径</span></span><br><span class="line">    viper.SetConfigName(<span class="string">&quot;config&quot;</span>) <span class="comment">// 配置文件名，不需要扩展名</span></span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)    <span class="comment">// 配置文件类型</span></span><br><span class="line">    viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)       <span class="comment">// 配置文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置</span></span><br><span class="line">    <span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;无法读取配置文件: %s&quot;</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用环境变量支持，从环境变量中覆盖配置</span></span><br><span class="line">    viper.AutomaticEnv()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最终的配置信息</span></span><br><span class="line">    config := Config&#123;</span><br><span class="line">        Addr: viper.GetString(<span class="string">&quot;addr&quot;</span>),</span><br><span class="line">        Port: viper.GetInt(<span class="string">&quot;port&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;地址: %s, 端口: %d\n&quot;</span>, config.Addr, config.Port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行 main.go</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>5、环境变量覆盖配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ADDR=127.0.0.1 </span><br><span class="line"><span class="comment"># export addr=127.0.0.1 # 小写是错误的</span></span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><h1 id="Viper层级配置示例"><span class="post-title-index">7. </span><a href="#Viper层级配置示例" class="headerlink" title="Viper层级配置示例"></a>Viper层级配置示例</h1><p>1、修改配置文件 config.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>2、编写代码 main.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="type">string</span> </span><br><span class="line">    Port <span class="type">int</span>   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置读取的配置文件名和路径</span></span><br><span class="line">    viper.SetConfigName(<span class="string">&quot;config&quot;</span>) <span class="comment">// 配置文件名，不需要扩展名</span></span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)    <span class="comment">// 配置文件类型</span></span><br><span class="line">    viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)       <span class="comment">// 配置文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置</span></span><br><span class="line">    <span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;无法读取配置文件: %s&quot;</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用环境变量支持，从环境变量中覆盖配置</span></span><br><span class="line">    viper.AutomaticEnv()</span><br><span class="line">    <span class="comment">// 匹配环境变量时，将配置Key中的点号(.)和横杠(-)替换为下划线(_)</span></span><br><span class="line">    viper.SetEnvKeyReplacer(strings.NewReplacer(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;_&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最终的配置信息</span></span><br><span class="line">    config := Config&#123;</span><br><span class="line">        Addr: viper.GetString(<span class="string">&quot;http.addr&quot;</span>),</span><br><span class="line">        Port: viper.GetInt(<span class="string">&quot;http.port&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;地址: %s, 端口: %d\n&quot;</span>, config.Addr, config.Port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、运行 main.go</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>4、环境变量覆盖配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HTTP_ADDR=127.0.0.1 </span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><h1 id="Viper层级配置示例进阶"><span class="post-title-index">8. </span><a href="#Viper层级配置示例进阶" class="headerlink" title="Viper层级配置示例进阶"></a>Viper层级配置示例进阶</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    HTTP <span class="keyword">struct</span> &#123;</span><br><span class="line">        Addr <span class="type">string</span> </span><br><span class="line">        Port <span class="type">int</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置读取的配置文件名和路径</span></span><br><span class="line">    viper.SetConfigName(<span class="string">&quot;config&quot;</span>) <span class="comment">// 配置文件名，不需要扩展名</span></span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)    <span class="comment">// 配置文件类型</span></span><br><span class="line">    viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)       <span class="comment">// 配置文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置</span></span><br><span class="line">    <span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;无法读取配置文件: %s&quot;</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从环境变量中覆盖配置</span></span><br><span class="line">    viper.AutomaticEnv() <span class="comment">// 启用环境变量支持</span></span><br><span class="line">    <span class="comment">// 匹配环境变量时，将配置Key中的点号(.)和横杠(-)替换为下划线(_)</span></span><br><span class="line">    viper.SetEnvKeyReplacer(strings.NewReplacer(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;_&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将配置文件反序列化为 config 对象</span></span><br><span class="line">    <span class="keyword">var</span> config *Config</span><br><span class="line">    <span class="keyword">if</span> err := viper.Unmarshal(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;地址: %s, 端口: %d\n&quot;</span>, config.HTTP.Addr, config.HTTP.Port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Viper库简介&quot;&gt;&lt;a href=&quot;#Viper库简介&quot; class=&quot;headerlink&quot; title=&quot;Viper库简介&quot;&gt;&lt;/a&gt;Viper库简介&lt;/h1&gt;&lt;p&gt;Viper是一个功能强大的Go语言配置管理库，旨在简化应用程序的配置处理。它支持多种配置文件格式，并能够从多种来源读取配置，适合现代应用程序的需求。Viper使得开发者能够专注于业务逻辑，而不必过多担心配置管理的问题。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/spf13/viper&quot;&gt;github - spf13/viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7096416508054044685&quot;&gt;配置解析神器viper使用详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jiguiquan.com/?p=3902&quot;&gt;Go语言功能齐全的配置管理库-Viper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="golang" scheme="https://www.voidking.com/categories/engineering/golang/"/>
    
    
    <category term="golang" scheme="https://www.voidking.com/tags/golang/"/>
    
    <category term="好好学Golang" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Golang/"/>
    
  </entry>
  
  <entry>
    <title>好好学K8S：Pod网络限速</title>
    <link href="https://www.voidking.com/dev-k8s-pod-network-speed-limit/"/>
    <id>https://www.voidking.com/dev-k8s-pod-network-speed-limit/</id>
    <published>2024-10-06T08:00:00.000Z</published>
    <updated>2025-04-04T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为避免Pod打满带宽，有时需要对Pod进行限速。<br>本文中，我们就来学习一下Pod中的网络限速方法。</p><p>相关文档：</p><ul><li><a href="https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/configure-bandwidth-limits-for-pods-in-flannel">为Pod配置带宽限制</a></li><li><a href="https://www.alibabacloud.com/help/en/eci/user-guide/configure-the-bandwidth-of-a-pod-1">Limit the inbound and outbound bandwidth of pods</a></li><li><a href="https://www.voidking.com/dev-k8s-network-policy/">《好好学K8S：K8S中的网络策略》</a></li><li><a href="https://www.voidking.com/dev-docker-container-network-speed-limit/">《好好学K8S：Pod网络限速》</a></li></ul><span id="more"></span><h1 id="Pod网络限速思路"><span class="post-title-index">2. </span><a href="#Pod网络限速思路" class="headerlink" title="Pod网络限速思路"></a>Pod网络限速思路</h1><p>1、CNI插件需要支持带宽限速<br>2、Pod中配置注解</p><p>注意：这种限速方式，对内网和外网都有效。</p><h1 id="CNI插件启用带宽限速"><span class="post-title-index">3. </span><a href="#CNI插件启用带宽限速" class="headerlink" title="CNI插件启用带宽限速"></a>CNI插件启用带宽限速</h1><h2 id="Flannel"><span class="post-title-index">3.1. </span><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h2><p>1、编辑flannel插件的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit cm -n kube-system kube-flannel-cfg</span><br></pre></td></tr></table></figure><p>plugins 配置中，增加 bandwidth 配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">cni-conf.json:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;name&quot;: &quot;cb0&quot;,</span></span><br><span class="line"><span class="string">      &quot;cniVersion&quot;:&quot;0.3.1&quot;,</span></span><br><span class="line"><span class="string">      &quot;plugins&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;bandwidth&quot;,</span></span><br><span class="line"><span class="string">          &quot;capabilities&quot;: &#123;&quot;bandwidth&quot;: true&#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure><p>2、重建flannel pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system delete pod -l app=flannel</span><br></pre></td></tr></table></figure><h2 id="Calico"><span class="post-title-index">3.2. </span><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h2><p>1、编辑calico插件的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/cni/net.d/10-calico.conflist</span><br></pre></td></tr></table></figure><p>plugins 配置中，增加 bandwidth 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k8s-pod-network&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bandwidth&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;bandwidth&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>2、重建calico pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n calico-system delete pod -l k8s-app=calico-node</span><br></pre></td></tr></table></figure><h1 id="Pod中配置注解"><span class="post-title-index">4. </span><a href="#Pod中配置注解" class="headerlink" title="Pod中配置注解"></a>Pod中配置注解</h1><p>1、pod中添加限速注解</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress-bandwidth:</span> <span class="string">&quot;1M&quot;</span>  <span class="comment"># 限制入站带宽为 1 Mbps，单位bit</span></span><br><span class="line">    <span class="attr">kubernetes.io/egress-bandwidth:</span> <span class="string">&quot;3M&quot;</span>   <span class="comment"># 限制出站带宽为 3 Mbps，单位bit</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">testpod</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">testpod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">debian:bookworm-slim</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">testpod</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tail</span> <span class="string">-f</span> <span class="string">/dev/null</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>2、登录进入pod中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it testpod -- /bin/bash</span><br></pre></td></tr></table></figure><p>3、测试外网速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install -y wget python3</span><br><span class="line"></span><br><span class="line">wget https://raw.github.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class="line">python3 speedtest.py</span><br></pre></td></tr></table></figure><p>4、测试内网速度<br>创建两个pod，其中一个启动 iperf server，另外一个启动 iperf client<br>（1）pod1启动iperf server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y iperf</span><br><span class="line">iperf -s</span><br></pre></td></tr></table></figure><p>（2）pod2启动iperf client：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y iperf</span><br><span class="line">iperf -c <span class="variable">$POD1_IP</span> -i 3</span><br></pre></td></tr></table></figure><h1 id="CNI插件带宽限速原理解析"><span class="post-title-index">5. </span><a href="#CNI插件带宽限速原理解析" class="headerlink" title="CNI插件带宽限速原理解析"></a>CNI插件带宽限速原理解析</h1><p>本节以CNI插件Calico为例，学习Pod带宽限速的原理。</p><h2 id="限速原理"><span class="post-title-index">5.1. </span><a href="#限速原理" class="headerlink" title="限速原理"></a>限速原理</h2><p>Calico 本身不直接处理带宽注解，而是依赖以下组件协同工作：</p><p>Kubernetes 网络组件:</p><ul><li>kubelet 会读取这些注解</li><li>通过 CNI 插件配置传递给底层网络</li></ul><p>Linux Traffic Control (tc):</p><ul><li>实际带宽限制是通过 Linux 的流量控制子系统实现的</li><li>使用 Hierarchical Token Bucket (HTB) 队列规则（Queueing Discipline）</li></ul><p>CNI 插件:</p><ul><li>Calico 会确保这些限制被应用到正确的网络接口</li></ul><h2 id="出口限制实现"><span class="post-title-index">5.2. </span><a href="#出口限制实现" class="headerlink" title="出口限制实现"></a>出口限制实现</h2><p>1、当 Pod 创建时，kubelet 检测到 egress-bandwidth 注解</p><p>2、通过 CNI 调用，在 Pod 的网络命名空间中设置规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc add dev eth0 root handle 1: htb default 10</span><br><span class="line">tc class add dev eth0 parent 1: classid 1:1 htb rate 1mbit</span><br></pre></td></tr></table></figure><p>所有从 Pod 发出的流量都会受到这个限制。</p><h2 id="入口限制实现"><span class="post-title-index">5.3. </span><a href="#入口限制实现" class="headerlink" title="入口限制实现"></a>入口限制实现</h2><p>入口限制的实现更复杂，通常通过设置一个虚拟的 ifb (Intermediate Functional Block) 设备</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 ifb 设备</span></span><br><span class="line">ip <span class="built_in">link</span> add ifb0 <span class="built_in">type</span> ifb</span><br><span class="line">ip <span class="built_in">link</span> <span class="built_in">set</span> dev ifb0 up</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将入口流量重定向到 ifb</span></span><br><span class="line">tc qdisc add dev eth0 handle ffff: ingress</span><br><span class="line">tc filter add dev eth0 parent ffff: protocol ip u32 match u32 0 0 action mirred egress redirect dev ifb0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 ifb 上应用限制</span></span><br><span class="line">tc qdisc add dev ifb0 root handle 1: htb default 10</span><br><span class="line">tc class add dev ifb0 parent 1: classid 1:1 htb rate 1mbit</span><br></pre></td></tr></table></figure><h2 id="注解与底层限速规则的关联"><span class="post-title-index">5.4. </span><a href="#注解与底层限速规则的关联" class="headerlink" title="注解与底层限速规则的关联"></a>注解与底层限速规则的关联</h2><p>已知pod中的限速注解为：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">apiVersion:</span> v1</span><br><span class="line"><span class="params">kind:</span> Pod</span><br><span class="line"><span class="params">metadata:</span></span><br><span class="line">  <span class="params">annotations:</span></span><br><span class="line">    kubernetes.io<span class="operator">/</span><span class="params">ingress-bandwidth:</span> <span class="string">&quot;1M&quot;</span>  <span class="comment"># 限制入站带宽为 1 Mbps，单位bit</span></span><br><span class="line">    kubernetes.io<span class="operator">/</span><span class="params">egress-bandwidth:</span> <span class="string">&quot;3M&quot;</span>   <span class="comment"># 限制出站带宽为 3 Mbps，单位bit</span></span><br></pre></td></tr></table></figure><p>创建pod后，查看pod在宿主机中的底层限速配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tc qdisc show</span><br></pre></td></tr></table></figure><p>看到的内容格式如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">qdisc tbf 1: dev cali47528e10e0c root refcnt 2 rate 1Mbit burst 27917286b lat 1924.2s</span><br><span class="line">qdisc ingress ffff: dev cali47528e10e0c parent ffff:fff1 ----------------</span><br><span class="line">qdisc tbf 1: dev bwpc6db82aef347 root refcnt 2 rate 3Mbit burst 62277024b lat 549.8s</span><br></pre></td></tr></table></figure><p>出口限制内容解析：</p><ul><li>设备名：bwpc6db82aef347（Kubernetes 为带宽限制创建的虚拟接口）</li><li>类型：tbf（Token Bucket Filter）</li><li>速率：rate 3Mbit → 对应 egress-bandwidth: 3M</li><li>作用方向：root 表示这是出口限制</li><li>突发流量限制：burst是为了应对突发流量，避免丢包，burst 62277024b，b表示bytes，允许短时间内突发最多传输 59.4MB 数据，这部分数据可以超过rate限制</li></ul><p>入口限制内容解析：</p><ul><li>设备名：cali47528e10e0c（Calico 的 Pod 接口）</li><li>类型：tbf + ingress 队列</li><li>速率：rate 1Mbit → 对应 ingress-bandwidth: 1M</li><li>特殊实现：Kubernetes 通过将入口流量 重定向到虚拟接口 的方式实现入口限制；实际生效的是 tbf 规则（虽然显示在 root 位置，但因重定向而作用于入口）</li><li>突发流量限制：burst 27917286b，b表示bytes，允许短时间内突发最多传输 26.6MB 数据，这部分数据可以超过rate限制</li></ul><p>查看tc规则详情：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tc -s qdisc show dev bwpc6db82aef347</span><br><span class="line">tc -s qdisc show dev cali47528e10e0c</span><br></pre></td></tr></table></figure><h1 id="后记"><span class="post-title-index">6. </span><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>实际测试发现，Pod中配置注解的方式确实可以实现限制带宽，测速时的 带宽量级 会随着 限速量级 的变化而变化。<br>但是，限速效果不太好，测出的 带宽数值 与设置的 限速数值 有较大差距，并且多次测试结果波动很大。<br>整体来说，Pod中配置注解的方式可以限速，但是不可以精确限速。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为避免Pod打满带宽，有时需要对Pod进行限速。&lt;br&gt;本文中，我们就来学习一下Pod中的网络限速方法。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/configure-bandwidth-limits-for-pods-in-flannel&quot;&gt;为Pod配置带宽限制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.alibabacloud.com/help/en/eci/user-guide/configure-the-bandwidth-of-a-pod-1&quot;&gt;Limit the inbound and outbound bandwidth of pods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-k8s-network-policy/&quot;&gt;《好好学K8S：K8S中的网络策略》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-docker-container-network-speed-limit/&quot;&gt;《好好学K8S：Pod网络限速》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    
    <category term="网络" scheme="https://www.voidking.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="好好学K8S" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6K8S/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之开源WAF</title>
    <link href="https://www.voidking.com/dev-web-security-waf/"/>
    <id>https://www.voidking.com/dev-web-security-waf/</id>
    <published>2024-10-06T08:00:00.000Z</published>
    <updated>2024-10-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WAF简介"><span class="post-title-index">1. </span><a href="#WAF简介" class="headerlink" title="WAF简介"></a>WAF简介</h1><p>WAF（Web Application Firewall）是保护Web应用程序免受各种网络攻击的重要工具。区别于传统防火墙，WAF 工作在应用层，对基于 HTTP/HTTPS 协议的 Web 系统有着更好的防护效果，使其免于受到黑客的攻击。</p><p>随着网络安全威胁的不断演变，开源WAF因其灵活性、可定制性和成本效益而受到越来越多企业的青睐。本文中，将盘点几款流行的开源WAF。</p><p>相关文档：</p><ul><li><a href="https://gitcode.csdn.net/6630550d16ca5020cb5bc5d3.html">2024 值得推荐的免费开源 WAF</a></li><li><a href="https://www.secrss.com/articles/55827">盘点2023年十大免费/开源WAF</a></li><li><a href="https://wnote.com/post/tools-safeline-waf/">开源Waf安全防护解决方案</a></li><li><a href="https://cloud.baidu.com/article/2701022">CentOS 7.7上利用OpenResty实现WAF应用防火墙</a></li><li><a href="https://freegeektime.com/100029001/119013/">WAF：保护我们的网络服务</a></li><li><a href="https://www.zenarmor.com/docs/network-security-tutorials/best-open-source-web-application-firewalls">The Best Open Source Web Application Firewalls</a></li><li><a href="https://www.openappsec.io/post/top-10-free-wafs-web-application-firewalls-for-2024">Top 10 Free WAFs (Web Application Firewalls) for 2024</a></li></ul><span id="more"></span><h1 id="ModeSecurity"><span class="post-title-index">2. </span><a href="#ModeSecurity" class="headerlink" title="ModeSecurity"></a>ModeSecurity</h1><p>ModSecurity是一个老牌的开源WAF，最初为Apache HTTP服务器开发，后来扩展到Nginx和IIS等其他平台。</p><p>准确来说 ModSecurity 并不是一款 “WAF”，而是一个 “WAF 规则集”，ModSecurity 是绝大部分 WAF 的底层基石，它并不包含其他 WAF 常见的网站管理、日志管理等功能，甚至完全没有界面，ModSecurity 有的只是防护规则。</p><p>ModSecurity 不适合直接使用，安装配置复杂，需要配合二次开发做一定的定制才能用起来，上手门槛高。</p><p>项目地址：<a href="https://github.com/owasp-modsecurity/ModSecurity">ModeSecurity</a>，star数 8.1k</p><h1 id="SafeLine"><span class="post-title-index">3. </span><a href="#SafeLine" class="headerlink" title="SafeLine"></a>SafeLine</h1><p>SafeLine，中文名 “雷池”，是一款简单好用，效果突出的 Web 应用防火墙(WAF)，可以保护 Web 服务不受黑客攻击。</p><p>雷池通过过滤和监控 Web 应用与互联网之间的 HTTP 流量来保护 Web 服务。可以保护 Web 服务免受 SQL 注入、XSS、 代码注入、命令注入、CRLF 注入、ldap 注入、xpath 注入、RCE、XXE、SSRF、路径遍历、后门、暴力破解、CC、爬虫 等攻击。</p><p>雷池的社区认可度很高，优势在于性能好、防护能力强、安装配置简单。</p><p>项目地址：<a href="https://github.com/chaitin/SafeLine">SafeLine</a>，star数 12.2k</p><h1 id="BunkerWeb"><span class="post-title-index">4. </span><a href="#BunkerWeb" class="headerlink" title="BunkerWeb"></a>BunkerWeb</h1><p>BunkerWeb 号称是下一代开源 Web 应用程序防火墙（WAF）。<br>BunkerWeb 作为一个功能齐全的 Web 服务器（在后台基于 NGINX），负责保护 Web 服务，使其“默认安全”。BunkerWeb 可以无缝集成到我们现有的环境（Linux、Docker、Swarm、Kubernetes 等）中，并且是完全可配置的（不要惊慌，如果我们不喜欢 CLI，有一个很棒的 Web UI）以满足我们自己的用例。换句话说，网络安全不再是一件麻烦事。<br>BunkerWeb 包含作为核心一部分的主要安全功能，还可以通过插件系统轻松扩展其他功能。</p><p>项目地址：<a href="https://github.com/bunkerity/bunkerweb">BunkerWeb</a>，star数 6.3k</p><h1 id="Coraza"><span class="post-title-index">5. </span><a href="#Coraza" class="headerlink" title="Coraza"></a>Coraza</h1><p>Coraza 是一个开源的企业级高性能 Web 应用防火墙 (WAF)。它是用 Go 编写的，支持 ModSecurity SecLang 规则集，并且与 OWASP 核心规则集 v4 100% 兼容。</p><p>项目地址：<a href="https://github.com/corazawaf/coraza">Coraza</a>，star数 2.2k</p><h1 id="open-appsec"><span class="post-title-index">6. </span><a href="#open-appsec" class="headerlink" title="open-appsec"></a>open-appsec</h1><p>open-appsec (openappsec.io) 基于机器学习提供针对 OWASP 前十名和零日攻击的预防性 Web 应用程序和 API 威胁保护。它可以作为 Kubernetes Ingress、NGINX、Envoy（即将推出）和 API 网关的附加组件进行部署。</p><p>open-appsec 引擎学习用户如何与您的 Web 应用程序正常交互。然后，它利用这些信息自动检测超出正常操作范围的请求，并进行进一步分析以决定该请求是否恶意。</p><p>项目地址：<a href="https://github.com/openappsec/openappsec">open-appsec</a>，star数 0.8k</p><h1 id="OpenResty"><span class="post-title-index">7. </span><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h1><p>OpenResty是一个基于Nginx和LuaJIT的Web平台，它提供了强大的功能和灵活性，使得我们可以轻松地实现各种Web应用的需求。在OpenResty中，我们可以利用Lua脚本编写WAF规则，对进入的HTTP请求进行检测和过滤。</p><p>项目地址：<a href="https://github.com/openresty/openresty">OpenResty</a>，star数 12.6k</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;WAF简介&quot;&gt;&lt;a href=&quot;#WAF简介&quot; class=&quot;headerlink&quot; title=&quot;WAF简介&quot;&gt;&lt;/a&gt;WAF简介&lt;/h1&gt;&lt;p&gt;WAF（Web Application Firewall）是保护Web应用程序免受各种网络攻击的重要工具。区别于传统防火墙，WAF 工作在应用层，对基于 HTTP/HTTPS 协议的 Web 系统有着更好的防护效果，使其免于受到黑客的攻击。&lt;/p&gt;
&lt;p&gt;随着网络安全威胁的不断演变，开源WAF因其灵活性、可定制性和成本效益而受到越来越多企业的青睐。本文中，将盘点几款流行的开源WAF。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gitcode.csdn.net/6630550d16ca5020cb5bc5d3.html&quot;&gt;2024 值得推荐的免费开源 WAF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.secrss.com/articles/55827&quot;&gt;盘点2023年十大免费/开源WAF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wnote.com/post/tools-safeline-waf/&quot;&gt;开源Waf安全防护解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.baidu.com/article/2701022&quot;&gt;CentOS 7.7上利用OpenResty实现WAF应用防火墙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://freegeektime.com/100029001/119013/&quot;&gt;WAF：保护我们的网络服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zenarmor.com/docs/network-security-tutorials/best-open-source-web-application-firewalls&quot;&gt;The Best Open Source Web Application Firewalls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.openappsec.io/post/top-10-free-wafs-web-application-firewalls-for-2024&quot;&gt;Top 10 Free WAFs (Web Application Firewalls) for 2024&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    
    <category term="网络" scheme="https://www.voidking.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="安全" scheme="https://www.voidking.com/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="黑客" scheme="https://www.voidking.com/tags/%E9%BB%91%E5%AE%A2/"/>
    
  </entry>
  
</feed>
