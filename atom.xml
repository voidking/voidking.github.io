<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好好学习的郝</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="https://www.voidking.com/atom.xml" rel="self"/>
  
  <link href="https://www.voidking.com/"/>
  <updated>2023-05-27T08:00:00.000Z</updated>
  <id>https://www.voidking.com/</id>
  
  <author>
    <name>好好学习的郝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Helm官方文档摘录</title>
    <link href="https://www.voidking.com/dev-helm-doc-extract/"/>
    <id>https://www.voidking.com/dev-helm-doc-extract/</id>
    <published>2023-05-27T08:00:00.000Z</published>
    <updated>2023-05-27T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Helm官方文档写的很棒，本文会摘录Helm官方文档中的一些基础知识和最佳实践，备忘。<br>更细致全面的内容，请移步阅读<a href="https://helm.sh/zh/docs/">Helm官方文档</a>。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-helm-start/">《Helm入门篇》</a></li><li><a href="https://helm.sh/zh/docs/chart_template_guide/getting_started/">Helm - Getting Started</a></li></ul><span id="more"></span><h1 id="Helm三大概念"><a href="#Helm三大概念" class="headerlink" title="Helm三大概念"></a>Helm三大概念</h1><p>Chart 代表着 Helm 包。它包含在 Kubernetes 集群内部运行应用程序，工具或服务所需的所有资源定义。你可以把它看作是 Homebrew formula，Apt dpkg，或 Yum RPM 在Kubernetes 中的等价物。</p><p>Repository（仓库） 是用来存放和共享 charts 的地方。它就像 Perl 的 CPAN 档案库网络 或是 Fedora 的 软件包仓库，只不过它是供 Kubernetes 包所使用的。</p><p>Release 是运行在 Kubernetes 集群中的 chart 的实例。一个 chart 通常可以在同一个集群中安装多次。每一次安装都会创建一个新的 release。以 MySQL chart为例，如果你想在你的集群中运行两个数据库，你可以安装该chart两次。每一个数据库都会拥有它自己的 release 和 release name。</p><p>在了解了上述这些概念以后，我们就可以这样来解释 Helm：<br>Helm 安装 charts 到 Kubernetes 集群中，每次安装都会创建一个新的 release。你可以在 Helm 的 chart repositories 中寻找新的 chart。</p><h1 id="Helm安装资源的顺序"><a href="#Helm安装资源的顺序" class="headerlink" title="Helm安装资源的顺序"></a>Helm安装资源的顺序</h1><p>Helm按照以下顺序安装资源：</p><ul><li>Namespace</li><li>NetworkPolicy</li><li>ResourceQuota</li><li>LimitRange</li><li>PodSecurityPolicy</li><li>PodDisruptionBudget</li><li>ServiceAccount</li><li>Secret</li><li>SecretList</li><li>ConfigMap</li><li>StorageClass</li><li>PersistentVolume</li><li>PersistentVolumeClaim</li><li>CustomResourceDefinition</li><li>ClusterRole</li><li>ClusterRoleList</li><li>ClusterRoleBinding</li><li>ClusterRoleBindingList</li><li>Role</li><li>RoleList</li><li>RoleBinding</li><li>RoleBindingList</li><li>Service</li><li>DaemonSet</li><li>Pod</li><li>ReplicationController</li><li>ReplicaSet</li><li>Deployment</li><li>HorizontalPodAutoscaler</li><li>StatefulSet</li><li>Job</li><li>CronJob</li><li>Ingress</li><li>APIService</li></ul><h1 id="Chart模板指南"><a href="#Chart模板指南" class="headerlink" title="Chart模板指南"></a>Chart模板指南</h1><p>内容太多，建议直接阅读<a href="https://helm.sh/zh/docs/chart_template_guide/getting_started/">Helm官方文档 - Chart模板指南</a>，了解基础概念和语法。</p><p>本节只简单说明几个概念和语法。</p><h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p><code>templates/</code>目录中的<code>.yaml</code>文件和<code>.tpl</code>文件，就是模板。<br>当Helm评估chart时，会通过模板渲染引擎将所有文件发送到templates/目录中。 然后收集模板的结果并发送给Kubernetes。</p><p>values.yaml 文件也导入到了模板。这个文件包含了chart的 默认值 。这些值会在用户执行helm install 或 helm upgrade时被覆盖。</p><p>Chart.yaml 文件包含了该chart的描述。你可以从模板中访问它。charts/目录 可以 包含其他的chart(称之为 子chart)。</p><p>模板中横线的作用：</p><ul><li><code>&#123;&#123;-`：表示在模板渲染时要去掉前面的空白字符和换行符。- `-&#125;&#125;</code>：表示在模板渲染时要去掉后面的空白字符和换行符。</li></ul><h2 id="变量和作用域"><a href="#变量和作用域" class="headerlink" title="变量和作用域"></a>变量和作用域</h2><p>Helm模板中，变量是对另一个对象的命名引用。</p><p>变量的作用域一般不是全局的，而是其声明所在的块。所谓块，是指<code>if/else</code>、<code>with</code>、<code>range</code>、<code>define</code>、<code>template</code>、<code>block</code>定义的范围。</p><p><code>.</code>代表对当前作用域的引用，<code>.Values</code>表示在当前作用域查找Values对象。<br>每个模板中，默认可以访问到的内置对象有Release、Values、Chart、Files、Capabilities和Template。<br>如果定义了块，那么在块中不可以通过<code>.Values</code>找到Values对象。</p><p><code>$</code>代表对根作用域的引用，<code>$.Values</code>表示在根作用域查找Values对象。<br>如果定义了块，那么在块中可以通过<code>$.Values</code>找到Values对象。</p><p>变量定义格式示例：<code>&#123;&#123;- $name := .Release.Name -&#125;&#125;</code><br>在模板顶层定义变量，变量的作用域会是整个模板；在块中定义变量，变量的作用域只在块内。</p><h2 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h2><p>Helm 模板语言是用强类型Go编程语言实现的。 因此，模板中的变量是 有类型的。大多数情况下，变量将作为以下类型之一显示：</p><ul><li>string: 文本字符串</li><li>bool: true 或 false</li><li>int: 整型值（包含8位，16位，32位，和64有符号和无符号整数）</li><li>float64: 64位浮点数(也有8位，16位，32位类型)</li><li>字节切片([]byte)，一般用于保存（可能的）二进制数据</li><li>struct: 有属性和方法的对象</li><li>上述某种类型的切片(索引列表)</li><li>字符串键map (<code>map[string]interface&#123;&#125;</code>) 值是上述某种类型</li></ul><p>Go里面有很多其他类型，有时你需要在模板里转换。调试对象类型最简便的方式是在模板中传递给printf “%t”，这样会打印类型。 也可以使用 typeOf 和 kindOf 函数。</p><h2 id="命名模板"><a href="#命名模板" class="headerlink" title="命名模板"></a>命名模板</h2><p>命名模板（也被称作一个 部分 或一个 子模板）名称是全局的。<br>一个常见的命名惯例是用chart名称作为模板前缀。使用特定chart名称作为前缀可以避免可能因为 两个不同chart使用了相同名称的模板而引起的冲突。</p><p>用define和template声明和使用模板。<br>按照惯例，define声明的命名模板一般放在<code>_helpers.tpl</code>文件中。因为是模板名称是全局的，因此可以被<code>.yaml</code>文件引用。</p><p>template渲染时，一般传入<code>.</code>作为命名模板可以访问的范围。<br>include是template的替代，只是为了更好地处理YAML文档的输出格式，方便缩进。</p><h2 id="NOTES-txt文件"><a href="#NOTES-txt文件" class="headerlink" title="NOTES.txt文件"></a>NOTES.txt文件</h2><p>在helm install 或 helm upgrade命令的最后，Helm会打印出对用户有用的信息。 使用模板可以高度自定义这部分信息。<br>要在chart添加安装说明，只需创建 templates/NOTES.txt 文件即可。该文件是纯文本，但会像模板一样处理， 所有正常的模板函数和对象都是可用的。</p><h2 id="helmignore-文件"><a href="#helmignore-文件" class="headerlink" title=".helmignore 文件"></a>.helmignore 文件</h2><p><code>.helmignore</code> 文件用来指定你不想包含在你的helm chart中的文件。<br>如果该文件存在，helm package 命令会在打包应用时忽略所有在 <code>.helmignore</code> 文件中匹配的文件。</p><p>一些值得注意的和.gitignore不同之处：</p><ul><li>不支持<code>**</code>语法。</li><li>globbing库是Go的 ‘filepath.Match’，不是fnmatch(3)</li><li>末尾空格总会被忽略(不支持转义序列)</li><li>不支持<code>!</code>作为特殊的引导序列</li><li>默认不会排除自身，需要显式添加 .helmignore</li></ul><h2 id="YAML技术"><a href="#YAML技术" class="headerlink" title="YAML技术"></a>YAML技术</h2><p>参考文档：<a href="https://www.voidking.com/dev-yaml/">《YAML语言》</a></p><h1 id="Chart开发技巧"><a href="#Chart开发技巧" class="headerlink" title="Chart开发技巧"></a>Chart开发技巧</h1><h2 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h2><p>Helm使用<a href="https://pkg.go.dev/text/template">Go模板</a>，同时增加了两个特殊模板方法：<code>include</code>和<code>required</code>。</p><p>include方法允许你引入另一个模板，并将结果传递给其他模板方法。<br>比如，这个模板片段包含了一个叫mytpl的模板，然后将其转成小写，并使用双引号括起来。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value: &#123;&#123; include &quot;mytpl&quot; . | lower | quote &#125;&#125;</span><br></pre></td></tr></table></figure><p>required方法可以让你声明模板渲染所需的特定值。如果这个值是空的，模板渲染会出错并打印用户提交的错误信息。<br>下面这个required方法的例子声明了一个.Values.who需要的条目，并且当这个条目不存在时会打印错误信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value: &#123;&#123; required &quot;A valid .Values.who entry required!&quot; .Values.who &#125;&#125;</span><br></pre></td></tr></table></figure><p>tpl方法允许开发者在模板中使用字符串作为模板。将模板字符串作为值传给chart或渲染额外的配置文件时会很有用。<br>语法： <code>&#123;&#123; tpl TEMPLATE_STRING VALUES &#125;&#125;</code></p><h2 id="使用Partials和模板引用"><a href="#使用Partials和模板引用" class="headerlink" title="使用Partials和模板引用"></a>使用Partials和模板引用</h2><p>有时你想在chart中创建可以重复利用的部分，不管是块还是局部模板。通常将这些文件保存在自己的文件中会更干净。</p><p>在 <code>templates/</code> 目录中，任何以下划线(<code>_</code>)开始的文件不希望输出到Kubernetes清单文件中。<br>因此按照惯例，辅助模板和局部模板会被放在<code>_helpers.tpl</code>文件中。</p><h2 id="创建镜像拉取密钥"><a href="#创建镜像拉取密钥" class="headerlink" title="创建镜像拉取密钥"></a>创建镜像拉取密钥</h2><p>1、定义 values.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">imageCredentials:</span></span><br><span class="line">  <span class="attr">registry:</span> <span class="string">quay.io</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">someone</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">sillyness</span></span><br><span class="line">  <span class="attr">email:</span> <span class="string">someone@host.com</span></span><br></pre></td></tr></table></figure><p>2、定义辅助模板（写在 <code>_helpers.tpl</code> 文件里）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;imagePullSecret&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- with .Values.imageCredentials &#125;&#125;</span><br><span class="line">&#123;&#123;- printf &quot;&#123;\&quot;auths\&quot;:&#123;\&quot;%s\&quot;:&#123;\&quot;username\&quot;:\&quot;%s\&quot;,\&quot;password\&quot;:\&quot;%s\&quot;,\&quot;email\&quot;:\&quot;%s\&quot;,\&quot;auth\&quot;:\&quot;%s\&quot;&#125;&#125;&#125;&quot; .registry .username .password .email (printf &quot;%s:%s&quot; .username .password | b64enc) | b64enc &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure><p>3、模板中使用辅助模板</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myregistrykey</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/dockerconfigjson</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">.dockerconfigjson:</span> &#123;&#123; <span class="string">template</span> <span class="string">&quot;imagePullSecret&quot;</span> <span class="string">.</span> &#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="YAML是JSON的超集"><a href="#YAML是JSON的超集" class="headerlink" title="YAML是JSON的超集"></a>YAML是JSON的超集</h2><p>根据YAML规范，YAML是JSON的超集。这意味着任意的合法JSON结构在YAML中应该是合法的。</p><p>这有个优势：有时候模板开发者会发现使用类JSON语法更容易表达数据结构而不是处理YAML的空白敏感度。</p><p>作为最佳实践，模板应遵循类YAML语法 除非 JSON语法大大降低了格式问题的风险。</p><h2 id="构建复杂Chart"><a href="#构建复杂Chart" class="headerlink" title="构建复杂Chart"></a>构建复杂Chart</h2><p>在CNCF的 Artifact Hub 中的很多chart是创建更先进应用的“组成部分”。但是chart可能被用于创建大规模应用实例。 在这种场景中，一个总的chart会有很多子chart，每一个是整体功能的一部分。</p><p>当前从离散组件组成一个复杂应用的最佳实践是创建一个顶层总体chart构建全局配置，然后使用charts子目录嵌入每个组件。</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><h2 id="一般惯例"><a href="#一般惯例" class="headerlink" title="一般惯例"></a>一般惯例</h2><h3 id="chart名称"><a href="#chart名称" class="headerlink" title="chart名称"></a>chart名称</h3><p>chart名称必须是小写字母和数字。单词之间可以使用横杠分隔(-)。</p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>Helm尽可能使用 <a href="https://semver.org/">SemVer 2</a>来表示版本号。（注意Docker镜像的tag不一定遵循SemVer， 因此被认为是一个不幸的例外规则。）</p><p>当SemVer版本存储在Kubernetes标签中时，我们通常把+字符改成_，因为标签不允许使用+作为值进行签名。</p><h3 id="格式化YAML"><a href="#格式化YAML" class="headerlink" title="格式化YAML"></a>格式化YAML</h3><p>YAML 文件应该按照 双空格 缩进(绝不要使用tab键)。</p><h3 id="Helm-和-Chart的用法"><a href="#Helm-和-Chart的用法" class="headerlink" title="Helm 和 Chart的用法"></a>Helm 和 Chart的用法</h3><p>以下是几个 Helm 和 helm 的惯用方法。</p><ul><li>Helm 是指整个项目</li><li>helm 是指客户端命令</li><li>chart 不是专有名词，不需要首字母大写</li><li>Chart.yaml 需要首字母大写，因为文件名大小写敏感</li></ul><p>若有疑问，使用 Helm (‘H’大写)。</p><h2 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h2><h3 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h3><p>变量名称以小写字母开头，单词按驼峰区分</p><h3 id="扁平或嵌套的Value"><a href="#扁平或嵌套的Value" class="headerlink" title="扁平或嵌套的Value"></a>扁平或嵌套的Value</h3><p>YAML是一种灵活格式，值可以嵌套得很深，也可以是扁平的。<br>大多数场景中，扁平的优于嵌套的。因为对模板开发者和用户来说更加简单。</p><h3 id="类型清楚"><a href="#类型清楚" class="headerlink" title="类型清楚"></a>类型清楚</h3><p>YAML的类型强制规则有时候是很反常的。比如，foo: false 和 foo: “false” 是不一样的。大整型数如：foo: 12345678 有时会被转换成科学计数法。</p><p>避免类型强制规则错误最简单的方式是字符串明确定义，其他都是不明确的。或者，简单来讲， 给所有字符串打引号。</p><p>通常，为了避免整数转换问题，将整型存储为字符串更好，并用 <code>&#123;&#123; int $value &#125;&#125;</code> 在模板中将字符串转回整型。</p><p>在大多数场景中，显式的类型标记更好，所以 <code>foo: !!string 1234</code> 会将1234作为字符串对待。 但是，YAML解析器会消耗标记，因此类型数据在一次解析后会丢失。</p><h3 id="考虑用户使用value"><a href="#考虑用户使用value" class="headerlink" title="考虑用户使用value"></a>考虑用户使用value</h3><p>有三种value来源:</p><ul><li>chart的values.yaml文件</li><li>由<code>helm install -f</code>提供的values文件</li><li>在执行<code>helm install</code> 时传递给–set 或 –set-string 参数的values</li></ul><p>当设计values的结构时，记得你的chart用户可能会通过-f 参数或–set选项覆盖他们。<br>由于–set在表现上更有限，编写你values.yaml文件的第一指导原则是确保它容易被–set覆盖。因此使用map构建values文件更好。</p><h3 id="给values-yaml写文档"><a href="#给values-yaml写文档" class="headerlink" title="给values.yaml写文档"></a>给values.yaml写文档</h3><p>values.yaml中每个定义的属性都应该文档化。文档字符串应该以它要描述的属性开头，并至少给出一句描述。</p><h2 id="模板-1"><a href="#模板-1" class="headerlink" title="模板"></a>模板</h2><h3 id="templates-结构"><a href="#templates-结构" class="headerlink" title="templates 结构"></a>templates 结构</h3><p><code>templates/</code>目录结构应该如下：</p><ul><li>如果生成YAML输出，模板文件应该有扩展名.yaml。 扩展名是.tpl可用于生成非格式化内容的模板文件。</li><li>模板文件名称应该使用横杠符号(my-example-configmap.yaml)，不用驼峰记法。</li><li>每个资源的定义应该在它自己的模板文件中。</li><li>模板文件的名称应该反映名称中的资源类型。比如：foo-pod.yaml， bar-svc.yaml</li></ul><h3 id="定义模板的名称"><a href="#定义模板的名称" class="headerlink" title="定义模板的名称"></a>定义模板的名称</h3><p>定义的模板(在<code>&#123;&#123; define &#125;&#125;</code>命令中定义的模板)是可全局访问的。这就意味着chart和所有的子chart都可以访问用<code>&#123;&#123; define &#125;&#125;</code>创建的所有模板。</p><p>因此， 所有定义的模板名称应该被命名空间化。</p><p>正确的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;nginx.fullname&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;/* ... */&#125;&#125;</span><br><span class="line">&#123;&#123; end -&#125;&#125;</span><br></pre></td></tr></table></figure><p>不正确的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- define &quot;fullname&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;/* ... */&#125;&#125;</span><br><span class="line">&#123;&#123; end -&#125;&#125;</span><br></pre></td></tr></table></figure><p>强烈建议通过<code>helm create</code>命令创建新chart，因为模板名称是根据此最佳实践自动定义的。</p><h3 id="格式化模板"><a href="#格式化模板" class="headerlink" title="格式化模板"></a>格式化模板</h3><p>模板应该使用两个 空格 缩进（永远不要用tab）。<br>模板命令的大括号前后应该使用空格。<br>正确的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; .foo &#125;&#125;</span><br><span class="line">&#123;&#123; print &quot;foo&quot; &#125;&#125;</span><br><span class="line">&#123;&#123;- print &quot;bar&quot; -&#125;&#125;</span><br></pre></td></tr></table></figure><p>不正确的：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;.foo&#125;&#125;</span><br><span class="line">&#123;&#123;print &quot;foo&quot;&#125;&#125;</span><br><span class="line">&#123;&#123;-print &quot;bar&quot;-&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="生成模板中的空格"><a href="#生成模板中的空格" class="headerlink" title="生成模板中的空格"></a>生成模板中的空格</h3><p>最好在生成的模板中将空格量保持在最小值。尤其是大量的空行不应该相邻出现。但偶尔有空行（尤其在逻辑块之间）是没问题的。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>YAML和Helm模板都有注释标记符。<br>YAML注释：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># This is a comment</span><br><span class="line">type: sprocket</span><br></pre></td></tr></table></figure><p>模板注释：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;- /*</span><br><span class="line">This is a comment.</span><br><span class="line">*/&#125;&#125;</span><br><span class="line">type: frobnitz</span><br></pre></td></tr></table></figure><h3 id="在模板和模板输出中使用JSON"><a href="#在模板和模板输出中使用JSON" class="headerlink" title="在模板和模板输出中使用JSON"></a>在模板和模板输出中使用JSON</h3><p>YAML是JSON的超集。在某些情况下，使用JSON语法比其他YAML表示更具可读性。</p><p>比如，这个YAML更接近表示列表的普通YAML方法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">arguments:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;--dirname&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;/foo&quot;</span></span><br></pre></td></tr></table></figure><p>但是折叠成JSON列表样式时会更易阅读:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">arguments:</span> [<span class="string">&quot;--dirname&quot;</span>, <span class="string">&quot;/foo&quot;</span>]</span><br></pre></td></tr></table></figure><p>使用JSON可以很好地提高易读性。然而，JSON语法不应用于表示更复杂的结构。</p><h2 id="标签和注释"><a href="#标签和注释" class="headerlink" title="标签和注释"></a>标签和注释</h2><p>建议使用 <code>helm.sh/chart: NAME-VERSION</code> 作为标签，以便操作员可以找到特定chart的所有实例。</p><p>如果元数据项不是用于查询，就应该设置为注释。</p><p>标准标签参考文档：<a href="https://helm.sh/zh/docs/chart_best_practices/labels/">标签和注释</a></p><h2 id="Pod和Pod模板"><a href="#Pod和Pod模板" class="headerlink" title="Pod和Pod模板"></a>Pod和Pod模板</h2><p>Pod指的是Pod，Pod模板指的是Deployment、ReplicationController、ReplicaSet、DaemonSet、StatefulSet等。</p><p>容器镜像应该使用固定的tag或镜像SHA。不应该使用latest, head, canary等标签或其他被设计为“浮动的”标签。</p><p>所有的Pod模板部分应该指定一个selector。比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">selector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyName</span></span><br><span class="line"><span class="attr">template:</span></span><br><span class="line">  <span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">labels:</span></span><br><span class="line">      <span class="attr">app.kubernetes.io/name:</span> <span class="string">MyName</span></span><br></pre></td></tr></table></figure><h2 id="基于角色的访问控制"><a href="#基于角色的访问控制" class="headerlink" title="基于角色的访问控制"></a>基于角色的访问控制</h2><p>RBAC 资源有：</p><ul><li>ServiceAccount (namespaced)</li><li>Role (namespaced)</li><li>ClusterRole</li><li>RoleBinding (namespaced)</li><li>ClusterRoleBinding</li></ul><p>RBAC和服务账户配置应该使用独立的key。它们是独立的内容。在YAML中将这两个概念分开可以消除歧义使其更加清晰。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rbac:</span></span><br><span class="line">  <span class="comment"># Specifies whether RBAC resources should be created</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">serviceAccount:</span></span><br><span class="line">  <span class="comment"># Specifies whether a ServiceAccount should be created</span></span><br><span class="line">  <span class="attr">create:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># The name of the ServiceAccount to use.</span></span><br><span class="line">  <span class="comment"># If not set and create is true, a name is generated using the fullname template</span></span><br><span class="line">  <span class="attr">name:</span></span><br></pre></td></tr></table></figure><p>rbac.create 应该是布尔值，用于控制RBAC资源是否被创建。默认是 true。用户想自己管理RBAC访问控制时可以设置为false (示例如下)。</p><p>serviceAccount.name 要设置为由chart创建的访问控制资源的ServiceAccount的名称。 如果serviceAccount.create是true，则使用该名称的ServiceAccount会被创建。如果没有设置名称， 则会使用fullname模板生成一个名称。如果serviceAccount.create是false，则不会被创建，但仍然会与相同的资源关联， 以便后续手动创建的引用它的RBAC资源可以正常工作。如果serviceAccount.create是false且没有指定名称， 会使用默认的ServiceAccount。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;/*</span><br><span class="line">Create the name of the service account to use</span><br><span class="line">*/&#125;&#125;</span><br><span class="line">&#123;&#123;- define &quot;mychart.serviceAccountName&quot; -&#125;&#125;</span><br><span class="line">&#123;&#123;- if .Values.serviceAccount.create -&#125;&#125;</span><br><span class="line">    &#123;&#123; default (include &quot;mychart.fullname&quot; .) .Values.serviceAccount.name &#125;&#125;</span><br><span class="line">&#123;&#123;- else -&#125;&#125;</span><br><span class="line">    &#123;&#123; default &quot;default&quot; .Values.serviceAccount.name &#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br><span class="line">&#123;&#123;- end -&#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><h2 id="语法检查"><a href="#语法检查" class="headerlink" title="语法检查"></a>语法检查</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm lint</span><br></pre></td></tr></table></figure><h2 id="测试本地渲染"><a href="#测试本地渲染" class="headerlink" title="测试本地渲染"></a>测试本地渲染</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm template --debug</span><br></pre></td></tr></table></figure><h2 id="测试服务器渲染"><a href="#测试服务器渲染" class="headerlink" title="测试服务器渲染"></a>测试服务器渲染</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --dry-run --debug</span><br></pre></td></tr></table></figure><h2 id="忽略检查测试服务器渲染"><a href="#忽略检查测试服务器渲染" class="headerlink" title="忽略检查测试服务器渲染"></a>忽略检查测试服务器渲染</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm install --dry-run --disable-openapi-validation</span><br></pre></td></tr></table></figure><h2 id="查看安装在服务上的模板"><a href="#查看安装在服务上的模板" class="headerlink" title="查看安装在服务上的模板"></a>查看安装在服务上的模板</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm get manifest</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Helm官方文档写的很棒，本文会摘录Helm官方文档中的一些基础知识和最佳实践，备忘。&lt;br&gt;更细致全面的内容，请移步阅读&lt;a href=&quot;https://helm.sh/zh/docs/&quot;&gt;Helm官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-helm-start/&quot;&gt;《Helm入门篇》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://helm.sh/zh/docs/chart_template_guide/getting_started/&quot;&gt;Helm - Getting Started&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="helm" scheme="https://www.voidking.com/tags/helm/"/>
    
  </entry>
  
  <entry>
    <title>搭建Spark on Yarn集群</title>
    <link href="https://www.voidking.com/dev-spark-on-yarn/"/>
    <id>https://www.voidking.com/dev-spark-on-yarn/</id>
    <published>2023-05-14T08:00:00.000Z</published>
    <updated>2023-05-14T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>计划在三台Linux主机中搭建Spark on Yarn集群，Spark版本3.2.3，Hadoop版本3.2.3。</p><p>主机配置为4C8G，操作系统为CentOS7，hosts配置为：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">192.168.56.101</span> spark-master</span><br><span class="line"><span class="number">192.168.56.102</span> spark-slave1</span><br><span class="line"><span class="number">192.168.56.103</span> spark-slave2</span><br></pre></td></tr></table></figure><p>选择101作为master节点，另外两个作为worker节点。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-install-hadoop-on-linux/">《Linux中安装配置Hadoop》</a></li><li><a href="https://www.voidking.com/dev-install-spark-on-linux/">《Linux中搭建Spark集群》</a></li><li><a href="https://blog.csdn.net/u011374856/article/details/119869602">Hadoop 3.2.2 安装与使用文档超详细图文步骤</a></li><li><a href="https://zhuanlan.zhihu.com/p/487572725">spark3.2+hadoop3.3.2三节点分布式部署初体验</a></li><li><a href="https://juejin.cn/post/7095277036868436004">搭建Spark on Yarn集群</a></li><li><a href="https://blog.csdn.net/m0_61022929/article/details/126403124">spark3.3.0安装&amp;部署过程</a></li></ul><span id="more"></span><h1 id="安装Java"><a href="#安装Java" class="headerlink" title="安装Java"></a>安装Java</h1><p>参考文档<a href="https://www.voidking.com/dev-install-jdk-on-all-platforms/">《全平台安装JDK》</a></p><h1 id="安装Hadoop"><a href="#安装Hadoop" class="headerlink" title="安装Hadoop"></a>安装Hadoop</h1><h2 id="下载Hadoop安装包"><a href="#下载Hadoop安装包" class="headerlink" title="下载Hadoop安装包"></a>下载Hadoop安装包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://dlcdn.apache.org/hadoop/common/hadoop-3.2.3/hadoop-3.2.3.tar.gz --no-check-certificate</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/hadoop/</span><br><span class="line">tar -xzvf hadoop-3.2.3.tar.gz -C /usr/local/hadoop/</span><br></pre></td></tr></table></figure><h2 id="修改Hadoop配置"><a href="#修改Hadoop配置" class="headerlink" title="修改Hadoop配置"></a>修改Hadoop配置</h2><p>1、修改hadoop-env.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop/hadoop-3.2.3</span><br><span class="line">vim etc/hadoop/hadoop-env.sh</span><br></pre></td></tr></table></figure><p>修改JAVA_HOME为绝对路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/jdk1.8.0_161</span><br></pre></td></tr></table></figure><p>2、验证环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hadoop version</span><br></pre></td></tr></table></figure><h2 id="单机测试运行"><a href="#单机测试运行" class="headerlink" title="单机测试运行"></a>单机测试运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ./input</span><br><span class="line"><span class="built_in">cp</span> ./etc/hadoop/*.xml ./input</span><br><span class="line">./bin/hadoop jar ./share/hadoop/mapreduce/hadoop-mapreduce-examples-*.jar grep ./input ./output <span class="string">&#x27;dfs[a-z.]+&#x27;</span></span><br><span class="line"><span class="built_in">cat</span> ./output/*</span><br></pre></td></tr></table></figure><p>看到结果<code>1  dfsadmin</code>表明运行成功。</p><h2 id="master节点配置HDFS"><a href="#master节点配置HDFS" class="headerlink" title="master节点配置HDFS"></a>master节点配置HDFS</h2><p>1、修改etc/hadoop/core-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定hdfs中nomenode的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>fs.defaultFS<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>hdfs://spark-master:9000<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 指定hadoop运行时产生文件的存储目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>hadoop.tmp.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/hadoop-3.2.3/data/tmp<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置参考文档：<a href="https://hadoop.apache.org/docs/r3.2.3/hadoop-project-dist/hadoop-common/core-default.xml">hadoop3.2.3 core-default.xml</a></p><p>2、修改etc/hadoop/hdfs-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置dfs副本数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.replication<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hdfs的web管理页面的端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.http.address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>0.0.0.0:50070<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置secondnamenode的端口 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.secondary.http-address<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-master:9001<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- namenode目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.namenode.name.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/hadoop-3.2.3/data/dfs/name<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- datanode目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dfs.datanode.data.dir<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>file:/usr/local/hadoop/hadoop-3.2.3/data/dfs/data<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置参考文档：<a href="https://hadoop.apache.org/docs/r3.2.3/hadoop-project-dist/hadoop-hdfs/hdfs-default.xml">hadoop3.2.3 hdfs-default.xml</a></p><p>3、修改etc/hadoop/workers</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark-master</span><br><span class="line">spark-slave1</span><br><span class="line">spark-slave2</span><br></pre></td></tr></table></figure><h2 id="master节点配置配置Yarn"><a href="#master节点配置配置Yarn" class="headerlink" title="master节点配置配置Yarn"></a>master节点配置配置Yarn</h2><p>1、编辑 etc/hadoop/mapred-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定mr运行在yarn上 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>mapreduce.framework.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>yarn<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、编辑 etc/hadoop/yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- reducer 获取数据的方式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>mapreduce_shuffle<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定 YARN 的 ResourceManager 的地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>spark-master<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 该节点上YARN可使用的物理内存总量，默认是 8192（MB）--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意，如果你的节点内存资源不够8GB，则需要调减小这个值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.resource.memory-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">&lt;!-- 单个任务可申请最少内存，默认 1024 MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.minimum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>1024<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 单个任务可申请最大内存，默认 8192 MB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.maximum-allocation-mb<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>4096<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/local/hadoop/hadoop-3.2.3</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$JRE_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/bin:<span class="variable">$HADOOP_HOME</span>/sbin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>使生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="拷贝配置到slave节点"><a href="#拷贝配置到slave节点" class="headerlink" title="拷贝配置到slave节点"></a>拷贝配置到slave节点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rsync -P -avz /usr/local/hadoop 192.168.56.102:/usr/local/</span><br><span class="line">rsync -P -avz /usr/local/hadoop 192.168.56.103:/usr/local/</span><br><span class="line">rsync -P -avz /etc/profile 192.168.56.102:/etc/profile</span><br><span class="line">rsync -P -avz /etc/profile 192.168.56.103:/etc/profile</span><br></pre></td></tr></table></figure><h2 id="master节点启动HDFS"><a href="#master节点启动HDFS" class="headerlink" title="master节点启动HDFS"></a>master节点启动HDFS</h2><p>1、格式化namenode</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/hdfs namenode -format</span><br></pre></td></tr></table></figure><p>执行完成，没有报错，当前目录中出现了tmp目录，表明格式化成功。slave节点不会出现tmp目录。</p><p>2、添加HDFS用户环境变量<br>/etc/profile中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HDFS_DATANODE_USER=root</span><br><span class="line"><span class="built_in">export</span> HDFS_DATANODE_SECURE_USER=hdfs</span><br><span class="line"><span class="built_in">export</span> HDFS_NAMENODE_USER=root</span><br><span class="line"><span class="built_in">export</span> HDFS_SECONDARYNAMENODE_USER=root</span><br></pre></td></tr></table></figure><p>或者sbin/start-dfs.sh 和 sbin/stop-dfs.sh，文件顶部添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HDFS_DATANODE_USER=root</span><br><span class="line">HDFS_DATANODE_SECURE_USER=hdfs</span><br><span class="line">HDFS_NAMENODE_USER=root</span><br><span class="line">HDFS_SECONDARYNAMENODE_USER=root</span><br></pre></td></tr></table></figure><p>否则执行可能报错：<br>Starting namenodes on [spark-master]<br>ERROR: Attempting to operate on hdfs namenode as root<br>ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation.<br>Starting datanodes<br>ERROR: Attempting to operate on hdfs datanode as root<br>ERROR: but there is no HDFS_DATANODE_USER defined. Aborting operation.<br>Starting secondary namenodes [spark-master]<br>ERROR: Attempting to operate on hdfs secondarynamenode as root<br>ERROR: but there is no HDFS_SECONDARYNAMENODE_USER defined. Aborting operation.</p><p>3、启动hdfs服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-dfs.sh</span><br></pre></td></tr></table></figure><p>这条命令会在master和slave节点同时启动hdfs，会提示输入密码，最好提前配置好免密登录。</p><p>4、查看hdfs进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p>master节点可以看到：</p><ul><li>org.apache.hadoop.hdfs.server.namenode.NameNode</li><li>org.apache.hadoop.hdfs.server.datanode.DataNode</li><li>org.apache.hadoop.hdfs.server.namenode.SecondaryNameNode</li></ul><p>slave节点可以看到：</p><ul><li>org.apache.hadoop.hdfs.server.datanode.DataNode</li></ul><p>5、浏览器访问<br>浏览器访问 <a href="http://192.168.56.101:50070/">http://192.168.56.101:50070</a><br>可以看到 NameNode 和 Datanode 的信息。</p><h2 id="master节点启动Yarn"><a href="#master节点启动Yarn" class="headerlink" title="master节点启动Yarn"></a>master节点启动Yarn</h2><p>1、修改 sbin/start-yarn.sh 和 sbin/stop-yarn.sh，文件顶部添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YARN_RESOURCEMANAGER_USER=root</span><br><span class="line">HADOOP_SECURE_DN_USER=yarn</span><br><span class="line">YARN_NODEMANAGER_USER=root</span><br></pre></td></tr></table></figure><p>2、启动yarn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><p>3、查看进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p>master可以看到：</p><ul><li>org.apache.hadoop.yarn.server.nodemanager.NodeManager</li><li>org.apache.hadoop.yarn.server.resourcemanager.ResourceManager</li></ul><p>slave节点可以看到：</p><ul><li>org.apache.hadoop.yarn.server.nodemanager.NodeManager</li></ul><p>4、浏览器访问<br>浏览器访问 <a href="http://192.168.56.101:8088/">http://192.168.56.101:8088</a><br>可以看到 Yarn ResourceManager的信息。</p><h1 id="安装Spark"><a href="#安装Spark" class="headerlink" title="安装Spark"></a>安装Spark</h1><h2 id="master节点配置"><a href="#master节点配置" class="headerlink" title="master节点配置"></a>master节点配置</h2><p>1、下载spark并解压</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://archive.apache.org/dist/spark/spark-3.2.3/spark-3.2.3-bin-hadoop3.2-scala2.13.tgz</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/local/spark</span><br><span class="line">tar -xzvf spark-3.2.3-bin-hadoop3.2-scala2.13.tgz -C /usr/local/spark</span><br></pre></td></tr></table></figure><p>更多版本的spark，可以在<a href="https://archive.apache.org/dist/spark/">Spark release archives</a>页面找到。</p><p>2、创建配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/spark-3.2.3-bin-hadoop3.2-scala2.13/conf</span><br><span class="line"><span class="built_in">cp</span> workers.template workers</span><br><span class="line"><span class="built_in">cp</span> spark-defaults.conf.template spark-defaults.conf</span><br><span class="line"><span class="built_in">cp</span> spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure><p>3、修改配置<br>（1）workers中删除localhost，添加</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spark-master</span><br><span class="line">spark-slave1</span><br><span class="line">spark-slave2</span><br></pre></td></tr></table></figure><p>（2）spark-defaults.conf暂时不变</p><p>（3）spark-env.sh中添加</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/lib/jvm/jdk1.8.0_161</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_HOST=spark-master</span><br><span class="line"><span class="built_in">export</span> SPARK_MASTER_PORT=7077</span><br><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/local/spark/spark-3.2.3-bin-hadoop3.2-scala2.13</span><br><span class="line"><span class="built_in">export</span> HADOOP_HOME=/usr/local/hadoop/hadoop-3.2.3</span><br><span class="line"><span class="built_in">export</span> HADOOP_CONF_DIR=/usr/local/hadoop/hadoop-3.2.3/etc/hadoop/</span><br><span class="line"><span class="built_in">export</span> YARN_CONF_DIR=/usr/local/hadoop/hadoop-3.2.3/etc/hadoop/</span><br></pre></td></tr></table></figure><p>4、/etc/profile中添加环境变量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> SPARK_HOME=/usr/local/spark/spark-3.2.3-bin-hadoop3.2-scala2.13</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$SPARK_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>5、使配置生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure><h2 id="master配置同步到worker"><a href="#master配置同步到worker" class="headerlink" title="master配置同步到worker"></a>master配置同步到worker</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rsync -P -avz /usr/local/spark 192.168.56.102:/usr/local/</span><br><span class="line">rsync -P -avz /usr/local/spark 192.168.56.103:/usr/local/</span><br><span class="line">rsync -P -avz /etc/profile 192.168.56.102:/etc/profile</span><br><span class="line">rsync -P -avz /etc/profile 192.168.56.103:/etc/profile</span><br></pre></td></tr></table></figure><h2 id="运行Spark"><a href="#运行Spark" class="headerlink" title="运行Spark"></a>运行Spark</h2><p>1、启动spark（在master节点上执行）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/spark/spark-3.2.3-bin-hadoop3.2-scala2.13/sbin</span><br><span class="line">./start-all.sh</span><br></pre></td></tr></table></figure><p>根据提示，依次输入两台worker节点的密码。（这里最好配置上免密登录）<br>这样，三个节点上的spark就都可以启动起来。</p><p>2、验证安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps -l</span><br></pre></td></tr></table></figure><p>master节点看到Master和Worker进程，worker节点看到Worker进程。</p><p>3、浏览器访问<br>浏览器访问 <a href="http://192.168.56.101:8080/">http://192.168.56.101:8080</a><br>可以看到spark master信息。<br>浏览器访问 <a href="http://192.168.56.102:8081/">http://192.168.56.102:8081</a><br>可以看到spark slave节点信息。</p><h1 id="测试使用Spark-on-Yarn"><a href="#测试使用Spark-on-Yarn" class="headerlink" title="测试使用Spark on Yarn"></a>测试使用Spark on Yarn</h1><p>1、spark-submit提交任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit \</span><br><span class="line">  --class org.apache.spark.examples.SparkPi \</span><br><span class="line">  --master yarn \</span><br><span class="line">  ./examples/jars/spark-examples_2.13-3.2.3.jar 1000</span><br></pre></td></tr></table></figure><p>3、浏览器查看进度<br>浏览器访问 <a href="http://192.168.50.105:8088/">http://192.168.50.105:8088</a><br>在Yarn ResourceManager页面，可以查看到任务详情。</p><h1 id="vcore数量不对问题"><a href="#vcore数量不对问题" class="headerlink" title="vcore数量不对问题"></a>vcore数量不对问题</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>理论上：<code>vcores使用数 = executor-cores * num-executors + 1</code><br>但是实际提交任务后，配置的executor-cores并没有起作用。</p><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">./bin/spark-submit --class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">--driver-memory 2g \</span><br><span class="line">--executor-memory 1g \</span><br><span class="line">--num-executors 4 \</span><br><span class="line">--executor-cores 2 \</span><br><span class="line">./examples/jars/spark-examples_2.13-3.2.3.jar 10</span><br></pre></td></tr></table></figure><p>上面的提交，理论上应该使用<code>2 * 4 + 1 = 9</code>核，实际上从Yarn ResourceManager页面查看Allocated CPU VCores，只分配了5核。<br>也就是说executor-cores没有生效，使用了默认值1。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>1、编辑 capacity-scheduler.xml </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/hadoop/hadoop-3.2.3</span><br><span class="line">vim etc/hadoop/capacity-scheduler.xml</span><br></pre></td></tr></table></figure><p>如下修改：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.scheduler.capacity.resource-calculator<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;value&gt;org.apache.hadoop.yarn.util.resource.DefaultResourceCalculator&lt;/value&gt; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.hadoop.yarn.util.resource.DominantResourceCalculator<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">    The ResourceCalculator implementation to be used to compare</span><br><span class="line">    Resources in the scheduler.</span><br><span class="line">    The default i.e. DefaultResourceCalculator only uses Memory while</span><br><span class="line">    DominantResourceCalculator uses dominant-resource to compare</span><br><span class="line">    multi-dimensional resources such as Memory, CPU etc.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2、同步到slave节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rsync -P -avz /usr/local/hadoop/hadoop-3.2.3/etc/hadoop/ 192.168.56.102:/usr/local/hadoop/hadoop-3.2.3/etc/hadoop</span><br><span class="line">rsync -P -avz /usr/local/hadoop/hadoop-3.2.3/etc/hadoop/ 192.168.56.103:/usr/local/hadoop/hadoop-3.2.3/etc/hadoop</span><br></pre></td></tr></table></figure><p>3、重启yarn</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./sbin/stop-yarn.sh</span><br><span class="line">./sbin/start-yarn.sh</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://www.cnblogs.com/yesecangqiong/p/10125333.html">spark on yarn提交后vcore数不对</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;计划在三台Linux主机中搭建Spark on Yarn集群，Spark版本3.2.3，Hadoop版本3.2.3。&lt;/p&gt;
&lt;p&gt;主机配置为4C8G，操作系统为CentOS7，hosts配置为：&lt;/p&gt;
&lt;figure class=&quot;highlight accesslog&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;192.168.56.101&lt;/span&gt; spark-master&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;192.168.56.102&lt;/span&gt; spark-slave1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;192.168.56.103&lt;/span&gt; spark-slave2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;选择101作为master节点，另外两个作为worker节点。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-install-hadoop-on-linux/&quot;&gt;《Linux中安装配置Hadoop》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-install-spark-on-linux/&quot;&gt;《Linux中搭建Spark集群》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u011374856/article/details/119869602&quot;&gt;Hadoop 3.2.2 安装与使用文档超详细图文步骤&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/487572725&quot;&gt;spark3.2+hadoop3.3.2三节点分布式部署初体验&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7095277036868436004&quot;&gt;搭建Spark on Yarn集群&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/m0_61022929/article/details/126403124&quot;&gt;spark3.3.0安装&amp;amp;部署过程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="bigdata" scheme="https://www.voidking.com/categories/engineering/bigdata/"/>
    
    <category term="java" scheme="https://www.voidking.com/categories/engineering/java/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="java" scheme="https://www.voidking.com/tags/java/"/>
    
    <category term="hadoop" scheme="https://www.voidking.com/tags/hadoop/"/>
    
    <category term="spark" scheme="https://www.voidking.com/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>部署ChatGPT镜像站</title>
    <link href="https://www.voidking.com/dev-chatgpt-mirror-site/"/>
    <id>https://www.voidking.com/dev-chatgpt-mirror-site/</id>
    <published>2023-04-08T08:00:00.000Z</published>
    <updated>2023-04-08T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ChatGPT镜像站简介"><a href="#ChatGPT镜像站简介" class="headerlink" title="ChatGPT镜像站简介"></a>ChatGPT镜像站简介</h1><p>使用ChatGPT是有一定门槛的：科学上网，并且是特定地区科学上网。<br>近期ChatGPT开始封号，如果科学上网工具的出口IP频繁变化，那么ChatGPT账号可能被封。</p><p>而搭建使用ChatGPT镜像站，可以降低国内使用ChatGPT的门槛，并且避免账号被封。</p><p>参考文档：</p><ul><li><a href="https://juejin.cn/post/7217381222024233016">教程：部署个人专属的 ChatGPT 镜像教程</a></li></ul><span id="more"></span><h1 id="整体部署思路"><a href="#整体部署思路" class="headerlink" title="整体部署思路"></a>整体部署思路</h1><p>1、注册ChatGPT账号<br>2、获取OpenAI API Key<br>3、准备国外主机<br>4、准备Docker环境<br>5、部署ChatGPT镜像站<br>6、配置域名</p><h1 id="注册ChatGPT账号"><a href="#注册ChatGPT账号" class="headerlink" title="注册ChatGPT账号"></a>注册ChatGPT账号</h1><p>参考文档：</p><ul><li><a href="https://juejin.cn/post/7201806164392656953">国内开通Chat GPT Plus保姆级教程【典藏】</a></li><li><a href="https://nujuo8y1qx.feishu.cn/docx/AdqEdlT52oBiawx6Vv2cc89DnLb">ChatGPT学习手册</a></li><li><a href="https://juejin.cn/post/7183138644378452028">推荐一个方便好用的 ChatGPT 客户端</a></li></ul><h1 id="获取OpenAI-API-Key"><a href="#获取OpenAI-API-Key" class="headerlink" title="获取OpenAI API Key"></a>获取OpenAI API Key</h1><p>访问<a href="https://platform.openai.com/account/api-keys">OpenAI - API keys</a>，Create new secret key</p><h1 id="准备国外主机"><a href="#准备国外主机" class="headerlink" title="准备国外主机"></a>准备国外主机</h1><p>选择一个提供国外主机的云厂商，购买一台国外主机（推荐美国），并且主机的IP国内可以访问，安装Linux系统。</p><p>微软作为openai的大股东，选择微软azure的云主机，可能更不容易被封号。<br>azure注册需要visa或者master信用卡。注册后azure提供<code>$200</code>的免费试用额度，期限一个月，升级到即用即付订阅，可以延长免费期限到一年。</p><p>相关文档：</p><ul><li><a href="https://azure.microsoft.com/zh-cn/">Azure官网</a></li><li><a href="https://learn.microsoft.com/zh-cn/azure/virtual-machines/">Azure 中的虚拟机</a></li><li><a href="https://azure.microsoft.com/zh-cn/pricing/calculator/">定价计算器</a></li><li><a href="https://azure.microsoft.com/zh-cn/pricing/vm-selector/">虚拟机选择器</a></li></ul><h1 id="准备Docker环境"><a href="#准备Docker环境" class="headerlink" title="准备Docker环境"></a>准备Docker环境</h1><p>安装Docker，参考文档：<a href="https://www.voidking.com/dev-docker-start/">《Docker入门篇》</a></p><h1 id="部署ChatGPT镜像站"><a href="#部署ChatGPT镜像站" class="headerlink" title="部署ChatGPT镜像站"></a>部署ChatGPT镜像站</h1><p>ChatGPT镜像站源码很多，本文中选择Star数很高的ChuanhuChatGPT。</p><p>ChuanhuChatGPT优点：</p><ul><li>流式传输 / 无限对话 / 保存对话 / 预设Prompt集 / 联网搜索 / 根据文件回答</li><li>渲染LaTeX / 渲染表格 / 代码高亮 / 自动亮暗色切换 / 自适应界面 / “小而美”的体验</li><li>自定义api-Host / 多参数可调 / 多API Key均衡负载 / 多用户显示 / 适配GPT-4 / 支持本地部署LLM</li></ul><p>参考文档：</p><ul><li><a href="https://github.com/GaiZhenbiao/ChuanhuChatGPT">GaiZhenbiao/ChuanhuChatGPT</a></li><li><a href="https://github.com/GaiZhenbiao/ChuanhuChatGPT/wiki/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">ChuanhuChatGPT - 使用教程</a></li></ul><h2 id="打包服务镜像"><a href="#打包服务镜像" class="headerlink" title="打包服务镜像"></a>打包服务镜像</h2><p>1、克隆ChuanhuChatGPT项目，切换到指定版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/GaiZhenbiao/ChuanhuChatGPT.git</span><br><span class="line"><span class="built_in">cd</span> ChuanhuChatGPT</span><br><span class="line">git checkout 20230409</span><br></pre></td></tr></table></figure><p>2、打包镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t voidking/chuanhuchatgpt:20230409 .</span><br></pre></td></tr></table></figure><h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>1、准备配置文件<br>复制 config_example.json 为 /opt/chuanhuchatgpt/config.json，按照提示修改参数配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 你的OpenAI API Key，一般必填，</span></span><br><span class="line">    <span class="comment">// 若缺省填为 &quot;openai_api_key&quot;: &quot;&quot; 则必须再在图形界面中填入API Key</span></span><br><span class="line">    <span class="attr">&quot;openai_api_key&quot;</span><span class="punctuation">:</span> <span class="string">&quot;sk-xxxxxxxxxxxxxxxxxxxxxxxxx&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 如果使用代理，请取消注释下面的两行，并替换代理URL</span></span><br><span class="line">    <span class="comment">// &quot;https_proxy&quot;: &quot;http://127.0.0.1:1079&quot;,</span></span><br><span class="line">    <span class="comment">// &quot;http_proxy&quot;: &quot;http://127.0.0.1:1079&quot;,</span></span><br><span class="line">    <span class="attr">&quot;users&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">[</span><span class="string">&quot;用户1的用户名&quot;</span><span class="punctuation">,</span> <span class="string">&quot;用户1的密码&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">[</span><span class="string">&quot;用户2的用户名&quot;</span><span class="punctuation">,</span> <span class="string">&quot;用户2的密码&quot;</span><span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;advance_docs&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;pdf&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="comment">// 是否认为PDF是双栏的</span></span><br><span class="line">            <span class="attr">&quot;two_column&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="comment">// 是否使用OCR识别PDF中的公式</span></span><br><span class="line">            <span class="attr">&quot;formula_ocr&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// 是否多个API Key轮换使用</span></span><br><span class="line">    <span class="attr">&quot;multi_api_key&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;api_key_list&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;sk-xxxxxxxxxxxxxxxxxxxxxxxx1&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sk-xxxxxxxxxxxxxxxxxxxxxxxx2&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;sk-xxxxxxxxxxxxxxxxxxxxxxxx3&quot;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>其中users参数可以为空，<code>&quot;users&quot;: []</code>，表示不设置用户名密码。</p><p>建议配置：</p><ul><li>openai_api_key不用填，因为docker run时会覆盖这个参数。</li><li>填入用户名密码，避免被盗用。</li><li>启用multi_api_key，不用在页面输入key，而且拥有多个key时能够负载均衡。</li></ul><p>2、启动服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name chuanhuchatgpt -d \</span><br><span class="line">    -e my_api_key=<span class="string">&quot;替换成API&quot;</span> \</span><br><span class="line">    -e api_host=<span class="string">&quot;替换成自定义的api请求地址&quot;</span> \</span><br><span class="line">    -v /opt/chuanhuchatgpt/history:/app/history \</span><br><span class="line">    -v /opt/chuanhuchatgpt/config.json:/app/config.json \</span><br><span class="line">    -p 7860:7860 \</span><br><span class="line">    voidking/chuanhuchatgpt:20230409</span><br></pre></td></tr></table></figure><p>其中 my_api_key 必填，api_host 可省略。<br>config.json中配置的openai_api_key无效，因为my_api_key这里必填，会覆盖config.json中的配置。</p><p>3、查看服务状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs chuanhuchatgpt</span><br><span class="line">docker update --restart=always chuanhuchatgpt</span><br></pre></td></tr></table></figure><p>4、访问服务<br>浏览器访问 <code>http://&lt;主机IP&gt;:7860</code></p><h1 id="配置域名"><a href="#配置域名" class="headerlink" title="配置域名"></a>配置域名</h1><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-nginx-start/">《Nginx入门篇》</a></li><li><a href="https://github.com/GaiZhenbiao/ChuanhuChatGPT/wiki/%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B">ChuanhuChatGPT - 使用教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ChatGPT镜像站简介&quot;&gt;&lt;a href=&quot;#ChatGPT镜像站简介&quot; class=&quot;headerlink&quot; title=&quot;ChatGPT镜像站简介&quot;&gt;&lt;/a&gt;ChatGPT镜像站简介&lt;/h1&gt;&lt;p&gt;使用ChatGPT是有一定门槛的：科学上网，并且是特定地区科学上网。&lt;br&gt;近期ChatGPT开始封号，如果科学上网工具的出口IP频繁变化，那么ChatGPT账号可能被封。&lt;/p&gt;
&lt;p&gt;而搭建使用ChatGPT镜像站，可以降低国内使用ChatGPT的门槛，并且避免账号被封。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7217381222024233016&quot;&gt;教程：部署个人专属的 ChatGPT 镜像教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
  </entry>
  
  <entry>
    <title>K8S中Pod抓包</title>
    <link href="https://www.voidking.com/dev-k8s-pod-packet-capture/"/>
    <id>https://www.voidking.com/dev-k8s-pod-packet-capture/</id>
    <published>2023-03-02T19:10:00.000Z</published>
    <updated>2023-04-08T10:10:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pod抓包概述"><a href="#Pod抓包概述" class="headerlink" title="Pod抓包概述"></a>Pod抓包概述</h1><p>排查网络问题的最好方法就是抓包分析，在 Kubernetes 中对 Pod 进行抓包的常见方法包括：</p><ul><li>在 Pod 中安装 tcpdump 工具，直接对流量进行抓包，捕获网络流量并输出到文件或终端上。这种方法的优点是灵活性高，可以根据实际情况进行定制和调试，但需要在 Pod 中安装额外的工具，可能会增加 Pod 的大小和复杂度。</li><li>使用 kubectl port-forward 命令将 Pod 的网络流量转发到本地，然后使用本地的 tcpdump 工具对流量进行抓包。这种方法的优点是简单易用，不需要在 Pod 中安装额外的工具，但需要手动进行转发和抓包，可能不太方便。</li><li>使用 Kubernetes 中的网络插件提供的抓包功能，例如 Cilium、Weave Net、Calico 等。这些网络插件一般都提供了抓包工具或者抓包接口，可以直接对 Pod 的网络流量进行抓包，而无需在 Pod 中安装额外的工具或者进行手动转发。</li><li>登录 Pod 所在节点，进入容器 netns，然后使用节点上 tcpdump 工具进行抓包。</li></ul><p>以上方法都比较繁琐，令人惊喜的是出现了 ksniff，可以让我们在 Kubernetes 更简便地抓包。<br>本文中，我们会学习使用ksniff来进行Pod抓包。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-wireshark-start/">Wireshark入门篇</a></li><li><a href="https://github.com/eldadru/ksniff">eldadru/ksniff</a></li><li><a href="https://imroc.cc/post/202105/capture-packets-with-ksniff/">kubernetes 实用技巧: 使用 ksniff 抓包</a></li><li><a href="https://zhuanlan.zhihu.com/p/493202827">如何在 Kubernetes Pod 内进行网络抓包</a></li><li><a href="https://mp.weixin.qq.com/s/5gKpnvjSkvMDU-V6Mo77dQ">Kubernetes 网络异常分类及排错指南</a></li></ul><span id="more"></span><h1 id="ksniff抓包原理"><a href="#ksniff抓包原理" class="headerlink" title="ksniff抓包原理"></a>ksniff抓包原理</h1><h2 id="普通模式"><a href="#普通模式" class="headerlink" title="普通模式"></a>普通模式</h2><p>ksniff 上传 tcpdump 二进制文件到目标 Pod 的一个容器里，然后执行二进制文件来实现抓包。</p><h2 id="特权模式"><a href="#特权模式" class="headerlink" title="特权模式"></a>特权模式</h2><p>ksniff 启动另外一个pod，和目标pod共享network namespace，抓取目标pod中的网络包。</p><h1 id="安装wireshark"><a href="#安装wireshark" class="headerlink" title="安装wireshark"></a>安装wireshark</h1><p>wireshark安装方法参考文档<a href="https://www.voidking.com/dev-wireshark-start/">《Wireshark入门篇》</a></p><h1 id="安装ksniff"><a href="#安装ksniff" class="headerlink" title="安装ksniff"></a>安装ksniff</h1><p>1、安装krew<br>krew安装方法参考文档<a href="https://www.voidking.com/dev-kubectl-krew/">《kubectl插件管理器krew》</a></p><p>2、安装ksniff</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl krew install sniff</span><br><span class="line">kubectl sniff --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><h1 id="使用ksniff"><a href="#使用ksniff" class="headerlink" title="使用ksniff"></a>使用ksniff</h1><h2 id="创建测试容器"><a href="#创建测试容器" class="headerlink" title="创建测试容器"></a>创建测试容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run <span class="built_in">test</span> --image=busybox --<span class="built_in">command</span> <span class="built_in">sleep</span> 7200</span><br></pre></td></tr></table></figure><h2 id="实时抓包"><a href="#实时抓包" class="headerlink" title="实时抓包"></a>实时抓包</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl sniff <span class="built_in">test</span> -n default</span><br></pre></td></tr></table></figure><p>执行该命令后，会自动弹出本地安装的 wireshark 并实时捕获。<br>如果报错Error: signal: abort trap，可以尝试再次执行该命令。</p><h2 id="执行一些网络命令"><a href="#执行一些网络命令" class="headerlink" title="执行一些网络命令"></a>执行一些网络命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it <span class="built_in">test</span> -- /bin/sh</span><br><span class="line">nslookup www.baidu.com</span><br></pre></td></tr></table></figure><p>pod中执行命令后，会在wireshark中看到捕获的网络包。</p><h2 id="抓包保存成文件"><a href="#抓包保存成文件" class="headerlink" title="抓包保存成文件"></a>抓包保存成文件</h2><p>有时我们可能无法直接在本地执行 kubectl，这时可以先抓包保存成文件，然后拷贝到本地使用wireshark进行分析。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl sniff <span class="built_in">test</span> -n default -o test.pcap</span><br></pre></td></tr></table></figure><h2 id="特权模式-1"><a href="#特权模式-1" class="headerlink" title="特权模式"></a>特权模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl sniff <span class="built_in">test</span> -n default -p</span><br></pre></td></tr></table></figure><h2 id="查看明文"><a href="#查看明文" class="headerlink" title="查看明文"></a>查看明文</h2><p>如果数据包内容很多都是明文 (比如 HTTP)，只希望大概看下明文内容，可以指定 -o - 将抓包内容直接打印到标准输出 (stdout)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl sniff <span class="built_in">test</span> -n default -o -</span><br></pre></td></tr></table></figure><h2 id="抓包时过滤"><a href="#抓包时过滤" class="headerlink" title="抓包时过滤"></a>抓包时过滤</h2><p>指定 tcpdump 过滤条件，屏蔽掉不需要的数据，避免数据量过大。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl sniff <span class="built_in">test</span> -n default -f <span class="string">&quot;port 80&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Pod抓包概述&quot;&gt;&lt;a href=&quot;#Pod抓包概述&quot; class=&quot;headerlink&quot; title=&quot;Pod抓包概述&quot;&gt;&lt;/a&gt;Pod抓包概述&lt;/h1&gt;&lt;p&gt;排查网络问题的最好方法就是抓包分析，在 Kubernetes 中对 Pod 进行抓包的常见方法包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Pod 中安装 tcpdump 工具，直接对流量进行抓包，捕获网络流量并输出到文件或终端上。这种方法的优点是灵活性高，可以根据实际情况进行定制和调试，但需要在 Pod 中安装额外的工具，可能会增加 Pod 的大小和复杂度。&lt;/li&gt;
&lt;li&gt;使用 kubectl port-forward 命令将 Pod 的网络流量转发到本地，然后使用本地的 tcpdump 工具对流量进行抓包。这种方法的优点是简单易用，不需要在 Pod 中安装额外的工具，但需要手动进行转发和抓包，可能不太方便。&lt;/li&gt;
&lt;li&gt;使用 Kubernetes 中的网络插件提供的抓包功能，例如 Cilium、Weave Net、Calico 等。这些网络插件一般都提供了抓包工具或者抓包接口，可以直接对 Pod 的网络流量进行抓包，而无需在 Pod 中安装额外的工具或者进行手动转发。&lt;/li&gt;
&lt;li&gt;登录 Pod 所在节点，进入容器 netns，然后使用节点上 tcpdump 工具进行抓包。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上方法都比较繁琐，令人惊喜的是出现了 ksniff，可以让我们在 Kubernetes 更简便地抓包。&lt;br&gt;本文中，我们会学习使用ksniff来进行Pod抓包。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-wireshark-start/&quot;&gt;Wireshark入门篇&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/eldadru/ksniff&quot;&gt;eldadru/ksniff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://imroc.cc/post/202105/capture-packets-with-ksniff/&quot;&gt;kubernetes 实用技巧: 使用 ksniff 抓包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/493202827&quot;&gt;如何在 Kubernetes Pod 内进行网络抓包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/5gKpnvjSkvMDU-V6Mo77dQ&quot;&gt;Kubernetes 网络异常分类及排错指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
    <category term="网络" scheme="https://www.voidking.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="kubectl" scheme="https://www.voidking.com/tags/kubectl/"/>
    
    <category term="wireshark" scheme="https://www.voidking.com/tags/wireshark/"/>
    
  </entry>
  
  <entry>
    <title>GitLab Pipeline统计</title>
    <link href="https://www.voidking.com/dev-gitlab-pipeline-statistics/"/>
    <id>https://www.voidking.com/dev-gitlab-pipeline-statistics/</id>
    <published>2023-02-28T17:00:00.000Z</published>
    <updated>2023-02-28T17:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>计划对CICD进行优化，主要包括降低pipeline的失败率和降低构建发布时间。</p><p>最开始，要对pipeline进行统计，搞清楚当前的情况，做到心里有“数”，制定合理的目标。<br>优化一段时间后，需要再用相同的统计方法对pipeline进行统计，看看优化的效果。</p><p>好了，问题来了：怎样统计最近两个月的gitlab pipeline？<br>具体需求包括： </p><ul><li>总的pipeline次数</li><li>成功的pipeline次数</li><li>失败的pipeline次数</li><li>取消的pipeline次数</li><li>跳过的pipeline次数</li><li>耗时超过5分钟的pipeline次数</li><li>耗时超过10分钟的pipeline次数</li><li>耗时超过半小时的pipeline次数</li><li>耗时超过1小时的pipeline次数</li><li>pipeline的失败率</li></ul><p>使用GitLab的<a href="https://gitlab.voidking.com/admin/usage_trends">Analytics</a>可以看到部分我们想要的数据，比如某个月的pipeline总次数，失败的总次数等。但是并不能根据我们的需要选择时间段进行统计，也不能统计pipeline的持续时间，因此最好的方法是通过GitLab API进行统计。</p><p>参考文档：<a href="https://docs.gitlab.com/ee/api/pipelines.html">Pipelines API</a></p><span id="more"></span><h1 id="需求处理"><a href="#需求处理" class="headerlink" title="需求处理"></a>需求处理</h1><p>以下内容主要来自chatgpt，稍作修改。</p><h2 id="获取API-Token"><a href="#获取API-Token" class="headerlink" title="获取API Token"></a>获取API Token</h2><p>在 GitLab 中获取 API 访问 token 的步骤如下：</p><ol><li><p>登录到 GitLab 网站。</p></li><li><p>点击右上角头像，选择 “Settings”。</p></li><li><p>在左侧菜单栏中，选择 “Access Tokens”。</p></li><li><p>输入一个描述信息，并选择需要授予 API 访问权限的范围，然后点击 “Create Personal Access Token”。</p></li><li><p>复制生成的访问 token。</p></li></ol><p>请注意，访问 token 是敏感信息，请妥善保管，不要泄露给他人。此外，为了保证安全性，建议定期更换访问 token。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>完整代码请访问：<a href="https://github.com/voidking/hexo-storage/blob/main/gitlab-pipeline-statistics/statistics.py">gitlab-pipeline-statistics/statistics.py</a></p><p>以上代码适用于GitLab 14.0.5 ，其他版本不一定适用。</p><p>注意：成功次数+失败次数+取消次数+跳过次数 != 总次数<br>因为除了这四种常见状态，还有七种状态，具体状态可以参考<a href="https://docs.gitlab.com/ee/api/pipelines.html">Pipelines API</a>。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h1&gt;&lt;p&gt;计划对CICD进行优化，主要包括降低pipeline的失败率和降低构建发布时间。&lt;/p&gt;
&lt;p&gt;最开始，要对pipeline进行统计，搞清楚当前的情况，做到心里有“数”，制定合理的目标。&lt;br&gt;优化一段时间后，需要再用相同的统计方法对pipeline进行统计，看看优化的效果。&lt;/p&gt;
&lt;p&gt;好了，问题来了：怎样统计最近两个月的gitlab pipeline？&lt;br&gt;具体需求包括： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总的pipeline次数&lt;/li&gt;
&lt;li&gt;成功的pipeline次数&lt;/li&gt;
&lt;li&gt;失败的pipeline次数&lt;/li&gt;
&lt;li&gt;取消的pipeline次数&lt;/li&gt;
&lt;li&gt;跳过的pipeline次数&lt;/li&gt;
&lt;li&gt;耗时超过5分钟的pipeline次数&lt;/li&gt;
&lt;li&gt;耗时超过10分钟的pipeline次数&lt;/li&gt;
&lt;li&gt;耗时超过半小时的pipeline次数&lt;/li&gt;
&lt;li&gt;耗时超过1小时的pipeline次数&lt;/li&gt;
&lt;li&gt;pipeline的失败率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用GitLab的&lt;a href=&quot;https://gitlab.voidking.com/admin/usage_trends&quot;&gt;Analytics&lt;/a&gt;可以看到部分我们想要的数据，比如某个月的pipeline总次数，失败的总次数等。但是并不能根据我们的需要选择时间段进行统计，也不能统计pipeline的持续时间，因此最好的方法是通过GitLab API进行统计。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;a href=&quot;https://docs.gitlab.com/ee/api/pipelines.html&quot;&gt;Pipelines API&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="cicd" scheme="https://www.voidking.com/tags/cicd/"/>
    
    <category term="gitlab" scheme="https://www.voidking.com/tags/gitlab/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置GitHub Actions自动构建发布</title>
    <link href="https://www.voidking.com/dev-hexo-github-actions/"/>
    <id>https://www.voidking.com/dev-hexo-github-actions/</id>
    <published>2023-02-25T20:00:00.000Z</published>
    <updated>2023-02-26T19:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Travis-CI必须付费了"><a href="#Travis-CI必须付费了" class="headerlink" title="Travis CI必须付费了"></a>Travis CI必须付费了</h1><p>2023年2月25日，使用travis ci部署hexo项目，发现并没有触发任务。</p><p>登录<a href="https://www.travis-ci.com/">travis ci</a>，发现提示：</p><blockquote><p>Builds have been temporarily disabled for public repositories due to a negative credit balance. Please go to the Plan page to replenish your credit balance or alter your Consume paid credits for OSS setting.</p></blockquote><p>在<a href="https://app.travis-ci.com/account/plan">travis ci plan</a>页面关闭了Consume paid credits for OSS，但是依然提示：</p><blockquote><p>Builds have been temporarily disabled for private and public repositories due to a negative credit balance. Please go to the Plan page to replenish your credit balance.</p></blockquote><p>点击Change plan，发现已经没有免费的plan了，而最便宜的plan，也要<code>$69/monthly</code>，太贵了，放弃。<br>不过可以理解，毕竟跑CI是需要服务器的，服务器是需要花钱的。</p><p>那就换成<a href="https://docs.github.com/en/actions">GitHub Actions</a>吧，有付费版，也有免费版。</p><span id="more"></span><h1 id="Quickstart-for-GitHub-Actions"><a href="#Quickstart-for-GitHub-Actions" class="headerlink" title="Quickstart for GitHub Actions"></a>Quickstart for GitHub Actions</h1><p>参考文档：<a href="https://docs.github.com/en/actions/quickstart">Quickstart for GitHub Actions</a></p><p>1、 创建新的分支（因为原分支是适用于travis ci的）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b github-action</span><br><span class="line">git push origin HEAD:github-action</span><br></pre></td></tr></table></figure><p>2、 创建 github-actions-demo.yml 文件<br><a href="https://github.com/voidking/hexo-deploy">voidking/hexo-deploy</a>项目中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p .github/workflows</span><br><span class="line">vim .github/workflows/github-actions-demo.yml</span><br></pre></td></tr></table></figure><p>github-actions-demo.yml 文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">GitHub</span> <span class="string">Actions</span> <span class="string">Demo</span></span><br><span class="line"><span class="attr">run-name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.actor</span> <span class="string">&#125;&#125;</span> <span class="string">is</span> <span class="string">testing</span> <span class="string">out</span> <span class="string">GitHub</span> <span class="string">Actions</span> <span class="string">🚀</span></span><br><span class="line"><span class="attr">on:</span> [<span class="string">push</span>]</span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">Explore-GitHub-Actions:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;🎉 The job was automatically triggered by a $<span class="template-variable">&#123;&#123; github.event_name &#125;&#125;</span> event.&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;🐧 This job is now running on a $<span class="template-variable">&#123;&#123; runner.os &#125;&#125;</span> server hosted by GitHub!&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;🔎 The name of your branch is $<span class="template-variable">&#123;&#123; github.ref &#125;&#125;</span> and your repository is $<span class="template-variable">&#123;&#123; github.repository &#125;&#125;</span>.&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Check</span> <span class="string">out</span> <span class="string">repository</span> <span class="string">code</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v3</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;💡 The $<span class="template-variable">&#123;&#123; github.repository &#125;&#125;</span> repository has been cloned to the runner.&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;🖥️ The workflow is now ready to test your code on the runner.&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">List</span> <span class="string">files</span> <span class="string">in</span> <span class="string">the</span> <span class="string">repository</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          ls $&#123;&#123; github.workspace &#125;&#125;</span></span><br><span class="line"><span class="string"></span>      <span class="bullet">-</span> <span class="attr">run:</span> <span class="string">echo</span> <span class="string">&quot;🍏 This job&#x27;s status is $<span class="template-variable">&#123;&#123; job.status &#125;&#125;</span>.&quot;</span></span><br></pre></td></tr></table></figure><p>3、 上传代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;github action test&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>报错：refusing to allow a Personal Access Token to create or update workflow <code>.github/workflows/github-actions-demo.yml</code> without <code>workflow</code> scope</p><p>这是因为我们的Access Token需要具有create or update workflow的权限，因此需要重新创建一个Access Token。<br>具体操作方法：访问<a href="https://github.com/settings/tokens">Personal access tokens (classic)</a>页面，Generate new token，生成token时一定要勾选repo和workflow。</p><p>然后，使用新的token再次push即可。修改token的方法参考文档<a href="https://www.voidking.com/dev-git/command/">《Git实用命令》</a>。</p><p>4、查看Actions<br>访问<a href="https://github.com/voidking/hexo-deploy/actions">voidking/hexo-deploy Actions</a>页面，即可看到CI workflows（相当于gitlab中的pipelines）。</p><h1 id="Hexo配置GitHub-Actions"><a href="#Hexo配置GitHub-Actions" class="headerlink" title="Hexo配置GitHub Actions"></a>Hexo配置GitHub Actions</h1><p>参考文档：</p><ul><li><a href="https://docs.github.com/en/actions">GitHub Actions</a></li><li><a href="https://docs.github.com/en/actions/using-workflows/workflow-syntax-for-github-actions">Workflow syntax for GitHub Actions</a></li><li><a href="https://github.com/marketplace/actions/hexo-action">Hexo Action</a></li><li><a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">利用 Github Actions 自动部署 Hexo 博客</a></li><li><a href="https://www.ruanyifeng.com/blog/2019/12/github_actions.html">GitHub Actions 教程：定时发送天气邮件</a></li></ul><h2 id="CICD思路"><a href="#CICD思路" class="headerlink" title="CICD思路"></a>CICD思路</h2><ol><li>拉取负责部署的hexo-deploy repo，里面是hexo的配置文件（关于站点配置和构建配置等，详情参考<a href="https://www.voidking.com/dev-hexo-travis-ci/">《Hexo配置Travis CI自动构建发布》</a>）</li><li>拉取hexo theme repo，里面是站点主题</li><li>拉取hexo-backup repo，里面是markdown文档</li><li>hexo-backup中的文档放到hexo可以构建（编译）的位置</li><li>安装nodejs</li><li>安装hexo、gulp等依赖</li><li>执行构建（编译）</li><li>上传编译后的html等静态文件到两个pages repo<br>a. github pages是国外流量的源站<br>b. aliyun server是国内流量的源站<br>c. aliyun server从gitee pages拉取最新版本<br>d. gitee pages本身不对外提供服务，只是作为一个git仓库</li><li>aliyun server从gitee pages拉取最新版本</li></ol><h2 id="准备github-actions-yml"><a href="#准备github-actions-yml" class="headerlink" title="准备github-actions.yml"></a>准备github-actions.yml</h2><p>github-actions.yml内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">CICD</span></span><br><span class="line"><span class="attr">run-name:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.actor</span> <span class="string">&#125;&#125;</span> <span class="string">build</span> <span class="string">and</span> <span class="string">deploy</span> <span class="string">hexo!</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">github-actions</span></span><br><span class="line"></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">GIT_USER:</span> <span class="string">voidking</span></span><br><span class="line">  <span class="attr">HEXO_BACKUP_REPO:</span> <span class="string">voidking/hexo-backup</span></span><br><span class="line">  <span class="attr">HEXO_BACKUP_REPO_BRANCH:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">HEXO_THEME_REPO:</span> <span class="string">voidking/hexo-theme-next</span></span><br><span class="line">  <span class="attr">HEXO_THEME_REPO_BRANCH:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">GITHUB_PAGES_REPO:</span> <span class="string">github.com/voidking/voidking.github.io.git</span></span><br><span class="line">  <span class="attr">GITEE_PAGES_REPO:</span> <span class="string">gitee.com/voidking/voidking.git</span></span><br><span class="line">  <span class="attr">GITHUB_PAGES_URL:</span> <span class="string">&quot;https://$&#123;GIT_USER&#125;:$<span class="template-variable">&#123;&#123; secrets.GH_TOKEN &#125;&#125;</span>@$&#123;GITHUB_PAGES_REPO&#125;&quot;</span></span><br><span class="line">  <span class="attr">GITEE_PAGES_URL:</span> <span class="string">&quot;https://$&#123;GIT_USER&#125;:$<span class="template-variable">&#123;&#123; secrets.GITEE_TOKEN &#125;&#125;</span>@$&#123;GITEE_PAGES_REPO&#125;&quot;</span></span><br><span class="line">  <span class="attr">ALI_IP:</span> <span class="number">8.136</span><span class="number">.13</span><span class="number">.58</span></span><br><span class="line">  <span class="attr">ALI_USER:</span> <span class="string">voidking</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span> <span class="string">on</span> <span class="string">node</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span> <span class="string">and</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.os</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">os:</span> [<span class="string">ubuntu-latest</span>]</span><br><span class="line">        <span class="attr">node_version:</span> [<span class="number">12.22</span><span class="number">.5</span>]</span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">theme</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.HEXO_THEME_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.HEXO_THEME_REPO_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">themes/next</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">hexo-backup</span> <span class="string">repo</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">repository:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.HEXO_BACKUP_REPO</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.HEXO_BACKUP_REPO_BRANCH</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">hexo-backup</span></span><br><span class="line">        <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.GH_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Move</span> <span class="string">markdown</span> <span class="string">articles</span> <span class="string">to</span> <span class="string">current</span> <span class="string">directory</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">mv</span> <span class="string">hexo-backup/source</span> <span class="string">.</span> <span class="string">&amp;&amp;</span> <span class="string">rm</span> <span class="string">-rf</span> <span class="string">source/private</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">nodejs</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-node@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">node-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">nodejs</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">nodejs</span> <span class="string">project</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Push</span> <span class="string">to</span> <span class="string">voidking.github.io</span> <span class="string">and</span> <span class="string">gitee</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        git config --global user.name &quot;voidking&quot;</span></span><br><span class="line"><span class="string">        git config --global user.email &quot;voidking@qq.com&quot;</span></span><br><span class="line"><span class="string">        git clone https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@$&#123;&#123; env.GITHUB_PAGES_REPO &#125;&#125; voidking</span></span><br><span class="line"><span class="string">        cd voidking</span></span><br><span class="line"><span class="string">        rm -rfv `ls -a | grep -vw &#x27;\.&#x27; | grep -vw &#x27;\.git&#x27; | xargs`</span></span><br><span class="line"><span class="string">        ls -al</span></span><br><span class="line"><span class="string">        # unalias cp </span></span><br><span class="line"><span class="string">        cp -rf ../public/. .</span></span><br><span class="line"><span class="string">        cp ../source/.travis.yml .</span></span><br><span class="line"><span class="string">        git add . &amp;&amp; git commit -m &quot;GitHub Actions Auto Builder&quot;</span></span><br><span class="line"><span class="string">        git push --force --quiet $&#123;&#123; env.GITHUB_PAGES_URL &#125;&#125; master:master</span></span><br><span class="line"><span class="string">        git push --force --quiet $&#123;&#123; env.GITEE_PAGES_URL &#125;&#125; master:master</span></span><br><span class="line"><span class="string"></span>  </span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Deploy</span> <span class="string">to</span> <span class="string">Aliyun</span> <span class="string">Server</span></span><br><span class="line">    <span class="attr">needs:</span> <span class="string">build</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">id_rsa</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        mkdir -p ~/.ssh/</span></span><br><span class="line"><span class="string">        echo $&#123;&#123; secrets.ID_RSA &#125;&#125; | base64 -d &gt; ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string">        chmod 600 ~/.ssh/id_rsa</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Execute</span> <span class="string">ssh</span> <span class="string">command</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        ssh -o StrictHostKeyChecking=no \</span></span><br><span class="line"><span class="string">        -o PubkeyAcceptedKeyTypes=ssh-rsa \</span></span><br><span class="line"><span class="string">        $&#123;&#123; env.ALI_USER &#125;&#125;@$&#123;&#123; env.ALI_IP &#125;&#125; \</span></span><br><span class="line"><span class="string">        &quot;cd /opt/nginx/work/voidking/ &amp;&amp; git pull --force --quiet $&#123;&#123; env.GITEE_PAGES_URL &#125;&#125; master:master&quot;</span></span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>github action中定义变量有三种方式：vars、secrets和env。</li><li>vars/secrets在workflow触发前定义，env在workflow触发后定义。</li><li><code>$&#123;&#123;&#125;&#125;</code>双花括号表示上下文引用，详情参考<a href="https://docs.github.com/en/actions/learn-github-actions/contexts#context-availability">Context availability</a>。</li><li><code>$&#123;&#125;</code>单花括号表示shell方式使用中env变量。</li><li>使用env中的变量有两种方式：上下文引用和shell方式使用。</li></ul><h2 id="配置加密变量"><a href="#配置加密变量" class="headerlink" title="配置加密变量"></a>配置加密变量</h2><p>上面的workflow配置中，用到了一些敏感变量，GH_TOKEN、GITEE_TOKEN和ID_RSA，这些变量需要加密。</p><p>配置加密变量的方法：</p><ul><li>repository级别变量：Project -&gt; Settings -&gt; Actions secrets and variables -&gt; New repository secret</li><li>environments级别变量：Project -&gt; Settings -&gt; Actions secrets and variables -&gt; Manage enviroments -&gt; New enviroment -&gt; Environment secrets -&gt; Add secret</li></ul><p>其中ID_RSA的获取方法为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen</span><br><span class="line">ALI_IP=<span class="string">&quot;8.136.13.58&quot;</span></span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub voidking@<span class="variable">$&#123;ALI_IP&#125;</span></span><br><span class="line"><span class="built_in">cat</span> .ssh/id_rsa | <span class="built_in">base64</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="CICD测试"><a href="#CICD测试" class="headerlink" title="CICD测试"></a>CICD测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;github action test&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>访问<a href="https://github.com/voidking/hexo-deploy/actions">voidking/hexo-deploy Actions</a>页面，即可看到最新的workflow。<br>最开始难免出错，根据报错进行调整即可。</p><p>最终，实现了和travis ci上一样的功能，nice。</p><h1 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h1><h2 id="env不能用在job-if"><a href="#env不能用在job-if" class="headerlink" title="env不能用在job:if"></a>env不能用在job:if</h2><p>当使用job:if时，如下定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">BUILD:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">env.BUILD</span> <span class="string">==</span> <span class="string">&quot;true&quot;</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br></pre></td></tr></table></figure><p>报错： Unrecognized named-value: ‘env’. Located at position 1 within expression: env.BUILD == “true” .github/workflows/github-actions.yml</p><p>这是个github action的坑，参考文档：</p><ul><li><a href="https://github.com/actions/runner/issues/480">Workflow level env does not work properly in all fields.</a></li><li><a href="https://github.com/actions/runner/issues/1661">workflow level env. is unrecognised on job level’s ‘if’-expression when calling reusable workflow</a></li></ul><h2 id="workflow-dispatch无效"><a href="#workflow-dispatch无效" class="headerlink" title="workflow_dispatch无效"></a>workflow_dispatch无效</h2><p>当使用job:if时，如下定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">workflow_dispatch:</span></span><br><span class="line">    <span class="attr">inputs:</span></span><br><span class="line">      <span class="attr">build:</span></span><br><span class="line">        <span class="attr">description:</span> <span class="string">&quot;build project&quot;</span></span><br><span class="line">        <span class="attr">required:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">default:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">boolean</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">Build</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">inputs.build</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br></pre></td></tr></table></figure><p>无法触发build job。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Travis-CI必须付费了&quot;&gt;&lt;a href=&quot;#Travis-CI必须付费了&quot; class=&quot;headerlink&quot; title=&quot;Travis CI必须付费了&quot;&gt;&lt;/a&gt;Travis CI必须付费了&lt;/h1&gt;&lt;p&gt;2023年2月25日，使用travis ci部署hexo项目，发现并没有触发任务。&lt;/p&gt;
&lt;p&gt;登录&lt;a href=&quot;https://www.travis-ci.com/&quot;&gt;travis ci&lt;/a&gt;，发现提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Builds have been temporarily disabled for public repositories due to a negative credit balance. Please go to the Plan page to replenish your credit balance or alter your Consume paid credits for OSS setting.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;a href=&quot;https://app.travis-ci.com/account/plan&quot;&gt;travis ci plan&lt;/a&gt;页面关闭了Consume paid credits for OSS，但是依然提示：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Builds have been temporarily disabled for private and public repositories due to a negative credit balance. Please go to the Plan page to replenish your credit balance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;点击Change plan，发现已经没有免费的plan了，而最便宜的plan，也要&lt;code&gt;$69/monthly&lt;/code&gt;，太贵了，放弃。&lt;br&gt;不过可以理解，毕竟跑CI是需要服务器的，服务器是需要花钱的。&lt;/p&gt;
&lt;p&gt;那就换成&lt;a href=&quot;https://docs.github.com/en/actions&quot;&gt;GitHub Actions&lt;/a&gt;吧，有付费版，也有免费版。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="hexo" scheme="https://www.voidking.com/categories/engineering/hexo/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="cicd" scheme="https://www.voidking.com/tags/cicd/"/>
    
    <category term="hexo" scheme="https://www.voidking.com/tags/hexo/"/>
    
    <category term="travis-ci" scheme="https://www.voidking.com/tags/travis-ci/"/>
    
    <category term="github-actions" scheme="https://www.voidking.com/tags/github-actions/"/>
    
  </entry>
  
  <entry>
    <title>CentOS8更换软件安装源</title>
    <link href="https://www.voidking.com/dev-centos8-change-repo/"/>
    <id>https://www.voidking.com/dev-centos8-change-repo/</id>
    <published>2023-02-07T17:00:00.000Z</published>
    <updated>2023-02-07T17:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>CentOS8已于2021年12月31日停止维护，在2022年1月31日，CentOS团队终于从官方镜像中移除CentOS8的所有包。</p><p>如果仍然需要运行CentOS8，我们可以在/etc/yum.repos.d中更新安装源。</p><span id="more"></span><h1 id="更换方法"><a href="#更换方法" class="headerlink" title="更换方法"></a>更换方法</h1><p>1、备份原安装源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r /etc/yum.repos.d&#123;,.bak&#125;</span><br></pre></td></tr></table></figure><p>2、替换安装源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> /etc/yum.repos.d/*.repo -rf</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo</span><br><span class="line"><span class="comment">#curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-vault-8.5.2111.repo</span></span><br></pre></td></tr></table></figure><p>3、更新安装源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;CentOS8已于2021年12月31日停止维护，在2022年1月31日，CentOS团队终于从官方镜像中移除CentOS8的所有包。&lt;/p&gt;
&lt;p&gt;如果仍然需要运行CentOS8，我们可以在/etc/yum.repos.d中更新安装源。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="centos" scheme="https://www.voidking.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>Docker问题记录</title>
    <link href="https://www.voidking.com/dev-docker-problem/"/>
    <id>https://www.voidking.com/dev-docker-problem/</id>
    <published>2022-11-15T16:00:00.000Z</published>
    <updated>2023-06-22T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录使用Docker过程中遇到的问题和解决办法。</p><span id="more"></span><h1 id="docker启动失败"><a href="#docker启动失败" class="headerlink" title="docker启动失败"></a>docker启动失败</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>docker启动卡住，查看日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker -l</span><br><span class="line">journalctl -ru docker</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error (Unable to complete atomic operation, key modified) deleting object [endpoint 622bf1a499580702606742e5f5554ac99e7c0d61abcd5d9063881fc2da33d16f afdce62ce70de2cbe5a971b05521280940947e4968c163e48c3e5252919a4fae], retrying....</span><br></pre></td></tr></table></figure><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep docker</span><br><span class="line"><span class="built_in">kill</span> -9 xxx</span><br><span class="line">systemctl stop containerd</span><br><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure><h1 id="OCI-runtime-create-failed"><a href="#OCI-runtime-create-failed" class="headerlink" title="OCI runtime create failed"></a>OCI runtime create failed</h1><h2 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><p>原本可以正常启动nvidia runtime的容器，使用相同的启动命令，突然有一天开始报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: process_linux.go:545: container init caused: Running hook #1:: error running hook: exit status 1, stdout: , stderr: nvidia-container-cli: initialization error: driver error: failed to process request: unknown.</span><br><span class="line"></span><br><span class="line">docker: Error response from daemon: OCI runtime create failed: container_linux.go:380: starting container process caused: process_linux.go:545: container init caused: Running hook #1:: error running hook: exit status 1, stdout: , stderr: Auto-detected mode as &#x27;legacy&#x27;</span><br><span class="line">nvidia-container-cli: initialization error: load library failed: /usr/bin/../lib64/libm.so.6: symbol __strtof128_nan, version glibc_private not defined in file libc.so.6 with link time reference: unknown.</span><br></pre></td></tr></table></figure><h2 id="解决办法-1"><a href="#解决办法-1" class="headerlink" title="解决办法"></a>解决办法</h2><p>尝试了重启docker、重启主机、重装nvidia-container-tookit、重装nvidia驱动，全部无效。</p><p>最终解决办法：检查libm.so.6的软链指向，修改指向到另外的libm。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin/../lib64/</span><br><span class="line"><span class="built_in">ln</span> -snf libm-2.17.so  libm.so.6</span><br></pre></td></tr></table></figure><h1 id="error-pulling-image-configuration"><a href="#error-pulling-image-configuration" class="headerlink" title="error pulling image configuration"></a>error pulling image configuration</h1><h2 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p><code>docker pull ubuntu</code> 报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/ubuntu</span><br><span class="line">6b851dcae6ca: Pulling fs layer</span><br><span class="line">error pulling image configuration: Get https://production.cloudflare.docker.com/registry-v2/docker/registry/v2/blobs/sha256/99/99284ca6cea039c7784d1414608c6e846dd56830c2a13e1341be681c3ffcc8ac/data?verify=1687183284-D5%2FDxEvl7V%2BLtRcgWmwP0MDFiTo%3D: dial tcp 104.18.125.25:443: i/o timeout</span><br></pre></td></tr></table></figure><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>production.cloudflare.docker.com 的IP是会变化的，当前的这个 104.18.121.25 刚好被墙了，无法访问。<br>查看是否被墙的办法：访问<a href="https://www.itdog.cn/http/">ITDOG</a>，输入 production.cloudflare.docker.com 这个网址。</p><h2 id="解决办法一"><a href="#解决办法一" class="headerlink" title="解决办法一"></a>解决办法一</h2><p>配置使用镜像站，从镜像站拉取镜像，避开 production.cloudflare.docker.com 这个域名。</p><p>1、编辑docker配置文件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json</span><br></pre></td></tr></table></figure><p>添加 registry-mirrors 配置，配置方法参考<a href="https://www.voidking.com/dev-docker-registry-mirror/">《Docker镜像站的配置和使用》</a></p><p>2、重启docker</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br><span class="line">docker info</span><br></pre></td></tr></table></figure><h2 id="解决办法二"><a href="#解决办法二" class="headerlink" title="解决办法二"></a>解决办法二</h2><p>解决办法一，有时也不可行，因为有可能全国都被墙了，镜像站也无法从源站拉取我们需要的镜像。</p><p>此时只能使用终极解决办法：使用梯子。<br>方法一：机器上直接配置使用梯子，配置方法参考<a href="https://www.voidking.com/dev-linux-network-proxy/">《Linux配置网络代理》</a>。<br>方法二：搭建一个docker本地镜像站，配置使用梯子；其他机器配置使用这个docker镜像站。配置方法参考<a href="https://www.voidking.com/dev-docker-registry-mirror/">《Docker镜像站的配置和使用》</a>。</p><h1 id="failed-to-compute-cache-key"><a href="#failed-to-compute-cache-key" class="headerlink" title="failed to compute cache key"></a>failed to compute cache key</h1><h2 id="问题描述-3"><a href="#问题描述-3" class="headerlink" title="问题描述"></a>问题描述</h2><p>已知Dockerfile内容为：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> alpine:<span class="number">3.7</span>.<span class="number">3</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/work</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> Dockerfile .</span></span><br></pre></td></tr></table></figure><p>Dockerfile所在目录，执行<code>docker build</code>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">failed to compute cache key: failed to calculate checksum of ref moby::heujqm1lca2el12jsbquzoarg: &quot;/Dockerfile&quot;: not found</span><br></pre></td></tr></table></figure><h2 id="解决办法-2"><a href="#解决办法-2" class="headerlink" title="解决办法"></a>解决办法</h2><p>检查 <code>.dockerignore</code> 文件，大概率是因为该文件中忽略了 <code>Dockerfile</code> 。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文记录使用Docker过程中遇到的问题和解决办法。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="gpu" scheme="https://www.voidking.com/tags/gpu/"/>
    
  </entry>
  
  <entry>
    <title>GitLab CI配置代码质量检查</title>
    <link href="https://www.voidking.com/dev-gitlab-ci-code-quality-check/"/>
    <id>https://www.voidking.com/dev-gitlab-ci-code-quality-check/</id>
    <published>2022-11-11T14:00:00.000Z</published>
    <updated>2023-02-13T17:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="怎样保证代码质量？"><a href="#怎样保证代码质量？" class="headerlink" title="怎样保证代码质量？"></a>怎样保证代码质量？</h1><p>保证代码质量有三种常用的方法：Code Review、编码规范和单元测试。</p><p>Code Review需要别人帮助Review，现在可以找ChatGPT帮助Review。<br>而对于编码规范检查和运行单元测试，是可以通过CI流水线自动完成的。<br>本文中，我们学习在GitLab CI流水线中配置编码规范检查和运行单元测试。</p><span id="more"></span><h1 id="编码规范检查"><a href="#编码规范检查" class="headerlink" title="编码规范检查"></a>编码规范检查</h1><p>参考文档：</p><ul><li><a href="https://docs.gitlab.com/ee/ci/testing/code_quality.html">Code Quality</a></li><li><a href="https://gitlab.com/gitlab-org/ci-cd/codequality/-/tree/master">gitlab-org/ci-cd/codequality</a></li></ul><p>GitLab官方给的文档，使用codeclimate进行编码规范检查。<br>针对python，我们不使用codeclimate，而是使用更加常用的pylint或者flake8。</p><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">code_check</span></span><br><span class="line"></span><br><span class="line"><span class="attr">code_check:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">code_check</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:3.7.10-slim-buster</span></span><br><span class="line">  <span class="attr">before_script:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">pylint</span> <span class="string">-i</span> <span class="string">https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pylint</span> <span class="string">**/*.py</span></span><br></pre></td></tr></table></figure><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">unittest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">unittest:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">unittest</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:3.7.10-slim-buster</span></span><br><span class="line">  <span class="attr">before_script:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">pytest</span> <span class="string">-i</span> <span class="string">https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pytest</span> <span class="string">--junitxml=report.xml</span> <span class="string">tests/</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">reports:</span></span><br><span class="line">      <span class="attr">junit:</span> <span class="string">report.xml</span></span><br></pre></td></tr></table></figure><p>下载report.xml的方法：进入CI/CD Pipelines页面，找到Job对应的Pipeline，最右边三个点，点击下载artifacts。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-python-unittest/">《Python单元测试》</a></li><li><a href="https://www.voidking.com/dev-gitlab-cicd/">《GitLab CI/CD入门篇》</a></li></ul><h1 id="单元测试覆盖率"><a href="#单元测试覆盖率" class="headerlink" title="单元测试覆盖率"></a>单元测试覆盖率</h1><p>示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">unittest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">unittest:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">unittest</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:3.7.10-slim-buster</span></span><br><span class="line">  <span class="attr">before_script:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">pytest</span> <span class="string">pytest-cov</span> <span class="string">-i</span> <span class="string">https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pytest</span> <span class="string">--cov-report</span> <span class="string">xml</span> <span class="string">--cov=.</span> <span class="string">tests/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">coverage</span> <span class="string">report</span> <span class="string">--precision=2</span></span><br><span class="line">  <span class="attr">coverage:</span> <span class="string">&#x27;/\d+\.\d+%$/&#x27;</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">reports:</span></span><br><span class="line">      <span class="attr">cobertura:</span> <span class="string">coverage.xml</span></span><br></pre></td></tr></table></figure><p>其中<code>coverage report</code>输出内容结构为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name    Stmts    Miss   Cover</span><br><span class="line">-----------------------------</span><br><span class="line">...</span><br><span class="line">main.py   36      36       0%</span><br><span class="line">-----------------------------</span><br><span class="line">TOTAL   3130    3127    0.10%</span><br></pre></td></tr></table></figure><p>正则匹配coverage，最终输出到UI的是最后一个匹配到的值<code>0.10</code>。</p><p>下载coverage.xml的方法：进入CI/CD Pipelines页面，找到Job对应的Pipeline，最右边三个点，点击下载artifacts。</p><p>查看单测覆盖率的方法：进入CI/CD Pipelines页面，进入Job对应的Pipeline详情，点击Jobs，可以看到Coverage。</p><p>查看单测覆盖率的方法2：Job详情页，直接查看<code>coverage report</code>命令的输出内容。</p><p>单元测试和单元测试覆盖率，可以合并为一个stage：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">unittest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">unittest:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">unittest</span></span><br><span class="line">  <span class="attr">image:</span> <span class="string">python:3.7.10-slim-buster</span></span><br><span class="line">  <span class="attr">before_script:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">pytest</span> <span class="string">pytest-cov</span> <span class="string">-i</span> <span class="string">https://pypi.tuna.tsinghua.edu.cn/simple</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="comment">#- export PYTHONPATH=&quot;$CI_PROJECT_DIR&quot;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">pytest</span> <span class="string">--junitxml=report.xml</span> <span class="string">--cov-report</span> <span class="string">xml</span> <span class="string">--cov=.</span> <span class="string">tests/</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">coverage</span> <span class="string">report</span> <span class="string">--precision=2</span></span><br><span class="line">  <span class="attr">coverage:</span> <span class="string">&#x27;/\d+\.\d+%$/&#x27;</span></span><br><span class="line">  <span class="attr">artifacts:</span></span><br><span class="line">    <span class="attr">reports:</span></span><br><span class="line">      <span class="attr">junit:</span> <span class="string">report.xml</span></span><br><span class="line">      <span class="attr">cobertura:</span> <span class="string">coverage.xml</span></span><br></pre></td></tr></table></figure><p>参考文档：</p><ul><li><a href="https://docs.gitlab.cn/14.0/ee/user/project/merge_requests/test_coverage_visualization.html">Test coverage visualization</a></li><li><a href="https://www.voidking.com/dev-gitlab-cicd/">《GitLab CI/CD入门篇》</a></li></ul><h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="git-hooks"><a href="#git-hooks" class="headerlink" title="git hooks"></a>git hooks</h2><p>Git钩子是一些在Git执行特定操作时触发的脚本，可以用于自定义和自动化工作流程，不同的Git钩子有不同的调用时间。</p><p>客户端钩子：</p><ul><li>pre-commit：在每次提交之前运行。</li><li>pre-push：在git push之前运行。</li><li>post-commit：在每次提交之后运行。</li><li>post-checkout：在切换分支或检出文件后运行。</li><li>post-merge：在合并操作完成后运行。</li></ul><p>服务器端钩子：</p><ul><li>pre-receive：在远程仓库接收到推送前运行。</li><li>update：在远程仓库接收到推送后，对每个要更新的引用（分支或标签）运行一次。</li><li>post-receive：在远程仓库接收到推送后，对所有要更新的引用运行一次。</li></ul><p>每个项目的<code>.git/hooks</code>的目录中，看到这些钩子的官方示例。<br>示例文件以<code>.sample</code>结尾，去掉<code>.sample</code>后缀可激活该钩子脚本。</p><p>参考文档：</p><ul><li><a href="https://git-scm.com/docs/githooks">githooks - Hooks used by Git</a></li><li><a href="https://pre-commit.com/">pre-commit</a></li><li><a href="https://amos-x.com/index.php/amos/archives/pre-commit/">Git项目管理，代码规范pre-commit使用详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/65820736">用 pre-commit hook 解决 Python 项目编码规范</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;怎样保证代码质量？&quot;&gt;&lt;a href=&quot;#怎样保证代码质量？&quot; class=&quot;headerlink&quot; title=&quot;怎样保证代码质量？&quot;&gt;&lt;/a&gt;怎样保证代码质量？&lt;/h1&gt;&lt;p&gt;保证代码质量有三种常用的方法：Code Review、编码规范和单元测试。&lt;/p&gt;
&lt;p&gt;Code Review需要别人帮助Review，现在可以找ChatGPT帮助Review。&lt;br&gt;而对于编码规范检查和运行单元测试，是可以通过CI流水线自动完成的。&lt;br&gt;本文中，我们学习在GitLab CI流水线中配置编码规范检查和运行单元测试。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    <category term="testing" scheme="https://www.voidking.com/categories/engineering/testing/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="gitlab" scheme="https://www.voidking.com/tags/gitlab/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
    <category term="测试" scheme="https://www.voidking.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>GitLab CI问题记录</title>
    <link href="https://www.voidking.com/dev-gitlab-ci-problems/"/>
    <id>https://www.voidking.com/dev-gitlab-ci-problems/</id>
    <published>2022-11-11T14:00:00.000Z</published>
    <updated>2023-02-13T17:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Job-is-stuck"><a href="#Job-is-stuck" class="headerlink" title="Job is stuck"></a>Job is stuck</h2><p>Shell Runner跑CI任务，报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Job is stuck. Check runners. allowed to fail</span><br></pre></td></tr></table></figure><p>解决办法：<br>经查是因为gitlab-runner版本比较高（15.5.0），新版本的runner，要求<code>.gitlab-ci.yml</code>必须要配置tags，指定runner。</p><span id="more"></span><h2 id="setting-GIT-CLONE-PATH-is-not-allowed"><a href="#setting-GIT-CLONE-PATH-is-not-allowed" class="headerlink" title="setting GIT_CLONE_PATH is not allowed"></a>setting GIT_CLONE_PATH is not allowed</h2><p>Shell Runner跑CI任务，报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Job failed: setting GIT_CLONE_PATH is not allowed, enable `custom_build_dir` feature</span><br></pre></td></tr></table></figure><p>解决办法：启用custom_build_dir</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab-runner/config.toml</span><br></pre></td></tr></table></figure><p>添加custom_build_dir配置</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[runners]]</span></span><br><span class="line">  <span class="section">[runners.custom_build_dir]</span></span><br><span class="line">    <span class="attr">enabled</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>重启gitlab-runner</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-runner restart</span><br></pre></td></tr></table></figure><h2 id="fatal-git-fetch-pack"><a href="#fatal-git-fetch-pack" class="headerlink" title="fatal: git fetch-pack"></a>fatal: git fetch-pack</h2><p>Shell Runner跑CI任务，报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: git fetch-pack: expected shallow list</span><br><span class="line">fatal: The remote end hung up unexpectedly</span><br></pre></td></tr></table></figure><p>解决办法：<br>git版本问题，升级git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-1.noarch.rpm</span><br><span class="line">yum install -y git </span><br></pre></td></tr></table></figure><h2 id="不能锁定配置文件"><a href="#不能锁定配置文件" class="headerlink" title="不能锁定配置文件"></a>不能锁定配置文件</h2><p>Shell Runner跑CI任务，报错：<br>error: 不能锁定配置文件 /home/gitlab-runner/builds/builds/xxx/main.tmp/git-template/config: 没有那个文件或目录</p><p>解决办法：<br>没有检索到找到解决办法，尝试降级到<code>14.5.0</code>，问题解决。降级方法参考【Linux环境安装runner】一节。</p><h2 id="No-such-file-or-directory"><a href="#No-such-file-or-directory" class="headerlink" title="No such file or directory"></a>No such file or directory</h2><p>Shell Runner跑CI任务，报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Skipping Git checkout</span><br><span class="line">Skipping Git submodules setup</span><br><span class="line">...</span><br><span class="line">$ pip3 install -r requirements.txt</span><br><span class="line">ERROR: Could not open requirements file: [Errno 2] No such file or directory: &#x27;requirements.txt&#x27;</span><br></pre></td></tr></table></figure><p>解决办法：<code>.gitlab-ci.yml</code>文件中添加GIT_CHECKOUT变量</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">variables:</span></span><br><span class="line">  <span class="attr">GIT_CHECKOUT:</span> <span class="string">&quot;true&quot;</span></span><br></pre></td></tr></table></figure><h2 id="下载镜像报错"><a href="#下载镜像报错" class="headerlink" title="下载镜像报错"></a>下载镜像报错</h2><p>Docker Machine Runner跑CI任务，一直正常。<br>Docker Machine Runner没有任何变动，突然有一天，执行docker build的时候，下载基础镜像报错：<br>ERROR: failed to do request: Head <a href="https://192.168.56.101:5000/v2/library/python/manifests/3.8">https://192.168.56.101:5000/v2/library/python/manifests/3.8</a>: http: server gave HTTP response to HTTPS client</p><p>重启gitlab-runner问题依旧，重启机器问题依旧。</p><p>解决办法：runner配置里，指定docker image的版本为<code>docker:19.03</code>，而不要使用<code>docker</code>，否则一直会拉取最新版的docker，而最新版的docker不支持发送http请求镜像仓库。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Job-is-stuck&quot;&gt;&lt;a href=&quot;#Job-is-stuck&quot; class=&quot;headerlink&quot; title=&quot;Job is stuck&quot;&gt;&lt;/a&gt;Job is stuck&lt;/h2&gt;&lt;p&gt;Shell Runner跑CI任务，报错：&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Job is stuck. Check runners. allowed to fail&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;解决办法：&lt;br&gt;经查是因为gitlab-runner版本比较高（15.5.0），新版本的runner，要求&lt;code&gt;.gitlab-ci.yml&lt;/code&gt;必须要配置tags，指定runner。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="cicd" scheme="https://www.voidking.com/tags/cicd/"/>
    
    <category term="gitlab" scheme="https://www.voidking.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>GitLab Runner安装实践</title>
    <link href="https://www.voidking.com/dev-gitlab-runner-install/"/>
    <id>https://www.voidking.com/dev-gitlab-runner-install/</id>
    <published>2022-11-11T14:00:00.000Z</published>
    <updated>2023-06-17T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GitLab-Runner版本说明"><a href="#GitLab-Runner版本说明" class="headerlink" title="GitLab Runner版本说明"></a>GitLab Runner版本说明</h1><p>出于兼容性原因，GitLab Runner major.minor 版本应与 GitLab major.minor 版本保持同步。<br>较旧的runner可能仍然可以使用较新的 GitLab 版本，反之亦然。但是，如果存在版本差异，功能可能无法使用或无法正常工作。<br>minor版本更新时，会保障向后兼容性。但是，有时 GitLab 的minor版本更新会引入新功能，这些新功能需要 GitLab Runner 在同一minor版本上。</p><p>需要特别注意的是：GitLab Runner 15.0 对注册 API 请求格式进行了更改。它阻止 GitLab Runner 与低于 14.8 的 GitLab 版本通信。我们必须使用适合 GitLab 版本的 Runner 版本，或升级 GitLab 应用程序。</p><p>更多内容参考文档<a href="https://docs.gitlab.com/runner/">GitLab Runner</a></p><span id="more"></span><h1 id="查看安装教程"><a href="#查看安装教程" class="headerlink" title="查看安装教程"></a>查看安装教程</h1><h2 id="指定项目的Runner"><a href="#指定项目的Runner" class="headerlink" title="指定项目的Runner"></a>指定项目的Runner</h2><p>打开gitlab项目 -&gt; Settings -&gt; CI/CD -&gt; Runners -&gt; Expand -&gt; Show Runner installation instructions</p><p>页面的 registration token，用于注册指定项目（当前项目）的runner。</p><h2 id="共享的Runner"><a href="#共享的Runner" class="headerlink" title="共享的Runner"></a>共享的Runner</h2><p>查看Runner：<a href="https://gitlab.voidking.com/admin/runners">https://gitlab.voidking.com/admin/runners</a>  </p><p>打开gitlab runner管理页面 -&gt; Show Runner installation instructions</p><p>页面的 registration token，用于注册共享runner。</p><h1 id="TOML语法"><a href="#TOML语法" class="headerlink" title="TOML语法"></a>TOML语法</h1><p>gitlab-runner配置文件为config.toml，使用TOML语法。<br>TOML的目标是成为一种易于阅读的最小配置文件格式。<br>TOML被设计为明确地映射到哈希表。<br>TOML应该很容易解析成各种语言的数据结构。</p><p>参考文档：</p><ul><li><a href="https://docs.gitlab.com/runner/configuration/">Configuring GitLab Runner</a></li><li><a href="https://github.com/toml-lang/toml">TOML</a></li><li><a href="https://www.cnblogs.com/xingxia/p/toml.html">TOML 1.0格式语法</a></li><li><a href="https://www.convertjson.com/toml-to-json.htm">Convert TOML To JSON</a></li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p><code>#</code>，井号后面表示注释</p><h2 id="键值对"><a href="#键值对" class="headerlink" title="键值对"></a>键值对</h2><p>键名为字符串，值可以为字符串、整数、浮点数、布尔值、日期、时刻、数组、行内表等。<br>键名在等号的左边，值在等号的右边。</p><p>例如：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name</span> = <span class="string">&quot;voidking&quot;</span></span><br></pre></td></tr></table></figure><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>表的表示方法：方括号+表名，例如<code>[table]</code>。<br>表是键值对的集合，类似于json中的对象（花括号中内容）。在它下方，直至下一个表头或文件结束，都是这个表的键值对。<br>顶层表，又被称为根表，于文档开始处开始并在第一个表头（或文件结束处）前结束。</p><p>表名的规则和键名的规则相同。</p><p>表的层级结构以点<code>.</code>分隔，分隔的每个部分都是一个表名。<br>定义一个多层级表时，如果最后一个表名前的表没有被创建，那么会被自动创建。</p><p>例如：</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[table]</span></span><br><span class="line"><span class="comment"># 定义一个名为 table 的表</span></span><br><span class="line"><span class="attr">key1</span> = <span class="string">&quot;some string&quot;</span></span><br><span class="line"><span class="attr">key2</span> = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">fruit.apple.color</span> = <span class="string">&quot;红色&quot;</span></span><br><span class="line"><span class="comment"># 定义一个名为 fruit 的表</span></span><br><span class="line"><span class="comment"># 定义一个名为 fruit.apple 的表</span></span><br><span class="line"></span><br><span class="line"><span class="attr">fruit.apple.taste.sweet</span> = <span class="literal">true</span></span><br><span class="line"><span class="comment"># 定义一个名为 fruit.apple.taste 的表</span></span><br><span class="line"><span class="comment"># fruit 和 fruit.apple 已经创建过了</span></span><br></pre></td></tr></table></figure><h2 id="表数组"><a href="#表数组" class="headerlink" title="表数组"></a>表数组</h2><p>表数组表示方法：双层方括号+表名，例如<code>[[fruits]]</code>。<br>表数组是表的数组，类似于json中的对象数组。</p><p>表数组的第一例定义了这个数组及其首个表元素，而后续的每个表数组在该数组中创建并定义一个新的表元素。</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[[fruits]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;苹果&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[fruits.physical]</span>  <span class="comment"># 子表</span></span><br><span class="line"><span class="attr">color</span> = <span class="string">&quot;红色&quot;</span></span><br><span class="line"><span class="attr">shape</span> = <span class="string">&quot;圆形&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[fruits.varieties]]</span>  <span class="comment"># 嵌套表数组</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;蛇果&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[fruits.varieties]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;澳洲青苹&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[fruits]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;香蕉&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[[fruits.varieties]]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">&quot;车前草&quot;</span></span><br></pre></td></tr></table></figure><p>对应的json格式为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;fruits&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;苹果&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;physical&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;color&quot;</span><span class="punctuation">:</span> <span class="string">&quot;红色&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;shape&quot;</span><span class="punctuation">:</span> <span class="string">&quot;圆形&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;varieties&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;蛇果&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;澳洲青苹&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;香蕉&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;varieties&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span> <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;车前草&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>TOML中的缩进没有意义，只是为了方便读者理解层级结构。</p><h1 id="Linux环境安装Runner"><a href="#Linux环境安装Runner" class="headerlink" title="Linux环境安装Runner"></a>Linux环境安装Runner</h1><p>参考文档：<a href="https://docs.gitlab.com/runner/install/index.html">Install GitLab Runner</a></p><p>1、安装runner</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Download the binary for your system</span></span><br><span class="line">sudo curl -L --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Give it permissions to execute</span></span><br><span class="line">sudo <span class="built_in">chmod</span> +x /usr/local/bin/gitlab-runner</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a GitLab CI user</span></span><br><span class="line">sudo useradd --comment <span class="string">&#x27;GitLab Runner&#x27;</span> --create-home gitlab-runner --shell /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install and run as service</span></span><br><span class="line">sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner</span><br><span class="line">sudo gitlab-runner start</span><br><span class="line">sudo gitlab-runner -v</span><br></pre></td></tr></table></figure><p>PS：其他版本的runner源码和二进制文件，可以在<a href="https://gitlab.com/gitlab-org/gitlab-runner/-/releases">gitlab-runner Releases</a>页面找到。</p><p>对于centos系统，可以直接使用rpm包安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y https://gitlab-runner.downloads.s3.amazonaws.com/latest/rpm/gitlab-runner_amd64.rpm </span><br></pre></td></tr></table></figure><p>2、添加到gitlab-runner到docker用户组（可选）<br>如果gitlab-runner执行的ci脚本需要运行docker，那么需要将gitlab-runner到docker用户组</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -a -G docker gitlab-runner</span><br><span class="line"><span class="comment"># if no docker group</span></span><br><span class="line">sudo usermod -a -G root gitlab-runner</span><br><span class="line"></span><br><span class="line">sudo -u gitlab-runner -H docker info</span><br></pre></td></tr></table></figure><p>3、gitlab-runner添加sudo权限（可选）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sudoers</span><br></pre></td></tr></table></figure><p>添加配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-runner ALL=(ALL) NOPASSWD: ALL</span><br></pre></td></tr></table></figure><h1 id="注册Shell类型Runner"><a href="#注册Shell类型Runner" class="headerlink" title="注册Shell类型Runner"></a>注册Shell类型Runner</h1><p>Shell类型的Executor，在Runner程序所在主机上运行CI任务。</p><p>前置条件：安装好了Runner。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner register -h</span><br><span class="line">sudo gitlab-runner register --url https://gitlab.voidking.com/ --registration-token <span class="variable">$REGISTRATION_TOKEN</span></span><br></pre></td></tr></table></figure><p>REGISTRATION_TOKEN可以在gitlab页面获取到，详情参考上文【查看安装教程】一节。<br>根据提示，填写url、token、description、tags（多个tag以英文逗号分隔）、executor类型等信息，这里executor类型填写<code>shell</code>。</p><h1 id="注册Docker类型Runner"><a href="#注册Docker类型Runner" class="headerlink" title="注册Docker类型Runner"></a>注册Docker类型Runner</h1><p>Docker类型的Executor，在Runner程序所在主机上的Docker容器中运行CI任务。</p><p>前置条件：安装好了Runner，而且Runner所在主机已经安装配置好了Docker。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner register --url https://gitlab.voidking.com/ --registration-token <span class="variable">$REGISTRATION_TOKEN</span></span><br></pre></td></tr></table></figure><p>根据提示，填写url、token、description、tags、executor类型等信息，这里executor类型填写<code>docker</code>，最后填写一个默认的镜像。</p><h1 id="注册Docker-Machine类型Runner"><a href="#注册Docker-Machine类型Runner" class="headerlink" title="注册Docker Machine类型Runner"></a>注册Docker Machine类型Runner</h1><p>参考文档：</p><ul><li><a href="https://docs.gitlab.com/runner/executors/docker_machine.html">Install and register GitLab Runner for autoscaling with Docker Machine</a></li><li><a href="https://docs.gitlab.com/runner/configuration/autoscale.html">Docker Machine Executor autoscale configuration</a></li><li><a href="https://www.runoob.com/docker/docker-machine.html">Docker Machine</a></li><li><a href="https://blog.csdn.net/RenshenLi/article/details/121585307">docker-machine的安装与使用</a></li></ul><h2 id="安装虚拟机驱动"><a href="#安装虚拟机驱动" class="headerlink" title="安装虚拟机驱动"></a>安装虚拟机驱动</h2><p>可选驱动：</p><ul><li>virtualbox（推荐），参考文档<a href="https://www.voidking.com/dev-linux-virtualbox/">Linux下使用VirtualBox</a></li><li>qemu，参考文档<a href="https://github.com/machine-drivers/docker-machine-driver-qemu">machine-drivers/docker-machine-driver-qemu</a></li><li>kvm，参考文档<a href="https://github.com/dhiltgen/docker-machine-kvm">dhiltgen/docker-machine-kvm</a></li></ul><p>1、安装virtualbox驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https://download.virtualbox.org/virtualbox/6.1.26/VirtualBox-6.1-6.1.26_145957_el7-1.x86_64.rpm</span><br></pre></td></tr></table></figure><p>2、安装编译环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kernel-devel kernel-devel install gcc make perl kernel-headers</span><br></pre></td></tr></table></figure><p>3、激活virtualbox内核支持</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/vboxconfig</span><br></pre></td></tr></table></figure><h2 id="安装Docker-Machine"><a href="#安装Docker-Machine" class="headerlink" title="安装Docker Machine"></a>安装Docker Machine</h2><p>1、下载docker-machine二进制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://gitlab.com/gitlab-org/ci-cd/docker-machine/-/releases/v0.16.2-gitlab.15/downloads/docker-machine-Linux-x86_64</span><br><span class="line"><span class="built_in">mv</span> docker-machine-Linux-x86_64 /usr/sbin/docker-machine</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/sbin/docker-machine</span><br></pre></td></tr></table></figure><p>更多版本可以访问<a href="https://gitlab.com/gitlab-org/ci-cd/docker-machine/-/releases">docker-machine/releases</a>页面查找。</p><p>2、测试启动虚拟机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine create -d virtualbox <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="注册Runner"><a href="#注册Runner" class="headerlink" title="注册Runner"></a>注册Runner</h2><p>前置条件：安装好了Runner。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gitlab-runner register --url https://gitlab.voidking.com/ --registration-token <span class="variable">$REGISTRATION_TOKEN</span></span><br></pre></td></tr></table></figure><p>根据提示，填写url、token、description、tags、executor类型等信息，这里executor类型填写<code>docker+machine</code>，最后填写一个默认的镜像。</p><h2 id="配置镜像加速（可选）"><a href="#配置镜像加速（可选）" class="headerlink" title="配置镜像加速（可选）"></a>配置镜像加速（可选）</h2><p>参考文档<a href="https://www.voidking.com/dev-docker-registry-mirror/">《Docker镜像站的配置和使用》</a>，搭建本地镜像站。</p><h2 id="配置缓存"><a href="#配置缓存" class="headerlink" title="配置缓存"></a>配置缓存</h2><p>1、启动minio容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name minio \</span><br><span class="line">--restart always \</span><br><span class="line">-p 9000:9000 \</span><br><span class="line">-p 9001:9001  \</span><br><span class="line">-v /data/minio/.minio:/data/.minio \</span><br><span class="line">-v /data/minio/export:/export \</span><br><span class="line">-e <span class="string">&quot;MINIO_ROOT_USER=root&quot;</span> \</span><br><span class="line">-e <span class="string">&quot;MINIO_ROOT_PASSWORD=xxxxxx&quot;</span> \</span><br><span class="line">minio/minio:latest server /export --console-address <span class="string">&quot;:9001&quot;</span></span><br></pre></td></tr></table></figure><p>2、页面访问<br><a href="http://192.168.56.101:9001/">http://192.168.56.101:9001/</a> </p><h2 id="配置Runner"><a href="#配置Runner" class="headerlink" title="配置Runner"></a>配置Runner</h2><p>1、修改 /etc/gitlab-runner/config.toml</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">concurrent = 3</span><br><span class="line">check_interval = 0</span><br><span class="line"></span><br><span class="line">[session_server]</span><br><span class="line">  session_timeout = 1800</span><br><span class="line"></span><br><span class="line">[[runners]]</span><br><span class="line">  limit = 3</span><br><span class="line">  name = &quot;dockermachine&quot;</span><br><span class="line">  url = &quot;https://gitlab.voidking.com&quot;</span><br><span class="line">  token = &quot;xxx&quot;</span><br><span class="line">  executor = &quot;docker+machine&quot;</span><br><span class="line">  [runners.custom_build_dir]</span><br><span class="line">    enabled = true</span><br><span class="line">  [runners.cache]</span><br><span class="line">    Type = &quot;s3&quot;</span><br><span class="line">    Path = &quot;runner&quot;</span><br><span class="line">    Shared = true</span><br><span class="line">    [runners.cache.s3]</span><br><span class="line">      ServerAddress = &quot;192.168.56.101:9000&quot;</span><br><span class="line">      AccessKey = &quot;root&quot;</span><br><span class="line">      SecretKey = &quot;xxx&quot;</span><br><span class="line">      BucketName = &quot;runner&quot;</span><br><span class="line">      Insecure = true</span><br><span class="line">    [runners.cache.gcs]</span><br><span class="line">    [runners.cache.azure]</span><br><span class="line">  [runners.docker]</span><br><span class="line">    tls_verify = false</span><br><span class="line">    image = &quot;docker:19.03&quot;</span><br><span class="line">    privileged = true</span><br><span class="line">    disable_entrypoint_overwrite = false</span><br><span class="line">    oom_kill_disable = false</span><br><span class="line">    disable_cache = false</span><br><span class="line">    volumes = [&quot;/certs/client&quot;,&quot;/cache&quot;, &quot;/var/run/docker.sock:/var/run/docker.sock&quot;]</span><br><span class="line">    pull_policy = [&quot;if-not-present&quot;]</span><br><span class="line">    shm_size = 0</span><br><span class="line">  [runners.machine]</span><br><span class="line">    IdleCount = 5</span><br><span class="line">    MaxGrowthRate = 1</span><br><span class="line">    IdleTime = 1800</span><br><span class="line">    MachineDriver = &quot;virtualbox&quot;</span><br><span class="line">    MachineName = &quot;auto-scale-%s&quot;</span><br><span class="line">    MachineOptions = [</span><br><span class="line">      &quot;engine-registry-mirror=http://192.168.56.101:5000&quot;,</span><br><span class="line">      &quot;engine-registry-mirror=http://192.168.56.101:5001&quot;,</span><br><span class="line">      &quot;virtualbox-memory=4048&quot;,</span><br><span class="line">      &quot;virtualbox-disk-size=204800&quot;,</span><br><span class="line">      &quot;virtualbox-cpu-count=2&quot;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure><p>注意：runners.docker.image要指定版本，否则每次构建都会拉取最新版的docker，而最新版本的docker不支持http请求镜像仓库。<br>更多docker版本可以访问<a href="https://hub.docker.com/_/docker/tags?page=1">dockerhub - docker</a>获取。</p><p>其中MachineOptions中给定的参数，是<code>docker-machine create</code>命令接收的参数。</p><p>2、重新启动runner</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-runner restart</span><br></pre></td></tr></table></figure><h2 id="管理Docker-Machine"><a href="#管理Docker-Machine" class="headerlink" title="管理Docker Machine"></a>管理Docker Machine</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-machine <span class="built_in">ls</span></span><br><span class="line">docker-machine ssh xxx</span><br></pre></td></tr></table></figure><h1 id="K8S环境安装Runner"><a href="#K8S环境安装Runner" class="headerlink" title="K8S环境安装Runner"></a>K8S环境安装Runner</h1><p>本节中，我们在K8S中通过helm安装Runner。</p><p>参考文档：</p><ul><li><a href="https://docs.gitlab.com/runner/install/kubernetes.html">GitLab Runner Helm Chart</a></li><li><a href="https://docs.gitlab.com/runner/install/kubernetes.html#running-docker-in-docker-containers-with-gitlab-runner">GitLab Runner Helm Chart - Running Docker-in-Docker containers with GitLab Runner</a></li><li><a href="https://www.youtube.com/watch?v=0Fes86qtBSc">GitLab CI CD | Install and Configure GitLab Runner on Kubernetes with Helm</a></li><li><a href="http://docs.idevops.site/gitlabci/chapter05/01/01-runner%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BC%98%E5%8C%96%E9%85%8D%E7%BD%AE/">Runner构建优化</a></li><li><a href="https://www.qikqiak.com/post/gitlab-runner-install-on-k8s/">在 Kubernetes 上安装 Gitlab CI Runner</a></li></ul><h2 id="准备存储"><a href="#准备存储" class="headerlink" title="准备存储"></a>准备存储</h2><p>通过helm安装runner，values当前还不支持配置storageclass。因此，需要先自行准备好runner的存储。主要参考文档<a href="https://www.voidking.com/dev-k8s-storageclass/">《K8S中安装配置StorageClass》</a></p><p>准备pvc定义 runner-pvc.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">gitlab-runner-cache</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">nfs-storage</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteMany</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">50Gi</span></span><br></pre></td></tr></table></figure><h2 id="准备Runner配置"><a href="#准备Runner配置" class="headerlink" title="准备Runner配置"></a>准备Runner配置</h2><p>1、添加gitlab repo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm repo add gitlab https://charts.gitlab.io</span><br><span class="line">helm repo update</span><br></pre></td></tr></table></figure><p>2、查看可用的runner版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm search repo -l gitlab/gitlab-runner</span><br></pre></td></tr></table></figure><p>CHART VERSION有对应的APP VERSION版本，选择需要的APP VERSION版本。<br>这里选择14.0.0版本，对应CHART VERSION为0.30.0</p><p>3、下载chart</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">helm fetch gitlab/gitlab-runner --version 0.30.0</span><br><span class="line">tar -xzvf gitlab-runner-0.30.0.tgz</span><br></pre></td></tr></table></figure><p>4、values.yaml修改配置</p><ul><li>image：指定版本gitlab/gitlab-runner:alpine-v14.0.1，更多镜像版本可以访问<a href="https://hub.docker.com/r/gitlab/gitlab-runner/tags">docker hub</a>查找</li><li>gitlabUrl：改成我们自己的的gitlab地址</li><li>runnerRegistrationToken：参考【查看安装教程】一节获取</li><li>resources：修改申请和限制的资源</li><li>rbac.create：改成true，创建sa用于创建runner</li><li>name：改成runner想要在gitlab中显示的名称</li><li>tags：改成runner想要注册的tags，多个tag以英文逗号分隔</li><li>replicas：改成runner期望的副本数，这些runner副本使用同一个name。</li><li>privileged：改成true，启用docker in docker</li><li>runners.config：支持自定义构建目录，支持docker in docker</li></ul><p>runners.config内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[runners.custom_build_dir]</span><br><span class="line">  enabled = true</span><br><span class="line"></span><br><span class="line">[[runners.kubernetes.volumes.host_path]]</span><br><span class="line">  name = &quot;docker&quot;</span><br><span class="line">  mount_path = &quot;/var/run/docker.sock&quot;</span><br><span class="line">  read_only = true</span><br><span class="line">  host_path = &quot;/var/run/docker.sock&quot;</span><br></pre></td></tr></table></figure><p>我们想要对构建缓存使用持久化存储，因此需要添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## configure build cache</span></span><br><span class="line"><span class="attr">cibuild:</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">pvcName:</span> <span class="string">gitlab-runner-cache</span></span><br><span class="line">    <span class="attr">mountPath:</span> <span class="string">/home/gitlab-runner/ci-build-cache</span></span><br></pre></td></tr></table></figure><p>同时，需要修改gitlab-runner/templates/configmap.yaml<br>data.entrypoint部分添加runner配置，自动挂载存储</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># add build cache and </span></span><br><span class="line"><span class="string">cat</span> <span class="string">&lt;&lt;EOF</span> <span class="string">&gt;&gt;/home/gitlab-runner/.gitlab-runner/config.toml</span></span><br><span class="line">  [[<span class="string">runners.kubernetes.volumes.pvc</span>]]</span><br><span class="line">    <span class="string">name</span> <span class="string">=</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;.Values.cibuild.cache.pvcName&#125;&#125;</span>&quot;</span></span><br><span class="line">    <span class="string">mount_path</span> <span class="string">=</span> <span class="string">&quot;<span class="template-variable">&#123;&#123;.Values.cibuild.cache.mountPath&#125;&#125;</span>&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Start the runner</span></span><br><span class="line"><span class="string">exec</span> <span class="string">/entrypoint</span> <span class="string">run</span> <span class="string">--user=gitlab-runner</span> <span class="string">\</span></span><br><span class="line">  <span class="string">--working-directory=/home/gitlab-runner</span></span><br></pre></td></tr></table></figure><h2 id="安装Runner"><a href="#安装Runner" class="headerlink" title="安装Runner"></a>安装Runner</h2><p>1、安装runner</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create ns gitlab-14-0</span><br><span class="line">kubectl apply -f runner-pvc.yaml -n gitlab-14-0</span><br><span class="line">helm install --namespace gitlab-14-0 gitlab-runner ./gitlab-runner</span><br></pre></td></tr></table></figure><p>2、查看安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get all -n gitlab-14-0</span><br><span class="line">kubectl get pvc -n gitlab-14-0</span><br><span class="line">kubectl logs pod/gitlab-runner-gitlab-runner-849988b584-kllqv -n gitlab-14-0</span><br></pre></td></tr></table></figure><p>3、查看runner注册结果<br><a href="https://gitlab.voidking.com/admin/runners">https://gitlab.voidking.com/admin/runners</a></p><p>找到新的runner，点击右侧的Edit按钮，可以做进一步的配置。</p><h1 id="自定义builds路径"><a href="#自定义builds路径" class="headerlink" title="自定义builds路径"></a>自定义builds路径</h1><p>参考文档<a href="https://docs.gitlab.com/ee/ci/large_repositories/">Optimize GitLab for large repositories</a></p><p>1、准备builds目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /builds</span><br><span class="line"><span class="built_in">mkdir</span> /cache</span><br><span class="line"><span class="built_in">chown</span> gitlab-runner:gitlab-runner -R /builds</span><br><span class="line"><span class="built_in">chown</span> gitlab-runner:gitlab-runner -R /cache</span><br></pre></td></tr></table></figure><p>2、修改runner配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/gitlab-runner/config.toml</span><br></pre></td></tr></table></figure><p>添加配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[[runners]]</span><br><span class="line">  builds_dir = &quot;/builds&quot;</span><br><span class="line">  cache_dir = &quot;/cache&quot;</span><br><span class="line">  [runners.custom_build_dir]</span><br><span class="line">    enabled = true</span><br></pre></td></tr></table></figure><p>3、重启runner</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitlab-runner restart</span><br></pre></td></tr></table></figure><h1 id="取消注册Runner"><a href="#取消注册Runner" class="headerlink" title="取消注册Runner"></a>取消注册Runner</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看token</span></span><br><span class="line">gitlab-runner list</span><br><span class="line"><span class="comment"># token还可以在/etc/gitlab-runner/config.toml中查看</span></span><br><span class="line"><span class="comment"># 取消注册runner</span></span><br><span class="line">gitlab-runner unregister -t <span class="variable">$token</span> -u https://gitlab.voidking.com/</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GitLab-Runner版本说明&quot;&gt;&lt;a href=&quot;#GitLab-Runner版本说明&quot; class=&quot;headerlink&quot; title=&quot;GitLab Runner版本说明&quot;&gt;&lt;/a&gt;GitLab Runner版本说明&lt;/h1&gt;&lt;p&gt;出于兼容性原因，GitLab Runner major.minor 版本应与 GitLab major.minor 版本保持同步。&lt;br&gt;较旧的runner可能仍然可以使用较新的 GitLab 版本，反之亦然。但是，如果存在版本差异，功能可能无法使用或无法正常工作。&lt;br&gt;minor版本更新时，会保障向后兼容性。但是，有时 GitLab 的minor版本更新会引入新功能，这些新功能需要 GitLab Runner 在同一minor版本上。&lt;/p&gt;
&lt;p&gt;需要特别注意的是：GitLab Runner 15.0 对注册 API 请求格式进行了更改。它阻止 GitLab Runner 与低于 14.8 的 GitLab 版本通信。我们必须使用适合 GitLab 版本的 Runner 版本，或升级 GitLab 应用程序。&lt;/p&gt;
&lt;p&gt;更多内容参考文档&lt;a href=&quot;https://docs.gitlab.com/runner/&quot;&gt;GitLab Runner&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="cicd" scheme="https://www.voidking.com/tags/cicd/"/>
    
    <category term="gitlab" scheme="https://www.voidking.com/tags/gitlab/"/>
    
    <category term="helm" scheme="https://www.voidking.com/tags/helm/"/>
    
    <category term="virtualbox" scheme="https://www.voidking.com/tags/virtualbox/"/>
    
  </entry>
  
  <entry>
    <title>GitLab Runner入门篇</title>
    <link href="https://www.voidking.com/dev-gitlab-runner-start/"/>
    <id>https://www.voidking.com/dev-gitlab-runner-start/</id>
    <published>2022-11-11T14:00:00.000Z</published>
    <updated>2023-02-13T15:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GitLab-Runner简介"><a href="#GitLab-Runner简介" class="headerlink" title="GitLab Runner简介"></a>GitLab Runner简介</h1><p>GitLab Runner 是一个开源软件，它与 GitLab CI/CD 配合，在管道流中运行作业。<br>GitLab Runner 是用Go编写，几乎可以直接运行在任何操作系统（个别系统需要自行编译）。<br>GitLab Runner 也可以在 Docker 容器内运行或部署到 Kubernetes 集群中。</p><p>GitLab Runner能不能替换成其他的Runner？可以，但是没有必要，毕竟Gitlab Runner是开源的，有什么个性化需求就自己改一改。而且，也没有找到合适的替代产品。</p><p>参考文档：</p><ul><li><a href="https://docs.gitlab.com/runner/">GitLab Runner</a> </li><li><a href="https://docs.gitlab.cn/jh/ci/">GitLab CI/CD中文文档</a></li><li><a href="https://docs.gitlab.com/ee/ci/">GitLab CI/CD文档</a></li><li><a href="https://docs.gitlab.com/runner/">GitLab Runner</a></li><li><a href="https://docs.gitlab.com/runner/executors/">Executors</a></li><li><a href="https://docs.gitlab.com/runner/executors/shell.html">The Shell executor</a></li><li><a href="https://www.voidking.com/dev-gitlab-cicd/">《GitLab CI/CD入门篇》</a></li></ul><span id="more"></span><h1 id="GitLab、Runner和Executor"><a href="#GitLab、Runner和Executor" class="headerlink" title="GitLab、Runner和Executor"></a>GitLab、Runner和Executor</h1><p>关于GitLab、Runner和Executor的关系，有一个比喻很恰当：<br>GitLab是老板，会去查看需求单（.gitlab-ci.yml），建立一张又一张有先后顺序的工单（CI Pipeline）。<br>GitLab Runner 是执行 CI Job 的工人，定期去询问老板（GitLab）现在有分配给自己的工作（CI Job）吗？如果拿到工作，就开始执行，并在执行过程中将进度即时写在工单上。<br>Executor 是工人（Runner）执行 CI Job 的工作环境，例如一个 CI Job 是打印出”hello”，那么Runner可以在本地Shell环境中执行，可以在虚拟机环境中执行，还可以在Docker环境中执行；而如果一个CI Job需要在基础镜像上进行构建，那么就需要Docker环境或者K8S环境了。</p><p>Runner通常在安装Runner的同一台机器上处理作业。但是，我们也可以让Runner在容器、k8s 集群、或者云上的自动缩放实例中处理作业。</p><p>安装Runner后，想要使用它，需要在GitLab平台进行注册，注册做的工作就是建立Gitlab与Runner之间的通信。<br>注册完成后，Runner就可以运行来自 GitLab 的 CI/CD 作业了。</p><p>当我们注册一个Runner时，必须选择一个Executor。Executor决定了每个作业运行的环境。</p><p>Gitlab Runner的安装环境包括Linux、MacOS、Windows、Docker和Kubernetes。<br>而不同安装环境的Runner，支持不同的Executors。<br>根据Executor的不同，同一个Runner程序，可以注册为不同Executor类型的Runner，例如SSH、Shell、Parallels、VirtualBox、Docker、Docker Machine (auto-scaling)、Kubernetes、Custom。</p><p>例如：</p><ul><li>如果我们希望 CI/CD 作业运行 PowerShell 命令，那么可以在 Windows 服务器上安装 GitLab Runner，然后注册一个使用 Shell Executor的Runner。</li><li>如果我们希望 CI/CD 作业在自定义 Docker 容器中运行命令，那么可以在 Linux 服务器上安装 GitLab Runner 并注册一个使用 Docker Executor 的 Runner。</li><li>我们还可以在虚拟机上安装 GitLab Runner，并让它使用另一个虚拟机作为Executor。</li></ul><p>最常用的Executor：Shell、Docker、Docker Machine、Kubernetes。</p><p>参考文档：</p><ul><li><a href="https://docs.gitlab.com/runner/">GitLab Runner</a> </li><li><a href="https://docs.gitlab.com/runner/executors/index.html">Executors</a></li><li><a href="https://chengweichen.com/2021/03/gitlab-ci-executor.html">GitLab CI 之 Runner 的 Executor 該如何選擇？</a></li></ul><h1 id="Executor简介"><a href="#Executor简介" class="headerlink" title="Executor简介"></a>Executor简介</h1><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Shell 是最简单的配置执行器。构建所需的所有依赖项都需要手动安装在安装 GitLab Runner 的同一台机器上。</p><h2 id="Docker-executor"><a href="#Docker-executor" class="headerlink" title="Docker executor"></a>Docker executor</h2><p>一个很好的选择是使用 Docker，因为它允许一个干净的构建环境，并且具有简单的依赖项管理（构建项目的所有依赖项都可以放在 Docker 映像中）。 Docker 执行器允许您轻松创建具有依赖服务的构建环境，例如 MySQL。</p><p>当我们在 Docker 容器中安装 GitLab Runner 并选择 Docker executor来运行作业时，它有时被称为 Docker-in-Docker （dind）配置。</p><p>注意：有些Docker容器中，默认的shell并不是bash，shell选择逻辑如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -x /usr/local/bin/bash ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/local/bin/bash <span class="variable">$@</span></span><br><span class="line"><span class="keyword">elif</span> [ -x /usr/bin/bash ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/bin/bash <span class="variable">$@</span></span><br><span class="line"><span class="keyword">elif</span> [ -x /bin/bash ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> /bin/bash <span class="variable">$@</span></span><br><span class="line"><span class="keyword">elif</span> [ -x /usr/local/bin/sh ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/local/bin/sh <span class="variable">$@</span></span><br><span class="line"><span class="keyword">elif</span> [ -x /usr/bin/sh ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> /usr/bin/sh <span class="variable">$@</span></span><br><span class="line"><span class="keyword">elif</span> [ -x /bin/sh ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">exec</span> /bin/sh <span class="variable">$@</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> shell not found</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>参考文档：</p><ul><li><a href="https://shisho.dev/blog/posts/docker-in-docker/">How To Run Docker in Docker</a></li><li><a href="https://devopscube.com/run-docker-in-docker/">How To Run Docker in Docker Container</a></li><li><a href="https://medium.com/@tonywooster/docker-in-docker-in-gitlab-runners-220caeb708ca">Docker-in-Docker in Gitlab Runners</a></li><li><a href="https://gitlab.com/gitlab-org/gitlab-runner/-/issues/1758">shell in docker executor isn’t bash</a></li></ul><h2 id="Docker-Machine-executor"><a href="#Docker-Machine-executor" class="headerlink" title="Docker Machine executor"></a>Docker Machine executor</h2><p>Docker Machine 是 Docker 执行器的特殊版本，支持自动缩放。它像普通的 Docker 执行器一样工作，但使用 Docker Machine 按需创建的构建主机。</p><p>Docker官方已经废弃了Docker Machine，GitLab Runner使用的是自己维护的Docker Machine。</p><p>Docker Machine executor原理：</p><ul><li>安装Runner并配置gitlab-runner用户具有启动虚拟机的权限</li><li>Runner调用驱动启动Docker Machine VM，VM系统为<a href="https://github.com/boot2docker/boot2docker">Boot2Docker</a></li><li>当VM中开始跑CI Job时，会启动一个Docker容器作为执行容器，在容器中跑CI Job</li><li>CI Job中可以包含docker build等命令，此时会共享调用VM的Docker，是Docker in Docker模式的一种</li></ul><p>参考文档：</p><ul><li><a href="https://docs.gitlab.com/runner/executors/docker_machine.html">Install and register GitLab Runner for autoscaling with Docker Machine</a></li><li><a href="https://docs.gitlab.com/runner/configuration/autoscale.html">Docker Machine Executor autoscale configuration</a></li></ul><h2 id="Kubernetes-executor"><a href="#Kubernetes-executor" class="headerlink" title="Kubernetes executor"></a>Kubernetes executor</h2><p>Kubernetes 执行器允许您使用现有的 Kubernetes 集群进行构建。执行器将调用 Kubernetes 集群 API 并为每个 GitLab CI 作业创建一个新的 Pod（带有构建容器和服务容器）。</p><p>Kubernetes executor也是支持 Docker-in-Docker 的。</p><p>参考文档：</p><ul><li><a href="https://docs.gitlab.com/runner/executors/kubernetes.html">The Kubernetes executor for GitLab Runner</a></li><li><a href="https://docs.gitlab.com/runner/executors/kubernetes.html#using-docker-in-your-builds">The Kubernetes executor for GitLab Runner - Using Docker in your builds</a></li><li><a href="https://stackoverflow.com/questions/58847455/cannot-access-docker-daemon-in-gitlab-runner-using-kubernetes-executor">Cannot access docker daemon in gitlab runner using Kubernetes executor</a></li></ul><h2 id="SSH-executor"><a href="#SSH-executor" class="headerlink" title="SSH executor"></a>SSH executor</h2><p>SSH 执行器是为了完整性而添加的，但它是所有执行器中受支持最少的。它使 GitLab Runner 连接到外部服务器并在那里运行构建。我们有一些来自使用此执行器的组织的成功案例，但通常我们建议使用其他类型之一。</p><h2 id="Virtual-Machine-executor"><a href="#Virtual-Machine-executor" class="headerlink" title="Virtual Machine executor"></a>Virtual Machine executor</h2><p>这种类型的执行器允许您使用已创建的虚拟机，该虚拟机被克隆并用于运行您的构建。我们提供两个完整的系统虚拟化选项：VirtualBox 和 Parallels。如果您想在不同的操作系统上运行构建，它们可能会很有用，因为它允许在 Windows、Linux、macOS 或 FreeBSD 上创建虚拟机，然后 GitLab Runner 连接到虚拟机并在其上运行构建。它的使用也有助于降低基础设施成本。</p><h2 id="Custom-executor"><a href="#Custom-executor" class="headerlink" title="Custom executor"></a>Custom executor</h2><p>自定义执行器允许您指定自己的执行环境。当 GitLab Runner 不提供执行器（例如，LXC 容器）时，您可以向 GitLab Runner 提供自己的可执行文件，以配置和清理您想要使用的任何环境。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;GitLab-Runner简介&quot;&gt;&lt;a href=&quot;#GitLab-Runner简介&quot; class=&quot;headerlink&quot; title=&quot;GitLab Runner简介&quot;&gt;&lt;/a&gt;GitLab Runner简介&lt;/h1&gt;&lt;p&gt;GitLab Runner 是一个开源软件，它与 GitLab CI/CD 配合，在管道流中运行作业。&lt;br&gt;GitLab Runner 是用Go编写，几乎可以直接运行在任何操作系统（个别系统需要自行编译）。&lt;br&gt;GitLab Runner 也可以在 Docker 容器内运行或部署到 Kubernetes 集群中。&lt;/p&gt;
&lt;p&gt;GitLab Runner能不能替换成其他的Runner？可以，但是没有必要，毕竟Gitlab Runner是开源的，有什么个性化需求就自己改一改。而且，也没有找到合适的替代产品。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.gitlab.com/runner/&quot;&gt;GitLab Runner&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.gitlab.cn/jh/ci/&quot;&gt;GitLab CI/CD中文文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.gitlab.com/ee/ci/&quot;&gt;GitLab CI/CD文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.gitlab.com/runner/&quot;&gt;GitLab Runner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.gitlab.com/runner/executors/&quot;&gt;Executors&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.gitlab.com/runner/executors/shell.html&quot;&gt;The Shell executor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-gitlab-cicd/&quot;&gt;《GitLab CI/CD入门篇》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="cicd" scheme="https://www.voidking.com/tags/cicd/"/>
    
    <category term="gitlab" scheme="https://www.voidking.com/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>GitLab CI报错ERROR: Job failed (system failure)</title>
    <link href="https://www.voidking.com/dev-gitlab-ci-job-faild-system-failure/"/>
    <id>https://www.voidking.com/dev-gitlab-ci-job-faild-system-failure/</id>
    <published>2022-11-10T19:00:00.000Z</published>
    <updated>2022-11-10T19:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>GitLab CI任务，Runner使用的是<code>docker machine executor</code>类型的执行器，执行失败报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Running on runner-h6ezaymy-project-1037-concurrent-0 via runner-h6ezaymy-auto-scale-1668060271-ce458595...</span><br><span class="line">...</span><br><span class="line">WARNING: Failed to pull image with policy &quot;if-not-present&quot;: error during connect: Post https://192.168.99.251:2376/v1.25/images/create?fromImage=registry.gitlab.com%2Fgitlab-org%2Fgitlab-runner%2Fgitlab-runner-helper&amp;tag=x86_64-58ba2b95: dial tcp 192.168.99.251:2376: connect: no route to host (manager.go:205:3s)</span><br><span class="line">ERROR: Job failed (system failure): error during connect: Post https://192.168.99.251:2376/v1.25/containers/47272fbe49e4be0f85724ad99f0657b72f568810ce0f4914c57e7fcf114764e2/wait: dial tcp 192.168.99.251:2376: connect: no route to host</span><br></pre></td></tr></table></figure><p>重试，问题依旧。</p><span id="more"></span><h1 id="排查思路"><a href="#排查思路" class="headerlink" title="排查思路"></a>排查思路</h1><p>问题原因猜测：</p><ul><li>偶发问题？确认是否能稳定复现</li><li>CICD配置问题？确认CICD配置，检查用法是否正确</li><li>runner问题？重启runner，再次尝试复现</li></ul><p>排查确认：</p><ul><li>偶发问题，重试失败，但是夜间可以成功执行</li><li>CICD配置正常，报错与配置无关，而且夜间可以成功执行</li><li>runner问题无法排除，需要进一步排查</li></ul><h1 id="Runner问题排查"><a href="#Runner问题排查" class="headerlink" title="Runner问题排查"></a>Runner问题排查</h1><h2 id="网络问题？"><a href="#网络问题？" class="headerlink" title="网络问题？"></a>网络问题？</h2><p>登录到runner所在宿主机，进入到runner</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine ssh runner-h6ezaymy-auto-scale-1668060271-ce458595</span><br></pre></td></tr></table></figure><p>提示vm不存在。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-machine <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>查看当前的vm，负责运行任务的vm确实不存在了，看来不是网络问题。<br>怀疑是vm出问题被干掉了，然后重新创建了一个vm。<br>那么vm为什么会被干掉？看看日志吧。</p><h2 id="查看系统日志"><a href="#查看系统日志" class="headerlink" title="查看系统日志"></a>查看系统日志</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">journalctl -xe</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="built_in">cat</span> /var/log/messages | grep -i <span class="built_in">kill</span> -A3 -B3</span><br></pre></td></tr></table></figure><p>确实找到了程序被干掉的证据，刚好和gitlabci任务失败的时间吻合。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">11月 10 17:13:42 runner kernel: Out of memory: Kill process 12293 (MainHGCMthread) score 215 or sacrifice child</span><br><span class="line">11月 10 17:13:42 runner kernel: Killed process 12294 (EMT-0), UID 0, total-vm:4345420kB, anon-rss:45340kB, file-rss:2622104kB, shmem-rss:4kB</span><br></pre></td></tr></table></figure><p>那么这个vm为什么被干掉了？oom？</p><h2 id="CI任务占用内存太高？"><a href="#CI任务占用内存太高？" class="headerlink" title="CI任务占用内存太高？"></a>CI任务占用内存太高？</h2><p>检查ci任务的代码，并没有发现导致超高内存占用的逻辑。</p><h2 id="Linux-OOM机制"><a href="#Linux-OOM机制" class="headerlink" title="Linux OOM机制"></a>Linux OOM机制</h2><p>回想起Linux OOM的逻辑，并不是一个程序占用内存高就把它干掉，而是整个系统的内存高，才会选出一个打分最高的程序干掉。</p><p>这就合理了，下午的时候runner所在宿主机上跑满了任务，很有可能出现内存紧张的情况。而这个被干掉的runner当时被打分最高，所以被干掉了。</p><p>Linux OOM机制参考：</p><ul><li><a href="https://www.cnblogs.com/MrLiuZF/p/15229868.html">Linux OOM机制分析</a></li><li><a href="https://www.vpsee.com/2013/10/how-to-configure-the-linux-oom-killer/">如何理解和配置 Linux 下的 OOM Killer？</a></li></ul><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>方法一：增加资源<br>升级宿主机内存，或者添加runner宿主机</p><p>方法二：错峰执行ci任务<br>比如这个失败的任务，还是夜间执行吧</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;GitLab CI任务，Runner使用的是&lt;code&gt;docker machine executor&lt;/code&gt;类型的执行器，执行失败报错：&lt;/p&gt;
&lt;figure class=&quot;highlight text&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Running on runner-h6ezaymy-project-1037-concurrent-0 via runner-h6ezaymy-auto-scale-1668060271-ce458595...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;WARNING: Failed to pull image with policy &amp;quot;if-not-present&amp;quot;: error during connect: Post https://192.168.99.251:2376/v1.25/images/create?fromImage=registry.gitlab.com%2Fgitlab-org%2Fgitlab-runner%2Fgitlab-runner-helper&amp;amp;tag=x86_64-58ba2b95: dial tcp 192.168.99.251:2376: connect: no route to host (manager.go:205:3s)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ERROR: Job failed (system failure): error during connect: Post https://192.168.99.251:2376/v1.25/containers/47272fbe49e4be0f85724ad99f0657b72f568810ce0f4914c57e7fcf114764e2/wait: dial tcp 192.168.99.251:2376: connect: no route to host&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;重试，问题依旧。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="cicd" scheme="https://www.voidking.com/tags/cicd/"/>
    
    <category term="gitlab" scheme="https://www.voidking.com/tags/gitlab/"/>
    
    <category term="oom" scheme="https://www.voidking.com/tags/oom/"/>
    
  </entry>
  
  <entry>
    <title>ArgoCD报错Unable to load data问题</title>
    <link href="https://www.voidking.com/dev-argocd-unable-to-load-data/"/>
    <id>https://www.voidking.com/dev-argocd-unable-to-load-data/</id>
    <published>2022-11-03T19:00:00.000Z</published>
    <updated>2022-11-03T19:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>断电后，k8s集群重新拉起。argocd无法同步gitlab中的数据，报错：</p><p>Unable to load data: Failed to fetch default: <code>git fetch origin --tags --force</code> failed exit status 128: fatal: unable to access ‘<a href="https://gitlab.voidking.com/devops/argocd.git/&#39;">https://gitlab.voidking.com/devops/argocd.git/&#39;</a>: server certificate verification failed. CAfile: none CRLfile: none</p><span id="more"></span><h1 id="查日志"><a href="#查日志" class="headerlink" title="查日志"></a>查日志</h1><h2 id="查看argocd-repo-server日志"><a href="#查看argocd-repo-server日志" class="headerlink" title="查看argocd repo-server日志"></a>查看argocd repo-server日志</h2><p>repo-server负责从gitlab同步数据，查看一下它的日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs --<span class="built_in">tail</span>=100 argo-cd-argocd-repo-server-547b6cf9f9-dff7d -n argocd</span><br></pre></td></tr></table></figure><p>内容为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time=&quot;2022-11-03T06:04:33Z&quot; level=error msg=&quot;finished unary call with code Unknown&quot; error=&quot;Get \&quot;https://gitlab.voidking.com/devops/argocd.git/info/refs?service=git-upload-pack\&quot;: x509: certificate is not valid for any names, but wanted to match gitlab.voidking.com&quot; grpc.code=Unknown grpc.method=GenerateManifest grpc.request.deadline=&quot;2022-11-03T06:05:33Z&quot; grpc.service=repository.RepoServerService grpc.start_time=&quot;2022-11-03T06:04:33Z&quot; grpc.time_ms=38.558 span.kind=server system=grpc</span><br></pre></td></tr></table></figure><h2 id="查看argocd其他组件日志"><a href="#查看argocd其他组件日志" class="headerlink" title="查看argocd其他组件日志"></a>查看argocd其他组件日志</h2><p>挨个查看argocd其他组件日志，其中dex-server看着有些问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs --<span class="built_in">tail</span>=100 argo-cd-argocd-dex-server-7cc5cc5455-c7q29  -n argocd</span><br></pre></td></tr></table></figure><p>内容为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time=&quot;2022-10-31T03:24:16Z&quot; level=info msg=&quot;keys expired, rotating&quot;</span><br><span class="line">time=&quot;2022-10-31T03:24:16Z&quot; level=info msg=&quot;keys rotated, next rotation: 2022-10-31 09:24:16.595711381 +0000 UTC&quot;</span><br></pre></td></tr></table></figure><h1 id="证书问题？"><a href="#证书问题？" class="headerlink" title="证书问题？"></a>证书问题？</h1><p>怀疑是证书到期导致的，打算对证书进行更新，参考文档<a href="https://argo-cd.readthedocs.io/en/stable/operator-manual/tls/">TLS configuration</a></p><p>但是，怎么确认证书已经到期了呢？具体怎么操作更新证书？<br>没有找到方法，先看看还有没有其他可能。</p><h1 id="重启一下试试？"><a href="#重启一下试试？" class="headerlink" title="重启一下试试？"></a>重启一下试试？</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k get pod argo-cd-argocd-repo-server-547b6cf9f9-dff7d -n argocd -oyaml | k replace --force -f -</span><br></pre></td></tr></table></figure><p>重建pod后，问题解决了。。。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;断电后，k8s集群重新拉起。argocd无法同步gitlab中的数据，报错：&lt;/p&gt;
&lt;p&gt;Unable to load data: Failed to fetch default: &lt;code&gt;git fetch origin --tags --force&lt;/code&gt; failed exit status 128: fatal: unable to access ‘&lt;a href=&quot;https://gitlab.voidking.com/devops/argocd.git/&amp;#39;&quot;&gt;https://gitlab.voidking.com/devops/argocd.git/&amp;#39;&lt;/a&gt;: server certificate verification failed. CAfile: none CRLfile: none&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="argocd" scheme="https://www.voidking.com/tags/argocd/"/>
    
    <category term="cicd" scheme="https://www.voidking.com/tags/cicd/"/>
    
    <category term="devops" scheme="https://www.voidking.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>KubeSphere版本升级</title>
    <link href="https://www.voidking.com/dev-kubesphere-upgrade/"/>
    <id>https://www.voidking.com/dev-kubesphere-upgrade/</id>
    <published>2022-11-02T10:00:00.000Z</published>
    <updated>2022-11-18T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>当前KubeSphere版本v3.2.1，但是因为权限管理不好用（不能针对不同集群单独授权），因此计划升级到v3.3.1。<br>KubeSphere v3.3.0之后支持为每个集群单独设置集群成员和集群角色，提供了更细粒度的权限管控机制，进一步完善了 KubeSphere 的多租户系统。</p><p>参考文档：</p><ul><li><a href="https://baijiahao.baidu.com/s?id=1737027419479012228&wfr=spider&for=pc">KubeSphere 3.3.0 全新升级，来了！</a></li><li><a href="https://kubesphere.io/zh/docs/v3.3/release/release-v331/">Release Notes - 3.3.1 版本说明</a></li><li><a href="https://kubesphere.io/zh/docs/v3.3/upgrade/upgrade-with-ks-installer/">使用 ks-installer 升级</a></li><li><a href="https://kubesphere.io/zh/docs/v3.3/upgrade/air-gapped-upgrade-with-ks-installer/">使用 ks-installer 离线升级</a></li></ul><span id="more"></span><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><ul><li>您应该先在测试环境中实施升级模拟。在测试环境中成功升级并且所有应用程序都正常运行之后，再在生产环境中升级您的集群。</li><li>在升级过程中，应用程序可能会短暂中断（尤其是单副本容器组），请安排合理的升级时间。</li><li>建议在生产环境中升级之前备份 etcd 和有状态应用程序。您可以使用 Velero 来备份和迁移 Kubernetes 资源以及持久化存储卷。</li></ul><p>参考文档：</p><ul><li><a href="https://kubesphere.io/zh/docs/v3.3/upgrade/overview/">升级 - 概述</a></li><li><a href="https://velero.io/">Velero</a></li><li><a href="https://baijiahao.baidu.com/s?id=1736481781028427417&wfr=spider&for=pc">详解kubernetes备份恢复利器 Velero</a></li></ul><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1、备份<br>2、kubesphere执行升级</p><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><h2 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h2><p>备份etcd，参考 <a href="https://www.voidking.com/dev-k8s-etcd-backup-restore/">《K8S集群中etcd备份和恢复》</a></p><h2 id="有状态应用程序"><a href="#有状态应用程序" class="headerlink" title="有状态应用程序"></a>有状态应用程序</h2><p>未完待续</p><h1 id="执行升级"><a href="#执行升级" class="headerlink" title="执行升级"></a>执行升级</h1><p>1、下载yaml文件&amp;提交到k8s集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/kubesphere/ks-installer/releases/download/v3.3.1/kubesphere-installer.yaml</span><br><span class="line">kubectl apply -f kubesphere-installer.yaml  --force</span><br></pre></td></tr></table></figure><p>2、观察升级进展</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get all -n kubesphere-system</span><br><span class="line">kubectl get pods -n kubesphere-system</span><br><span class="line">kubectl describe job.batch/ks-upgrade -n kubesphere-system</span><br><span class="line">kubectl logs -f ks-installer-895b8994d-5qrjs -n kubesphere-system</span><br></pre></td></tr></table></figure><p>3、验证升级后的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n kubesphere-system -oyaml | grep image:</span><br></pre></td></tr></table></figure><p>浏览器访问ks，右上角点击<code>用户名</code>，<code>关于</code>，就可以看到当前ks版本。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h1&gt;&lt;p&gt;当前KubeSphere版本v3.2.1，但是因为权限管理不好用（不能针对不同集群单独授权），因此计划升级到v3.3.1。&lt;br&gt;KubeSphere v3.3.0之后支持为每个集群单独设置集群成员和集群角色，提供了更细粒度的权限管控机制，进一步完善了 KubeSphere 的多租户系统。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://baijiahao.baidu.com/s?id=1737027419479012228&amp;wfr=spider&amp;for=pc&quot;&gt;KubeSphere 3.3.0 全新升级，来了！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubesphere.io/zh/docs/v3.3/release/release-v331/&quot;&gt;Release Notes - 3.3.1 版本说明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubesphere.io/zh/docs/v3.3/upgrade/upgrade-with-ks-installer/&quot;&gt;使用 ks-installer 升级&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubesphere.io/zh/docs/v3.3/upgrade/air-gapped-upgrade-with-ks-installer/&quot;&gt;使用 ks-installer 离线升级&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="kubesphere" scheme="https://www.voidking.com/tags/kubesphere/"/>
    
  </entry>
  
  <entry>
    <title>kubectl插件管理器krew</title>
    <link href="https://www.voidking.com/dev-kubectl-krew/"/>
    <id>https://www.voidking.com/dev-kubectl-krew/</id>
    <published>2022-10-24T20:00:00.000Z</published>
    <updated>2023-06-10T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="krew简介"><a href="#krew简介" class="headerlink" title="krew简介"></a>krew简介</h1><blockquote><p>Krew itself is a kubectl plugin that is installed and updated via Krew (yes, Krew self-hosts).</p></blockquote><p>Krew 是 kubectl 插件的包管理器。<br>Krew 是一个让使用 kubectl 插件变得容易的工具。 Krew 帮助您发现插件，在您的机器上安装和管理它们。它类似于 apt、dnf 或 brew 等工具。当前，Krew 上提供了 200 多个 kubectl 插件。</p><p>参考文档：</p><ul><li><a href="https://krew.sigs.k8s.io/docs/user-guide/setup/install/">krew - Installing</a></li><li><a href="https://github.com/kubernetes-sigs/krew">Krew</a></li></ul><span id="more"></span><h1 id="安装配置krew"><a href="#安装配置krew" class="headerlink" title="安装配置krew"></a>安装配置krew</h1><h2 id="MacOS-Linux中通用安装方法"><a href="#MacOS-Linux中通用安装方法" class="headerlink" title="MacOS/Linux中通用安装方法"></a>MacOS/Linux中通用安装方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line">  <span class="built_in">set</span> -x; <span class="built_in">cd</span> <span class="string">&quot;<span class="subst">$(mktemp -d)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  OS=<span class="string">&quot;<span class="subst">$(uname | tr &#x27;[:upper:]&#x27; &#x27;[:lower:]&#x27;)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  ARCH=<span class="string">&quot;<span class="subst">$(uname -m | sed -e &#x27;s/x86_64/amd64/&#x27; -e &#x27;s/\(arm\)\(64\)\?.*/\1\2/&#x27; -e &#x27;s/aarch64$/arm64/&#x27;)</span>&quot;</span> &amp;&amp;</span><br><span class="line">  KREW=<span class="string">&quot;krew-<span class="variable">$&#123;OS&#125;</span>_<span class="variable">$&#123;ARCH&#125;</span>&quot;</span> &amp;&amp;</span><br><span class="line">  curl -fsSLO <span class="string">&quot;https://github.com/kubernetes-sigs/krew/releases/latest/download/<span class="variable">$&#123;KREW&#125;</span>.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  tar zxvf <span class="string">&quot;<span class="variable">$&#123;KREW&#125;</span>.tar.gz&quot;</span> &amp;&amp;</span><br><span class="line">  ./<span class="string">&quot;<span class="variable">$&#123;KREW&#125;</span>&quot;</span> install krew</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="MacOS中安装方法"><a href="#MacOS中安装方法" class="headerlink" title="MacOS中安装方法"></a>MacOS中安装方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> | <span class="built_in">tr</span> <span class="string">&#x27;[:upper:]&#x27;</span> <span class="string">&#x27;[:lower:]&#x27;</span></span><br><span class="line">wget https://github.com/kubernetes-sigs/krew/releases/download/v0.4.3/krew.yaml</span><br><span class="line">wget https://github.com/kubernetes-sigs/krew/releases/download/v0.4.3/krew-darwin_amd64.tar.gz</span><br><span class="line">tar -xzvf krew-darwin_amd64.tar.gz</span><br><span class="line">./krew-darwin_amd64 install --manifest=krew.yaml --archive=krew-darwin_amd64.tar.gz</span><br></pre></td></tr></table></figure><h2 id="Linux中安装方法"><a href="#Linux中安装方法" class="headerlink" title="Linux中安装方法"></a>Linux中安装方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> | <span class="built_in">tr</span> <span class="string">&#x27;[:upper:]&#x27;</span> <span class="string">&#x27;[:lower:]&#x27;</span></span><br><span class="line">wget https://github.com/kubernetes-sigs/krew/releases/download/v0.4.3/krew.yaml</span><br><span class="line">wget https://github.com/kubernetes-sigs/krew/releases/download/v0.4.3/krew-linux_amd64.tar.gz</span><br><span class="line">tar -xzvf krew-linux_amd64.tar.gz</span><br><span class="line">./krew-linux_amd64 install --manifest=krew.yaml --archive=krew-linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><h2 id="添加krew到环境变量"><a href="#添加krew到环境变量" class="headerlink" title="添加krew到环境变量"></a>添加krew到环境变量</h2><p>1、<code>~/.bashrc</code>或者<code>~/.bash_profile</code>中添加PATH</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$&#123;PATH&#125;</span>:<span class="variable">$&#123;HOME&#125;</span>/.krew/bin&quot;</span></span><br></pre></td></tr></table></figure><p>2、使生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl krew</span><br><span class="line">kubectl krew update</span><br><span class="line">kubectl krew search</span><br></pre></td></tr></table></figure><h1 id="使用krew"><a href="#使用krew" class="headerlink" title="使用krew"></a>使用krew</h1><p>例如，安装neat</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl krew install neat</span><br></pre></td></tr></table></figure><p>例如，安装sniff</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl krew install sniff</span><br></pre></td></tr></table></figure><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>除了使用krew安装kubectl插件之外，还有另外一个更加直接的办法安装kubectl插件：下载插件的二进制文件，和kubectl文件放到一起。<br>例如，安装neat：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/itaysk/kubectl-neat/releases/download/v2.0.3/kubectl-neat_linux_amd64.tar.gz</span><br><span class="line">tar -xzvf kubectl-neat_linux_amd64.tar.gz</span><br><span class="line"><span class="built_in">which</span> kubectl <span class="comment"># /usr/bin/kubectl</span></span><br><span class="line"><span class="built_in">mv</span> kubectl-neat /usr/bin</span><br><span class="line">kubectl neat -h</span><br><span class="line">kubectl get pod <span class="built_in">test</span> -oyaml | kubectl neat</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;krew简介&quot;&gt;&lt;a href=&quot;#krew简介&quot; class=&quot;headerlink&quot; title=&quot;krew简介&quot;&gt;&lt;/a&gt;krew简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Krew itself is a kubectl plugin that is installed and updated via Krew (yes, Krew self-hosts).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Krew 是 kubectl 插件的包管理器。&lt;br&gt;Krew 是一个让使用 kubectl 插件变得容易的工具。 Krew 帮助您发现插件，在您的机器上安装和管理它们。它类似于 apt、dnf 或 brew 等工具。当前，Krew 上提供了 200 多个 kubectl 插件。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://krew.sigs.k8s.io/docs/user-guide/setup/install/&quot;&gt;krew - Installing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kubernetes-sigs/krew&quot;&gt;Krew&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="kubectl" scheme="https://www.voidking.com/tags/kubectl/"/>
    
    <category term="krew" scheme="https://www.voidking.com/tags/krew/"/>
    
  </entry>
  
  <entry>
    <title>K8S配置使用imagePullSecrets</title>
    <link href="https://www.voidking.com/dev-k8s-imagepullsecrets/"/>
    <id>https://www.voidking.com/dev-k8s-imagepullsecrets/</id>
    <published>2022-10-22T14:00:00.000Z</published>
    <updated>2023-06-03T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-harbor-start/">《Harbor入门篇》</a>一文中，我们已经安装配置好了Harbor。<br>本文中，我们来学习一下怎样在K8S中配置使用imagePullSecrets，从Harbor或者其他私有镜像仓库拉取镜像。</p><p>参考文档：</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry/">从私有仓库拉取镜像</a></li></ul><span id="more"></span><h1 id="创建imagePullSecrets"><a href="#创建imagePullSecrets" class="headerlink" title="创建imagePullSecrets"></a>创建imagePullSecrets</h1><p>创建一个docker-registry类型的secret，名字为<code>harbor-secret</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl create secret docker-registry harbor-secret \</span><br><span class="line">  --docker-server=harbor.voidking.com \</span><br><span class="line">  --docker-username=admin \</span><br><span class="line">  --docker-password=Harbor12345</span><br></pre></td></tr></table></figure><h1 id="使用imagePullSecrets"><a href="#使用imagePullSecrets" class="headerlink" title="使用imagePullSecrets"></a>使用imagePullSecrets</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">testpod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">busybox</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">harbor.voidking.com/voidking/busybox:1.31</span></span><br><span class="line">    <span class="attr">command:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="string">sleep</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;3600&quot;</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">harbor-secret</span></span><br></pre></td></tr></table></figure><h1 id="给pod添加默认imagePullSecrets"><a href="#给pod添加默认imagePullSecrets" class="headerlink" title="给pod添加默认imagePullSecrets"></a>给pod添加默认imagePullSecrets</h1><p>上面的配置，已经可以正常从harbor镜像仓库拉取镜像了。<br>但是，每个pod都需要指定一下imagePullSecrets，也是比较麻烦。<br>这里我们可以在命名空间默认sa中添加imagePullSecrets，这样我们就不用在pod中指定imagePullSecrets了，创建pod时会自动注入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch serviceaccount default \</span><br><span class="line">  -p <span class="string">&quot;&#123;\&quot;imagePullSecrets\&quot;: [&#123;\&quot;name\&quot;: \&quot;docker-secret\&quot;&#125;]&#125;&quot;</span> \</span><br><span class="line">  -n &lt;your-namespace&gt;</span><br></pre></td></tr></table></figure><h1 id="全局配置imagePullSecrets"><a href="#全局配置imagePullSecrets" class="headerlink" title="全局配置imagePullSecrets"></a>全局配置imagePullSecrets</h1><p>如果新增了namespace，那么这个namespace就需要单独添加一次imagePullSecrets，而且这个namespace的sa也需要添加imagePullSecrets。</p><p>这里可以使用imagepullsecret-patcher来简化我们的工作，参考文档：</p><ul><li><a href="https://devopstales.github.io/kubernetes/k8s-imagepullsecret-patcher/">How to use imagePullSecrets cluster-wide??</a></li><li><a href="https://medium.com/titansoft-engineering/kubernetes-cluster-wide-access-to-private-container-registry-with-imagepullsecret-patcher-b8b8fb79f7e5">Kubernetes cluster-wide access to private container registry with imagepullsecret-patcher</a></li><li><a href="https://github.com/titansoft-pte-ltd/imagepullsecret-patcher">imagepullsecret-patcher</a></li><li><a href="https://github.com/titansoft-pte-ltd/imagepullsecret-patcher/tree/master/deploy-example">imagepullsecret-patcher deploy-example</a></li></ul><p>1、获取 dockerconfigjson</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># kubectl get secret harbor-secret -oyaml</span></span><br><span class="line">kubectl create secret docker-registry harbor-secret \</span><br><span class="line">  --docker-server=harbor.voidking.com \</span><br><span class="line">  --docker-username=admin \</span><br><span class="line">  --docker-password=Harbor12345 \</span><br><span class="line">  --dry-run=client -oyaml</span><br></pre></td></tr></table></figure><p>获取到 dockerconfigjson ，填入到下一步的 deployment.yaml 文件中。</p><p>2、准备资源清单</p><ul><li>namespace.yaml，定义namespace</li><li>rbac.yaml，定义sa权限</li><li>deployment，定义imagepullsecret-patcher服务</li></ul><p>namespace.yaml 内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br></pre></td></tr></table></figure><p>rbac.yaml 内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">secrets</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">serviceaccounts</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">patch</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">create</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">delete</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">namespaces</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">imagepullsecret-patcher</span></span><br></pre></td></tr></table></figure><p>deployment.yaml 内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">kubernetes.io/dockerconfigjson</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">image-pull-secret-src</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">.dockerconfigjson:</span> <span class="string">eyJhdXRocyI6eyJoYXJib3Iudm9pZGtpbmcuY29tIjp7InVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6IkhhcmJvcjEyMzQ1IiwiYXV0aCI6IllXUnRhVzQ2U0dGeVltOXlNVEl6TkRVPSJ9fX0=</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">automountServiceAccountToken:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">imagepullsecret-patcher</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">&quot;quay.io/titansoft/imagepullsecret-patcher:v0.14&quot;</span></span><br><span class="line">          <span class="attr">env:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CONFIG_FORCE</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CONFIG_DEBUG</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;false&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CONFIG_ALLSERVICEACCOUNT</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;true&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CONFIG_DOCKERCONFIGJSONPATH</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;/app/secrets/.dockerconfigjson&quot;</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CONFIG_SECRETNAME</span></span><br><span class="line">              <span class="attr">value:</span> <span class="string">&quot;harbor-secret&quot;</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">src-dockerconfigjson</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">&quot;/app/secrets&quot;</span></span><br><span class="line">              <span class="attr">readOnly:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">resources:</span></span><br><span class="line">            <span class="attr">requests:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="number">0.1</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">15Mi</span></span><br><span class="line">            <span class="attr">limits:</span></span><br><span class="line">              <span class="attr">cpu:</span> <span class="number">0.2</span></span><br><span class="line">              <span class="attr">memory:</span> <span class="string">30Mi</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">src-dockerconfigjson</span></span><br><span class="line">          <span class="attr">secret:</span> </span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">image-pull-secret-src</span></span><br></pre></td></tr></table></figure><p>其中dockerconfigjson改成上一步中获取到的dockerconfigjson，CONFIG_SECRETNAME变量的value改成期望的secret名称。</p><p>3、安装imagepullsecret-patcher</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f namespace.yaml</span><br><span class="line">kubectl apply -f rbac.yaml</span><br><span class="line">kubectl apply -f deployment.yaml</span><br></pre></td></tr></table></figure><p>4、查看安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get all -n imagepullsecret-patcher</span><br><span class="line">kubectl get sa -n imagepullsecret-patcher</span><br><span class="line">kubectl get sa default -n imagepullsecret-patcher -oyaml</span><br></pre></td></tr></table></figure><p>可以发现，<code>harbor-secret</code> 已经注入到了sa中。</p><h1 id="修改imagePullSecrets"><a href="#修改imagePullSecrets" class="headerlink" title="修改imagePullSecrets"></a>修改imagePullSecrets</h1><p>有时候，我们需要修改imagePullSecrets，比如修改用户名和密码。这时可以直接修改 image-pull-secret-src 这个secret，修改完成后，imagepullsecret-patcher会自动完成所有namespace下的 harbor-secret 的修改。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit secret image-pull-secret-src -n imagepullsecret-patcher</span><br></pre></td></tr></table></figure><h1 id="删除imagePullSecrets"><a href="#删除imagePullSecrets" class="headerlink" title="删除imagePullSecrets"></a>删除imagePullSecrets</h1><p>有时候，我们需要替换imagePullSecrets，比如imagePullSecrets名称发生了变更。这时就需要删除原本的imagePullSecrets。</p><p>单个sa删除imagePullSecrets方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INDEX=$(kubectl get sa default -n imagepullsecret-patcher -o json | jq <span class="string">&#x27;.imagePullSecrets | map(.name == &quot;harbor-secret&quot;) | index(true)&#x27;</span>)</span><br><span class="line">kubectl patch sa default --<span class="built_in">type</span>=json -p=<span class="string">&quot;[&#123;&#x27;op&#x27;: &#x27;remove&#x27;, &#x27;path&#x27;: &#x27;/imagePullSecrets/<span class="variable">$INDEX</span>&#x27;&#125;]&quot;</span> -n imagepullsecret-patcher</span><br></pre></td></tr></table></figure><p>批量sa删除imagePullSecrets方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">kubectl get ns | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | grep -v <span class="string">&quot;NAME&quot;</span> &gt; namespace.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> namespace <span class="keyword">in</span> `<span class="built_in">cat</span> namespace.txt`;<span class="keyword">do</span></span><br><span class="line">  INDEX=$(kubectl get sa default -n <span class="variable">$namespace</span> -o json | jq <span class="string">&#x27;.imagePullSecrets | map(.name == &quot;harbor-secret&quot;) | index(true)&#x27;</span>)</span><br><span class="line">  kubectl patch sa default --<span class="built_in">type</span>=json -p=<span class="string">&quot;[&#123;&#x27;op&#x27;: &#x27;remove&#x27;, &#x27;path&#x27;: &#x27;/imagePullSecrets/<span class="variable">$INDEX</span>&#x27;&#125;]&quot;</span> -n <span class="variable">$namespace</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h1 id="添加多个imagePullSecrets"><a href="#添加多个imagePullSecrets" class="headerlink" title="添加多个imagePullSecrets"></a>添加多个imagePullSecrets</h1><p>问：如果有多个镜像仓库需要配置imagePullSecrets，该怎么处理？<br>答：可以把多个imagePullSecrets写入到同一个dockerconfigjson。</p><h2 id="dockerconfigjson解析"><a href="#dockerconfigjson解析" class="headerlink" title="dockerconfigjson解析"></a>dockerconfigjson解析</h2><p>dockerconfigjson是一个base64加密的字符串，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;eyJhdXRocyI6eyJoYXJib3Iudm9pZGtpbmcuY29tIjp7InVzZXJuYW1lIjoiYWRtaW4iLCJwYXNzd29yZCI6IkhhcmJvcjEyMzQ1IiwiYXV0aCI6IllXUnRhVzQ2U0dGeVltOXlNVEl6TkRVPSJ9fX0=&quot;</span> | <span class="built_in">base64</span> -d</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;auths&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;harbor.voidking.com&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;Harbor12345&quot;</span><span class="punctuation">,</span><span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span><span class="string">&quot;YWRtaW46SGFyYm9yMTIzNDU=&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>实际上，它的结构和<code>docker login</code>后产生的<code>$HOME/.docker/config.json</code>完全一致。</p><p>其中，auth的value也是base64加密的字符串，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;YWRtaW46SGFyYm9yMTIzNDU=&quot;</span> | <span class="built_in">base64</span> -d</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin:Harbor12345</span><br></pre></td></tr></table></figure><h2 id="dockerconfigjson拼接"><a href="#dockerconfigjson拼接" class="headerlink" title="dockerconfigjson拼接"></a>dockerconfigjson拼接</h2><p>知道了dockerconfigjson的结构，那么我们可以知道，如果有多个imagePullSecrets，我们可以自己拼接一个dockerconfigjson明文字符串，然后进行base64加密。</p><p>dockerconfigjson1 内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;auths&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;harbor.voidking.com&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;admin&quot;</span><span class="punctuation">,</span><span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;Harbor12345&quot;</span><span class="punctuation">,</span><span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span><span class="string">&quot;YWRtaW46SGFyYm9yMTIzNDU=&quot;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>dockerconfigjson2 内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;auths&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;harbor1.voidking.com&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;haojin&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span> <span class="string">&quot;haojin123&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;auth&quot;</span><span class="punctuation">:</span> <span class="string">&quot;aGFvamluOmhhb2ppbjEyMwo=&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>那么 dockerconfigjson1 和 dockerconfigjson2 可以拼接成一个明文dockerconfigjson：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jq -n <span class="string">&#x27;reduce inputs as $i (&#123;&#125;; . * $i)&#x27;</span> dockerconfigjson1 dockerconfigjson2 | jq -c</span><br></pre></td></tr></table></figure><p>然后通过base64加密，就是我们需要的加密后的dockerconfigjson。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jq -n <span class="string">&#x27;reduce inputs as $i (&#123;&#125;; . * $i)&#x27;</span> dockerconfigjson1 dockerconfigjson2 | jq -c | <span class="built_in">base64</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure><p>参考文档：</p><ul><li><a href="https://github.com/titansoft-pte-ltd/imagepullsecret-patcher/issues/29">Multiple deployments for multiple secrets / private registries?</a></li><li><a href="https://www.voidking.com/dev-jq-command/">《jq命令的安装使用》</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-harbor-start/&quot;&gt;《Harbor入门篇》&lt;/a&gt;一文中，我们已经安装配置好了Harbor。&lt;br&gt;本文中，我们来学习一下怎样在K8S中配置使用imagePullSecrets，从Harbor或者其他私有镜像仓库拉取镜像。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/tasks/configure-pod-container/pull-image-private-registry/&quot;&gt;从私有仓库拉取镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
    <category term="harbor" scheme="https://www.voidking.com/tags/harbor/"/>
    
  </entry>
  
  <entry>
    <title>K8S中安装配置KubeSphere</title>
    <link href="https://www.voidking.com/dev-k8s-kubesphere/"/>
    <id>https://www.voidking.com/dev-k8s-kubesphere/</id>
    <published>2022-10-10T15:00:00.000Z</published>
    <updated>2023-01-11T10:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KubeSphere简介"><a href="#KubeSphere简介" class="headerlink" title="KubeSphere简介"></a>KubeSphere简介</h1><blockquote><p>KubeSphere 愿景是打造一个以 Kubernetes 为内核的云原生分布式操作系统，它的架构可以非常方便地使第三方应用与云原生生态组件进行即插即用（plug-and-play）的集成，支持云原生应用在多云与多集群的统一分发和运维管理。</p></blockquote><p>简单来说，KubeSphere（下文简称ks）就是一个容器管理平台，可以图形化管理多个K8S集群。</p><p>相关链接：</p><ul><li><a href="https://kubesphere.io/zh/">KubeSphere官网</a></li><li><a href="https://kubesphere.io/zh/videos/">KubeSphere学习视频</a></li></ul><span id="more"></span><h1 id="安装准备"><a href="#安装准备" class="headerlink" title="安装准备"></a>安装准备</h1><p>参考<a href="https://kubesphere.io/zh/docs/v3.3/installing-on-kubernetes/introduction/prerequisites/">在 Kubernetes 上安装 KubeSphere - 准备工作</a>，确认环境满足ks安装需求。</p><h2 id="k8s版本"><a href="#k8s版本" class="headerlink" title="k8s版本"></a>k8s版本</h2><p>计划安装kubesphere-v3.3.0版本，需要确认 Kubernetes 版本必须为：v1.19.x，v1.20.x，v1.21.x，v1.22.x 或 v1.23.x（实验性支持）。</p><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>可用 CPU &gt; 1 核；内存 &gt; 2 G。CPU 必须为 x86_64，暂时不支持 Arm 架构的 CPU。</p><h2 id="StorageClass"><a href="#StorageClass" class="headerlink" title="StorageClass"></a>StorageClass</h2><p>Kubernetes 集群已配置默认 StorageClass（请使用 <code>kubectl get sc</code> 进行确认）。<br>这一条是最重要的，因为k8s集群默认并不会配置storageclass，需要我们自己单独配置。<br>storage安装配置方法参考<a href="https://www.voidking.com/dev-k8s-storageclass/">《K8S中安装配置StorageClass》</a></p><h1 id="安装ks"><a href="#安装ks" class="headerlink" title="安装ks"></a>安装ks</h1><p>参考<a href="https://kubesphere.io/zh/docs/v3.3/installing-on-kubernetes/introduction/overview/">在 Kubernetes 上安装 KubeSphere - 概述</a>，安装kubesphere-v3.3.0版本</p><p>1、下载manifests</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/kubesphere/ks-installer/releases/download/v3.3.0/kubesphere-installer.yaml</span><br><span class="line">wget https://github.com/kubesphere/ks-installer/releases/download/v3.3.0/cluster-configuration.yaml</span><br></pre></td></tr></table></figure><p>2、修改集群配置 cluster-configuration.yaml<br>ks-apiserver和ks-controller-manager的资源调整示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">common:</span></span><br><span class="line">    <span class="attr">core:</span></span><br><span class="line">      <span class="attr">console:</span></span><br><span class="line">        <span class="attr">enableMultiLogin:</span> <span class="literal">true</span></span><br><span class="line">        <span class="attr">port:</span> <span class="number">30880</span></span><br><span class="line">      <span class="attr">apiserver:</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">400Mi</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">8Gi</span></span><br><span class="line">      <span class="attr">controllerManager:</span></span><br><span class="line">        <span class="attr">resources:</span></span><br><span class="line">          <span class="attr">requests:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">400Mi</span></span><br><span class="line">          <span class="attr">limits:</span></span><br><span class="line">            <span class="attr">cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">            <span class="attr">memory:</span> <span class="string">8Gi</span></span><br><span class="line">    <span class="attr">minio:</span></span><br><span class="line">      <span class="attr">volumeSize:</span> <span class="string">200Gi</span> <span class="comment"># Minio PVC size.</span></span><br></pre></td></tr></table></figure><p>因为ks-apiserver和ks-controller-manager容易OOM，所以内存上限设置高一些。</p><p>kubesphere的一些功能（数据备份、日志存储、应用数据存储）需要依赖minio，因此把minio的存储调大一些。</p><p>opensearch一般用不到，opensearch.enabled 改成false。</p><p>3、提交资源清单到k8s集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f kubesphere-installer.yaml</span><br><span class="line">kubectl apply -f cluster-configuration.yaml</span><br></pre></td></tr></table></figure><p>4、查看安装过程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k describe pod/ks-installer-xxx-xxx -n kubesphere-system</span><br><span class="line">kubectl logs -n kubesphere-system $(kubectl get pod -n kubesphere-system -l <span class="string">&#x27;app in (ks-install, ks-installer)&#x27;</span> -o jsonpath=<span class="string">&#x27;&#123;.items[0].metadata.name&#125;&#x27;</span>) -f</span><br></pre></td></tr></table></figure><p>5、查看ks状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl get all -n kubesphere-system</span><br><span class="line">kubectl get svc/ks-console -n kubesphere-system</span><br></pre></td></tr></table></figure><h1 id="storageclass问题排查"><a href="#storageclass问题排查" class="headerlink" title="storageclass问题排查"></a>storageclass问题排查</h1><p>redis没有ready，一直处于pending状态，查看详情</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod/redis-d744b7468-45sh4 -n kubesphere-system</span><br></pre></td></tr></table></figure><p>报错：0/x nodes are available: x pod has unbound immediate PersistentVolumeClaims.</p><p>查看nfs-client-provisioner日志</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs --<span class="built_in">tail</span>=100 nfs-client-provisioner-7975f9b954-7fw5l</span><br></pre></td></tr></table></figure><p>报错：<br>provision “kubesphere-system/redis-pvc” class “nfs-storage”: unexpected error getting claim reference: selfLink was empty, can’t make reference</p><p>这是因为，1.20.x之后的k8s版本，selflink已经弃用了。而nfs-client-provisioner的实现基于selflink，因此报错。</p><p>解决办法：apiserver启动时添加参数<code>--feature-gates=RemoveSelfLink=false</code><br>1、编辑kube-apiserver.yaml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/kubernetes/manifests/kube-apiserver.yaml</span><br></pre></td></tr></table></figure><p>如下修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">command:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">kube-apiserver</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--...</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">--feature-gates=RemoveSelfLink=false</span></span><br></pre></td></tr></table></figure><p>2、重建apiserver pod<br>因为apiserver是static pod，所以在修改完kube-apiserver.yaml后会自动重建。</p><p>参考文档：</p><ul><li><a href="https://github.com/kubernetes-sigs/nfs-subdir-external-provisioner/issues/25">unexpected error getting claim reference: selfLink was empty, can’t make reference</a></li><li><a href="https://www.cnblogs.com/zhangsi-lzq/p/14292628.html">kubernetes1.20版本 nfs-provisioner报错问题:”selfLink was empty”</a></li></ul><h1 id="验证ks"><a href="#验证ks" class="headerlink" title="验证ks"></a>验证ks</h1><p>KS默认对外开放 30880 端口，通过 NodePort (IP:30880) 使用默认帐户和密码 (admin/P@88w0rd) 访问 Web 控制台。<br><a href="http://192.168.56.101:30880/login">http://192.168.56.101:30880/login</a><br>第一次登录时，会提示修改密码。</p><h1 id="修改ks配置"><a href="#修改ks配置" class="headerlink" title="修改ks配置"></a>修改ks配置</h1><p>如果ks已经安装完成，想要修改ks集群配置的话，可以通过修改clusterconfiguration配置来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get cm kubesphere-config -n kubesphere-system -oyaml</span><br><span class="line">kubectl get clusterconfiguration ks-installer -n kubesphere-system -oyaml</span><br><span class="line">kubectl edit clusterconfiguration ks-installer -n kubesphere-system</span><br></pre></td></tr></table></figure><p>修改ks-installer配置后，相关pod会自动重启（请耐心等待，大概5分钟内会自动重启）。</p><p>参考文档<a href="https://kubesphere.io/zh/docs/v3.3/access-control-and-account-management/external-authentication/use-an-ldap-service/">KubeSphere - LDAP身份提供者</a></p><h1 id="重置ks密码"><a href="#重置ks密码" class="headerlink" title="重置ks密码"></a>重置ks密码</h1><p>如果忘记了ks的密码，可以通过kubectl命令进行重置。参考文档<a href="https://kubesphere.io/docs/v3.3/faq/access-control/forgot-password/">Reset the Account Password</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl patch <span class="built_in">users</span> &lt;USERNAME&gt; -p <span class="string">&#x27;&#123;&quot;spec&quot;:&#123;&quot;password&quot;:&quot;&lt;YOURPASSWORD&gt;&quot;&#125;&#125;&#x27;</span> --<span class="built_in">type</span>=<span class="string">&#x27;merge&#x27;</span> &amp;&amp; kubectl annotate <span class="built_in">users</span> &lt;USERNAME&gt; iam.kubesphere.io/password-encrypted-</span><br></pre></td></tr></table></figure><h1 id="nginx配置"><a href="#nginx配置" class="headerlink" title="nginx配置"></a>nginx配置</h1><p>配置好nginx，通过域名访问ks正常，但是在ks页面上访问容器终端时可能报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not connect to the container. Do you have sufficient privileges?</span><br></pre></td></tr></table></figure><p>这是因为页面访问终端需要websocket支持，所以nginx配置中需要添加websocket支持，配置方法参考<a href="https://www.voidking.com/dev-nginx-start/">《Nginx入门篇》</a>。</p><h1 id="添加项目到企业空间"><a href="#添加项目到企业空间" class="headerlink" title="添加项目到企业空间"></a>添加项目到企业空间</h1><p>Kubernetes命名空间就是KubeSphere项目，这些项目可以在 平台管理-&gt;集群管理-&gt;具体集群-&gt;项目 中查看到。</p><p>添加现有KubeSphere项目到企业空间：<br>1、以管理员身份登录KubeSphere控制台，转到集群管理页面。点击项目，可以查看在当前集群中运行的所有项目。<br>2、通过 kubectl 创建的命名空间不属于任何企业空间。请点击右侧的三个点，选择分配企业空间。<br>3、在弹出的对话框中，为该项目选择一个企业空间和项目管理员，然后点击确定。<br>4、转到企业空间，可以在项目页面看到该项目已显示。</p><p>参考文档：</p><ul><li><a href="https://kubesphere.io/zh/docs/v3.3/faq/access-control/add-kubernetes-namespace-to-kubesphere-workspace/">添加现有 Kubernetes 命名空间至 KubeSphere 企业空间</a></li></ul><h1 id="批量添加项目到企业空间"><a href="#批量添加项目到企业空间" class="headerlink" title="批量添加项目到企业空间"></a>批量添加项目到企业空间</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get ns |grep voidking | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> | xargs kubectl patch ns -p <span class="string">&#x27;metadata: &#123;labels: &#123;kubesphere.io/workspace: &quot;voidking&quot;&#125;, annotations: &#123;kubesphere.io/creator: &quot;haojin&quot;&#125;&#125;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="ks多集群"><a href="#ks多集群" class="headerlink" title="ks多集群"></a>ks多集群</h1><p>参考文档：</p><ul><li><a href="https://blog.51cto.com/u_15127592/2803374">Kubernetes 多集群在开源项目 KubeSphere 的应用</a></li></ul><h1 id="多租户管理"><a href="#多租户管理" class="headerlink" title="多租户管理"></a>多租户管理</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>集群：k8s集群。</li><li>企业空间：业务管理基本单元。</li><li>公司部门：公司内部的部门和ks部门没有必然联系。</li><li>ks部门：企业空间中权限划分的单位，每个企业空间包含多个ks部门，每个ks部门包含多个用户，方便批量授权。</li><li>ks用户：每个公司成员，对应一个ks用户，一个ks用户可以属于多个ks部门。</li><li>项目：项目对应k8s中的namespace，一个项目可以同时分配给不同的ks部门。</li></ul><p>集群和企业空间，是多对多的关系。一个企业空间可以包含多个集群，一个集群可以被多个企业空间包含。</p><p>ks中每个项目只能添加到一个企业空间，因此企业空间按照业务来划分，作为业务管理的基本单位。</p><p>企业空间作为操作kubesphere的唯一入口，在企业空间授权一个项目的管理权限后，如果用户通过集群管理找到一个项目，是没有权限的。</p><p>每个企业空间，建议设置1-3个管理员。管理员负责本企业空间的具体权限管理，例如添加管理员、新建部门、给新成员授权等</p><p>ks部门划分的目的，是为了项目的权限管理，因此需要先对集群和项目权限进行规划。<br>通过ks部门，授权可以精确到每个项目和每个人。</p><p>参考文档：</p><ul><li><a href="https://kubesphere.io/zh/docs/v3.3/access-control-and-account-management/multi-tenancy-in-kubesphere/">KubeSphere 中的多租户</a></li><li><a href="https://kubesphere.io/zh/docs/v3.3/faq/access-control/add-kubernetes-namespace-to-kubesphere-workspace/">添加现有 Kubernetes 命名空间至 KubeSphere 企业空间</a></li></ul><h2 id="多租户管理操作流程"><a href="#多租户管理操作流程" class="headerlink" title="多租户管理操作流程"></a>多租户管理操作流程</h2><p>1、创建企业空间，并关联集群</p><p>2、添加现有项目到企业空间</p><p>3、创建部门，针对部门精细化授权</p><p>4、添加用户到部门</p><p>5、通知ks入口都使用企业空间，不要使用集群管理</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;KubeSphere简介&quot;&gt;&lt;a href=&quot;#KubeSphere简介&quot; class=&quot;headerlink&quot; title=&quot;KubeSphere简介&quot;&gt;&lt;/a&gt;KubeSphere简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;KubeSphere 愿景是打造一个以 Kubernetes 为内核的云原生分布式操作系统，它的架构可以非常方便地使第三方应用与云原生生态组件进行即插即用（plug-and-play）的集成，支持云原生应用在多云与多集群的统一分发和运维管理。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;简单来说，KubeSphere（下文简称ks）就是一个容器管理平台，可以图形化管理多个K8S集群。&lt;/p&gt;
&lt;p&gt;相关链接：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubesphere.io/zh/&quot;&gt;KubeSphere官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubesphere.io/zh/videos/&quot;&gt;KubeSphere学习视频&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    <category term="storage" scheme="https://www.voidking.com/categories/engineering/storage/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="存储" scheme="https://www.voidking.com/tags/%E5%AD%98%E5%82%A8/"/>
    
    <category term="kubesphere" scheme="https://www.voidking.com/tags/kubesphere/"/>
    
    <category term="storageclass" scheme="https://www.voidking.com/tags/storageclass/"/>
    
  </entry>
  
  <entry>
    <title>KubeSphere登录后报错Session Timeout</title>
    <link href="https://www.voidking.com/dev-kubesphere-session-timeout/"/>
    <id>https://www.voidking.com/dev-kubesphere-session-timeout/</id>
    <published>2022-10-10T15:00:00.000Z</published>
    <updated>2022-11-02T11:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>大部分用户能够正常登录和使用ks，但是个别用户（voidking01）登录ks后报错。<br>用户登录ks，正常；登录后查看工作台，正常；查看host集群和只包含host集群的企业空间，正常。</p><p>但是，选择一个非host集群或者选择一个包含非host集群的企业空间后，页面就会弹出错误提示：<br>Session timeout or this account is logged in elsewhere, please login again</p><p>然后转到登录页面，再次登录，继续弹出上面的错误提示。循环往复。</p><span id="more"></span><h1 id="权限问题？"><a href="#权限问题？" class="headerlink" title="权限问题？"></a>权限问题？</h1><p>更改用户权限为admin，问题依旧。</p><p>重新给用户授权，问题依旧。</p><h1 id="ks版本问题？"><a href="#ks版本问题？" class="headerlink" title="ks版本问题？"></a>ks版本问题？</h1><p>ks版本从3.2.1升级到了3.3.1，问题依旧。</p><h1 id="kube-events组件问题？"><a href="#kube-events组件问题？" class="headerlink" title="kube-events组件问题？"></a>kube-events组件问题？</h1><p>参考文档<a href="https://kubesphere.com.cn/forum/d/1501">登录成功后，总是提示会话超时或此账户在其他登录地方登录，请重新登录</a></p><p>经检查，并没有kube-events失败日志，不是它的问题。</p><h1 id="ks配置问题？"><a href="#ks配置问题？" class="headerlink" title="ks配置问题？"></a>ks配置问题？</h1><p>参考文档：</p><ul><li><a href="https://kubesphere.io/docs/v3.3/faq/access-control/session-timeout/">Session Timeout</a></li><li><a href="https://kubesphere.io/docs/v3.3/access-control-and-account-management/external-authentication/set-up-external-authentication/">Set Up External Authentication</a></li></ul><p>阅读ks文档，怀疑是ks配置不对引起的。那就按照官方文档重新配置一下试试。</p><h2 id="host集群"><a href="#host集群" class="headerlink" title="host集群"></a>host集群</h2><p>1、编辑ks-installer配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubesphere-system edit cc ks-installer</span><br></pre></td></tr></table></figure><p>2、修改authentication部分配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">authentication:</span></span><br><span class="line">    <span class="attr">jwtSecret:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="attr">authenticateRateLimiterMaxTries:</span> <span class="number">10</span></span><br><span class="line">    <span class="attr">authenticateRateLimiterDuration:</span> <span class="string">10m0s</span></span><br><span class="line">    <span class="attr">loginHistoryRetentionPeriod:</span> <span class="string">168h</span></span><br><span class="line">    <span class="attr">maximumClockSkew:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">multipleLogin:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">oauthOptions:</span></span><br><span class="line">      <span class="attr">accessTokenMaxAge:</span> <span class="string">1h</span></span><br><span class="line">      <span class="attr">accessTokenInactivityTimeout:</span> <span class="string">30m</span></span><br><span class="line">      <span class="attr">identityProviders:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LDAP</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">LDAPIdentityProvider</span></span><br><span class="line">        <span class="attr">mappingMethod:</span> <span class="string">auto</span></span><br><span class="line">        <span class="attr">provider:</span></span><br><span class="line">          <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.2</span><span class="string">:389</span></span><br><span class="line">          <span class="attr">managerDN:</span> <span class="string">uid=root,cn=users,dc=nas</span></span><br><span class="line">          <span class="attr">managerPassword:</span> <span class="string">********</span></span><br><span class="line">          <span class="attr">userSearchBase:</span> <span class="string">cn=users,dc=nas</span></span><br><span class="line">          <span class="attr">loginAttribute:</span> <span class="string">uid</span></span><br><span class="line">          <span class="attr">mailAttribute:</span> <span class="string">mail</span></span><br></pre></td></tr></table></figure><h2 id="member集群"><a href="#member集群" class="headerlink" title="member集群"></a>member集群</h2><p>member集群只要配置<code>jwtSecret</code>即可，和host集群保持一致。详情参考<a href="https://kubesphere.io/docs/v3.3/multicluster-management/enable-multicluster/direct-connection/">Direct Connection</a></p><p>修改完成，ks pod重建后，问题依旧。</p><h1 id="删除用户重建？"><a href="#删除用户重建？" class="headerlink" title="删除用户重建？"></a>删除用户重建？</h1><p>删除用户，用户重新登录，重新授权，问题依旧。</p><h1 id="时钟问题？"><a href="#时钟问题？" class="headerlink" title="时钟问题？"></a>时钟问题？</h1><p>参考<a href="https://kubesphere.io/docs/v3.3/faq/access-control/session-timeout/">Session Timeout</a>文档，还有一种可能是节点时钟偏差。</p><blockquote><p>The node clock skew affects time-sensitive operations such as validating the expiration time of a user token. You can configure the server time synchronization with an NTP server. MaximumClockSkew can also be set, which defaults to 10 seconds.</p></blockquote><p>分别登录host集群和member集群的apiserver pod，执行<code>date</code>命令查看时间。<br>发现不同集群的时区配置不同，啊哈，大概率是这个问题了！！！</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">cp</span> /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br></pre></td></tr></table></figure><p>统一所有集群节点时区为<code>Asia/Shanghai</code>，然后重建ks pod。问题依旧。</p><p>把<code>maximumClockSkew</code>也调大一些，默认10s，调整到60s试试。问题依旧。</p><h1 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h1><p>参考文档<a href="https://kubesphere.com.cn/docs/v3.3/faq/multi-cluster-management/host-cluster-access-member-cluster/">恢复主集群对成员集群的访问权限</a>，查看member集群的api-server日志。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kubesphere-system logs ks-apiserver-7c9c9456bd-qv6bs</span><br></pre></td></tr></table></figure><p>出现报错信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">W1104 11:13:28.432457       1 clusterroles.go:117] invalid aggregation role found: cluster-admin, role-template-manage-configmaps</span><br><span class="line">W1104 11:13:28.432464       1 clusterroles.go:117] invalid aggregation role found: cluster-admin, role-template-view-secrets</span><br><span class="line">W1104 11:13:28.432469       1 clusterroles.go:117] invalid aggregation role found: cluster-admin, role-template-manage-secrets</span><br><span class="line">W1104 11:13:28.432475       1 clusterroles.go:117] invalid aggregation role found: cluster-admin, role-template-view-service-accounts</span><br><span class="line">W1104 11:13:28.432484       1 clusterroles.go:117] invalid aggregation role found: cluster-admin, role-template-manage-service-accounts</span><br><span class="line">E1104 11:13:51.879574       1 upgradeaware.go:401] Error proxying data from backend to client: readfrom tcp 10.244.161.166:9090-&gt;192.168.50.74:34540: write tcp 10.244.161.166:9090-&gt;192.168.50.74:34540: write: connection reset by peer</span><br></pre></td></tr></table></figure><p>顺着这个日志，在kubesphere社区找到了一个相同的问题<a href="https://kubesphere.com.cn/forum/d/7394-kubesphere-member">kubesphere使用子账户…会跳转到登录界面</a></p><blockquote><p>看起来是多集群同步出问题了，看下 host 集群 kube-federation-system 这个 namespace 下的 pod 是否都正常</p></blockquote><p>根据论坛大佬的提示，检查kube-federation-system 这个 namespace 下的pod信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n kube-federation-system</span><br><span class="line">kubectl logs --<span class="built_in">tail</span>=100 kubefed-admission-webhook-657959d4d6-2sx5f -n kube-federation-system</span><br><span class="line">kubectl logs --<span class="built_in">tail</span>=100 kubefed-controller-manager-54fbd87f7f-6t7jq -n kube-federation-system</span><br><span class="line">kubectl logs --<span class="built_in">tail</span>=100 kubefed-controller-manager-54fbd87f7f-fh9pk -n kube-federation-system</span><br></pre></td></tr></table></figure><p>看着也没有什么明显的报错信息。</p><p>根据论坛的提示，有两个解决办法：一个是替换kubeconfig，一个是升级kubefed controller。</p><ul><li><a href="https://github.com/kubesphere/kubesphere/issues/4891">Update the version of kubefed controller </a></li><li><a href="https://github.com/kubernetes-sigs/kubefed/pull/1505">fix: controller-manager panic when kubeconfig set filed insecure-skip-tls-verify</a></li></ul><p>这里我们选择升级kubefed controller。</p><h1 id="升级kubefed-controller"><a href="#升级kubefed-controller" class="headerlink" title="升级kubefed controller"></a>升级kubefed controller</h1><p>1、查看当前kubefed controller版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployment.apps/kubefed-controller-manager -n kube-federation-system -oyaml| grep image</span><br></pre></td></tr></table></figure><p>查看到当前版本v0.8.1</p><p>2、查看kubefed controller最新版本<br>访问<a href="https://hub.docker.com/r/kubesphere/kubefed/tags">dockerhub - kubesphere/kubefed</a><br>找到当前最新版本，也是v0.8.1</p><p>莫非不是版本问题？再对比本地镜像和线上镜像的DIGEST，发现它们是不同的。看来是修复bug后，使用了原来的镜像tag。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect kubesphere/kubefed:v0.8.1 | grep -i <span class="built_in">id</span></span><br></pre></td></tr></table></figure><p>3、缩容kubefed controller</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=0 deployment.apps/kubefed-controller-manager -n kube-federation-system</span><br></pre></td></tr></table></figure><p>4、删除宿主机本地镜像&amp;拉取最新镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker rmi kubesphere/kubefed:v0.8.1 </span><br><span class="line">docker pull kubesphere/kubefed:v0.8.1</span><br></pre></td></tr></table></figure><p>5、重新拉起kubefed controller</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale --replicas=1 deployment.apps/kubefed-controller-manager -n kube-federation-system</span><br></pre></td></tr></table></figure><p>问题依旧。。。</p><h1 id="废弃集群的问题？"><a href="#废弃集群的问题？" class="headerlink" title="废弃集群的问题？"></a>废弃集群的问题？</h1><p>再次查看kubefed-controller-manager的日志，感觉像是废弃集群引起的问题。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">E1104 08:10:15.107249       1 controller.go:512] failed to delete FederatedGlobalRoleBinding &quot;voidking01-platform-regular&quot;: the following clusters were not ready: vk-dev, edge-cluster</span><br><span class="line">I1104 08:10:15.702028       1 controller.go:471] Ensuring deletion of FederatedGlobalRoleBinding &quot;voidking01-platform-admin&quot;</span><br><span class="line">I1104 08:10:15.702064       1 controller.go:500] Deserializing delete options of FederatedGlobalRoleBinding &quot;voidking01-platform-admin&quot;</span><br><span class="line">I1104 08:10:15.702072       1 controller.go:508] Deleting resources managed by FederatedGlobalRoleBinding &quot;voidking01-platform-admin&quot; from member clusters.</span><br><span class="line">E1104 08:10:15.702117       1 controller.go:512] failed to delete FederatedGlobalRoleBinding &quot;voidking01-platform-admin&quot;: the following clusters were not ready: vk-dev, edge-cluster</span><br></pre></td></tr></table></figure><p>删除废弃的集群后（未就绪的集群），问题解决。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h1&gt;&lt;p&gt;大部分用户能够正常登录和使用ks，但是个别用户（voidking01）登录ks后报错。&lt;br&gt;用户登录ks，正常；登录后查看工作台，正常；查看host集群和只包含host集群的企业空间，正常。&lt;/p&gt;
&lt;p&gt;但是，选择一个非host集群或者选择一个包含非host集群的企业空间后，页面就会弹出错误提示：&lt;br&gt;Session timeout or this account is logged in elsewhere, please login again&lt;/p&gt;
&lt;p&gt;然后转到登录页面，再次登录，继续弹出上面的错误提示。循环往复。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    <category term="storage" scheme="https://www.voidking.com/categories/engineering/storage/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="存储" scheme="https://www.voidking.com/tags/%E5%AD%98%E5%82%A8/"/>
    
    <category term="kubesphere" scheme="https://www.voidking.com/tags/kubesphere/"/>
    
    <category term="storageclass" scheme="https://www.voidking.com/tags/storageclass/"/>
    
  </entry>
  
  <entry>
    <title>K8S集群中变更数据存储路径</title>
    <link href="https://www.voidking.com/dev-change-data-dir-in-k8s/"/>
    <id>https://www.voidking.com/dev-change-data-dir-in-k8s/</id>
    <published>2022-10-09T20:00:00.000Z</published>
    <updated>2023-05-20T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求描述"><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>docker的默认工作目录是<code>/var/lib/docker</code>，会存放镜像文件、容器日志和写入到容器临时目录的文件等，默认挂载在系统盘。</p><p>kubelet的默认工作目录是<code>/var/lib/kubelet</code>，会存放volume文件（包括emptyDir volume)、plugin文件等，也是默认挂载在系统盘。</p><p>使用kubeadm安装的etcd，默认数据目录是<code>/var/lib/etcd</code>，也是默认挂载在系统盘。</p><p>而系统盘一般都不会太大，因此最好把docker工作目录、kubelet工作目录和etcd数据目录更改到数据盘。</p><span id="more"></span><h1 id="操作思路"><a href="#操作思路" class="headerlink" title="操作思路"></a>操作思路</h1><p>节点分为两类，master节点（多个节点）和worker节点（多个节点）。</p><p>单个master节点操作流程：<br>1、master-x禁止调度、驱逐pod<br>2、master-x操作修改docker工作目录、kubelet工作目录<br>3、master-x开放调度<br>4、master-x操作修改etcd数据目录</p><p>单个worker节点操作流程：<br>1、worker-x禁止调度、驱逐pod<br>2、worker-x操作修改docker工作目录、kubelet工作目录<br>3、worker-x开放调度</p><p>master节点挨个操作，worker节点挨个操作或者分批操作。</p><h1 id="master节点操作"><a href="#master节点操作" class="headerlink" title="master节点操作"></a>master节点操作</h1><p>以master-0为例，方便进行描述。</p><h2 id="禁止调度-amp-驱逐pod"><a href="#禁止调度-amp-驱逐pod" class="headerlink" title="禁止调度&amp;驱逐pod"></a>禁止调度&amp;驱逐pod</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain master-0 --ignore-daemonsets</span><br></pre></td></tr></table></figure><p>驱逐master-0节点上的pod，附带效果禁止调度。</p><h2 id="修改docker工作目录"><a href="#修改docker工作目录" class="headerlink" title="修改docker工作目录"></a>修改docker工作目录</h2><p>详情参考 <a href="https://www.voidking.com/dev-docker-data-root-dir/">《Docker修改工作目录》</a></p><h2 id="修改kubelet工作目录"><a href="#修改kubelet工作目录" class="headerlink" title="修改kubelet工作目录"></a>修改kubelet工作目录</h2><p>详情参考 <a href="https://www.voidking.com/dev-kubelet-root-dir/">《kubelet修改工作目录》</a></p><h2 id="开放调度"><a href="#开放调度" class="headerlink" title="开放调度"></a>开放调度</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl uncordon master-0</span><br></pre></td></tr></table></figure><h2 id="单个节点修改etcd数据目录"><a href="#单个节点修改etcd数据目录" class="headerlink" title="单个节点修改etcd数据目录"></a>单个节点修改etcd数据目录</h2><p>详情参考 <a href="https://www.voidking.com/dev-etcd-data-dir/">《etcd修改数据目录》</a></p><h1 id="worker节点操作"><a href="#worker节点操作" class="headerlink" title="worker节点操作"></a>worker节点操作</h1><p>以worker-0为例，方便进行描述。</p><h2 id="禁止调度-amp-驱逐pod-1"><a href="#禁止调度-amp-驱逐pod-1" class="headerlink" title="禁止调度&amp;驱逐pod"></a>禁止调度&amp;驱逐pod</h2><p><code>kubectl drain worker-0 --ignore-daemonsets</code></p><p>驱逐worker-0节点上的pod，附带效果禁止调度。</p><h2 id="修改docker工作目录-1"><a href="#修改docker工作目录-1" class="headerlink" title="修改docker工作目录"></a>修改docker工作目录</h2><p>详情参考 <a href="https://www.voidking.com/dev-docker-data-root/">《Docker修改工作目录》</a></p><h2 id="修改kubelet工作目录-1"><a href="#修改kubelet工作目录-1" class="headerlink" title="修改kubelet工作目录"></a>修改kubelet工作目录</h2><p>详情参考 <a href="https://www.voidking.com/dev-kubelet-root-dir/">《kubelet修改工作目录》</a></p><h2 id="开放调度-1"><a href="#开放调度-1" class="headerlink" title="开放调度"></a>开放调度</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl uncordon worker-0</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h1&gt;&lt;p&gt;docker的默认工作目录是&lt;code&gt;/var/lib/docker&lt;/code&gt;，会存放镜像文件、容器日志和写入到容器临时目录的文件等，默认挂载在系统盘。&lt;/p&gt;
&lt;p&gt;kubelet的默认工作目录是&lt;code&gt;/var/lib/kubelet&lt;/code&gt;，会存放volume文件（包括emptyDir volume)、plugin文件等，也是默认挂载在系统盘。&lt;/p&gt;
&lt;p&gt;使用kubeadm安装的etcd，默认数据目录是&lt;code&gt;/var/lib/etcd&lt;/code&gt;，也是默认挂载在系统盘。&lt;/p&gt;
&lt;p&gt;而系统盘一般都不会太大，因此最好把docker工作目录、kubelet工作目录和etcd数据目录更改到数据盘。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
</feed>
