<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好好学习的郝</title>
  
  <subtitle>一个计算机技术爱好者与学习者</subtitle>
  <link href="https://www.voidking.com/atom.xml" rel="self"/>
  
  <link href="https://www.voidking.com/"/>
  <updated>2024-05-04T08:00:00.000Z</updated>
  <id>https://www.voidking.com/</id>
  
  <author>
    <name>好好学习的郝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>好好学Docker：基于Docker buildx构建多平台镜像</title>
    <link href="https://www.voidking.com/dev-docker-buildx/"/>
    <id>https://www.voidking.com/dev-docker-buildx/</id>
    <published>2024-05-04T08:00:00.000Z</published>
    <updated>2024-05-04T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-buildx-是什么？"><span class="post-title-index">1. </span><a href="#Docker-buildx-是什么？" class="headerlink" title="Docker buildx 是什么？"></a>Docker buildx 是什么？</h1><p>Docker buildx 是 Docker 官方维护的一个 CLI 插件，它基于 BuildKit 引擎，提供了不同于 docker build 的更多功能，<br>buildx的一个关键特性是可以同时为不同的硬件架构构建并输出镜像，使得我们可以很容易地交叉构建镜像。比如，我们可以在 AMD64 的机器上构建 ARM64 架构的镜像，这对于软件的跨平台支持非常有用。</p><p>Docker buildx 支持的平台主要包括以下几种：</p><ul><li>Linux：包括多种 CPU 架构和操作系统，如 x86_64、ARM、IBM Power、IBM Z 等。</li><li>Windows：包括多种 CPU 架构和操作系统，如 x86_64、ARM64 等。</li><li>macOS：支持 Intel、Apple M1 架构。</li></ul><p>在本文中，我们将学习 Docker buildx 工具，并基于它构建多平台镜像。</p><p>参考文档：</p><ul><li><a href="https://github.com/docker/buildx">github - docker/buildx</a></li><li><a href="https://jimmysong.io/blog/docker-multi-platform-image-building/">Docker 多平台构建指南：构建 WebAssembly 镜像</a></li><li><a href="https://docs.docker.com/build/drivers/docker-container/">Docker container build driver</a></li><li><a href="https://blog.haohtml.com/archives/31052">利用 docker buildx 构建多平台镜像</a></li></ul><span id="more"></span><h1 id="Docker-buildx-builder是什么？"><span class="post-title-index">2. </span><a href="#Docker-buildx-builder是什么？" class="headerlink" title="Docker buildx builder是什么？"></a>Docker buildx builder是什么？</h1><p>单纯的 Docker builder，一般是指执行 Docker 镜像构建任务的一个实体或者进程。</p><p>在 Docker buildx 工具中，builder 指的是进行镜像构建的一个实例或环境。</p><p>builder 实例的特性：</p><ul><li>它可以被配置为支持跨多种平台的构建，如 <code>linux/amd64</code>、<code>linux/arm64</code> 等。</li><li>每个 builder 实例可以使用不同的驱动程序，Docker buildx 默认支持两种类型的驱动：<code>docker</code> 和 <code>docker-container</code>。</li><li>它允许我们定义构建环境的不同方面，比如资源限制、构建缓存存储位置等。</li><li>builder 实例可以是本地的，也可以被配置为分布式，由多个节点组成，以便分布式地执行构建任务。</li></ul><p>builder 实例常用命令：</p><ul><li><code>docker buildx ls</code>：查看 builer 实例列表</li><li><code>docker buildx inspect</code>：检查当前 builder 实例的详细信息，如果想查看特定的 builder，可以将其名称作为参数传入命令</li><li><code>docker buildx use</code>：切换到一个指定的 builder 实例，让后续的 <code>docker buildx</code> 命令使用该实例</li><li><code>docker buildx create</code>：创建新的 builder 实例</li><li><code>docker buildx update</code>：修改 builder 实例配置</li><li><code>docker buildx rm</code>：删除一个 builder 实例</li></ul><p>builder 常用配置：</p><ul><li>平台：指定 builder 可以为哪些操作系统和架构对组合来构建镜像。例如 <code>linux/amd64</code>、<code>linux/arm64</code>、<code>windows/amd64</code> 等。</li><li>环境变量：为 builder 实例设定环境变量，这些变量在构建过程中可用。</li><li>构建选项：例如构建缓存的位置、构建输出的位置、是否使用 BuildKit 功能等。</li><li>节点：在使用 <code>docker-container</code> 驱动时，我们可以添加多个节点，这些节点可以扩展 builder 的构建能力。</li><li>驱动选项：指定构建使用的驱动和配置，例如 <code>image</code> 驱动或者 <code>docker-container</code> 驱动的细节配置，包括使用的网络模式等。</li></ul><h1 id="配置-Docker-buildx-环境"><span class="post-title-index">3. </span><a href="#配置-Docker-buildx-环境" class="headerlink" title="配置 Docker buildx 环境"></a>配置 Docker buildx 环境</h1><p>1、确保 Docker 版本不低于 19.03，才能使用 buildx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure><p>2、检查 buildx 插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx version</span><br></pre></td></tr></table></figure><p>通过apt或者yum等包管理方式安装的Docker，默认是带有 buildx 插件的。</p><p>如果我们使用的 Docker 版本中没有包含 buildx，或者想要安装最新版本的 buildx，可以访问 <a href="https://github.com/docker/buildx">github - docker/buildx</a> 获取安装指南。</p><p>3、安装 buildx 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/docker/buildx/releases/download/v0.14.0/buildx-v0.14.0.linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> a+x buildx-v0.14.0.linux-amd64</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/libexec/docker/cli-plugins</span><br><span class="line"><span class="built_in">mv</span> buildx-v0.14.0.linux-amd64 /usr/libexec/docker/cli-plugins/docker-buildx</span><br></pre></td></tr></table></figure><p>更多系统适用的 buildx 版本，可以访问<a href="https://github.com/docker/buildx/releases">github - buildx releases</a>页面获取。</p><p>4、启用实验性功能<br>为了构建多平台镜像，需要确保 Docker 的实验性功能被启用，因为 buildx 依赖这些功能。<br>我们可以通过修改 Docker 配置文件（通常位于 <code>~/.docker/config.json</code>）来启用实验功能。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="string">&quot;enabled&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="支持多平台构建的-builder-实例"><span class="post-title-index">4. </span><a href="#支持多平台构建的-builder-实例" class="headerlink" title="支持多平台构建的 builder 实例"></a>支持多平台构建的 builder 实例</h1><p>buildx 有一个默认的 builder，但是这个builder不支持多平台构建。因此，我们需要创建一个支持多平台构建的 builder 实例。</p><p>1、查看 builder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>2、创建一个支持多平台构建的 builder 实例，并切换到新的builder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx create --name mybuilder --driver docker-container --use</span><br></pre></td></tr></table></figure><p>注意：使用docker-container driver才支持多平台构建。</p><p>3、查看 builder 详情并初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx inspect --bootstrap</span><br></pre></td></tr></table></figure><p>4、切换builder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker buildx use default</span><br><span class="line">docker buildx use mybuilder</span><br></pre></td></tr></table></figure><p>5、查看builder详情</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx inspect mybuilder</span><br></pre></td></tr></table></figure><h1 id="构建多平台的镜像"><span class="post-title-index">5. </span><a href="#构建多平台的镜像" class="headerlink" title="构建多平台的镜像"></a>构建多平台的镜像</h1><p>1、查看基础镜像的多平台镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx imagetools inspect busybox:1.34</span><br></pre></td></tr></table></figure><p>2、编写 Dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox:1.34</span><br></pre></td></tr></table></figure><p>3、构建多平台镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7  -t voidking/busybox:1.34 .</span><br></pre></td></tr></table></figure><p>出现警告：WARNING: No output specified with docker-container driver. Build result will only remain in the build cache. To push result image into registry use –push or to load image into docker use –load</p><p>这个命令将会为 amd64、arm64 和 arm/v7 架构构建镜像，但是，构建后的镜像通过 <code>docker images</code> 是看不到的，只会存在BuildKit 的构建缓存中，也就是说<code>-t</code>参数是无效的。</p><p>想要看到构建出的镜像，有两个办法：<br>方法一：使用<code>--push</code>参数直接上传到镜像仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7  -t voidking/busybox:1.34 --push .</span><br><span class="line">docker buildx imagetools inspect voidking/busybox:1.34</span><br></pre></td></tr></table></figure><p>方法二：使用<code>--load</code>参数，一次只构建一个平台的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/arm64  -t voidking/busybox:1.34 --load .</span><br><span class="line">docker inspect voidking/busybox:1.34</span><br></pre></td></tr></table></figure><h1 id="后记"><span class="post-title-index">6. </span><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>构建出的镜像，并不确保一定可用。可以使用像 QEMU 这样的模拟器，或者实际的硬件设备来测试构建的容器镜像。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-buildx-是什么？&quot;&gt;&lt;a href=&quot;#Docker-buildx-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Docker buildx 是什么？&quot;&gt;&lt;/a&gt;Docker buildx 是什么？&lt;/h1&gt;&lt;p&gt;Docker buildx 是 Docker 官方维护的一个 CLI 插件，它基于 BuildKit 引擎，提供了不同于 docker build 的更多功能，&lt;br&gt;buildx的一个关键特性是可以同时为不同的硬件架构构建并输出镜像，使得我们可以很容易地交叉构建镜像。比如，我们可以在 AMD64 的机器上构建 ARM64 架构的镜像，这对于软件的跨平台支持非常有用。&lt;/p&gt;
&lt;p&gt;Docker buildx 支持的平台主要包括以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux：包括多种 CPU 架构和操作系统，如 x86_64、ARM、IBM Power、IBM Z 等。&lt;/li&gt;
&lt;li&gt;Windows：包括多种 CPU 架构和操作系统，如 x86_64、ARM64 等。&lt;/li&gt;
&lt;li&gt;macOS：支持 Intel、Apple M1 架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本文中，我们将学习 Docker buildx 工具，并基于它构建多平台镜像。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/docker/buildx&quot;&gt;github - docker/buildx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jimmysong.io/blog/docker-multi-platform-image-building/&quot;&gt;Docker 多平台构建指南：构建 WebAssembly 镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/build/drivers/docker-container/&quot;&gt;Docker container build driver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.haohtml.com/archives/31052&quot;&gt;利用 docker buildx 构建多平台镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置WebIDE VSCode</title>
    <link href="https://www.voidking.com/dev-docker-webide-vscode/"/>
    <id>https://www.voidking.com/dev-docker-webide-vscode/</id>
    <published>2024-04-13T08:00:00.000Z</published>
    <updated>2024-04-13T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebIDE简介"><span class="post-title-index">1. </span><a href="#WebIDE简介" class="headerlink" title="WebIDE简介"></a>WebIDE简介</h1><p>WebIDE是一个现代化的开发工具，它可以让我们直接在浏览器中编写、运行和调试代码。不需要安装任何软件，只需要一个现代化的浏览器和网络连接就可以进行开发。这是一种全新的开发方式，并迅速得到了广大开发者的欢迎。</p><p>参考文档：</p><ul><li><a href="https://www.iceyao.com.cn/post/2023-03-09-webide_learning_note/">WebIDE技术方案调研</a></li><li><a href="https://xie.infoq.cn/article/46f422772132bfb9dd2a39100">2022 年最有前景的 5 个 Web IDE</a></li><li><a href="https://juejin.cn/post/7008428269317914661">如何在团队内快速落地WebIDE</a></li></ul><span id="more"></span><h1 id="主流WebIDE对比"><span class="post-title-index">2. </span><a href="#主流WebIDE对比" class="headerlink" title="主流WebIDE对比"></a>主流WebIDE对比</h1><h2 id="VSCode流派"><span class="post-title-index">2.1. </span><a href="#VSCode流派" class="headerlink" title="VSCode流派"></a>VSCode流派</h2><p>VSCode流派基于<a href="https://github.com/Microsoft/vscode">VSCode</a>，提供了通过浏览器访问VSCode IDE的功能。<br>支持VSCode插件，并提供了与VSCode相同的编辑器功能。</p><p>代表：<a href="https://github.com/features/codespaces">Codespaces</a>、<a href="https://github.com/coder/code-server">coder/code-server</a>、<a href="https://codesandbox.io/">CodeSandbox</a></p><h2 id="Projector流派"><span class="post-title-index">2.2. </span><a href="#Projector流派" class="headerlink" title="Projector流派"></a>Projector流派</h2><p>JetBrains Projector流派基于JetBrains，提供了通过浏览器远程访问JetBrains IDE的功能。<br>支持多个编程语言和多种插件，并提供了与JetBrains IDE相同的编辑器功能。</p><p>代表：<a href="https://github.com/JetBrains/projector-server">JetBrains Projector</a></p><h2 id="Theia流派"><span class="post-title-index">2.3. </span><a href="#Theia流派" class="headerlink" title="Theia流派"></a>Theia流派</h2><p>Theia流派基于Eclipse Theia，部分功能复用VSCode，但是在扩展能力上，远超VSCode。</p><p>代表：<a href="https://www.gitpod.io/">Gitpod</a>、阿里云OpenSumi、华为云CodeArtsIDE、Google云IDE</p><h2 id="StackBlitz"><span class="post-title-index">2.4. </span><a href="#StackBlitz" class="headerlink" title="StackBlitz"></a>StackBlitz</h2><p>StackBlitz是一款专为Web应用程序开发设计的WebIDE，适合前端开发。</p><h1 id="code-server工作原理"><span class="post-title-index">3. </span><a href="#code-server工作原理" class="headerlink" title="code-server工作原理"></a>code-server工作原理</h1><p>通过浏览器或者客户端连接远程的IDE（code-server），远程IDE负责执行，结果实时返回。如果产生数据，那么数据存储在远程磁盘上。<br>远程IDE可以运行在VM上，也可以运行在容器中。</p><h1 id="安装配置code-server"><span class="post-title-index">4. </span><a href="#安装配置code-server" class="headerlink" title="安装配置code-server"></a>安装配置code-server</h1><p>参考文档：<a href="https://coder.com/docs/code-server/latest/install#docker">Coder Docs - Install by Docker</a></p><p>1、安装code-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This will start a code-server container and expose it at http://127.0.0.1:8080.</span></span><br><span class="line"><span class="comment"># It will also mount your current directory into the container as `/home/coder/project`</span></span><br><span class="line"><span class="comment"># and forward your UID/GID so that all file system operations occur as your user outside</span></span><br><span class="line"><span class="comment"># the container.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Your $HOME/.config is mounted at $HOME/.config within the container to ensure you can</span></span><br><span class="line"><span class="comment"># easily access/modify your code-server config in $HOME/.config/code-server/config.json</span></span><br><span class="line"><span class="comment"># outside the container.</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.config</span><br><span class="line">docker run -it --name code-server -d \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -v <span class="string">&quot;<span class="variable">$HOME</span>/.local:/home/coder/.local&quot;</span> \</span><br><span class="line">  -v <span class="string">&quot;<span class="variable">$HOME</span>/.config:/home/coder/.config&quot;</span> \</span><br><span class="line">  -v <span class="string">&quot;<span class="variable">$PWD</span>:/home/coder/project&quot;</span> \</span><br><span class="line">  -u <span class="string">&quot;<span class="subst">$(id -u)</span>:<span class="subst">$(id -g)</span>&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;DOCKER_USER=<span class="variable">$USER</span>&quot;</span> \</span><br><span class="line">  codercom/code-server:latest</span><br></pre></td></tr></table></figure><p>2、查看code-server状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs code-server</span><br></pre></td></tr></table></figure><h1 id="使用code-server"><span class="post-title-index">5. </span><a href="#使用code-server" class="headerlink" title="使用code-server"></a>使用code-server</h1><p>1、浏览器访问code-server服务<br>假设主机IP为 192.168.50.101，那么浏览器访问 <a href="http://192.168.50.101:8080/login">http://192.168.50.101:8080/login</a></p><p>2、获取密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it code-server <span class="built_in">cat</span> /root/.config/code-server/config.yaml</span><br></pre></td></tr></table></figure><p>获取到密码后，在浏览器页面中输入密码，即可进入code-server。</p><p>3、使用code-server<br>使用方法和vscode基本没有差别。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;WebIDE简介&quot;&gt;&lt;a href=&quot;#WebIDE简介&quot; class=&quot;headerlink&quot; title=&quot;WebIDE简介&quot;&gt;&lt;/a&gt;WebIDE简介&lt;/h1&gt;&lt;p&gt;WebIDE是一个现代化的开发工具，它可以让我们直接在浏览器中编写、运行和调试代码。不需要安装任何软件，只需要一个现代化的浏览器和网络连接就可以进行开发。这是一种全新的开发方式，并迅速得到了广大开发者的欢迎。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.iceyao.com.cn/post/2023-03-09-webide_learning_note/&quot;&gt;WebIDE技术方案调研&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xie.infoq.cn/article/46f422772132bfb9dd2a39100&quot;&gt;2022 年最有前景的 5 个 Web IDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7008428269317914661&quot;&gt;如何在团队内快速落地WebIDE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="vscode" scheme="https://www.voidking.com/tags/vscode/"/>
    
    <category term="编辑器" scheme="https://www.voidking.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置Chrome</title>
    <link href="https://www.voidking.com/dev-docker-chrome/"/>
    <id>https://www.voidking.com/dev-docker-chrome/</id>
    <published>2024-04-06T08:00:00.000Z</published>
    <updated>2024-04-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Kasm Workspaces is a docker container streaming platform for delivering browser-based access to desktops, applications, and web services.</p></blockquote><p>Kasm Workspaces是一个Docker容器流媒体平台，用于提供基于浏览器的访问桌面、应用程序和Web服务。</p><p>Kasm Workspaces提供了一个可通过浏览器访问的 Google Chrome 版本。本文中，我们就来部署一下这个Docker Chrome。</p><p>参考文档：</p><ul><li><a href="https://hub.docker.com/r/kasmweb/chrome">dockerhub - kasmweb/chrome</a></li></ul><span id="more"></span><h1 id="安装Docker-Chrome"><span class="post-title-index">2. </span><a href="#安装Docker-Chrome" class="headerlink" title="安装Docker Chrome"></a>安装Docker Chrome</h1><p>1、安装Docker Chrome</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --name chrome -d \</span><br><span class="line">  --restart always \</span><br><span class="line">  --shm-size=1024m \</span><br><span class="line">  -p 6901:6901 \</span><br><span class="line">  -e VNC_PW=password123 \</span><br><span class="line">  -e LANG=zh_CN.UTF-8 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -u root \</span><br><span class="line">  kasmweb/chrome:1.14.0</span><br></pre></td></tr></table></figure><p>2、查看运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep chrome</span><br><span class="line">docker logs chrome</span><br></pre></td></tr></table></figure><h1 id="使用Docker-Chrome"><span class="post-title-index">3. </span><a href="#使用Docker-Chrome" class="headerlink" title="使用Docker Chrome"></a>使用Docker Chrome</h1><p>1、浏览器访问Chrome<br>假设宿主机地址为 192.168.56.101 ，那么访问地址为：<a href="https://192.168.56.101:6901/">https://192.168.56.101:6901</a><br>注意是https，不是http。</p><p>2、登录KasmVNC<br>根据提示，输入用户名和密码，登录KasmVNC<br>用户名为 kasm_user ，密码为 password123</p><p>3、使用Chrome<br>和本地Chrome基本没有差别，使用起来很方便。</p><p>Please note that some functionality, such as audio, uploads, downloads, and microphone pass-through, is only available when using Kasm Workspaces for orchestration.</p><p>请注意，某些功能只有在使用Kasm工作区进行编排时才可用，比如音频、上传、下载和麦克风传递。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Kasm Workspaces is a docker container streaming platform for delivering browser-based access to desktops, applications, and web services.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kasm Workspaces是一个Docker容器流媒体平台，用于提供基于浏览器的访问桌面、应用程序和Web服务。&lt;/p&gt;
&lt;p&gt;Kasm Workspaces提供了一个可通过浏览器访问的 Google Chrome 版本。本文中，我们就来部署一下这个Docker Chrome。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://hub.docker.com/r/kasmweb/chrome&quot;&gt;dockerhub - kasmweb/chrome&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="centos" scheme="https://www.voidking.com/tags/centos/"/>
    
    <category term="dns" scheme="https://www.voidking.com/tags/dns/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Shell：Shell脚本问题记录</title>
    <link href="https://www.voidking.com/dev-shell-problem/"/>
    <id>https://www.voidking.com/dev-shell-problem/</id>
    <published>2024-04-06T08:00:00.000Z</published>
    <updated>2024-04-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录在编写Shell脚本时遇到的问题，备忘。</p><span id="more"></span><h1 id="Docker输出取值问题"><span class="post-title-index">2. </span><a href="#Docker输出取值问题" class="headerlink" title="Docker输出取值问题"></a>Docker输出取值问题</h1><h2 id="问题描述"><span class="post-title-index">2.1. </span><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">value=$(docker <span class="built_in">exec</span> -it <span class="built_in">test</span> <span class="built_in">echo</span> <span class="string">&#x27;&quot;10&quot;&#x27;</span>)</span><br><span class="line"><span class="comment"># echo &quot;$value&quot;</span></span><br><span class="line">value=<span class="variable">$&#123;value//\&quot;/&#125;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$value</span> =~ ^[0-9]+$ ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;running&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;failed&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这段代码的期望输出为 running，实际输出为 failed ，是为什么？<br>其中test容器是任意一个docker容器，比如busybox。</p><h2 id="问题排查解决"><span class="post-title-index">2.2. </span><a href="#问题排查解决" class="headerlink" title="问题排查解决"></a>问题排查解决</h2><p>在docker命令执行的结果中，可能包含一些看不见的控制字符。</p><p>排查方法：使用od命令查看不可见的控制字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$value</span>&quot;</span> | <span class="built_in">od</span> -c</span><br></pre></td></tr></table></figure><p>可以看到输出为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000000   &quot;   1   0   &quot;  \r  \n</span><br><span class="line">0000006</span><br></pre></td></tr></table></figure><p>由此可以发现控制字符为 <code>\r</code> 和 <code>\n</code>。</p><p>解决办法：进一步处理value变量，去除控制字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value=$(<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$value</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\r\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="扩展学习：od命令"><span class="post-title-index">2.3. </span><a href="#扩展学习：od命令" class="headerlink" title="扩展学习：od命令"></a>扩展学习：od命令</h2><p>od命令用于将指定文件内容以八进制、十进制、十六进制、浮点格式或ASCII编码字符方式显示。通常用于显示或查看文件中不能直接显示在终端的字符。od命令系统默认的显示方式是八进制，名称源于Octal Dump。</p><p>常见的文件为文本文件和二进制文件。od命令主要用来查看保存在二进制文件中的值，按照指定格式解释文件中的数据并输出，不管是IEEE754格式的浮点数还是ASCII码，od命令都能按照需求输出它们的值。</p><p><code>od -c</code>: same as -t c,  select printable characters or backslash escapes</p><h1 id="直接运行和定时任务运行结果不一致问题"><span class="post-title-index">3. </span><a href="#直接运行和定时任务运行结果不一致问题" class="headerlink" title="直接运行和定时任务运行结果不一致问题"></a>直接运行和定时任务运行结果不一致问题</h1><h2 id="问题描述-1"><span class="post-title-index">3.1. </span><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">value=$(docker <span class="built_in">exec</span> -it <span class="built_in">test</span> <span class="built_in">echo</span> <span class="string">&#x27;&quot;10&quot;&#x27;</span>)</span><br><span class="line">value=$(<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$value</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\r\n\&quot;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$value</span> =~ ^[0-9]+$ ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;running&quot;</span> | <span class="built_in">tee</span> -a /tmp/shell.log</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;failed&quot;</span> | <span class="built_in">tee</span> -a /tmp/shell.log</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>上面这段代码，直接运行时结果为 running ，contab运行结果为 failed ，表现不一致，为什么？</p><h2 id="问题排查解决-1"><span class="post-title-index">3.2. </span><a href="#问题排查解决-1" class="headerlink" title="问题排查解决"></a>问题排查解决</h2><p>经测试，发现 <code>docker exec -it test echo &#39;&quot;10&quot;&#39;</code> 命令中去掉 <code>-it</code> ，问题可以解决。</p><p>推测问题原因是cron作业不能添加交互式终端参数。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文记录在编写Shell脚本时遇到的问题，备忘。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="shell" scheme="https://www.voidking.com/categories/engineering/shell/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
    <category term="crontab" scheme="https://www.voidking.com/tags/crontab/"/>
    
    <category term="好好学Shell" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Shell/"/>
    
  </entry>
  
  <entry>
    <title>好好学K8S：kubectl增强工具和替代工具</title>
    <link href="https://www.voidking.com/dev-kubectl-enhancements-and-alternatives/"/>
    <id>https://www.voidking.com/dev-kubectl-enhancements-and-alternatives/</id>
    <published>2024-03-23T08:00:00.000Z</published>
    <updated>2024-03-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>kubectl 在 Kubernetes 环境中发挥了关键的管理作用，但随着 Kubernetes 的复杂性增加，管理者可能需要更直观、更便捷的工具。</p><p>本文介绍一些可替代或补充 kubectl 的工具，可以分为命令行工具、GUI工具、GUI平台三类。<br>其中命令行工具和GUI工具是指适合个人使用的Kubernetes管理工具，GUI平台是指适合多人同时使用的Kubernetes管理系统。</p><ul><li>命令行工具：kube-shell、k9s、stern</li><li>GUI工具：k8slens、octant</li><li>GUI平台：kubesphere、rancher</li></ul><span id="more"></span><h1 id="命令行工具"><span class="post-title-index">2. </span><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><h2 id="kube-shell"><span class="post-title-index">2.1. </span><a href="#kube-shell" class="headerlink" title="kube-shell"></a>kube-shell</h2><p><a href="https://github.com/cloudnativelabs/kube-shell">kube-shell</a> 是一个增强的 Kubernetes shell，基于kubectl，增加了自动完成、内联文档和其他有用的功能，使得在交互式环境中更友好地使用 Kubernetes。</p><h2 id="k9s"><span class="post-title-index">2.2. </span><a href="#k9s" class="headerlink" title="k9s"></a>k9s</h2><p><a href="https://github.com/derailed/k9s">k9s</a> 提供了一个终端 UI 界面，以交互的方式对 Kubernetes 集群进行操作。它的操作方式类似 vim，可以快速浏览各种资源、实时查看日志等。</p><p>Linux中安装方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/derailed/k9s/releases/download/v0.32.4/k9s_Linux_amd64.tar.gz</span><br><span class="line">tar -xzvf k9s_Linux_amd64.tar.gz k9s &amp;&amp; <span class="built_in">chmod</span> +x k9s &amp;&amp; <span class="built_in">mv</span> k9s /usr/bin </span><br></pre></td></tr></table></figure><p>使用k9s：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k9s <span class="comment"># 使用默认 kubeconfig</span></span><br><span class="line">k9s --context ~/.kube/config <span class="comment"># 指定 kubeconfig</span></span><br></pre></td></tr></table></figure><p>刚打开k9s界面，点击enter可能会提示 no connection to cached dial ，需要稍等一会再次点击enter。</p><p>使用方法参考文档：</p><ul><li><a href="https://rainfd.com/post/19_k9s%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/">K9s简易教程</a></li><li><a href="https://k9scli.io/topics/commands/">k9s - Commands</a></li></ul><h2 id="stern"><span class="post-title-index">2.3. </span><a href="#stern" class="headerlink" title="stern"></a>stern</h2><p><a href="https://github.com/stern/stern">stern</a> 是一个 Kubernetes 的日志跟踪工具，它可以同时跟踪一个或多个 pod 的日志，支持颜色高亮、自定义模板、自动刷新等功能。</p><h1 id="GUI工具"><span class="post-title-index">3. </span><a href="#GUI工具" class="headerlink" title="GUI工具"></a>GUI工具</h1><h2 id="k8slens"><span class="post-title-index">3.1. </span><a href="#k8slens" class="headerlink" title="k8slens"></a>k8slens</h2><p><a href="https://github.com/lensapp/lens">k8slens（Lens）</a> 是一个具有丰富功能的 Kubernetes IDE，它可以直接运行在桌面环境中，为用户提供直观的图形化界面对 Kubernetes 集群进行管理。</p><h2 id="octant"><span class="post-title-index">3.2. </span><a href="#octant" class="headerlink" title="octant"></a>octant</h2><p><a href="https://octant.dev/">Octant</a> 是由 VMware 开发的一款 Kubernetes 辅助工具，它提供了一个 Web 界面，可以帮助理解 Kubernetes 工作负载和集群，支持自定义插件，增强其功能。</p><p>目前已经停止维护。</p><h1 id="GUI平台"><span class="post-title-index">4. </span><a href="#GUI平台" class="headerlink" title="GUI平台"></a>GUI平台</h1><h2 id="kubesphere"><span class="post-title-index">4.1. </span><a href="#kubesphere" class="headerlink" title="kubesphere"></a>kubesphere</h2><p><a href="https://kubesphere.io/zh/">KubeSphere</a> 是一个以 Kubernetes 为基础的开源平台，提供更高级的多租户服务、更友好的 API 和 UI、应用市场、DevOps、微服务管理等功能。</p><h2 id="rancher"><span class="post-title-index">4.2. </span><a href="#rancher" class="headerlink" title="rancher"></a>rancher</h2><p><a href="https://www.rancher.com/">Rancher</a> 是一个全功能的 Kubernetes 管理平台，它可以在任何基础设施上运行 Kubernetes，同时提供集群管理、应用管理、监控、日志、CI/CD、网络、存储等功能。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;kubectl 在 Kubernetes 环境中发挥了关键的管理作用，但随着 Kubernetes 的复杂性增加，管理者可能需要更直观、更便捷的工具。&lt;/p&gt;
&lt;p&gt;本文介绍一些可替代或补充 kubectl 的工具，可以分为命令行工具、GUI工具、GUI平台三类。&lt;br&gt;其中命令行工具和GUI工具是指适合个人使用的Kubernetes管理工具，GUI平台是指适合多人同时使用的Kubernetes管理系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令行工具：kube-shell、k9s、stern&lt;/li&gt;
&lt;li&gt;GUI工具：k8slens、octant&lt;/li&gt;
&lt;li&gt;GUI平台：kubesphere、rancher&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="kubectl" scheme="https://www.voidking.com/tags/kubectl/"/>
    
    <category term="好好学K8S" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6K8S/"/>
    
  </entry>
  
  <entry>
    <title>好好学Linux：Linux中拷贝硬盘</title>
    <link href="https://www.voidking.com/dev-linux-copy-disk/"/>
    <id>https://www.voidking.com/dev-linux-copy-disk/</id>
    <published>2024-03-23T08:00:00.000Z</published>
    <updated>2024-03-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求描述"><span class="post-title-index">1. </span><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>Linux主机中原本有一块数据盘 /dev/sdb，挂载到了 /data 目录，存储了大量数据。<br>现在新增了一块数据盘 /dev/sdc，想要把sdb的数据完全拷贝到sdc，然后用sdb替换sdc，这个需求该怎样处理？</p><span id="more"></span><h1 id="实现思路"><span class="post-title-index">2. </span><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>1、把sdb的数据拷贝到sdc<br>2、检查sdc数据<br>3、修改挂载配置，sdc替换sdb，重启主机</p><h1 id="拷贝硬盘全部数据"><span class="post-title-index">3. </span><a href="#拷贝硬盘全部数据" class="headerlink" title="拷贝硬盘全部数据"></a>拷贝硬盘全部数据</h1><h2 id="拷贝硬盘全部数据概述"><span class="post-title-index">3.1. </span><a href="#拷贝硬盘全部数据概述" class="headerlink" title="拷贝硬盘全部数据概述"></a>拷贝硬盘全部数据概述</h2><p>拷贝硬盘全部数据，有三种方法：</p><ul><li>使用cp命令。不推荐，因为cp不能断点续传，所以拷贝大量文件时如果出错会浪费时间重传。</li><li>使用rsync命令。备选，支持断点续传，但是如果存在大量小文件时拷贝速度会很慢。</li><li>使用dd命令。首选，拷贝整个磁盘的数据，速度非常快且数据完整。</li></ul><p>因此，这里选择使用dd命令来拷贝磁盘数据。</p><h2 id="dd命令拷贝数据"><span class="post-title-index">3.2. </span><a href="#dd命令拷贝数据" class="headerlink" title="dd命令拷贝数据"></a>dd命令拷贝数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/dev/sdc bs=64K conv=noerror,<span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>if：input file，输入文件，这里就是要复制的源盘/dev/sdb。</li><li>of：output file，输出文件，这里就是要复制的目标盘/dev/sdc。</li><li>bs：block size，块大小，这里我们设置为64K。</li><li>conv：convert，转换选项，这里我们设置为noerror（读写出错不停止）和sync（输入输出不足块大小时，会用空字符补足）。</li></ul><p>dd命令默认的块大小是512字节，这意味着默认情况下，dd命令每次读取和写入的数据大小是512字节。如果我们的磁盘支持更大的块大小，那么增加块大小可以帮助提高数据复制的速度。在这个例子中，我们设定块大小为64K，这意味着dd命令每次读取和写入的数据大小是64K字节。</p><p>注意：在执行这个命令之前，确保/dev/sdc 没有被挂载并且没有其他程序正在使用。此外，这个操作可能会需要一些时间，需要耐心等待。</p><h2 id="查看dd进度"><span class="post-title-index">3.3. </span><a href="#查看dd进度" class="headerlink" title="查看dd进度"></a>查看dd进度</h2><p>dd命令在复制数据完成后会自动结束。有时候，dd命令可能会运行非常长的时间，此时可以通过向dd命令发送SIGUSR1信号来查看它当前的进度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -USR1 $(pgrep ^<span class="built_in">dd</span>)</span><br></pre></td></tr></table></figure><p>这条命令会找到dd命令的进程ID并向其发送SIGUSR1信号，这将导致dd命令打印出其当前的复制进度。</p><p>输出内容类似于：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6525616+0 records in</span><br><span class="line">6525616+0 records out</span><br><span class="line">427662770176 bytes (428 GB) copied, 3034.84 s, 141 MB/s</span><br></pre></td></tr></table></figure><p>这个输出中，6525616 指的是已经复制的块数量，块大小为64K（默认512），<code>6525616*64*1024 = 427662770176</code></p><h2 id="dd断点续传"><span class="post-title-index">3.4. </span><a href="#dd断点续传" class="headerlink" title="dd断点续传"></a>dd断点续传</h2><p>dd命令本身并不支持断点续传。如果执行 dd 命令过程中出现了中断，那么重新执行dd命令会从头开始复制，比较浪费时间。<br>但是，我们可以使用一些参数来模拟断点续传的功能。<br>skip 参数可以让 dd 在复制数据前跳过源文件/设备的一定数量的块，seek 参数可以让 dd 在开始写入数据前跳过目标文件/设备的一定数量的块。</p><p>假设我们确认已知的dd进度为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6525616+0 records in</span><br><span class="line">6525616+0 records out</span><br><span class="line">427662770176 bytes (428 GB) copied, 3034.84 s, 141 MB/s</span><br></pre></td></tr></table></figure><p>那么，断点续传可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/dev/sdc bs=64K skip=6525616 seek=6525616 conv=noerror,<span class="built_in">sync</span></span><br></pre></td></tr></table></figure><h2 id="修改UUID"><span class="post-title-index">3.5. </span><a href="#修改UUID" class="headerlink" title="修改UUID"></a>修改UUID</h2><p>使用dd拷贝一个设备到另一个设备，那么设备的UUID也被同时复制过去。这将导致两个设备拥有相同的UUID，这样在一些情况下可能会引发问题，比如在/boot/grub/grub.cfg文件或者/etc/fstab里面用UUID来标识设备。</p><p>要修改一个文件系统的UUID，需要使用对应文件系统的工具。</p><p>查看UUID命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid /dev/sdc</span><br></pre></td></tr></table></figure><p>对于ext2，ext3，ext4文件系统，可以使用tune2fs命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -U random /dev/sdc</span><br></pre></td></tr></table></figure><p>对于xfs文件系统，可以使用xfs_admin命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_admin -U generate /dev/sdc</span><br></pre></td></tr></table></figure><p>对于btrfs文件系统，可以使用btrfstune命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btrfstune -f -u /dev/sdc</span><br></pre></td></tr></table></figure><p>注意：上述所有命令在执行之前，需要先确保该设备已经被卸载。</p><h2 id="修改UUID报错问题"><span class="post-title-index">3.6. </span><a href="#修改UUID报错问题" class="headerlink" title="修改UUID报错问题"></a>修改UUID报错问题</h2><p>1、执行修改UUID的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_admin -U generate /dev/sdc</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ERROR: The filesystem has valuable metadata changes in a log which needs to</span><br><span class="line">be replayed.  Mount the filesystem to replay the log, and unmount it before</span><br><span class="line">re-running xfs_admin.  If you are unable to mount the filesystem, then use</span><br><span class="line">the xfs_repair -L option to destroy the log and attempt a repair.</span><br><span class="line">Note that destroying the log may cause corruption -- please attempt a mount</span><br><span class="line">of the filesystem before doing this.</span><br></pre></td></tr></table></figure><p>2、根据报错提示挂载磁盘，然后卸载磁盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /sdc</span><br><span class="line">mount /dev/sdc /sdc</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount: wrong fs type, bad option, bad superblock on /dev/sdc,</span><br><span class="line">       missing codepage or helper program, or other error</span><br><span class="line"></span><br><span class="line">       In some cases useful info is found in syslog - try</span><br><span class="line">       dmesg | tail or so.</span><br></pre></td></tr></table></figure><p>3、尝试修复磁盘问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_repair -L /dev/sdc</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Phase 1 - find and verify superblock...</span><br><span class="line">Phase 2 - using internal log</span><br><span class="line">        - zero log...</span><br><span class="line">...</span><br><span class="line">Phase 7 - verify and correct link counts...</span><br><span class="line">Maximum metadata LSN (12:673358) is ahead of log (1:2).</span><br><span class="line">Format log to cycle 15.</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>4、再次尝试修改UUID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_admin -U generate /dev/sdc</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Clearing log and setting UUID</span><br><span class="line">writing all SBs</span><br><span class="line">new UUID = 25b43fed-781f-419e-b5a9-273042c7f1e1</span><br></pre></td></tr></table></figure><p>5、尝试挂载和卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdc /sdc</span><br><span class="line"><span class="built_in">ls</span> -l /sdc</span><br><span class="line">umount /sdc</span><br></pre></td></tr></table></figure><h1 id="检查sdc数据（可选）"><span class="post-title-index">4. </span><a href="#检查sdc数据（可选）" class="headerlink" title="检查sdc数据（可选）"></a>检查sdc数据（可选）</h1><p>1、挂载 sdc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /sdc</span><br><span class="line">mount /dev/sdc /sdc</span><br></pre></td></tr></table></figure><p>2、比较数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -P -avz /data/ /sdc</span><br></pre></td></tr></table></figure><h1 id="修改挂载配置"><span class="post-title-index">5. </span><a href="#修改挂载配置" class="headerlink" title="修改挂载配置"></a>修改挂载配置</h1><p>1、查看 sdc UUID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid /dev/sdc</span><br></pre></td></tr></table></figure><p>2、修改 /etc/fstab 配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=xxx /data xfs  defaults 0 0</span><br></pre></td></tr></table></figure><p>其中 xxx 修改为 sdc 的 UUID</p><p>3、重启主机 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h1&gt;&lt;p&gt;Linux主机中原本有一块数据盘 /dev/sdb，挂载到了 /data 目录，存储了大量数据。&lt;br&gt;现在新增了一块数据盘 /dev/sdc，想要把sdb的数据完全拷贝到sdc，然后用sdb替换sdc，这个需求该怎样处理？&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="linux" scheme="https://www.voidking.com/categories/engineering/linux/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    <category term="storage" scheme="https://www.voidking.com/categories/engineering/storage/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
    <category term="好好学Linux" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Linux/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：Docker容器磁盘IO限速</title>
    <link href="https://www.voidking.com/dev-docker-container-blkio-limit/"/>
    <id>https://www.voidking.com/dev-docker-container-blkio-limit/</id>
    <published>2024-03-09T08:00:00.000Z</published>
    <updated>2024-03-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为避免Docker容器打满磁盘IO，有时需要对容器进行磁盘IO限速。</p><p>参考文档：</p><ul><li><a href="https://docs.docker.com/reference/cli/docker/container/run/">docker container run</a></li><li><a href="https://docs.docker.com/compose/compose-file/05-services/#blkio_config">Services top-level elements - blkio_config</a></li><li><a href="https://docs.docker.com/compose/compose-file/compose-file-v2/#blkio_config">Compose file version 2 reference - blkio_config</a></li><li><a href="https://blog.csdn.net/qq_34556414/article/details/121564025">容器磁盘限速：我的容器里磁盘读写为什么不稳定?</a></li></ul><span id="more"></span><h1 id="启动容器时限制容器磁盘IO"><span class="post-title-index">2. </span><a href="#启动容器时限制容器磁盘IO" class="headerlink" title="启动容器时限制容器磁盘IO"></a>启动容器时限制容器磁盘IO</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run --name <span class="built_in">test</span> -d \</span><br><span class="line">  --device-read-bps=/dev/sda:40mb \</span><br><span class="line">  --device-write-bps=/dev/sda:20mb \</span><br><span class="line">  --blkio-weight=500 \</span><br><span class="line">  busybox:latest <span class="built_in">tail</span> -f /dev/null</span><br></pre></td></tr></table></figure><p>上面的命令中，限制了容器读写 /dev/sda 的速度：</p><ul><li>读速度最高40MBps</li><li>写速度最高 20MBps</li><li>磁盘IO权重500（多个容器竞争IO时的相对权重，取值10到1000）</li></ul><p>注意1：device对应的宿主机的磁盘设备，例如 /dev/sda、/dev/sdb1<br>注意2：创建容器之后，无法通过 update 修改容器磁盘IO限制<br>注意3：宿主机内核版本在3.13以上才支持blkio cgroups；Docker存储驱动也需要支持blkio cgroups，比如overlay2</p><h1 id="Compose限制容器磁盘IO"><span class="post-title-index">3. </span><a href="#Compose限制容器磁盘IO" class="headerlink" title="Compose限制容器磁盘IO"></a>Compose限制容器磁盘IO</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&#x27;3.2&#x27;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">your-service:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">your-image:latest</span></span><br><span class="line">    <span class="attr">blkio_config:</span></span><br><span class="line">      <span class="attr">weight:</span> <span class="number">500</span></span><br><span class="line">      <span class="attr">device_read_bps:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/dev/sda</span></span><br><span class="line">          <span class="attr">rate:</span> <span class="string">40mb</span></span><br><span class="line">      <span class="attr">device_write_bps:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">path:</span> <span class="string">/dev/sda</span></span><br><span class="line">          <span class="attr">rate:</span> <span class="string">20mb</span></span><br></pre></td></tr></table></figure><h1 id="查看容器磁盘IO限制"><span class="post-title-index">4. </span><a href="#查看容器磁盘IO限制" class="headerlink" title="查看容器磁盘IO限制"></a>查看容器磁盘IO限制</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.HostConfig.BlkioDeviceReadBps&#125;&#125;&#x27;</span> &lt;container <span class="built_in">id</span>&gt;</span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.HostConfig.BlkioDeviceWriteBps&#125;&#125;&#x27;</span> &lt;container <span class="built_in">id</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为避免Docker容器打满磁盘IO，有时需要对容器进行磁盘IO限速。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/reference/cli/docker/container/run/&quot;&gt;docker container run&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/compose/compose-file/05-services/#blkio_config&quot;&gt;Services top-level elements - blkio_config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/compose/compose-file/compose-file-v2/#blkio_config&quot;&gt;Compose file version 2 reference - blkio_config&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34556414/article/details/121564025&quot;&gt;容器磁盘限速：我的容器里磁盘读写为什么不稳定?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="网络" scheme="https://www.voidking.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置AdGuard Home</title>
    <link href="https://www.voidking.com/dev-docker-adguardhome/"/>
    <id>https://www.voidking.com/dev-docker-adguardhome/</id>
    <published>2024-02-16T08:00:00.000Z</published>
    <updated>2024-02-24T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Adguard-Home简介"><span class="post-title-index">1. </span><a href="#Adguard-Home简介" class="headerlink" title="Adguard Home简介"></a>Adguard Home简介</h1><blockquote><p>Adguard Home: Free and open source, powerful network-wide ads &amp; trackers blocking DNS server.</p></blockquote><p>AdGuard Home 是一款免费开源的用于拦截广告和跟踪的DNS服务器，是 AdGuard DNS 的开源版本。</p><p>参考文档：</p><ul><li><a href="https://adguard.com/en/adguard-home/overview.html">AdGuard Home 主页</a></li><li><a href="https://github.com/AdguardTeam/AdguardHome">GitHub - AdguardTeam/AdguardHome</a></li><li><a href="https://hub.docker.com/r/adguard/adguardhome">DockerHub - adguard/adguardhome</a></li><li><a href="https://adguard-dns.io/zh_cn/welcome.html">AdGuard DNS 主页</a></li></ul><span id="more"></span><h1 id="安装AdGuard-Home"><span class="post-title-index">2. </span><a href="#安装AdGuard-Home" class="headerlink" title="安装AdGuard Home"></a>安装AdGuard Home</h1><p>1、下载 adguardhome 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull adguard/adguardhome:v0.107.44</span><br></pre></td></tr></table></figure><p>2、运行 adguardhome 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --name adguardhome\</span><br><span class="line">    --restart unless-stopped\</span><br><span class="line">    -v /opt/adguardhome/workdir:/opt/adguardhome/work\</span><br><span class="line">    -v /opt/adguardhome/confdir:/opt/adguardhome/conf\</span><br><span class="line">    -p 53:53/tcp -p 53:53/udp\</span><br><span class="line">    -p 67:67/udp -p 68:68/udp\</span><br><span class="line">    -p 80:80/tcp -p 443:443/tcp -p 443:443/udp -p 3000:3000/tcp\</span><br><span class="line">    -p 853:853/tcp\</span><br><span class="line">    -p 784:784/udp -p 853:853/udp -p 8853:8853/udp\</span><br><span class="line">    -p 5443:5443/tcp -p 5443:5443/udp\</span><br><span class="line">    -d adguard/adguardhome:v0.107.44</span><br></pre></td></tr></table></figure><p>端口说明：</p><ul><li><code>-p 53:53/tcp -p 53:53/udp</code>: plain DNS.</li><li><code>-p 67:67/udp -p 68:68/tcp -p 68:68/udp</code>: add if you intend to use AdGuard Home as a DHCP server.</li><li><code>-p 80:80/tcp -p 443:443/tcp -p 443:443/udp -p 3000:3000/tcp</code>: add if you are going to use AdGuard Home’s admin panel as well as run AdGuard Home as an <a href="https://github.com/AdguardTeam/AdGuardHome/wiki/Encryption">HTTPS/DNS-over-HTTPS</a> server.</li><li><code>-p 853:853/tcp</code>: add if you are going to run AdGuard Home as a <a href="https://github.com/AdguardTeam/AdGuardHome/wiki/Encryption">DNS-over-TLS</a> server.</li><li><code>-p 784:784/udp -p 853:853/udp -p 8853:8853/udp</code>: add if you are going to run AdGuard Home as a DNS-over-QUIC server. You may only leave one or two of these.</li><li><code>-p 5443:5443/tcp -p 5443:5443/udp</code>: add if you are going to run AdGuard Home as a <a href="https://github.com/AdguardTeam/AdGuardHome/wiki/DNSCrypt">DNSCrypt</a> server.</li></ul><p>简化版命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run --name adguardhome\</span><br><span class="line">    --restart unless-stopped\</span><br><span class="line">    -v /opt/adguardhome/workdir:/opt/adguardhome/work\</span><br><span class="line">    -v /opt/adguardhome/confdir:/opt/adguardhome/conf\</span><br><span class="line">    -p 53:53/tcp -p 53:53/udp\</span><br><span class="line">    -p 80:80/tcp -p 3000:3000/tcp\</span><br><span class="line">    -d adguard/adguardhome:v0.107.44</span><br></pre></td></tr></table></figure><p>3、查看运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep adguardhome</span><br><span class="line">docker logs adguardhome</span><br></pre></td></tr></table></figure><h1 id="配置使用AdGuard-Home"><span class="post-title-index">3. </span><a href="#配置使用AdGuard-Home" class="headerlink" title="配置使用AdGuard Home"></a>配置使用AdGuard Home</h1><h2 id="初始化配置"><span class="post-title-index">3.1. </span><a href="#初始化配置" class="headerlink" title="初始化配置"></a>初始化配置</h2><p>1、访问网页配置界面<br>假设宿主机IP为 192.168.56.101 ，那么 网页配置界面 为：<a href="http://192.168.56.101:3000/">http://192.168.56.101:3000/</a></p><p>2、初始化配置<br>第一次登录时，AdGuard Home会引导我们对 网页管理界面 进行初始化配置。<br>初始化配置完成之后，网页配置界面就不能访问了。</p><p>配置数据会保存到 <code>/opt/adguardhome/confdir/AdGuardHome.yaml</code> 文件中。</p><p>3、访问网页管理界面<br>假设宿主机IP为 192.168.56.101 ，那么 网页管理界面 为：<a href="http://192.168.56.101/">http://192.168.56.101:80/</a><br><img src="https://cdn.adguard.com/public/Adguard/Common/adguard_home.gif"></p><h2 id="AdGuard-Home-DNS配置"><span class="post-title-index">3.2. </span><a href="#AdGuard-Home-DNS配置" class="headerlink" title="AdGuard Home DNS配置"></a>AdGuard Home DNS配置</h2><p>点击设置，点击DNS设置，按需配置DNS。</p><p>常用配置：</p><ul><li>上游 DNS 服务器</li><li>速率限制</li><li>DNS 缓存配置</li><li>允许的客户端</li><li>不允许的客户端</li><li>不允许的域名</li></ul><p>配置数据会保存到 <code>/opt/adguardhome/confdir/AdGuardHome.yaml</code> 文件中。</p><h2 id="过滤器配置"><span class="post-title-index">3.3. </span><a href="#过滤器配置" class="headerlink" title="过滤器配置"></a>过滤器配置</h2><h3 id="DNS黑名单"><span class="post-title-index">3.3.1. </span><a href="#DNS黑名单" class="headerlink" title="DNS黑名单"></a>DNS黑名单</h3><p>点击过滤器，点击DNS黑名单。</p><p>DNS黑名单，可以阻止访问特定域名。<br>默认黑名单列表为<a href="https://adguardteam.github.io/HostlistsRegistry/assets/filter_1.txt">AdGuard DNS filter</a>，可选的黑名单列表还有几十个。</p><h3 id="DNS重写"><span class="post-title-index">3.3.2. </span><a href="#DNS重写" class="headerlink" title="DNS重写"></a>DNS重写</h3><p>点击过滤器，点击DNS重写。</p><p>DNS重写，可以配置自定义域名解析。</p><h3 id="自定义过滤规则"><span class="post-title-index">3.3.3. </span><a href="#自定义过滤规则" class="headerlink" title="自定义过滤规则"></a>自定义过滤规则</h3><p>点击过滤器，点击自定义过滤规则。</p><p>自定义过滤规则，可以配置自定义域名解析，也可以阻止访问特定域名。</p><h2 id="客户机配置使用AdGuard-Home"><span class="post-title-index">3.4. </span><a href="#客户机配置使用AdGuard-Home" class="headerlink" title="客户机配置使用AdGuard Home"></a>客户机配置使用AdGuard Home</h2><p>假设宿主机IP为 192.168.56.101 ，那么 resolv.conf 配置为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameserver 192.168.56.101</span><br></pre></td></tr></table></figure><p>具体操作方法参考文档：<a href="https://www.voidking.com/dev-dns-start/">《DNS入门篇》</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Adguard-Home简介&quot;&gt;&lt;a href=&quot;#Adguard-Home简介&quot; class=&quot;headerlink&quot; title=&quot;Adguard Home简介&quot;&gt;&lt;/a&gt;Adguard Home简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Adguard Home: Free and open source, powerful network-wide ads &amp;amp; trackers blocking DNS server.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;AdGuard Home 是一款免费开源的用于拦截广告和跟踪的DNS服务器，是 AdGuard DNS 的开源版本。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://adguard.com/en/adguard-home/overview.html&quot;&gt;AdGuard Home 主页&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AdguardTeam/AdguardHome&quot;&gt;GitHub - AdguardTeam/AdguardHome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hub.docker.com/r/adguard/adguardhome&quot;&gt;DockerHub - adguard/adguardhome&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://adguard-dns.io/zh_cn/welcome.html&quot;&gt;AdGuard DNS 主页&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="centos" scheme="https://www.voidking.com/tags/centos/"/>
    
    <category term="dns" scheme="https://www.voidking.com/tags/dns/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学K8S：K8S中的Request和Limit</title>
    <link href="https://www.voidking.com/dev-k8s-request-limit/"/>
    <id>https://www.voidking.com/dev-k8s-request-limit/</id>
    <published>2024-01-27T08:00:00.000Z</published>
    <updated>2024-01-27T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Pod和容器的资源设置"><span class="post-title-index">1. </span><a href="#Pod和容器的资源设置" class="headerlink" title="Pod和容器的资源设置"></a>Pod和容器的资源设置</h1><p>当我们定义 Pod 时，可以选择性地为每个容器设定所需要的资源数量。最常见的可设定资源是 CPU 和内存（RAM）大小；此外还有其他类型的资源。</p><p>当我们为 Pod 中的 Container 指定了资源 request（请求） 时， kube-scheduler 就利用该信息决定将 Pod 调度到哪个节点上。<br>当我们为 Container 指定了资源 limit（限制） 时，kubelet 就可以确保运行的容器不会使用超出所设限制的资源。<br>kubelet 还会为容器预留所 request（请求） 数量的系统资源，供其使用。</p><p>参考文档：</p><ul><li><a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/">为 Pod 和容器管理资源</a></li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/policy/limit-range/">限制范围</a></li><li><a href="https://cloud.tencent.com/document/product/457/45634">设置 Request 与 Limit</a></li></ul><span id="more"></span><h1 id="K8S中的资源单位"><span class="post-title-index">2. </span><a href="#K8S中的资源单位" class="headerlink" title="K8S中的资源单位"></a>K8S中的资源单位</h1><h2 id="CPU资源单位"><span class="post-title-index">2.1. </span><a href="#CPU资源单位" class="headerlink" title="CPU资源单位"></a>CPU资源单位</h2><p>CPU 资源的限制和请求以 cpu 为单位。<br>在 Kubernetes 中，一个 CPU 等于 1 个物理 CPU 核 或者 1 个虚拟核， 取决于节点是一台物理主机还是运行在某物理主机上的虚拟机。</p><p>我们也可以表达带小数 CPU 的请求。 当我们定义一个容器，将其 <code>spec.containers[].resources.requests.cpu</code> 设置为 0.5 时， 我们所请求的 CPU 是我们请求 1.0 CPU 时的一半。 对于 CPU 资源单位，数量 表达式 0.1 等价于表达式 100m，可以看作 <code>100 millicpu</code>。 有些人说成是<code>一百毫核</code>，其实说的是同样的事情。</p><p>CPU 资源总是设置为资源的绝对数量而非相对数量值。 例如，无论容器运行在单核、双核或者 48-核的机器上，500m CPU 表示的是大约相同的计算能力。</p><h2 id="内存资源单位"><span class="post-title-index">2.2. </span><a href="#内存资源单位" class="headerlink" title="内存资源单位"></a>内存资源单位</h2><p>memory 的限制和请求以字节为单位。<br>我们可以使用普通的整数，或者带有以下 数量后缀 的定点数字来表示内存：E、P、T、G、M、k。<br>我们也可以使用对应的 2 的幂数：Ei、Pi、Ti、Gi、Mi、Ki。<br>例如，以下表达式所代表的是大致相同的值：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">128974848、129e6、129M、128974848000m、123Mi</span><br></pre></td></tr></table></figure><p>请注意后缀的大小写。如果我们请求 400m 临时存储，实际上所请求的是 0.4 字节。 如果有人这样设定资源请求或限制，可能他的实际想法是申请 400Mi 字节（400Mi） 或者 400M 字节。</p><h2 id="本地临时性存储单位"><span class="post-title-index">2.3. </span><a href="#本地临时性存储单位" class="headerlink" title="本地临时性存储单位"></a>本地临时性存储单位</h2><p>ephemeral-storage 本地临时性存储的单位和内存资源的单位相同。</p><p>本地临时性存储说明：<br>节点可以具有本地的临时性存储，由本地挂接的可写入设备或者有时也用 RAM 来提供支持。<br>临时（Ephemeral）意味着对所存储的数据不提供长期可用性的保证。</p><p>Pods 通常可以使用临时性本地存储来实现缓冲区、保存日志等功能。 kubelet 可以为使用本地临时存储的 Pods 提供这种存储空间，允许后者使用 emptyDir 类型的卷将其挂载到容器中。</p><p>kubelet 也使用此类存储来保存节点层面的容器日志、 容器镜像文件以及运行中容器的可写入层。</p><p>详情参考文档<a href="https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/#local-ephemeral-storage">本地临时存储</a></p><h2 id="GPU资源单位"><span class="post-title-index">2.4. </span><a href="#GPU资源单位" class="headerlink" title="GPU资源单位"></a>GPU资源单位</h2><p>K8S中，在调度使用GPU资源时，使用不同的 Kubernets Device Plugin，GPU单位也是不同的。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-k8s-gpu/">《K8S使用GPU》</a></li><li><a href="https://www.voidking.com/dev-k8s-gpumanager/">《K8S使用GPU Manager调度GPU》</a></li><li><a href="https://www.voidking.com/dev-k8s-gpushare/">《K8S使用GPU Share调度GPU》</a></li></ul><h1 id="容器资源设置示例"><span class="post-title-index">3. </span><a href="#容器资源设置示例" class="headerlink" title="容器资源设置示例"></a>容器资源设置示例</h1><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">app</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">images.my-company.example/app:v4</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">log-aggregator</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">images.my-company.example/log-aggregator:v6</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">requests:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;64Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;250m&quot;</span></span><br><span class="line">      <span class="attr">limits:</span></span><br><span class="line">        <span class="attr">memory:</span> <span class="string">&quot;128Mi&quot;</span></span><br><span class="line">        <span class="attr">cpu:</span> <span class="string">&quot;500m&quot;</span></span><br></pre></td></tr></table></figure><p>上面的 Pod 有两个容器。每个容器的请求为 0.25 CPU 和 64MiB（226 字节）内存， 每个容器的资源限制为 0.5 CPU 和 128MiB 内存。 我们可以认为该 Pod 的资源请求为 0.5 CPU 和 128 MiB 内存，资源限制为 1 CPU 和 256MiB 内存。</p><h1 id="设置Request和Limit默认值"><span class="post-title-index">4. </span><a href="#设置Request和Limit默认值" class="headerlink" title="设置Request和Limit默认值"></a>设置Request和Limit默认值</h1><p>可使用 LimitRange 来设置 namespace 的 request 与 limit 默认值，也可设定 request 与 limit 的最大值与最小值。示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">LimitRange</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cpu-resource-constraint</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">limits:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">default:</span> <span class="comment"># 此处定义默认限制值</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">    <span class="attr">defaultRequest:</span> <span class="comment"># 此处定义默认请求值</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">500m</span></span><br><span class="line">    <span class="attr">max:</span> <span class="comment"># max 和 min 定义限制范围</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="attr">min:</span></span><br><span class="line">      <span class="attr">cpu:</span> <span class="string">100m</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">Container</span></span><br></pre></td></tr></table></figure><h1 id="怎样设置合理的Request和Limit？"><span class="post-title-index">5. </span><a href="#怎样设置合理的Request和Limit？" class="headerlink" title="怎样设置合理的Request和Limit？"></a>怎样设置合理的Request和Limit？</h1><h2 id="建议设置Request"><span class="post-title-index">5.1. </span><a href="#建议设置Request" class="headerlink" title="建议设置Request"></a>建议设置Request</h2><p>Request 的值并不代表给容器实际分配的资源大小，而是用于提供给调度器。调度器会检测每个节点可用于分配的资源（节点可分配资源 = 节点资源总额 - 已调度到节点上的 Pod 内容器 request 之和），同时记录每个节点已经被分配的资源（节点上所有 Pod 中定义的容器 request 之和）。如发现节点剩余的可分配资源已小于当前需被调度的 Pod 的 request，则该 Pod 就不会被调度到此节点。反之，则会被调度到此节点。  </p><p>如果不配置 request，调度器就无法感知节点资源使用情况，无法做出合理的调度决策，可能会造成调度不合理，引起节点状态混乱。建议给所有容器设置 request，使调度器可感知节点资源情况，以便做出合理的调度决策。集群的节点资源能够被合理的分配使用，避免因资源分配不均而导致发生故障。 </p><h2 id="重要应用Request等于Limit"><span class="post-title-index">5.2. </span><a href="#重要应用Request等于Limit" class="headerlink" title="重要应用Request等于Limit"></a>重要应用Request等于Limit</h2><p>在Kubernetes中，request和limit之间的差异决定了容器的QoS类别。</p><ul><li>如果 <code>request == limit</code>，则容器属于Guaranteed QoS类别。</li><li>如果 <code>request &lt; limit</code>，则容器属于Burstable QoS类别。</li><li>如果没有设置request和limit，则容器属于BestEffort QoS类别。</li></ul><p>不同的QoS类别有不同的调度和驱逐策略。<br>节点资源不足时，会触发自动驱逐和删除，优先删除BestEffort容器，其次是Burstable容器，最后是Guaranteed容器。<br>同时，request和limit之间的差值越大，Burstable类型的容器被驱逐的风险就越高。</p><p>对于生产环境中关键的服务，推荐设置 <code>request == limit</code> ，即Guaranteed QoS类别，以保证在节点故障时关键服务不易被驱逐导致线上业务受到影响。</p><h2 id="提高资源利用率"><span class="post-title-index">5.3. </span><a href="#提高资源利用率" class="headerlink" title="提高资源利用率"></a>提高资源利用率</h2><p>如果应用设置了较高的 request 值，而实际占用资源远小于设定值，会导致节点整体的资源利用率较低。除对时延非常敏感的业务外，敏感的业务本身并不期望节点利用率过高，影响网络包收发速度。<br>建议对非核心，并且资源非长期占用的应用，适当减少 request 以提高资源利用率。如果我们的服务支持水平扩容，那么除 CPU 密集型应用外，单副本的 request 值通常可设置为不大于1核。例如，coredns 设置为0.1核，即100m即可。  </p><h2 id="避免Request和Limit值过大"><span class="post-title-index">5.4. </span><a href="#避免Request和Limit值过大" class="headerlink" title="避免Request和Limit值过大"></a>避免Request和Limit值过大</h2><p>如果我们的服务使用单副本或少量副本，且 request 及 limit 的值设置过大，使服务可分配到足够多的资源去支撑业务。那么某个副本发生故障时，可能会给业务带来较大影响。<br>当 Pod 所在节点发生故障时，由于 request 值过大，且集群内资源分配的较为碎片化，其余节点无足够可分配资源满足该 Pod 的 request，那么该 Pod 无法实现漂移，无法自愈，会加重对业务的影响。<br>建议尽量减小 request 及 limit，通过增加副本的方式对我们的服务支撑能力进行水平扩容，使系统更加灵活可靠。 </p><h2 id="避免测试-namespace-消耗过多资源"><span class="post-title-index">5.5. </span><a href="#避免测试-namespace-消耗过多资源" class="headerlink" title="避免测试 namespace 消耗过多资源"></a>避免测试 namespace 消耗过多资源</h2><p>若生产集群有用于测试的 namespace，如不加以限制，则可能导致集群负载过高，影响生产业务。可以使用 ResourceQuota 限制测试 namespace 的 request 与 limit 的总大小。示例如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ResourceQuota</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">quota-test</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">hard:</span></span><br><span class="line">    <span class="attr">requests.cpu:</span> <span class="string">&quot;1&quot;</span></span><br><span class="line">    <span class="attr">requests.memory:</span> <span class="string">1Gi</span></span><br><span class="line">    <span class="attr">limits.cpu:</span> <span class="string">&quot;2&quot;</span></span><br><span class="line">    <span class="attr">limits.memory:</span> <span class="string">2Gi</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Pod和容器的资源设置&quot;&gt;&lt;a href=&quot;#Pod和容器的资源设置&quot; class=&quot;headerlink&quot; title=&quot;Pod和容器的资源设置&quot;&gt;&lt;/a&gt;Pod和容器的资源设置&lt;/h1&gt;&lt;p&gt;当我们定义 Pod 时，可以选择性地为每个容器设定所需要的资源数量。最常见的可设定资源是 CPU 和内存（RAM）大小；此外还有其他类型的资源。&lt;/p&gt;
&lt;p&gt;当我们为 Pod 中的 Container 指定了资源 request（请求） 时， kube-scheduler 就利用该信息决定将 Pod 调度到哪个节点上。&lt;br&gt;当我们为 Container 指定了资源 limit（限制） 时，kubelet 就可以确保运行的容器不会使用超出所设限制的资源。&lt;br&gt;kubelet 还会为容器预留所 request（请求） 数量的系统资源，供其使用。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/configuration/manage-resources-containers/&quot;&gt;为 Pod 和容器管理资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kubernetes.io/zh-cn/docs/concepts/policy/limit-range/&quot;&gt;限制范围&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/document/product/457/45634&quot;&gt;设置 Request 与 Limit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    <category term="architecture" scheme="https://www.voidking.com/categories/engineering/architecture/"/>
    
    
    <category term="架构" scheme="https://www.voidking.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="好好学K8S" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6K8S/"/>
    
  </entry>
  
  <entry>
    <title>好好学Linux：限制用户命令</title>
    <link href="https://www.voidking.com/dev-linux-limit-user-command/"/>
    <id>https://www.voidking.com/dev-linux-limit-user-command/</id>
    <published>2024-01-13T08:00:00.000Z</published>
    <updated>2024-01-13T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在Linux系统中，为了增强安全性，避免不适当的使用，有时需要限制特定用户或用户组的命令行访问。</p><p>常用的限制方法包括 profile限制、authorized_keys限制、<a href="https://www.gnu.org/software/bash/manual/html_node/The-Restricted-Shell.html">rbash</a>限制，本文我们就来学习一下这些方法。</p><p>参考文档：</p><ul><li><a href="https://sukbeta.github.io/linux-Restrict-user-command-method/">linux 限制用户命令方法</a></li><li><a href="https://kuanghy.github.io/2017/02/20/rbash">受限的 bash – rbash</a></li><li><a href="https://xz.aliyun.com/t/7642">rbash逃逸大全</a></li><li><a href="https://github.com/ghantoos/lshell">ghantoos/lshell</a></li><li><a href="https://www.voidking.com/dev-shell-sudo/">《shell命令之sudo》</a></li></ul><span id="more"></span><h1 id="profile限制"><span class="post-title-index">2. </span><a href="#profile限制" class="headerlink" title="profile限制"></a>profile限制</h1><p>当一个shell登录时，它将读取 <code>/etc/profile</code> 文件中的全部环境变量，然后再执行 <code>/etc/profile.d/</code> 目录中的所有 <code>.sh</code> 结尾的脚本。<br>因此，我们可以定义一个 <code>/etc/profile.d/login.sh</code> 脚本，用来限制用户的PATH，以此限制用户命令。</p><p>下面是一个 login.sh 示例，限制用户只能使用 ssh 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">user=`<span class="built_in">whoami</span>`</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$&#123;user&#125;</span>&quot;</span> != <span class="string">&quot;root&quot;</span> ];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> -e <span class="string">&quot;** \e[01;33m current user is: \e[01;31m <span class="variable">$LOGNAME</span>\e[00m  ** \e[00m&quot;</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="variable">$HOME</span>/bin</span><br><span class="line">    <span class="built_in">rm</span> -f <span class="variable">$HOME</span>/bin/*</span><br><span class="line">    <span class="built_in">ln</span> -s /usr/bin/ssh <span class="variable">$HOME</span>/bin/</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;PATH=$HOME/bin&#x27;</span> &gt; <span class="variable">$HOME</span>/.restricted_profile</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;export PATH&#x27;</span> &gt;&gt; <span class="variable">$HOME</span>/.restricted_profile</span><br><span class="line">    <span class="built_in">chown</span> <span class="variable">$&#123;user&#125;</span>:<span class="variable">$&#123;user&#125;</span> <span class="variable">$HOME</span>/.restricted_profile</span><br><span class="line">    <span class="built_in">exec</span> bash --restricted --noprofile --rcfile <span class="variable">$HOME</span>/.restricted_profile</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>但是，这种方法只能限制用户登录后的命令，如果用户远程执行命令，就限制不住了。<br>比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -t work@192.168.55.100 <span class="string">&quot;bash&quot;</span></span><br></pre></td></tr></table></figure><p>更多关于登录session和非登录session的内容，可以参考<a href="https://www.voidking.com/dev-bashprofile-bashrc/">《bash_profile和bashrc的区别》</a></p><h1 id="authorized-keys限制"><span class="post-title-index">3. </span><a href="#authorized-keys限制" class="headerlink" title="authorized_keys限制"></a>authorized_keys限制</h1><p>想要限制非登录session，一种可选的方案是使用 authorized_keys 。</p><p>1、authorized_keys 中配置 public key</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command=&quot;/usr/bin/ssh $SSH_ORIGINAL_COMMAND@tiger.voidking.com -p 2222&quot; ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC9...</span><br></pre></td></tr></table></figure><p>2、用户使用ssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -t work@192.168.55.100 <span class="string">&quot;haojin&quot;</span></span><br></pre></td></tr></table></figure><p>详情参考：<a href="https://www.voidking.com/dev-shell-ssh/">《shell命令之ssh》</a></p><h1 id="rbash限制"><span class="post-title-index">4. </span><a href="#rbash限制" class="headerlink" title="rbash限制"></a>rbash限制</h1><h2 id="rbash简介"><span class="post-title-index">4.1. </span><a href="#rbash简介" class="headerlink" title="rbash简介"></a>rbash简介</h2><p>rbash（restricted bash）是 bash 的一个版本，实际上 rbash 是 bash 的一个软连接，能够限制用户的命令。</p><p>具体限制包括：</p><ul><li>不能执行 cd 命令。只能在当前目录下工作，其它目录都无法进入。</li><li>不能修改 PATH、ENV、HOME、SHELL等环境变量的值。</li><li>不能执行包含 <code>/</code> 字符的程序。例如，我们无法执行 /usr/bin/uname 或 ./uname 命令或程序。但是，我们依然可以运行 uname 命令。也就是说，当前目录以外的程序或命令是无法被执行的。</li><li>不能使用 <code>&gt;</code> 和 <code>&gt;&gt;</code> 等重定向运算符进行重定向输出。</li><li>不能在脚本中或其它方式关闭 Restricted Shell 模式。</li><li>不能使用 set+r 或 set+o restricted 等方式退出 Restricted Shell 模式。</li></ul><h2 id="rbash限制只能执行ssh"><span class="post-title-index">4.2. </span><a href="#rbash限制只能执行ssh" class="headerlink" title="rbash限制只能执行ssh"></a>rbash限制只能执行ssh</h2><p>1、创建一个用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ls -s /bin/bash /bin/rbash</span></span><br><span class="line">useradd -s /bin/rbash -m ruser</span><br><span class="line"><span class="built_in">touch</span> /home/ruser/&#123;.bashrc,.bash_profile&#125;</span><br><span class="line"><span class="built_in">chown</span> -R root:ruser /home/ruser/&#123;.bashrc,.bash_profile&#125;</span><br><span class="line"><span class="built_in">chmod</span> 640 /home/ruser/&#123;.bashrc,.bash_profile&#125;</span><br><span class="line"><span class="built_in">mkdir</span> -p /home/ruser/bin</span><br></pre></td></tr></table></figure><p>2、限制用户只能执行ssh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=/home/ruser/bin&quot;</span> &gt;&gt; /home/ruser/.bash_profile</span><br><span class="line"><span class="built_in">ln</span> -s /usr/bin/ssh /home/ruser/bin/ssh</span><br></pre></td></tr></table></figure><p>但是，rbash有很多逃逸方法，比如一个简单的<code>bash</code>命令就可以逃逸，无论是session登录还是非session登录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -t work@192.168.55.100 <span class="string">&quot;bash&quot;</span></span><br></pre></td></tr></table></figure><h1 id="限制用户命令实战"><span class="post-title-index">5. </span><a href="#限制用户命令实战" class="headerlink" title="限制用户命令实战"></a>限制用户命令实战</h1><h2 id="需求描述"><span class="post-title-index">5.1. </span><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h2><ul><li>jumpserver只能内网使用，但是有少量外网用户也需要使用jumpserver。</li><li>为避免增加了风险，jumpserver不能放通到外网。</li></ul><h2 id="解决方案"><span class="post-title-index">5.2. </span><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>外网可以访问的主机A放通一个ssh命令用于登录，主机A可以连通到jumpserver主机。</p><h2 id="Step1：制作并运行ssh镜像"><span class="post-title-index">5.3. </span><a href="#Step1：制作并运行ssh镜像" class="headerlink" title="Step1：制作并运行ssh镜像"></a>Step1：制作并运行ssh镜像</h2><p>1、准备一个限制登录脚本 ssh.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;`date +%Y%m%d%H%M%S` ssh script was executed by key: <span class="variable">$SSH_KEY</span>&quot;</span> &gt;&gt; /opt/ssh.log</span><br><span class="line">ssh -o StrictHostKeyChecking=no -o HostKeyAlgorithms=+ssh-rsa <span class="variable">$SSH_ORIGINAL_COMMAND</span>@jump.voidking.com -p 2222</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> a+x ssh.sh</span><br></pre></td></tr></table></figure><p>2、定义 Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Using debian as base</span></span><br><span class="line"><span class="keyword">FROM</span> debian:bookworm-slim</span><br><span class="line"></span><br><span class="line"><span class="comment"># Maintainer</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> voidking <span class="string">&quot;voidking@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Update and install openssh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apt/sources.list.d/debian.sources</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    apt-get install -y --no-install-recommends openssh-server</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">cd</span> /etc/ssh &amp;&amp; ssh-keygen -A &amp;&amp; <span class="built_in">mkdir</span> -p /run/sshd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable SFTP and password login</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> sed -i <span class="string">&#x27;/sftp/c\Subsystem sftp /bin/false&#x27;</span> /etc/ssh/sshd_config &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    sed -i <span class="string">&#x27;/PasswordAuthentication/c\PasswordAuthentication no&#x27;</span> /etc/ssh/sshd_config &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">echo</span> <span class="string">&#x27;PermitUserEnvironment yes&#x27;</span> &gt;&gt; /etc/ssh/sshd_config</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ssh.sh /opt/ssh.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 777 -R /opt</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add new user</span></span><br><span class="line"><span class="comment"># RUN useradd -m work &amp;&amp; echo &quot;work:work123&quot; | chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> useradd -m work &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">mkdir</span> -p /home/work/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chown</span> work:work /home/work/.ssh &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">touch</span> /home/work/.ssh/authorized_keys &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chown</span> work:work /home/work/.ssh/authorized_keys &amp;&amp; \</span></span><br><span class="line"><span class="language-bash">    <span class="built_in">chmod</span> 600 /home/work/.ssh/authorized_keys</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the entry point</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;/usr/sbin/sshd&quot;</span>, <span class="string">&quot;-D&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>3、打包镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t voidking/ssh:debian-bookworm-slim .</span><br></pre></td></tr></table></figure><p>4、运行镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name ssh \</span><br><span class="line">    -p 10022:22 \</span><br><span class="line">    -v /etc/timezone:/etc/timezone:ro \</span><br><span class="line">    -v /etc/localtime:/etc/localtime:ro</span><br><span class="line">    voidking/ssh:debian-bookworm-slim</span><br></pre></td></tr></table></figure><h2 id="Step2：配置public-key"><span class="post-title-index">5.4. </span><a href="#Step2：配置public-key" class="headerlink" title="Step2：配置public key"></a>Step2：配置public key</h2><p>配置外部用户的 public key 到ssh容器中 work用户的authorized_keys，以使得外部用户有权限执行 command 中指定的 ssh.sh 脚本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it ssh /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;environment=&quot;SSH_KEY=haojin&quot;,command=&quot;/opt/ssh.sh $SSH_ORIGINAL_COMMAND&quot; ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC9...&#x27;</span> &gt;&gt; /home/work/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><h2 id="Step3：测试登录"><span class="post-title-index">5.5. </span><a href="#Step3：测试登录" class="headerlink" title="Step3：测试登录"></a>Step3：测试登录</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -t work@192.168.55.100 -p 10022 <span class="string">&quot;haojin&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在Linux系统中，为了增强安全性，避免不适当的使用，有时需要限制特定用户或用户组的命令行访问。&lt;/p&gt;
&lt;p&gt;常用的限制方法包括 profile限制、authorized_keys限制、&lt;a href=&quot;https://www.gnu.org/software/bash/manual/html_node/The-Restricted-Shell.html&quot;&gt;rbash&lt;/a&gt;限制，本文我们就来学习一下这些方法。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://sukbeta.github.io/linux-Restrict-user-command-method/&quot;&gt;linux 限制用户命令方法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://kuanghy.github.io/2017/02/20/rbash&quot;&gt;受限的 bash – rbash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xz.aliyun.com/t/7642&quot;&gt;rbash逃逸大全&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/ghantoos/lshell&quot;&gt;ghantoos/lshell&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-shell-sudo/&quot;&gt;《shell命令之sudo》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="shell" scheme="https://www.voidking.com/categories/engineering/shell/"/>
    
    <category term="linux" scheme="https://www.voidking.com/categories/engineering/linux/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
    <category term="好好学Linux" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Linux/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions实现PyPI发版</title>
    <link href="https://www.voidking.com/dev-github-actions-pypi-release/"/>
    <id>https://www.voidking.com/dev-github-actions-pypi-release/</id>
    <published>2024-01-06T08:00:00.000Z</published>
    <updated>2024-01-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文中，我们学习在GitHub Actions中实现PyPI发版。<br>具体来说，就是在GitHub Actions中实现打包Python软件包，并且上传软件包到 pypi.org 站点。</p><p>相关文档：</p><ul><li><a href="https://www.voidking.com/dev-python-pypi/">《Python软件仓库PyPI》</a></li><li><a href="https://www.voidking.com/dev-docker-pypi-server/">《使用Docker安装配置PyPI Server》</a></li></ul><span id="more"></span><h1 id="GitHub-Secret配置"><span class="post-title-index">2. </span><a href="#GitHub-Secret配置" class="headerlink" title="GitHub Secret配置"></a>GitHub Secret配置</h1><p>GitHub 项目仓库中，添加一个名为 <code>PYPI_API_TOKEN</code> 的 secret ，它的值是从 pypi.org 获取到的API TOKEN。<br>这个secret，使得 workflow 有权限向 pypi.org 上传Python软件包。</p><h1 id="GitHub-Actions"><span class="post-title-index">3. </span><a href="#GitHub-Actions" class="headerlink" title="GitHub Actions"></a>GitHub Actions</h1><p>新建一个workflow，例如 <code>.github/workflows/build-package.yaml</code></p><p>内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">upload</span> <span class="string">python</span> <span class="string">package</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">release:</span></span><br><span class="line">    <span class="attr">types:</span> [<span class="string">created</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">&#x27;3.9&#x27;</span></span><br><span class="line">        <span class="attr">cache:</span> <span class="string">&#x27;pip&#x27;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">        pip install -r requirements.txt</span></span><br><span class="line"><span class="string">        pip install -e.</span></span><br><span class="line"><span class="string">        pip install setuptools wheel twine</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">package</span> <span class="string">version</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        export VERSION=&quot;$&#123;GITHUB_REF#refs/tags/v&#125;&quot;</span></span><br><span class="line"><span class="string">        sed -i &quot;s/version=.*/version=\&quot;$&#123;VERSION&#125;\&quot;,/&quot; setup.py</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Build</span> <span class="string">and</span> <span class="string">publish</span></span><br><span class="line">      <span class="attr">env:</span></span><br><span class="line">        <span class="attr">TWINE_USERNAME:</span> <span class="string">__token__</span></span><br><span class="line">        <span class="attr">TWINE_PASSWORD:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.PYPI_API_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python setup.py bdist_wheel sdist</span></span><br><span class="line"><span class="string">        twine upload dist/*</span></span><br></pre></td></tr></table></figure><h1 id="使用方法示例"><span class="post-title-index">4. </span><a href="#使用方法示例" class="headerlink" title="使用方法示例"></a>使用方法示例</h1><p>1、打tag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git tag v0.6.4</span><br><span class="line">git push origin v0.6.4</span><br></pre></td></tr></table></figure><p>2、github发版<br>github项目页面，点击左侧的 <code>Releases</code>，点击<code>Draft a new release</code><br>选择tag，<code>Release title</code> 输入版本号 <code>v0.6.4</code>，点击 <code>Publish release</code></p><p>3、pypi自动发版<br>github发版后，会触发 workflow ，自动打包并发版到 pypi.org</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文中，我们学习在GitHub Actions中实现PyPI发版。&lt;br&gt;具体来说，就是在GitHub Actions中实现打包Python软件包，并且上传软件包到 pypi.org 站点。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-python-pypi/&quot;&gt;《Python软件仓库PyPI》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-docker-pypi-server/&quot;&gt;《使用Docker安装配置PyPI Server》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="github" scheme="https://www.voidking.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>MacOS安装配置Mermaid</title>
    <link href="https://www.voidking.com/dev-macos-mermaid/"/>
    <id>https://www.voidking.com/dev-macos-mermaid/</id>
    <published>2023-12-23T08:00:00.000Z</published>
    <updated>2024-03-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Mermaid简介"><span class="post-title-index">1. </span><a href="#Mermaid简介" class="headerlink" title="Mermaid简介"></a>Mermaid简介</h1><blockquote><p>Mermaid: JavaScript based diagramming and charting tool that renders Markdown-inspired text definitions to create and modify diagrams dynamically.</p></blockquote><p>参考文档：</p><ul><li><a href="https://mermaid.js.org/">Mermaid官网</a></li><li><a href="https://github.com/mermaid-js/mermaid">github - mermaid</a></li><li><a href="https://github.com/mermaid-js/mermaid-cli">github - mermaid-cli</a></li></ul><span id="more"></span><h1 id="Mermaid与Puppeteer"><span class="post-title-index">2. </span><a href="#Mermaid与Puppeteer" class="headerlink" title="Mermaid与Puppeteer"></a>Mermaid与Puppeteer</h1><p>Mermaid库本身并不依赖于Puppeteer，Mermaid可以直接在浏览器或其他Javascript环境下运行，通过Mermaid的API可以生成SVG格式的图表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/mermaid/dist/mermaid.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">mermaid.<span class="property">mermaidAPI</span>.<span class="title function_">initialize</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">startOnLoad</span>:<span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">&#125;);</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过这种方式使用Mermaid就不需要安装或配置Puppeteer或Chromium。</p><p>但是，Mermaid提供的命令行工具mermaid-cli（mmdc）是依赖Puppeteer的。<br>mermaid-cli使用Puppeteer（一个Node.js库）启动一个Chromium实例来渲染图表的SVG并将其保存为文件。</p><h1 id="安装Node"><span class="post-title-index">3. </span><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h1><p>1、安装nvm<br>nvm安装方法参考文档<a href="https://www.voidking.com/hobby-macos-settings/">《MacOS上软件配置》</a></p><p>2、安装v20版本node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nvm install v20.10.0</span><br></pre></td></tr></table></figure><p>node版本要大于v14，更低版本的node会报错 SyntaxError ，详情参考 <a href="https://github.com/mermaid-js/mermaid-cli/issues/572">Client does not start</a></p><p>3、使用v20版本node</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nvm use v20.10.0</span><br><span class="line">nvm <span class="built_in">alias</span> default v20.10.0</span><br><span class="line">nvm list</span><br></pre></td></tr></table></figure><h1 id="安装Mermaid"><span class="post-title-index">4. </span><a href="#安装Mermaid" class="headerlink" title="安装Mermaid"></a>安装Mermaid</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PUPPETEER_SKIP_DOWNLOAD=<span class="string">&quot;true&quot;</span> </span><br><span class="line">npm install -g @mermaid-js/mermaid-cli</span><br></pre></td></tr></table></figure><h1 id="安装Chromium（可选）"><span class="post-title-index">5. </span><a href="#安装Chromium（可选）" class="headerlink" title="安装Chromium（可选）"></a>安装Chromium（可选）</h1><p>1、下载<a href="https://download-chromium.appspot.com/">chromium</a></p><p>2、放置chromium到指定路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unzip chrome-mac.zip</span><br><span class="line"><span class="built_in">mv</span> chrome-mac <span class="variable">$HOME</span>/.cache/puppeteer/chrome</span><br></pre></td></tr></table></figure><h1 id="使用mmdc"><span class="post-title-index">6. </span><a href="#使用mmdc" class="headerlink" title="使用mmdc"></a>使用mmdc</h1><h2 id="mmdc简介"><span class="post-title-index">6.1. </span><a href="#mmdc简介" class="headerlink" title="mmdc简介"></a>mmdc简介</h2><p>mmdc是Mermaid CLI（命令行接口）的核心命令，用于把Mermaid图表代码转换为图像文件（如SVG、PNG、PDF）。</p><p>mmdc语法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmdc -i /path/to/input_file -o /path/to/output_file -p puppeteer-config.json</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>-i 参数后接输入文件路径，对应的是包含 Mermaid 代码的文件。</li><li>-o 参数后接输出文件路径，对应的是转换后的图像文件。</li><li>-p 参数用于指定Puppeteer配置文件的路径，Puppeteer是一个Node库，提供了控制Chromium、Chrome或Firefox的高级API。</li><li>-w 和 -H 控制浏览器视窗的尺寸（不是生成的图像的尺寸）</li><li>-t 参数用于指定主题样式，比如default、forest、neutral等。</li></ul><h2 id="mmdc使用示例"><span class="post-title-index">6.2. </span><a href="#mmdc使用示例" class="headerlink" title="mmdc使用示例"></a>mmdc使用示例</h2><p>1、创建 pupeteer 配置文件 puppeteer-config.json</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;executablePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Users/vk/.cache/puppeteer/chrome/chrome-mac/Chromium.app/Contents/MacOS/Chromium&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>如果使用Chrome的话，配置内容如下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;executablePath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>2、创建一个 mmd 文件 flowchart.mmd</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TD;</span><br><span class="line">    A--&gt;B;</span><br><span class="line">    A--&gt;C;</span><br><span class="line">    B--&gt;D;</span><br><span class="line">    C--&gt;D;</span><br></pre></td></tr></table></figure><p>3、生成图表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mmdc -i flowchart.mmd -o flowchart.png -p puppeteer-config.json</span><br></pre></td></tr></table></figure><h1 id="Python调用Mermaid"><span class="post-title-index">7. </span><a href="#Python调用Mermaid" class="headerlink" title="Python调用Mermaid"></a>Python调用Mermaid</h1><p>参考代码：<a href="https://github.com/geekan/MetaGPT/blob/main/metagpt/utils/mermaid.py">MetaGPT - metagpt/utils/mermaid.py</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Mermaid简介&quot;&gt;&lt;a href=&quot;#Mermaid简介&quot; class=&quot;headerlink&quot; title=&quot;Mermaid简介&quot;&gt;&lt;/a&gt;Mermaid简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Mermaid: JavaScript based diagramming and charting tool that renders Markdown-inspired text definitions to create and modify diagrams dynamically.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://mermaid.js.org/&quot;&gt;Mermaid官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mermaid-js/mermaid&quot;&gt;github - mermaid&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mermaid-js/mermaid-cli&quot;&gt;github - mermaid-cli&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="frontend" scheme="https://www.voidking.com/categories/engineering/frontend/"/>
    
    <category term="shell" scheme="https://www.voidking.com/categories/engineering/shell/"/>
    
    <category term="computer" scheme="https://www.voidking.com/categories/computer/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="macos" scheme="https://www.voidking.com/tags/macos/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
    <category term="mermaid" scheme="https://www.voidking.com/tags/mermaid/"/>
    
  </entry>
  
  <entry>
    <title>好好学Python：Python单元测试框架之pytest</title>
    <link href="https://www.voidking.com/dev-python-pytest/"/>
    <id>https://www.voidking.com/dev-python-pytest/</id>
    <published>2023-12-23T08:00:00.000Z</published>
    <updated>2023-12-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pytest简介"><span class="post-title-index">1. </span><a href="#pytest简介" class="headerlink" title="pytest简介"></a>pytest简介</h1><blockquote><p>The pytest framework makes it easy to write small, readable tests, and can scale to support complex functional testing for applications and libraries.</p></blockquote><p>pytest是一种卓越的Python测试框架，它提供了简单、高效的方式来编写可以扩展的测试用例。</p><p>本文学习pytest的测试用例写法，内容整理自 chatgpt gpt-4-0613 。</p><p>相关文档：</p><ul><li><a href="https://docs.pytest.org/en/7.4.x/">pytest官网</a></li><li><a href="https://www.voidking.com/dev-python-unittest/">《Python单元测试》</a></li></ul><span id="more"></span><h1 id="pytest基本测试"><span class="post-title-index">2. </span><a href="#pytest基本测试" class="headerlink" title="pytest基本测试"></a>pytest基本测试</h1><h2 id="准备一个模块"><span class="post-title-index">2.1. </span><a href="#准备一个模块" class="headerlink" title="准备一个模块"></a>准备一个模块</h2><p>准备一个mathlib模块，包含一个求和函数add()：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mathlib.py</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><h2 id="编写测试用例"><span class="post-title-index">2.2. </span><a href="#编写测试用例" class="headerlink" title="编写测试用例"></a>编写测试用例</h2><p>Python中编写测试用例，一种常见的方式是创建一个以<code>test_</code>为前缀的函数，这个函数应包含测试用例的名字和内部执行逻辑。</p><p>我们想要创建一个测试用例来检验 add 函数，我们可以创建一个 test_mathlib.py 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_mathlib.py</span></span><br><span class="line"><span class="keyword">import</span> mathlib</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_add</span>():</span><br><span class="line">    res = mathlib.add(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">assert</span> res == <span class="number">8</span></span><br></pre></td></tr></table></figure><h2 id="执行测试"><span class="post-title-index">2.3. </span><a href="#执行测试" class="headerlink" title="执行测试"></a>执行测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest test_mathlib.py</span><br></pre></td></tr></table></figure><h2 id="丰富测试用例"><span class="post-title-index">2.4. </span><a href="#丰富测试用例" class="headerlink" title="丰富测试用例"></a>丰富测试用例</h2><p>为了使测试更丰富，我们可以使用 <code>@pytest.mark.parametrize</code> 装饰器为函数参数提供多组值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test_mathlib.py</span></span><br><span class="line"><span class="keyword">import</span> mathlib</span><br><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.parametrize(<span class="params"><span class="string">&quot;a, b, expected&quot;</span>, [</span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params"><span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span></span>), </span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params"><span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span></span>), </span></span></span><br><span class="line"><span class="params"><span class="meta">    (<span class="params"><span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span></span>)</span></span></span><br><span class="line"><span class="params"><span class="meta">]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_add</span>(<span class="params">a, b, expected</span>):</span><br><span class="line">    res = mathlib.add(a, b)</span><br><span class="line">    <span class="keyword">assert</span> res == expected</span><br></pre></td></tr></table></figure><h1 id="pytest进阶测试"><span class="post-title-index">3. </span><a href="#pytest进阶测试" class="headerlink" title="pytest进阶测试"></a>pytest进阶测试</h1><h2 id="Fixture"><span class="post-title-index">3.1. </span><a href="#Fixture" class="headerlink" title="Fixture"></a>Fixture</h2><p>Fixture（预置） 是 pytest 提供的一种特殊的函数，它将测试前的准备工作和解除步骤打包成一个函数，以供测试用例调用。这样做可以提高测试的可重用性和代码的可读性。</p><p>例如，我们要为数据库相关的测试都创建一个测试数据库，并在测试结束后清理掉，可以写个fixture如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.fixture</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">db</span>():</span><br><span class="line">    db = setup_database()</span><br><span class="line">    <span class="keyword">yield</span> db</span><br><span class="line">    teardown_database(db)</span><br></pre></td></tr></table></figure><p>然后在测试函数中使用这个 db fixture：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_database</span>(<span class="params">db</span>):</span><br><span class="line">    <span class="comment"># Now you can interact with the db object, which is set up </span></span><br><span class="line">    <span class="comment"># at the beginning of the test and will be torn down at the end.</span></span><br></pre></td></tr></table></figure><h2 id="Mocking"><span class="post-title-index">3.2. </span><a href="#Mocking" class="headerlink" title="Mocking"></a>Mocking</h2><p>Mocking（模拟） 是一种强大的技术，它可以模拟我们在测试中所依赖的部分的行为。例如，我们的函数可能依赖于一个第三方服务或者数据库，在测试环境中，很可能无法启动这些服务。这时，就可以用 Mock 对象替代这些服务或者数据库。pytest 提供了 unittest.mock 作为内置的 mocking 框架。</p><p>下面是一个简单的 mocking 例子，假设我们有一个打印函数 <code>print_content()</code>，我们并不希望在测试的时候真的打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> unittest.mock <span class="keyword">import</span> MagicMock</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_print_content</span>():</span><br><span class="line">    print_content = MagicMock()</span><br><span class="line">    print_content(<span class="string">&quot;hello&quot;</span>) </span><br><span class="line">    print_content.assert_called_with(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="Marker"><span class="post-title-index">3.3. </span><a href="#Marker" class="headerlink" title="Marker"></a>Marker</h2><p>在 pytest 中，Marker（标记）用于给测试用例添加元数据。比如最常见的 skip 和 xfail，它们会让 pytest 跳过或者期望失败的测试用例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.skip(<span class="params">reason=<span class="string">&quot;No way to test this&quot;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_the_unknown</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@pytest.mark.xfail</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_feature_x</span>():</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p><code>@pytest.mark.asyncio</code> 也是一个常用的内置装饰器，用于标记需要异步执行的函数。</p><p>Python3.5 版本引入了 async / await 关键字支持原生协程，它允许我们编写异步的代码，而不需要依赖于特定的包或者复杂的回调链。然而，pytest 是同步的，它不能原生支持 async / await 式的测试。这就是 pytest.mark.asyncio 装饰器的作用: 它让我们能够以同步的方式来测试异步的代码。</p><p>我们也可以自定义 marker。然后我们可以在运行 pytest 的时候指定参数 <code>-m</code> 来只运行有特定标记的测试用例，从而帮助我们更好地管理和运行我们的测试。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pytest.mark.my_marker</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_function</span>():</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># Run the test</span></span><br><span class="line">pytest -m my_marker</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;pytest简介&quot;&gt;&lt;a href=&quot;#pytest简介&quot; class=&quot;headerlink&quot; title=&quot;pytest简介&quot;&gt;&lt;/a&gt;pytest简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;The pytest framework makes it easy to write small, readable tests, and can scale to support complex functional testing for applications and libraries.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pytest是一种卓越的Python测试框架，它提供了简单、高效的方式来编写可以扩展的测试用例。&lt;/p&gt;
&lt;p&gt;本文学习pytest的测试用例写法，内容整理自 chatgpt gpt-4-0613 。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.pytest.org/en/7.4.x/&quot;&gt;pytest官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-python-unittest/&quot;&gt;《Python单元测试》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="testing" scheme="https://www.voidking.com/categories/engineering/testing/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="chatgpt" scheme="https://www.voidking.com/tags/chatgpt/"/>
    
    <category term="好好学Python" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Python/"/>
    
    <category term="测试" scheme="https://www.voidking.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>好好学Git：Git LFS</title>
    <link href="https://www.voidking.com/dev-git-lfs/"/>
    <id>https://www.voidking.com/dev-git-lfs/</id>
    <published>2023-12-16T08:00:00.000Z</published>
    <updated>2023-12-16T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git-LFS-简介"><span class="post-title-index">1. </span><a href="#Git-LFS-简介" class="headerlink" title="Git LFS 简介"></a>Git LFS 简介</h1><blockquote><p>Git LFS: An open source Git extension for versioning large files<br>Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.</p></blockquote><p>Git LFS (Large File Storage）是一个开源的Git大文件版本控制的解决方案和工具集，工具自身是基于Golang进行实现，并在Github上开源。原理上是通过对Git客户端进行扩展的方式，从而集成并兼容了原生的Git客户端。Git LFS良好的设计，让用户感觉在对大文件处理过程中，与普通Git的使用方式上没有任何差别，也就是说，在使用方式上Git LFS对用户是完全透明的。</p><p>参考文档：</p><ul><li><a href="https://git-lfs.com/">GIT Large File Storage</a></li><li><a href="https://github.com/git-lfs/git-lfs">github - git-lfs/git-lfs</a></li><li><a href="https://docs.github.com/zh/repositories/working-with-files/managing-large-files/about-git-large-file-storage">关于 Git Large File Storage</a></li><li><a href="https://help.aliyun.com/document_detail/206887.html">什么是Git LFS大文件存储?</a></li><li><a href="https://help.aliyun.com/document_detail/206889.html">如何使用 Git LFS</a></li></ul><span id="more"></span><h1 id="下载和安装Git-LFS"><span class="post-title-index">2. </span><a href="#下载和安装Git-LFS" class="headerlink" title="下载和安装Git LFS"></a>下载和安装Git LFS</h1><h2 id="官方脚本安装"><span class="post-title-index">2.1. </span><a href="#官方脚本安装" class="headerlink" title="官方脚本安装"></a>官方脚本安装</h2><p>1、下载适合系统的 <a href="https://github.com/git-lfs/git-lfs/releases">git-lfs/releases</a></p><p>2、解压安装<br>解压后，执行 <code>install.sh</code> 脚本，这个脚本会做两个事情：</p><ul><li>在<code>$PATH</code>中安装Git LFS的二进制可执行文件</li><li>执行<code>git lfs install</code>命令，让当前环境支持全局的LFS配置</li></ul><p>安装成功，会输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Git LFS initialized.</span><br></pre></td></tr></table></figure><h2 id="Linux"><span class="post-title-index">2.2. </span><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>参考文档：<a href="https://packagecloud.io/github/git-lfs/install">Git LFS - Installation instructions</a></p><p>Linux Debian：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s http://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure><p>RPM packages：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s http://packagecloud.io/install/repositories/github/git-lfs/script.rpm.sh | sudo bash</span><br></pre></td></tr></table></figure><h2 id="MacOS"><span class="post-title-index">2.3. </span><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install git-lfs</span><br></pre></td></tr></table></figure><h2 id="Windows"><span class="post-title-index">2.4. </span><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>目前lfs已经集成在了Git for Windows 中，直接下载和使用最新版本的Windows Git即可。</p><h1 id="让仓库支持Git-LFS"><span class="post-title-index">3. </span><a href="#让仓库支持Git-LFS" class="headerlink" title="让仓库支持Git LFS"></a>让仓库支持Git LFS</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure><p>如果官方脚本安装，那么不需要执行这条命令。</p><h1 id="使用Git-LFS"><span class="post-title-index">4. </span><a href="#使用Git-LFS" class="headerlink" title="使用Git LFS"></a>使用Git LFS</h1><p>1、设置LFS追踪 mp4 类型的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs track <span class="string">&quot;*.mp4&quot;</span></span><br></pre></td></tr></table></figure><p>track 命令实际上是修改了仓库中的 <code>.gitattributes</code> 文件。</p><p>2、查看LFS追踪的文件类型</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git lfs track</span><br></pre></td></tr></table></figure><p>3、提交 <code>.gitattributes</code> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .gitattributes</span><br><span class="line">git commit -m <span class="string">&quot;Add LFS config&quot;</span></span><br></pre></td></tr></table></figure><p>4、放入一个 mp4 类型的文件到仓库中</p><p>5、提交并推送 mp4 类型文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add test.mp4</span><br><span class="line">git commit -m <span class="string">&quot;Add a bigfile&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>推送后，查看该mp4文件，会显示 Stored with Git LFS 。</p><p>注意：github中fork的仓库是不支持LFS上传大文件的，详情参考：<a href="https://github.com/git-lfs/git-lfs/issues/1906">can not upload new objects to public fork</a>。如果想要上传大文件，需要源仓库管理员授权push的权限。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Git-LFS-简介&quot;&gt;&lt;a href=&quot;#Git-LFS-简介&quot; class=&quot;headerlink&quot; title=&quot;Git LFS 简介&quot;&gt;&lt;/a&gt;Git LFS 简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Git LFS: An open source Git extension for versioning large files&lt;br&gt;Git Large File Storage (LFS) replaces large files such as audio samples, videos, datasets, and graphics with text pointers inside Git, while storing the file contents on a remote server like GitHub.com or GitHub Enterprise.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Git LFS (Large File Storage）是一个开源的Git大文件版本控制的解决方案和工具集，工具自身是基于Golang进行实现，并在Github上开源。原理上是通过对Git客户端进行扩展的方式，从而集成并兼容了原生的Git客户端。Git LFS良好的设计，让用户感觉在对大文件处理过程中，与普通Git的使用方式上没有任何差别，也就是说，在使用方式上Git LFS对用户是完全透明的。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://git-lfs.com/&quot;&gt;GIT Large File Storage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/git-lfs/git-lfs&quot;&gt;github - git-lfs/git-lfs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/zh/repositories/working-with-files/managing-large-files/about-git-large-file-storage&quot;&gt;关于 Git Large File Storage&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/206887.html&quot;&gt;什么是Git LFS大文件存储?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://help.aliyun.com/document_detail/206889.html&quot;&gt;如何使用 Git LFS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="好好学Git" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Git/"/>
    
    <category term="github" scheme="https://www.voidking.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>好好学Git：Git pre-commit 代码质量检查</title>
    <link href="https://www.voidking.com/dev-git-pre-commit/"/>
    <id>https://www.voidking.com/dev-git-pre-commit/</id>
    <published>2023-12-16T08:00:00.000Z</published>
    <updated>2023-12-16T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pre-commit-简介"><span class="post-title-index">1. </span><a href="#pre-commit-简介" class="headerlink" title="pre-commit 简介"></a>pre-commit 简介</h1><p>Git 提供了一种称为钩子（hook）的特性，帮助我们在关键时刻自动执行自定义脚本。<br>其中，名为 <code>pre-commit</code> 的钩子会在每次 commit 之前运行，能够作为保障代码质量的工具。</p><span id="more"></span><h1 id="使用-pre-commit"><span class="post-title-index">2. </span><a href="#使用-pre-commit" class="headerlink" title="使用 pre-commit"></a>使用 pre-commit</h1><p>在项目的根目录下，找到 <code>.git/hooks</code> 文件夹，这个文件夹中存放的就是各种钩子脚本。</p><p>创建一个新文件命名为 pre-commit ，务必不要添加后缀，如 .sh 或 .py。</p><p>在 pre-commit 文件中，我们可以添加任何可以执行的脚本。<br>例如，如果我们针对 Python 的 .py 文件进行检查，则我们可能的 pre-commit 内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env bash</span></span><br><span class="line">FILES_PATTERN=<span class="string">&#x27;\.(py)(\..+)?$&#x27;</span></span><br><span class="line">FORBIDDEN=<span class="string">&#x27;pdb.set_trace()&#x27;</span></span><br><span class="line">git diff --cached --name-only | \</span><br><span class="line">    <span class="keyword">while</span> read FILE; do</span><br><span class="line">        <span class="keyword">if</span> [[ <span class="string">&quot;$&#123;FILE&#125;&quot;</span> =~ $&#123;FILES_PATTERN&#125; ]]; then</span><br><span class="line">            <span class="keyword">if</span> grep --quiet <span class="string">&quot;$&#123;FORBIDDEN&#125;&quot;</span> <span class="string">&quot;$&#123;FILE&#125;&quot;</span>; then</span><br><span class="line">                echo <span class="string">&quot;$&#123;FILE&#125; contains $&#123;FORBIDDEN&#125;&quot;</span></span><br><span class="line">                exit <span class="number">1</span></span><br><span class="line">            fi</span><br><span class="line">        fi</span><br><span class="line">    done || exit $?</span><br></pre></td></tr></table></figure><p>这个检查脚本的意思是，如果我们的 .py 文件中含有 pdb.set_trace()，那么拒绝该次 commit。</p><p>设置完后，我们需要使脚本具有执行权限，使用 <code>chmod +x .git/hooks/pre-commit</code> 命令即可。</p><p>之后，每一次的 git commit，在提交之前，都会执行我们定义好的 pre-commit 脚本，保证代码符合我们设置的规范，从而提升代码质量。</p><h1 id="pre-commit-框架"><span class="post-title-index">3. </span><a href="#pre-commit-框架" class="headerlink" title="pre-commit 框架"></a>pre-commit 框架</h1><p>当我们有大量项目时，pre-commit 脚本的管理维护就变成了一件痛苦的事情。<br>此时，就需要 pre-commit 框架出马了。pre-commit 框架是一个支持多语言的 pre-commit 脚本的管理器，能够简化我们的 pre-commit 脚本配置。<br>使用 pre-commit 框架时，在 <code>.pre-commit-config.yaml</code> 配置文件指定所需的linter列表（脚本列表），然后 pre-commit 框架会自动下载这些linter并运行。</p><p>需要特别说明的是：一些最好的 linter 可能是项目中不使用的语言编写的。例如 scss-lint 是一个用于检查SCSS的 linter，但是它是用Ruby编写的。而我们使用 pre-commit 框架时，完全不用关心 scss-lint 的安装配置，只要在linter列表中指定使用它即可。</p><p>参考文档：</p><ul><li><a href="https://pre-commit.com/">pre-commit 框架</a></li><li><a href="https://github.com/pre-commit/pre-commit">github - pre-commit/pre-commit</a></li><li><a href="https://www.voidking.com/dev-python-code-quality-check/">《Python代码质量检查》</a></li></ul><h1 id="安装-pre-commit-框架"><span class="post-title-index">4. </span><a href="#安装-pre-commit-框架" class="headerlink" title="安装 pre-commit 框架"></a>安装 pre-commit 框架</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pre-commit</span><br></pre></td></tr></table></figure><h1 id="使用-pre-commit-框架"><span class="post-title-index">5. </span><a href="#使用-pre-commit-框架" class="headerlink" title="使用 pre-commit 框架"></a>使用 pre-commit 框架</h1><p>1、创建 pre-commit 框架配置文件 <code>.pre-commit-config.yaml</code></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_stages:</span> [ <span class="string">commit</span> ]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install</span></span><br><span class="line"><span class="comment"># 1. pip install pre-commit</span></span><br><span class="line"><span class="comment"># 2. pre-commit install(the first time you download the repo, it will be cached for future use)</span></span><br><span class="line"><span class="attr">repos:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/pycqa/isort</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">5.11</span><span class="number">.5</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">isort</span></span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&#x27;--profile&#x27;</span>, <span class="string">&#x27;black&#x27;</span>]</span><br><span class="line">        <span class="attr">exclude:</span> <span class="string">&gt;-</span></span><br><span class="line"><span class="string">            (?x)^(</span></span><br><span class="line"><span class="string">            .*__init__\.py$</span></span><br><span class="line"><span class="string">            )</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/astral-sh/ruff-pre-commit</span></span><br><span class="line">    <span class="comment"># Ruff version.</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="string">v0.0.284</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">ruff</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">repo:</span> <span class="string">https://github.com/psf/black</span></span><br><span class="line">    <span class="attr">rev:</span> <span class="number">23.3</span><span class="number">.0</span></span><br><span class="line">    <span class="attr">hooks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">black</span></span><br><span class="line">        <span class="attr">args:</span> [<span class="string">&#x27;--line-length&#x27;</span>, <span class="string">&#x27;120&#x27;</span>]</span><br></pre></td></tr></table></figure><p>2、运行pre-commit框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pre-commit run --all-files</span><br></pre></td></tr></table></figure><p>3、配置commit前自动调用pre-commit框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF  &gt; .git/hooks/pre-commit</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">source $HOME/.bash_profile</span></span><br><span class="line"><span class="string">pre-commit run --all-files</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">chmod</span> a+x .git/hooks/pre-commit</span><br></pre></td></tr></table></figure><p>4、测试commit</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># modify something</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;something&quot;</span></span><br></pre></td></tr></table></figure><h1 id="github-配置使用-pre-commit-框架"><span class="post-title-index">6. </span><a href="#github-配置使用-pre-commit-框架" class="headerlink" title="github 配置使用 pre-commit 框架"></a>github 配置使用 pre-commit 框架</h1><p>github actions 中，也可以配置使用 pre-commit 框架，用于检查代码规范。</p><p>项目根目录中，新建 <code>.github/workflows/pre-commit.yaml</code>，内容为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Pre-commit</span> <span class="string">checks</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">          </span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">pre-commit-check:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">Source</span> <span class="string">Code</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">Python</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">&#x27;3.9.17&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">pre-commit</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">pip</span> <span class="string">install</span> <span class="string">pre-commit</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Initialize</span> <span class="string">pre-commit</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">pre-commit</span> <span class="string">install</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Run</span> <span class="string">pre-commit</span> <span class="string">hooks</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">pre-commit</span> <span class="string">run</span> <span class="string">--all-files</span></span><br></pre></td></tr></table></figure><p>提交到github，就OK了。</p><h1 id="扩展阅读：git-hooks"><span class="post-title-index">7. </span><a href="#扩展阅读：git-hooks" class="headerlink" title="扩展阅读：git hooks"></a>扩展阅读：git hooks</h1><p>Git钩子是一些在Git执行特定操作时触发的脚本，可以用于自定义和自动化工作流程，不同的Git钩子有不同的调用时间。</p><p>客户端钩子：</p><ul><li>pre-commit：在每次提交之前运行。</li><li>pre-push：在git push之前运行。</li><li>post-commit：在每次提交之后运行。</li><li>post-checkout：在切换分支或检出文件后运行。</li><li>post-merge：在合并操作完成后运行。</li></ul><p>服务器端钩子：</p><ul><li>pre-receive：在远程仓库接收到推送前运行。</li><li>update：在远程仓库接收到推送后，对每个要更新的引用（分支或标签）运行一次。</li><li>post-receive：在远程仓库接收到推送后，对所有要更新的引用运行一次。</li></ul><p>每个项目的<code>.git/hooks</code>的目录中，看到这些钩子的官方示例。<br>示例文件以<code>.sample</code>结尾，去掉<code>.sample</code>后缀可激活该钩子脚本。</p><p>参考文档：</p><ul><li><a href="https://git-scm.com/docs/githooks">githooks - Hooks used by Git</a></li><li><a href="https://pre-commit.com/">pre-commit</a></li><li><a href="https://amos-x.com/index.php/amos/archives/pre-commit/">Git项目管理，代码规范pre-commit使用详解</a></li><li><a href="https://zhuanlan.zhihu.com/p/65820736">用 pre-commit hook 解决 Python 项目编码规范</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;pre-commit-简介&quot;&gt;&lt;a href=&quot;#pre-commit-简介&quot; class=&quot;headerlink&quot; title=&quot;pre-commit 简介&quot;&gt;&lt;/a&gt;pre-commit 简介&lt;/h1&gt;&lt;p&gt;Git 提供了一种称为钩子（hook）的特性，帮助我们在关键时刻自动执行自定义脚本。&lt;br&gt;其中，名为 &lt;code&gt;pre-commit&lt;/code&gt; 的钩子会在每次 commit 之前运行，能够作为保障代码质量的工具。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    <category term="testing" scheme="https://www.voidking.com/categories/engineering/testing/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="好好学Git" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Git/"/>
    
    <category term="测试" scheme="https://www.voidking.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>GitHub Actions配置代码质量检查</title>
    <link href="https://www.voidking.com/dev-github-actions-code-quality-check/"/>
    <id>https://www.voidking.com/dev-github-actions-code-quality-check/</id>
    <published>2023-12-16T08:00:00.000Z</published>
    <updated>2024-01-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Gitlab CI中可以配置代码质量检查，同样的，GitHub Actions中也可以配置代码质量检查。<br>本文中，我们学习在GitHub Actions中配置Python的编码规范检查和运行单元测试。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-gitlab-ci-code-quality-check/">《GitLab CI配置代码质量检查》</a></li><li><a href="https://docs.github.com/zh/actions/automating-builds-and-tests/building-and-testing-python">GitHub Actions - 构建和测试 Python</a></li><li><a href="https://juejin.cn/s/github%20python%20coverage%20badge">github python coverage badge</a></li></ul><span id="more"></span><h1 id="Python编码规范检查"><span class="post-title-index">2. </span><a href="#Python编码规范检查" class="headerlink" title="Python编码规范检查"></a>Python编码规范检查</h1><p>详情参考 <a href="https://www.voidking.com/dev-git-pre-commit/">《git pre-commit 代码质量检查》</a>。</p><h1 id="Python单元测试"><span class="post-title-index">3. </span><a href="#Python单元测试" class="headerlink" title="Python单元测试"></a>Python单元测试</h1><h2 id="Python通用单元测试"><span class="post-title-index">3.1. </span><a href="#Python通用单元测试" class="headerlink" title="Python通用单元测试"></a>Python通用单元测试</h2><p>使用多个Python版本运行单元测试。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Python</span> <span class="string">application</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">python-version:</span> [<span class="string">&#x27;3.9&#x27;</span>, <span class="string">&#x27;3.10&#x27;</span>, <span class="string">&#x27;3.11&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">        pip install -e.</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Test</span> <span class="string">with</span> <span class="string">pytest</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        pip install pytest</span></span><br><span class="line"><span class="string">        # export OPENAI_API_KEY=&quot;$&#123;&#123; secrets.OPENAI_API_KEY &#125;&#125;&quot; OPENAI_API_MODEL=&quot;gpt-3.5-turbo-1106&quot;</span></span><br><span class="line"><span class="string">        pytest tests/ --doctest-modules --junitxml=junit/test-results-$&#123;&#123; matrix.python-version &#125;&#125;.xml</span></span><br><span class="line"><span class="string"></span>      <span class="comment"># continue-on-error: true</span></span><br></pre></td></tr></table></figure><h2 id="单测并上传单测结果"><span class="post-title-index">3.2. </span><a href="#单测并上传单测结果" class="headerlink" title="单测并上传单测结果"></a>单测并上传单测结果</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Python</span> <span class="string">application</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">python-version:</span> [<span class="string">&#x27;3.9&#x27;</span>, <span class="string">&#x27;3.10&#x27;</span>, <span class="string">&#x27;3.11&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">        pip install -e.</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Test</span> <span class="string">with</span> <span class="string">pytest</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        pip install pytest</span></span><br><span class="line"><span class="string">        pytest tests/ --doctest-modules --junitxml=junit/test-results-$&#123;&#123; matrix.python-version &#125;&#125;.xml</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">pytest</span> <span class="string">test</span> <span class="string">results</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">pytest-results-$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">junit/test-results-$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;.xml</span></span><br><span class="line">        <span class="attr">retention-days:</span> <span class="number">3</span></span><br><span class="line">      <span class="comment"># Use always() to always run this step to publish test results when there are test failures</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">always()</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Python单元测试覆盖率"><span class="post-title-index">4. </span><a href="#Python单元测试覆盖率" class="headerlink" title="Python单元测试覆盖率"></a>Python单元测试覆盖率</h1><h2 id="生成单测覆盖率并展示"><span class="post-title-index">4.1. </span><a href="#生成单测覆盖率并展示" class="headerlink" title="生成单测覆盖率并展示"></a>生成单测覆盖率并展示</h2><p>1、安装单测依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pytest pytest-cov coverage-badge</span><br></pre></td></tr></table></figure><p>2、生成单测覆盖率结果文件 <code>.coverage</code> 和 html 格式报告</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytest tests/ --doctest-modules --cov=. --cov-report=html</span><br></pre></td></tr></table></figure><p>pytest参数说明：</p><ul><li><code>tests/</code> 指定测试文件的路径</li><li><code>--doctest-modules</code> 运行所有发现的doctest模块</li><li><code>--junitxml=junit/test-results.xml</code> 指定生成junitxml格式的测试报告</li><li><code>--cov=.</code> 生成单测覆盖率结果文件 <code>.coverage</code> 必须的参数，指定要收集哪些代码的覆盖率信息，<code>.</code> 表示收集当前目录下所有代码的覆盖率信息</li><li><code>--cov-report=html</code> 指定生成 html 格式的测试覆盖率报告，存到 htmlcov 目录中，等同于单独运行 <code>coverage html -i</code></li><li><code>--cov-report=xml</code> 指定生成 xml 格式的测试覆盖率报告，存储为 coverage.xml ，等同于单独运行 <code>coverage xml -i</code></li></ul><p>3、查看测试覆盖率</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coverage report -m</span><br></pre></td></tr></table></figure><p>4、生成badge svg</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">coverage-badge -o coverage.svg</span><br></pre></td></tr></table></figure><p>5、github README 引用 badge</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Coverage Status</span>](<span class="link">/path/to/coverage.svg</span>)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![Coverage Status</span>](<span class="link">/path/to/coverage.svg</span>)](<span class="link">https://your-badge-link</span>)</span><br></pre></td></tr></table></figure><h2 id="单测覆盖率整合到github-actions"><span class="post-title-index">4.2. </span><a href="#单测覆盖率整合到github-actions" class="headerlink" title="单测覆盖率整合到github actions"></a>单测覆盖率整合到github actions</h2><p>1、github actions配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Python</span> <span class="string">application</span> <span class="string">test</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line">  <span class="attr">push:</span> </span><br><span class="line">    <span class="attr">branches:</span> </span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">python-version:</span> [<span class="string">&#x27;3.9&#x27;</span>, <span class="string">&#x27;3.10&#x27;</span>, <span class="string">&#x27;3.11&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Set</span> <span class="string">up</span> <span class="string">Python</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/setup-python@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">python-version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">dependencies</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        python -m pip install --upgrade pip</span></span><br><span class="line"><span class="string">        pip install -e.</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Test</span> <span class="string">with</span> <span class="string">pytest</span></span><br><span class="line">      <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">        pip install pytest pytest-cov pytest-html coverage-badge</span></span><br><span class="line"><span class="string">        # export OPENAI_API_KEY=&quot;$&#123;&#123; secrets.OPENAI_API_KEY &#125;&#125;&quot; OPENAI_API_MODEL=&quot;gpt-3.5-turbo-1106&quot;</span></span><br><span class="line"><span class="string">        pytest tests/ --doctest-modules --junitxml=junit/test-results-$&#123;&#123; matrix.python-version &#125;&#125;.xml --cov=. --cov-report=xml:cov.xml --cov-report=html:htmlcov</span></span><br><span class="line"><span class="string">        coverage report -m</span></span><br><span class="line"><span class="string">        coverage-badge -o coverage.svg</span></span><br><span class="line"><span class="string">        # upload coverage.svg to a object storage</span></span><br><span class="line"><span class="string"></span>    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">pytest</span> <span class="string">test</span> <span class="string">results</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">actions/upload-artifact@v3</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">pytest-results-$&#123;&#123;</span> <span class="string">matrix.python-version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          ./junit/test-results-$&#123;&#123; matrix.python-version &#125;&#125;.xml</span></span><br><span class="line"><span class="string">          ./htmlcov/</span></span><br><span class="line"><span class="string"></span>        <span class="attr">retention-days:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">always()</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p>2、github README 引用 badge</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">Coverage Status</span>](<span class="link">https://object-storage-domain/path/to/coverage.svg</span>)</span><br></pre></td></tr></table></figure><h2 id="忽略指定目录"><span class="post-title-index">4.3. </span><a href="#忽略指定目录" class="headerlink" title="忽略指定目录"></a>忽略指定目录</h2><p>项目更目录中，创建 coverage 配置文件 <code>.coveragerc</code> </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[run]</span><br><span class="line">omit =</span><br><span class="line">    */tests/*</span><br><span class="line">    */migrations/*</span><br><span class="line">exclude_lines =</span><br><span class="line">    # 忽略异常抛出代码</span><br><span class="line">    raise NotImplementedError</span><br><span class="line">    # 忽略抽象基类中的函数定义</span><br><span class="line">    @abstractmethod</span><br><span class="line">    # 忽略带有pragma: no cover注释的行</span><br><span class="line">    pragma: no cover</span><br></pre></td></tr></table></figure><p>omit 用于指定不应该包含在覆盖率统计中的文件或目录，exclude_lines 用于指定不应该包含在覆盖率统计中的代码行。</p><h2 id="使用Codecov"><span class="post-title-index">4.4. </span><a href="#使用Codecov" class="headerlink" title="使用Codecov"></a>使用Codecov</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Upload</span> <span class="string">coverage</span> <span class="string">to</span> <span class="string">Codecov</span></span><br><span class="line">      <span class="attr">uses:</span> <span class="string">codecov/codecov-action@v2</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">token:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.CODECOV_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">file:</span> <span class="string">./cov.xml</span></span><br><span class="line">      <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">always()</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><h1 id="PR单测审批"><span class="post-title-index">5. </span><a href="#PR单测审批" class="headerlink" title="PR单测审批"></a>PR单测审批</h1><p>用户提交PR后，想要触发审批，配置是很简单的，例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&#x27;**&#x27;</span></span><br></pre></td></tr></table></figure><p>但是，如果我们在workflow中用到了secret，那配置就没有这么简单了。<br>因为github限制了<code>pull_request</code>触发的workflow读取secret的权限，所以副本仓库提交到主仓库的pr，读取不到主仓库secret。<br>这是一种对主仓库secret的保护，详情参考文档<a href="https://stackoverflow.com/questions/73866908/github-actions-main-repository-secret-not-picked-up-from-pull-request-build">github actions main repository secret not picked up from pull request build</a></p><p>如果确实需要让pr的workflow读取到secret，该怎么处理？<a href="https://securitylab.github.com/research/github-actions-preventing-pwn-requests/">Keeping your GitHub Actions and workflows secure Part 1: Preventing pwn requests</a> 这篇文章提供了两种方法可供参考。<br>方法一：pr事件触发workflow1，workflow1结束事件触发workflow2，此时workflow2就有权限读取secret了。但是，这种方法中，workflow1和workflow2之间缺少直观的关联，在pr页面和github actions页面上都看不出来联系，不友好。<br>方法二：使用 <code>pull_request_target</code> 代替 <code>pull_request</code> ，此时触发的workflow有权限读取secret。配置简单，页面也能直观看到，但是，这种方法降低了安全性。</p><p>方法一和方法二各有优劣，个人更推荐方法二，因为方法二可以配合<code>environment</code>加一道审批，增强安全性，弥补缺陷。<br>此外，使用 <code>pull_request_target</code> 时， <code>actions/checkout@v4</code> 默认切分支是切到 target 分支，想要测试pr分支，需要指定切分支到pr head。详情参考<a href="https://github.com/actions/checkout">Checkout V4</a></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">pull_request_target:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">environment:</span> <span class="string">unittest</span></span><br><span class="line">    <span class="attr">strategy:</span></span><br><span class="line">      <span class="attr">matrix:</span></span><br><span class="line">        <span class="attr">python-version:</span> [<span class="string">&#x27;3.9&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v4</span></span><br><span class="line">      <span class="attr">with:</span></span><br><span class="line">        <span class="attr">ref:</span> <span class="string">$&#123;&#123;</span> <span class="string">github.event.pull_request.head.sha</span> <span class="string">&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><code>pull_request</code> 和 <code>pull_request_target</code> 是有很大区别的，<a href="https://docs.github.com/en/actions/using-workflows/events-that-trigger-workflows#pull_request_target">Events that trigger workflows - pull_request_target</a> 文档中说：</p><blockquote><p>This event runs in the context of the base of the pull request, rather than in the context of the merge commit, as the pull_request event does. </p></blockquote><p>个人理解为：<code>pull_request</code> 的workflow是根据pr合并后的workflow yaml运行，而<code>pull_request_target</code> 的workflow是根据pr合并前的workflow yaml运行的，详情参考文档：<a href="https://stackoverflow.com/questions/74957218/what-is-the-difference-between-pull-request-and-pull-request-target-event-in-git">What is the difference between pull_request and pull_request_target event in GitHubActions</a></p><p>注意：如果一个pr中修改了 workflow ，那么在github actions页面看到的 workflow yaml 就是修改后的。但是如果是<code>pull_request_target</code> 事件触发的workflow，那么虽然看到了修改后的yaml，实际执行会按照修改前的yaml执行。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Gitlab CI中可以配置代码质量检查，同样的，GitHub Actions中也可以配置代码质量检查。&lt;br&gt;本文中，我们学习在GitHub Actions中配置Python的编码规范检查和运行单元测试。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-gitlab-ci-code-quality-check/&quot;&gt;《GitLab CI配置代码质量检查》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.github.com/zh/actions/automating-builds-and-tests/building-and-testing-python&quot;&gt;GitHub Actions - 构建和测试 Python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/s/github%20python%20coverage%20badge&quot;&gt;github python coverage badge&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="python" scheme="https://www.voidking.com/categories/engineering/python/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="git" scheme="https://www.voidking.com/categories/engineering/git/"/>
    
    <category term="testing" scheme="https://www.voidking.com/categories/engineering/testing/"/>
    
    
    <category term="python" scheme="https://www.voidking.com/tags/python/"/>
    
    <category term="git" scheme="https://www.voidking.com/tags/git/"/>
    
    <category term="github" scheme="https://www.voidking.com/tags/github/"/>
    
    <category term="测试" scheme="https://www.voidking.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置青龙面板</title>
    <link href="https://www.voidking.com/dev-docker-qinglong/"/>
    <id>https://www.voidking.com/dev-docker-qinglong/</id>
    <published>2023-12-09T08:00:00.000Z</published>
    <updated>2024-05-21T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="青龙面板简介"><span class="post-title-index">1. </span><a href="#青龙面板简介" class="headerlink" title="青龙面板简介"></a>青龙面板简介</h1><blockquote><p>青龙面板是一个支持 Python3、JavaScript、Shell、Typescript 的定时任务管理平台</p></blockquote><p>Linux自带的crontab可以配置定时任务，但是并不方便。而使用青龙面板，能够可视化配置定时任务，简单快捷。<br>本文中，我们学习一下青龙面板的安装配置，试一试签到薅羊毛。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-linux-crontab/">《Linux设置定时任务》</a></li><li><a href="https://github.com/whyour/qinglong">github - whyour/qinglong</a></li><li><a href="https://zhuanlan.zhihu.com/p/664671254">利用拾光坞开启青龙面板薅羊毛（保姆级教程）</a></li></ul><span id="more"></span><h1 id="安装青龙版面"><span class="post-title-index">2. </span><a href="#安装青龙版面" class="headerlink" title="安装青龙版面"></a>安装青龙版面</h1><p>1、下载<a href="https://hub.docker.com/r/whyour/qinglong">青龙面板Docker镜像</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull whyour/qinglong:debian</span><br></pre></td></tr></table></figure><p>2、启动青龙面板</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name qinglong -d \</span><br><span class="line">  -p 5700:5700 \</span><br><span class="line">  -v /opt/ql/data:/ql/data \</span><br><span class="line">  -e QlBaseUrl=<span class="string">&quot;/&quot;</span> \</span><br><span class="line">  -e QlPort=<span class="string">&quot;5700&quot;</span> \</span><br><span class="line">  --hostname qinglong \</span><br><span class="line">  --restart unless-stopped \</span><br><span class="line">  whyour/qinglong:debian</span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为qinglong，后台运行</li><li>映射宿主机5700端口到容器的5700</li><li>挂载宿主机文件 /opt/ql/data 到容器目录 /ql/data</li><li>设置环境变量 QlBaseUrl 和 QlPort，青龙面板服务启动时使用</li><li>设置容器主机名为 qinglong</li><li>设置容器随docker启动自动启动</li></ul><p>3、验证安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker logs qinglong</span><br></pre></td></tr></table></figure><p>4、登录进容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it qinglong /bin/bash</span><br></pre></td></tr></table></figure><p>5、web访问青龙面板<br>浏览器访问 <code>http:&lt;ip&gt;:5700</code><br>初次访问时，会提示进行初始化配置。</p><h1 id="内置命令"><span class="post-title-index">3. </span><a href="#内置命令" class="headerlink" title="内置命令"></a>内置命令</h1><h2 id="task"><span class="post-title-index">3.1. </span><a href="#task" class="headerlink" title="task"></a>task</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 依次执行，如果设置了随机延迟，将随机延迟一定秒数</span></span><br><span class="line">task &lt;file_path&gt;                                             </span><br><span class="line"><span class="comment"># 依次执行，无论是否设置了随机延迟，均立即运行，前台会输出日，同时记录在日志文件中</span></span><br><span class="line">task &lt;file_path&gt; now                                         </span><br><span class="line"><span class="comment"># 并发执行，无论是否设置了随机延迟，均立即运行，前台不产生日，直接记录在日志文件中，且可指定账号执行</span></span><br><span class="line">task &lt;file_path&gt; conc &lt;env_name&gt; &lt;account_number&gt;(可选的) </span><br><span class="line"><span class="comment"># 指定账号执行，无论是否设置了随机延迟，均立即运行 </span></span><br><span class="line">task &lt;file_path&gt; desi &lt;env_name&gt; &lt;account_number&gt;      </span><br><span class="line"><span class="comment"># 设置任务超时时间   </span></span><br><span class="line">task -m &lt;max_time&gt; &lt;file_path&gt;</span><br><span class="line"><span class="comment"># 使用 -- 分割，-- 后面的参数会传给脚本，下面的例子，脚本就可接收到参数 -u whyour -p password</span></span><br><span class="line">task &lt;file_path&gt; -- -u whyour -p password</span><br></pre></td></tr></table></figure><h2 id="ql"><span class="post-title-index">3.2. </span><a href="#ql" class="headerlink" title="ql"></a>ql</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新并重启青龙</span></span><br><span class="line">ql update</span><br><span class="line"><span class="comment"># 运行自定义脚本extra.sh</span></span><br><span class="line">ql extra</span><br><span class="line"><span class="comment"># 添加单个脚本文件</span></span><br><span class="line">ql raw &lt;file_url&gt;</span><br><span class="line"><span class="comment"># 添加单个仓库的指定脚本</span></span><br><span class="line">ql repo &lt;repo_url&gt; &lt;whitelist&gt; &lt;blacklist&gt; &lt;dependence&gt; &lt;branch&gt; &lt;extensions&gt;</span><br><span class="line"><span class="comment"># 删除旧日志</span></span><br><span class="line">ql rmlog &lt;days&gt;</span><br><span class="line"><span class="comment"># 启动tg-bot</span></span><br><span class="line">ql bot</span><br><span class="line"><span class="comment"># 检测青龙环境并修复</span></span><br><span class="line">ql check</span><br><span class="line"><span class="comment"># 重置登录错误次数</span></span><br><span class="line">ql resetlet                                                  </span><br><span class="line"><span class="comment"># 禁用两步登录</span></span><br><span class="line">ql resettfa</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>file_url: 脚本地址</li><li>repo_url: 仓库地址</li><li>whitelist: 拉取仓库时的白名单，即就是需要拉取的脚本的路径包含的字符串，多个竖线分割</li><li>blacklist: 拉取仓库时的黑名单，即就是需要拉取的脚本的路径不包含的字符串，多个竖线分割</li><li>dependence: 拉取仓库需要的依赖文件，会直接从仓库拷贝到scripts下的仓库目录，不受黑名单影响，多个竖线分割</li><li>extensions: 拉取仓库的文件后缀，多个竖线分割</li><li>branch: 拉取仓库的分支</li><li>days: 需要保留的日志的天数</li><li>file_path: 任务执行时的文件路径</li><li>env_name: 任务执行时需要并发或者指定时的环境变量名称</li><li>account_number: 任务执行时指定某个环境变量需要执行的账号序号</li><li>max_time: 超时时间，后缀”s”代表秒(默认值), “m”代表分, “h”代表小时, “d”代表天</li></ul><h1 id="配置青龙面板"><span class="post-title-index">4. </span><a href="#配置青龙面板" class="headerlink" title="配置青龙面板"></a>配置青龙面板</h1><h2 id="配置支持更多脚本类型"><span class="post-title-index">4.1. </span><a href="#配置支持更多脚本类型" class="headerlink" title="配置支持更多脚本类型"></a>配置支持更多脚本类型</h2><p>点击左侧配置文件，找到 <code>RepoFileExtensions=&quot;js py&quot;</code> ，修改为 <code>RepoFileExtensions=&quot;js py sh ts&quot;</code>，右上角保存。</p><p>点击左侧对比工具，对比修改前后的变化。</p><h2 id="安装脚本需要的依赖"><span class="post-title-index">4.2. </span><a href="#安装脚本需要的依赖" class="headerlink" title="安装脚本需要的依赖"></a>安装脚本需要的依赖</h2><p>点击左侧依赖管理，创建依赖，名称一栏中输入脚本可能需要的依赖，多个依赖换行输入，点击确定即可下载安装依赖。</p><h2 id="配置面板通知"><span class="post-title-index">4.3. </span><a href="#配置面板通知" class="headerlink" title="配置面板通知"></a>配置面板通知</h2><p>点击左侧通知设置，选择一个通知方式，根据提示填入必要的信息，保存。<br>建议使用飞书机器人，配置最简单：飞书群里新建一个自定义机器人，把webhook地址的最后一段粘贴到larkKey即可。</p><h2 id="配置脚本通知"><span class="post-title-index">4.4. </span><a href="#配置脚本通知" class="headerlink" title="配置脚本通知"></a>配置脚本通知</h2><p>青龙面板设置里的那个只是用来面板级别的通知，比如订阅更新。而脚本里的通知，需要在配置文件里去配置的。详情参考文档<a href="https://github.com/mrabit/aliyundriveDailyCheck/issues/141">如何设置任务执行完毕后发送通知</a></p><p>1、微信登录 <a href="https://sct.ftqq.com/sendkey">Server酱</a>，获取一个SendKey，测试通知</p><p>2、点击左侧配置文件，找到 <code>PUSH_KEY</code> ，填入上一步获取到的 SendKey，保存</p><h2 id="配置代理"><span class="post-title-index">4.5. </span><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>点击左侧环境变量，添加两个关于代理的环境变量。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http_proxy=http://192.168.5.233:20171</span><br><span class="line">https_proxy=http://192.168.5.233:20171</span><br></pre></td></tr></table></figure><p>之所以要配置代理，是因为很多订阅是从github拉取的，而github从国内访问是需要科学上网的，因此最好配置一下代理。<br>这两个代理变量，平时禁用，拉取订阅时启用。</p><h1 id="配置签到任务"><span class="post-title-index">5. </span><a href="#配置签到任务" class="headerlink" title="配置签到任务"></a>配置签到任务</h1><h2 id="阿里云盘签到（已废弃）"><span class="post-title-index">5.1. </span><a href="#阿里云盘签到（已废弃）" class="headerlink" title="阿里云盘签到（已废弃）"></a>阿里云盘签到（已废弃）</h2><p>参考文档：<a href="https://github.com/mrabit/aliyundriveDailyCheck">github - mrabit/aliyundriveDailyCheck</a></p><p>1、获取阿里云盘 refresh_token<br>web登录阿里云盘后，控制台粘贴</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">copy</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="property">token</span>).<span class="property">refresh_token</span>); <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="variable language_">localStorage</span>.<span class="property">token</span>).<span class="property">refresh_token</span>);</span><br></pre></td></tr></table></figure><p>2、青龙面板添加环境变量 refreshToken<br>如果有多个账号要签到，那就添加多个refreshToken。</p><p>3、安装js依赖</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br></pre></td></tr></table></figure><p>4、添加订阅</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ql repo https://github.com/mrabit/aliyundriveDailyCheck.git <span class="string">&quot;autoSignin&quot;</span> <span class="string">&quot;&quot;</span> <span class="string">&quot;qlApi&quot;</span></span><br></pre></td></tr></table></figure><p>添加订阅后，点击运行，即可从github拉取定时任务。拉取成功之后，建议禁用订阅。</p><p>5、配置定时任务<br>点击定时任务页面，找到 autoSignin.js 任务，点击运行，测试运行。<br>测试没有问题，编辑定时任务，设置一个合适的运行时间。</p><p>6、配置自动更新 refreshToken<br>系统设置，应用设置，创建一个应用 autoSignin（名称随意）。<br>autoSignin 应用的 CLIENT_ID 和 CLIENT_SECRET 配置到环境变量中。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;青龙面板简介&quot;&gt;&lt;a href=&quot;#青龙面板简介&quot; class=&quot;headerlink&quot; title=&quot;青龙面板简介&quot;&gt;&lt;/a&gt;青龙面板简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;青龙面板是一个支持 Python3、JavaScript、Shell、Typescript 的定时任务管理平台&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Linux自带的crontab可以配置定时任务，但是并不方便。而使用青龙面板，能够可视化配置定时任务，简单快捷。&lt;br&gt;本文中，我们学习一下青龙面板的安装配置，试一试签到薅羊毛。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-linux-crontab/&quot;&gt;《Linux设置定时任务》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/whyour/qinglong&quot;&gt;github - whyour/qinglong&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/664671254&quot;&gt;利用拾光坞开启青龙面板薅羊毛（保姆级教程）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>个人电脑作为Ubuntu服务器</title>
    <link href="https://www.voidking.com/dev-pc-as-ubuntu-server/"/>
    <id>https://www.voidking.com/dev-pc-as-ubuntu-server/</id>
    <published>2023-12-02T08:00:00.000Z</published>
    <updated>2024-05-04T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近买了个85寸电视，就想搞个NAS。<br>看了看价格，绿联NAS DX4600 2000左右，蜗牛星际NAS 1000左右，硬盘还需要另外购买。贫穷，让我想到了废弃已久的华为荣耀笔记本电脑。<br>要不然，用它作为NAS？还可以作为软路由？还可以部署Nginx、Jupyter、ChatGPT代理等常用服务，还可以参考 <a href="https://github.com/awesome-selfhosted/awesome-selfhosted">Awesome-Selfhosted</a> 部署更多有趣的项目，想想还挺不错。搞起来！</p><span id="more"></span><h1 id="NAS与软路由简介"><span class="post-title-index">2. </span><a href="#NAS与软路由简介" class="headerlink" title="NAS与软路由简介"></a>NAS与软路由简介</h1><blockquote><p>NAS，全称为网络附属存储(Network Attached Storage)，是一种专门的网络存储设备。NAS 设备通过网络直接连接到其他设备，用户可以随时随地通过网络存取NAS中的数据。<br>NAS设备的主要功能是提供数据存储和备份，同时还可能有流媒体服务、打印服务等其他功能。NAS设备可用于家庭和企业，帮助实现数据共享和存储管理，特别在企业场景下，NAS可以优化数据备份、共享和远程访问等业务流程。NAS设备可能通过NFS、FTP、SMB、WebDAV、DLNA等协议对外提供服务。</p></blockquote><blockquote><p>软路由是指使用普通计算机和路由软件实现的具有路由功能的设备。与一般的硬件路由器不同，软路由器可以运行在商用操作系统上，并由用户自定义和配置，以满足特定网络环境和应用的需求。软路由可以提供诸如路由转发、防火墙、VPN、流量管理等多种功能。</p></blockquote><p>NAS和软路由一体化设备，就是同时实现网络路由和数据存储功能的设备。它既能提供网络路由和防火墙等网络服务，又能提供文件共享和数据备份等存储服务。以下是几种常见的一体化方案：</p><ul><li>在通用Linux系统中安装NAS软件和路由软件。通用Linux系统中（如Ubuntu、CentOS），安装NAS软件来实现存储功能，安装路由软件来实现路由功能。</li><li>在NAS系统中安装路由软件。NAS系统中（如FreeNAS、OpenMediaVault），安装路由软件来实现路由功能。</li><li>在软路由系统中安装NAS软件。软路由系统中（如OpenWrt、pfSense、OPNsense），安装NAS软件来实现存储功能。</li><li>虚拟化技术。在主机上创建两个虚拟机，分别安装软路由系统和NAS系统；或者使用Docker，运行软路由系统和NAS系统。</li><li>商业一体化设备。一些厂商推出了一体化的软路由NAS设备，如华硕的RT-AC86U、群晖的DS216j等。这些设备可以同时实现软路由和NAS的功能，方便用户快速搭建家庭网络。</li></ul><p>参考文档：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/592292837">软路由/NAS - All in one(非虚拟化)方案</a></li><li><a href="https://nas.xiaosiseo.com/post/12295.html">软路由NAS一体方案：打造智能物联网家庭网络</a></li><li><a href="https://zhuanlan.zhihu.com/p/411161467">NFS、FTP、SMB、WebDav、DLNA协议，傻傻分不清？</a></li><li><a href="https://zhuanlan.zhihu.com/p/104639279">从听说到上手，人人都能看懂的软路由入门指南</a></li><li><a href="https://zh.wikipedia.org/wiki/OpenWrt">Wikipedia - OpenWrt</a></li></ul><h1 id="安装Ubuntu系统"><span class="post-title-index">3. </span><a href="#安装Ubuntu系统" class="headerlink" title="安装Ubuntu系统"></a>安装Ubuntu系统</h1><p>参考文档：<a href="https://ubuntu.com/tutorials/create-a-usb-stick-on-macos#1-overview">Create a bootable USB stick on macOS</a></p><p>1、服务器系统选择 <a href="https://releases.ubuntu.com/18.04.6/">ubuntu-18.04.6-desktop-amd64.iso</a><br>之所以选择desktop版，是因为desktop版是图形化界面，初始化配置很方便。后期不想要desktop的话，可以卸载掉。</p><p>2、使用<a href="https://etcher.balena.io/">balenaEtcher</a>制作一个U盘启动盘</p><p>3、笔记本插入U盘，开机选择从U盘启动</p><p>4、根据提示安装Ubuntu系统</p><p>系统分区时注意事项：</p><ul><li>建议手动进行分区，<code>New Partition Table</code>，如果分错了就<code>Revert</code>重新搞。</li><li>32MB给 <code>bios</code>，格式reserved bios boot area</li><li>500MB给 <code>efi</code>，格式efi</li><li>2GB 给 <code>/boot</code>，格式ext4</li><li>其余空间给 <code>/</code>，格式ext4</li></ul><p>在现代电脑系统（使用UEFI模式）中，电脑首先引导到EFI分区，EFI分区中的UEFI启动加载器，接着加载/boot分区中的操作系统内核，然后操作系统开始运行。</p><p>参考文档：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/569347838">如何安装 Ubuntu 22.04 LTS 桌面版 (图文教程) </a></li><li><a href="https://www.jianshu.com/p/146e39f6178d">Ubuntu22.04安装时手动分区</a></li><li><a href="https://baijiahao.baidu.com/s?id=1773827057913424371&wfr=spider&for=pc">XFS vs. EXT4：哪个更适合你的应用场景？</a></li></ul><h1 id="初始化Ubuntu系统"><span class="post-title-index">4. </span><a href="#初始化Ubuntu系统" class="headerlink" title="初始化Ubuntu系统"></a>初始化Ubuntu系统</h1><h2 id="配置固定IP"><span class="post-title-index">4.1. </span><a href="#配置固定IP" class="headerlink" title="配置固定IP"></a>配置固定IP</h2><p>图形界面配置。</p><p>或者参考<a href="https://www.voidking.com/dev-ubuntu18-static-ip/">《Ubuntu18配置静态IP》</a>，使用命令行配置。</p><h2 id="配置合上屏幕不休眠"><span class="post-title-index">4.2. </span><a href="#配置合上屏幕不休眠" class="headerlink" title="配置合上屏幕不休眠"></a>配置合上屏幕不休眠</h2><p>1、编辑logind配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/logind.conf</span><br></pre></td></tr></table></figure><p>修改其中的配置为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandleLidSwitch=ignore</span><br></pre></td></tr></table></figure><p>HandleLidSwitch是指笔记本屏幕合起来，设置为ignore，也就是笔记本屏幕合起来时不进行任何改变。</p><p>2、重启 systemd-logind</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart systemd-logind</span><br></pre></td></tr></table></figure><h2 id="安装向日葵"><span class="post-title-index">4.3. </span><a href="#安装向日葵" class="headerlink" title="安装向日葵"></a>安装向日葵</h2><p>1、参考向日葵官方文档，安装向日葵</p><p>2、安装 lightdm ，并重启主机</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y lightdm</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><p>参考文档：</p><ul><li><a href="https://service.oray.com/question/11017.html">向日葵 - Linux 个人版（命令行版本）使用手册</a></li><li><a href="https://blog.csdn.net/fighting_88412/article/details/133857593">Ubuntu重启后向日葵远程连接一直卡在连接界面</a></li></ul><h1 id="安装配置Samba"><span class="post-title-index">5. </span><a href="#安装配置Samba" class="headerlink" title="安装配置Samba"></a>安装配置Samba</h1><h2 id="安装Samba"><span class="post-title-index">5.1. </span><a href="#安装Samba" class="headerlink" title="安装Samba"></a>安装Samba</h2><p>1、安装Samba</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install samba</span><br></pre></td></tr></table></figure><p>2、查看Samba服务状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status nmbd</span><br></pre></td></tr></table></figure><h2 id="配置Samba"><span class="post-title-index">5.2. </span><a href="#配置Samba" class="headerlink" title="配置Samba"></a>配置Samba</h2><p>1、创建共享目录，并给sambashare用户组设置所有目录的读写权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /data/samba/video</span><br><span class="line">find /data/samba -<span class="built_in">type</span> d -<span class="built_in">exec</span> <span class="built_in">chgrp</span> sambashare &#123;&#125; \;</span><br><span class="line">find /data/samba -<span class="built_in">type</span> d -<span class="built_in">exec</span> <span class="built_in">chmod</span> 770 &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>其中，sambashare用户组是在安装Samba过程中自动创建的。</p><p>3、创建samba用户并授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -s /usr/sbin/nologin -G sambashare samba</span><br><span class="line">smbpasswd -a samba</span><br></pre></td></tr></table></figure><p>Samba权限控制使用Linux用户和组的权限系统，但具有自己的身份验证机制，与标准Linux身份验证分开。</p><p>4、配置共享目录和用户<br>编辑samba配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/samba/smb.conf</span><br></pre></td></tr></table></figure><p>在文件最后添加：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[video]</span><br><span class="line">    path = /data/samba/video</span><br><span class="line">    browseable = yes</span><br><span class="line">    read only = no</span><br><span class="line">    force create mode = 0660</span><br><span class="line">    force directory mode = 2770</span><br><span class="line">    valid users = @sambashare @sadmin</span><br><span class="line"></span><br><span class="line">#[doc]</span><br><span class="line">#    path = /data/samba/doc</span><br><span class="line">#    browseable = no</span><br><span class="line">#    read only = yes</span><br><span class="line">#    force create mode = 0660</span><br><span class="line">#    force directory mode = 2770</span><br><span class="line">#    valid users = samba @sambashare</span><br></pre></td></tr></table></figure><p>配置说明：</p><ul><li><code>[video]</code> 和 <code>[doc]</code> 表示登录时使用的共享名称。</li><li><code>path</code> 表示共享的目录。</li><li><code>browseable</code> 表示可浏览，是否可在共享列表中列出此共享。如果设置为no，其他用户将看不到共享目录。</li><li><code>read only</code> 表示valid users列表中指定的用户是否设置仅允许读，如果值yes，则仅允许读。</li><li><code>force create mode</code> 表示此共享创建文件时设置的文件权限模式。</li><li><code>force directory mode</code> 表示此共享创建目录时设置目录权限的模式。</li><li><code>valid users</code> 表示允许访问共享的用户和组的列表。群组以<code>@</code>符号为前缀。</li></ul><p>更多配置选项，请参考文档 <a href="https://www.samba.org/samba/docs/current/man-html/smb.conf.5.html">smb.conf — The configuration file for the Samba suite</a></p><p>5、重启samba</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart nmbd</span><br><span class="line">systemctl status nmbd</span><br></pre></td></tr></table></figure><h2 id="测试使用Samba"><span class="post-title-index">5.3. </span><a href="#测试使用Samba" class="headerlink" title="测试使用Samba"></a>测试使用Samba</h2><p>1、安装 samba client</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install smbclient</span><br></pre></td></tr></table></figure><p>2、创建测试文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> test.txt</span><br></pre></td></tr></table></figure><p>3、连接samba server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbclient //192.168.5.233/users -U samba</span><br></pre></td></tr></table></figure><p>4、上传下载文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">smb: \&gt; <span class="built_in">ls</span></span><br><span class="line">smb: \&gt; put test.txt test.txt</span><br><span class="line">smb: \&gt; get test.txt test2.txt</span><br><span class="line">smb: \&gt; <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>下载文件时，还可以使用smbget工具</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smbget -U samba smb://192.168.5.233/video/test.txt -o test3.txt</span><br></pre></td></tr></table></figure><h2 id="配置防火墙"><span class="post-title-index">5.4. </span><a href="#配置防火墙" class="headerlink" title="配置防火墙"></a>配置防火墙</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ufw allow <span class="string">&#x27;Samba&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="本地挂载阿里云盘"><span class="post-title-index">6. </span><a href="#本地挂载阿里云盘" class="headerlink" title="本地挂载阿里云盘"></a>本地挂载阿里云盘</h1><h2 id="安装Docker"><span class="post-title-index">6.1. </span><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h2><p>参考文档：<a href="https://www.voidking.com/dev-docker-start/">《Docker入门篇》</a></p><h2 id="获取阿里云盘refresh-token"><span class="post-title-index">6.2. </span><a href="#获取阿里云盘refresh-token" class="headerlink" title="获取阿里云盘refresh token"></a>获取阿里云盘refresh token</h2><p>参考文档<a href="https://hub.docker.com/r/messense/aliyundrive-webdav">dockerhub - messense/aliyundrive-webdav</a>，<a href="https://messense-aliyundrive-webdav-backendrefresh-token-ucs0wn.streamlit.app/">通过在线工具获取 refresh token</a>。</p><p>以前通过浏览器自行获取refresh token的方法已失效，详情参考 <a href="https://github.com/messense/aliyundrive-webdav/discussions/900">Error: Invalid refresh token value found in –refresh-token argument</a>。</p><h2 id="启动阿里云盘webdav容器"><span class="post-title-index">6.3. </span><a href="#启动阿里云盘webdav容器" class="headerlink" title="启动阿里云盘webdav容器"></a>启动阿里云盘webdav容器</h2><p>1、拉取webdav镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull messense/aliyundrive-webdav:2.3.3</span><br></pre></td></tr></table></figure><p>2、启动webdav容器（本地文件服务器）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name=aliyundrive-webdav \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -e REFRESH_TOKEN=<span class="string">&#x27;your token&#x27;</span> \</span><br><span class="line">  -e WEBDAV_AUTH_USER=admin \</span><br><span class="line">  -e WEBDAV_AUTH_PASSWORD=admin\</span><br><span class="line">  messense/aliyundrive-webdav:2.3.3</span><br></pre></td></tr></table></figure><p>3、查看webdav容器状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker logs aliyundrive-webdav</span><br></pre></td></tr></table></figure><h2 id="挂载阿里云盘"><span class="post-title-index">6.4. </span><a href="#挂载阿里云盘" class="headerlink" title="挂载阿里云盘"></a>挂载阿里云盘</h2><p>1、安装webdav驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -y davfs2</span><br></pre></td></tr></table></figure><p>2、创建挂载目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /data/aliyundrive</span><br></pre></td></tr></table></figure><p>3、挂载阿里云盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mount -t davfs http://192.168.5.233:8080/ /data/aliyundrive</span><br></pre></td></tr></table></figure><p>4、查看挂载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/aliyundrive</span><br><span class="line"><span class="built_in">ls</span> -l</span><br></pre></td></tr></table></figure><h2 id="通过samba共享"><span class="post-title-index">6.5. </span><a href="#通过samba共享" class="headerlink" title="通过samba共享"></a>通过samba共享</h2><p>本地目录挂载阿里云盘后，和其他普通目录一样，也可以通过samba共享给其他主机。<br>samba配置如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[aliyundrive]</span><br><span class="line">    path = /data/aliyundrive</span><br><span class="line">    browseable = yes</span><br><span class="line">    read only = yes</span><br><span class="line">    valid users = @sambashare @sadmin</span><br></pre></td></tr></table></figure><h2 id="拷贝阿里云盘中的文件到本地"><span class="post-title-index">6.6. </span><a href="#拷贝阿里云盘中的文件到本地" class="headerlink" title="拷贝阿里云盘中的文件到本地"></a>拷贝阿里云盘中的文件到本地</h2><p>如果担心访问阿里云盘时候的网络不稳定，可以把一部分文件下载到本地磁盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">screen rsync -P -azv <span class="string">&#x27;爱情公寓&#x27;</span> /data/samba/video</span><br></pre></td></tr></table></figure><p>下载速度很快，家庭千兆宽带大概平均 10MB/s，峰值 30MB/s。</p><h1 id="安装配置WebDAV"><span class="post-title-index">7. </span><a href="#安装配置WebDAV" class="headerlink" title="安装配置WebDAV"></a>安装配置WebDAV</h1><h2 id="WebDAV简介"><span class="post-title-index">7.1. </span><a href="#WebDAV简介" class="headerlink" title="WebDAV简介"></a>WebDAV简介</h2><p>WebDAV（Web-based Distributed Authoring and Versioning）是一种基于HTTP协议的通信协议，用于使用户可以方便地对服务器上的文档进行远程编辑和管理。WebDAV扩展了HTTP/1.1协议，增加了一系列的方法，以支持文件的创建、移动、复制和删除等操作。</p><p>使用WebDAV需要两个基本组件：WebDAV客户端和服务器。WebDAV客户端可以是任何支持该协议标准的软件，如一些文件管理器、专门的WebDAV应用程序或甚至是某些操作系统内置的文件浏览功能。服务器端则需要运行支持WebDAV的服务器软件，如Apache的mod_dav模块。</p><p>设置WebDAV环境时，通常需要在服务器上进行配置，以确保正确的文件权限、认证和安全设置。出于安全考虑，WebDAV通信应该通过SSL/TLS加密来保护数据传输过程中的安全性（使用HTTPS协议而不是HTTP）。</p><p>相较于Samba，WebDAV的权限检查更严格，比如目录中存在权限为问号的文件，那么整个目录都无法访问。</p><h2 id="安装WebDAV服务端"><span class="post-title-index">7.2. </span><a href="#安装WebDAV服务端" class="headerlink" title="安装WebDAV服务端"></a>安装WebDAV服务端</h2><p>1、安装Apache HTTP服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install apache2</span><br></pre></td></tr></table></figure><p>2、启用Apache的WebDAV模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a2enmod dav dav_fs</span><br></pre></td></tr></table></figure><p>3、重启Apache</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure><h2 id="配置WebDAV服务端"><span class="post-title-index">7.3. </span><a href="#配置WebDAV服务端" class="headerlink" title="配置WebDAV服务端"></a>配置WebDAV服务端</h2><p>1、创建WebDAV共享目录，并授权</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /data/samba</span><br><span class="line">find /data/samba -<span class="built_in">type</span> d -<span class="built_in">exec</span> <span class="built_in">chmod</span> 777 &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>这里复用Samba共享目录，同时修改权限为777，否则 www-data 用户无权读写。</p><p>2、配置WebDAV服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apache2/sites-available/000-default.conf</span><br></pre></td></tr></table></figure><p>VirtualHost标签中，添加如下内容：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Alias /webdav /data/samba</span><br><span class="line"><span class="tag">&lt;<span class="name">Location</span> /<span class="attr">webdav</span>&gt;</span></span><br><span class="line">    DAV On</span><br><span class="line">    AuthType Basic</span><br><span class="line">    AuthName &quot;WebDAV&quot;</span><br><span class="line">    AuthUserFile /etc/apache2/webdav.password</span><br><span class="line">    Require valid-user</span><br><span class="line"><span class="tag">&lt;/<span class="name">Location</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、创建用户名和密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -bc /etc/apache2/webdav.password user1 password1</span><br></pre></td></tr></table></figure><p>增加用户名和密码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -b /etc/apache2/webdav.password user2 password2</span><br></pre></td></tr></table></figure><p>4、重启Apache</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure><h2 id="测试使用WebDAV"><span class="post-title-index">7.4. </span><a href="#测试使用WebDAV" class="headerlink" title="测试使用WebDAV"></a>测试使用WebDAV</h2><h3 id="浏览器访问"><span class="post-title-index">7.4.1. </span><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h3><p>假设主机IP为 192.168.5.233<br>浏览器访问 <a href="http://192.168.5.233/webdav">http://192.168.5.233/webdav</a><br>访问时，会提示输入用户名和密码，证明我们的webdav配置正常。</p><p>登录后，会提示 Forbidden You don’t have permission to access this resource.<br>这是正常的，因为缺少 index.html 这种文件。</p><p>假设有一个文件路径为：/data/samba/test.png<br>那么通过浏览器可以直接访问：<a href="http://192.168.5.233/webdav/test.png">http://192.168.5.233/webdav/test.png</a></p><h3 id="cadver客户端访问"><span class="post-title-index">7.4.2. </span><a href="#cadver客户端访问" class="headerlink" title="cadver客户端访问"></a>cadver客户端访问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt install cadaver</span><br><span class="line"></span><br><span class="line">cadaver http://192.168.5.233/webdav</span><br></pre></td></tr></table></figure><p>连接时，会提示输入用户名和密码。</p><p>连接成功后，会看到 <code>cadaver</code> 命令行提示符，此时可以使用以下命令：</p><ul><li><code>ls</code>: 列出当前目录中的文件和目录。</li><li><code>cd directory</code>: 更改到名为 <code>directory</code> 的目录。</li><li><code>pwd</code>: 显示当前目录的完整路径。</li><li><code>get filename</code>: 下载文件 <code>filename</code> 到本地当前目录。</li><li><code>put filename</code>: 上传本地文件 <code>filename</code> 到当前的WebDAV目录。</li><li><code>mget *.ext</code>: 下载当前目录中所有扩展名为 <code>.ext</code> 的文件。</li><li><code>mput *.ext</code>: 上传当前本地目录中所有扩展名为 <code>.ext</code> 的文件。</li><li><code>delete filename</code>: 删除文件 <code>filename</code>。</li><li><code>mkcol directory</code>: 创建一个名为 <code>directory</code> 的新目录。</li><li><code>move source destination</code>: 移动或重命名文件 <code>source</code> 为 <code>destination</code>。</li><li><code>copy source destination</code>: 复制文件 <code>source</code> 到 <code>destination</code>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近买了个85寸电视，就想搞个NAS。&lt;br&gt;看了看价格，绿联NAS DX4600 2000左右，蜗牛星际NAS 1000左右，硬盘还需要另外购买。贫穷，让我想到了废弃已久的华为荣耀笔记本电脑。&lt;br&gt;要不然，用它作为NAS？还可以作为软路由？还可以部署Nginx、Jupyter、ChatGPT代理等常用服务，还可以参考 &lt;a href=&quot;https://github.com/awesome-selfhosted/awesome-selfhosted&quot;&gt;Awesome-Selfhosted&lt;/a&gt; 部署更多有趣的项目，想想还挺不错。搞起来！&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="ubuntu" scheme="https://www.voidking.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>好好学Linux：CentOS救援模式使用说明</title>
    <link href="https://www.voidking.com/dev-centos-rescue-mode/"/>
    <id>https://www.voidking.com/dev-centos-rescue-mode/</id>
    <published>2023-10-14T08:00:00.000Z</published>
    <updated>2023-10-14T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>当CentOS系统崩溃无法正常启动时，往往需要进入救援模式进行恢复。<br>本文中，我们学习一下CentOS救援模式的使用方法。</p><p>参考文档：</p><ul><li><a href="https://blog.csdn.net/hdyebd/article/details/83754257">Linux紧急救援模式(Centos7) </a></li><li><a href="https://blog.csdn.net/hp_log/article/details/126967463">centos 8 进入紧急救援模式</a></li><li><a href="https://docs.centos.org/en-US/centos/install-guide/Rescue_Mode/">Basic System Recovery</a></li><li><a href="https://handle.idv.tw/centos7-%E5%87%BA%E7%8F%BEwelcome-to-emergency-mode%E7%9A%84%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95/">centos7 出現welcome to emergency mode的解決方法</a></li></ul><span id="more"></span><h1 id="进入救援模式"><span class="post-title-index">2. </span><a href="#进入救援模式" class="headerlink" title="进入救援模式"></a>进入救援模式</h1><h2 id="自带救援模式"><span class="post-title-index">2.1. </span><a href="#自带救援模式" class="headerlink" title="自带救援模式"></a>自带救援模式</h2><p>通过外接设备（KVM/显示器键盘）或者VNC连接到主机。</p><p>1、开机启动，在出现内核选项时按下 <code>e</code> 进入编辑</p><p>2、添加内核参数<br>centos7找到 <code>linux16</code> 开头的行并在行尾添加内核参数 <code>rd.break</code><br>centos8找到 <code>linux</code> 开头的行并在行尾添加内核参数 <code>rd.break</code></p><p>3、并按 <code>ctrl+x</code> 进入单用户模式 </p><p>4、挂载并更改根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mount –o remount,rw /sysroot </span><br><span class="line"><span class="built_in">chroot</span> /sysroot </span><br></pre></td></tr></table></figure><h2 id="第三方系统救援模式"><span class="post-title-index">2.2. </span><a href="#第三方系统救援模式" class="headerlink" title="第三方系统救援模式"></a>第三方系统救援模式</h2><p>通过外接设备（KVM/显示器键盘）或者VNC连接到主机。</p><p>1、插入包含CentOS系统的光盘或者U盘</p><p>2、开机启动，按下F12，选择从光盘或者U盘启动</p><p>3、启动后选择 Troubleshooting，Rescue a CentOS system</p><h1 id="救援模式常用操作"><span class="post-title-index">3. </span><a href="#救援模式常用操作" class="headerlink" title="救援模式常用操作"></a>救援模式常用操作</h1><h2 id="更改root密码"><span class="post-title-index">3.1. </span><a href="#更改root密码" class="headerlink" title="更改root密码"></a>更改root密码</h2><p>如果root密码丢失，主机刚好启动失败，这时候就必须通过救援模式修改root密码了。</p><p>1、进入自带救援模式</p><p>2、操作修改root密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">passwd root</span><br><span class="line"><span class="built_in">touch</span> /.autorelabel </span><br><span class="line"><span class="built_in">exit</span> </span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="修复启动失败"><span class="post-title-index">3.2. </span><a href="#修复启动失败" class="headerlink" title="修复启动失败"></a>修复启动失败</h2><p>1、进入自带救援模式</p><p>2、查看系统启动日志，找到具体的启动失败的原因</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">journalctl -xb</span><br></pre></td></tr></table></figure><p>断电后的启动失败，极大概率是因为挂载问题。<br>例如，如果提示时因为 <code>/data</code> 目录的挂载问题，那么就在 <code>/etc/fstab</code> 中注释掉 <code>/data</code> 目录的挂载。<br>然后重启主机即可 <code>reboot</code></p><h2 id="修复grub"><span class="post-title-index">3.3. </span><a href="#修复grub" class="headerlink" title="修复grub"></a>修复grub</h2><p>问题原因：<code>rm /boot/grub* -rf</code><br>问题表现：启动时出现报错 error: file ‘/grub2/i386-pc/normal.mod’ not found.</p><p>1、进入第三方系统救援模式</p><p>2、更改根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mnt/sysimage</span><br><span class="line"><span class="built_in">rm</span> /boot/grub* -rf</span><br><span class="line"><span class="built_in">ls</span> /boot</span><br><span class="line"><span class="built_in">mkdir</span> /boot/grub2</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">grub2-install /dev/sda</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="修复-boot"><span class="post-title-index">3.4. </span><a href="#修复-boot" class="headerlink" title="修复/boot"></a>修复/boot</h2><p>问题原因：<code>rm /boot/* -rf</code><br>问题表现：启动时出现报错 error: file ‘/grub2/i386-pc/normal.mod’ not found.</p><p>1、进入第三方系统救援模式</p><p>2、更改根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chroot</span> /mnt/sysimage</span><br><span class="line"><span class="built_in">ls</span> /boot</span><br><span class="line">mount /dev/sr0 /mnt </span><br><span class="line">rpm -ivh /mnt/Packages/kernel-3.10.0-693.e17.x86_64.rpm.rpm --force</span><br><span class="line"><span class="built_in">ls</span> /boot</span><br><span class="line">grub2-install /dev/sda</span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h1 id="救援模式与紧急模式"><span class="post-title-index">4. </span><a href="#救援模式与紧急模式" class="headerlink" title="救援模式与紧急模式"></a>救援模式与紧急模式</h1><p>救援模式（Rescue Mode）：也称作单用户模式，主要用于修复系统问题。在这种模式下，系统会尝试挂载所有的文件系统，启动网络服务，让你有机会对系统进行彻底的维护。你可以更改系统文件，修复系统问题（比如重设root密码，修复GRUB启动器问题等）。这是一个维护和修复系统问题的模式。</p><p>紧急模式（Emergency Mode）：这是最低级别的启动模式，只会提供最少的系统功能（仅启动根文件系统，这个文件系统默认会以只读方式进行挂载），不会启动网络连接，不会尝试挂载其他文件系统。这种模式主要用于在无法进入 Rescue 模式时进行最低级别的系统问题排查。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;当CentOS系统崩溃无法正常启动时，往往需要进入救援模式进行恢复。&lt;br&gt;本文中，我们学习一下CentOS救援模式的使用方法。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hdyebd/article/details/83754257&quot;&gt;Linux紧急救援模式(Centos7) &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/hp_log/article/details/126967463&quot;&gt;centos 8 进入紧急救援模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.centos.org/en-US/centos/install-guide/Rescue_Mode/&quot;&gt;Basic System Recovery&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://handle.idv.tw/centos7-%E5%87%BA%E7%8F%BEwelcome-to-emergency-mode%E7%9A%84%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95/&quot;&gt;centos7 出現welcome to emergency mode的解決方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="linux" scheme="https://www.voidking.com/categories/engineering/linux/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="好好学Linux" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Linux/"/>
    
    <category term="centos" scheme="https://www.voidking.com/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>网络排查工具MTR入门篇</title>
    <link href="https://www.voidking.com/dev-mtr-start/"/>
    <id>https://www.voidking.com/dev-mtr-start/</id>
    <published>2023-10-05T08:00:00.000Z</published>
    <updated>2023-10-05T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MTR简介"><span class="post-title-index">1. </span><a href="#MTR简介" class="headerlink" title="MTR简介"></a>MTR简介</h1><p>网络排查工程常常包含了诊断网络中断和稳定性问题。在这些场合下，网络工程师们通常会使用一些有效的网络工具来帮助他们准确地查找问题所在。其中，MTR是一款极其实用的网络诊断工具。</p><p>MTR，全名为My Traceroute，是一款网络诊断工具，结合了traceoute和ping两种常见工具的功能。通过源自源主机到目标主机的网络连接的持续跟踪，MTR能提供每个路由节点的响应速度和系统稳定性情况。</p><p>参考文档：</p><ul><li><a href="https://www.starcto.com/nettool/306.html">关于网络排查工具MTR那些你必须了解的事情</a></li><li><a href="https://cloud.tencent.com/document/product/213/14638">使用 MTR 分析网络延迟及丢包</a></li><li><a href="https://cloud.tencent.com/document/product/213/57336">云服务器网络访问丢包</a></li></ul><span id="more"></span><h1 id="安装MTR"><span class="post-title-index">2. </span><a href="#安装MTR" class="headerlink" title="安装MTR"></a>安装MTR</h1><p>MTR是开源的，我们可以在大多数的Linux发行版中找到它。</p><p>在Ubuntu或Debian系统中，我们可以通过下列命令来进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install mtr</span><br></pre></td></tr></table></figure><p>如果我们正在使用CentOS或者Fedora，可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install mtr</span><br></pre></td></tr></table></figure><h1 id="运行MTR"><span class="post-title-index">3. </span><a href="#运行MTR" class="headerlink" title="运行MTR"></a>运行MTR</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr 192.168.56.101</span><br></pre></td></tr></table></figure><p>运行后，MTR将运行统计报告，展示当前主机到目标主机的每一跳联网情况。</p><p>运行结果的主要信息如下：</p><ul><li>Hostname：到目的服务器要经过的每个主机 IP 或名称。</li><li>Nr：经过节点的数量。</li><li>Loss%：对应节点的丢包率。</li><li>Sent：发送的数据包数量。</li><li>Recv：接收到响应的数量。</li><li>Best：最短的响应时间。</li><li>Avrg：平均响应时间。</li><li>Worst：最长的响应时间。</li><li>Last：最近一次的响应时间。</li></ul><p>在MTR运行时，我们能看到各路由节点的丢包率，如果某一跳的丢包率很高，那么这就可能是网络问题的所在。<br>大多数情况，只需要关注最后一跳（目的地址）是否有丢包即可。</p><p>此外，MTR并不仅仅提供实时的网络连接状态，还可以通过生成报告的方式保存网络状态。<br>通过在命令后添加”–report”，MTR将在运行一定时间后生成一个报告。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mtr --report 192.168.56.101</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;MTR简介&quot;&gt;&lt;a href=&quot;#MTR简介&quot; class=&quot;headerlink&quot; title=&quot;MTR简介&quot;&gt;&lt;/a&gt;MTR简介&lt;/h1&gt;&lt;p&gt;网络排查工程常常包含了诊断网络中断和稳定性问题。在这些场合下，网络工程师们通常会使用一些有效的网络工具来帮助他们准确地查找问题所在。其中，MTR是一款极其实用的网络诊断工具。&lt;/p&gt;
&lt;p&gt;MTR，全名为My Traceroute，是一款网络诊断工具，结合了traceoute和ping两种常见工具的功能。通过源自源主机到目标主机的网络连接的持续跟踪，MTR能提供每个路由节点的响应速度和系统稳定性情况。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.starcto.com/nettool/306.html&quot;&gt;关于网络排查工具MTR那些你必须了解的事情&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/document/product/213/14638&quot;&gt;使用 MTR 分析网络延迟及丢包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/document/product/213/57336&quot;&gt;云服务器网络访问丢包&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="shell" scheme="https://www.voidking.com/categories/engineering/shell/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="网络" scheme="https://www.voidking.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
