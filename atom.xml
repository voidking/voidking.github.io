<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好好学习的郝</title>
  
  <subtitle>好好学习，天天向上！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.voidking.com/"/>
  <updated>2020-06-28T00:39:48.724Z</updated>
  <id>https://www.voidking.com/</id>
  
  <author>
    <name>好好学习的郝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kube-controller-manager指标收集</title>
    <link href="https://www.voidking.com/dev-kube-controller-manager-metrics/"/>
    <id>https://www.voidking.com/dev-kube-controller-manager-metrics/</id>
    <published>2020-06-22T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>大家都知道需要监控k8s指标，但是具体需要监控k8s的哪些组件的哪些指标？<br>本文，就来学习梳理kube-controller-mananger组件的监控指标。</p><a id="more"></a><h1 id="有哪些指标？"><a href="#有哪些指标？" class="headerlink" title="有哪些指标？"></a>有哪些指标？</h1><p>要收集指标，首先要知道有哪些指标可以收集。<br>方法一：使用curl命令</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">k</span> <span class="built_in">get</span> pods -n kube-<span class="built_in">system</span> -<span class="keyword">o</span> wide | <span class="keyword">grep</span> kube-controller-manager</span><br><span class="line"><span class="keyword">k</span> <span class="built_in">get</span> svc -n kube-<span class="built_in">system</span> -<span class="keyword">o</span> wide | <span class="keyword">grep</span> kube-controller-manager</span><br><span class="line"></span><br><span class="line">ssh <span class="symbol">&lt;clusterhost&gt;</span></span><br><span class="line">curl localhos<span class="variable">t:</span><span class="symbol">&lt;nodeport&gt;</span>/metrics</span><br></pre></td></tr></table></figure><p>方法二：在prometheus使用promql</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count(&#123;job=<span class="string">"kube-controller-manager"</span>&#125;) by (<span class="name">__name__</span>)</span><br><span class="line">count(&#123;job=<span class="string">"kube-controller-manager"</span>,__name__!~<span class="string">"^go_.*"</span>&#125;) by (<span class="name">__name__</span>)</span><br></pre></td></tr></table></figure><h1 id="指标含义？"><a href="#指标含义？" class="headerlink" title="指标含义？"></a>指标含义？</h1><p>找到了指标，接下来需要知道指标的含义。<br>访问 <a href="https://docs.signalfx.com/en/latest/integrations/agent/monitors/kube-controller-manager.html" target="_blank" rel="noopener">Splunk doc - kube-controller-manager</a>，使用指标名称搜索即可。</p><p>比如搜索：<br>rest_client_request_duration_seconds_bucket<br>得到结果：<br>rest_client_request_duration_seconds_bucket (cumulative)<br>Request latency in seconds. Broken down by verb and URL. (bucket)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;大家都知道需要监控k8s指标，但是具体需要监控k8s的哪些组件的哪些指标？&lt;br&gt;本文，就来学习梳理kube-controller-mananger组件的监控指标。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
      <category term="监控" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="监控" scheme="https://www.voidking.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="prometheus" scheme="https://www.voidking.com/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>Prometheus查询语言：PromQL</title>
    <link href="https://www.voidking.com/dev-prometheus-query-language-promql/"/>
    <id>https://www.voidking.com/dev-prometheus-query-language-promql/</id>
    <published>2020-06-21T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PromQL简介"><a href="#PromQL简介" class="headerlink" title="PromQL简介"></a>PromQL简介</h1><blockquote><p>Prometheus提供了一种称为PromQL（Prometheus查询语言）的功能查询语言，使用户可以实时选择和汇总时间序列数据。表达式的结果既可以显示为图形，也可以在Prometheus的表达式浏览器中显示为表格数据，也可以由外部系统通过HTTP API使用。</p></blockquote><p>更多内容参考<a href="https://prometheus.io/docs/prometheus/latest/querying/basics/" target="_blank" rel="noopener">QUERYING PROMETHEUS</a> 和 <a href="https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql" target="_blank" rel="noopener">探索PromQL</a>。</p><a id="more"></a><h1 id="时间序列"><a href="#时间序列" class="headerlink" title="时间序列"></a>时间序列</h1><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># HELP node_cpu Seconds the cpus spent in each mode.</span></span><br><span class="line"><span class="meta"># TYPE node_cpu counter</span></span><br><span class="line">node_cpu&#123;cpu=<span class="string">"cpu0"</span>,mode=<span class="string">"idle"</span>&#125; <span class="number">362812.7890625</span></span><br><span class="line"><span class="meta"># HELP node_load1 1m load average.</span></span><br><span class="line"><span class="meta"># TYPE node_load1 gauge</span></span><br><span class="line">node_load1 <span class="number">3.0703125</span></span><br></pre></td></tr></table></figure><p>其中非#开头的每一行表示当前Node Exporter采集到的一个监控指标（监控样本）：node_cpu和node_load1表明了当前指标的名称（大括号中的标签则反映了该指标的一些特征和维度），浮点数是该指标的具体值。指标格式为：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">metric_name</span> <span class="selector-attr">[ &#123;label_name=<span class="string">"label_value"</span>&#125; ]</span> <span class="selector-tag">value</span> <span class="selector-attr">[ timestamp ]</span></span><br></pre></td></tr></table></figure><p>其中metric_name和label_name必须遵循PromQL的格式规范要求。value是一个float格式的数据，timestamp的类型为int64（从1970-01-01 00:00:00以来的毫秒数），timestamp为可选默认为当前时间。具有相同metric_name的样本必须按照一个组的形式排列，并且每一行必须是唯一的指标名称和标签键值对组合。</p><p>Prometheus会将所有采集到的指标数据以时间序列（time-series）的方式保存在内存数据库中，并且定时保存到硬盘上。时间序列是按照时间戳和指标的序列顺序存放的，我们称之为向量(vector)。</p><p>可以将time-series理解为一个数字矩阵，X轴是时间戳，Y轴是指标。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>在Prometheus的表达语言中，一个表达式或子表达式可以分以下四种类型之一：</p><ul><li>瞬时向量：一组时间序列，这组时间序列具有相同的时间戳</li><li>范围向量：一段时间范围的时间序列</li><li>标量：一个简单的数字浮点值</li><li>String：一个简单的字符串值；目前未使用</li></ul><p>根据用例（例如在绘制图形或显示表达式的输出时），由于用户指定的表达式的结果，其中只有某些类型是合法的。例如，返回瞬时向量的表达式是唯一可以直接绘制图形的类型。</p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><p>字符串可以用单引号，双引号或反引号指定为常量。<br>PromQL遵循与Go相同的转义规则。在单引号或双引号中，反斜杠开始一个转义序列。可以使用八进制或十六进制提供特定字符。<br>反引号内不会处理任何转义。与Go不同，Prometheus不会在反引号内丢弃换行符。</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"this is a string"</span><br><span class="line">'these are unescaped: <span class="symbol">\n</span> <span class="symbol">\\</span> <span class="symbol">\t</span>'</span><br><span class="line">`these are not unescaped: <span class="symbol">\n</span> ' " <span class="symbol">\t</span>`</span><br></pre></td></tr></table></figure><h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><p>浮点常量可以写做数字形式：<code>[-](digits)[.(digits)]</code> ，例如 -2.43</p><h1 id="时间序列选择器"><a href="#时间序列选择器" class="headerlink" title="时间序列选择器"></a>时间序列选择器</h1><h2 id="瞬时向量选择器"><a href="#瞬时向量选择器" class="headerlink" title="瞬时向量选择器"></a>瞬时向量选择器</h2><p>瞬时向量选择器允许在给定的时间戳（瞬时）下选择一组时间序列和每个样本的单个样本值：以最简单的形式，仅指定度量名称。这将导致一个瞬时向量，其中包含具有该度量名称的所有时间序列的元素。<br>通过在花括号 <code>{}</code> 中附加逗号分隔的标签匹配器列表，可以进一步过滤这些时间序列。<br>也可以否定标签值，或将标签值与正则表达式匹配。存在以下标签匹配运算符：</p><ul><li>=：选择与字符串完全相等的标签。</li><li>!=：选择不等于字符串的标签。</li><li>=〜：选择与字符串进行正则表达式匹配的标签。</li><li>!〜：选择与字符串正则表达式不匹配的标签。</li></ul><p>匹配空标签值的标签匹配器还会选择所有根本没有设置特定标签的时间序列。正则表达式匹配完全锚定。同一标签名称可能有多个匹配器。<br>向量选择器必须指定一个名称或至少一个与空字符串不匹配的标签匹配器。<br>通过与内部 <code>__name__</code> 标签进行匹配，标签匹配器也可以应用于度量标准名称。Prometheus中的所有正则表达式都使用<a href="https://github.com/google/re2/wiki/Syntax" target="_blank" rel="noopener">RE2语法</a>。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;job=~<span class="string">".*"</span>&#125; <span class="comment"># Bad!</span></span><br><span class="line">&#123;job=~<span class="string">".+"</span>&#125;              <span class="comment"># Good!</span></span><br><span class="line">&#123;job=~<span class="string">".*"</span>,method=<span class="string">"get"</span>&#125; <span class="comment"># Good!</span></span><br><span class="line">&#123;__name__=~<span class="string">"job:.*"</span>&#125; <span class="comment"># selects all metrics that have a name starting with job:</span></span><br><span class="line"><span class="keyword">on</span>&#123;&#125; <span class="comment"># Bad!</span></span><br><span class="line">&#123;__name__=<span class="string">"on"</span>&#125; <span class="comment"># Good!</span></span><br></pre></td></tr></table></figure><h2 id="范围向量选择器"><a href="#范围向量选择器" class="headerlink" title="范围向量选择器"></a>范围向量选择器</h2><p>范围向量的工作方式与瞬时向量相同，不同的是范围向量从瞬时向量中选择了一定范围的样本。语法上，将范围持续时间附加在向量选择器末尾的方括号 <code>[]</code> 中，以指定提取时间值的范围。<br>持续时间以数字指定，后面紧跟以下单位之一：s - seconds，m - minutes，h - hours，d - days，w - weeks，y - years</p><h2 id="偏移量"><a href="#偏移量" class="headerlink" title="偏移量"></a>偏移量</h2><p>偏移量允许更改查询中各个瞬时向量和范围向量的时间偏移。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total offset <span class="number">5</span>m</span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(http_requests_total&#123;method=<span class="string">"GET"</span>&#125; offset <span class="number">5</span>m)</span></span> <span class="comment">// GOOD.</span></span><br><span class="line"><span class="function"><span class="title">sum</span><span class="params">(http_requests_total&#123;method=<span class="string">"GET"</span>&#125;)</span></span> offset <span class="number">5</span>m <span class="comment">// INVALID.</span></span><br><span class="line"><span class="function"><span class="title">rate</span><span class="params">(http_requests_total[<span class="number">5</span>m] offset <span class="number">1</span>w)</span></span></span><br></pre></td></tr></table></figure><h1 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h1><p>子查询对给定的范围进行即时查询。子查询的结果是范围向量。<br>语法：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;instant_query&gt; '[' &lt;range&gt; ':' <span class="meta">[&lt;resolution&gt;]</span> ']' [ offset &lt;duration&gt; ]</span><br></pre></td></tr></table></figure><p>resolution是可选的。默认值为全局评估间隔。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>Prometheus支持许多二进制和聚合运算符，更多内容参考<a href="https://prometheus.io/docs/prometheus/latest/querying/operators/" target="_blank" rel="noopener">表达式语言运算符</a>。</p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>Prometheus支持多种对数据进行操作的函数，更多内容参考<a href="https://prometheus.io/docs/prometheus/latest/querying/functions/" target="_blank" rel="noopener">表达式语言函数</a>。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>PromQL支持以＃开头的行注释。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>详细内容参见<a href="https://prometheus.io/docs/prometheus/latest/querying/examples/" target="_blank" rel="noopener">QUERY EXAMPLE</a></p><h2 id="简单时间序列查询"><a href="#简单时间序列查询" class="headerlink" title="简单时间序列查询"></a>简单时间序列查询</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http_requests_total</span><br><span class="line">&#123;<span class="attribute">__name__</span>=<span class="string">"http_requests_total"</span>&#125;</span><br><span class="line">http_requests_total&#123;<span class="attribute">job</span>=<span class="string">"apiserver"</span>, <span class="attribute">handler</span>=<span class="string">"/api/comments"</span>&#125;</span><br><span class="line">http_requests_total&#123;<span class="attribute">job</span>=<span class="string">"apiserver"</span>, <span class="attribute">handler</span>=<span class="string">"/api/comments"</span>&#125;[5m]</span><br><span class="line">http_requests_total&#123;<span class="attribute">job</span>=~".*server"&#125;</span><br><span class="line">http_requests_total&#123;status!~<span class="string">"4.."</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="子查询-1"><a href="#子查询-1" class="headerlink" title="子查询"></a>子查询</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rate(http_requests_total[<span class="number">5</span>m])[<span class="number">30</span>m:<span class="number">1</span>m]</span><br><span class="line">max_over_time(deriv(rate(distance_covered_total[<span class="number">5</span>s])[<span class="number">30</span>s:<span class="number">5</span>s])[<span class="number">10</span>m:])</span><br></pre></td></tr></table></figure><h2 id="函数运算等"><a href="#函数运算等" class="headerlink" title="函数运算等"></a>函数运算等</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rate(<span class="name">http_requests_total</span>[<span class="number">5</span>m])</span><br><span class="line"></span><br><span class="line">sum by (<span class="name">job</span>) (</span><br><span class="line">  rate(<span class="name">http_requests_total</span>[<span class="number">5</span>m])</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">(<span class="name">instance_memory_limit_bytes</span> - instance_memory_usage_bytes) / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">sum by (<span class="name">app</span>, proc) (</span><br><span class="line">  instance_memory_limit_bytes - instance_memory_usage_bytes</span><br><span class="line">) / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line"></span><br><span class="line">topk(<span class="number">3</span>, sum by (<span class="name">app</span>, proc) (<span class="name">rate</span>(<span class="name">instance_cpu_time_ns</span>[<span class="number">5</span>m])))</span><br><span class="line"></span><br><span class="line">count by (<span class="name">app</span>) (<span class="name">instance_cpu_time_ns</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PromQL简介&quot;&gt;&lt;a href=&quot;#PromQL简介&quot; class=&quot;headerlink&quot; title=&quot;PromQL简介&quot;&gt;&lt;/a&gt;PromQL简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Prometheus提供了一种称为PromQL（Prometheus查询语言）的功能查询语言，使用户可以实时选择和汇总时间序列数据。表达式的结果既可以显示为图形，也可以在Prometheus的表达式浏览器中显示为表格数据，也可以由外部系统通过HTTP API使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多内容参考&lt;a href=&quot;https://prometheus.io/docs/prometheus/latest/querying/basics/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;QUERYING PROMETHEUS&lt;/a&gt; 和 &lt;a href=&quot;https://yunlzheng.gitbook.io/prometheus-book/parti-prometheus-ji-chu/promql&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;探索PromQL&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="监控" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="监控" scheme="https://www.voidking.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="prometheus" scheme="https://www.voidking.com/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker安装配置Grafana</title>
    <link href="https://www.voidking.com/dev-docker-grafana/"/>
    <id>https://www.voidking.com/dev-docker-grafana/</id>
    <published>2020-06-17T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Grafana简介"><a href="#Grafana简介" class="headerlink" title="Grafana简介"></a>Grafana简介</h1><blockquote><p><a href="https://grafana.com/" target="_blank" rel="noopener">Grafana</a> allows you to query, visualize, alert on and understand your metrics no matter where they are stored.</p></blockquote><p>本文中，我们会使用Docker来安装配置grafana，并且显示prometheus中的数据。<br>前置条件是安装配置好了docker环境，安装方法参考<a href="https://www.voidking.com/dev-docker-start/">《Docker入门》</a>。已知docker宿主机IP为192.168.56.102。</p><a id="more"></a><h1 id="安装Grafana"><a href="#安装Grafana" class="headerlink" title="安装Grafana"></a>安装Grafana</h1><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/r/grafana/grafana" target="_blank" rel="noopener">grafana版本</a>。</p><p>2、下载grafana镜像（以grafana6.7.4为例）<br><code>docker pull grafana/grafana:6.7.4</code></p><p>3、启动grafana服务</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=vk-grafana -d \</span><br><span class="line">-p <span class="number">3000</span>:<span class="number">3000</span> \</span><br><span class="line">grafana/grafana:<span class="number">6.7</span><span class="number">.4</span></span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为vk-grafana，后台运行</li><li>映射宿主机3000端口到容器3000端口</li></ul><p>grafana的配置文件为 /etc/grafana/grafana.ini ，可以进入容器进行修改，或者挂出到宿主机。</p><p>更高级的启动命令参考<a href="https://grafana.com/docs/grafana/latest/installation/docker/" target="_blank" rel="noopener">How to use the container</a>。</p><p>4、验证安装<br><code>docker ps</code><br>mysql启动正常的话就可以看到vk-grafana容器。<br>如果启动失败，可以使用<code>docker logs vk-grafana</code>查看失败原因并进行解决。</p><h1 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h1><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd <span class="params">--add-port=3000/tcp</span> <span class="params">--permanent</span></span><br><span class="line">systemctl <span class="keyword">reload</span> firewalld</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">systemctl stop firewalld</span><br></pre></td></tr></table></figure><h1 id="测试服务"><a href="#测试服务" class="headerlink" title="测试服务"></a>测试服务</h1><p>1、本机测试<br><code>curl localhost:3000</code></p><p>2、浏览器测试<br>访问 <a href="http://192.168.56.102:3000" target="_blank" rel="noopener">http://192.168.56.102:3000</a><br>用户名密码默认都是admin，第一次登录会提示修改。</p><h1 id="配置Prometheus数据"><a href="#配置Prometheus数据" class="headerlink" title="配置Prometheus数据"></a>配置Prometheus数据</h1><p>假设我们已经安装配置好了prometheus，参考<a href="https://www.voidking.com/dev-docker-prometheus/">《使用Docker安装配置Prometheus》</a>。</p><p>1、添加数据资源<br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/welcome.jpg?imageView2/0/w/800" alt=""><br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/adddata.jpg?imageView2/0/w/800" alt=""></p><p>2、配置Prometheus数据<br>Name填入 Prometheus ，URL填入 <code>http://192.168.56.102:9090</code>，其他不用变。Save&amp;Test。<br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/prometheus.jpg?imageView2/0/w/800" alt=""><br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/savetest.jpg?imageView2/0/w/800" alt=""></p><p>3、选择dashboard<br>点击Dashboards，点击三个Import，引入三个dashboard。<br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/dashboard.jpg?imageView2/0/w/800" alt=""></p><p>4、引入其他dashboard<br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/import.jpg?imageView2/0/w/800" alt=""><br>比如可以填入URL <a href="https://grafana.com/grafana/dashboards/405" target="_blank" rel="noopener">https://grafana.com/grafana/dashboards/405</a> ，点击Load，就可以下载Node Exporter的dashboard。<br>选择Folder，选择Prometheus数据源，Import。<br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/nodeexporter.jpg?imageView2/0/w/800" alt=""><br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/nodeexporter2.jpg?imageView2/0/w/800" alt=""></p><p>5、查看dashboard<br>左上角HOME，出现下拉框，即可选择dashboard。<br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/select.jpg?imageView2/0/w/800" alt=""><br><img src="http://cdn.voidking.com/@/imgs/docker-grafana/promstats.jpg?imageView2/0/w/800" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Grafana简介&quot;&gt;&lt;a href=&quot;#Grafana简介&quot; class=&quot;headerlink&quot; title=&quot;Grafana简介&quot;&gt;&lt;/a&gt;Grafana简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://grafana.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Grafana&lt;/a&gt; allows you to query, visualize, alert on and understand your metrics no matter where they are stored.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文中，我们会使用Docker来安装配置grafana，并且显示prometheus中的数据。&lt;br&gt;前置条件是安装配置好了docker环境，安装方法参考&lt;a href=&quot;https://www.voidking.com/dev-docker-start/&quot;&gt;《Docker入门》&lt;/a&gt;。已知docker宿主机IP为192.168.56.102。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
      <category term="监控" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
      <category term="centos" scheme="https://www.voidking.com/tags/centos/"/>
    
      <category term="监控" scheme="https://www.voidking.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="grafana" scheme="https://www.voidking.com/tags/grafana/"/>
    
      <category term="prometheus" scheme="https://www.voidking.com/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>使用Docker安装配置Prometheus</title>
    <link href="https://www.voidking.com/dev-docker-prometheus/"/>
    <id>https://www.voidking.com/dev-docker-prometheus/</id>
    <published>2020-06-16T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Prometheus简介"><a href="#Prometheus简介" class="headerlink" title="Prometheus简介"></a>Prometheus简介</h1><blockquote><p>Prometheus是在SoundCloud的基础上构建的开源系统监视和警报工具。自从2012年以来，许多公司和组织都采用了Prometheus，该项目拥有非常活跃的开发人员和用户社区。现在，它是一个独立的开源项目，并且独立于任何公司进行维护。为了强调这一点并阐明项目的治理结构，Prometheus在2016年加入了Cloud Native Computing Foundation，这是继Kubernetes之后的第二个托管项目。</p></blockquote><p>Prometheus的主要特性包括：</p><ul><li>一个包含时间序列的多维数据模型，由指标名称和键值对进行标记</li><li>PromQL，一种灵活的查询语言</li><li>不依赖分布式存储；单服务器节点是自治的</li><li>时间序列收集是通过HTTP拉取模型实现的</li><li>支持通过中间网关推送时间序列</li><li>通过服务发现或静态配置发现目标</li><li>支持多种图形和仪表板</li></ul><p>Prometheus生态系统包含多个组件，其中许多是可选的：</p><ul><li>prometheus server，负责收取并存储时间序列数据</li><li>client libraries，用于检测应用程序代码</li><li>push gateway，支持短期工作</li><li>exporters，适用于特定服务的指标收集器，如HAProxy，StatsD，Graphite</li><li>alertmanager，处理报警</li><li>各种支持工具</li></ul><p>更多内容参考<a href="https://prometheus.io/docs/introduction/overview/" target="_blank" rel="noopener">Prometheus文档</a>。<br>本文中，我们会使用Docker来安装配置Prometheus，主要参考<a href="https://www.cnblogs.com/informatics/p/12215255.html" target="_blank" rel="noopener">Prometheus监控系统之入门篇</a>。<br>前置条件是安装配置好了docker环境，安装方法参考<a href="https://www.voidking.com/dev-docker-start/">《Docker入门》</a>。已知docker宿主机IP为192.168.56.102。</p><a id="more"></a><h1 id="prometheus-server"><a href="#prometheus-server" class="headerlink" title="prometheus server"></a>prometheus server</h1><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/r/prom/prometheus" target="_blank" rel="noopener">prometheus server</a>。</p><p>2、下载prometheus server镜像（以v2.18.0为例）<br><code>docker pull prom/prometheus:v2.18.0</code></p><p>3、创建配置文件<br>创建prometheus.yml，内容为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span> <span class="comment">#默认采集监控数据时间间隔</span></span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="attr">monitor:</span> <span class="string">'my-monitor'</span></span><br><span class="line"><span class="attr">scrape_configs:</span>  <span class="comment">#监控对象设置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">prometheus</span> <span class="comment">#任务名称</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span> <span class="comment">#每隔5s获取一次监控数据</span></span><br><span class="line">    <span class="attr">static_configs:</span> <span class="comment">#监控对象地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['127.0.0.1:9090']</span>  <span class="comment"># 将自己加入到监控对象中</span></span><br></pre></td></tr></table></figure><p>创建rules.yml，内容为空。</p><p>4、启动prometheus server</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run <span class="params">--name=prometheus</span> -d \</span><br><span class="line">-p 9090<span class="function">:9090</span> \</span><br><span class="line">-v $<span class="params">(pwd)</span><span class="string">/prometheus.yml</span>:<span class="string">/etc/prometheus/prometheus.yml</span> \</span><br><span class="line">-v $<span class="params">(pwd)</span><span class="string">/rules.yml</span>:<span class="string">/etc/prometheus/rules.yml</span> \</span><br><span class="line">prom/prometheus<span class="function">:v2.18.0</span> <span class="params">--config</span>.file=<span class="string">/etc/prometheus/prometheus.yml</span> <span class="params">--web</span>.enable-lifecycle</span><br></pre></td></tr></table></figure><p>5、测试服务<br>浏览器访问 <a href="http://192.168.56.102:9090/" target="_blank" rel="noopener">http://192.168.56.102:9090/</a><br><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/graph.jpg?imageView2/0/w/800" alt=""></p><p>6、查看targets<br>浏览器访问 <a href="http://192.168.56.102:9090/targets/" target="_blank" rel="noopener">http://192.168.56.102:9090/targets/</a><br><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/targets.jpg?imageView2/0/w/800" alt=""></p><p>7、查看指标<br>浏览器访问 <a href="http://192.168.56.102:9090/metrics/" target="_blank" rel="noopener">http://192.168.56.102:9090/metrics/</a><br><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/metrics.jpg?imageView2/0/w/800" alt=""></p><h1 id="node-exporter"><a href="#node-exporter" class="headerlink" title="node exporter"></a>node exporter</h1><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/r/prom/node-exporter" target="_blank" rel="noopener">node exporter</a>。</p><p>2、下载node-exporter镜像（以v1.0.0为例）<br><code>docker pull prom/node-exporter:v1.0.0</code></p><p>3、启动node exporter</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="attr">name=</span><span class="keyword">node</span><span class="title">-exporter</span> -d \</span><br><span class="line">-p <span class="number">9100</span>:<span class="number">9100</span> \</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">docker run --<span class="attr">name=</span><span class="keyword">node</span><span class="title">-exporter</span> -d \</span><br><span class="line">  -p <span class="number">9100</span>:<span class="number">9100</span> \</span><br><span class="line">  --<span class="attr">net=</span><span class="string">"host"</span> \</span><br><span class="line">  --<span class="attr">pid=</span><span class="string">"host"</span> \</span><br><span class="line">  -v <span class="string">"/:/host:ro,rslave"</span> \</span><br><span class="line">  prom/<span class="keyword">node</span>-exporter:<span class="title">v1</span>.<span class="number">0.0</span> \</span><br><span class="line">  --path.<span class="attr">rootfs=</span>/host</span><br></pre></td></tr></table></figure><h1 id="promserver收集exporter数据"><a href="#promserver收集exporter数据" class="headerlink" title="promserver收集exporter数据"></a>promserver收集exporter数据</h1><p>1、修改prometheus.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span> <span class="comment">#默认采集监控数据时间间隔</span></span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="attr">monitor:</span> <span class="string">'my-monitor'</span></span><br><span class="line"><span class="attr">scrape_configs:</span>  <span class="comment">#监控对象设置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">prometheus</span> <span class="comment">#任务名称</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span> <span class="comment">#每隔5s获取一次监控数据</span></span><br><span class="line">    <span class="attr">static_configs:</span> <span class="comment">#监控对象地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['127.0.0.1:9090']</span>  <span class="comment"># 将自己加入到监控对象中</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.56.102:9100']</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">'client-node-exporter'</span></span><br></pre></td></tr></table></figure><p>2、重新加载配置文件<br><code>curl -X POST http://localhost:9090/-/reload</code><br>然而我重新加载配置文件并不生效，最后重启了prometheus server。</p><p>3、查看targets<br>浏览器访问 <a href="http://192.168.56.102:9090/targets/" target="_blank" rel="noopener">http://192.168.56.102:9090/targets/</a><br><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/targets2.png?imageView2/0/w/800" alt=""></p><h1 id="push-gateway"><a href="#push-gateway" class="headerlink" title="push gateway"></a>push gateway</h1><p>Prometheus采集数据是用的pull方式，prometheus配置文件设置的5秒就是采集数据的频率。但是有些数据并不适合采用这样的方式，对这样的数据可以使用Push Gateway服务。PushGateway比较适合临时作业和批处理作业，由于这些作业是short-lived的，如果采用pull的模式，可能在prometheus采集之前，作业已经执行结束。pushgateway相当于一个暂存器，这些临时作业将metrics数据缓存到pushgateway中，然后等待Prometheus来pull数据。</p><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/r/prom/pushgateway" target="_blank" rel="noopener">pushgateway</a>。</p><p>2、下载pushgateway镜像（以v1.1.0为例）<br><code>docker pull prom/pushgateway:v1.1.0</code></p><p>3、启动push gateway</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --name=pushgateway -d \</span><br><span class="line">-p <span class="number">9091</span>:<span class="number">9091</span> \</span><br><span class="line">prom/pushgateway:v1<span class="number">.1</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>4、测试服务<br>浏览器访问 <a href="http://192.168.56.102:9091/#" target="_blank" rel="noopener">http://192.168.56.102:9091/#</a><br><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/pushgateway.png?imageView2/0/w/800" alt=""></p><p>5、推送数据给push gateway</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="string">"exam_metric 100"</span> | curl --data-binary @- <span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:9091/metrics</span><span class="regexp">/job/exam</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | curl --data-binary @- <span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:9091/metrics</span><span class="regexp">/job/exam</span><span class="regexp">/instance/test</span></span><br><span class="line">chinese <span class="number">120</span></span><br><span class="line">math <span class="number">150</span></span><br><span class="line">english <span class="number">140</span></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/pushgateway2.png?imageView2/0/w/800" alt=""></p><h1 id="promserver收集pushgateway数据"><a href="#promserver收集pushgateway数据" class="headerlink" title="promserver收集pushgateway数据"></a>promserver收集pushgateway数据</h1><p>1、修改prometheus.yml文件</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">global</span>:</span><br><span class="line">  <span class="attribute">scrape_interval</span>: <span class="number">15s</span> #默认采集监控数据时间间隔</span><br><span class="line">  <span class="attribute">external_labels</span>:</span><br><span class="line">    <span class="attribute">monitor</span>: <span class="string">'my-monitor'</span></span><br><span class="line"><span class="attribute">scrape_configs</span>:  #监控对象设置</span><br><span class="line">  - <span class="attribute">job_name</span>: prometheus #任务名称</span><br><span class="line">    <span class="attribute">scrape_interval</span>: <span class="number">5s</span> #每隔<span class="number">5s</span>获取一次监控数据</span><br><span class="line">    <span class="attribute">static_configs</span>: #监控对象地址</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'127.0.0.1:9090'</span>]  # 将自己加入到监控对象中</span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'192.168.56.102:9100'</span>]</span><br><span class="line">        <span class="attribute">labels</span>:</span><br><span class="line">          <span class="attribute">group</span>: <span class="string">'client-node-exporter'</span></span><br><span class="line">      - <span class="attribute">targets</span>: [<span class="string">'192.168.56.102:9091'</span>]</span><br><span class="line">        <span class="attribute">labels</span>:</span><br><span class="line">          <span class="attribute">group</span>: <span class="string">'pushgateway'</span></span><br></pre></td></tr></table></figure><p>2、重新加载配置或者重启promserver</p><p>3、在promserver查看数据<br><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/chinese.png?imageView2/0/w/800" alt=""></p><h1 id="alertmanager"><a href="#alertmanager" class="headerlink" title="alertmanager"></a>alertmanager</h1><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/r/prom/alertmanager" target="_blank" rel="noopener">alertmanager</a>。</p><p>2、下载alertmanager镜像（以v0.15.0为例）<br><code>docker pull prom/alertmanager:v0.15.0</code></p><p>高版本比如v0.20.0打开页面后会报错，Uncaught TypeError: Cannot read property ‘elmFs’ of undefined</p><p>3、创建配置文件alertmanager.yml</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">global</span>:</span><br><span class="line">  <span class="attribute">resolve_timeout</span>: <span class="number">5</span>m</span><br><span class="line"><span class="attribute">route</span>:</span><br><span class="line">  <span class="attribute">group_by</span>: [<span class="string">'exam'</span>]  #与prometheus配置文件rules.yml中配置规则名对应</span><br><span class="line">  <span class="attribute">group_wait</span>: <span class="number">10s</span> #报警等待时间</span><br><span class="line">  <span class="attribute">group_interval</span>: <span class="number">10s</span> #报警间隔时间</span><br><span class="line">  <span class="attribute">repeat_interval</span>: <span class="number">1</span>m #重复报警间隔时间</span><br><span class="line">  <span class="attribute">receiver</span>: <span class="string">'web.hook'</span> #告警处理方式，我们这里通过web.hook方式，也可以配置成邮件等方式</span><br><span class="line"><span class="attribute">receivers</span>:</span><br><span class="line">  - <span class="attribute">name</span>: <span class="string">'web.hook'</span></span><br><span class="line">    <span class="attribute">webhook_configs</span>:</span><br><span class="line">      - <span class="attribute">url</span>: <span class="string">'http://192.168.56.102:8080/exam/test'</span> #告警webhook地址，告警信息会post到该地址，需要编写服务接收该告警数据</span><br><span class="line"><span class="attribute">inhibit_rules</span>:</span><br><span class="line">  - <span class="attribute">source_match</span>:</span><br><span class="line">      <span class="attribute">severity</span>: <span class="string">'critical'</span></span><br><span class="line">    <span class="attribute">target_match</span>:</span><br><span class="line">      <span class="attribute">severity</span>: <span class="string">'warning'</span> #目标告警状态</span><br><span class="line">    <span class="attribute">equal</span>: [<span class="string">'alertname'</span>, <span class="string">'dev'</span>, <span class="string">'instance'</span>]</span><br></pre></td></tr></table></figure><p>4、启动push gateway</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> <span class="attribute">--name</span>=alertmanager -d \</span><br><span class="line">-p 9093:9093 \</span><br><span class="line">-v $(pwd)/alertmanager.yml:/etc/alertmanager/alertmanager.yml \</span><br><span class="line">prom/alertmanager:v0.20.0 --config.<span class="attribute">file</span>=/etc/alertmanager/alertmanager.yml --storage.<span class="attribute">path</span>=/alertmanager</span><br></pre></td></tr></table></figure><p>5、测试服务<br>浏览器访问 <a href="http://192.168.56.102:9093/" target="_blank" rel="noopener">http://192.168.56.102:9093/</a><br><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/alertmanager.png?imageView2/0/w/800" alt=""></p><h1 id="告警配置"><a href="#告警配置" class="headerlink" title="告警配置"></a>告警配置</h1><p>1、编辑rules.yml，设置报警规则</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">exam</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">alert:</span> <span class="string">exam告警测试</span></span><br><span class="line">        <span class="attr">expr:</span> <span class="string">chinese</span> <span class="string">&gt;</span> <span class="number">100</span> <span class="comment">#语文成绩大于100告警，注：我们在pushgateway推送数据的时候，设置的是120，因此会触发告警</span></span><br><span class="line">        <span class="attr">for:</span> <span class="string">1m</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">status:</span> <span class="string">warning</span></span><br><span class="line">        <span class="attr">annotations:</span></span><br><span class="line">          <span class="attr">summary:</span> <span class="string">"<span class="template-variable">&#123;&#123;$labels.instance&#125;&#125;</span>:语文成绩优秀! nb了!!!"</span></span><br><span class="line">          <span class="attr">description:</span> <span class="string">"<span class="template-variable">&#123;&#123;$labels.instance&#125;&#125;</span>: 语文成绩优秀! nbnbnb!!!"</span></span><br></pre></td></tr></table></figure><p>2、编辑prometheus.yml配置文件，添加alertmanager配置和rules.yml文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">scrape_interval:</span> <span class="string">15s</span> <span class="comment">#默认采集监控数据时间间隔</span></span><br><span class="line">  <span class="attr">external_labels:</span></span><br><span class="line">    <span class="attr">monitor:</span> <span class="string">'my-monitor'</span></span><br><span class="line"><span class="attr">scrape_configs:</span>  <span class="comment">#监控对象设置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">job_name:</span> <span class="string">prometheus</span> <span class="comment">#任务名称</span></span><br><span class="line">    <span class="attr">scrape_interval:</span> <span class="string">5s</span> <span class="comment">#每隔5s获取一次监控数据</span></span><br><span class="line">    <span class="attr">static_configs:</span> <span class="comment">#监控对象地址</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['127.0.0.1:9090']</span>  <span class="comment"># 将自己加入到监控对象中</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.56.102:9100']</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">'client-node-exporter'</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.56.102:9091']</span></span><br><span class="line">        <span class="attr">labels:</span></span><br><span class="line">          <span class="attr">group:</span> <span class="string">'pushgateway'</span></span><br><span class="line"><span class="attr">rule_files:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">/etc/prometheus/rules.yml</span>   <span class="comment">#告警规则文件路径</span></span><br><span class="line"><span class="attr">alerting:</span>   <span class="comment">#告警管理器设置</span></span><br><span class="line">  <span class="attr">alertmanagers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">static_configs:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">targets:</span> <span class="string">['192.168.56.102:9093']</span> <span class="comment">#告警信息会发送给alertmanager进一步处理</span></span><br></pre></td></tr></table></figure><p>3、重新加载配置或者重启promserver</p><p>4、在alertmanager查看alerts<br><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/alert.png?imageView2/0/w/800" alt=""></p><h1 id="告警通知处理"><a href="#告警通知处理" class="headerlink" title="告警通知处理"></a>告警通知处理</h1><p>alertmanager.yml文件中配置的告警方式是webhook，告警发送到 <a href="http://192.168.56.102:8080/exam/test" target="_blank" rel="noopener">http://192.168.56.102:8080/exam/test</a> ，因此，我们需要一个服务来接收处理这个告警。</p><p>1、安装golang环境，参考<a href="https://www.voidking.com/dev-centos7-beego-env/">《CentOS7部署beego项目》</a>golang安装一节</p><p>2、创建main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"io/ioutil"</span></span><br><span class="line"><span class="string">"github.com/gin-gonic/gin"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.POST(<span class="string">"/exam/test"</span>, <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">res, _ := ioutil.ReadAll(c.Request.Body)</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(res)) <span class="comment">//这里我们只简单打印告警信息</span></span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">"message"</span>: <span class="string">"alert message"</span>,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run(<span class="string">":8080"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、运行代码</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="built_in">get</span> github.<span class="keyword">com</span>/gin-gonic/gin</span><br><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><p><img src="http://cdn.voidking.com/@/imgs/docker-prometheus/webhook.png?imageView2/0/w/800" alt=""><br>如上图，服务接收到了告警信息。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上，配置完成了promserver、exporter、pushgateway、alertmanager，跑通了数据的收集和显示，测试了告警信息的收集。本文就到这里，需要用到prometheus的其他内容时，再继续学习，比如<a href="https://thanos.io/" target="_blank" rel="noopener">thanos</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Prometheus简介&quot;&gt;&lt;a href=&quot;#Prometheus简介&quot; class=&quot;headerlink&quot; title=&quot;Prometheus简介&quot;&gt;&lt;/a&gt;Prometheus简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Prometheus是在SoundCloud的基础上构建的开源系统监视和警报工具。自从2012年以来，许多公司和组织都采用了Prometheus，该项目拥有非常活跃的开发人员和用户社区。现在，它是一个独立的开源项目，并且独立于任何公司进行维护。为了强调这一点并阐明项目的治理结构，Prometheus在2016年加入了Cloud Native Computing Foundation，这是继Kubernetes之后的第二个托管项目。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Prometheus的主要特性包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个包含时间序列的多维数据模型，由指标名称和键值对进行标记&lt;/li&gt;
&lt;li&gt;PromQL，一种灵活的查询语言&lt;/li&gt;
&lt;li&gt;不依赖分布式存储；单服务器节点是自治的&lt;/li&gt;
&lt;li&gt;时间序列收集是通过HTTP拉取模型实现的&lt;/li&gt;
&lt;li&gt;支持通过中间网关推送时间序列&lt;/li&gt;
&lt;li&gt;通过服务发现或静态配置发现目标&lt;/li&gt;
&lt;li&gt;支持多种图形和仪表板&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Prometheus生态系统包含多个组件，其中许多是可选的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prometheus server，负责收取并存储时间序列数据&lt;/li&gt;
&lt;li&gt;client libraries，用于检测应用程序代码&lt;/li&gt;
&lt;li&gt;push gateway，支持短期工作&lt;/li&gt;
&lt;li&gt;exporters，适用于特定服务的指标收集器，如HAProxy，StatsD，Graphite&lt;/li&gt;
&lt;li&gt;alertmanager，处理报警&lt;/li&gt;
&lt;li&gt;各种支持工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更多内容参考&lt;a href=&quot;https://prometheus.io/docs/introduction/overview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Prometheus文档&lt;/a&gt;。&lt;br&gt;本文中，我们会使用Docker来安装配置Prometheus，主要参考&lt;a href=&quot;https://www.cnblogs.com/informatics/p/12215255.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Prometheus监控系统之入门篇&lt;/a&gt;。&lt;br&gt;前置条件是安装配置好了docker环境，安装方法参考&lt;a href=&quot;https://www.voidking.com/dev-docker-start/&quot;&gt;《Docker入门》&lt;/a&gt;。已知docker宿主机IP为192.168.56.102。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
      <category term="监控" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/%E7%9B%91%E6%8E%A7/"/>
    
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
      <category term="centos" scheme="https://www.voidking.com/tags/centos/"/>
    
      <category term="监控" scheme="https://www.voidking.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
      <category term="prometheus" scheme="https://www.voidking.com/tags/prometheus/"/>
    
  </entry>
  
  <entry>
    <title>httpload使用说明</title>
    <link href="https://www.voidking.com/dev-httpload/"/>
    <id>https://www.voidking.com/dev-httpload/</id>
    <published>2020-06-05T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="httpload简介"><a href="#httpload简介" class="headerlink" title="httpload简介"></a>httpload简介</h1><p>http_load可以并行启动多个http请求，以便测试Web服务器的吞吐量。<br>但是，与大多数测试客户端不同的是，它是单线程运行的，因此不会使客户端计算机产生大量负载。<br>此外，http_load还可以配置支持https请求。<br>更多内容参考<a href="http://www.acme.com/software/http_load/" target="_blank" rel="noopener">http_load - multiprocessing http test client</a>。</p><a id="more"></a><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>1、安装openssl，以便支持https</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum <span class="keyword">install</span> openssl</span><br><span class="line">yum <span class="keyword">install</span> openssl-devel</span><br></pre></td></tr></table></figure><p>2、下载httpload并解压</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># wget http:<span class="comment">//acme.com/software/http_load/http_load-12mar2006.tar.gz</span></span><br><span class="line">wget http:<span class="comment">//www.acme.com/software/http_load/http_load-09Mar2016.tar.gz</span></span><br><span class="line">tar -xzvf http_load<span class="number">-09</span>Mar2016.tar.gz</span><br><span class="line">cd http_load<span class="number">-09</span>Mar2016/</span><br></pre></td></tr></table></figure><p>3、编辑Makefile，取消SSL相关注释</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SSL_TREE =     <span class="regexp">/usr/local</span><span class="regexp">/ssl</span></span><br><span class="line"><span class="regexp">SSL_DEFS =     -DUSE_SSL</span></span><br><span class="line"><span class="regexp">SSL_INC =      -I$(SSL_TREE)/include</span></span><br><span class="line">SSL_LIBS =     -L$(SSL_TREE)/<span class="class"><span class="keyword">lib</span> -<span class="title">lssl</span> -<span class="title">lcrypto</span></span></span><br></pre></td></tr></table></figure><p>4、编译不安装<br><code>make</code><br>执行命令后，当前目录下生成可执行文件 http_load</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>1、查看帮助<br><code>./http_load --help</code></p><p>2、创建文件 url.list</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">https:</span><span class="comment">//www.baidu.com</span></span><br></pre></td></tr></table></figure><p>3、启动测试</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./http_load -s <span class="number">10</span> -p <span class="number">1</span> -r <span class="number">10</span> url.<span class="type">list</span></span><br><span class="line">./http_load -s <span class="number">180</span> -p <span class="number">1</span> -r <span class="number">10</span> -timeout <span class="number">1</span> url.<span class="type">list</span></span><br><span class="line">./http_load -seconds <span class="number">180</span> -parallel <span class="number">1</span> -rate <span class="number">10</span> -timeout <span class="number">1</span> url.<span class="type">list</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;httpload简介&quot;&gt;&lt;a href=&quot;#httpload简介&quot; class=&quot;headerlink&quot; title=&quot;httpload简介&quot;&gt;&lt;/a&gt;httpload简介&lt;/h1&gt;&lt;p&gt;http_load可以并行启动多个http请求，以便测试Web服务器的吞吐量。&lt;br&gt;但是，与大多数测试客户端不同的是，它是单线程运行的，因此不会使客户端计算机产生大量负载。&lt;br&gt;此外，http_load还可以配置支持https请求。&lt;br&gt;更多内容参考&lt;a href=&quot;http://www.acme.com/software/http_load/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http_load - multiprocessing http test client&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="基础" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="测试" scheme="https://www.voidking.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile中的CMD和ENTRYPOINT</title>
    <link href="https://www.voidking.com/dev-dockerfile-cmd-entrypoint/"/>
    <id>https://www.voidking.com/dev-dockerfile-cmd-entrypoint/</id>
    <published>2020-04-28T10:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Dockerfile中的CMD和ENTRYPOINT有什么区别？<br>docker run时默认执行什么命令，怎样覆盖默认命令？<br>pod定义中的args和command字段有什么作用？<br>本文，我们来回答一下这些问题。主要参考<a href="https://goinbigdata.com/docker-run-vs-cmd-vs-entrypoint/" target="_blank" rel="noopener">Docker RUN vs CMD vs ENTRYPOINT</a>和<a href="https://www.udemy.com/user/mumshad-mannambeth/" target="_blank" rel="noopener">Mumshad Mannambeth的课程</a>。</p><a id="more"></a><h1 id="指令执行方式"><a href="#指令执行方式" class="headerlink" title="指令执行方式"></a>指令执行方式</h1><p>RUN和ENTRYPOINT指令都可以有两种执行方式：shell方式和exec方式。</p><h2 id="shell方式"><a href="#shell方式" class="headerlink" title="shell方式"></a>shell方式</h2><p>shell方式格式：<br><code>&lt;instruction&gt; &lt;command&gt;</code></p><p>例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install python3</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello world"</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello world"</span></span></span><br></pre></td></tr></table></figure><p>当指令以shell方式执行时，它会在后台调用 <code>/bin/sh -c &lt;command&gt;</code>，并且会进行常规的shell处理。例如，Dockerfile中的以下定义：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name voidking</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Hello, <span class="variable">$name</span>"</span></span></span><br></pre></td></tr></table></figure><p>docker run 会输出 <code>Hello, voidking</code> ，变量会被替换。</p><h2 id="exec方式"><a href="#exec方式" class="headerlink" title="exec方式"></a>exec方式</h2><p>exec方式格式：<br><code>&lt;instruction&gt; [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...]</code><br>例子：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> [<span class="string">"apt-get"</span>, <span class="string">"install"</span>, <span class="string">"python3"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/echo"</span>, <span class="string">"Hello world"</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>, <span class="string">"Hello world"</span>]</span></span><br></pre></td></tr></table></figure><p>当指令以exec方式执行时，它将直接调用可执行文件，并且不会进行shell处理。例如，Dockerfile中的以下定义：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name voidking</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/echo"</span>, <span class="string">"Hello, <span class="variable">$name</span>"</span>]</span></span><br></pre></td></tr></table></figure><p>docker run 会输出 <code>Hello, $name</code> ，变量不会被替换。</p><p>如果需要运行bash而不是sh，需要使用exec方式。在这种情况下，将进行常规的shell处理。例如，Dockerfile中的以下定义：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> name voidking</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"/bin/bash"</span>, <span class="string">"-c"</span>, <span class="string">"echo Hello, <span class="variable">$name</span>"</span>]</span></span><br></pre></td></tr></table></figure><p>docker run 会输出 <code>Hello, voidking</code> ，变量会被替换。</p><h1 id="CMD和ENTRYPOINT"><a href="#CMD和ENTRYPOINT" class="headerlink" title="CMD和ENTRYPOINT"></a>CMD和ENTRYPOINT</h1><h2 id="CMD定义"><a href="#CMD定义" class="headerlink" title="CMD定义"></a>CMD定义</h2><p>访问<a href="https://hub.docker.com/_/ubuntu?tab=description" target="_blank" rel="noopener">dockerhub ubuntu</a>，Supported tags and respective Dockerfile links，随便选择一个系统版本，这里选择 16.04 。点击链接，可以看到Dockerfile的定义。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch</span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># overlook all the definition</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"/bin/bash"</span>]</span></span><br></pre></td></tr></table></figure><p>可以看到，Dockerfile中定义了CMD为 <code>/bin/bash</code> ，也就是定义了默认命令为 <code>/bin/bash</code>。</p><p><code>docker run ubuntu:16.04</code> 会执行默认命令 <code>/bin/bash</code> 。</p><h2 id="执行特定命令"><a href="#执行特定命令" class="headerlink" title="执行特定命令"></a>执行特定命令</h2><p>我们想要执行命令，那么需要在docker run时指定命令，覆盖默认命令。<br><code>docker run ubuntu:16.04 sleep 3600</code>，会执行 <code>sleep 3600</code> 。</p><p>如果想要使这个特定命令永久生效，那么需要使用Dockerfile定义一个新的镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"sleep"</span>,<span class="string">"3600"</span>]</span></span><br></pre></td></tr></table></figure><p><code>docker build -t ubuntu-sleeper .</code>，生成新的镜像。</p><p><code>docker run ubuntu-sleeper</code>，执行默认命令 <code>sleep 3600</code> 。</p><h2 id="特定参数"><a href="#特定参数" class="headerlink" title="特定参数"></a>特定参数</h2><p>如果我们想要修改sleep的时间，该怎么做？</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run ubuntu:<span class="number">16.04</span> sleep <span class="number">3600</span></span><br><span class="line">docker run ubuntu:<span class="number">16.04</span> sleep <span class="number">1200</span></span><br></pre></td></tr></table></figure><p>sleep命令没有变，变化的只有参数，sleep是否可以省略？可以的，定义一个新的镜像。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> [<span class="string">"sleep"</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">"3600"</span>]</span></span><br></pre></td></tr></table></figure><p><code>docker build -t ubuntu-sleeper .</code>，生成新的镜像。</p><p><code>docker run ubuntu-sleeper</code>，执行默认命令 <code>sleep 3600</code> 。</p><p><code>docker run ubuntu-sleeper 1200</code>，执行命令 <code>sleep 1200</code> 。</p><p>那么，ENTRYPOINT里的命令是否可以被替换的呢？也是可以的。<br><code>docker run --entrypoint sleep2.0 ubuntu-sleeper 1200</code>，执行命令 <code>sleep2.0 1200</code> 。</p><p>综上，docker run会默认执行 <code>ENTRYPOINT + CMD</code>。<br>通常情况下，我们会在Dockerfile中定义ENTRYPOINT作为固定命令，定义CMD作为默认参数。</p><h1 id="args和command"><a href="#args和command" class="headerlink" title="args和command"></a>args和command</h1><p>在k8s中定义pod时，有args和command两个字段。这两个字段，分别覆盖CMD和ENTRYPOINT。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">apiVersion</span>: v1</span><br><span class="line"><span class="attribute">kind</span>: Pod</span><br><span class="line"><span class="attribute">metadata</span>:</span><br><span class="line">  <span class="attribute">creationTimestamp</span>: null</span><br><span class="line">  <span class="attribute">labels</span>:</span><br><span class="line">    <span class="attribute">run</span>: ubuntu</span><br><span class="line">  <span class="attribute">name</span>: ubuntu</span><br><span class="line"><span class="attribute">spec</span>:</span><br><span class="line">  <span class="attribute">containers</span>:</span><br><span class="line">  - <span class="attribute">image</span>: <span class="attribute">ubuntu</span>:<span class="number">16.04</span></span><br><span class="line">    <span class="attribute">name</span>: ubuntu</span><br><span class="line">    <span class="attribute">resources</span>: &#123;&#125;</span><br><span class="line">    <span class="attribute">command</span>: [<span class="string">"sleep"</span>]</span><br><span class="line">    <span class="attribute">args</span>: [<span class="string">"1200"</span>]</span><br><span class="line">  <span class="attribute">dnsPolicy</span>: ClusterFirst</span><br><span class="line">  <span class="attribute">restartPolicy</span>: Always</span><br><span class="line"><span class="attribute">status</span>: &#123;&#125;</span><br></pre></td></tr></table></figure><p>该pod启动后的执行命令为 <code>sleep 1200</code> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Dockerfile中的CMD和ENTRYPOINT有什么区别？&lt;br&gt;docker run时默认执行什么命令，怎样覆盖默认命令？&lt;br&gt;pod定义中的args和command字段有什么作用？&lt;br&gt;本文，我们来回答一下这些问题。主要参考&lt;a href=&quot;https://goinbigdata.com/docker-run-vs-cmd-vs-entrypoint/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Docker RUN vs CMD vs ENTRYPOINT&lt;/a&gt;和&lt;a href=&quot;https://www.udemy.com/user/mumshad-mannambeth/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Mumshad Mannambeth的课程&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>怎样做出可口的食物？</title>
    <link href="https://www.voidking.com/essay-how-to-cook-good-food/"/>
    <id>https://www.voidking.com/essay-how-to-cook-good-food/</id>
    <published>2020-04-19T19:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>记不得新冠疫情开始的具体时间，只知道今年的春节（2020年1月25日），没有出去拜年，春节期间也没有出去聚餐。然后，疫情日益严重，继湖北武汉之后，各市也开始封城。<br>复工日期一推再推，2月15日经历了两次信息登记，三次体温检测，顺利返回北京。先去社区办理观察证，小区内隔离两周，拿到出入证，还要录入人脸识别，以便进出小区。<br>3月9日年后第一次上班，需要查询近期行程，测量体温，才能进入达美中心。复工后三周休两周，直到最近，才每周上班。但是，仍然不敢在外面吃饭，因为多人用餐是最容易传播新冠的途径。</p><p>因此，厨道大兴！而小编不才也加入了自己做饭的行列，毕竟自己做才最放心。做的多了，自然不能只满足于能吃，而要追求好吃。</p><a id="more"></a><h1 id="秘诀"><a href="#秘诀" class="headerlink" title="秘诀"></a>秘诀</h1><p>用最少的调料，最简单的烹饪方法，最大程度发挥出食物本来的味道。</p><p>1、糖，是万能的，别怕，不管是任何菜式，出锅前放一丢丢，总会遇到你想要的味道。糖，不是为了让菜变得甜腻，而是作为味引，激发出足以挑拨你味蕾的口感。</p><p>2、豆瓣酱在肉类处理上，是不会犯错的存在，最简单的，放油，放豆瓣酱和肉沫，加一点点料酒去腥，就可以得到满满一碗辣肉面的肉酱，放在冰箱里吧，什么时候饿了，下碗面条浇一点这个肉酱上去，端在面前，是一碗面条吗？不，是一碗准备时间只需要5分钟的幸福。</p><p>3、蚝油在好多素菜的处理上，完全可以替代盐，而且有着盐没有的那股“鲜”味，最直接的就是花菜，尤其是干锅花菜。洗干净沥干，然后下油，放一点点花椒或者辣椒，吧花菜放进去，一滴水也不要加，感觉差不多了，放耗油+生抽，别放盐，出锅，有追求的就再放些五花肉片进去，尝尝，是不是觉得外面的干锅简直是垃圾？</p><p>4、初学者，不要想着一气呵成，很多东西是可以在烹饪过程中不断调整的，容错性巨高，特别是烹饪时间较长的菜式，例如蒸菜。大个比方：梅干菜扣肉，前面不罗嗦，就说上蒸锅开蒸之后，每隔半小时用筷子舔一下，觉得咸了赶紧吧里面的汁水逼出来一点，觉得淡了就加一勺老抽进去，觉得不够甜就放一小粒冰糖在边边，容错性巨高。</p><p>5、洋葱没有什么味道，它的全部价值在于增香。举个例子：最最最最简单的，炒鸡蛋，加一两片洋葱进去，感觉是两个菜。</p><p>6、刀工没有那么重要，现在的厨房懒人工具太多了，不要把时间浪费在练习刀工上，至少我是这么认为的，还容易受伤。</p><p>7、外面的菜口感总觉得和家里不一样，是因为外面的火，远远比家里的要旺，这个是煤气灶的硬伤，解决不了的，但也并不是没有一点办法，我个人的解决方案是，尤其在所谓的“爆炒”菜式中，会将火开至最大，然后将锅倾斜至很夸张的角度，目的是让火舌舔到锅里的油，这样就会有锅里起火的效果，温度非常之高，然后上盖子压灭，出锅。这招是我自己捣鼓出来的，有的时候实在是少油，火舌舔不到，我就在锅边边刷一点油。</p><p>8、汤类中的“鲜”，我指的是的寻常汤类，不外乎来自这四种东西——笋、肉、味精、白胡椒粉（评论提醒，还有一种，但我不经常做，就是菇类）。这也是我经常做的几道，极其方便。比如，上海菜中有一道“腌笃鲜”，冬笋、精肉、咸肉，一比一比一入锅，一大锅，熬着吧，啥也不用放，真的其他啥也不用放（姜片和料酒去腥还是必需的），1个小时后出锅，撒点葱花，冬天里简直是。。。王菲有首歌叫什么来着？天上人间是吧，诶。</p><p>再比如，我这边有个卖臭豆腐的，炸完后浸入一种汤里，巨好喝，问他怎么弄的，他摆摆手说是秘方，不外传。回家自己细细一品，转身进厨房，不说一模一样，但可以乱真——牛肉汤，味精、五香粉，酸豆角，白胡椒粉，香菜。就这么简单，还秘方不外传，啊我呸。</p><p>9、用猪油，比其他任何的大豆油或色拉油炒出来的菜，都要香，我用过一次就上瘾，唯一的缺点就是凝固点太高了（很多人评论纠正我是低？我也搞不明白了，如果普通油凝固需要零下1度，而猪油凝固零上5度，到底是谁高谁低呢？），很容易就变成膏体，冬天是需要用勺子挖的。</p><p>10、最后给个心得，其实厨艺这东西没有什么玄妙的，无非是经验而已，我一个人搁那捣鼓五六十年，出来绝对也是一等一的大师，总有个阴差阳错能让我悟到一些原本没人点拨到的TIPS，那为什么不去寻求身边的高手呢？比方，我吃番茄炒蛋，永远是淡而无味，加再多调味品都没办法拯救的哪种，结果我一朋友对我说，你说说你怎么弄的呢？说完，所有的步骤和路数都是OK的，唯一一点，出错了，炒番茄的时候没有用勺子用力压番茄，这样番茄里的酱汁就不会被压出来，也就没有办法裹在蛋上形成独特的口感了。我一听，大惊，对啊，就是这个道理。</p><p>再比方，那个薯条，我随便怎么都弄不出那种麦当劳的风味，口感一模一样，就是没有那种风味，最后问题出在，土豆切条之后需要用牛奶浸泡一晚上，没有牛奶用奶粉也可以，这样会有若有若无的奶香味道，味蕾再发达的人，别人不说，这种味道你要能领悟原材料估计得靠缘分。</p><p>你看，是不是一个很小的点拨？小到你压根不会去注意。</p><p>多问多讨教就对了。</p><p>11、最后的最后，大家都是一双手，厨艺这东西练练总会上去的，但巧妇难为无米之炊，家里的调料一定要齐全，不然就会变成我，经常戴着口罩围着围裙坐电梯到小区门口超市买缺的调料（那回头率老高了）。郫县豆瓣酱、料酒、老姜、蒜瓣、老抽（酱油）、生抽（鲜酱油）、香醋、白醋、白砂糖、老冰糖、白芝麻、小磨麻油、甜面酱、蚝油、辣椒面、五香粉、八角、桂皮、香叶、咖哩粉、白胡椒粉、鲜辣粉、花椒粉、椒盐、孜然粉、番茄酱、浓汤宝（牛肉、猪肉和老母鸡）、蜂蜜、老干妈豆豉酱。</p><p>这些调味品有共同的特征——1、保质期较长，常备着，不容易坏。2、使用频率极其频繁。3、要么不用，一旦那道菜式需要用到，而你恰恰缺少，那这道菜基本就属于做不了了，非要不可的那种。</p><h1 id="调味品"><a href="#调味品" class="headerlink" title="调味品"></a>调味品</h1><ul><li>油：大豆油即可，菜籽油更好。</li><li>盐：海盐、湖盐、井盐、岩盐，任选即可。</li><li>酱油：生抽，老抽。生抽一般用来蘸料，拌凉菜，或者是炒菜时提个鲜；老抽一般在红烧时做上色用。简单来说，拌菜炒菜用生抽，红烧用老抽。</li><li>醋：陈醋，白醋，米醋。陈醋用途最广，可以炒菜，可以凉拌，可以蘸酱，还能上色；白醋最大的用处体现在它的功能性，比如除臭除味、美肤养颜、洗涤除垢等等；米醋因为口味柔和，有着非常浓厚的香气，所以多用来凉拌。</li><li>糖：绵糖。</li><li>其他：十三香、干辣椒（小米椒）/辣椒粉、大茴香（孜然）/孜然粉、八角、花椒/花椒粉、桂皮、香叶、小茴香、芝麻、烧烤料。</li></ul><h1 id="烹饪"><a href="#烹饪" class="headerlink" title="烹饪"></a>烹饪</h1><p>万能流程：<br>1、放油，放肉，放料酒，翻炒。<br>2、放菜，翻炒。<br>3、放入调味料（最后放盐），翻炒。<br>4、根据经验，观察色泽，尝一尝，出锅。</p><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ul><li>APP：下厨房</li><li>保存土豆：纸箱+不透光</li><li>存肉：买来肉之后按一顿的份量切块，每块分别放入保鲜膜，冷冻。</li><li>化肉：盐+白醋</li><li>磨刀：碗底，同一个方向</li></ul><h1 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h1><p><a href="https://www.zhihu.com/question/21696230" target="_blank" rel="noopener">你是明白了哪几个基本原理之后而厨艺大增的？</a></p><p><a href="http://open.163.com/newview/movie/free?pid=MD96HFRVB&mid=MDHNHOJB3" target="_blank" rel="noopener">来自专业厨师的36个无价的烹饪技巧</a></p><p><a href="http://open.163.com/newview/movie/free?pid=MD96HFRVB&mid=MDCGPFIUS" target="_blank" rel="noopener">20个你不知道的聪明的烹饪技巧</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;记不得新冠疫情开始的具体时间，只知道今年的春节（2020年1月25日），没有出去拜年，春节期间也没有出去聚餐。然后，疫情日益严重，继湖北武汉之后，各市也开始封城。&lt;br&gt;复工日期一推再推，2月15日经历了两次信息登记，三次体温检测，顺利返回北京。先去社区办理观察证，小区内隔离两周，拿到出入证，还要录入人脸识别，以便进出小区。&lt;br&gt;3月9日年后第一次上班，需要查询近期行程，测量体温，才能进入达美中心。复工后三周休两周，直到最近，才每周上班。但是，仍然不敢在外面吃饭，因为多人用餐是最容易传播新冠的途径。&lt;/p&gt;
&lt;p&gt;因此，厨道大兴！而小编不才也加入了自己做饭的行列，毕竟自己做才最放心。做的多了，自然不能只满足于能吃，而要追求好吃。&lt;/p&gt;
    
    </summary>
    
    
      <category term="随笔" scheme="https://www.voidking.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>使用curl访问k8s的apiserver</title>
    <link href="https://www.voidking.com/dev-curl-k8s-api-server/"/>
    <id>https://www.voidking.com/dev-curl-k8s-api-server/</id>
    <published>2020-04-15T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.716Z</updated>
    
    <content type="html"><![CDATA[<h1 id="k8s管理工具"><a href="#k8s管理工具" class="headerlink" title="k8s管理工具"></a>k8s管理工具</h1><p>管理k8s集群，除了kubectl和go-client，其实还可以使用curl命令。<br>本文，我们就学习一下怎样使用curl访问k8s的apiserver，实现k8s集群的管理。主要参考<a href="https://www.codercto.com/a/89468.html" target="_blank" rel="noopener">如何使用curl访问k8s的apiserver</a>。</p><a id="more"></a><h1 id="查看pod"><a href="#查看pod" class="headerlink" title="查看pod"></a>查看pod</h1><p>需求：使用curl命令，实现 kubectl get pod 同样的效果。</p><h2 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h2><p>想要使用curl命令访问apiserver，首先要获得一个具有权限的token。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> secrets <span class="comment">--all-namespaces | grep admin</span></span><br><span class="line">kubectl describe secrets admin-<span class="keyword">token</span>-vmv2c -n kube-<span class="keyword">system</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Name:</span>         <span class="string">admin-token-vmv2c</span></span><br><span class="line"><span class="attr">Namespace:</span>    <span class="string">kube-system</span></span><br><span class="line"><span class="attr">Labels:</span>       <span class="string">&lt;none&gt;</span></span><br><span class="line"><span class="attr">Annotations:  kubernetes.io/service-account.name:</span> <span class="string">admin</span></span><br><span class="line">              <span class="attr">kubernetes.io/service-account.uid:</span> <span class="string">a75b4cdc-e120-11e9-8695-00163e300424</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Type:</span>  <span class="string">kubernetes.io/service-account-token</span></span><br><span class="line"></span><br><span class="line"><span class="string">Data</span></span><br><span class="line"><span class="string">====</span></span><br><span class="line"><span class="attr">ca.crt:</span>     <span class="number">1419</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">namespace:</span>  <span class="number">11</span> <span class="string">bytes</span></span><br><span class="line"><span class="attr">token:</span>      <span class="string">xxxthisisatokenxxx</span></span><br></pre></td></tr></table></figure><p>最后一个字段就是token，那么这个token有哪些权限呢？</p><h2 id="查看token权限"><a href="#查看token权限" class="headerlink" title="查看token权限"></a>查看token权限</h2><p>根据annotations中的key value，可以看到这个secrets绑定了一个service-account(sa)，name为admin。等同于这个token绑定了一个sa，name为admin。</p><p>查看admin这个service-account的信息。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> <span class="keyword">sa</span> --<span class="keyword">all</span>-namespaces | <span class="keyword">grep</span> admin</span><br><span class="line">kubectl describe <span class="keyword">sa</span> admin -n kube-<span class="built_in">system</span></span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Name:                admin</span><br><span class="line">Namespace:           kube-<span class="built_in">system</span></span><br><span class="line">Label<span class="variable">s:</span>              <span class="symbol">&lt;none&gt;</span></span><br><span class="line">Annotation<span class="variable">s:</span>         kubectl.kubernetes.io/<span class="keyword">last</span>-applied-configuration:</span><br><span class="line">                       &#123;<span class="string">"apiVersion"</span>:<span class="string">"v1"</span>,<span class="string">"kind"</span>:<span class="string">"ServiceAccount"</span>,<span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"admin"</span>,<span class="string">"namespace"</span>:<span class="string">"kube-system"</span>&#125;&#125;</span><br><span class="line">Image pull secret<span class="variable">s:</span>  <span class="symbol">&lt;none&gt;</span></span><br><span class="line">Mountable secret<span class="variable">s:</span>   admin-token-vmv2c</span><br><span class="line">Token<span class="variable">s:</span>              admin-token-vmv2c</span><br><span class="line">Event<span class="variable">s:</span>              <span class="symbol">&lt;none&gt;</span></span><br></pre></td></tr></table></figure><p>没有关于admin的权限信息，那么我们再看一下admin绑定了哪些role和clusterrole。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> rolebindings --<span class="keyword">all</span>-namespaces -oyaml | <span class="keyword">grep</span> <span class="string">"name: admin"</span> -A10 -B10</span><br><span class="line">kubectl <span class="built_in">get</span> clusterrolebindings --<span class="keyword">all</span>-namespaces -oyaml | <span class="keyword">grep</span> <span class="string">"name: admin"</span> -A10 -B10</span><br></pre></td></tr></table></figure><p>找到有用信息为：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line"><span class="symbol">  kind:</span> ClusterRoleBinding</span><br><span class="line"><span class="symbol">  metadata:</span></span><br><span class="line"><span class="symbol">    annotations:</span></span><br><span class="line">      kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">        &#123;<span class="string">"apiVersion"</span>:<span class="string">"rbac.authorization.k8s.io/v1beta1"</span>,<span class="string">"kind"</span>:<span class="string">"ClusterRoleBinding"</span>,<span class="string">"metadata"</span>:&#123;<span class="string">"annotations"</span>:&#123;&#125;,<span class="string">"name"</span>:<span class="string">"admin"</span>&#125;,<span class="string">"roleRef"</span>:&#123;<span class="string">"apiGroup"</span>:<span class="string">"rbac.authorization.k8s.io"</span>,<span class="string">"kind"</span>:<span class="string">"ClusterRole"</span>,<span class="string">"name"</span>:<span class="string">"cluster-admin"</span>&#125;,<span class="string">"subjects"</span>:[&#123;<span class="string">"kind"</span>:<span class="string">"ServiceAccount"</span>,<span class="string">"name"</span>:<span class="string">"admin"</span>,<span class="string">"namespace"</span>:<span class="string">"kube-system"</span>&#125;]&#125;</span><br><span class="line"><span class="symbol">    creationTimestamp:</span> <span class="string">"2019-09-27T12:16:37Z"</span></span><br><span class="line"><span class="symbol">    name:</span> admin</span><br><span class="line"><span class="symbol">    resourceVersion:</span> <span class="string">"1317"</span></span><br><span class="line"><span class="symbol">    selfLink:</span> <span class="meta-keyword">/apis/</span>rbac.authorization.k8s.io<span class="meta-keyword">/v1/</span>clusterrolebindings/admin</span><br><span class="line"><span class="symbol">    uid:</span> a75e1ef9-e120<span class="number">-11e9</span><span class="number">-8695</span><span class="number">-00163e300424</span></span><br><span class="line"><span class="symbol">  roleRef:</span></span><br><span class="line"><span class="symbol">    apiGroup:</span> rbac.authorization.k8s.io</span><br><span class="line"><span class="symbol">    kind:</span> ClusterRole</span><br><span class="line"><span class="symbol">    name:</span> cluster-admin</span><br><span class="line"><span class="symbol">  subjects:</span></span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line"><span class="symbol">    name:</span> admin</span><br><span class="line"><span class="symbol">    namespace:</span> kube-system</span><br></pre></td></tr></table></figure><p>可知admin绑定了一个名为cluster-admin的clusterrole，接着查看cluster-admin的权限。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe clusterrole <span class="keyword">cluster</span>-<span class="keyword">admin</span> -n kube-<span class="keyword">system</span></span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Name:         cluster-admin</span><br><span class="line">Labels:       kubernetes.io/<span class="attribute">bootstrapping</span>=rbac-defaults</span><br><span class="line">Annotations:  rbac.authorization.kubernetes.io/autoupdate: <span class="literal">true</span></span><br><span class="line">PolicyRule:</span><br><span class="line">  Resources  Non-Resource URLs <span class="built_in"> Resource </span>Names  Verbs</span><br><span class="line">  ---------  -----------------  --------------  -----</span><br><span class="line">  *.*        []                 []              [*]</span><br><span class="line">             [*]                []              [*]</span><br></pre></td></tr></table></figure><p>cluster-admin这个角色拥有集群的所有权限，因此admin这个sa拥有集群的所有权限。</p><h2 id="使用token"><a href="#使用token" class="headerlink" title="使用token"></a>使用token</h2><p>1、设置token和apiserver作为变量</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TOKEN=<span class="constructor">$(<span class="params">kubectl</span> <span class="params">describe</span> <span class="params">secrets</span> $(<span class="params">kubectl</span> <span class="params">get</span> <span class="params">secrets</span> -<span class="params">n</span> <span class="params">kube</span>-<span class="params">system</span> |<span class="params">grep</span> <span class="params">admin</span> |<span class="params">cut</span> -<span class="params">f1</span> -<span class="params">d</span> ' ')</span> -n kube-system <span class="pattern-match">|grep -<span class="constructor">E</span> '^token' |cut -f2 -d':'|tr -d '\t'|tr -d ' ')</span></span><br><span class="line"><span class="pattern-match"><span class="constructor">APISERVER</span>=<span class="constructor">$(<span class="params">kubectl</span> <span class="params">config</span> <span class="params">view</span> |<span class="params">grep</span> <span class="params">server</span>|<span class="params">cut</span> -<span class="params">f</span> 2- -<span class="params">d</span> <span class="string">":"</span> | <span class="params">tr</span> -<span class="params">d</span> <span class="string">" "</span>)</span></span></span><br><span class="line"><span class="pattern-match">``` </span></span><br><span class="line"><span class="pattern-match"></span></span><br><span class="line"><span class="pattern-match">2、查看<span class="constructor">API</span>的url，使用curl命令调用<span class="constructor">API</span></span></span><br></pre></td></tr></table></figure><p>kubectl get pods -v8<br>curl -H “Authorization: Bearer $TOKEN” $APISERVER/api/v1/namespaces/default/pods/  –insecure</p><p>```</p><p>以上，拿到了default空间下的pod信息，和 kubectl get pod 等同。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;k8s管理工具&quot;&gt;&lt;a href=&quot;#k8s管理工具&quot; class=&quot;headerlink&quot; title=&quot;k8s管理工具&quot;&gt;&lt;/a&gt;k8s管理工具&lt;/h1&gt;&lt;p&gt;管理k8s集群，除了kubectl和go-client，其实还可以使用curl命令。&lt;br&gt;本文，我们就学习一下怎样使用curl访问k8s的apiserver，实现k8s集群的管理。主要参考&lt;a href=&quot;https://www.codercto.com/a/89468.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;如何使用curl访问k8s的apiserver&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>PS绘制抛物线</title>
    <link href="https://www.voidking.com/hobby-ps-parabola/"/>
    <id>https://www.voidking.com/hobby-ps-parabola/</id>
    <published>2020-04-12T18:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><p>已有一张 draw.io 绘制出的图像如下。<br><img src="http://cdn.voidking.com/@/imgs/ps-parabola/parabola.png?imageView2/0/w/250" alt=""></p><p>现在需要在小球之间绘制平抛运动的抛物线。</p><a id="more"></a><h1 id="绘制方法"><a href="#绘制方法" class="headerlink" title="绘制方法"></a>绘制方法</h1><p>1、使用PS打开原始图像，使用 ctrl+加号 放大到合适的大小。</p><p>2、菜单栏图层，新建，图层。</p><p>3、工具栏选择钢笔工具。单击上面的小球，然后单击下面的小球并按住鼠标，向下拉伸，移动调整曲线的弧度。</p><p>4、右键曲线，建立选区，确定。或者直接 ctrl+Enter ，路径变成选区。</p><p>5、菜单栏编辑，描边，确定。<br>ctrl+D 取消选区，选中图层 Enter回车 去掉钢笔笔迹。</p><p>6、图层，只显示抛物线，工具栏选择橡皮擦工具，擦除不需要的部分。</p><p>7、图层，显示所有图层，即可看到需要的抛物线。</p><p>重复上述步骤，完成另外两条抛物线，最终结果如下图。<br><img src="http://cdn.voidking.com/@/imgs/ps-parabola/parabola.jpg?imageView2/0/w/250" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;&lt;p&gt;已有一张 draw.io 绘制出的图像如下。&lt;br&gt;&lt;img src=&quot;http://cdn.voidking.com/@/imgs/ps-parabola/parabola.png?imageView2/0/w/250&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在需要在小球之间绘制平抛运动的抛物线。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爱好" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/"/>
    
      <category term="电脑" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/%E7%94%B5%E8%84%91/"/>
    
    
      <category term="ps" scheme="https://www.voidking.com/tags/ps/"/>
    
  </entry>
  
  <entry>
    <title>MacOS设置</title>
    <link href="https://www.voidking.com/hobby-macos-settings/"/>
    <id>https://www.voidking.com/hobby-macos-settings/</id>
    <published>2020-04-08T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="系统相关"><a href="#系统相关" class="headerlink" title="系统相关"></a>系统相关</h1><h2 id="用户名"><a href="#用户名" class="headerlink" title="用户名"></a>用户名</h2><p>系统偏好设置，用户与群组，点按锁按钮以进行修改。右键用户，高级选项。<br>修改账户名称为vk，这个名称是shell中显示的用户名。<br>修改全名为voidking，这个名称是mac系统显示的名称。<br>个人目录，修改为 /Users/vk ，这个目录是新的home目录。</p><p>修改完成后点击“好”，系统重启，然后整个系统恢复到出厂状态。</p><a id="more"></a><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><p>系统偏好设置，用户与群组，更改密码。</p><h2 id="触控板"><a href="#触控板" class="headerlink" title="触控板"></a>触控板</h2><p>系统偏好设置，触控板，光标与点按。<br>勾选 轻点来点按，勾选 辅助点按，跟踪速度调整为喜欢的速度。 </p><h2 id="电脑名称"><a href="#电脑名称" class="headerlink" title="电脑名称"></a>电脑名称</h2><p>系统偏好设置，共享，电脑名称，编辑。</p><h2 id="开机声音"><a href="#开机声音" class="headerlink" title="开机声音"></a>开机声音</h2><p>1、关闭开机声音</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nvram BootAudio=%00</span><br><span class="line">sudo nvram SystemAudioVolume=%80</span><br></pre></td></tr></table></figure><p>2、打开开机声音</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo nvram BootAudio=%01</span><br><span class="line">sudo nvram -d SystemAudioVolume</span><br></pre></td></tr></table></figure><h2 id="查看文件"><a href="#查看文件" class="headerlink" title="查看文件"></a>查看文件</h2><p>使用mac系统的Finder，可以查看“我的所有文件”，但是这是假的，点击这个选项只能看到最近使用的一些文件。</p><p>解决办法：打开Finder，command＋逗号，出现Finder偏好设置，边栏，设备中勾选硬盘。然后在侧边栏中，就可以打开硬盘，看到所有文件了。</p><p>当然， /etc 这种文件夹是看不到的。</p><h2 id="打不开软件"><a href="#打不开软件" class="headerlink" title="打不开软件"></a>打不开软件</h2><p>从网络下载的软件，安装时提示：<br>打不开“xxx”，因为它来自身份不明的开发者。</p><p>解决办法：系统偏好设置，安全性和隐私，点锁按钮以进行更改，任何来源，允许来自任何来源。</p><h2 id="安装字体"><a href="#安装字体" class="headerlink" title="安装字体"></a>安装字体</h2><p>1、从windows系统 C:\Windows\Fonts 目录中拷贝需要的字体。<br>2、command+shift+G，输入 <code>/Library/Fonts</code>，前往。<br>3、字体放入 Fonts 目录。</p><h2 id="启动sftp"><a href="#启动sftp" class="headerlink" title="启动sftp"></a>启动sftp</h2><p>1、系统偏好设置，共享，勾选远程登录</p><p>、测试</p><p><code>sftp localhost</code></p><h1 id="软件相关"><a href="#软件相关" class="headerlink" title="软件相关"></a>软件相关</h1><h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><p>1、打开shell<br>command＋space，输入“terminal”。<br>或者 Launchpad，其他，终端。<br>为了方便使用，可以把终端放到Dock。</p><p>2、个性设置<br>在home目录下创建 .bash_profile 文件，内容为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ll</span></span><br><span class="line">alias ll="ls -l"</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> color</span></span><br><span class="line">export CLICOLOR=1</span><br><span class="line"><span class="meta">#</span><span class="bash"> \h:\W \u\$</span></span><br><span class="line">export PS1='\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] '</span><br><span class="line"><span class="meta">#</span><span class="bash"> grep</span></span><br><span class="line">alias grep='grep --color=always'</span><br></pre></td></tr></table></figure><p>更好的方式是，直接使用ohmyzsh，或者<a href="https://iterm2.com/" target="_blank" rel="noopener">iterm2</a>。</p><h2 id="ohmyzsh"><a href="#ohmyzsh" class="headerlink" title="ohmyzsh"></a>ohmyzsh</h2><p><a href="https://ohmyz.sh/" target="_blank" rel="noopener">Oh My Zsh</a> is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with thousands of helpful functions, helpers, plugins, themes, and a few things that make you shout…”Oh My ZSH!”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">sh -c "$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)"</span><br></pre></td></tr></table></figure><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>git配置参考<a href="https://www.voidking.com/dev-git-command/">《常用git命令》</a>。</p><h2 id="ssh-config"><a href="#ssh-config" class="headerlink" title="ssh config"></a>ssh config</h2><p>登录远程服务器，需要<br><code>ssh username@host -p port</code><br>在记忆这些信息是很麻烦的，因此我们需要一个简单的方法。</p><p>1、创建 .ssh/config 文件，内容为</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Host jumpbox</span><br><span class="line">HostName jumpbox.voidking.com</span><br><span class="line">User voidking</span><br><span class="line">Port 2345</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line"></span><br><span class="line">Host bastionhost</span><br><span class="line">HostName 45.68.78.134</span><br><span class="line">User root</span><br><span class="line">Port 3456</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>2、配置authorized_keys</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L https://raw.githubusercontent.com/beautifulcode/ssh-copy-id-for-OSX/master/install.sh | sh</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub jumpbox</span><br><span class="line">ssh-copy-id -i ~/.ssh/id_rsa.pub bastionhost</span><br></pre></td></tr></table></figure><p>3、登录服务器 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh jumpbox</span><br><span class="line">ssh bastionhost</span><br></pre></td></tr></table></figure><h2 id="sublime"><a href="#sublime" class="headerlink" title="sublime"></a>sublime</h2><p>sublime破解方法：</p><p>1、<code>vim /etc/hosts</code>，添加</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0.0.1</span> www.sublimetext.com</span><br><span class="line"><span class="number">127.0.0.1</span> license.sublimehq.com</span><br></pre></td></tr></table></figure><p>2、sublime中输入license</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">----- BEGIN LICENSE -----</span><br><span class="line">Member J2TeaM</span><br><span class="line">Single User License</span><br><span class="line">EA7E<span class="number">-1011316</span></span><br><span class="line">D7DA350E <span class="number">1</span>B8B0760 <span class="number">972</span>F8B60 F3E64036</span><br><span class="line">B9B4E234 F356F38F <span class="number">0</span>AD1E3B7 <span class="number">0E9</span>C5FAD</span><br><span class="line">FA0A2ABE <span class="number">25</span>F65BD8 D51458E5 <span class="number">3923</span>CE80</span><br><span class="line"><span class="number">87428428</span> <span class="number">79079</span>A01 AA69F319 A1AF29A4</span><br><span class="line">A684C2DC <span class="number">0</span>B1583D4 <span class="number">19</span>CBD290 <span class="number">217618</span>CD</span><br><span class="line"><span class="number">5653E0</span>A0 BACE3948 BB2EE45E <span class="number">422</span>D2C87</span><br><span class="line">DD9AF44B <span class="number">99</span>C49590 D2DBDEE1 <span class="number">75860</span>FD2</span><br><span class="line"><span class="number">8</span>C8BB2AD B2ECE5A4 EFC08AF2 <span class="number">25</span>A9B864</span><br><span class="line">------ END LICENSE ------</span><br></pre></td></tr></table></figure><h2 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h2><p>brew 全称<a href="http://brew.sh/index.html" target="_blank" rel="noopener">Homebrew</a>，是Mac OSX上的软件包管理工具。</p><p>安装brew：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"</span><br><span class="line"><span class="meta">#</span><span class="bash"> 国内安装失败的话，建议换下面的脚本</span></span><br><span class="line">/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"</span><br></pre></td></tr></table></figure><h2 id="iterm2"><a href="#iterm2" class="headerlink" title="iterm2"></a>iterm2</h2><p>安装<a href="https://iterm2.com/" target="_blank" rel="noopener">iterm2</a></p><h3 id="配置rzsz"><a href="#配置rzsz" class="headerlink" title="配置rzsz"></a>配置rzsz</h3><p>1、安装iterm2-zmodem</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brew install wget</span><br><span class="line">brew install lrzsz</span><br><span class="line"></span><br><span class="line">git clone https://github.com/aikuyun/iterm2-zmodem.git</span><br><span class="line">cd iterm2-zmodem</span><br><span class="line">cp iterm2-* /usr/local/bin</span><br><span class="line">cd /usr/local/bin</span><br><span class="line">chmod +x iterm2-*</span><br></pre></td></tr></table></figure><p>2、iterm2配置项 </p><p>Profiles-&gt;OpenProfiles-&gt;EditProfiles-&gt;Advanced-&gt;Tirgger，添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Regular expression:</span>  <span class="string">/*/*B0100</span></span><br><span class="line"><span class="attr">Action:</span> <span class="string">Run</span> <span class="string">Silent</span> <span class="string">Coprocess</span></span><br><span class="line"><span class="attr">Parameters:</span> <span class="string">/usr/local/bin/iterm2-send-zmodem.sh</span></span><br><span class="line"><span class="attr">Instant:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">Regular expression:</span>  <span class="string">/*/*B00000000000000</span></span><br><span class="line"><span class="attr">Action:</span> <span class="string">Run</span> <span class="string">Silent</span> <span class="string">Coprocess</span></span><br><span class="line"><span class="attr">Parameters:</span> <span class="string">/usr/local/bin/iterm2-recv-zmodem.sh</span></span><br><span class="line"><span class="attr">Instant:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="clone-session"><a href="#clone-session" class="headerlink" title="clone session"></a>clone session</h3><p>1、Iterm2-&gt;Preferences-&gt;Profile-&gt;Working Directory<br>勾选 Reuse previous session’s directory</p><p>2、编辑 .ssh/config 文件，添加</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">host *</span><br><span class="line">ControlMaster auto</span><br><span class="line">ControlPath ~/.ssh/master-<span class="built_in">%r</span>@<span class="built_in">%h</span>:<span class="built_in">%p</span></span><br></pre></td></tr></table></figure><p>3、重新打开终端，第一次登录需要密码。第二次登录同一台机器，就不需要密码了，nice。</p><h2 id="mysqlclient"><a href="#mysqlclient" class="headerlink" title="mysqlclient"></a>mysqlclient</h2><p>1、安装mysqlclient</p><p><code>brew install mysql-connector-c</code></p><p>2、编辑 .zshrc 添加路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mysql</span></span><br><span class="line">export PATH="/usr/local/Cellar/mysql-client/8.0.19/bin:$PATH"</span><br></pre></td></tr></table></figure><h2 id="好用的软件"><a href="#好用的软件" class="headerlink" title="好用的软件"></a>好用的软件</h2><ul><li><a href="https://www.google.com/intl/zh-CN/chrome/" target="_blank" rel="noopener">Chrome</a></li><li><a href="https://www.typora.io/" target="_blank" rel="noopener">typora</a></li><li><a href="https://iterm2.com/" target="_blank" rel="noopener">iterm2</a></li><li><a href="http://www.sublimetext.com/" target="_blank" rel="noopener">sublime</a></li><li><a href="http://www.sequelpro.com/" target="_blank" rel="noopener">sequelpro</a></li><li><a href="https://www.wps.cn/" target="_blank" rel="noopener">wps</a></li><li><a href="https://pan.baidu.com/" target="_blank" rel="noopener">百度云盘</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;系统相关&quot;&gt;&lt;a href=&quot;#系统相关&quot; class=&quot;headerlink&quot; title=&quot;系统相关&quot;&gt;&lt;/a&gt;系统相关&lt;/h1&gt;&lt;h2 id=&quot;用户名&quot;&gt;&lt;a href=&quot;#用户名&quot; class=&quot;headerlink&quot; title=&quot;用户名&quot;&gt;&lt;/a&gt;用户名&lt;/h2&gt;&lt;p&gt;系统偏好设置，用户与群组，点按锁按钮以进行修改。右键用户，高级选项。&lt;br&gt;修改账户名称为vk，这个名称是shell中显示的用户名。&lt;br&gt;修改全名为voidking，这个名称是mac系统显示的名称。&lt;br&gt;个人目录，修改为 /Users/vk ，这个目录是新的home目录。&lt;/p&gt;
&lt;p&gt;修改完成后点击“好”，系统重启，然后整个系统恢复到出厂状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="爱好" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/"/>
    
      <category term="电脑" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/%E7%94%B5%E8%84%91/"/>
    
    
  </entry>
  
  <entry>
    <title>安装部署K8S集群的艰难之路</title>
    <link href="https://www.voidking.com/dev-install-k8s-the-hard-way/"/>
    <id>https://www.voidking.com/dev-install-k8s-the-hard-way/</id>
    <published>2020-04-01T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.voidking.com/dev-kubeadm-install-k8s/">《使用kubeadm安装部署K8S集群》</a>一文中，使用kubeadm安装部署了k8s集群。但是，kubeadm的安装方式太简单了，而cka的要求不止这么简单。因此，我们还需要学习从零开始，一个一个组件安装配置k8s集群的方法，所谓k8s the hard way。</p><p>本文的目标是在virtualbox中，搭建一个k8s集群，一个master节点，一个node01节点。</p><p>主要参考<a href="https://github.com/kelseyhightower/kubernetes-the-hard-way" target="_blank" rel="noopener">kelseyhightower/kubernetes-the-hard-way</a>和<a href="https://github.com/mmumshad/kubernetes-the-hard-way" target="_blank" rel="noopener">mmumshad/kubernetes-the-hard-way</a>。</p><a id="more"></a><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>创建两台centos7虚拟机，master节点1C2G，node01节点1C1G</li><li>配置网络，master节点IP为192.168.56.150，node01节点的IP为192.168.56.151</li><li>配置hostname，并且把两个节点的hostname添加到/etc/hosts</li><li>安装Docker，参考<a href="https://www.voidking.com/dev-docker-start/">《Docker入门》</a></li></ul><h1 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h1><p>1、安装kubectl</p><p>2、创建CA，给每个组件生成TLS证书<br>TLS证书包括：<br>ETCD Server Certificate<br>Kubernetes API Server Certificate<br>Controller Manager Client Certificate<br>Scheduler Client Certificate</p><p>Service Account Key Pair<br>Kube Proxy Client Certificate<br>Kubelet Client Certificates<br>Admin Client Certificate</p><p>3、给每个组件生成k8s配置文件，用于访问apiserver</p><p>4、生成数据加密配置和密钥，使集群支持静态加密</p><p>5、指定CA和TLS，在master节点启动etcd</p><p>6、指定CA和TLS，在master节点启动kube-apiserver、kube-controller-manager、kube-scheduler</p><p>7、指定CA和TLS，在node01节点启动kubelet和kube-proxy</p><p>8、指定CA和TLS，生成admin用户的配置文件，使用kubectl可以访问集群</p><p>9、部署weave，使pod可以获取到IP</p><p>10、部署coredns，使svc服务名可以使用</p><p>11、Smoke Test和End-to-End Tests</p><h1 id="实践篇"><a href="#实践篇" class="headerlink" title="实践篇"></a>实践篇</h1><p>操作过程太长，具体还是参考前言中的两个 kubernetes-the-hard-way 文档吧。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-kubeadm-install-k8s/&quot;&gt;《使用kubeadm安装部署K8S集群》&lt;/a&gt;一文中，使用kubeadm安装部署了k8s集群。但是，kubeadm的安装方式太简单了，而cka的要求不止这么简单。因此，我们还需要学习从零开始，一个一个组件安装配置k8s集群的方法，所谓k8s the hard way。&lt;/p&gt;
&lt;p&gt;本文的目标是在virtualbox中，搭建一个k8s集群，一个master节点，一个node01节点。&lt;/p&gt;
&lt;p&gt;主要参考&lt;a href=&quot;https://github.com/kelseyhightower/kubernetes-the-hard-way&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;kelseyhightower/kubernetes-the-hard-way&lt;/a&gt;和&lt;a href=&quot;https://github.com/mmumshad/kubernetes-the-hard-way&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mmumshad/kubernetes-the-hard-way&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>PostgreSQL入门篇</title>
    <link href="https://www.voidking.com/dev-postgresql-start/"/>
    <id>https://www.voidking.com/dev-postgresql-start/</id>
    <published>2020-03-30T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.732Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PostgreSQL简介"><a href="#PostgreSQL简介" class="headerlink" title="PostgreSQL简介"></a>PostgreSQL简介</h1><blockquote><p>PostgreSQL is a powerful, open source object-relational database system with over 30 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.</p></blockquote><p>更多内容参考<a href="https://www.postgresql.org/" target="_blank" rel="noopener">PostgreSQL官网</a>和<a href="https://www.postgresql.org/docs/" target="_blank" rel="noopener">PostgreSQL Documentation</a>。</p><p>Harbor中使用的数据库就是PostgreSQL，因此本文对PostgreSQL（pg）进行一个简单的学习，主要参考<a href="https://www.runoob.com/postgresql/postgresql-tutorial.html" target="_blank" rel="noopener">PostgreSQL 菜鸟教程</a>。</p><a id="more"></a><h1 id="Harbor中的pg"><a href="#Harbor中的pg" class="headerlink" title="Harbor中的pg"></a>Harbor中的pg</h1><p>1、进入pg容器<br><code>docker exec -it harbor-db /bin/bash</code></p><p>2、登录pg<br><code>psql -U postgres -h postgresql -p 5432</code><br>默认密码为 root123 ，实际密码查看harbor.yml中的配置。</p><p>3、查看帮助</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\<span class="keyword">help</span></span><br><span class="line">\<span class="keyword">help</span> <span class="keyword">select</span></span><br></pre></td></tr></table></figure><p>4、查看数据库，切换数据库，查看表</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">\l</span></span><br><span class="line"><span class="string">\c</span> registry;</span><br><span class="line"><span class="string">\d</span></span><br><span class="line"><span class="string">\dt</span></span><br></pre></td></tr></table></figure><p>5、查看表结构</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\d registry<span class="comment">;</span></span><br><span class="line">\d replication_policy<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>6、查看表数据</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> registry;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> replication_policy;</span><br></pre></td></tr></table></figure><p>可以看到，查看表数据的方法和mysql完全相同。<br>实际上，pg支持标准的sql语法，因此增删查改的语法参考<a href="https://www.voidking.com/dev-mysql-command/">《MySQL常用命令》</a>即可。</p><h1 id="安装pg"><a href="#安装pg" class="headerlink" title="安装pg"></a>安装pg</h1><p>如果单独使用pg，该怎样安装？下面学习使用docker安装pg的方法。</p><p>1、登录dockerhub查看需要的<a href="https://hub.docker.com/_/postgres" target="_blank" rel="noopener">pg版本</a>。</p><p>2、下载pg镜像（以pg12.2为例）<br><code>docker pull postgres:12.2</code></p><p>3、启动pg服务</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name vk-pg -d \</span><br><span class="line">-<span class="ruby">p <span class="number">5432</span><span class="symbol">:</span><span class="number">5432</span> \</span></span><br><span class="line"><span class="ruby">-e POSTGRES_PASSWORD=voidking \</span></span><br><span class="line"><span class="ruby">-e PGDATA=<span class="regexp">/var/lib</span><span class="regexp">/postgresql/data</span><span class="regexp">/pgdata \</span></span></span><br><span class="line"><span class="ruby">-v /opt/postgresql/<span class="symbol">data:</span>/var/lib/postgresql/data \</span></span><br><span class="line"><span class="ruby"><span class="symbol">postgres:</span><span class="number">12.2</span></span></span><br></pre></td></tr></table></figure><p>以上命令：</p><ul><li>命名容器为vk-pg，后台运行</li><li>映射宿主机5432端口到容器5432端口</li><li>设置pg数据库密码和数据存放目录</li><li>映射宿主机/opt/postgresql/data目录（不需要提前创建目录）到容器/var/lib/postgresql/data目录</li></ul><p>更高级的启动命令参考<a href="https://hub.docker.com/_/postgres?tab=description" target="_blank" rel="noopener">How to use this image</a>。</p><p>4、验证安装<br><code>docker ps</code><br>gp启动正常的话就可以看到vk-pg容器。<br>如果启动失败，可以使用<code>docker logs vk-pg</code>查看失败原因并进行解决。</p><p>使用nc命令验证：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">yum</span> <span class="string">install nc</span></span><br><span class="line"><span class="attr">nc</span> <span class="string">-v localhost 5432</span></span><br></pre></td></tr></table></figure><p>5、登录pg</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">exec -it vk-pg /bin/bash</span></span><br><span class="line"><span class="attr">psql</span> <span class="string">-U postgres</span></span><br><span class="line"><span class="attr">psql</span> <span class="string">-U postgres -h localhost -p 5432</span></span><br></pre></td></tr></table></figure><p>啊嘞，直接登录进去了，不需要密码？<br>这是因为，pg镜像在本地设置了信任身份验证，因此从容器内连接时不需要密码。</p><p>但是，如果从其他主机/容器进行连接，则需要输入密码。<br>比如在宿主机（系统为centos7）上登录pg：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">yum</span> <span class="string">list | grep postgresql</span></span><br><span class="line"><span class="attr">yum</span> <span class="string">install postgresql.x86_64</span></span><br><span class="line"><span class="attr">psql</span> <span class="string">-U postgres -h localhost -p 5432</span></span><br></pre></td></tr></table></figure><p>这次必须输入正确的密码才能登录。</p><p>以上，pg安装配置完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;PostgreSQL简介&quot;&gt;&lt;a href=&quot;#PostgreSQL简介&quot; class=&quot;headerlink&quot; title=&quot;PostgreSQL简介&quot;&gt;&lt;/a&gt;PostgreSQL简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;PostgreSQL is a powerful, open source object-relational database system with over 30 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多内容参考&lt;a href=&quot;https://www.postgresql.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PostgreSQL官网&lt;/a&gt;和&lt;a href=&quot;https://www.postgresql.org/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PostgreSQL Documentation&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;Harbor中使用的数据库就是PostgreSQL，因此本文对PostgreSQL（pg）进行一个简单的学习，主要参考&lt;a href=&quot;https://www.runoob.com/postgresql/postgresql-tutorial.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PostgreSQL 菜鸟教程&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="数据库" scheme="https://www.voidking.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Harbor入门篇</title>
    <link href="https://www.voidking.com/dev-harbor-start/"/>
    <id>https://www.voidking.com/dev-harbor-start/</id>
    <published>2020-03-22T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Harbor简介"><a href="#Harbor简介" class="headerlink" title="Harbor简介"></a>Harbor简介</h1><blockquote><p>Harbor is an open source container image registry that secures images with role-based access control, scans images for vulnerabilities, and signs images as trusted. As a CNCF Incubating project, Harbor delivers compliance, performance, and interoperability to help you consistently and securely manage images across cloud native compute platforms like Kubernetes and Docker.</p></blockquote><p>更多内容参考<a href="https://goharbor.io/" target="_blank" rel="noopener">Harbor官网</a>。</p><a id="more"></a><h1 id="安装Harbor"><a href="#安装Harbor" class="headerlink" title="安装Harbor"></a>安装Harbor</h1><h2 id="前置条件"><a href="#前置条件" class="headerlink" title="前置条件"></a>前置条件</h2><p>参考<a href="https://goharbor.io/docs/1.10/install-config/installation-prereqs/" target="_blank" rel="noopener">Harbor Installation Prerequisites</a></p><p>1、硬件需求<br>硬件最小需求：2C4G40G。<br>硬件推荐需求：4C8G160G。</p><p>2、软件需求<br>Docker engine，Version 17.06.0-ce+ or higher<br>Docker Compose，Version 1.18.0 or higher<br>Openssl，Latest is preferred</p><p>3、网络端口<br>444、4443和80</p><h2 id="下载安装Harbor"><a href="#下载安装Harbor" class="headerlink" title="下载安装Harbor"></a>下载安装Harbor</h2><p>1、访问<a href="https://github.com/goharbor/harbor/releases" target="_blank" rel="noopener">Harbor releases page</a>，下载需要的harbor版本，这里选择下载 harbor-offline-installer-v1.10.1.tgz</p><p>或者使用curl命令下载：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -C - -O -L https:<span class="regexp">//gi</span>thub.com<span class="regexp">/goharbor/</span>harbor<span class="regexp">/releases/</span>download<span class="regexp">/v1.10.1/</span>harbor-offline-installer-v1.<span class="number">10.1</span>.tgz</span><br></pre></td></tr></table></figure><p>2、解压</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tar</span> <span class="selector-tag">-xzvf</span> <span class="selector-tag">harbor-offline-installer-v1</span><span class="selector-class">.10</span><span class="selector-class">.1</span><span class="selector-class">.tgz</span></span><br><span class="line"><span class="selector-tag">cd</span> <span class="selector-tag">harbor</span></span><br></pre></td></tr></table></figure><p>3、配置harbor.yml<br>安装前修改harbor.yaml，参考<a href="https://goharbor.io/docs/1.10/install-config/configure-yml-file/" target="_blank" rel="noopener">Configure the Harbor YML File</a>，按需要修改如下几个字段：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># The IP address or hostname to access admin UI and registry service.</span></span><br><span class="line"><span class="comment"># DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.</span></span><br><span class="line">hostname: harbor.voidking.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># http related config</span></span><br><span class="line">http:</span><br><span class="line">  #<span class="built_in"> port </span><span class="keyword">for</span> http,<span class="built_in"> default </span>is 80. <span class="keyword">If</span> https enabled, this<span class="built_in"> port </span>will redirect <span class="keyword">to</span> https port</span><br><span class="line">  port: 80</span><br><span class="line"></span><br><span class="line"><span class="comment"># https related config</span></span><br><span class="line"><span class="comment"># https:</span></span><br><span class="line">  # https<span class="built_in"> port </span><span class="keyword">for</span> harbor,<span class="built_in"> default </span>is 443</span><br><span class="line">  #port: 443</span><br><span class="line">  # The path of cert <span class="keyword">and</span> key files <span class="keyword">for</span> nginx</span><br><span class="line">  #certificate: /your/certificate/path</span><br><span class="line">  #private_key: /your/private/key/path</span><br><span class="line"></span><br><span class="line"><span class="comment"># The initial password of Harbor admin</span></span><br><span class="line"><span class="comment"># It only works in first time to install harbor</span></span><br><span class="line"><span class="comment"># Remember Change the admin password from UI after launching Harbor.</span></span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"></span><br><span class="line"><span class="comment"># The default data volume</span></span><br><span class="line">data_volume: /data</span><br><span class="line"></span><br><span class="line"><span class="comment"># Harbor DB configuration</span></span><br><span class="line">database:</span><br><span class="line">  # The password <span class="keyword">for</span> the root<span class="built_in"> user </span>of Harbor DB. Change this before any production use.</span><br><span class="line">  password: root123</span><br><span class="line">  # The maximum number of connections <span class="keyword">in</span> the idle<span class="built_in"> connection </span>pool. <span class="keyword">If</span> it &lt;=0, <span class="literal">no</span> idle connections are retained.</span><br><span class="line">  max_idle_conns: 50</span><br><span class="line">  # The maximum number of open connections <span class="keyword">to</span> the database. <span class="keyword">If</span> it &lt;= 0, then there is <span class="literal">no</span> limit on the number of open connections.</span><br><span class="line">  # Note: the<span class="built_in"> default </span>number of connections is 100 <span class="keyword">for</span> postgres.</span><br><span class="line">  max_open_conns: 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># Log configurations</span></span><br><span class="line">log:</span><br><span class="line">  # options are debug, info, warning, error, fatal</span><br><span class="line">  level: info</span><br><span class="line">  # configs <span class="keyword">for</span> logs <span class="keyword">in</span> local storage</span><br><span class="line">  local:</span><br><span class="line">    # Log files are rotated log_rotate_count times before being removed. <span class="keyword">If</span> count is 0, old versions are removed rather than rotated.</span><br><span class="line">    rotate_count: 50</span><br><span class="line">    # Log files are rotated only <span class="keyword">if</span> they grow bigger than log_rotate_size bytes. <span class="keyword">If</span> size is followed by k, the size is assumed <span class="keyword">to</span> be <span class="keyword">in</span> kilobytes.</span><br><span class="line">    # <span class="keyword">If</span> the M is used, the size is <span class="keyword">in</span> megabytes, <span class="keyword">and</span> <span class="keyword">if</span> G is used, the size is <span class="keyword">in</span> gigabytes. So size 100, size 100k, size 100M <span class="keyword">and</span> size 100G</span><br><span class="line">    # are all valid.</span><br><span class="line">    rotate_size: 200M</span><br><span class="line">    # The directory on your host that store log</span><br><span class="line">    location: /var/log/harbor</span><br></pre></td></tr></table></figure><p>4、执行安装<br><code>./install.sh</code><br><img src="http://cdn.voidking.com/@/imgs/harbor-start/install.jpg?imageView2/0/w/700" alt=""><br>如果安装完成发现配置错误，可以修改配置后再次执行脚本。<br>如果报错 ERROR: Failed to Setup IP tables: Unable to enable SKIP DNAT rule ，那么重启docker后再次执行脚本。</p><p>至此，harbor安装完成，没有配置https。</p><h1 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h1><h2 id="浏览器验证"><a href="#浏览器验证" class="headerlink" title="浏览器验证"></a>浏览器验证</h2><p>浏览器访问 <a href="http://192.168.56.200" target="_blank" rel="noopener">http://192.168.56.200</a> ，可以看到harbor登录页面。<br>输入用户名密码，admin和Harbor12345，登录harbor控制台。<br><img src="http://cdn.voidking.com/@/imgs/harbor-start/login.jpg?imageView2/0/w/700" alt=""></p><h2 id="命令行验证"><a href="#命令行验证" class="headerlink" title="命令行验证"></a>命令行验证</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker login <span class="number">192.168</span><span class="number">.56</span><span class="number">.200</span></span><br></pre></td></tr></table></figure><p>输入用户名密码，admin和Harbor12345，登录报错：<br>Error response from daemon: Get <a href="https://192.168.56.200/v2/" target="_blank" rel="noopener">https://192.168.56.200/v2/</a>: dial tcp 192.168.56.200:443: connect: connection refused。</p><p>这是因为，docker1.3.x之后与registry交互，默认使用https协议。<br>修改/etc/docker/daemon.json，添加insecure-registries参数：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [</span><br><span class="line">    <span class="string">"https://mirror.ccs.tencentyun.com"</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"insecure-registries"</span>: [</span><br><span class="line">    <span class="string">"http://192.168.56.200"</span>,</span><br><span class="line">    <span class="string">"http://harbor.voidking.com"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后重启docker：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">systemctl</span> <span class="string">daemon-reload</span></span><br><span class="line"><span class="attr">systemctl</span> <span class="string">restart docker</span></span><br></pre></td></tr></table></figure><p>重新登录，成功。<br><img src="http://cdn.voidking.com/@/imgs/harbor-start/login2.jpg?imageView2/0/w/500" alt=""></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="启动和停止"><a href="#启动和停止" class="headerlink" title="启动和停止"></a>启动和停止</h2><p>1、停止<br><code>docker-compose down -v</code></p><p>2、修改配置<br>修改harbor.yml后，执行<code>./prepare</code></p><p>3、启动<br><code>docker-compose up -d</code></p><h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker pull busybox:<span class="number">1.31</span></span><br><span class="line">docker tag busybox:<span class="number">1.31</span> harbor.<span class="built_in">void</span>king.com/<span class="built_in">void</span>king/busybox:<span class="number">1.31</span></span><br><span class="line">docker tag busybox:<span class="number">1.31</span> harbor.<span class="built_in">void</span>king.com/<span class="built_in">void</span>king/subpath/busybox:<span class="number">1.31</span></span><br><span class="line">docker push harbor.<span class="built_in">void</span>king.com/<span class="built_in">void</span>king/busybox:<span class="number">1.31</span></span><br></pre></td></tr></table></figure><p>报错：<br>The push refers to repository [harbor.voidking.com/voidking/busybox]<br>a6d503001157: Preparing<br>denied: requested access to the resource is denied</p><p>这是因为，需要先创建项目。在web控制台创建项目 voidking，再次上传，成功。带有subpath的镜像，同样可以上传成功。</p><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull harbor.<span class="built_in">void</span>king.com/<span class="built_in">void</span>king/busybox:<span class="number">1.31</span></span><br></pre></td></tr></table></figure><h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p>如果搭建高可用harbor，比如搭建两个实例的harbor，那么需要XSRFKey保持一致，在 common/config/core/app.conf 中配置。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Harbor简介&quot;&gt;&lt;a href=&quot;#Harbor简介&quot; class=&quot;headerlink&quot; title=&quot;Harbor简介&quot;&gt;&lt;/a&gt;Harbor简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Harbor is an open source container image registry that secures images with role-based access control, scans images for vulnerabilities, and signs images as trusted. As a CNCF Incubating project, Harbor delivers compliance, performance, and interoperability to help you consistently and securely manage images across cloud native compute platforms like Kubernetes and Docker.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多内容参考&lt;a href=&quot;https://goharbor.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Harbor官网&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>K8S中的RBAC鉴权</title>
    <link href="https://www.voidking.com/dev-k8s-rbac-auth/"/>
    <id>https://www.voidking.com/dev-k8s-rbac-auth/</id>
    <published>2020-03-20T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RBAC-Authorization"><a href="#RBAC-Authorization" class="headerlink" title="RBAC Authorization"></a>RBAC Authorization</h1><blockquote><p>Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within your organization.</p></blockquote><p>更多内容，参考<a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/" target="_blank" rel="noopener">Using RBAC Authorization</a>。</p><p><a href="https://www.voidking.com/dev-ssl-tls/">《SSL和TLS》</a>文中，通过API签名一节，创建了新用户jane，并且给该用户的证书进行签名。现在我们有了jane.crt和jane.key，本文中会配置jane拥有一些k8s集群的管理权限。</p><a id="more"></a><h1 id="角色和绑定"><a href="#角色和绑定" class="headerlink" title="角色和绑定"></a>角色和绑定</h1><p>首先，给用户jane配置权限，使其能够创建和查看default空间下的pods。</p><h2 id="命令实现"><a href="#命令实现" class="headerlink" title="命令实现"></a>命令实现</h2><p>1、创建角色</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl create <span class="keyword">role</span> <span class="title">--help</span></span><br><span class="line">kubectl create <span class="keyword">role</span> <span class="title">developer</span> --<span class="attr">resource=</span>pods --<span class="attr">verb=</span>list,create</span><br></pre></td></tr></table></figure><p>2、角色绑定</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="keyword">create</span> rolebinding dev-<span class="keyword">user</span>-binding --<span class="keyword">role</span>=developer --<span class="keyword">user</span>=jane</span><br></pre></td></tr></table></figure><p>3、验证权限</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl auth can-i <span class="built_in">list</span> pods <span class="comment">--as jane</span></span><br><span class="line">kubectl <span class="keyword">get</span> pods <span class="comment">--as jane</span></span><br></pre></td></tr></table></figure><p>至此，用户jane的权限配置完成。</p><h2 id="manifest实现"><a href="#manifest实现" class="headerlink" title="manifest实现"></a>manifest实现</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">developer</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> <span class="string">[""]</span></span><br><span class="line">  <span class="attr">resources:</span> <span class="string">["pods"]</span></span><br><span class="line">  <span class="attr">verbs:</span> <span class="string">["list",</span> <span class="string">"create"</span><span class="string">]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">kind: RoleBindingapiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-user-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">developer</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.iomaster</span></span><br></pre></td></tr></table></figure><h1 id="集群角色和绑定"><a href="#集群角色和绑定" class="headerlink" title="集群角色和绑定"></a>集群角色和绑定</h1><p>以上，给jane授权，是在namespace范围内的。当我们想给jane授权cluster范围的权限时，就需要clusterroles。</p><p>比如，我们想给jane授权node相关的权限，可以如下实现。</p><h2 id="命令实现-1"><a href="#命令实现-1" class="headerlink" title="命令实现"></a>命令实现</h2><p>1、创建集群角色</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrole <span class="keyword">node</span><span class="title">-reader</span> --<span class="attr">verb=</span>get,list,watch --<span class="attr">resource=</span>nodes</span><br></pre></td></tr></table></figure><p>2、绑定集群角色</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create clusterrolebinding <span class="keyword">node</span><span class="title">-reader-binding</span> --<span class="attr">user=</span>jane --<span class="attr">clusterrole=</span><span class="keyword">node</span><span class="title">-reader</span></span><br></pre></td></tr></table></figure><h2 id="manifest实现-1"><a href="#manifest实现-1" class="headerlink" title="manifest实现"></a>manifest实现</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-reader</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">""</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">nodes</span></span><br><span class="line">  <span class="attr">verbs:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">list</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">watch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-reader-binding</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">node-reader</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span></span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>如果使用clusterrole指定的资源是pods这种namespace级别的资源，该集群角色绑定给jane后会有什么效果？<br>答：jane对所有namespace中的pods资源拥有clusterrole中定义的操作权限。</p><h1 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h1><p>用户jane已经拥有了需要的权限，该怎样访问k8s集群呢？答案是通过kubeconfig文件。</p><h2 id="kubeconfig"><a href="#kubeconfig" class="headerlink" title="kubeconfig"></a>kubeconfig</h2><p>1、查看配置<br><code>kubectl config view</code><br>记录当前的server地址。</p><p>2、保存ca.crt</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat .kube<span class="built_in">/config </span>| grep certificate-authority-data | awk <span class="string">'&#123;print $2&#125;'</span> | base64 --decode &gt; ca.crt</span><br></pre></td></tr></table></figure><h2 id="jane-kubeconfig"><a href="#jane-kubeconfig" class="headerlink" title="jane.kubeconfig"></a>jane.kubeconfig</h2><p>1、设置集群参数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl<span class="built_in"> config </span>set-cluster kubernetes \</span><br><span class="line"><span class="attribute">--server</span>=<span class="string">"https://172.17.0.69:6443"</span> \</span><br><span class="line"><span class="attribute">--certificate-authority</span>=/root/ca.crt \</span><br><span class="line"><span class="attribute">--embed-certs</span>=<span class="literal">true</span> \</span><br><span class="line"><span class="attribute">--kubeconfig</span>=jane.kubeconfig</span><br></pre></td></tr></table></figure><p>当前目录生成jane.kubeconfig文件。</p><p>2、设置客户端认证参数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl<span class="built_in"> config </span>set-credentials jane \</span><br><span class="line"><span class="attribute">--client-certificate</span>=/root/jane.crt \</span><br><span class="line"><span class="attribute">--client-key</span>=/root/jane.key \</span><br><span class="line"><span class="attribute">--embed-certs</span>=<span class="literal">true</span> \</span><br><span class="line"><span class="attribute">--kubeconfig</span>=jane.kubeconfig</span><br></pre></td></tr></table></figure><p>3、设置上下文参数</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl<span class="built_in"> config </span>set-context jane@kubernetes \</span><br><span class="line"><span class="attribute">--cluster</span>=kubernetes \</span><br><span class="line"><span class="attribute">--user</span>=jane \</span><br><span class="line"><span class="attribute">--namespace</span>=default \</span><br><span class="line"><span class="attribute">--kubeconfig</span>=jane.kubeconfig</span><br></pre></td></tr></table></figure><p>4、查看配置</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat jane.kubeconfig</span><br><span class="line">kubectl<span class="built_in"> config </span>view --kubeconfig jane.kubeconfig</span><br></pre></td></tr></table></figure><p>5、设置默认上下文</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">KUBECONFIG</span>=/root/jane.kubeconfig</span><br><span class="line">kubectl<span class="built_in"> config </span>use-context jane@kubernetes <span class="attribute">--kubeconfig</span>=jane.kubeconfig</span><br></pre></td></tr></table></figure><p>6、权限测试<br><code>kubectl get pods</code><br>如果没有配置权限，会输出：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">Error</span> <span class="keyword">from</span><span class="built_in"> server </span>(Forbidden): pods is forbidden:<span class="built_in"> User </span><span class="string">"jane"</span> cannot list<span class="built_in"> resource </span><span class="string">"pods"</span> <span class="keyword">in</span> API<span class="built_in"> group </span><span class="string">""</span> <span class="keyword">in</span> the namespace <span class="string">"default"</span></span><br></pre></td></tr></table></figure><p>如果配置好了权限，会输出pod相关信息。</p><p>但是，以上权限测试只是在minikube或者<a href="https://www.katacoda.com/courses/kubernetes/playground" target="_blank" rel="noopener">katacoda</a>平台生效。<br>如果使用<a href="https://kodekloud.com/courses/enrolled/675080" target="_blank" rel="noopener">kodekloud</a>或者阿里云k8s集群，会报错：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: You must be logged <span class="keyword">in</span> <span class="keyword">to</span> the<span class="built_in"> server </span>(Unauthorized)</span><br></pre></td></tr></table></figure><p>研究了四个多小时，才发现是平台的问题，服气了。。。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;RBAC-Authorization&quot;&gt;&lt;a href=&quot;#RBAC-Authorization&quot; class=&quot;headerlink&quot; title=&quot;RBAC Authorization&quot;&gt;&lt;/a&gt;RBAC Authorization&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within your organization.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多内容，参考&lt;a href=&quot;https://kubernetes.io/docs/reference/access-authn-authz/rbac/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Using RBAC Authorization&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-ssl-tls/&quot;&gt;《SSL和TLS》&lt;/a&gt;文中，通过API签名一节，创建了新用户jane，并且给该用户的证书进行签名。现在我们有了jane.crt和jane.key，本文中会配置jane拥有一些k8s集群的管理权限。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>JSONPath</title>
    <link href="https://www.voidking.com/dev-jsonpath/"/>
    <id>https://www.voidking.com/dev-jsonpath/</id>
    <published>2020-03-18T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSONPath简介"><a href="#JSONPath简介" class="headerlink" title="JSONPath简介"></a>JSONPath简介</h1><blockquote><p>JSON (JavaScript Object Notation) allows for easy interchange of data, often between a program and a database.<br>JSONPath is a query language for JSON, similar to XPath for XML. </p></blockquote><p>如上，json是一种常用的数据格式，jsonpath是json的查询语言，类似于XPath和SQL。</p><a id="more"></a><h1 id="JSONPath语法"><a href="#JSONPath语法" class="headerlink" title="JSONPath语法"></a>JSONPath语法</h1><p>摘自 <a href="https://github.com/json-path/JsonPath" target="_blank" rel="noopener">json-path/JsonPath</a></p><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><table><thead><tr><th align="left">Operator</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left"><code>$</code></td><td align="left">The root element to query. This starts all path expressions.</td></tr><tr><td align="left"><code>@</code></td><td align="left">The current node being processed by a filter predicate.</td></tr><tr><td align="left"><code>*</code></td><td align="left">Wildcard. Available anywhere a name or numeric are required.</td></tr><tr><td align="left"><code>..</code></td><td align="left">Deep scan. Available anywhere a name is required.</td></tr><tr><td align="left"><code>.&lt;name&gt;</code></td><td align="left">Dot-notated child</td></tr><tr><td align="left"><code>[&#39;&lt;name&gt;&#39; (, &#39;&lt;name&gt;&#39;)]</code></td><td align="left">Bracket-notated child or children</td></tr><tr><td align="left"><code>[&lt;number&gt; (, &lt;number&gt;)]</code></td><td align="left">Array index or indexes</td></tr><tr><td align="left"><code>[start:end]</code></td><td align="left">Array slice operator</td></tr><tr><td align="left"><code>[?(&lt;expression&gt;)]</code></td><td align="left">Filter expression. Expression must evaluate to a boolean value.</td></tr></tbody></table><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>Functions can be invoked at the tail end of a path - the input to a function is the output of the path expression.<br>The function output is dictated by the function itself.</p><table><thead><tr><th align="left">Function</th><th align="left">Description</th><th>Output</th></tr></thead><tbody><tr><td align="left">min()</td><td align="left">Provides the min value of an array of numbers</td><td>Double</td></tr><tr><td align="left">max()</td><td align="left">Provides the max value of an array of numbers</td><td>Double</td></tr><tr><td align="left">avg()</td><td align="left">Provides the average value of an array of numbers</td><td>Double</td></tr><tr><td align="left">stddev()</td><td align="left">Provides the standard deviation value of an array of numbers</td><td>Double</td></tr><tr><td align="left">length()</td><td align="left">Provides the length of an array</td><td>Integer</td></tr><tr><td align="left">sum()</td><td align="left">Provides the sum value of an array of numbers</td><td>Double</td></tr></tbody></table><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>Filters are logical expressions used to filter arrays. A typical filter would be <code>[?(@.age &gt; 18)]</code> where <code>@</code> represents the current item being processed. More complex filters can be created with logical operators <code>&amp;&amp;</code> and <code>||</code>. String literals must be enclosed by single or double quotes (<code>[?(@.color == &#39;blue&#39;)]</code> or <code>[?(@.color == &quot;blue&quot;)]</code>).   </p><table><thead><tr><th align="left">Operator</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">==</td><td align="left">left is equal to right (note that 1 is not equal to ‘1’)</td></tr><tr><td align="left">!=</td><td align="left">left is not equal to right</td></tr><tr><td align="left">&lt;</td><td align="left">left is less than right</td></tr><tr><td align="left">&lt;=</td><td align="left">left is less or equal to right</td></tr><tr><td align="left">&gt;</td><td align="left">left is greater than right</td></tr><tr><td align="left">&gt;=</td><td align="left">left is greater than or equal to right</td></tr><tr><td align="left">=~</td><td align="left">left matches regular expression  [?(@.name =~ /foo.*?/i)]</td></tr><tr><td align="left">in</td><td align="left">left exists in right [?(@.size in [‘S’, ‘M’])]</td></tr><tr><td align="left">nin</td><td align="left">left does not exists in right</td></tr><tr><td align="left">subsetof</td><td align="left">left is a subset of right [?(@.sizes subsetof [‘S’, ‘M’, ‘L’])]</td></tr><tr><td align="left">anyof</td><td align="left">left has an intersection with right [?(@.sizes anyof [‘M’, ‘L’])]</td></tr><tr><td align="left">noneof</td><td align="left">left has no intersection with right [?(@.sizes noneof [‘M’, ‘L’])]</td></tr><tr><td align="left">size</td><td align="left">size of left (array or string) should match right</td></tr><tr><td align="left">empty</td><td align="left">left (array or string) should be empty</td></tr></tbody></table><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>Given the json</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"store"</span>: &#123;</span><br><span class="line">        <span class="string">"book"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"category"</span>: <span class="string">"reference"</span>,</span><br><span class="line">                <span class="string">"author"</span>: <span class="string">"Nigel Rees"</span>,</span><br><span class="line">                <span class="string">"title"</span>: <span class="string">"Sayings of the Century"</span>,</span><br><span class="line">                <span class="string">"price"</span>: <span class="number">8.95</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"category"</span>: <span class="string">"fiction"</span>,</span><br><span class="line">                <span class="string">"author"</span>: <span class="string">"Evelyn Waugh"</span>,</span><br><span class="line">                <span class="string">"title"</span>: <span class="string">"Sword of Honour"</span>,</span><br><span class="line">                <span class="string">"price"</span>: <span class="number">12.99</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"category"</span>: <span class="string">"fiction"</span>,</span><br><span class="line">                <span class="string">"author"</span>: <span class="string">"Herman Melville"</span>,</span><br><span class="line">                <span class="string">"title"</span>: <span class="string">"Moby Dick"</span>,</span><br><span class="line">                <span class="string">"isbn"</span>: <span class="string">"0-553-21311-3"</span>,</span><br><span class="line">                <span class="string">"price"</span>: <span class="number">8.99</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"category"</span>: <span class="string">"fiction"</span>,</span><br><span class="line">                <span class="string">"author"</span>: <span class="string">"J. R. R. Tolkien"</span>,</span><br><span class="line">                <span class="string">"title"</span>: <span class="string">"The Lord of the Rings"</span>,</span><br><span class="line">                <span class="string">"isbn"</span>: <span class="string">"0-395-19395-8"</span>,</span><br><span class="line">                <span class="string">"price"</span>: <span class="number">22.99</span></span><br><span class="line">            &#125;</span><br><span class="line">        ],</span><br><span class="line">        <span class="string">"bicycle"</span>: &#123;</span><br><span class="line">            <span class="string">"color"</span>: <span class="string">"red"</span>,</span><br><span class="line">            <span class="string">"price"</span>: <span class="number">19.95</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"expensive"</span>: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">JsonPath (click link to try)</th><th align="left">Result</th></tr></thead><tbody><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$.store.book[*].author" target="_blank">$.store.book[*].author</a></td><td align="left">The authors of all books</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..author" target="_blank">$..author</a></td><td align="left">All authors</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$.store.*" target="_blank">$.store.*</a></td><td align="left">All things, both books and bicycles</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$.store..price" target="_blank">$.store..price</a></td><td align="left">The price of everything</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[2]" target="_blank">$..book[2]</a></td><td align="left">The third book</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[2]" target="_blank">$..book[-2]</a></td><td align="left">The second to last book</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[0,1]" target="_blank">$..book[0,1]</a></td><td align="left">The first two books</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[:2]" target="_blank">$..book[:2]</a></td><td align="left">All books from index 0 (inclusive) until index 2 (exclusive)</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[1:2]" target="_blank">$..book[1:2]</a></td><td align="left">All books from index 1 (inclusive) until index 2 (exclusive)</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[-2:]" target="_blank">$..book[-2:]</a></td><td align="left">Last two books</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[2:]" target="_blank">$..book[2:]</a></td><td align="left">Book number two from tail</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[?(@.isbn)]" target="_blank">$..book[?(@.isbn)]</a></td><td align="left">All books with an ISBN number</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$.store.book[?(@.price < 10)]" target="_blank">$.store.book[?(@.price &lt; 10)]</a></td><td align="left">All books in store cheaper than 10</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[?(@.price <= $['expensive'])]" target="_blank">$..book[?(@.price &lt;= $[‘expensive’])]</a></td><td align="left">All books in store that are not “expensive”</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book[?(@.author =~ /.*REES/i)]" target="_blank">$..book[?(@.author =~ /.*REES/i)]</a></td><td align="left">All books matching regex (ignore case)</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..*" target="_blank">$..*</a></td><td align="left">Give me every thing</td></tr><tr><td align="left"><a href="http://jsonpath.herokuapp.com/?path=$..book.length()" target="_blank">$..book.length()</a></td><td align="left">The number of books</td></tr></tbody></table><h1 id="在线测试"><a href="#在线测试" class="headerlink" title="在线测试"></a>在线测试</h1><p><a href="https://jsonpath.com/" target="_blank" rel="noopener">JSONPath Online Evaluator</a></p><h1 id="kubectl-JSONPath"><a href="#kubectl-JSONPath" class="headerlink" title="kubectl + JSONPath"></a>kubectl + JSONPath</h1><p>kubelet支持JSONPath，具体参考<a href="https://kubernetes.io/zh/docs/reference/kubectl/jsonpath/" target="_blank" rel="noopener">JSONPath 支持</a>。<br>除了标准jsonpath语法外,kubernetes jsonpath模板还额外支持以下语法:</p><ul><li>用””双引号来引用JSONPath表达式中的文本</li><li>使用range和end来遍历集合</li><li>使用负数来从尾部索引集合</li></ul><p>查看node的cpu信息：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes -o=jsonpath='&#123;<span class="string">.items</span>[*]<span class="string">.metadata.name</span>&#125;'</span><br><span class="line">kubectl get nodes -o=jsonpath='&#123;<span class="string">.items</span>[*]<span class="string">.status.capacity.cpu</span>&#125;'</span><br><span class="line">kubectl get nodes -o=jsonpath='&#123;<span class="string">.items</span>[*]<span class="string">.metadata.name</span>&#125;&#123;<span class="string">.items</span>[*]<span class="string">.status.capacity.cpu</span>&#125;'</span><br><span class="line">kubectl get nodes -o=jsonpath='&#123;<span class="string">.items</span>[*]<span class="string">.metadata.name</span>&#125;&#123;<span class="string">"\n"</span>&#125;&#123;<span class="string">.items</span>[*]<span class="string">.status.capacity.cpu</span>&#125;'</span><br><span class="line">kubectl get nodes -o=jsonpath='&#123;range <span class="string">.items</span>[*]&#125;&#123;<span class="string">.metadata.name</span>&#125;&#123;<span class="string">"\t"</span>&#125;&#123;<span class="string">.status.capacity.cpu</span>&#125;&#123;end&#125;'</span><br><span class="line">kubectl get nodes -o=custom-columns=NODE<span class="function">:.metadata.name</span>,CPU<span class="function">:.status.capacity.cpu</span></span><br><span class="line">kubectl get nodes <span class="params">--sort-by=</span><span class="string">.metadata.name</span></span><br><span class="line">kubectl get nodes <span class="params">--sort-by=</span><span class="string">.status.capacity.cpu</span></span><br></pre></td></tr></table></figure><h1 id="json2yaml"><a href="#json2yaml" class="headerlink" title="json2yaml"></a>json2yaml</h1><p>json和yaml可以相互转化，这里推荐一个在线工具<a href="https://www.json2yaml.com/" target="_blank" rel="noopener">JSON to YAML</a>。</p><p>如果有python3环境，还可以使用python-json2yaml工具。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">pip</span> <span class="string">install PyYAML==5.1</span></span><br><span class="line"><span class="attr">pip</span> <span class="string">install python-json2yaml</span></span><br><span class="line"><span class="attr">cat</span> <span class="string">a.json | json2yaml &gt; a.yaml</span></span><br><span class="line"><span class="attr">cat</span> <span class="string">a.yaml | yaml2json</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JSONPath简介&quot;&gt;&lt;a href=&quot;#JSONPath简介&quot; class=&quot;headerlink&quot; title=&quot;JSONPath简介&quot;&gt;&lt;/a&gt;JSONPath简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;JSON (JavaScript Object Notation) allows for easy interchange of data, often between a program and a database.&lt;br&gt;JSONPath is a query language for JSON, similar to XPath for XML. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上，json是一种常用的数据格式，jsonpath是json的查询语言，类似于XPath和SQL。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
      <category term="json" scheme="https://www.voidking.com/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>使用kubeadm安装部署K8S集群</title>
    <link href="https://www.voidking.com/dev-kubeadm-install-k8s/"/>
    <id>https://www.voidking.com/dev-kubeadm-install-k8s/</id>
    <published>2020-03-16T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="kubeadm简介"><a href="#kubeadm简介" class="headerlink" title="kubeadm简介"></a>kubeadm简介</h1><p><a href="https://www.voidking.com/dev-kubeadm-upgrade/">《使用kubeadm升级K8S集群》</a>一文中，了解了k8s集群中常见组件，并且使用kubeadm对k8s集群进行了升级。本文中，会学习使用kubeadm安装部署k8s集群。</p><blockquote><p>Kubeadm is a tool built to provide kubeadm init and kubeadm join as best-practice “fast paths” for creating Kubernetes clusters.</p></blockquote><p>更多内容，参考<a href="https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/" target="_blank" rel="noopener">Overview of kubeadm</a>和<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">Installing kubeadm</a>。</p><a id="more"></a><h1 id="安装流程"><a href="#安装流程" class="headerlink" title="安装流程"></a>安装流程</h1><p>目标：搭建一个k8s集群，包括master和node01两个节点，节点系统为ubuntu16.04.2。</p><p>1、环境准备。</p><p>2、在两个节点上安装kubeadm。</p><p>3、使用kubeadm初始化节点。</p><p>4、安装网络插件。</p><p>5、验证安装。</p><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><p>1、配置主机名</p><p>2、配置IP地址</p><p>3、参考<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/#letting-iptables-see-bridged-traffic" target="_blank" rel="noopener">Letting iptables see bridged traffic</a>，配置iptables</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ensure legacy binaries are installed</span></span><br><span class="line">sudo apt-get <span class="keyword">install</span> -y iptables arptables ebtables</span><br><span class="line"></span><br><span class="line"><span class="comment"># switch to legacy versions</span></span><br><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--set iptables /usr/sbin/iptables-legacy</span></span><br><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--set ip6tables /usr/sbin/ip6tables-legacy</span></span><br><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--set arptables /usr/sbin/arptables-legacy</span></span><br><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--set ebtables /usr/sbin/ebtables-legacy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Letting iptables see bridged traffic</span></span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-<span class="keyword">call</span>-ip6tables = <span class="number">1</span></span><br><span class="line">net.bridge.bridge-nf-<span class="keyword">call</span>-iptables = <span class="number">1</span></span><br><span class="line">EOF</span><br><span class="line">sysctl <span class="comment">--system</span></span><br></pre></td></tr></table></figure><p>4、参考<a href="https://www.voidking.com/dev-docker-start/">Docker入门</a>，安装Docker</p><h1 id="安装kubeadm"><a href="#安装kubeadm" class="headerlink" title="安装kubeadm"></a>安装kubeadm</h1><p>参考<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/" target="_blank" rel="noopener">Installing kubeadm</a>。</p><p>1、确认系统版本<br><code>cat /etc/os-release</code></p><p>2、执行安装kubeadm、kubelet和kubectl（两个节点都要执行）</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span> &amp;&amp; sudo apt-<span class="built_in">get</span> install -<span class="keyword">y</span> apt-transport-https curl</span><br><span class="line">curl -s http<span class="variable">s:</span>//packages.cloud.google.<span class="keyword">com</span>/apt/doc/apt-key.gpg | sudo apt-key <span class="built_in">add</span> -</span><br><span class="line"><span class="keyword">cat</span> &lt;&lt;EOF | sudo tee /etc/apt/sources.<span class="keyword">list</span>.d/kubernetes.<span class="keyword">list</span></span><br><span class="line"><span class="keyword">deb</span> http<span class="variable">s:</span>//apt.kubernetes.io/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">sudo apt-<span class="built_in">get</span> install -<span class="keyword">y</span> kubelet kubeadm kubectl</span><br><span class="line">sudo apt-<span class="keyword">mark</span> hold kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><p>3、查看kubelet版本<br><code>kubelet --version</code></p><h1 id="初始化节点"><a href="#初始化节点" class="headerlink" title="初始化节点"></a>初始化节点</h1><p>参考<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#installing-kubeadm-on-your-hosts" target="_blank" rel="noopener">Installing kubeadm on your hosts</a>。</p><h2 id="master"><a href="#master" class="headerlink" title="master"></a>master</h2><p>1、测试与gcr.io的连接<br><code>kubeadm config images pull</code></p><p>2、执行初始化<br><code>kubeadm init</code><br>完成后，屏幕输出会提示创建配置文件，以及添加worker node的join命令，记录下来。</p><p>3、创建配置文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br></pre></td></tr></table></figure><p>PS：如果忘记了添加worker node的join命令，可以重新生成。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm <span class="keyword">token</span> <span class="built_in">create</span> <span class="comment">--help</span></span><br><span class="line">kubeadm <span class="keyword">token</span> <span class="built_in">create</span> <span class="comment">--print-join-command</span></span><br></pre></td></tr></table></figure><p>生成新的join命令后，之前的join命令同样可以使用。</p><h2 id="node01"><a href="#node01" class="headerlink" title="node01"></a>node01</h2><p>1、使用join命令，添加node01节点到集群</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">kubeadm</span> <span class="selector-tag">join</span> 172<span class="selector-class">.17</span><span class="selector-class">.0</span><span class="selector-class">.53</span><span class="selector-pseudo">:6443</span> <span class="selector-tag">--token</span> <span class="selector-tag">b09bi7</span><span class="selector-class">.ob6evvc11a8jt1ie</span> \</span><br><span class="line">    <span class="selector-tag">--discovery-token-ca-cert-hash</span> <span class="selector-tag">sha256</span><span class="selector-pseudo">:8abadf8f2eb81301060af3ac6002959714ccf79aaf853546445a2fd6a0265001</span></span><br></pre></td></tr></table></figure><p>2、验证结果<br>在master节点执行：<br><code>kubectl get nodes</code><br>可以看到master节点和node01节点，都是NotReady的状态。</p><h1 id="安装网络插件"><a href="#安装网络插件" class="headerlink" title="安装网络插件"></a>安装网络插件</h1><p>参考<a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network" target="_blank" rel="noopener">Installing a Pod network add-on</a>，本文中选择安装weave。（以下命令都是在master节点执行。）</p><p>1、安装weave</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply <span class="operator">-f</span> <span class="string">"https://cloud.weave.works/k8s/net?k8s-version=<span class="variable">$</span>(kubectl version | base64 | tr -d '\n')"</span></span><br></pre></td></tr></table></figure><p>2、验证结果<br><code>kubectl get nodes -w</code><br>等待一会，可以看到master节点和node01节点，变化为Ready的状态，nice。</p><p>以上，k8s集群安装部署完成。</p><h1 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h1><h2 id="手动验证"><a href="#手动验证" class="headerlink" title="手动验证"></a>手动验证</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="builtin-name">get</span> nodes</span><br><span class="line">kubectl <span class="builtin-name">get</span> pods --all-namespaces</span><br><span class="line">service kube-apiserver status</span><br><span class="line">service kube-controller-manager status</span><br><span class="line">service kube-scheduler status</span><br><span class="line">service kubelet status</span><br><span class="line">service kube-proxy status</span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kubectl</span> <span class="string">run nginx</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">get pods</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">scale --replicas=3 deploy/nginx</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">get pods</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">expose deployment nginx --port=80 --type=NodePort</span></span><br><span class="line"><span class="attr">kubectl</span> <span class="string">get service</span></span><br><span class="line"><span class="attr">curl</span> <span class="string">http://node01:31850</span></span><br></pre></td></tr></table></figure><h2 id="test-infra"><a href="#test-infra" class="headerlink" title="test-infra"></a>test-infra</h2><p>源码地址：<a href="https://github.com/kubernetes/test-infra" target="_blank" rel="noopener">kubernetes/test-infra</a></p><p>1、拉取源码<br><code>go get -u k8s.io/test-infra/kubetest</code></p><p>2、执行kubetest</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kubetest <span class="attribute">--extract</span>=v1.11.3</span><br><span class="line">cd kubernetes</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">KUBE_MASTER_IP</span>=<span class="string">"172.17.0.53:6443"</span></span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">KUBE_MASTER</span>=kube-master</span><br><span class="line">kubetest --test <span class="attribute">--provider</span>=skeleton &gt; testout.txt</span><br><span class="line">kubetest --test <span class="attribute">--provider</span>=skeleton <span class="attribute">--test_args</span>=<span class="string">"ginkgo.focus=Secrets"</span> &gt; testout.txt</span><br><span class="line">cat testout.txt</span><br></pre></td></tr></table></figure><h2 id="Smoke-Test"><a href="#Smoke-Test" class="headerlink" title="Smoke Test"></a>Smoke Test</h2><p>按照<a href="https://github.com/mmumshad/kubernetes-the-hard-way/blob/master/docs/15-smoke-test.md" target="_blank" rel="noopener">Smoke Test</a>文档操作一遍。</p><h2 id="sonobuoy"><a href="#sonobuoy" class="headerlink" title="sonobuoy"></a>sonobuoy</h2><p>官网地址：<a href="https://sonobuoy.io/" target="_blank" rel="noopener">sonobuoy</a><br>源码地址：<a href="https://github.com/vmware-tanzu/sonobuoy" target="_blank" rel="noopener">vmware-tanzu/sonobuoy</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;kubeadm简介&quot;&gt;&lt;a href=&quot;#kubeadm简介&quot; class=&quot;headerlink&quot; title=&quot;kubeadm简介&quot;&gt;&lt;/a&gt;kubeadm简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-kubeadm-upgrade/&quot;&gt;《使用kubeadm升级K8S集群》&lt;/a&gt;一文中，了解了k8s集群中常见组件，并且使用kubeadm对k8s集群进行了升级。本文中，会学习使用kubeadm安装部署k8s集群。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kubeadm is a tool built to provide kubeadm init and kubeadm join as best-practice “fast paths” for creating Kubernetes clusters.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多内容，参考&lt;a href=&quot;https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Overview of kubeadm&lt;/a&gt;和&lt;a href=&quot;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/install-kubeadm/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Installing kubeadm&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>AutoHotkey配置鼠标光标在屏幕之间瞬移</title>
    <link href="https://www.voidking.com/hobby-autohotkey-mouse-cursor-switch-between-screens/"/>
    <id>https://www.voidking.com/hobby-autohotkey-mouse-cursor-switch-between-screens/</id>
    <published>2020-03-12T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双屏幕带来的问题"><a href="#双屏幕带来的问题" class="headerlink" title="双屏幕带来的问题"></a>双屏幕带来的问题</h1><p>很多同事都会在笔记本电脑之外，再配备一个或两个屏幕，我也另外配备了一块屏幕。但是，使用双屏幕会带来两个问题：一个是窗口的切换移动不方便，另一个是鼠标的切换移动不方便。</p><p><a href="https://www.voidking.com/hobby-windows-shortcut-key/">《Windows快捷键》</a>一文中，提到了两个可以用于多个屏幕窗口操作的快捷键：<br>1、alt+tab，切换窗口。<br>2、win+shift+左右键，可以移动窗口到另一个屏幕。</p><p>窗口的问题基本解决了，但是鼠标的问题还没有解决。怎么办？很多文章说，通过“显示设置”，调整两个屏幕的相对位置，就能更加容易地在两个屏幕间移动鼠标光标。但是，这个方法只是缓解了问题，并没有解决问题，鼠标光标移动依然很麻烦。</p><p>此时，就该本文的主角 <a href="https://www.autohotkey.com/" target="_blank" rel="noopener">AutoHotkey</a> 出马了！</p><a id="more"></a><h1 id="AutoHotkey"><a href="#AutoHotkey" class="headerlink" title="AutoHotkey"></a>AutoHotkey</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>AutoHotkey is a free, open-source scripting language for Windows that allows users to easily create small to complex scripts for all kinds of tasks such as: form fillers, auto-clicking, macros, etc.</p></blockquote><p>正如官方的介绍，autohotkey是一个免费开源的脚本语言，可以帮助用户在Windows上轻松创建脚本，例如：表格填充，自动单击，宏等。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1、访问<a href="https://www.autohotkey.com/" target="_blank" rel="noopener">AutoHotkey官网</a>或者<a href="https://github.com/Lexikos/AutoHotkey_L" target="_blank" rel="noopener">AutoHotkey-github</a>，下载安装包，本文中选择下载 AutoHotkey_1.1.32.00_setup.exe </p><p>2、双击安装即可</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><p>1、新建文件helloworld.ahk，内容为：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">!H::</span></span><br><span class="line"><span class="built_in">Send,</span> helloworld</span><br><span class="line"><span class="keyword">Return</span></span><br></pre></td></tr></table></figure><p>第一行定义快捷键，其中<code>!</code>代表alt，H就是H。<br>第二行Send命令，<code>,</code>后的是参数。<br>第三行Return停止后面的脚本。</p><p>2、启动脚本<br>双击helloworld.ahk，或者右键helloworld.ahk，Run Script。查看系统托盘，可以看到多了一个H的图标，这就是正在运行的脚本。</p><p>3、测试脚本<br>打开任意一个文档，按下 alt+H ，发现会自动填入 “helloworld”，nice。</p><h2 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h2><p>1、符号说明</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#Win</span></span><br><span class="line">!Alt</span><br><span class="line">^Control</span><br><span class="line">+Shift</span><br><span class="line"><span class="meta">&amp;连接两个按键(含鼠标按键)，合并成一个自定义热键</span></span><br></pre></td></tr></table></figure><p>2、常用命令</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Send</span> <span class="string">发送一段字符</span></span><br><span class="line"><span class="attr">SendInput</span> <span class="string">发送一段字符</span></span><br><span class="line"><span class="attr">MsgBox</span> <span class="string">弹出对话框</span></span><br><span class="line"><span class="attr">Run</span> <span class="string">运行一个软件或者打开网页</span></span><br><span class="line"><span class="attr">WinActivate</span> <span class="string">窗口激活</span></span><br><span class="line"><span class="attr">WinWaitActive</span> <span class="string">等待窗口激活</span></span><br></pre></td></tr></table></figure><p>更多内容参考<a href="https://www.autohotkey.com/docs/AutoHotkey.htm" target="_blank" rel="noopener">AutoHotkey官方文档</a>。</p><h1 id="定义快捷键"><a href="#定义快捷键" class="headerlink" title="定义快捷键"></a>定义快捷键</h1><p>利用autohotkey，可以实现自定义快捷键。</p><h2 id="双脚本"><a href="#双脚本" class="headerlink" title="双脚本"></a>双脚本</h2><p>1、新建文件 mousemove1.ahk，内容为</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">!1::</span></span><br><span class="line"><span class="built_in">CoordMode,</span> Mouse, Screen</span><br><span class="line"><span class="built_in">MouseMove,</span> (<span class="built_in">A_ScreenWidth</span> // <span class="number">2</span>), (<span class="built_in">A_ScreenHeight</span> // <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>这段脚本运行后，按下 alt+1 ，鼠标光标会跳转到屏幕1的中心。</p><p>2、新建文件 mousemove2.ahk，内容为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!2::</span><br><span class="line">CoordMode, Mouse, Screen</span><br><span class="line">MouseMove, (A_ScreenWidth + 100), 100</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>这段脚本运行后，按下 alt+2 ，鼠标光标会跳转到屏幕2的左上角的(100,100)位置。</p><p>这两个脚本配合，已经可以鼠标光标在两个屏幕间切换，nice。<br>但是，mousemove2.ahk 还有改进的空间。既然屏幕1是跳转到屏幕中间，那么屏幕2自然也是跳转到屏幕中间更好。</p><p>屏幕2的分辨率为3840x2160，因此脚本修改为：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!2::</span><br><span class="line">CoordMode, Mouse, Screen</span><br><span class="line">MouseMove, (A_ScreenWidth + 1920), 1080</span><br><span class="line">return</span><br></pre></td></tr></table></figure><h2 id="单脚本"><a href="#单脚本" class="headerlink" title="单脚本"></a>单脚本</h2><p>以上，已经实现了鼠标光标在两个屏幕间的完美切换。但是，因为切换时有两个快捷键，所以切换鼠标所在屏幕时，还要想一下是切到1还是切到2，这也是一个可以改进的点。</p><p>创建文件 mousemove.ahk，内容为：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">!J::</span></span><br><span class="line"><span class="built_in">CoordMode,</span> Mouse, Screen</span><br><span class="line"><span class="built_in">MouseGetPos,</span> xpos, ypos</span><br><span class="line">if (xpos &lt;= <span class="built_in">A_ScreenWidth</span>) <span class="literal">and</span> (ypos &lt;= <span class="built_in">A_ScreenHeight</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">    MouseMove,</span> (<span class="built_in">A_ScreenWidth</span> // <span class="number">2</span>), (<span class="built_in">A_ScreenHeight</span> // <span class="number">2</span>)</span><br><span class="line">&#125;else &#123;</span><br><span class="line"><span class="built_in">MouseMove,</span> (<span class="built_in">A_ScreenWidth</span> + <span class="number">1920</span>), <span class="number">1080</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br></pre></td></tr></table></figure><p>这段脚本运行后，按下 alt+J ，可以实现鼠标光标切换到另一个屏幕的中心。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;双屏幕带来的问题&quot;&gt;&lt;a href=&quot;#双屏幕带来的问题&quot; class=&quot;headerlink&quot; title=&quot;双屏幕带来的问题&quot;&gt;&lt;/a&gt;双屏幕带来的问题&lt;/h1&gt;&lt;p&gt;很多同事都会在笔记本电脑之外，再配备一个或两个屏幕，我也另外配备了一块屏幕。但是，使用双屏幕会带来两个问题：一个是窗口的切换移动不方便，另一个是鼠标的切换移动不方便。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/hobby-windows-shortcut-key/&quot;&gt;《Windows快捷键》&lt;/a&gt;一文中，提到了两个可以用于多个屏幕窗口操作的快捷键：&lt;br&gt;1、alt+tab，切换窗口。&lt;br&gt;2、win+shift+左右键，可以移动窗口到另一个屏幕。&lt;/p&gt;
&lt;p&gt;窗口的问题基本解决了，但是鼠标的问题还没有解决。怎么办？很多文章说，通过“显示设置”，调整两个屏幕的相对位置，就能更加容易地在两个屏幕间移动鼠标光标。但是，这个方法只是缓解了问题，并没有解决问题，鼠标光标移动依然很麻烦。&lt;/p&gt;
&lt;p&gt;此时，就该本文的主角 &lt;a href=&quot;https://www.autohotkey.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;AutoHotkey&lt;/a&gt; 出马了！&lt;/p&gt;
    
    </summary>
    
    
      <category term="爱好" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/"/>
    
      <category term="电脑" scheme="https://www.voidking.com/categories/%E7%88%B1%E5%A5%BD/%E7%94%B5%E8%84%91/"/>
    
    
      <category term="windows" scheme="https://www.voidking.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>SSL和TLS</title>
    <link href="https://www.voidking.com/dev-ssl-tls/"/>
    <id>https://www.voidking.com/dev-ssl-tls/</id>
    <published>2020-03-09T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSL和TLS简介"><a href="#SSL和TLS简介" class="headerlink" title="SSL和TLS简介"></a>SSL和TLS简介</h1><p><a href="https://www.voidking.com/dev-hexo-https/">《Hexo启用https加密连接》</a>和<a href="https://www.voidking.com/dev-centos7-install-gitlab/">《CentOS7安装配置GitLab》</a>中都涉及到了SSL/TLS，SSL和TLS是啥？</p><blockquote><p>传输层安全性协议（英语：Transport Layer Security，缩写：TLS）及其前身安全套接层（英语：Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。<br>SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。</p></blockquote><p>更多内容参考<a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A" target="_blank" rel="noopener">维基百科-传输层安全性协议</a></p><a id="more"></a><h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><h2 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h2><blockquote><p>公开密钥基础建设（英语：Public Key Infrastructure，缩写：PKI），又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。<br>密码学上，公开密钥基础建设借着数字证书认证机构（CA）将用户的个人身份跟公开密钥链接在一起。对每个证书中心用户的身份必须是唯一的。链接关系通过注册和发布过程创建，取决于担保级别，链接关系可能由CA的各种软件或在人为监督下完成。PKI的确定链接关系的这一角色称为注册管理中心（Registration Authority，RA）。RA确保公开密钥和个人身份链接，可以防欺诈。在微软的公开密钥基础建设之下，注册管理中心（RA）又被叫做从属数字证书认证机构（Subordinate CA）。</p></blockquote><p>更多内容参考<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD" target="_blank" rel="noopener">维基百科-公开密钥基础架构</a></p><h2 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h2><blockquote><p>数字证书认证机构（英语：Certificate Authority，缩写为CA），也称为电子商务认证中心、电子商务认证授权机构，是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。</p></blockquote><p>更多内容参考<a href="https://zh.wikipedia.org/wiki/%E8%AF%81%E4%B9%A6%E9%A2%81%E5%8F%91%E6%9C%BA%E6%9E%84" target="_blank" rel="noopener">维基百科-证书颁发机构</a></p><h2 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h2><blockquote><p>公钥证书（英语：Public key certificate），又称数字证书（digital certificate）或身份证书（identity certificate）。是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。拥有者凭着此文件，可向电脑系统或其他用户表明身份，从而对方获得信任并授权访问或使用某些敏感的电脑服务。电脑系统或其他用户可以透过一定的程序核实证书上的内容，包括证书有否过期、数字签名是否有效，如果你信任签发的机构，就可以信任证书上的密钥，凭公钥加密与拥有者进行可靠的通信。</p></blockquote><blockquote><p>公钥证书包括自签证书、根证书、中介证书、授权证书、终端实体证书（TLS服务器证书和TLS客户端证书）。</p></blockquote><p>更多内容参考<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E8%AA%8D%E8%AD%89" target="_blank" rel="noopener">维基百科-公钥证书</a></p><h1 id="加密原理"><a href="#加密原理" class="headerlink" title="加密原理"></a>加密原理</h1><p>TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密。其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。<br><img src="http://cdn.voidking.com/@/imgs/ssl-tls/tls.jpg?imageView2/0/w/600" alt=""></p><p>TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。<br>例如，在 HTTPS 协议中，客户端发出请求，服务端会将公钥发给客户端，客户端验证过后生成一个密钥再用公钥加密后发送给服务端（非对称加密），双方会在 TLS 握手过程中生成一个协商密钥（对称密钥），成功后建立加密连接。通信过程中客户端将请求数据用协商密钥加密后发送，服务端也用协商密钥解密，响应也用相同的协商密钥。后续的通信使用对称加密是因为对称加解密快，而握手过程中非对称加密可以保证加密的有效性，但是过程复杂，计算量相对来说也大。</p><p>更多内容参考<a href="https://juejin.im/post/5b88a93df265da43231f1451" target="_blank" rel="noopener">SSL/TLS 详解</a></p><h1 id="自建CA并签发证书"><a href="#自建CA并签发证书" class="headerlink" title="自建CA并签发证书"></a>自建CA并签发证书</h1><p><a href="https://www.voidking.com/dev-centos7-install-gitlab/">《CentOS7安装配置GitLab》</a>一文中，添加SSL一节详细描述了自建CA并签发SSL证书的过程。<br>更多内容，可以参考<a href="https://www.yuanjies.com/?p=539" target="_blank" rel="noopener">基于OpenSSL自建CA和颁发SSL证书</a>和<a href="https://zhuanlan.zhihu.com/p/34788439" target="_blank" rel="noopener">使用 OpenSSL 自建 CA 并签发证书</a>。</p><h1 id="k8s中证书管理"><a href="#k8s中证书管理" class="headerlink" title="k8s中证书管理"></a>k8s中证书管理</h1><h2 id="查看证书"><a href="#查看证书" class="headerlink" title="查看证书"></a>查看证书</h2><p>1、查看证书位置</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps aux | grep kubelet</span><br><span class="line"><span class="comment"># find config file</span></span><br><span class="line">cat /var/<span class="class"><span class="keyword">lib</span>/<span class="title">kubelet</span>/<span class="title">config</span>.<span class="title">yaml</span> | <span class="title">grep</span> <span class="title">staticPodPath</span></span></span><br><span class="line">cd /etc/kubernetes/manifests</span><br><span class="line">cat kube-apiserver.yaml</span><br></pre></td></tr></table></figure><p>2、查看证书详情</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -<span class="keyword">in</span> <span class="regexp">/etc/</span>kubernetes<span class="regexp">/pki/</span>apiserver.crt -text</span><br></pre></td></tr></table></figure><h2 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h2><p>签名，或者签名过期后重新签名</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> <span class="regexp">/etc/</span>kubernetes<span class="regexp">/pki/</span>apiserver-etcd-client.csr -CA <span class="regexp">/etc/</span>kubernetes<span class="regexp">/pki/</span>etcd<span class="regexp">/ca.crt -CAkey /</span>etc<span class="regexp">/kubernetes/</span>pki<span class="regexp">/etcd/</span>ca.key -CAcreateserial -out <span class="regexp">/etc/</span>kubernetes<span class="regexp">/pki/</span>apiserver-etcd-client.crt</span><br></pre></td></tr></table></figure><h2 id="通过API签名"><a href="#通过API签名" class="headerlink" title="通过API签名"></a>通过API签名</h2><p>1、为新用户创建证书</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out jane.<span class="built_in">key</span> <span class="number">2048</span></span><br><span class="line">openssl req -<span class="built_in">new</span> -<span class="built_in">key</span> jane.<span class="built_in">key</span> -subj  <span class="string">"/CN=jane"</span> -out jane.csr</span><br><span class="line">cat jane.csr | <span class="built_in">base64</span> | <span class="built_in">tr</span> -d '\n'</span><br></pre></td></tr></table></figure><p>2、创建jane-csr.yaml文件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: certificates.k8s.io/v1beta1</span><br><span class="line">kind: CertificateSigningRequest</span><br><span class="line">metadata:</span><br><span class="line">  name: jane</span><br><span class="line">spec:</span><br><span class="line">  groups:</span><br><span class="line">  - system:authenticated</span><br><span class="line">  usages:</span><br><span class="line">  - digital signature</span><br><span class="line">  - key encipherment</span><br><span class="line">  -<span class="built_in"> server </span>auth</span><br><span class="line">  -<span class="built_in"> client </span>auth</span><br><span class="line">  request: <span class="attribute">LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZEQ0NBVHdDQVFBd0R6RU5NQXNHQTFVRUF3d0VhbUZ1WlRDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRApnZ0VQQURDQ0FRb0NnZ0VCQUtxbWFIa3BJeE94dDN2UmxJT1FnSUFxSUFsekhQcTRRVTBDTDVhS04xbmY4NXRzCi9LU3o0eml1a1hEQ1NOSVNIT1pWbTY5NzVJa3RXcGFySmhaTXptc1B2eUFSeXFWbWY2L1h0bmwyeE0xblhaUzAKZGc0b0E1dXFuR0w2dHpaQzF3VFY4RVFIZnRlcWYzbUpTN2JtdlppaXFlak12a2UzVkk5RTNFK0xsUUttNnVXRwprS2RDZ2ZHNUszRGJFczR1VzR6M0lMdTdEa1BlamJodWFtYzlxYVZNRVpLSGZ0bnlBYlFITkZVLzhvWVYvR1VzCnRFVWZMRXBBTmlqUFc5U0pPWHJtNUg1NXhOdExXVHMwenU3YlRSZWE0ZjFVaDFCbkZuUkhWYUJqNysydHpITTgKaklJS01KakdWOS9rUVltRmo3UTJZUW1wYzdXWGpPZEFWcHBSc1kwQ0F3RUFBYUFBTUEwR0NTcUdTSWIzRFFFQgpDd1VBQTRJQkFRQUZ2ZUxrUmYxd0xDQmN6cWdMVkJIUGZBa0MzeU1CTDA3VXl0QUlCcVhkR3h1QWtyL3NQT1dkClNxTkhIRkNzQVNmU0lNVC96djBrQS9yN3Fnd25BMCtZREZJSjNzUlBKZkJmNm1Ic3FrbjlPd1htR1E3d0orNFQKWXVCc1lJSllnNWtzVWJoQVhiQkVZekk2OUY0Uk52U0d0K1ZLOHBBdUQzcXRvejJsd3liV0cvaUo4V3FESTZNegpuMURBeDBkRDZmRWhIKy9DTWdSREY5OExCL1ZqMWZOUUlqZ2k3Rmc1aTByU1NtZUdUMllOblJldERZYWN4aWlzCjNFN1B4STdYWDd2QjRjY3pITlUrTG92N3JnSkVXM3lRMXZRTXRCNTZlbWJaNGVnL01XZEhkeWliVXo2aDQ1ZW8KUGN5b3QxaW1wdFRyK3kwSkt0SmJ1YllQOGd2RG5FeFYKLS0tLS1FTkQgQ0VSVElGSUNBVEUgUkVRVUVTVC0tLS0tCg</span>==</span><br></pre></td></tr></table></figure><p>3、签名请求并通过</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f jane-csr.yaml</span><br><span class="line">kubectl <span class="builtin-name">get</span> csr </span><br><span class="line">kubectl certificate approve jane</span><br><span class="line">kubectl <span class="builtin-name">get</span> csr jane -o yaml</span><br><span class="line">kubectl <span class="builtin-name">get</span> csr jane -o <span class="attribute">jsonpath</span>=<span class="string">'&#123;.status.certificate&#125;'</span> | base64 --decode &gt; jane.crt</span><br></pre></td></tr></table></figure><p>或者，直接使用openssl命令进行签名：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -<span class="keyword">in</span> <span class="regexp">/root/</span>jane.csr -CA <span class="regexp">/etc/</span>kubernetes<span class="regexp">/pki/</span>etcd<span class="regexp">/ca.crt -CAkey /</span>etc<span class="regexp">/kubernetes/</span>pki<span class="regexp">/etcd/</span>ca.key -CAcreateserial -out <span class="regexp">/root/</span>jane.crt</span><br></pre></td></tr></table></figure><p>PS：查看签名用的CA</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat <span class="regexp">/etc/</span>kubernetes<span class="regexp">/manifests/</span>kube-controller-manager.yaml | <span class="keyword">grep</span> ca.crt</span><br><span class="line">cat <span class="regexp">/etc/</span>kubernetes<span class="regexp">/manifests/</span>kube-controller-manager.yaml | <span class="keyword">grep</span> ca.key</span><br></pre></td></tr></table></figure><p>更多内容，参考<a href="https://kubernetes.io/docs/tasks/tls/managing-tls-in-a-cluster/" target="_blank" rel="noopener">Manage TLS Certificates in a Cluster</a>。</p><h1 id="证书格式转换"><a href="#证书格式转换" class="headerlink" title="证书格式转换"></a>证书格式转换</h1><p>X.509是一种证书标准，定义了证书中应该包含哪些内容，详情参考RFC5280，SSL使用的就是这种证书标准。<br>同样的X.509证书，可能有不同的编码格式，目前有以下两种编码格式。<br>PEM：Privacy Enhanced Mail，BASE64编码，以”—–BEGIN—–”开头，”—–END—–”结尾。<br>查看PEM格式证书的信息：<br><code>openssl x509 -in cert.pem -text -noout</code></p><p>DER：Distinguished Encoding Rules，二进制格式，不可读。<br>查看DER格式证书的信息：<br><code>openssl x509 -in cert.der -inform der -text -noout</code></p><p>问题来了，k8s中的证书，除了使用pem格式，还有就是crt格式，并没有der格式啊？这是因为，crt只是一个文件后缀，编码格式可能是pem也可能是der。</p><p>那么，pem和der怎样互相转换呢？</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># pem to der</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> cert.crt -outform der -<span class="keyword">out</span> cert.der</span><br><span class="line"><span class="meta"># der to pem</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> cert.crt -inform der -outform pem -<span class="keyword">out</span> cert.pem</span><br></pre></td></tr></table></figure><h1 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h1><p><a href="https://segmentfault.com/a/1190000002568019" target="_blank" rel="noopener">OpenSSL 与 SSL 数字证书概念贴</a><br><a href="https://cloud.tencent.com/developer/article/1114555" target="_blank" rel="noopener">SSL/TLS 原理详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SSL和TLS简介&quot;&gt;&lt;a href=&quot;#SSL和TLS简介&quot; class=&quot;headerlink&quot; title=&quot;SSL和TLS简介&quot;&gt;&lt;/a&gt;SSL和TLS简介&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.voidking.com/dev-hexo-https/&quot;&gt;《Hexo启用https加密连接》&lt;/a&gt;和&lt;a href=&quot;https://www.voidking.com/dev-centos7-install-gitlab/&quot;&gt;《CentOS7安装配置GitLab》&lt;/a&gt;中都涉及到了SSL/TLS，SSL和TLS是啥？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;传输层安全性协议（英语：Transport Layer Security，缩写：TLS）及其前身安全套接层（英语：Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。&lt;br&gt;SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更多内容参考&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;维基百科-传输层安全性协议&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
      <category term="tls" scheme="https://www.voidking.com/tags/tls/"/>
    
  </entry>
  
  <entry>
    <title>K8S集群中etcd备份和恢复</title>
    <link href="https://www.voidking.com/dev-k8s-etcd-backup-restore/"/>
    <id>https://www.voidking.com/dev-k8s-etcd-backup-restore/</id>
    <published>2020-03-08T22:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就像备份数据库一样，很多时候，我们也想对k8s资源配置进行备份。</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">get</span> <span class="built_in">all</span> --<span class="built_in">all</span>-namespaces -o yaml &gt; <span class="built_in">all</span>-deploy-services.yaml</span><br></pre></td></tr></table></figure><p>上面的方法，可以实现对k8s资源配置的备份。但是更好的办法，是对etcd进行备份。本文就学习一下k8s中etcd的备份和恢复方法。</p><a id="more"></a><h1 id="etcd集群状态"><a href="#etcd集群状态" class="headerlink" title="etcd集群状态"></a>etcd集群状态</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">HOST_1</span>=10.240.0.17</span><br><span class="line"><span class="attribute">HOST_2</span>=10.240.0.18</span><br><span class="line"><span class="attribute">HOST_3</span>=10.240.0.19</span><br><span class="line"><span class="attribute">ENDPOINTS</span>=<span class="variable">$HOST_1</span>:2379,$HOST_2:2379,$HOST_3:2379</span><br><span class="line">etcdctl <span class="attribute">--endpoints</span>=<span class="variable">$ENDPOINTS</span> member list</span><br><span class="line">etcdctl <span class="attribute">--write-out</span>=table <span class="attribute">--endpoints</span>=<span class="variable">$ENDPOINTS</span> endpoint status</span><br><span class="line">etcdctl <span class="attribute">--endpoints</span>=<span class="variable">$ENDPOINTS</span> endpoint health</span><br></pre></td></tr></table></figure><h1 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h1><p>1、查看配置</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod etcd-<span class="keyword">master</span> <span class="title">-n</span> kube-system | grep Command -i -A <span class="number">20</span></span><br></pre></td></tr></table></figure><p>看到Command字段为：</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Command:</span><br><span class="line">  etcd</span><br><span class="line">  -<span class="ruby">-advertise-client-urls=<span class="symbol">https:</span>/<span class="regexp">/172.17.0.10:2379</span></span></span><br><span class="line"><span class="ruby">  --cert-file=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/server.crt</span></span></span><br><span class="line"><span class="ruby">  --client-cert-auth=<span class="literal">true</span></span></span><br><span class="line"><span class="ruby">  --data-dir=<span class="regexp">/var/lib</span><span class="regexp">/etcd</span></span></span><br><span class="line"><span class="ruby">  --initial-advertise-peer-urls=<span class="symbol">https:</span>/<span class="regexp">/172.17.0.10:2380</span></span></span><br><span class="line"><span class="ruby">  --initial-cluster=master=<span class="symbol">https:</span>/<span class="regexp">/172.17.0.10:2380</span></span></span><br><span class="line"><span class="ruby">  --key-file=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/server.key</span></span></span><br><span class="line"><span class="ruby">  --listen-client-urls=<span class="symbol">https:</span>/<span class="regexp">/127.0.0.1:2379,https:/</span><span class="regexp">/172.17.0.10:2379</span></span></span><br><span class="line"><span class="ruby">  --listen-metrics-urls=<span class="symbol">http:</span>/<span class="regexp">/127.0.0.1:2381</span></span></span><br><span class="line"><span class="ruby">  --listen-peer-urls=<span class="symbol">https:</span>/<span class="regexp">/172.17.0.10:2380</span></span></span><br><span class="line"><span class="ruby">  --name=master</span></span><br><span class="line"><span class="ruby">  --peer-cert-file=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/peer.crt</span></span></span><br><span class="line"><span class="ruby">  --peer-client-cert-auth=<span class="literal">true</span></span></span><br><span class="line"><span class="ruby">  --peer-key-file=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/peer.key</span></span></span><br><span class="line"><span class="ruby">  --peer-trusted-ca-file=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/ca.crt</span></span></span><br><span class="line"><span class="ruby">  --snapshot-count=<span class="number">10000</span></span></span><br><span class="line"><span class="ruby">  --trusted-ca-file=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/ca.crt</span></span></span><br></pre></td></tr></table></figure><p>或者查看/etc/kubernetes/manifests/etcd.yaml。</p><p>2、执行备份</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">-<span class="ruby">-endpoints=<span class="symbol">https:</span>/<span class="regexp">/[127.0.0.1]:2379 \</span></span></span><br><span class="line"><span class="ruby">--cacert=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/ca.crt \</span></span></span><br><span class="line"><span class="ruby">--cert=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/server.crt \</span></span></span><br><span class="line"><span class="ruby">--key=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/server.key \</span></span></span><br><span class="line"><span class="ruby">snapshot save /tmp/snapshot-pre-boot.db</span></span><br></pre></td></tr></table></figure><p>3、查看备份</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">-<span class="ruby">-endpoints=<span class="symbol">https:</span>/<span class="regexp">/[127.0.0.1]:2379 \</span></span></span><br><span class="line"><span class="ruby">--cacert=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/ca.crt \</span></span></span><br><span class="line"><span class="ruby">--cert=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/server.crt \</span></span></span><br><span class="line"><span class="ruby">--key=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/server.key \</span></span></span><br><span class="line"><span class="ruby">snapshot status /tmp/snapshot-pre-boot.db -w table</span></span><br></pre></td></tr></table></figure><h1 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h1><p>1、恢复etcd数据</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">-<span class="ruby">-endpoints=<span class="symbol">https:</span>/<span class="regexp">/[127.0.0.1]:2379 \</span></span></span><br><span class="line"><span class="ruby">--cacert=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/ca.crt \</span></span></span><br><span class="line"><span class="ruby">--cert=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/server.crt \</span></span></span><br><span class="line"><span class="ruby">--key=<span class="regexp">/etc/kubernetes</span><span class="regexp">/pki/etcd</span><span class="regexp">/server.key \</span></span></span><br><span class="line"><span class="ruby">--initial-cluster=master=<span class="symbol">https:</span>/<span class="regexp">/127.0.0.1:2380 \</span></span></span><br><span class="line"><span class="ruby">--initial-cluster-token etcd-cluster-<span class="number">1</span> \</span></span><br><span class="line"><span class="ruby">--initial-advertise-peer-urls=<span class="symbol">https:</span>/<span class="regexp">/127.0.0.1:2380 \</span></span></span><br><span class="line"><span class="ruby">--name=master \</span></span><br><span class="line"><span class="ruby">--data-dir /var/lib/etcd-from-backup \</span></span><br><span class="line"><span class="ruby">snapshot restore /tmp/snapshot-pre-boot.db</span></span><br></pre></td></tr></table></figure><p>2、修改etcd.yaml<br><code>vim /etc/kubernetes/manifests/etcd.yaml</code>，如下修改：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">Update</span> --data-dir <span class="keyword">to</span> <span class="keyword">use</span> new target location</span><br><span class="line">--data-dir=/var/lib/etcd-<span class="keyword">from</span>-backup</span><br><span class="line"></span><br><span class="line"># <span class="keyword">Update</span> new initial-<span class="keyword">cluster</span>-token <span class="keyword">to</span> specify new <span class="keyword">cluster</span></span><br><span class="line">--initial-<span class="keyword">cluster</span>-token=etcd-<span class="keyword">cluster</span><span class="number">-1</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">Update</span> volumes <span class="keyword">and</span> volume mounts <span class="keyword">to</span> point <span class="keyword">to</span> new <span class="keyword">path</span></span><br><span class="line">    volumeMounts:</span><br><span class="line">    - mountPath: /var/lib/etcd-<span class="keyword">from</span>-backup</span><br><span class="line">      name: etcd-data</span><br><span class="line">    - mountPath: /etc/kubernetes/pki/etcd</span><br><span class="line">      name: etcd-certs</span><br><span class="line">  hostNetwork: <span class="literal">true</span></span><br><span class="line">  priorityClassName: <span class="keyword">system</span>-<span class="keyword">cluster</span>-critical</span><br><span class="line">  volumes:</span><br><span class="line">  - hostPath:</span><br><span class="line">      <span class="keyword">path</span>: /var/lib/etcd-<span class="keyword">from</span>-backup</span><br><span class="line">      <span class="built_in">type</span>: DirectoryOrCreate</span><br><span class="line">    name: etcd-data</span><br><span class="line">  - hostPath:</span><br><span class="line">      <span class="keyword">path</span>: /etc/kubernetes/pki/etcd</span><br><span class="line">      <span class="built_in">type</span>: DirectoryOrCreate</span><br><span class="line">    name: etcd-certs</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;就像备份数据库一样，很多时候，我们也想对k8s资源配置进行备份。&lt;/p&gt;
&lt;figure class=&quot;highlight q&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;kubectl &lt;span class=&quot;built_in&quot;&gt;get&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;all&lt;/span&gt; --&lt;span class=&quot;built_in&quot;&gt;all&lt;/span&gt;-namespaces -o yaml &amp;gt; &lt;span class=&quot;built_in&quot;&gt;all&lt;/span&gt;-deploy-services.yaml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面的方法，可以实现对k8s资源配置的备份。但是更好的办法，是对etcd进行备份。本文就学习一下k8s中etcd的备份和恢复方法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用kubeadm升级K8S集群</title>
    <link href="https://www.voidking.com/dev-kubeadm-upgrade/"/>
    <id>https://www.voidking.com/dev-kubeadm-upgrade/</id>
    <published>2020-03-08T20:00:00.000Z</published>
    <updated>2020-06-28T00:39:48.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="K8S组件版本说明"><a href="#K8S组件版本说明" class="headerlink" title="K8S组件版本说明"></a>K8S组件版本说明</h1><p>k8s集群中的常见组件包括：<br>A类：kube-apiserver<br>B类：controller-manager、kube-scheduler<br>C类：kubelet、kube-proxy<br>D类：etcd cluster、CoreDNS<br>E类：kubectl</p><p>组件的版本号一般表示为 major.minor.patch，比如v1.10.3。其中，A类组件是主要组件，以它为版本基准。比如，A类组件版本的minor号为x，那么B类组件版本必须为x或者x-1，C类组件版本必须为x、x-1或者x-2，E类组件版本必须为x、x-1或者x+1。而D类组件，和A类组件不是同一版本体系，版本兼容情况需要查看文档。整理成表格如下：</p><table><thead><tr><th>组件类别</th><th>minor版本</th><th>组件</th></tr></thead><tbody><tr><td>A类</td><td>x</td><td>kube-apiserver</td></tr><tr><td>B类</td><td>x、x-1</td><td>controller-manager、kube-scheduler</td></tr><tr><td>C类</td><td>x、x-1、x-2</td><td>kubelet、kube-proxy</td></tr><tr><td>E类</td><td>x、x-1、x+1</td><td>kubectl</td></tr><tr><td>D类</td><td>查看文档</td><td>etcd cluster、CoreDNS</td></tr></tbody></table><p>本文学习使用kubeadm进行k8s集群的升级。</p><a id="more"></a><h1 id="升级顺序"><a href="#升级顺序" class="headerlink" title="升级顺序"></a>升级顺序</h1><p>推荐的升级方法，是根据minor版本号逐级进行升级。比如v1.10.0想要升级到v1.13.0，不应该直接升级到v1.13.0，而是应该v1.10.0-&gt;v1.11.0-&gt;v1.12.0-&gt;v1.13.0。</p><p>升级顺序一般为：<br>1、升级kubeadm<br>2、升级master node<br>3、升级worker node<br>4、升级kubelet</p><h1 id="升级操作"><a href="#升级操作" class="headerlink" title="升级操作"></a>升级操作</h1><p>以v1.11.0升级v1.12.0为例。</p><h2 id="master节点"><a href="#master节点" class="headerlink" title="master节点"></a>master节点</h2><p>1、查看升级帮助<br><code>kubeadm upgrade plan</code></p><p>2、升级kubeadm</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span><span class="built_in"> upgrade </span>-y <span class="attribute">kubeadm</span>=1.12.0-00</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">apt install <span class="attribute">kubeadm</span>=1.12.0-00</span><br></pre></td></tr></table></figure><p>3、升级k8s的AB类组件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm<span class="built_in"> upgrade </span>apply v1.12.0</span><br></pre></td></tr></table></figure><p>此时使用kubectl get nodes，看到的version依然是v1.11.0，因为这里显示的是kubelet的版本，而不是kube-apiserver的版本。</p><p>4、升级master节点的kubelet</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install kubelet=<span class="number">1.12</span><span class="number">.0</span><span class="number">-00</span></span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><h2 id="worker节点"><a href="#worker节点" class="headerlink" title="worker节点"></a>worker节点</h2><p>1、驱逐worker节点的pods，封锁节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl drain <span class="keyword">node</span><span class="title">-1</span></span><br><span class="line">kubectl cordon <span class="keyword">node</span><span class="title">-1</span></span><br></pre></td></tr></table></figure><p>2、升级kubeadm和kubectl</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt-<span class="builtin-name">get</span> install <span class="attribute">kubeadm</span>=1.12.0-00</span><br><span class="line">apt-<span class="builtin-name">get</span> install <span class="attribute">kubelet</span>=1.12.0-00</span><br><span class="line">kubeadm<span class="built_in"> upgrade </span>node<span class="built_in"> config </span>--kubelet-version v1.12.0</span><br><span class="line">systemctl restart kubelet</span><br></pre></td></tr></table></figure><p>3、解除节点封锁<br><code>kubectl uncordon node-1</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;K8S组件版本说明&quot;&gt;&lt;a href=&quot;#K8S组件版本说明&quot; class=&quot;headerlink&quot; title=&quot;K8S组件版本说明&quot;&gt;&lt;/a&gt;K8S组件版本说明&lt;/h1&gt;&lt;p&gt;k8s集群中的常见组件包括：&lt;br&gt;A类：kube-apiserver&lt;br&gt;B类：controller-manager、kube-scheduler&lt;br&gt;C类：kubelet、kube-proxy&lt;br&gt;D类：etcd cluster、CoreDNS&lt;br&gt;E类：kubectl&lt;/p&gt;
&lt;p&gt;组件的版本号一般表示为 major.minor.patch，比如v1.10.3。其中，A类组件是主要组件，以它为版本基准。比如，A类组件版本的minor号为x，那么B类组件版本必须为x或者x-1，C类组件版本必须为x、x-1或者x-2，E类组件版本必须为x、x-1或者x+1。而D类组件，和A类组件不是同一版本体系，版本兼容情况需要查看文档。整理成表格如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;组件类别&lt;/th&gt;
&lt;th&gt;minor版本&lt;/th&gt;
&lt;th&gt;组件&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td&gt;A类&lt;/td&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;kube-apiserver&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B类&lt;/td&gt;
&lt;td&gt;x、x-1&lt;/td&gt;
&lt;td&gt;controller-manager、kube-scheduler&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;C类&lt;/td&gt;
&lt;td&gt;x、x-1、x-2&lt;/td&gt;
&lt;td&gt;kubelet、kube-proxy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;E类&lt;/td&gt;
&lt;td&gt;x、x-1、x+1&lt;/td&gt;
&lt;td&gt;kubectl&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;D类&lt;/td&gt;
&lt;td&gt;查看文档&lt;/td&gt;
&lt;td&gt;etcd cluster、CoreDNS&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;本文学习使用kubeadm进行k8s集群的升级。&lt;/p&gt;
    
    </summary>
    
    
      <category term="专业" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/"/>
    
      <category term="运维" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="k8s" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/categories/%E4%B8%93%E4%B8%9A/%E8%BF%90%E7%BB%B4/docker/"/>
    
    
      <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
      <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
  </entry>
  
</feed>
