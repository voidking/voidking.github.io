<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>好好学习的郝</title>
  
  <subtitle>一个计算机技术爱好者与学习者</subtitle>
  <link href="https://www.voidking.com/atom.xml" rel="self"/>
  
  <link href="https://www.voidking.com/"/>
  <updated>2024-11-30T08:00:00.000Z</updated>
  <id>https://www.voidking.com/</id>
  
  <author>
    <name>好好学习的郝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置AList</title>
    <link href="https://www.voidking.com/dev-docker-alist/"/>
    <id>https://www.voidking.com/dev-docker-alist/</id>
    <published>2024-11-30T08:00:00.000Z</published>
    <updated>2024-11-30T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AList简介"><span class="post-title-index">1. </span><a href="#AList简介" class="headerlink" title="AList简介"></a>AList简介</h1><blockquote><p>AList是一个支持多种存储介质的文件列表程序，基于 Gin 和 Solidjs 实现。</p></blockquote><p>相关文档：</p><ul><li><a href="https://github.com/AlistGo/alist">github - AlistGo/alist</a></li><li><a href="https://alist.nn.ci/">AList Docs</a></li><li><a href="https://www.voidking.com/dev-docker-filebrowser/">《好好学Docker：使用Docker安装配置FileBrowser》</a></li></ul><span id="more"></span><h1 id="AList优点"><span class="post-title-index">2. </span><a href="#AList优点" class="headerlink" title="AList优点"></a>AList优点</h1><ul><li>部署方便，开箱即用；支持Docker部署</li><li>支持多种存储介质，包括：本地存储、FTP、WebDAV、S3、阿里云盘、夸克网盘、百度网盘、天翼云盘等等。</li><li>支持作为<a href="https://alist.nn.ci/zh/guide/webdav.html">WebDav</a>服务器</li><li>支持LDAP</li><li>文件预览（PDF、markdown、代码、纯文本等）</li><li>画廊模式下的图像预览</li><li>视频和音频预览，支持歌词和字幕</li><li>Office 文档预览（docx、pptx、xlsx等）</li><li>受保护的路由（密码保护和身份验证）</li><li>文件永久链接复制和直接文件下载</li><li>文件/文件夹打包下载</li><li>网页上传(可以允许访客上传)，删除，新建文件夹，重命名，移动，复制</li><li>跨存储复制文件</li><li>离线下载</li><li>单线程下载/串流的多线程下载加速</li></ul><h1 id="安装AList"><span class="post-title-index">3. </span><a href="#安装AList" class="headerlink" title="安装AList"></a>安装AList</h1><p>参考文档：<a href="https://alist.nn.ci/guide/install/docker.html">AList Install - Use Docker</a></p><p>1、下载 alist 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull xhofe/alist:v3.40.0-ffmpeg</span><br></pre></td></tr></table></figure><p>2、启动 alist 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run --name alist -d \</span><br><span class="line">  --restart=unless-stopped \</span><br><span class="line">  -v /opt/alist/data:/opt/alist/data \</span><br><span class="line">  -v /opt/alist/root:/opt/alist/root \</span><br><span class="line">  -p 5244:5244 \</span><br><span class="line">  -e PUID=0 \</span><br><span class="line">  -e PGID=0 \</span><br><span class="line">  -e UMASK=022 \</span><br><span class="line">  -e <span class="string">&quot;TZ=Asia/Shanghai&quot;</span> \</span><br><span class="line">  xhofe/alist:v3.40.0-ffmpeg </span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>/opt/alist/data 目录，用于存储alist程序本身的数据</li><li>/opt/alist/root 目录，用于对外共享数据</li></ul><p>3、检查运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep alist</span><br><span class="line">docker logs alist</span><br></pre></td></tr></table></figure><h1 id="使用AList"><span class="post-title-index">4. </span><a href="#使用AList" class="headerlink" title="使用AList"></a>使用AList</h1><h2 id="设置密码"><span class="post-title-index">4.1. </span><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><p>3.25.0以上版本将密码改成加密方式存储的hash值，无法直接反算出密码，如果忘记了密码只能通过重新 随机生成 或者 手动设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 随机生成一个密码</span></span><br><span class="line">docker <span class="built_in">exec</span> -it alist ./alist admin random</span><br><span class="line"><span class="comment"># 手动设置一个密码,`NEW_PASSWORD`是指你需要设置的密码</span></span><br><span class="line">docker <span class="built_in">exec</span> -it alist ./alist admin <span class="built_in">set</span> NEW_PASSWORD</span><br></pre></td></tr></table></figure><h2 id="访问alist"><span class="post-title-index">4.2. </span><a href="#访问alist" class="headerlink" title="访问alist"></a>访问alist</h2><p>1、浏览器访问 alist<br>假设主机IP为 192.168.56.101，那么浏览器访问 <a href="http://192.168.56.101:5244/">http://192.168.56.101:5244</a></p><p>2、登录 alist<br>用户名 admin，密码是上一节中设置的密码。</p><h2 id="配置存储介质"><span class="post-title-index">4.3. </span><a href="#配置存储介质" class="headerlink" title="配置存储介质"></a>配置存储介质</h2><p>1、点击管理，存储，添加</p><p>2、添加本机存储</p><ul><li>驱动选择本机存储</li><li>根文件夹路径填入 <code>/opt/alist/root/</code></li><li>挂载路径填入 <code>/</code></li><li>启用缩略图</li><li>其他选项保持默认</li></ul><p>3、查看文件<br>浏览器访问 <a href="http://192.168.56.101:5244/">http://192.168.56.101:5244</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;AList简介&quot;&gt;&lt;a href=&quot;#AList简介&quot; class=&quot;headerlink&quot; title=&quot;AList简介&quot;&gt;&lt;/a&gt;AList简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;AList是一个支持多种存储介质的文件列表程序，基于 Gin 和 Solidjs 实现。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/AlistGo/alist&quot;&gt;github - AlistGo/alist&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://alist.nn.ci/&quot;&gt;AList Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-docker-filebrowser/&quot;&gt;《好好学Docker：使用Docker安装配置FileBrowser》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：容器指标查看工具ctop</title>
    <link href="https://www.voidking.com/dev-docker-ctop/"/>
    <id>https://www.voidking.com/dev-docker-ctop/</id>
    <published>2024-11-23T08:00:00.000Z</published>
    <updated>2024-11-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ctop简介"><span class="post-title-index">1. </span><a href="#ctop简介" class="headerlink" title="ctop简介"></a>ctop简介</h1><p>ctop 是一个类似于 top 的容器指标查看工具。<br>ctop 提供了查询多个容器实时指标的视图，以及查询特定容器实时指标的视图。ctop 内置对 Docker 和 runC 的支持；未来版本计划支持其他容器和集群系统的连接器。</p><p>相关文档：</p><ul><li><a href="https://github.com/bcicen/ctop">github - bcicen/ctop</a></li><li><a href="https://mp.weixin.qq.com/s/BXLZq2lc3OdRAeY551tTmg">容器的top工具：ctop</a></li></ul><span id="more"></span><h1 id="安装ctop"><span class="post-title-index">2. </span><a href="#安装ctop" class="headerlink" title="安装ctop"></a>安装ctop</h1><p>推荐使用二进制安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/bcicen/ctop/releases/download/v0.7.3/ctop-0.7.3-linux-amd64 -O /usr/local/bin/ctop</span><br><span class="line"><span class="built_in">chmod</span> +x /usr/local/bin/ctop</span><br></pre></td></tr></table></figure><h1 id="使用ctop"><span class="post-title-index">3. </span><a href="#使用ctop" class="headerlink" title="使用ctop"></a>使用ctop</h1><h2 id="查看全部容器指标"><span class="post-title-index">3.1. </span><a href="#查看全部容器指标" class="headerlink" title="查看全部容器指标"></a>查看全部容器指标</h2><p>1、启动 ctop，默认界面查看全部容器指标</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctop</span><br></pre></td></tr></table></figure><p>2、退出 ctop<br>按下 <code>q</code>，退出 ctop</p><h2 id="容器排序"><span class="post-title-index">3.2. </span><a href="#容器排序" class="headerlink" title="容器排序"></a>容器排序</h2><p>ctop界面中，按下 <code>s</code> ，选择排序字段。<br>支持的字段包括：cpu，io，mem，mem %，name，pids，net，state</p><h2 id="查看单个容器指标"><span class="post-title-index">3.3. </span><a href="#查看单个容器指标" class="headerlink" title="查看单个容器指标"></a>查看单个容器指标</h2><p>ctop界面中，选中容器后，按下 <code>o</code></p><h2 id="查看单个容器日志"><span class="post-title-index">3.4. </span><a href="#查看单个容器日志" class="headerlink" title="查看单个容器日志"></a>查看单个容器日志</h2><p>ctop页面中，选中容器后，按下 <code>l</code></p><h2 id="进入容器内部"><span class="post-title-index">3.5. </span><a href="#进入容器内部" class="headerlink" title="进入容器内部"></a>进入容器内部</h2><p>ctop页面中，选中容器后，按下 <code>e</code></p><h2 id="查找容器"><span class="post-title-index">3.6. </span><a href="#查找容器" class="headerlink" title="查找容器"></a>查找容器</h2><p>查找：ctop界面中，按下 <code>f</code>，输入关键词筛选容器，回车<br>退出查找：ctop界面中，按下 <code>f</code>，删除所有关键词，回车</p><h2 id="更多操作"><span class="post-title-index">3.7. </span><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h2><p>ctop界面中，选中容器后回车，出现菜单<br>此时可以选择查看单个容器指标、查看单个容器日志，还可以停止、暂停、重启、进入容器内部。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;ctop简介&quot;&gt;&lt;a href=&quot;#ctop简介&quot; class=&quot;headerlink&quot; title=&quot;ctop简介&quot;&gt;&lt;/a&gt;ctop简介&lt;/h1&gt;&lt;p&gt;ctop 是一个类似于 top 的容器指标查看工具。&lt;br&gt;ctop 提供了查询多个容器实时指标的视图，以及查询特定容器实时指标的视图。ctop 内置对 Docker 和 runC 的支持；未来版本计划支持其他容器和集群系统的连接器。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bcicen/ctop&quot;&gt;github - bcicen/ctop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/BXLZq2lc3OdRAeY551tTmg&quot;&gt;容器的top工具：ctop&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：自建RustDesk Server</title>
    <link href="https://www.voidking.com/dev-docker-install-rustdesk-server/"/>
    <id>https://www.voidking.com/dev-docker-install-rustdesk-server/</id>
    <published>2024-11-09T08:00:00.000Z</published>
    <updated>2024-11-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RustDesk简介"><span class="post-title-index">1. </span><a href="#RustDesk简介" class="headerlink" title="RustDesk简介"></a>RustDesk简介</h1><p>RustDesk 是一款开源的远程桌面软件，是 TeamViewer、向日葵的替代软件，提供了高效、安全的远程访问解决方案。</p><p>相关文档：</p><ul><li><a href="https://github.com/rustdesk/rustdesk">github - rustdesk/rustdesk</a></li><li><a href="https://rustdesk.com/zh-cn/">RustDesk官网</a></li><li><a href="https://rustdesk.com/docs/zh-cn/">RustDesk官方文档</a></li><li><a href="https://www.cnblogs.com/ryanyangcs/p/18186163">RustDesk 自建服务器部署和使用教程</a></li><li><a href="https://bbs.deepin.org/zh/post/253836">远程桌面软件 RustDesk</a></li></ul><span id="more"></span><h1 id="安装RustDesk-Client"><span class="post-title-index">2. </span><a href="#安装RustDesk-Client" class="headerlink" title="安装RustDesk Client"></a>安装RustDesk Client</h1><h2 id="Ubuntu22中安装RustDesk-Client"><span class="post-title-index">2.1. </span><a href="#Ubuntu22中安装RustDesk-Client" class="headerlink" title="Ubuntu22中安装RustDesk Client"></a>Ubuntu22中安装RustDesk Client</h2><p>本节中，我们在 Ubuntu22 中安装支持 Wayland 的 RustDesk Client。</p><p>1、下载 RustDesk Client 安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/rustdesk/rustdesk/releases/download/nightly/rustdesk-1.3.3-x86_64.deb</span><br></pre></td></tr></table></figure><p>2、安装 RustDesk Client</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install -fy ./rustdesk-1.3.3-x86_64.deb</span><br></pre></td></tr></table></figure><p>3、启动 RustDesk Client<br>在图形化界面中，启动RustDesk Client，记录下ID和密码用于远程控制。<br>建议设置一个固定的密码，并设置开机自动启动。</p><h2 id="MacOS中安装-RustDesk-Client"><span class="post-title-index">2.2. </span><a href="#MacOS中安装-RustDesk-Client" class="headerlink" title="MacOS中安装 RustDesk Client"></a>MacOS中安装 RustDesk Client</h2><p>1、下载 RustDesk Client 安装包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/rustdesk/rustdesk/releases/download/nightly/rustdesk-1.3.3-x86_64.dmg</span><br></pre></td></tr></table></figure><p>2、安装 RustDesk Client<br>双击 dmg 文件，拖拽安装</p><p>3、启动 RustDesk Client</p><h1 id="使用RustDesk进行远程操作"><span class="post-title-index">3. </span><a href="#使用RustDesk进行远程操作" class="headerlink" title="使用RustDesk进行远程操作"></a>使用RustDesk进行远程操作</h1><p>在两台设备上安装并启动 RustDesk Client，然后就可以像Teamviewer一样，输入对方的ID和密码，进行远程控制了。</p><p>RustDesk首次建立连接后会提示 <code>请选择要分享的画面（对端操作）</code> ，也就是说必须要求对端操作才能开始远程。<br>对端选择屏幕并记住选择后，后续再建立连接就不需要对端操作了。</p><p>注意：使用RustDesk远程时，哪怕对端已经锁屏息屏，也可以唤醒并进行远程，相当于本地操作远程屏幕。</p><p>重启主机后再次连接，会提示 <code>不支持使用 Wayland 登录界面</code> ，说明RustDesk对 Wayland 的支持并不好。详情参考：<a href="https://rustdesk.com/docs/en/client/linux/#login-screen">Login screen using Wayland is not supported yet.</a></p><h1 id="自建RustDesk-Server"><span class="post-title-index">4. </span><a href="#自建RustDesk-Server" class="headerlink" title="自建RustDesk Server"></a>自建RustDesk Server</h1><h2 id="为什么需要自建RustDesk-Server？"><span class="post-title-index">4.1. </span><a href="#为什么需要自建RustDesk-Server？" class="headerlink" title="为什么需要自建RustDesk Server？"></a>为什么需要自建RustDesk Server？</h2><p>以上，我们已经可以使用RustDesk Client，为什么还需要自建RustDesk Server？<br>两个原因：</p><ul><li>由于被诈骗分子频繁使用，该项目现已暂停国内服务。</li><li>使用默认的RustDesk Server，稳定性和隐私性不能保证。</li></ul><p>因此，自建RustDesk Server还是有必要的。</p><h2 id="基于Docker搭建RustDesk-Server"><span class="post-title-index">4.2. </span><a href="#基于Docker搭建RustDesk-Server" class="headerlink" title="基于Docker搭建RustDesk Server"></a>基于Docker搭建RustDesk Server</h2><p>参考文档：</p><ul><li><a href="https://rustdesk.com/docs/zh-cn/self-host/">RustDesk 自建服务器</a></li><li><a href="https://rustdesk.com/docs/en/self-host/rustdesk-server-oss/docker/">Install your own server with Docker</a></li></ul><p>1、准备软件目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /opt/rustdesk/data</span><br></pre></td></tr></table></figure><p>2、准备 docker-compose.yml</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt/rustdesk/</span><br><span class="line">vim docker-compose.yml</span><br></pre></td></tr></table></figure><p>写入如下内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">hbbs:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:1.1.12</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbs</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/rustdesk/data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">depends_on:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">hbbr:</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">rustdesk/rustdesk-server:1.1.12</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">hbbr</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/opt/rustdesk/data:/root</span></span><br><span class="line">    <span class="attr">network_mode:</span> <span class="string">&quot;host&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">unless-stopped</span></span><br></pre></td></tr></table></figure><p>3、启动 RustDesk Server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><p>4、查看 RustDesk Server 状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose ps</span><br><span class="line">docker ps | grep rustdesk</span><br><span class="line">docker logs hbbs</span><br><span class="line">docker logs hbbr</span><br></pre></td></tr></table></figure><p>5、获取服务器Key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs hbbs</span><br></pre></td></tr></table></figure><p>可以在日志中看到一个Key，记录下来。</p><h2 id="开放端口"><span class="post-title-index">4.3. </span><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h2><p>hbbs默认监听端口：</p><ul><li>21114（TCP）：用于 Web 控制台，仅在 Pro 版本中可用</li><li>21115（TCP）：用于 NAT 类型测试</li><li>21116（TCP/UDP）：UDP 用于 ID 注册和心跳服务，TCP 用于 TCP 打孔和连接服务</li><li>21118（TCP）：用于支持Web客户端，可选禁用</li></ul><p>hbbr默认监听端口：</p><ul><li>21117（TCP）：用于 Relay 服务</li><li>21119（TCP）：用于支持Web客户端，可选禁用</li></ul><h1 id="配置使用Rust-Server"><span class="post-title-index">5. </span><a href="#配置使用Rust-Server" class="headerlink" title="配置使用Rust Server"></a>配置使用Rust Server</h1><p>假设 Rust Server 的IP地址为 <code>8.136.12.13</code></p><p>1、打开Rust Client设置页面</p><p>2、网络，解锁网络设置</p><ul><li>ID服务器：填入 <code>8.136.13.58:21116</code></li><li>中继服务器：填入 <code>8.136.13.58:21117</code></li><li>Key：填入【基于Docker搭建RustDesk Server】一节中获取到的Key。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;RustDesk简介&quot;&gt;&lt;a href=&quot;#RustDesk简介&quot; class=&quot;headerlink&quot; title=&quot;RustDesk简介&quot;&gt;&lt;/a&gt;RustDesk简介&lt;/h1&gt;&lt;p&gt;RustDesk 是一款开源的远程桌面软件，是 TeamViewer、向日葵的替代软件，提供了高效、安全的远程访问解决方案。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/rustdesk/rustdesk&quot;&gt;github - rustdesk/rustdesk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustdesk.com/zh-cn/&quot;&gt;RustDesk官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://rustdesk.com/docs/zh-cn/&quot;&gt;RustDesk官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/ryanyangcs/p/18186163&quot;&gt;RustDesk 自建服务器部署和使用教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bbs.deepin.org/zh/post/253836&quot;&gt;远程桌面软件 RustDesk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="linux" scheme="https://www.voidking.com/categories/engineering/linux/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="ubuntu" scheme="https://www.voidking.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>好好学Linux：Ubuntu18 升级到 Ubuntu22</title>
    <link href="https://www.voidking.com/dev-upgrade-ubuntu18-to-ubuntu22/"/>
    <id>https://www.voidking.com/dev-upgrade-ubuntu18-to-ubuntu22/</id>
    <published>2024-11-09T08:00:00.000Z</published>
    <updated>2024-11-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要升级Ubuntu？"><span class="post-title-index">1. </span><a href="#为什么要升级Ubuntu？" class="headerlink" title="为什么要升级Ubuntu？"></a>为什么要升级Ubuntu？</h1><p>Ubuntu18 的常规支持已于2023年4月结束，而 Ubuntu22 有更长的常规支持周期，这意味着在未来几年内，用户将持续获得包括功能更新、安全更新和错误修复在内的全面支持，确保系统的稳定性和安全性。</p><p>Ubuntu22 采用了较新的 Linux 内核版本，新内核通常会带来更好的硬件支持、性能优化和安全性增强。</p><p>此外，最重要的是，很多Ubuntu中的软件仅支持最新版本的Ubuntu，比如Waydroid，比如麟卓卓懿。</p><p>因此，虽然升级Ubuntu比较麻烦，并且存在一定的风险，但是是值得的。</p><p>参考文档：</p><ul><li><a href="https://ubuntu.com/tutorials/upgrading-ubuntu-desktop#1-before-you-start">Upgrade Ubuntu desktop</a></li><li><a href="https://askubuntu.com/questions/1454762/18-04-22-04-upgrade">18.04 -&gt; 22.04 upgrade</a></li><li><a href="https://www.reddit.com/r/Ubuntu/comments/x3z08c/upgrade_ubuntu_1804_to_2204/">Upgrade ubuntu 18.04 to 22.04</a></li><li><a href="https://blog.csdn.net/liufangaliya/article/details/134132836">ubuntu18.04如何更新到22.04</a></li></ul><span id="more"></span><h1 id="Ubuntu18升级Ubuntu20"><span class="post-title-index">2. </span><a href="#Ubuntu18升级Ubuntu20" class="headerlink" title="Ubuntu18升级Ubuntu20"></a>Ubuntu18升级Ubuntu20</h1><p>Ubuntu不能跨版本升级，只能逐个版本升级，或者逐个LTS版本升级。因此需要先从Ubuntu18升级到Ubuntu20，再从Ubuntu20升级到Ubuntu22。</p><h2 id="升级前准备"><span class="post-title-index">2.1. </span><a href="#升级前准备" class="headerlink" title="升级前准备"></a>升级前准备</h2><p>0、关闭一些软件（可选）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop docker</span><br><span class="line">systemctl <span class="built_in">disable</span> docker</span><br><span class="line">systemctl stop v2raya</span><br><span class="line">systemctl <span class="built_in">disable</span> v2raya</span><br><span class="line">vncserver -<span class="built_in">kill</span> :1</span><br></pre></td></tr></table></figure><p>1、修改软件源配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/apt/sources.list</span><br></pre></td></tr></table></figure><p>添加如下配置：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic main restricted</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic-updates main restricted</span><br><span class="line">deb http://cn.archive.ubuntu.com/ubuntu/ bionic-security main restricted</span><br></pre></td></tr></table></figure><p>2、更新软件包</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt upgrade</span><br><span class="line">apt dist-upgrade</span><br></pre></td></tr></table></figure><p>3、删除无用软件包（可选）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt autoremove</span><br></pre></td></tr></table></figure><p>4、安装 update-manager-core</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install update-manager-core</span><br></pre></td></tr></table></figure><p>5、重启系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="执行升级"><span class="post-title-index">2.2. </span><a href="#执行升级" class="headerlink" title="执行升级"></a>执行升级</h2><p>1、配置使用lts升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/update-manager/release-upgrades</span><br></pre></td></tr></table></figure><p>如下修改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Prompt=lts</span><br></pre></td></tr></table></figure><p>注意：如果配置了 <code>Prompt=never</code> ，那么说明禁用了Ubuntu更新。更新时会提示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Checking for a new Ubuntu release</span><br><span class="line">In /etc/update-manager/release-upgrades Prompt</span><br><span class="line">is set to never so upgrading is not possible.</span><br></pre></td></tr></table></figure><p>参考文档：<a href="https://askubuntu.com/questions/1315484/cant-upgrade-from-18-04-server-to-20-04">Can’t upgrade from 18.04 server to 20.04</a></p><p>2、执行升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do-release-upgrade</span><br></pre></td></tr></table></figure><p>升级过程会有交互提示，根据提示选择即可。</p><p>整个升级过程大约1-2小时。升级完成需要重启一次系统。</p><p>3、查看当前版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure><h1 id="Ubuntu20升级到Ubuntu22"><span class="post-title-index">3. </span><a href="#Ubuntu20升级到Ubuntu22" class="headerlink" title="Ubuntu20升级到Ubuntu22"></a>Ubuntu20升级到Ubuntu22</h1><p>不用再次进行升级前准备，直接执行升级命令即可。</p><p>1、执行升级</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">do-release-upgrade</span><br></pre></td></tr></table></figure><p>升级过程会有交互提示，根据提示选择即可。</p><p>Ubuntu20升级Ubuntu22过程中，在 Upgrade to the firefox snap 时会卡住半个小时以上，请耐心等待。详情参考<a href="https://askubuntu.com/questions/1445771/upgrade-ubuntu-20-04-to-22-04-stuck-on-installing-the-firefox-snap">Upgrade Ubuntu 20.04 to 22.04 stuck on ‘’installing the firefox snap’’</a></p><p>2、查看当前版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -a</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;为什么要升级Ubuntu？&quot;&gt;&lt;a href=&quot;#为什么要升级Ubuntu？&quot; class=&quot;headerlink&quot; title=&quot;为什么要升级Ubuntu？&quot;&gt;&lt;/a&gt;为什么要升级Ubuntu？&lt;/h1&gt;&lt;p&gt;Ubuntu18 的常规支持已于2023年4月结束，而 Ubuntu22 有更长的常规支持周期，这意味着在未来几年内，用户将持续获得包括功能更新、安全更新和错误修复在内的全面支持，确保系统的稳定性和安全性。&lt;/p&gt;
&lt;p&gt;Ubuntu22 采用了较新的 Linux 内核版本，新内核通常会带来更好的硬件支持、性能优化和安全性增强。&lt;/p&gt;
&lt;p&gt;此外，最重要的是，很多Ubuntu中的软件仅支持最新版本的Ubuntu，比如Waydroid，比如麟卓卓懿。&lt;/p&gt;
&lt;p&gt;因此，虽然升级Ubuntu比较麻烦，并且存在一定的风险，但是是值得的。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ubuntu.com/tutorials/upgrading-ubuntu-desktop#1-before-you-start&quot;&gt;Upgrade Ubuntu desktop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://askubuntu.com/questions/1454762/18-04-22-04-upgrade&quot;&gt;18.04 -&amp;gt; 22.04 upgrade&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.reddit.com/r/Ubuntu/comments/x3z08c/upgrade_ubuntu_1804_to_2204/&quot;&gt;Upgrade ubuntu 18.04 to 22.04&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/liufangaliya/article/details/134132836&quot;&gt;ubuntu18.04如何更新到22.04&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="linux" scheme="https://www.voidking.com/categories/engineering/linux/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="好好学Linux" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Linux/"/>
    
    <category term="ubuntu" scheme="https://www.voidking.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置FileBrowser</title>
    <link href="https://www.voidking.com/dev-docker-filebrowser/"/>
    <id>https://www.voidking.com/dev-docker-filebrowser/</id>
    <published>2024-10-26T08:00:00.000Z</published>
    <updated>2024-10-26T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="FileBrowser简介"><span class="post-title-index">1. </span><a href="#FileBrowser简介" class="headerlink" title="FileBrowser简介"></a>FileBrowser简介</h1><p>FileBrowser 提供了一个在指定目录内的文件管理界面，功能包括上传、删除、预览、重命名和编辑文件。<br>它允许创建多个用户，每个用户可以拥有自己的目录。</p><p>相关文档：</p><ul><li><a href="https://github.com/filebrowser/filebrowser">github - filebrowser/filebrowser</a></li><li><a href="https://filebrowser.org/installation">FileBrowser Installation</a></li><li><a href="https://www.voidking.com/dev-docker-alist/">《好好学Docker：使用Docker安装配置AList》</a></li></ul><span id="more"></span><h1 id="安装FileBrowser"><span class="post-title-index">2. </span><a href="#安装FileBrowser" class="headerlink" title="安装FileBrowser"></a>安装FileBrowser</h1><p>1、下载 filebrowser 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull filebrowser/filebrowser:v2.31.2-s6</span><br></pre></td></tr></table></figure><p>2、准备持久化目录和文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name tmp -d \</span><br><span class="line">    filebrowser/filebrowser:v2.31.2-s6</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /opt/filebrowser/</span><br><span class="line">docker <span class="built_in">cp</span> tmp:/database/filebrowser.db /opt/filebrowser/</span><br><span class="line">docker <span class="built_in">cp</span> tmp:/config/settings.json /opt/filebrowser/</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">rm</span> tmp -f</span><br></pre></td></tr></table></figure><p>3、启动 filebrowser 容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">docker run --name filebrowser -d \</span><br><span class="line">    -v /opt/filebrowser/srv:/srv \</span><br><span class="line">    -v /opt/filebrowser/filebrowser.db:/database/filebrowser.db \</span><br><span class="line">    -v /opt/filebrowser/settings.json:/config/settings.json \</span><br><span class="line">    -e PUID=$(<span class="built_in">id</span> -u) \</span><br><span class="line">    -e PGID=$(<span class="built_in">id</span> -g) \</span><br><span class="line">    -p 8889:80 \</span><br><span class="line">    filebrowser/filebrowser:v2.31.2-s6</span><br></pre></td></tr></table></figure><p>4、检查运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line">docker logs filebrowser</span><br></pre></td></tr></table></figure><h1 id="使用FileBrowser"><span class="post-title-index">3. </span><a href="#使用FileBrowser" class="headerlink" title="使用FileBrowser"></a>使用FileBrowser</h1><p>1、浏览器访问 filebrowser<br>假设主机IP为 192.168.56.101，那么浏览器访问 <a href="http://192.168.56.101:8889/">http://192.168.56.101:8889</a></p><p>2、登录 filebrowser<br>默认用户名和密码都是 <code>admin</code>，首次登录后建议修改密码。</p><h1 id="后记"><span class="post-title-index">4. </span><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>FileBrowser配合Jupyter，绝了！让主机变得触手可及。<br>FileBrowser负责界面管理文件，Jupyter负责界面执行脚本，无线可能。比如笔记系统，比如影音系统，比如加解密系统。。。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;FileBrowser简介&quot;&gt;&lt;a href=&quot;#FileBrowser简介&quot; class=&quot;headerlink&quot; title=&quot;FileBrowser简介&quot;&gt;&lt;/a&gt;FileBrowser简介&lt;/h1&gt;&lt;p&gt;FileBrowser 提供了一个在指定目录内的文件管理界面，功能包括上传、删除、预览、重命名和编辑文件。&lt;br&gt;它允许创建多个用户，每个用户可以拥有自己的目录。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/filebrowser/filebrowser&quot;&gt;github - filebrowser/filebrowser&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://filebrowser.org/installation&quot;&gt;FileBrowser Installation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-docker-alist/&quot;&gt;《好好学Docker：使用Docker安装配置AList》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>邮箱配置中的SPF、DKIM、DMARC记录</title>
    <link href="https://www.voidking.com/dev-mail-spf-dkim-dmarc/"/>
    <id>https://www.voidking.com/dev-mail-spf-dkim-dmarc/</id>
    <published>2024-10-26T08:00:00.000Z</published>
    <updated>2024-11-09T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在现代电子邮件系统中，确保邮件的安全性和可靠性至关重要。SPF、DKIM和DMARC是三种主要的电子邮件身份验证机制，它们共同工作以防止垃圾邮件、钓鱼攻击和其他形式的邮件欺诈。</p><p>SPF、DKIM和DMARC机制在配置DNS时，记录类型都是TXT类型，在配置记录值时请注意DNS平台是否需要双引号。</p><p>本文将学习这三种机制及其在邮箱配置中的作用。</p><p>参考文档：</p><ul><li><a href="https://jovialchap.com/spf-dkim-dmarc-explained/">详解 SPF、DKIM、DMARC 记录与工作原理</a></li><li><a href="https://powerdmarc.com/fix-this-mail-is-unauthenticated-gmail-error/">550-5.7.26 Gmail Error: Email Blocked Because Sender is Unauthenticated</a></li><li><a href="https://powerdmarc.com/zh/what-is-a-dns-txt-record/">POWERDMARC - 什么是DNS TXT记录？</a></li><li><a href="https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-txt-record/">CloudFlare - 什么是 DNS TXT 记录？</a></li></ul><span id="more"></span><h1 id="SPF"><span class="post-title-index">2. </span><a href="#SPF" class="headerlink" title="SPF"></a>SPF</h1><h2 id="SPF简介"><span class="post-title-index">2.1. </span><a href="#SPF简介" class="headerlink" title="SPF简介"></a>SPF简介</h2><p>SPF全称为发件人策略框架，SPF是一种用于验证发送电子邮件的服务器是否被授权代表域名发送邮件的机制。<br>通过在DNS中添加SPF记录，域名所有者可以指定哪些IP地址可以发送该域名的邮件。</p><h2 id="SPF工作原理"><span class="post-title-index">2.2. </span><a href="#SPF工作原理" class="headerlink" title="SPF工作原理"></a>SPF工作原理</h2><p>当接收邮件服务器收到一封来自某个域名的邮件时，它会查找该域名的SPF记录，验证发件服务器的IP地址是否在授权列表中。如果匹配，邮件将被接受；如果不匹配，邮件可能会被标记为垃圾邮件或拒绝。</p><h2 id="SPF记录示例"><span class="post-title-index">2.3. </span><a href="#SPF记录示例" class="headerlink" title="SPF记录示例"></a>SPF记录示例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机记录：@</span><br><span class="line">记录类型：TXT</span><br><span class="line">记录值：&quot;v=spf1 ip4:192.0.2.0/24 include:_spf.example.com -all&quot;</span><br></pre></td></tr></table></figure><p>记录值字段说明：</p><ul><li><code>v=spf1</code>：表示使用SPF版本1。</li><li><code>ip4:192.0.2.0/24</code>：允许该IP地址范围发送邮件。</li><li><code>include:_spf.example.com</code>：允许其他域名的SPF记录。</li><li><code>-all</code>：表示不允许其他IP地址发送邮件。</li></ul><p>腾讯企业邮推荐记录值：<code>&quot;v=spf1 include:spf.mail.qq.com ~all&quot;</code> </p><p>参考文档：</p><ul><li><a href="https://open.work.weixin.qq.com/help2/pc/20047?person_id=1">550 SPF check failed</a></li><li><a href="https://open.work.weixin.qq.com/help2/pc/19817?person_id=1">如何设置企业邮箱的SPF记录值？</a></li></ul><h2 id="SPF语法解释"><span class="post-title-index">2.4. </span><a href="#SPF语法解释" class="headerlink" title="SPF语法解释"></a>SPF语法解释</h2><p>SPF记录定义了多种不同的 mechanism，这些 mechanism 规定了哪些 IP 是被允许的，哪些 IP 是被禁止的。</p><p>这一些mechanism包含以下几类：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">all | ip4 | ip6 | a | mx | ptr | exists | include</span><br><span class="line">同时还支持以下四种前缀：</span><br><span class="line">&quot;+&quot; -&gt; Pass (通过/同时这也是默认值) -&gt; 发件IP合法，接收</span><br><span class="line">&quot;-&quot; -&gt; Fail (拒绝) -&gt; 发件IP非法，退信</span><br><span class="line">&quot;~&quot; -&gt; Soft Fail (软拒绝) -&gt; 发件IP非法，接收</span><br><span class="line">&quot;?&quot; -&gt; Neutral (中立) -&gt; SPF记录中没有该IP信息，接收</span><br></pre></td></tr></table></figure><p>all 表示命中所有的 IP，通常放在 SPF 记录的尾部作为 fallback，结合上面提到的前缀举几个例子：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 -all&quot; 拒绝所有</span><br><span class="line">&quot;v=spf1 +all&quot; 接受所有</span><br></pre></td></tr></table></figure><p>ip4/ip6 的格式相近，具体的配置举例如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 ip4:192.168.0.1/16 -all&quot;</span><br><span class="line">只允许在 192.168.0.1 ~ 192.168.255.255 范围内的 IP</span><br><span class="line">&quot;v=spf1 ip6:1080::8:800:200C:417A/96 -all&quot;</span><br><span class="line">只允许在 1080::8:800:0000:0000 ~ 1080::8:800:FFFF:FFFF 范围内的 IP</span><br><span class="line">如果没有指定前缀长度，则默认只表示记录中所填写的IP（1个IP）</span><br></pre></td></tr></table></figure><p>a/mx 这两个 mechanism 会命中相应域名的 a 记录和 mx 记录，a语法mx的语法一致，如果没有填写域名则默认值为当前域名：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 mx -all&quot; 允许当前域名的 mx 记录对应的 IP 地址。</span><br><span class="line">&quot;v=spf1 mx mx:deferrals.example.com -all&quot; 允许当前域名和 deferrals.example.com 的 mx 记录对应的 IP 地址。</span><br><span class="line">&quot;v=spf1 a/24 -all&quot; 这个配置允许一个地址段</span><br></pre></td></tr></table></figure><p>include 用于引入某个域名下的SPF记录，例如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;v=spf1 include:example.com -all&quot; 采用和 example.com 完全一样的 SPF 记录</span><br></pre></td></tr></table></figure><h1 id="DKIM"><span class="post-title-index">3. </span><a href="#DKIM" class="headerlink" title="DKIM"></a>DKIM</h1><h2 id="DKIM简介"><span class="post-title-index">3.1. </span><a href="#DKIM简介" class="headerlink" title="DKIM简介"></a>DKIM简介</h2><p>DKIM全称为域名密钥识别邮件，DKIM是一种电子邮件身份验证方法，它通过数字签名确保邮件内容在传输过程中未被篡改。<br>发件人使用私钥对邮件进行签名，而接收方则使用公钥进行验证。</p><h2 id="DKIM工作原理"><span class="post-title-index">3.2. </span><a href="#DKIM工作原理" class="headerlink" title="DKIM工作原理"></a>DKIM工作原理</h2><p>当接收服务器收到一封带有DKIM签名的邮件时，它会提取签名并查找相应的公钥。如果公钥验证成功，表明邮件未被篡改且确实来自声称的发件人。</p><h2 id="DKIM记录示例"><span class="post-title-index">3.3. </span><a href="#DKIM记录示例" class="headerlink" title="DKIM记录示例"></a>DKIM记录示例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主机记录：&lt;selector&gt;._domainkey</span><br><span class="line">记录类型：TXT</span><br><span class="line">记录值：&quot;v=DKIM1; k=rsa; p=MIGfMA0GCS...&quot;</span><br><span class="line">记录值中的k=rsa</span><br></pre></td></tr></table></figure><p>记录值字段说明：</p><ul><li><code>v=DKIM1</code>：表示使用DKIM版本1。</li><li><code>k=rsa</code>：表示公钥是以RSA方式进行加密的。</li><li><code>p=MIGfMA0GCS...</code>：公钥部分。</li></ul><p>主机记录和记录值通常由电子邮件服务商提供，比如使用腾讯企业邮箱或网易企业邮箱，就登录管理员查看DKIM配置。</p><h1 id="DMARC"><span class="post-title-index">4. </span><a href="#DMARC" class="headerlink" title="DMARC"></a>DMARC</h1><h2 id="DMARC简介"><span class="post-title-index">4.1. </span><a href="#DMARC简介" class="headerlink" title="DMARC简介"></a>DMARC简介</h2><p>DMARC全称为基于域名的消息身份验证、报告和一致性，DMARC是建立在SPF和DKIM之上的一种机制，允许域名所有者指定如何处理未通过身份验证的邮件，并提供报告功能。</p><h2 id="DMARC工作原理"><span class="post-title-index">4.2. </span><a href="#DMARC工作原理" class="headerlink" title="DMARC工作原理"></a>DMARC工作原理</h2><p>接收服务器根据DMARC策略处理未通过SPF或DKIM验证的邮件。根据设置，它可以选择拒绝、隔离或无操作。同时，发送报告给域名所有者，以便他们监控和分析身份验证结果。</p><h2 id="DMARC记录示例"><span class="post-title-index">4.3. </span><a href="#DMARC记录示例" class="headerlink" title="DMARC记录示例"></a>DMARC记录示例</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主机记录：_dmarc</span><br><span class="line">记录类型：TXT</span><br><span class="line">记录值：&quot;v=DMARC1; p=reject; rua=mailto:dmarc-reports@example.com&quot;</span><br></pre></td></tr></table></figure><p>记录字段说明：</p><ul><li><code>v=DMARC1</code>：表示使用DMARC版本1。</li><li><code>p=reject</code>：指示接收方拒绝未通过身份验证的邮件。</li><li><code>rua=mailto:dmarc-reports@example.com</code>：指定接收报告的电子邮件地址。</li></ul><p>腾讯企业邮推荐记录值：<code>&quot;v=DMARC1; p=none; rua=mailto:mailauth-reports@qq.com&quot;</code> </p><p>参考文档：<a href="https://open.work.weixin.qq.com/help2/pc/19820">企业邮箱如何设置DMARC（TXT记录）</a></p><h1 id="发送邮件给Gmail报错问题"><span class="post-title-index">5. </span><a href="#发送邮件给Gmail报错问题" class="headerlink" title="发送邮件给Gmail报错问题"></a>发送邮件给Gmail报错问题</h1><h2 id="问题描述"><span class="post-title-index">5.1. </span><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>发送邮件给Gmail邮箱时，报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">550-5.7.26 Your email has been blocked because the sender is unauthenticated. </span><br><span class="line">550-5.7.26 Gmail requires all senders to authenticate with either SPF or DKIM. 550-5.7.26</span><br><span class="line">550-5.7.26 Authentication results: 550-5.7.26 DKIM = did not pass</span><br><span class="line">550-5.7.26 SPF [fuzhi.ai] with ip: [128.x.x.x] = did not pass</span><br></pre></td></tr></table></figure><h2 id="解决办法"><span class="post-title-index">5.2. </span><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>报错很清晰，发送邮件的服务器被Gmail拒绝了，Gmail怀疑这是伪造的发件人，因为邮件没能通过SPF或DKIM验证。</p><p>解决办法：检查并配置SPF和DKIM。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在现代电子邮件系统中，确保邮件的安全性和可靠性至关重要。SPF、DKIM和DMARC是三种主要的电子邮件身份验证机制，它们共同工作以防止垃圾邮件、钓鱼攻击和其他形式的邮件欺诈。&lt;/p&gt;
&lt;p&gt;SPF、DKIM和DMARC机制在配置DNS时，记录类型都是TXT类型，在配置记录值时请注意DNS平台是否需要双引号。&lt;/p&gt;
&lt;p&gt;本文将学习这三种机制及其在邮箱配置中的作用。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jovialchap.com/spf-dkim-dmarc-explained/&quot;&gt;详解 SPF、DKIM、DMARC 记录与工作原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://powerdmarc.com/fix-this-mail-is-unauthenticated-gmail-error/&quot;&gt;550-5.7.26 Gmail Error: Email Blocked Because Sender is Unauthenticated&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://powerdmarc.com/zh/what-is-a-dns-txt-record/&quot;&gt;POWERDMARC - 什么是DNS TXT记录？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cloudflare.com/zh-cn/learning/dns/dns-records/dns-txt-record/&quot;&gt;CloudFlare - 什么是 DNS TXT 记录？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>好好学K8S：K8S中的Leader Election机制</title>
    <link href="https://www.voidking.com/dev-k8s-leader-election/"/>
    <id>https://www.voidking.com/dev-k8s-leader-election/</id>
    <published>2024-10-19T08:00:00.000Z</published>
    <updated>2024-10-19T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求描述"><span class="post-title-index">1. </span><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>假设有一个基于client-go的程序，叫做watcher，会监听k8s集群中pod被删除的消息，当pod被删除时，会触发执行一个动作。<br>当watcher只有一个副本时，程序运行符合预期。但是当watcher有多个副本时，多个watcher副本都监听到pod被删除的消息，都会触发执行一个动作。而这个动作，我们希望只执行一次。<br>有什么办法，可以让多个watcher具备多个副本，但是当监听到pod被删除时，只会触发一次执行动作？</p><span id="more"></span><h1 id="实现思路"><span class="post-title-index">2. </span><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>要实现这个需求，有三个思路：</p><ul><li>思路一：基于K8S ValidatingAdmissionWebhook机制。实现一个ValidatingAdmissionWebhook，限制watcher服务只能有一个副本。watcher服务只有一个副本，自然就只会执行一次动作，但是，与需求不相符，不能高可用。</li><li>思路二：基于分布式锁。常见的实现方式包括使用 redis、zookeeper 或 etcd 等工具。这种实现方式简单，但是需要额外维护一个中间件，不够优雅。</li><li>思路三：基于K8S Leader Election机制。K8S 提供了 Leader Election 机制，可以通过 client-go 库实现，只有被选为 Leader 的 watcher 才会处理 pod 删除事件。</li></ul><p>本文中选择思路三（K8S Leader Election机制）来实现需求：服务多个副本但是只执行一次动作。</p><p>参考文档：</p><ul><li><a href="https://isekiro.com/kubernetes%E6%BA%90%E7%A0%81-%E6%8E%A7%E5%88%B6%E5%99%A8-leader-%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6/">kubernetes源码-控制器 leader 选举机制</a></li><li><a href="https://juejin.cn/post/7157648925078323207">k8s(kubernetes) 使用leader election实现选举</a></li></ul><h1 id="Leader-Election机制简介"><span class="post-title-index">3. </span><a href="#Leader-Election机制简介" class="headerlink" title="Leader Election机制简介"></a>Leader Election机制简介</h1><h2 id="Leader-Election原理"><span class="post-title-index">3.1. </span><a href="#Leader-Election原理" class="headerlink" title="Leader Election原理"></a>Leader Election原理</h2><p>Leader Election 是一种分布式系统中的机制，旨在确保在多个候选者中选出一个“领导者”进程，以负责执行特定的操作。</p><p>1、候选者识别：在 Leader Election 中，首先需要识别出一组候选者，这些候选者可能是运行在同一集群中的多个实例（如 Pods）。这些候选者会竞争成为领导者。</p><p>2、竞选过程：候选者通过某种方式（如心跳信号）宣告自己为领导者。通常，所有候选者会尝试同时声明自己为领导者。其中一个候选者成功地获得领导权，而其他候选者则进入待命状态，准备在当前领导者失效时进行新的竞选。</p><p>3、心跳机制：一旦某个实例成为领导者，它会定期发送心跳信号以维持其领导地位。如果领导者未能在预定时间内发送心跳信号，其他候选者将启动新的竞选过程，以确保始终有一个活跃的领导者。</p><p>4、故障恢复：当当前领导者发生故障或被终止时，其他候选者会迅速重新进行竞选，以确定新的领导者。这种机制保证了系统的高可用性。</p><h1 id="K8S-中的-Leader-Election-实现"><span class="post-title-index">4. </span><a href="#K8S-中的-Leader-Election-实现" class="headerlink" title="K8S 中的 Leader Election 实现"></a>K8S 中的 Leader Election 实现</h1><p>Kubernetes 提供了一种简化的方式来实现 Leader Election，相关概念包括资源锁和Lease API。</p><ul><li>资源锁：Kubernetes 使用 <code>ConfigMap</code> 或 <code>Lease</code> 等资源作为锁来管理领导权。每个候选者尝试更新这个资源以声明自己为领导者。例如，通过更新 <code>ConfigMap</code> 中的某个字段来表示当前的领导者。</li><li>Lease API：Kubernetes 从 v1.14 开始引入了 <code>coordination.k8s.io</code> API，允许更高效地管理领导权。使用 Lease 对象可以减少对 API 的调用频率，并避免过多的事件通知。</li></ul><p>选举过程：<br>1、候选者创建或获取 Lease 对象，并尝试更新其内容以表明其身份。<br>2、只有第一个成功更新 Lease 的实例能够获得领导权。<br>3、其他实例在发现 Lease 被更新后，将停止尝试并进入待命状态。</p><p>选举机制保证了控制器的高可用，同时只有一个控制器为主，其他为从，防止同个事件被多次重复监听，重复执行相关的业务逻辑。</p><h1 id="Leader-Election示例代码"><span class="post-title-index">5. </span><a href="#Leader-Election示例代码" class="headerlink" title="Leader Election示例代码"></a>Leader Election示例代码</h1><p>示例代码地址：<a href="https://github.com/kubernetes/client-go/tree/master/examples/leader-election">examples - leader-election</a></p><p>1、创建示例项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> leader-election-demo &amp;&amp; <span class="built_in">cd</span> leader-election-demo</span><br><span class="line">go mod init leader-election-demo</span><br></pre></td></tr></table></figure><p>2、粘贴示例代码<br>创建文件 main.go ，并且把示例代码粘贴进去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Copyright 2018 The Kubernetes Authors.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;flag&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;os/signal&quot;</span></span><br><span class="line">    <span class="string">&quot;syscall&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/google/uuid&quot;</span></span><br><span class="line">    metav1 <span class="string">&quot;k8s.io/apimachinery/pkg/apis/meta/v1&quot;</span></span><br><span class="line">    clientset <span class="string">&quot;k8s.io/client-go/kubernetes&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/client-go/rest&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/client-go/tools/clientcmd&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/client-go/tools/leaderelection&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/client-go/tools/leaderelection/resourcelock&quot;</span></span><br><span class="line">    <span class="string">&quot;k8s.io/klog/v2&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildConfig</span><span class="params">(kubeconfig <span class="type">string</span>)</span></span> (*rest.Config, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> kubeconfig != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        cfg, err := clientcmd.BuildConfigFromFlags(<span class="string">&quot;&quot;</span>, kubeconfig)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cfg, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cfg, err := rest.InClusterConfig()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cfg, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    klog.InitFlags(<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> kubeconfig <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> leaseLockName <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> leaseLockNamespace <span class="type">string</span></span><br><span class="line">    <span class="keyword">var</span> id <span class="type">string</span></span><br><span class="line"></span><br><span class="line">    flag.StringVar(&amp;kubeconfig, <span class="string">&quot;kubeconfig&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;absolute path to the kubeconfig file&quot;</span>)</span><br><span class="line">    flag.StringVar(&amp;id, <span class="string">&quot;id&quot;</span>, uuid.New().String(), <span class="string">&quot;the holder identity name&quot;</span>)</span><br><span class="line">    flag.StringVar(&amp;leaseLockName, <span class="string">&quot;lease-lock-name&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;the lease lock resource name&quot;</span>)</span><br><span class="line">    flag.StringVar(&amp;leaseLockNamespace, <span class="string">&quot;lease-lock-namespace&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;the lease lock resource namespace&quot;</span>)</span><br><span class="line">    flag.Parse()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> leaseLockName == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        klog.Fatal(<span class="string">&quot;unable to get lease lock resource name (missing lease-lock-name flag).&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> leaseLockNamespace == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        klog.Fatal(<span class="string">&quot;unable to get lease lock resource namespace (missing lease-lock-namespace flag).&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leader election uses the Kubernetes API by writing to a</span></span><br><span class="line">    <span class="comment">// lock object, which can be a LeaseLock object (preferred),</span></span><br><span class="line">    <span class="comment">// a ConfigMap, or an Endpoints (deprecated) object.</span></span><br><span class="line">    <span class="comment">// Conflicting writes are detected and each client handles those actions</span></span><br><span class="line">    <span class="comment">// independently.</span></span><br><span class="line">    config, err := buildConfig(kubeconfig)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        klog.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    client := clientset.NewForConfigOrDie(config)</span><br><span class="line"></span><br><span class="line">    run := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">        <span class="comment">// complete your controller loop here</span></span><br><span class="line">        klog.Info(<span class="string">&quot;Controller loop...&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use a Go context so we can tell the leaderelection code when we</span></span><br><span class="line">    <span class="comment">// want to step down</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// listen for interrupts or the Linux SIGTERM signal and cancel</span></span><br><span class="line">    <span class="comment">// our context, which the leader election code will observe and</span></span><br><span class="line">    <span class="comment">// step down</span></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>)</span><br><span class="line">    signal.Notify(ch, os.Interrupt, syscall.SIGTERM)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        &lt;-ch</span><br><span class="line">        klog.Info(<span class="string">&quot;Received termination, signaling shutdown&quot;</span>)</span><br><span class="line">        cancel()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we use the Lease lock type since edits to Leases are less common</span></span><br><span class="line">    <span class="comment">// and fewer objects in the cluster watch &quot;all Leases&quot;.</span></span><br><span class="line">    lock := &amp;resourcelock.LeaseLock&#123;</span><br><span class="line">        LeaseMeta: metav1.ObjectMeta&#123;</span><br><span class="line">            Name:      leaseLockName,</span><br><span class="line">            Namespace: leaseLockNamespace,</span><br><span class="line">        &#125;,</span><br><span class="line">        Client: client.CoordinationV1(),</span><br><span class="line">        LockConfig: resourcelock.ResourceLockConfig&#123;</span><br><span class="line">            Identity: id,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// start the leader election code loop</span></span><br><span class="line">    leaderelection.RunOrDie(ctx, leaderelection.LeaderElectionConfig&#123;</span><br><span class="line">        Lock: lock,</span><br><span class="line">        <span class="comment">// IMPORTANT: you MUST ensure that any code you have that</span></span><br><span class="line">        <span class="comment">// is protected by the lease must terminate **before**</span></span><br><span class="line">        <span class="comment">// you call cancel. Otherwise, you could have a background</span></span><br><span class="line">        <span class="comment">// loop still running and another process could</span></span><br><span class="line">        <span class="comment">// get elected before your background loop finished, violating</span></span><br><span class="line">        <span class="comment">// the stated goal of the lease.</span></span><br><span class="line">        ReleaseOnCancel: <span class="literal">true</span>,</span><br><span class="line">        LeaseDuration:   <span class="number">60</span> * time.Second,</span><br><span class="line">        RenewDeadline:   <span class="number">15</span> * time.Second,</span><br><span class="line">        RetryPeriod:     <span class="number">5</span> * time.Second,</span><br><span class="line">        Callbacks: leaderelection.LeaderCallbacks&#123;</span><br><span class="line">            OnStartedLeading: <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">                <span class="comment">// we&#x27;re notified when we start - this is where you would</span></span><br><span class="line">                <span class="comment">// usually put your code</span></span><br><span class="line">                run(ctx)</span><br><span class="line">            &#125;,</span><br><span class="line">            OnStoppedLeading: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">                <span class="comment">// we can do cleanup here</span></span><br><span class="line">                klog.Infof(<span class="string">&quot;leader lost: %s&quot;</span>, id)</span><br><span class="line">                os.Exit(<span class="number">0</span>)</span><br><span class="line">            &#125;,</span><br><span class="line">            OnNewLeader: <span class="function"><span class="keyword">func</span><span class="params">(identity <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                <span class="comment">// we&#x27;re notified when new leader elected</span></span><br><span class="line">                <span class="keyword">if</span> identity == id &#123;</span><br><span class="line">                    <span class="comment">// I just got the lock</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                &#125;</span><br><span class="line">                klog.Infof(<span class="string">&quot;new leader elected: %s&quot;</span>, identity)</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、安装依赖</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>4、运行代码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># first terminal</span></span><br><span class="line">go run main.go -kubeconfig=/path/to/kubeconfig -logtostderr=<span class="literal">true</span> -lease-lock-name=example -lease-lock-namespace=default -<span class="built_in">id</span>=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># second terminal</span></span><br><span class="line">go run main.go -kubeconfig=/path/to/kubeconfig -logtostderr=<span class="literal">true</span> -lease-lock-name=example -lease-lock-namespace=default -<span class="built_in">id</span>=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># third terminal</span></span><br><span class="line">go run main.go -kubeconfig=/path/to/kubeconfig -logtostderr=<span class="literal">true</span> -lease-lock-name=example -lease-lock-namespace=default -<span class="built_in">id</span>=3</span><br></pre></td></tr></table></figure><p>5、查看lease</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get lease</span><br></pre></td></tr></table></figure><p>看到如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME      HOLDER   AGE</span><br><span class="line">example   1        104s</span><br></pre></td></tr></table></figure><p>6、结束1号进程，再次查看lease<br>看到如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME      HOLDER   AGE</span><br><span class="line">example   3        3m12s</span><br></pre></td></tr></table></figure><p>上面的示例，可以证明Leader Election机制已经生效了。当1号进程不可用时，另外的两个进程其中之一会成为领导者。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h1&gt;&lt;p&gt;假设有一个基于client-go的程序，叫做watcher，会监听k8s集群中pod被删除的消息，当pod被删除时，会触发执行一个动作。&lt;br&gt;当watcher只有一个副本时，程序运行符合预期。但是当watcher有多个副本时，多个watcher副本都监听到pod被删除的消息，都会触发执行一个动作。而这个动作，我们希望只执行一次。&lt;br&gt;有什么办法，可以让多个watcher具备多个副本，但是当监听到pod被删除时，只会触发一次执行动作？&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="golang" scheme="https://www.voidking.com/categories/engineering/golang/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="golang" scheme="https://www.voidking.com/tags/golang/"/>
    
    <category term="好好学K8S" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6K8S/"/>
    
    <category term="client-go" scheme="https://www.voidking.com/tags/client-go/"/>
    
    <category term="kubectl" scheme="https://www.voidking.com/tags/kubectl/"/>
    
  </entry>
  
  <entry>
    <title>好好学Golang：Viper库</title>
    <link href="https://www.voidking.com/dev-golang-viper/"/>
    <id>https://www.voidking.com/dev-golang-viper/</id>
    <published>2024-10-06T08:00:00.000Z</published>
    <updated>2024-10-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Viper库简介"><span class="post-title-index">1. </span><a href="#Viper库简介" class="headerlink" title="Viper库简介"></a>Viper库简介</h1><p>Viper是一个功能强大的Go语言配置管理库，旨在简化应用程序的配置处理。它支持多种配置文件格式，并能够从多种来源读取配置，适合现代应用程序的需求。Viper使得开发者能够专注于业务逻辑，而不必过多担心配置管理的问题。</p><p>参考文档：</p><ul><li><a href="https://github.com/spf13/viper">github - spf13/viper</a></li><li><a href="https://juejin.cn/post/7096416508054044685">配置解析神器viper使用详解</a></li><li><a href="https://www.jiguiquan.com/?p=3902">Go语言功能齐全的配置管理库-Viper</a></li></ul><span id="more"></span><h1 id="Viper的特性"><span class="post-title-index">2. </span><a href="#Viper的特性" class="headerlink" title="Viper的特性"></a>Viper的特性</h1><ul><li>多种配置格式支持: Viper可以读取JSON、TOML、YAML、HCL、INI、envfile和Java properties等格式的配置文件。</li><li>环境变量支持: Viper可以从环境变量中读取配置。</li><li>命令行参数: 通过与<code>pflag</code>等库结合，Viper能够处理命令行参数，并优先覆盖其他配置来源。</li><li>实时监控: Viper支持实时监控配置文件的变动，并能在文件变化时自动重新加载配置。</li><li>远程配置系统: Viper可以从远程配置系统（如etcd或Consul）读取和监控配置变化。</li><li>默认值设置: 可以为不同的配置选项设置默认值，以确保应用在没有提供特定配置时仍能正常运行。</li><li>别名系统: Viper允许为参数设置别名，以便在不破坏现有代码的情况下重命名参数。</li></ul><h1 id="Viper读取配置的优先级"><span class="post-title-index">3. </span><a href="#Viper读取配置的优先级" class="headerlink" title="Viper读取配置的优先级"></a>Viper读取配置的优先级</h1><p>Viper支持从多个数据源读取配置值，因此当同一个配置key在多个数据源有值时，Viper读取配置的优先级从高到低如下：</p><ul><li>set：显示使用Set函数设置值</li><li>flag：命令行参数</li><li>env：环境变量</li><li>config：配置文件</li><li>key/value store：key/value存储系统，如 etcd</li><li>default：默认值</li></ul><h1 id="Viper读取环境变量"><span class="post-title-index">4. </span><a href="#Viper读取环境变量" class="headerlink" title="Viper读取环境变量"></a>Viper读取环境变量</h1><p>Viper读取环境变量，和读取配置文件中的变量，有很大不同：</p><ul><li>Viper的key不区分大小写，内部会统一转为小写</li><li>配置文件中的变量名，对应到环境变量中，全部大写</li><li>环境变量不方便表示层级，因此在层级key和环境变量对应时，通常把点和中划线替换为下划线</li></ul><h1 id="安装Viper"><span class="post-title-index">5. </span><a href="#安装Viper" class="headerlink" title="安装Viper"></a>安装Viper</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure><h1 id="Viper简单示例"><span class="post-title-index">6. </span><a href="#Viper简单示例" class="headerlink" title="Viper简单示例"></a>Viper简单示例</h1><p>以下是一个简单的示例，展示如何使用Viper加载YAML配置文件并从环境变量中覆盖某些值。</p><p>1、初始化一个golang项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> viper-demo &amp;&amp; <span class="built_in">cd</span> viper-demo</span><br><span class="line">go mod init viper-demo</span><br><span class="line">go get github.com/spf13/viper</span><br></pre></td></tr></table></figure><p>2、创建配置文件 config.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">addr:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>3、编写代码 main.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="type">string</span> </span><br><span class="line">    Port <span class="type">int</span>   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置读取的配置文件名和路径</span></span><br><span class="line">    viper.SetConfigName(<span class="string">&quot;config&quot;</span>) <span class="comment">// 配置文件名，不需要扩展名</span></span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)    <span class="comment">// 配置文件类型</span></span><br><span class="line">    viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)       <span class="comment">// 配置文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置</span></span><br><span class="line">    <span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;无法读取配置文件: %s&quot;</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用环境变量支持，从环境变量中覆盖配置</span></span><br><span class="line">    viper.AutomaticEnv()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最终的配置信息</span></span><br><span class="line">    config := Config&#123;</span><br><span class="line">        Addr: viper.GetString(<span class="string">&quot;addr&quot;</span>),</span><br><span class="line">        Port: viper.GetInt(<span class="string">&quot;port&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;地址: %s, 端口: %d\n&quot;</span>, config.Addr, config.Port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、运行 main.go</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>5、环境变量覆盖配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ADDR=127.0.0.1 </span><br><span class="line"><span class="comment"># export addr=127.0.0.1 # 小写是错误的</span></span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><h1 id="Viper层级配置示例"><span class="post-title-index">7. </span><a href="#Viper层级配置示例" class="headerlink" title="Viper层级配置示例"></a>Viper层级配置示例</h1><p>1、修改配置文件 config.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>2、编写代码 main.go</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    Addr <span class="type">string</span> </span><br><span class="line">    Port <span class="type">int</span>   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置读取的配置文件名和路径</span></span><br><span class="line">    viper.SetConfigName(<span class="string">&quot;config&quot;</span>) <span class="comment">// 配置文件名，不需要扩展名</span></span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)    <span class="comment">// 配置文件类型</span></span><br><span class="line">    viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)       <span class="comment">// 配置文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置</span></span><br><span class="line">    <span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;无法读取配置文件: %s&quot;</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启用环境变量支持，从环境变量中覆盖配置</span></span><br><span class="line">    viper.AutomaticEnv()</span><br><span class="line">    <span class="comment">// 匹配环境变量时，将配置Key中的点号(.)和横杠(-)替换为下划线(_)</span></span><br><span class="line">    viper.SetEnvKeyReplacer(strings.NewReplacer(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;_&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取最终的配置信息</span></span><br><span class="line">    config := Config&#123;</span><br><span class="line">        Addr: viper.GetString(<span class="string">&quot;http.addr&quot;</span>),</span><br><span class="line">        Port: viper.GetInt(<span class="string">&quot;http.port&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;地址: %s, 端口: %d\n&quot;</span>, config.Addr, config.Port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、运行 main.go</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br></pre></td></tr></table></figure><p>4、环境变量覆盖配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> HTTP_ADDR=127.0.0.1 </span><br><span class="line">go run main.go</span><br></pre></td></tr></table></figure><h1 id="Viper层级配置示例进阶"><span class="post-title-index">8. </span><a href="#Viper层级配置示例进阶" class="headerlink" title="Viper层级配置示例进阶"></a>Viper层级配置示例进阶</h1><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/spf13/viper&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">    HTTP <span class="keyword">struct</span> &#123;</span><br><span class="line">        Addr <span class="type">string</span> </span><br><span class="line">        Port <span class="type">int</span>   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 设置读取的配置文件名和路径</span></span><br><span class="line">    viper.SetConfigName(<span class="string">&quot;config&quot;</span>) <span class="comment">// 配置文件名，不需要扩展名</span></span><br><span class="line">    viper.SetConfigType(<span class="string">&quot;yaml&quot;</span>)    <span class="comment">// 配置文件类型</span></span><br><span class="line">    viper.AddConfigPath(<span class="string">&quot;.&quot;</span>)       <span class="comment">// 配置文件路径</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取配置</span></span><br><span class="line">    <span class="keyword">if</span> err := viper.ReadInConfig(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Errorf(<span class="string">&quot;无法读取配置文件: %s&quot;</span>, err))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从环境变量中覆盖配置</span></span><br><span class="line">    viper.AutomaticEnv() <span class="comment">// 启用环境变量支持</span></span><br><span class="line">    <span class="comment">// 匹配环境变量时，将配置Key中的点号(.)和横杠(-)替换为下划线(_)</span></span><br><span class="line">    viper.SetEnvKeyReplacer(strings.NewReplacer(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;_&quot;</span>, <span class="string">&quot;-&quot;</span>, <span class="string">&quot;_&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将配置文件反序列化为 config 对象</span></span><br><span class="line">    <span class="keyword">var</span> config *Config</span><br><span class="line">    <span class="keyword">if</span> err := viper.Unmarshal(&amp;config); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;地址: %s, 端口: %d\n&quot;</span>, config.HTTP.Addr, config.HTTP.Port)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Viper库简介&quot;&gt;&lt;a href=&quot;#Viper库简介&quot; class=&quot;headerlink&quot; title=&quot;Viper库简介&quot;&gt;&lt;/a&gt;Viper库简介&lt;/h1&gt;&lt;p&gt;Viper是一个功能强大的Go语言配置管理库，旨在简化应用程序的配置处理。它支持多种配置文件格式，并能够从多种来源读取配置，适合现代应用程序的需求。Viper使得开发者能够专注于业务逻辑，而不必过多担心配置管理的问题。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/spf13/viper&quot;&gt;github - spf13/viper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7096416508054044685&quot;&gt;配置解析神器viper使用详解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jiguiquan.com/?p=3902&quot;&gt;Go语言功能齐全的配置管理库-Viper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="golang" scheme="https://www.voidking.com/categories/engineering/golang/"/>
    
    
    <category term="golang" scheme="https://www.voidking.com/tags/golang/"/>
    
    <category term="好好学Golang" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Golang/"/>
    
  </entry>
  
  <entry>
    <title>好好学K8S：Pod网络限速</title>
    <link href="https://www.voidking.com/dev-k8s-pod-network-speed-limit/"/>
    <id>https://www.voidking.com/dev-k8s-pod-network-speed-limit/</id>
    <published>2024-10-06T08:00:00.000Z</published>
    <updated>2024-10-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>为避免Pod打满带宽，有时需要对Pod进行限速。<br>本文中，我们就来学习一下Pod中的网络限速方法。</p><p>相关文档：</p><ul><li><a href="https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/configure-bandwidth-limits-for-pods-in-flannel">为Pod配置带宽限制</a></li><li><a href="https://www.alibabacloud.com/help/en/eci/user-guide/configure-the-bandwidth-of-a-pod-1">Limit the inbound and outbound bandwidth of pods</a></li><li><a href="https://www.voidking.com/dev-k8s-network-policy/">《好好学K8S：K8S中的网络策略》</a></li><li><a href="https://www.voidking.com/dev-docker-container-network-speed-limit/">《好好学K8S：Pod网络限速》</a></li></ul><span id="more"></span><h1 id="Pod网络限速思路"><span class="post-title-index">2. </span><a href="#Pod网络限速思路" class="headerlink" title="Pod网络限速思路"></a>Pod网络限速思路</h1><p>1、CNI插件需要支持带宽限速<br>2、Pod中配置注解</p><p>注意：这种限速方式，对内网和外网都有效。</p><h1 id="CNI插件启用带宽限速"><span class="post-title-index">3. </span><a href="#CNI插件启用带宽限速" class="headerlink" title="CNI插件启用带宽限速"></a>CNI插件启用带宽限速</h1><h2 id="Flannel"><span class="post-title-index">3.1. </span><a href="#Flannel" class="headerlink" title="Flannel"></a>Flannel</h2><p>1、编辑flannel插件的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl edit cm -n kube-system kube-flannel-cfg</span><br></pre></td></tr></table></figure><p>plugins 配置中，增加 bandwidth 配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">cni-conf.json:</span> <span class="string">|</span></span><br><span class="line"><span class="string">    &#123;</span></span><br><span class="line"><span class="string">      &quot;name&quot;: &quot;cb0&quot;,</span></span><br><span class="line"><span class="string">      &quot;cniVersion&quot;:&quot;0.3.1&quot;,</span></span><br><span class="line"><span class="string">      &quot;plugins&quot;: [</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">          &quot;type&quot;: &quot;bandwidth&quot;,</span></span><br><span class="line"><span class="string">          &quot;capabilities&quot;: &#123;&quot;bandwidth&quot;: true&#125;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">      ]</span></span><br><span class="line"><span class="string">    &#125;</span></span><br></pre></td></tr></table></figure><p>2、重建flannel pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n kube-system delete pod -l app=flannel</span><br></pre></td></tr></table></figure><h2 id="Calico"><span class="post-title-index">3.2. </span><a href="#Calico" class="headerlink" title="Calico"></a>Calico</h2><p>1、编辑calico插件的配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/cni/net.d/10-calico.conflist</span><br></pre></td></tr></table></figure><p>plugins 配置中，增加 bandwidth 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;k8s-pod-network&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;cniVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.3.1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;plugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bandwidth&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;capabilities&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span><span class="attr">&quot;bandwidth&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>2、重建calico pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl -n calico-system delete pod -l k8s-app=calico-node</span><br></pre></td></tr></table></figure><h1 id="Pod中配置注解"><span class="post-title-index">4. </span><a href="#Pod中配置注解" class="headerlink" title="Pod中配置注解"></a>Pod中配置注解</h1><p>1、pod中添加限速注解</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernetes.io/ingress-bandwidth:</span> <span class="string">&quot;1M&quot;</span>  <span class="comment"># 限制入站带宽为 1 MBps，单位Byte</span></span><br><span class="line">    <span class="attr">kubernetes.io/egress-bandwidth:</span> <span class="string">&quot;3M&quot;</span>   <span class="comment"># 限制出站带宽为 3 MBps，单位Byte</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">run:</span> <span class="string">testpod</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">testpod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">image:</span> <span class="string">debian:bookworm-slim</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">testpod</span></span><br><span class="line">    <span class="attr">resources:</span> &#123;&#125;</span><br><span class="line">    <span class="attr">command:</span> [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;-c&quot;</span>]</span><br><span class="line">    <span class="attr">args:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">tail</span> <span class="string">-f</span> <span class="string">/dev/null</span></span><br><span class="line"><span class="attr">status:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>2、登录进入pod中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it testpod -- /bin/bash</span><br></pre></td></tr></table></figure><p>3、测试外网速度</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install -y wget python3</span><br><span class="line"></span><br><span class="line">wget https://raw.github.com/sivel/speedtest-cli/master/speedtest.py</span><br><span class="line">python3 speedtest.py</span><br></pre></td></tr></table></figure><p>4、测试内网速度<br>创建两个pod，其中一个启动 iperf server，另外一个启动 iperf client<br>（1）pod1启动iperf server：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y iperf</span><br><span class="line">iperf -s</span><br></pre></td></tr></table></figure><p>（2）pod2启动iperf client：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install -y iperf</span><br><span class="line">iperf -c <span class="variable">$POD1_IP</span> -i 3</span><br></pre></td></tr></table></figure><h1 id="后记"><span class="post-title-index">5. </span><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>实际测试发现，Pod中配置注解的方式确实可以实现限制带宽，测速时的 带宽量级 会随着 限速量级 的变化而变化。<br>但是，限速效果不太好，测出的 带宽数值 与设置的 限速数值 有较大差距，并且多次测试结果波动很大。<br>整体来说，Pod中配置注解的方式可以限速，不可以精确限速。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;为避免Pod打满带宽，有时需要对Pod进行限速。&lt;br&gt;本文中，我们就来学习一下Pod中的网络限速方法。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://help.aliyun.com/zh/ack/ack-managed-and-ack-dedicated/user-guide/configure-bandwidth-limits-for-pods-in-flannel&quot;&gt;为Pod配置带宽限制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.alibabacloud.com/help/en/eci/user-guide/configure-the-bandwidth-of-a-pod-1&quot;&gt;Limit the inbound and outbound bandwidth of pods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-k8s-network-policy/&quot;&gt;《好好学K8S：K8S中的网络策略》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-docker-container-network-speed-limit/&quot;&gt;《好好学K8S：Pod网络限速》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="cloudnative" scheme="https://www.voidking.com/categories/engineering/cloudnative/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="网络" scheme="https://www.voidking.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="好好学K8S" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6K8S/"/>
    
  </entry>
  
  <entry>
    <title>Web安全之开源WAF</title>
    <link href="https://www.voidking.com/dev-web-security-waf/"/>
    <id>https://www.voidking.com/dev-web-security-waf/</id>
    <published>2024-10-06T08:00:00.000Z</published>
    <updated>2024-10-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WAF简介"><span class="post-title-index">1. </span><a href="#WAF简介" class="headerlink" title="WAF简介"></a>WAF简介</h1><p>WAF（Web Application Firewall）是保护Web应用程序免受各种网络攻击的重要工具。区别于传统防火墙，WAF 工作在应用层，对基于 HTTP/HTTPS 协议的 Web 系统有着更好的防护效果，使其免于受到黑客的攻击。</p><p>随着网络安全威胁的不断演变，开源WAF因其灵活性、可定制性和成本效益而受到越来越多企业的青睐。本文中，将盘点几款流行的开源WAF。</p><p>相关文档：</p><ul><li><a href="https://gitcode.csdn.net/6630550d16ca5020cb5bc5d3.html">2024 值得推荐的免费开源 WAF</a></li><li><a href="https://www.secrss.com/articles/55827">盘点2023年十大免费/开源WAF</a></li><li><a href="https://wnote.com/post/tools-safeline-waf/">开源Waf安全防护解决方案</a></li><li><a href="https://cloud.baidu.com/article/2701022">CentOS 7.7上利用OpenResty实现WAF应用防火墙</a></li><li><a href="https://freegeektime.com/100029001/119013/">WAF：保护我们的网络服务</a></li><li><a href="https://www.zenarmor.com/docs/network-security-tutorials/best-open-source-web-application-firewalls">The Best Open Source Web Application Firewalls</a></li><li><a href="https://www.openappsec.io/post/top-10-free-wafs-web-application-firewalls-for-2024">Top 10 Free WAFs (Web Application Firewalls) for 2024</a></li></ul><span id="more"></span><h1 id="ModeSecurity"><span class="post-title-index">2. </span><a href="#ModeSecurity" class="headerlink" title="ModeSecurity"></a>ModeSecurity</h1><p>ModSecurity是一个老牌的开源WAF，最初为Apache HTTP服务器开发，后来扩展到Nginx和IIS等其他平台。</p><p>准确来说 ModSecurity 并不是一款 “WAF”，而是一个 “WAF 规则集”，ModSecurity 是绝大部分 WAF 的底层基石，它并不包含其他 WAF 常见的网站管理、日志管理等功能，甚至完全没有界面，ModSecurity 有的只是防护规则。</p><p>ModSecurity 不适合直接使用，安装配置复杂，需要配合二次开发做一定的定制才能用起来，上手门槛高。</p><p>项目地址：<a href="https://github.com/owasp-modsecurity/ModSecurity">ModeSecurity</a>，star数 8.1k</p><h1 id="SafeLine"><span class="post-title-index">3. </span><a href="#SafeLine" class="headerlink" title="SafeLine"></a>SafeLine</h1><p>SafeLine，中文名 “雷池”，是一款简单好用，效果突出的 Web 应用防火墙(WAF)，可以保护 Web 服务不受黑客攻击。</p><p>雷池通过过滤和监控 Web 应用与互联网之间的 HTTP 流量来保护 Web 服务。可以保护 Web 服务免受 SQL 注入、XSS、 代码注入、命令注入、CRLF 注入、ldap 注入、xpath 注入、RCE、XXE、SSRF、路径遍历、后门、暴力破解、CC、爬虫 等攻击。</p><p>雷池的社区认可度很高，优势在于性能好、防护能力强、安装配置简单。</p><p>项目地址：<a href="https://github.com/chaitin/SafeLine">SafeLine</a>，star数 12.2k</p><h1 id="BunkerWeb"><span class="post-title-index">4. </span><a href="#BunkerWeb" class="headerlink" title="BunkerWeb"></a>BunkerWeb</h1><p>BunkerWeb 号称是下一代开源 Web 应用程序防火墙（WAF）。<br>BunkerWeb 作为一个功能齐全的 Web 服务器（在后台基于 NGINX），负责保护 Web 服务，使其“默认安全”。BunkerWeb 可以无缝集成到我们现有的环境（Linux、Docker、Swarm、Kubernetes 等）中，并且是完全可配置的（不要惊慌，如果我们不喜欢 CLI，有一个很棒的 Web UI）以满足我们自己的用例。换句话说，网络安全不再是一件麻烦事。<br>BunkerWeb 包含作为核心一部分的主要安全功能，还可以通过插件系统轻松扩展其他功能。</p><p>项目地址：<a href="https://github.com/bunkerity/bunkerweb">BunkerWeb</a>，star数 6.3k</p><h1 id="Coraza"><span class="post-title-index">5. </span><a href="#Coraza" class="headerlink" title="Coraza"></a>Coraza</h1><p>Coraza 是一个开源的企业级高性能 Web 应用防火墙 (WAF)。它是用 Go 编写的，支持 ModSecurity SecLang 规则集，并且与 OWASP 核心规则集 v4 100% 兼容。</p><p>项目地址：<a href="https://github.com/corazawaf/coraza">Coraza</a>，star数 2.2k</p><h1 id="open-appsec"><span class="post-title-index">6. </span><a href="#open-appsec" class="headerlink" title="open-appsec"></a>open-appsec</h1><p>open-appsec (openappsec.io) 基于机器学习提供针对 OWASP 前十名和零日攻击的预防性 Web 应用程序和 API 威胁保护。它可以作为 Kubernetes Ingress、NGINX、Envoy（即将推出）和 API 网关的附加组件进行部署。</p><p>open-appsec 引擎学习用户如何与您的 Web 应用程序正常交互。然后，它利用这些信息自动检测超出正常操作范围的请求，并进行进一步分析以决定该请求是否恶意。</p><p>项目地址：<a href="https://github.com/openappsec/openappsec">open-appsec</a>，star数 0.8k</p><h1 id="OpenResty"><span class="post-title-index">7. </span><a href="#OpenResty" class="headerlink" title="OpenResty"></a>OpenResty</h1><p>OpenResty是一个基于Nginx和LuaJIT的Web平台，它提供了强大的功能和灵活性，使得我们可以轻松地实现各种Web应用的需求。在OpenResty中，我们可以利用Lua脚本编写WAF规则，对进入的HTTP请求进行检测和过滤。</p><p>项目地址：<a href="https://github.com/openresty/openresty">OpenResty</a>，star数 12.6k</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;WAF简介&quot;&gt;&lt;a href=&quot;#WAF简介&quot; class=&quot;headerlink&quot; title=&quot;WAF简介&quot;&gt;&lt;/a&gt;WAF简介&lt;/h1&gt;&lt;p&gt;WAF（Web Application Firewall）是保护Web应用程序免受各种网络攻击的重要工具。区别于传统防火墙，WAF 工作在应用层，对基于 HTTP/HTTPS 协议的 Web 系统有着更好的防护效果，使其免于受到黑客的攻击。&lt;/p&gt;
&lt;p&gt;随着网络安全威胁的不断演变，开源WAF因其灵活性、可定制性和成本效益而受到越来越多企业的青睐。本文中，将盘点几款流行的开源WAF。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gitcode.csdn.net/6630550d16ca5020cb5bc5d3.html&quot;&gt;2024 值得推荐的免费开源 WAF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.secrss.com/articles/55827&quot;&gt;盘点2023年十大免费/开源WAF&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wnote.com/post/tools-safeline-waf/&quot;&gt;开源Waf安全防护解决方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.baidu.com/article/2701022&quot;&gt;CentOS 7.7上利用OpenResty实现WAF应用防火墙&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://freegeektime.com/100029001/119013/&quot;&gt;WAF：保护我们的网络服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zenarmor.com/docs/network-security-tutorials/best-open-source-web-application-firewalls&quot;&gt;The Best Open Source Web Application Firewalls&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.openappsec.io/post/top-10-free-wafs-web-application-firewalls-for-2024&quot;&gt;Top 10 Free WAFs (Web Application Firewalls) for 2024&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    
    <category term="网络" scheme="https://www.voidking.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="安全" scheme="https://www.voidking.com/tags/%E5%AE%89%E5%85%A8/"/>
    
    <category term="黑客" scheme="https://www.voidking.com/tags/%E9%BB%91%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker创建安卓容器</title>
    <link href="https://www.voidking.com/dev-docker-android/"/>
    <id>https://www.voidking.com/dev-docker-android/</id>
    <published>2024-07-13T08:00:00.000Z</published>
    <updated>2024-07-13T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>以前，我们使用VirtualBox等虚拟化工具创建安卓虚拟机。现在，我们使用Docker可以创建安卓容器了，更加简单便捷。<br>本文中，我们就学习一下使用Docker创建安卓容器的方法，该方法基于 <a href="https://github.com/budtmo/docker-android">budtmo/docker-android</a> 项目，目前仅支持Ubuntu系统作为宿主机。</p><span id="more"></span><h1 id="检查宿主机是否支持虚拟化"><span class="post-title-index">2. </span><a href="#检查宿主机是否支持虚拟化" class="headerlink" title="检查宿主机是否支持虚拟化"></a>检查宿主机是否支持虚拟化</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt install cpu-checker</span><br><span class="line">kvm-ok</span><br></pre></td></tr></table></figure><p>如果输出下面的内容，表明没问题</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INFO: /dev/kvm exists</span><br><span class="line">KVM acceleration can be used</span><br></pre></td></tr></table></figure><h1 id="启动安卓容器"><span class="post-title-index">3. </span><a href="#启动安卓容器" class="headerlink" title="启动安卓容器"></a>启动安卓容器</h1><p>1、启动安卓容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --name android -d \</span><br><span class="line">  -p 6080:6080 \</span><br><span class="line">  -e EMULATOR_DEVICE=<span class="string">&quot;Samsung Galaxy S10&quot;</span> \</span><br><span class="line">  -e WEB_VNC=<span class="literal">true</span> \</span><br><span class="line">  --device /dev/kvm \</span><br><span class="line">  budtmo/docker-android:emulator_11.0</span><br></pre></td></tr></table></figure><p>2、查看容器状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker logs android</span><br><span class="line">docker <span class="built_in">exec</span> -it android <span class="built_in">cat</span> device_status</span><br></pre></td></tr></table></figure><h1 id="使用安卓容器"><span class="post-title-index">4. </span><a href="#使用安卓容器" class="headerlink" title="使用安卓容器"></a>使用安卓容器</h1><p>使用安卓容器的方法：通过浏览器访问使用。<br>假设宿主机IP为：192.168.56.101 ，那么浏览器访问 <a href="http://192.168.56.101:6080/">http://192.168.56.101:6080</a><br>然后，就可以愉快地操作安卓系统了。</p><p>不过，这种使用安卓系统的方式，是没有声音的，适合APP测试，不适合作为娱乐工具。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;以前，我们使用VirtualBox等虚拟化工具创建安卓虚拟机。现在，我们使用Docker可以创建安卓容器了，更加简单便捷。&lt;br&gt;本文中，我们就学习一下使用Docker创建安卓容器的方法，该方法基于 &lt;a href=&quot;https://github.com/budtmo/docker-android&quot;&gt;budtmo/docker-android&lt;/a&gt; 项目，目前仅支持Ubuntu系统作为宿主机。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="android" scheme="https://www.voidking.com/categories/engineering/android/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="android" scheme="https://www.voidking.com/tags/android/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Shell：基于shell实现主机存活探测</title>
    <link href="https://www.voidking.com/dev-shell-liveness-probe/"/>
    <id>https://www.voidking.com/dev-shell-liveness-probe/</id>
    <published>2024-06-29T08:00:00.000Z</published>
    <updated>2024-06-29T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求描述"><span class="post-title-index">1. </span><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>当前有三个K8S集群，每个集群内部都配置了监控和告警。但是，如果某个集群整个都挂掉了，那么是收不到告警的。<br>为了解决这个问题，需要配置一个外部的探活脚本，探测集群是否存活。探测时，选择集群中的任意两台主机的ssh端口进行探测。</p><span id="more"></span><h1 id="探活脚本实现"><span class="post-title-index">2. </span><a href="#探活脚本实现" class="headerlink" title="探活脚本实现"></a>探活脚本实现</h1><p>1、探活脚本为 probe.sh</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">dev_feishu_url=<span class="string">&quot;https://open.feishu.cn/open-apis/bot/v2/hook/aaa&quot;</span></span><br><span class="line">dev_idc=<span class="string">&quot;开发机房&quot;</span></span><br><span class="line">dev_error=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">test_feishu_url=<span class="string">&quot;https://open.feishu.cn/open-apis/bot/v2/hook/bbb&quot;</span></span><br><span class="line">test_idc=<span class="string">&quot;测试机房&quot;</span></span><br><span class="line">test_error=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line">prod_feishu_url=<span class="string">&quot;https://open.feishu.cn/open-apis/bot/v2/hook/ccc&quot;</span></span><br><span class="line">prod_idc=<span class="string">&quot;生产机房&quot;</span></span><br><span class="line">prod_error=<span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /root/.bashrc</span><br><span class="line"></span><br><span class="line">now=`<span class="built_in">date</span> +%Y%m%d-%H:%M:%S`</span><br><span class="line"></span><br><span class="line">host=$(&lt; /path/to/host.txt)</span><br><span class="line">linenum=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;host&#125;</span>&quot;</span> | <span class="built_in">wc</span> -l)</span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> `<span class="built_in">seq</span> 1 <span class="variable">$&#123;linenum&#125;</span>`;<span class="keyword">do</span></span><br><span class="line">  <span class="comment">#echo $&#123;index&#125;</span></span><br><span class="line">  line=$(<span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;host&#125;</span>&quot;</span> | sed -n <span class="string">&quot;<span class="variable">$&#123;index&#125;</span>p&quot;</span>)</span><br><span class="line">  idc=$(<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line">  ip=$(<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>)</span><br><span class="line">  port=$(<span class="built_in">echo</span> <span class="variable">$line</span> | awk <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line">  value=$(<span class="built_in">timeout</span> 5s nc -zv <span class="variable">$ip</span> <span class="variable">$port</span> 2&gt;&amp;1)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$value</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$value</span>&quot;</span> =~ <span class="string">&quot;succeeded&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$idc</span>&quot;</span> == <span class="string">&quot;dev&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">    dev_error=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$idc</span>&quot;</span> == <span class="string">&quot;test&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">    test_error=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$idc</span>&quot;</span> == <span class="string">&quot;prod&quot;</span> ]];<span class="keyword">then</span></span><br><span class="line">    prod_error=<span class="literal">true</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;$dev_error&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$dev_error</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;dev_error&quot;</span></span><br><span class="line">  curl -X POST <span class="string">&quot;<span class="variable">$&#123;dev_feishu_url&#125;</span>&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">    -d <span class="string">&quot;&#123;\&quot;msg_type\&quot;:\&quot;text\&quot;,\&quot;content\&quot;:&#123;\&quot;text\&quot;:\&quot;<span class="variable">$&#123;dev_idc&#125;</span> \n<span class="variable">$&#123;now&#125;</span> \ndev cluster error!\&quot;&#125;&#125;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;dev_working&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$test_error</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;test_error&quot;</span></span><br><span class="line">  curl -X POST <span class="string">&quot;<span class="variable">$&#123;test_feishu_url&#125;</span>&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">    -d <span class="string">&quot;&#123;\&quot;msg_type\&quot;:\&quot;text\&quot;,\&quot;content\&quot;:&#123;\&quot;text\&quot;:\&quot;<span class="variable">$&#123;test_idc&#125;</span> \n<span class="variable">$&#123;now&#125;</span> \ntest cluster error!\&quot;&#125;&#125;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;test_working&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="variable">$prod_error</span></span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;prod_error&quot;</span></span><br><span class="line">  curl -X POST <span class="string">&quot;<span class="variable">$&#123;prod_feishu_url&#125;</span>&quot;</span> \</span><br><span class="line">    -H <span class="string">&quot;Content-Type: application/json&quot;</span> \</span><br><span class="line">    -d <span class="string">&quot;&#123;\&quot;msg_type\&quot;:\&quot;text\&quot;,\&quot;content\&quot;:&#123;\&quot;text\&quot;:\&quot;<span class="variable">$&#123;prod_idc&#125;</span> \n<span class="variable">$&#123;now&#125;</span> \nprod cluster error!\&quot;&#125;&#125;&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;prod_working&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>2、准备一个机房和主机信息文件 host.txt</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dev 192.168.56.101 22</span><br><span class="line">dev 192.168.56.102 22</span><br><span class="line"><span class="built_in">test</span> 172.16.0.101 222</span><br><span class="line"><span class="built_in">test</span> 172.16.0.102 222</span><br><span class="line">prod 172.16.10.101 2222</span><br><span class="line">prod 172.16.10.102 2222</span><br></pre></td></tr></table></figure><h1 id="配置定时探活"><span class="post-title-index">3. </span><a href="#配置定时探活" class="headerlink" title="配置定时探活"></a>配置定时探活</h1><p>每隔5分钟探活一次：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*/5 * * * * /path/to/probe.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h1&gt;&lt;p&gt;当前有三个K8S集群，每个集群内部都配置了监控和告警。但是，如果某个集群整个都挂掉了，那么是收不到告警的。&lt;br&gt;为了解决这个问题，需要配置一个外部的探活脚本，探测集群是否存活。探测时，选择集群中的任意两台主机的ssh端口进行探测。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    <category term="monitoring" scheme="https://www.voidking.com/categories/engineering/monitoring/"/>
    
    <category term="shell" scheme="https://www.voidking.com/categories/engineering/shell/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="监控" scheme="https://www.voidking.com/tags/%E7%9B%91%E6%8E%A7/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>好好学Linux：基于 xfs_quota 限制目录大小</title>
    <link href="https://www.voidking.com/dev-xfs-quota/"/>
    <id>https://www.voidking.com/dev-xfs-quota/</id>
    <published>2024-06-29T08:00:00.000Z</published>
    <updated>2024-06-29T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xfs-quota简介"><span class="post-title-index">1. </span><a href="#xfs-quota简介" class="headerlink" title="xfs_quota简介"></a>xfs_quota简介</h1><p><code>xfs_quota</code> 是一个管理XFS文件系统配额的工具，它提供了一套丰富的命令行操作来配置项目、用户和组的磁盘配额。<br>比如某些情况下，我们需要限制Linux系统中一些目录的大小，此时就可以使用 xfs_quota 来实现。</p><p>参考文档：</p><ul><li><a href="https://www.voidking.com/dev-linux-mount/">《好好学Linux：Linux挂载文件系统》</a></li><li><a href="https://segmentfault.com/q/1010000008420423">Linux有什么办法可以限制目录的大小？</a></li></ul><span id="more"></span><h1 id="格式化磁盘和分区"><span class="post-title-index">2. </span><a href="#格式化磁盘和分区" class="headerlink" title="格式化磁盘和分区"></a>格式化磁盘和分区</h1><p>参考<a href="https://www.voidking.com/dev-linux-mount/">《好好学Linux：Linux挂载文件系统》</a>，磁盘分区并格式化为xfs格式。</p><h1 id="挂载-xfs-分区"><span class="post-title-index">3. </span><a href="#挂载-xfs-分区" class="headerlink" title="挂载 xfs 分区"></a>挂载 xfs 分区</h1><p>因为想要使用 xfs_quota 限制目录大小，所以挂载命令和普通的挂载会有不同。<br>单次挂载命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /limitdata</span><br><span class="line">mount -o pquota,uquota,gquota /dev/sdb1 /limitdata</span><br></pre></td></tr></table></figure><p>挂载命令中，加入了 <code>pquota,uquota,gquota</code>，意思是启用项目配额限制、用户配额限制和组配额限制。</p><p>自动挂载命令为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /limitdata</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;/dev/sdb1 /limitdata xfs defaults,pquota,uquota,gquota 0 0&quot;</span> &gt;&gt; /etc/fstab</span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure><h1 id="xfs-quota常用命令"><span class="post-title-index">4. </span><a href="#xfs-quota常用命令" class="headerlink" title="xfs_quota常用命令"></a>xfs_quota常用命令</h1><h2 id="查看配额使用情况"><span class="post-title-index">4.1. </span><a href="#查看配额使用情况" class="headerlink" title="查看配额使用情况"></a>查看配额使用情况</h2><p>要查看用户或组的配额使用情况，可以使用 <code>report</code> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&#x27;report -h&#x27;</span> /limitdata</span><br></pre></td></tr></table></figure><p><code>report -h</code> 参数会显示用户和组的磁盘使用情况，<code>-h</code> 为人类可读格式（如KB、MB、GB）。</p><p>初始配额使用情况为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">User quota on /limitdata (/dev/sdb1)</span><br><span class="line">                        Blocks</span><br><span class="line">User ID      Used   Soft   Hard Warn/Grace</span><br><span class="line">---------- ---------------------------------</span><br><span class="line">root            0      0      0  00 [------]</span><br><span class="line"></span><br><span class="line">Group quota on /limitdata (/dev/sdb1)</span><br><span class="line">                        Blocks</span><br><span class="line">Group ID     Used   Soft   Hard Warn/Grace</span><br><span class="line">---------- ---------------------------------</span><br><span class="line">root            0      0      0  00 [------]</span><br><span class="line"></span><br><span class="line">Project quota on /limitdata (/dev/sdb1)</span><br><span class="line">                        Blocks</span><br><span class="line">Project ID   Used   Soft   Hard Warn/Grace</span><br><span class="line">---------- ---------------------------------</span><br><span class="line">#0              0      0      0  00 [------]</span><br></pre></td></tr></table></figure><h2 id="进入交互shell"><span class="post-title-index">4.2. </span><a href="#进入交互shell" class="headerlink" title="进入交互shell"></a>进入交互shell</h2><p>xfs_quota 可以通过一个交互式的shell界面来操作，或者通过命令行参数执行单个命令。<br>如果想要使用交互式shell界面，可以运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x /limitdata</span><br></pre></td></tr></table></figure><p>这里 /limitdata 是XFS文件系统挂载点。</p><h2 id="设置用户配额"><span class="post-title-index">4.3. </span><a href="#设置用户配额" class="headerlink" title="设置用户配额"></a>设置用户配额</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&#x27;limit bsoft=10G bhard=20G username&#x27;</span> /limitdata</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>bsoft</code> 是软限制（当用户达到这个限制时，系统会发出警告但仍允许一定时间内超额使用），<code>bhard</code> 是硬限制（用户不能超过这个限制），<code>username</code> 是要设置配额的用户名，<code>10G</code> 和 <code>20G</code> 分别是对应的大小限制。</p><h2 id="设置组配额"><span class="post-title-index">4.4. </span><a href="#设置组配额" class="headerlink" title="设置组配额"></a>设置组配额</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> xfs_quota -x -c <span class="string">&#x27;limit bsoft=10G bhard=20G -g groupname&#x27;</span> /limitdata</span><br></pre></td></tr></table></figure><p><code>-g</code> 参数指明接下来的限制是针对组的。<code>groupname</code> 是要设置配额的组名。</p><h2 id="删除用户和组配额"><span class="post-title-index">4.5. </span><a href="#删除用户和组配额" class="headerlink" title="删除用户和组配额"></a>删除用户和组配额</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&#x27;limit -u bsoft=0 bhard=0 username&#x27;</span> /limitdata</span><br></pre></td></tr></table></figure><p>同理，删除组配额，用 <code>-g</code> 参数替换 <code>-u</code> 并提供组名。</p><h2 id="设置项目配额"><span class="post-title-index">4.6. </span><a href="#设置项目配额" class="headerlink" title="设置项目配额"></a>设置项目配额</h2><h3 id="定义项目"><span class="post-title-index">4.6.1. </span><a href="#定义项目" class="headerlink" title="定义项目"></a>定义项目</h3><p>1、编辑项目定义文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/projid</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">project100:100</span><br></pre></td></tr></table></figure><p>其中，冒号前的项目名，冒号后的是项目ID。</p><p>2、编辑项目和路径映射文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/projects</span><br></pre></td></tr></table></figure><p>添加：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100:/limitdata/dir100</span><br></pre></td></tr></table></figure><p>其中，冒号前的是项目ID，冒号后的是项目路径。意思是 /limitdata/dir100 归属 100 这个项目。</p><h3 id="初始化项目配额"><span class="post-title-index">4.6.2. </span><a href="#初始化项目配额" class="headerlink" title="初始化项目配额"></a>初始化项目配额</h3><p>在配置配额之前，需要初始化目录的项目配额记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /limitdata/dir100</span><br><span class="line">xfs_quota -x -c <span class="string">&#x27;project -s project100&#x27;</span> /limitdata</span><br></pre></td></tr></table></figure><p><code>-s</code> 选项会扫描目录树，查找所有属于该项目的文件，并初始化项目的配额记录。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Setting up project project100 (path /limitdata/dir100)...</span><br><span class="line">Processed 1 (/etc/projects and cmdline) paths for project project100 with recursion depth infinite (-1).</span><br></pre></td></tr></table></figure><h3 id="设置项目配额-1"><span class="post-title-index">4.6.3. </span><a href="#设置项目配额-1" class="headerlink" title="设置项目配额"></a>设置项目配额</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&#x27;limit -p bhard=2g project100&#x27;</span> /limitdata</span><br></pre></td></tr></table></figure><p>这个命令设置 <code>project100</code> 这个项目的硬磁盘空间限制为2GB。</p><h3 id="调整项目配额"><span class="post-title-index">4.6.4. </span><a href="#调整项目配额" class="headerlink" title="调整项目配额"></a>调整项目配额</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&#x27;limit -p bhard=1g project100&#x27;</span> /limitdata</span><br></pre></td></tr></table></figure><h3 id="检查项目配额"><span class="post-title-index">4.6.5. </span><a href="#检查项目配额" class="headerlink" title="检查项目配额"></a>检查项目配额</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_quota -x -c <span class="string">&#x27;report -p&#x27;</span> /limitdata</span><br></pre></td></tr></table></figure><p>这个命令会显示所有项目的配额和使用情况。</p><h3 id="测试写入内容"><span class="post-title-index">4.6.6. </span><a href="#测试写入内容" class="headerlink" title="测试写入内容"></a>测试写入内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/limitdata/dir100/testfile bs=1G count=2</span><br></pre></td></tr></table></figure><p>正常应该会报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dd: 写入&quot;/limitdata/dir100/testfile&quot; 出错: 设备上没有空间</span><br><span class="line">记录了2+0 的读入</span><br><span class="line">记录了1+0 的写出</span><br><span class="line">1073741824字节(1.1 GB)已复制，3.31217 秒，324 MB/秒</span><br></pre></td></tr></table></figure><h1 id="限制目录的大小"><span class="post-title-index">5. </span><a href="#限制目录的大小" class="headerlink" title="限制目录的大小"></a>限制目录的大小</h1><p>限制目录的大小，对应 xfs_quota 就是设置项目配额。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=p101</span><br><span class="line"><span class="built_in">id</span>=101</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;id&#125;</span>:/limitdata/dir<span class="variable">$&#123;id&#125;</span>&quot;</span> &gt;&gt; /etc/projects</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;name&#125;</span>:<span class="variable">$&#123;id&#125;</span>&quot;</span> &gt;&gt; /etc/projid</span><br><span class="line">xfs_quota -x -c <span class="string">&quot;project -s <span class="variable">$&#123;name&#125;</span>&quot;</span> /limitdata</span><br><span class="line">xfs_quota -x -c <span class="string">&quot;limit -p bhard=1G <span class="variable">$&#123;name&#125;</span>&quot;</span> /limitdata</span><br></pre></td></tr></table></figure><h1 id="xfs-quota-nfs"><span class="post-title-index">6. </span><a href="#xfs-quota-nfs" class="headerlink" title="xfs_quota + nfs"></a>xfs_quota + nfs</h1><p>注意： xfs_quota 管理的目录，开启了nfs共享目录，依然可以被限制。<br>比如 /limitdata 目录作为nfs共享目录对外开放，从其他主机上往 /limitdata/dir100 目录中写入数据，依然会受到 xfs_quota 的限制。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;xfs-quota简介&quot;&gt;&lt;a href=&quot;#xfs-quota简介&quot; class=&quot;headerlink&quot; title=&quot;xfs_quota简介&quot;&gt;&lt;/a&gt;xfs_quota简介&lt;/h1&gt;&lt;p&gt;&lt;code&gt;xfs_quota&lt;/code&gt; 是一个管理XFS文件系统配额的工具，它提供了一套丰富的命令行操作来配置项目、用户和组的磁盘配额。&lt;br&gt;比如某些情况下，我们需要限制Linux系统中一些目录的大小，此时就可以使用 xfs_quota 来实现。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-linux-mount/&quot;&gt;《好好学Linux：Linux挂载文件系统》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/q/1010000008420423&quot;&gt;Linux有什么办法可以限制目录的大小？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="storage" scheme="https://www.voidking.com/categories/engineering/storage/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="linux" scheme="https://www.voidking.com/categories/engineering/linux/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="好好学Linux" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Linux/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>nftables入门篇</title>
    <link href="https://www.voidking.com/dev-nftables-start/"/>
    <id>https://www.voidking.com/dev-nftables-start/</id>
    <published>2024-06-15T08:00:00.000Z</published>
    <updated>2024-06-15T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是nftables？"><span class="post-title-index">1. </span><a href="#什么是nftables？" class="headerlink" title="什么是nftables？"></a>什么是nftables？</h1><p><code>nftables</code>是Linux内核的一个网络包过滤工具（框架），用于替代传统的iptables/ip6tables/arptables/ebtables范式。<br><code>nftables</code>代表了对经典的<code>iptables</code>的进化与革新，它提供了一个简单、统一和高效的方式来管理网络数据包的流动，包括过滤和路由。</p><p>本文中，我们会学习<code>nftables</code>的基础知识，了解<code>nftables</code>的常用命令。</p><p>相关文档：</p><ul><li><a href="https://www.voidking.com/dev-iptables-start/">《iptables入门篇》</a></li></ul><span id="more"></span><h1 id="iptables-vs-nftables"><span class="post-title-index">2. </span><a href="#iptables-vs-nftables" class="headerlink" title="iptables vs nftables"></a>iptables vs nftables</h1><p><code>iptables</code>和<code>nftables</code>（nf表示netfilter）都是Linux系统中用于管理网络流量规则的工具，它们用于配置内核的网络包过滤、转发以及网络地址转换(NAT)等功能。</p><h2 id="iptables特点"><span class="post-title-index">2.1. </span><a href="#iptables特点" class="headerlink" title="iptables特点"></a>iptables特点</h2><ul><li><code>iptables</code>是在较早的Linux内核版本中引入的网络包过滤框架。</li><li>它主要和Netfilter框架交互，负责IPv4流量。</li><li><code>iptables</code>有自己的语法规则，通过命令行工具来管理。</li><li>它有多个表(table)，比如<code>filter</code>, <code>nat</code>, <code>mangle</code>, <code>raw</code>，每个表包含一组链(chain)，例如<code>INPUT</code>, <code>FORWARD</code>, <code>OUTPUT</code>。</li><li>命令行语法可能对新手来说比较复杂且难以理解。</li><li><code>iptables</code>没有直接的支持IPV6，需要通过<code>ip6tables</code>来进行配置。</li></ul><h2 id="nftables特点"><span class="post-title-index">2.2. </span><a href="#nftables特点" class="headerlink" title="nftables特点"></a>nftables特点</h2><ul><li><code>nftables</code>是<code>iptables</code>的现代替代品，随Linux内核3.13及以后版本发布。</li><li>它是为了解决<code>iptables</code>命令复杂和性能不佳等问题而设计的。</li><li><code>nftables</code>使用新的<code>nft</code>命令行工具，提供了一种更简洁的的语法，结构更为统一，并且可以同时处理IPv4、IPv6和其他协议，从而简化了规则集的管理和配置。</li><li><code>nftables</code>提供了一个内置的数据包分类引擎，用来代替<code>iptables</code>中的多个存在重叠功能的模块。</li><li><code>nftables</code>使用单个框架来取代<code>iptables</code>中的多个工具(<code>iptables</code>, <code>ip6tables</code>, <code>arptables</code>, <code>ebtables</code>)。</li></ul><h2 id="区别"><span class="post-title-index">2.3. </span><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul><li>语法：<code>nftables</code>有更为简单和现代的语法。</li><li>性能：<code>nftables</code>旨在提供更好的性能。</li><li>易用性：<code>nftables</code>提供更为统一的处理方式，减少了之前版本的复杂度。</li><li>功能整合：<code>nftables</code>合并了<code>iptables</code>的多个实用工具和表，简化了管理过程。</li><li>协议支持：<code>nftables</code>可以同时支持多个协议。</li></ul><h2 id="联系"><span class="post-title-index">2.4. </span><a href="#联系" class="headerlink" title="联系"></a>联系</h2><ul><li>目的：它们都旨在管理Linux内核的包过滤规则。</li><li>基础：<code>nftables</code>建立在<code>iptables</code>的基础上，尝试克服<code>iptables</code>现存的不足。</li><li>Netfilter：它们都使用Netfilter框架来实现网络包的过滤和处理。</li></ul><h2 id="小结"><span class="post-title-index">2.5. </span><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>总的来说，虽然<code>nftables</code>是作为<code>iptables</code>的后续者被设计和构建的，但两者在很长一段时间内是并存的，而现在Linux社区鼓励大家使用<code>nftables</code>以取代被认为过时的<code>iptables</code>。不过，许多老系统和应用可能仍然依赖于<code>iptables</code>。</p><h1 id="nftables关键组成"><span class="post-title-index">3. </span><a href="#nftables关键组成" class="headerlink" title="nftables关键组成"></a>nftables关键组成</h1><ul><li>nftables子系统：这是Linux内核的一部分，是nftables操作的核心。它通过Netfilter提供的钩子（hooks）处理数据包。</li><li>nft命令行工具：用户通过<code>nft</code>命令行工具与nftables子系统进行交互。这个工具用于设置和更新规则集。</li><li>规则集：规则集（rulesets）是nftables配置的核心。它包含了基于各种条件对数据包进行处理的规则。</li></ul><h1 id="安装nftables"><span class="post-title-index">4. </span><a href="#安装nftables" class="headerlink" title="安装nftables"></a>安装nftables</h1><p>在现代的Linux发行版上，默认情况下可能已经安装了<code>nftables</code>。如果没有安装，我们可以通过发行版的包管理工具来安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Debian/Ubuntu</span></span><br><span class="line"><span class="built_in">sudo</span> apt install nftables</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS/RHEL</span></span><br><span class="line"><span class="built_in">sudo</span> yum install nftables</span><br><span class="line"></span><br><span class="line"><span class="comment"># Fedora</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install nftables</span><br></pre></td></tr></table></figure><h1 id="nftables基础"><span class="post-title-index">5. </span><a href="#nftables基础" class="headerlink" title="nftables基础"></a>nftables基础</h1><h2 id="表、链和规则"><span class="post-title-index">5.1. </span><a href="#表、链和规则" class="headerlink" title="表、链和规则"></a>表、链和规则</h2><p>在nftables中，表（tables）是存储链（chains）的容器，而链则是规则的集合。一个规则可以决定接受、拒绝、转发还是处理一个数据包。</p><h2 id="nft命令基础"><span class="post-title-index">5.2. </span><a href="#nft命令基础" class="headerlink" title="nft命令基础"></a>nft命令基础</h2><h3 id="创建表"><span class="post-title-index">5.2.1. </span><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft add table ip my_table</span><br></pre></td></tr></table></figure><p>其中 <code>ip</code> 指定了正在创建的表将用于IPv4流量。</p><h3 id="创建链到表中"><span class="post-title-index">5.2.2. </span><a href="#创建链到表中" class="headerlink" title="创建链到表中"></a>创建链到表中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft add chain ip my_table my_chain &#123; <span class="built_in">type</span> filter hook input priority 0 \; &#125;</span><br></pre></td></tr></table></figure><h3 id="创建规则到链中"><span class="post-title-index">5.2.3. </span><a href="#创建规则到链中" class="headerlink" title="创建规则到链中"></a>创建规则到链中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft add rule ip my_table my_chain ip saddr 192.168.1.0/24 accept</span><br></pre></td></tr></table></figure><p>这个命令会在<code>my_chain</code>中添加一个规则，允许来自子网<code>192.168.1.0/24</code>的所有进入数据包。</p><h3 id="查看表、链和规则"><span class="post-title-index">5.2.4. </span><a href="#查看表、链和规则" class="headerlink" title="查看表、链和规则"></a>查看表、链和规则</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nft list tables</span><br><span class="line">nft list chains</span><br><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@gateway ~]# nft list tables</span><br><span class="line">table ip my_table</span><br><span class="line">[root@gateway ~]# nft list chains</span><br><span class="line">table ip my_table &#123;</span><br><span class="line">    chain my_chain &#123;</span><br><span class="line">        type filter hook input priority 0; policy accept;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">[root@gateway ~]# nft list ruleset</span><br><span class="line">table ip my_table &#123;</span><br><span class="line">    chain my_chain &#123;</span><br><span class="line">        type filter hook input priority 0; policy accept;</span><br><span class="line">        ip saddr 192.168.1.0/24 accept</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除规则"><span class="post-title-index">5.2.5. </span><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h3><p>查看当前的规则集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft list ruleset</span><br></pre></td></tr></table></figure><p>删除某个特定的规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft delete rule ip my_table my_chain handle 1</span><br></pre></td></tr></table></figure><h3 id="保存和恢复规则集"><span class="post-title-index">5.2.6. </span><a href="#保存和恢复规则集" class="headerlink" title="保存和恢复规则集"></a>保存和恢复规则集</h3><p>当主机重启后，表、链和规则会全部清空，因此需要保存和恢复规则集。</p><p>保存当前的规则集到文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft list ruleset &gt; /etc/nftables.conf</span><br></pre></td></tr></table></figure><p>从文件恢复规则集：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft -f /etc/nftables.conf</span><br></pre></td></tr></table></figure><h1 id="示例：基本的端口过滤"><span class="post-title-index">6. </span><a href="#示例：基本的端口过滤" class="headerlink" title="示例：基本的端口过滤"></a>示例：基本的端口过滤</h1><p>假设我们想要允许SSH（端口22）和HTTP（端口80）流量，但拒绝其他所有的入站流量。</p><p>1、新建一个表和链，默认允许所有流量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nft add table ip filter</span><br><span class="line">nft add chain ip filter input &#123; <span class="built_in">type</span> filter hook input priority 0 \; policy accept \; &#125;</span><br></pre></td></tr></table></figure><p>2、添加规则允许SSH和HTTP流量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nft add rule ip filter input tcp dport &#123;22, 80&#125; accept</span><br></pre></td></tr></table></figure><p>3、除了允许的规则外，拒绝所有流量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nft add rule ip filter input counter drop</span><br><span class="line">nft list chain ip filter input</span><br></pre></td></tr></table></figure><p>通过插入一个计数器规则，丢弃并记录没有匹配到accept规则的流量。</p><p>或者：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nft chain ip filter input &#123; <span class="built_in">type</span> filter hook input priority 0 \; policy drop \; &#125;</span><br><span class="line">nft list chain ip filter input</span><br></pre></td></tr></table></figure><p>通过修改链的默认策略为drop，丢弃没有匹配到accept规则的流量。</p><p>以上命令建立了一个默认拒绝所有进入流量的策略，并明确设定了接受端口为22和80的TCP连接的规则。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;什么是nftables？&quot;&gt;&lt;a href=&quot;#什么是nftables？&quot; class=&quot;headerlink&quot; title=&quot;什么是nftables？&quot;&gt;&lt;/a&gt;什么是nftables？&lt;/h1&gt;&lt;p&gt;&lt;code&gt;nftables&lt;/code&gt;是Linux内核的一个网络包过滤工具（框架），用于替代传统的iptables/ip6tables/arptables/ebtables范式。&lt;br&gt;&lt;code&gt;nftables&lt;/code&gt;代表了对经典的&lt;code&gt;iptables&lt;/code&gt;的进化与革新，它提供了一个简单、统一和高效的方式来管理网络数据包的流动，包括过滤和路由。&lt;/p&gt;
&lt;p&gt;本文中，我们会学习&lt;code&gt;nftables&lt;/code&gt;的基础知识，了解&lt;code&gt;nftables&lt;/code&gt;的常用命令。&lt;/p&gt;
&lt;p&gt;相关文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.voidking.com/dev-iptables-start/&quot;&gt;《iptables入门篇》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="shell" scheme="https://www.voidking.com/categories/engineering/shell/"/>
    
    <category term="network" scheme="https://www.voidking.com/categories/engineering/network/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="网络" scheme="https://www.voidking.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
    <category term="iptables" scheme="https://www.voidking.com/tags/iptables/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：基于Docker buildx构建多平台镜像</title>
    <link href="https://www.voidking.com/dev-docker-buildx/"/>
    <id>https://www.voidking.com/dev-docker-buildx/</id>
    <published>2024-05-04T08:00:00.000Z</published>
    <updated>2024-05-04T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-buildx-是什么？"><span class="post-title-index">1. </span><a href="#Docker-buildx-是什么？" class="headerlink" title="Docker buildx 是什么？"></a>Docker buildx 是什么？</h1><p>Docker buildx 是 Docker 官方维护的一个 CLI 插件，它基于 BuildKit 引擎，提供了不同于 docker build 的更多功能，<br>buildx的一个关键特性是可以同时为不同的硬件架构构建并输出镜像，使得我们可以很容易地交叉构建镜像。比如，我们可以在 AMD64 的机器上构建 ARM64 架构的镜像，这对于软件的跨平台支持非常有用。</p><p>Docker buildx 支持的平台主要包括以下几种：</p><ul><li>Linux：包括多种 CPU 架构和操作系统，如 x86_64、ARM、IBM Power、IBM Z 等。</li><li>Windows：包括多种 CPU 架构和操作系统，如 x86_64、ARM64 等。</li><li>macOS：支持 Intel、Apple M1 架构。</li></ul><p>在本文中，我们将学习 Docker buildx 工具，并基于它构建多平台镜像。</p><p>参考文档：</p><ul><li><a href="https://github.com/docker/buildx">github - docker/buildx</a></li><li><a href="https://jimmysong.io/blog/docker-multi-platform-image-building/">Docker 多平台构建指南：构建 WebAssembly 镜像</a></li><li><a href="https://docs.docker.com/build/drivers/docker-container/">Docker container build driver</a></li><li><a href="https://blog.haohtml.com/archives/31052">利用 docker buildx 构建多平台镜像</a></li></ul><span id="more"></span><h1 id="Docker-buildx-builder是什么？"><span class="post-title-index">2. </span><a href="#Docker-buildx-builder是什么？" class="headerlink" title="Docker buildx builder是什么？"></a>Docker buildx builder是什么？</h1><p>单纯的 Docker builder，一般是指执行 Docker 镜像构建任务的一个实体或者进程。</p><p>在 Docker buildx 工具中，builder 指的是进行镜像构建的一个实例或环境。</p><p>builder 实例的特性：</p><ul><li>它可以被配置为支持跨多种平台的构建，如 <code>linux/amd64</code>、<code>linux/arm64</code> 等。</li><li>每个 builder 实例可以使用不同的驱动程序，Docker buildx 默认支持两种类型的驱动：<code>docker</code> 和 <code>docker-container</code>。</li><li>它允许我们定义构建环境的不同方面，比如资源限制、构建缓存存储位置等。</li><li>builder 实例可以是本地的，也可以被配置为分布式，由多个节点组成，以便分布式地执行构建任务。</li></ul><p>builder 实例常用命令：</p><ul><li><code>docker buildx ls</code>：查看 builer 实例列表</li><li><code>docker buildx inspect</code>：检查当前 builder 实例的详细信息，如果想查看特定的 builder，可以将其名称作为参数传入命令</li><li><code>docker buildx use</code>：切换到一个指定的 builder 实例，让后续的 <code>docker buildx</code> 命令使用该实例</li><li><code>docker buildx create</code>：创建新的 builder 实例</li><li><code>docker buildx update</code>：修改 builder 实例配置</li><li><code>docker buildx rm</code>：删除一个 builder 实例</li></ul><p>builder 常用配置：</p><ul><li>平台：指定 builder 可以为哪些操作系统和架构对组合来构建镜像。例如 <code>linux/amd64</code>、<code>linux/arm64</code>、<code>windows/amd64</code> 等。</li><li>环境变量：为 builder 实例设定环境变量，这些变量在构建过程中可用。</li><li>构建选项：例如构建缓存的位置、构建输出的位置、是否使用 BuildKit 功能等。</li><li>节点：在使用 <code>docker-container</code> 驱动时，我们可以添加多个节点，这些节点可以扩展 builder 的构建能力。</li><li>驱动选项：指定构建使用的驱动和配置，例如 <code>image</code> 驱动或者 <code>docker-container</code> 驱动的细节配置，包括使用的网络模式等。</li></ul><h1 id="配置-Docker-buildx-环境"><span class="post-title-index">3. </span><a href="#配置-Docker-buildx-环境" class="headerlink" title="配置 Docker buildx 环境"></a>配置 Docker buildx 环境</h1><p>1、确保 Docker 版本不低于 19.03，才能使用 buildx</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker --version</span><br></pre></td></tr></table></figure><p>2、检查 buildx 插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx version</span><br></pre></td></tr></table></figure><p>通过apt或者yum等包管理方式安装的Docker，默认是带有 buildx 插件的。</p><p>如果我们使用的 Docker 版本中没有包含 buildx，或者想要安装最新版本的 buildx，可以访问 <a href="https://github.com/docker/buildx">github - docker/buildx</a> 获取安装指南。</p><p>3、安装 buildx 插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/docker/buildx/releases/download/v0.14.0/buildx-v0.14.0.linux-amd64</span><br><span class="line"><span class="built_in">chmod</span> a+x buildx-v0.14.0.linux-amd64</span><br><span class="line"><span class="built_in">mkdir</span> -p /usr/libexec/docker/cli-plugins</span><br><span class="line"><span class="built_in">mv</span> buildx-v0.14.0.linux-amd64 /usr/libexec/docker/cli-plugins/docker-buildx</span><br></pre></td></tr></table></figure><p>更多系统适用的 buildx 版本，可以访问<a href="https://github.com/docker/buildx/releases">github - buildx releases</a>页面获取。</p><p>4、启用实验性功能<br>为了构建多平台镜像，需要确保 Docker 的实验性功能被启用，因为 buildx 依赖这些功能。<br>我们可以通过修改 Docker 配置文件（通常位于 <code>~/.docker/config.json</code>）来启用实验功能。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;experimental&quot;</span><span class="punctuation">:</span> <span class="string">&quot;enabled&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h1 id="支持多平台构建的-builder-实例"><span class="post-title-index">4. </span><a href="#支持多平台构建的-builder-实例" class="headerlink" title="支持多平台构建的 builder 实例"></a>支持多平台构建的 builder 实例</h1><p>buildx 有一个默认的 builder，但是这个builder不支持多平台构建。因此，我们需要创建一个支持多平台构建的 builder 实例。</p><p>1、查看 builder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx <span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>2、创建一个支持多平台构建的 builder 实例，并切换到新的builder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx create --name mybuilder --driver docker-container --use</span><br></pre></td></tr></table></figure><p>注意：使用docker-container driver才支持多平台构建。</p><p>3、查看 builder 详情并初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx inspect --bootstrap</span><br></pre></td></tr></table></figure><p>4、切换builder</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker buildx use default</span><br><span class="line">docker buildx use mybuilder</span><br></pre></td></tr></table></figure><p>5、查看builder详情</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx inspect mybuilder</span><br></pre></td></tr></table></figure><h1 id="构建多平台的镜像"><span class="post-title-index">5. </span><a href="#构建多平台的镜像" class="headerlink" title="构建多平台的镜像"></a>构建多平台的镜像</h1><p>1、查看基础镜像的多平台镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx imagetools inspect busybox:1.34</span><br></pre></td></tr></table></figure><p>2、编写 Dockerfile</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox:1.34</span><br></pre></td></tr></table></figure><p>3、构建多平台镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7  -t voidking/busybox:1.34 .</span><br></pre></td></tr></table></figure><p>出现警告：WARNING: No output specified with docker-container driver. Build result will only remain in the build cache. To push result image into registry use –push or to load image into docker use –load</p><p>这个命令将会为 amd64、arm64 和 arm/v7 架构构建镜像，但是，构建后的镜像通过 <code>docker images</code> 是看不到的，只会存在BuildKit 的构建缓存中，也就是说<code>-t</code>参数是无效的。</p><p>想要看到构建出的镜像，有两个办法：<br>方法一：使用<code>--push</code>参数直接上传到镜像仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/amd64,linux/arm64,linux/arm/v7  -t voidking/busybox:1.34 --push .</span><br><span class="line">docker buildx imagetools inspect voidking/busybox:1.34</span><br></pre></td></tr></table></figure><p>方法二：使用<code>--load</code>参数，一次只构建一个平台的镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker buildx build --platform linux/arm64  -t voidking/busybox:1.34 --load .</span><br><span class="line">docker inspect voidking/busybox:1.34</span><br></pre></td></tr></table></figure><h1 id="后记"><span class="post-title-index">6. </span><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>构建出的镜像，并不确保一定可用。可以使用像 QEMU 这样的模拟器，或者实际的硬件设备来测试构建的容器镜像。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-buildx-是什么？&quot;&gt;&lt;a href=&quot;#Docker-buildx-是什么？&quot; class=&quot;headerlink&quot; title=&quot;Docker buildx 是什么？&quot;&gt;&lt;/a&gt;Docker buildx 是什么？&lt;/h1&gt;&lt;p&gt;Docker buildx 是 Docker 官方维护的一个 CLI 插件，它基于 BuildKit 引擎，提供了不同于 docker build 的更多功能，&lt;br&gt;buildx的一个关键特性是可以同时为不同的硬件架构构建并输出镜像，使得我们可以很容易地交叉构建镜像。比如，我们可以在 AMD64 的机器上构建 ARM64 架构的镜像，这对于软件的跨平台支持非常有用。&lt;/p&gt;
&lt;p&gt;Docker buildx 支持的平台主要包括以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Linux：包括多种 CPU 架构和操作系统，如 x86_64、ARM、IBM Power、IBM Z 等。&lt;/li&gt;
&lt;li&gt;Windows：包括多种 CPU 架构和操作系统，如 x86_64、ARM64 等。&lt;/li&gt;
&lt;li&gt;macOS：支持 Intel、Apple M1 架构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在本文中，我们将学习 Docker buildx 工具，并基于它构建多平台镜像。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/docker/buildx&quot;&gt;github - docker/buildx&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://jimmysong.io/blog/docker-multi-platform-image-building/&quot;&gt;Docker 多平台构建指南：构建 WebAssembly 镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.docker.com/build/drivers/docker-container/&quot;&gt;Docker container build driver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.haohtml.com/archives/31052&quot;&gt;利用 docker buildx 构建多平台镜像&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置WebIDE VSCode</title>
    <link href="https://www.voidking.com/dev-docker-webide-vscode/"/>
    <id>https://www.voidking.com/dev-docker-webide-vscode/</id>
    <published>2024-04-13T08:00:00.000Z</published>
    <updated>2024-04-13T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebIDE简介"><span class="post-title-index">1. </span><a href="#WebIDE简介" class="headerlink" title="WebIDE简介"></a>WebIDE简介</h1><p>WebIDE是一个现代化的开发工具，它可以让我们直接在浏览器中编写、运行和调试代码。不需要安装任何软件，只需要一个现代化的浏览器和网络连接就可以进行开发。这是一种全新的开发方式，并迅速得到了广大开发者的欢迎。</p><p>参考文档：</p><ul><li><a href="https://www.iceyao.com.cn/post/2023-03-09-webide_learning_note/">WebIDE技术方案调研</a></li><li><a href="https://xie.infoq.cn/article/46f422772132bfb9dd2a39100">2022 年最有前景的 5 个 Web IDE</a></li><li><a href="https://juejin.cn/post/7008428269317914661">如何在团队内快速落地WebIDE</a></li></ul><span id="more"></span><h1 id="主流WebIDE对比"><span class="post-title-index">2. </span><a href="#主流WebIDE对比" class="headerlink" title="主流WebIDE对比"></a>主流WebIDE对比</h1><h2 id="VSCode流派"><span class="post-title-index">2.1. </span><a href="#VSCode流派" class="headerlink" title="VSCode流派"></a>VSCode流派</h2><p>VSCode流派基于<a href="https://github.com/Microsoft/vscode">VSCode</a>，提供了通过浏览器访问VSCode IDE的功能。<br>支持VSCode插件，并提供了与VSCode相同的编辑器功能。</p><p>代表：<a href="https://github.com/features/codespaces">Codespaces</a>、<a href="https://github.com/coder/code-server">coder/code-server</a>、<a href="https://codesandbox.io/">CodeSandbox</a></p><h2 id="Projector流派"><span class="post-title-index">2.2. </span><a href="#Projector流派" class="headerlink" title="Projector流派"></a>Projector流派</h2><p>JetBrains Projector流派基于JetBrains，提供了通过浏览器远程访问JetBrains IDE的功能。<br>支持多个编程语言和多种插件，并提供了与JetBrains IDE相同的编辑器功能。</p><p>代表：<a href="https://github.com/JetBrains/projector-server">JetBrains Projector</a></p><h2 id="Theia流派"><span class="post-title-index">2.3. </span><a href="#Theia流派" class="headerlink" title="Theia流派"></a>Theia流派</h2><p>Theia流派基于Eclipse Theia，部分功能复用VSCode，但是在扩展能力上，远超VSCode。</p><p>代表：<a href="https://www.gitpod.io/">Gitpod</a>、阿里云OpenSumi、华为云CodeArtsIDE、Google云IDE</p><h2 id="StackBlitz"><span class="post-title-index">2.4. </span><a href="#StackBlitz" class="headerlink" title="StackBlitz"></a>StackBlitz</h2><p>StackBlitz是一款专为Web应用程序开发设计的WebIDE，适合前端开发。</p><h1 id="code-server工作原理"><span class="post-title-index">3. </span><a href="#code-server工作原理" class="headerlink" title="code-server工作原理"></a>code-server工作原理</h1><p>通过浏览器或者客户端连接远程的IDE（code-server），远程IDE负责执行，结果实时返回。如果产生数据，那么数据存储在远程磁盘上。<br>远程IDE可以运行在VM上，也可以运行在容器中。</p><h1 id="安装配置code-server"><span class="post-title-index">4. </span><a href="#安装配置code-server" class="headerlink" title="安装配置code-server"></a>安装配置code-server</h1><p>参考文档：<a href="https://coder.com/docs/code-server/latest/install#docker">Coder Docs - Install by Docker</a></p><p>1、安装code-server</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This will start a code-server container and expose it at http://127.0.0.1:8080.</span></span><br><span class="line"><span class="comment"># It will also mount your current directory into the container as `/home/coder/project`</span></span><br><span class="line"><span class="comment"># and forward your UID/GID so that all file system operations occur as your user outside</span></span><br><span class="line"><span class="comment"># the container.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Your $HOME/.config is mounted at $HOME/.config within the container to ensure you can</span></span><br><span class="line"><span class="comment"># easily access/modify your code-server config in $HOME/.config/code-server/config.json</span></span><br><span class="line"><span class="comment"># outside the container.</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.config</span><br><span class="line">docker run -it --name code-server -d \</span><br><span class="line">  -p 8080:8080 \</span><br><span class="line">  -v <span class="string">&quot;<span class="variable">$HOME</span>/.local:/home/coder/.local&quot;</span> \</span><br><span class="line">  -v <span class="string">&quot;<span class="variable">$HOME</span>/.config:/home/coder/.config&quot;</span> \</span><br><span class="line">  -v <span class="string">&quot;<span class="variable">$PWD</span>:/home/coder/project&quot;</span> \</span><br><span class="line">  -u <span class="string">&quot;<span class="subst">$(id -u)</span>:<span class="subst">$(id -g)</span>&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;DOCKER_USER=<span class="variable">$USER</span>&quot;</span> \</span><br><span class="line">  codercom/code-server:latest</span><br></pre></td></tr></table></figure><p>2、查看code-server状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs code-server</span><br></pre></td></tr></table></figure><h1 id="使用code-server"><span class="post-title-index">5. </span><a href="#使用code-server" class="headerlink" title="使用code-server"></a>使用code-server</h1><p>1、浏览器访问code-server服务<br>假设主机IP为 192.168.50.101，那么浏览器访问 <a href="http://192.168.50.101:8080/login">http://192.168.50.101:8080/login</a></p><p>2、获取密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it code-server <span class="built_in">cat</span> /root/.config/code-server/config.yaml</span><br></pre></td></tr></table></figure><p>获取到密码后，在浏览器页面中输入密码，即可进入code-server。</p><p>3、使用code-server<br>使用方法和vscode基本没有差别。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;WebIDE简介&quot;&gt;&lt;a href=&quot;#WebIDE简介&quot; class=&quot;headerlink&quot; title=&quot;WebIDE简介&quot;&gt;&lt;/a&gt;WebIDE简介&lt;/h1&gt;&lt;p&gt;WebIDE是一个现代化的开发工具，它可以让我们直接在浏览器中编写、运行和调试代码。不需要安装任何软件，只需要一个现代化的浏览器和网络连接就可以进行开发。这是一种全新的开发方式，并迅速得到了广大开发者的欢迎。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.iceyao.com.cn/post/2023-03-09-webide_learning_note/&quot;&gt;WebIDE技术方案调研&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xie.infoq.cn/article/46f422772132bfb9dd2a39100&quot;&gt;2022 年最有前景的 5 个 Web IDE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7008428269317914661&quot;&gt;如何在团队内快速落地WebIDE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="vscode" scheme="https://www.voidking.com/tags/vscode/"/>
    
    <category term="编辑器" scheme="https://www.voidking.com/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Docker：使用Docker安装配置Chrome</title>
    <link href="https://www.voidking.com/dev-docker-chrome/"/>
    <id>https://www.voidking.com/dev-docker-chrome/</id>
    <published>2024-04-06T08:00:00.000Z</published>
    <updated>2024-04-06T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>Kasm Workspaces is a docker container streaming platform for delivering browser-based access to desktops, applications, and web services.</p></blockquote><p>Kasm Workspaces是一个Docker容器流媒体平台，用于提供基于浏览器的访问桌面、应用程序和Web服务。</p><p>Kasm Workspaces提供了一个可通过浏览器访问的 Google Chrome 版本。本文中，我们就来部署一下这个Docker Chrome。</p><p>参考文档：</p><ul><li><a href="https://github.com/kasmtech/KasmVNC">github - kasmtech/KasmVNC</a></li><li><a href="https://hub.docker.com/r/kasmweb/chrome">dockerhub - kasmweb/chrome</a></li></ul><span id="more"></span><h1 id="安装Docker-Chrome"><span class="post-title-index">2. </span><a href="#安装Docker-Chrome" class="headerlink" title="安装Docker Chrome"></a>安装Docker Chrome</h1><p>1、安装Docker Chrome</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run --name chrome -d \</span><br><span class="line">  --restart always \</span><br><span class="line">  --shm-size=1024m \</span><br><span class="line">  -p 6901:6901 \</span><br><span class="line">  -e VNC_PW=password123 \</span><br><span class="line">  -e LANG=zh_CN.UTF-8 \</span><br><span class="line">  -e TZ=Asia/Shanghai \</span><br><span class="line">  -u root \</span><br><span class="line">  kasmweb/chrome:1.14.0</span><br></pre></td></tr></table></figure><p>2、查看运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker ps | grep chrome</span><br><span class="line">docker logs chrome</span><br></pre></td></tr></table></figure><h1 id="使用Docker-Chrome"><span class="post-title-index">3. </span><a href="#使用Docker-Chrome" class="headerlink" title="使用Docker Chrome"></a>使用Docker Chrome</h1><p>1、浏览器访问Chrome<br>假设宿主机地址为 192.168.56.101 ，那么访问地址为：<a href="https://192.168.56.101:6901/">https://192.168.56.101:6901</a><br>注意是https，不是http。</p><p>2、登录KasmVNC<br>根据提示，输入用户名和密码，登录KasmVNC<br>用户名为 kasm_user ，密码为 password123</p><p>3、使用Chrome<br>和本地Chrome基本没有差别，使用起来很方便。</p><p>Please note that some functionality, such as audio, uploads, downloads, and microphone pass-through, is only available when using Kasm Workspaces for orchestration.</p><p>请注意，某些功能只有在使用Kasm工作区进行编排时才可用，比如音频、上传、下载和麦克风传递。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Kasm Workspaces is a docker container streaming platform for delivering browser-based access to desktops, applications, and web services.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Kasm Workspaces是一个Docker容器流媒体平台，用于提供基于浏览器的访问桌面、应用程序和Web服务。&lt;/p&gt;
&lt;p&gt;Kasm Workspaces提供了一个可通过浏览器访问的 Google Chrome 版本。本文中，我们就来部署一下这个Docker Chrome。&lt;/p&gt;
&lt;p&gt;参考文档：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/kasmtech/KasmVNC&quot;&gt;github - kasmtech/KasmVNC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hub.docker.com/r/kasmweb/chrome&quot;&gt;dockerhub - kasmweb/chrome&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="好好学Docker" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Docker/"/>
    
  </entry>
  
  <entry>
    <title>好好学Shell：Shell脚本问题记录</title>
    <link href="https://www.voidking.com/dev-shell-problem/"/>
    <id>https://www.voidking.com/dev-shell-problem/</id>
    <published>2024-04-06T08:00:00.000Z</published>
    <updated>2024-12-14T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录在编写Shell脚本时遇到的问题，备忘。</p><span id="more"></span><h1 id="Docker输出取值问题"><span class="post-title-index">2. </span><a href="#Docker输出取值问题" class="headerlink" title="Docker输出取值问题"></a>Docker输出取值问题</h1><h2 id="问题描述"><span class="post-title-index">2.1. </span><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">value=$(docker <span class="built_in">exec</span> -it <span class="built_in">test</span> <span class="built_in">echo</span> <span class="string">&#x27;&quot;10&quot;&#x27;</span>)</span><br><span class="line"><span class="comment"># echo &quot;$value&quot;</span></span><br><span class="line">value=<span class="variable">$&#123;value//\&quot;/&#125;</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$value</span> =~ ^[0-9]+$ ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;running&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;failed&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>这段代码的期望输出为 running，实际输出为 failed ，是为什么？<br>其中test容器是任意一个docker容器，比如busybox。</p><h2 id="问题排查解决"><span class="post-title-index">2.2. </span><a href="#问题排查解决" class="headerlink" title="问题排查解决"></a>问题排查解决</h2><p>在docker命令执行的结果中，可能包含一些看不见的控制字符。</p><p>排查方法：使用od命令查看不可见的控制字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$value</span>&quot;</span> | <span class="built_in">od</span> -c</span><br></pre></td></tr></table></figure><p>可以看到输出为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0000000   &quot;   1   0   &quot;  \r  \n</span><br><span class="line">0000006</span><br></pre></td></tr></table></figure><p>由此可以发现控制字符为 <code>\r</code> 和 <code>\n</code>。</p><p>解决办法：进一步处理value变量，去除控制字符。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value=$(<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$value</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\r\n&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="扩展学习：od命令"><span class="post-title-index">2.3. </span><a href="#扩展学习：od命令" class="headerlink" title="扩展学习：od命令"></a>扩展学习：od命令</h2><p>od命令用于将指定文件内容以八进制、十进制、十六进制、浮点格式或ASCII编码字符方式显示。通常用于显示或查看文件中不能直接显示在终端的字符。od命令系统默认的显示方式是八进制，名称源于Octal Dump。</p><p>常见的文件为文本文件和二进制文件。od命令主要用来查看保存在二进制文件中的值，按照指定格式解释文件中的数据并输出，不管是IEEE754格式的浮点数还是ASCII码，od命令都能按照需求输出它们的值。</p><p><code>od -c</code>: same as -t c,  select printable characters or backslash escapes</p><h1 id="直接运行和定时任务运行结果不一致问题"><span class="post-title-index">3. </span><a href="#直接运行和定时任务运行结果不一致问题" class="headerlink" title="直接运行和定时任务运行结果不一致问题"></a>直接运行和定时任务运行结果不一致问题</h1><h2 id="问题描述-1"><span class="post-title-index">3.1. </span><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">value=$(docker <span class="built_in">exec</span> -it <span class="built_in">test</span> <span class="built_in">echo</span> <span class="string">&#x27;&quot;10&quot;&#x27;</span>)</span><br><span class="line">value=$(<span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$value</span>&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\r\n\&quot;&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$value</span> =~ ^[0-9]+$ ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;running&quot;</span> | <span class="built_in">tee</span> -a /tmp/shell.log</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;failed&quot;</span> | <span class="built_in">tee</span> -a /tmp/shell.log</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p>上面这段代码，直接运行时结果为 running ，contab运行结果为 failed ，表现不一致，为什么？</p><h2 id="问题排查解决-1"><span class="post-title-index">3.2. </span><a href="#问题排查解决-1" class="headerlink" title="问题排查解决"></a>问题排查解决</h2><p>经测试，发现 <code>docker exec -it test echo &#39;&quot;10&quot;&#39;</code> 命令中去掉 <code>-it</code> ，问题可以解决。</p><p>推测问题原因是cron作业不能添加交互式终端参数。</p><h1 id="tail报错Too-many-open-files"><span class="post-title-index">4. </span><a href="#tail报错Too-many-open-files" class="headerlink" title="tail报错Too many open files"></a>tail报错Too many open files</h1><h2 id="问题描述-2"><span class="post-title-index">4.1. </span><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h2><p>执行tail命令，报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail: inotify cannot be used, reverting to polling: Too many open files</span><br></pre></td></tr></table></figure><h2 id="解决办法"><span class="post-title-index">4.2. </span><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>参考文档：</p><ul><li><a href="https://askubuntu.com/questions/299689/tail-inotify-cannot-be-used-reverting-to-polling-too-many-open-files">tail: inotify cannot be used, reverting to polling: Too many open files</a></li><li><a href="https://medium.com/@ivanermilov/how-to-fix-inotify-cannot-be-used-reverting-to-polling-too-many-open-files-bb1c1437dbf">How to fix: “inotify cannot be used, reverting to polling: Too many open files”</a></li></ul><p>1、修改 /etc/sysctl.conf 配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br></pre></td></tr></table></figure><p>写入如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fs.inotify.max_user_watches=1048576</span><br><span class="line">fs.inotify.max_user_instances=1048576</span><br></pre></td></tr></table></figure><p>2、重载配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文记录在编写Shell脚本时遇到的问题，备忘。&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="docker" scheme="https://www.voidking.com/categories/engineering/docker/"/>
    
    <category term="shell" scheme="https://www.voidking.com/categories/engineering/shell/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="docker" scheme="https://www.voidking.com/tags/docker/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
    <category term="crontab" scheme="https://www.voidking.com/tags/crontab/"/>
    
    <category term="好好学Shell" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Shell/"/>
    
  </entry>
  
  <entry>
    <title>好好学K8S：kubectl增强工具和替代工具</title>
    <link href="https://www.voidking.com/dev-kubectl-enhancements-and-alternatives/"/>
    <id>https://www.voidking.com/dev-kubectl-enhancements-and-alternatives/</id>
    <published>2024-03-23T08:00:00.000Z</published>
    <updated>2024-03-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><span class="post-title-index">1. </span><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>kubectl 在 Kubernetes 环境中发挥了关键的管理作用，但随着 Kubernetes 的复杂性增加，管理者可能需要更直观、更便捷的工具。</p><p>本文介绍一些可替代或补充 kubectl 的工具，可以分为命令行工具、GUI工具、GUI平台三类。<br>其中命令行工具和GUI工具是指适合个人使用的Kubernetes管理工具，GUI平台是指适合多人同时使用的Kubernetes管理系统。</p><ul><li>命令行工具：kube-shell、k9s、stern</li><li>GUI工具：k8slens、octant</li><li>GUI平台：kubesphere、rancher</li></ul><span id="more"></span><h1 id="命令行工具"><span class="post-title-index">2. </span><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h1><h2 id="kube-shell"><span class="post-title-index">2.1. </span><a href="#kube-shell" class="headerlink" title="kube-shell"></a>kube-shell</h2><p><a href="https://github.com/cloudnativelabs/kube-shell">kube-shell</a> 是一个增强的 Kubernetes shell，基于kubectl，增加了自动完成、内联文档和其他有用的功能，使得在交互式环境中更友好地使用 Kubernetes。</p><h2 id="k9s"><span class="post-title-index">2.2. </span><a href="#k9s" class="headerlink" title="k9s"></a>k9s</h2><p><a href="https://github.com/derailed/k9s">k9s</a> 提供了一个终端 UI 界面，以交互的方式对 Kubernetes 集群进行操作。它的操作方式类似 vim，可以快速浏览各种资源、实时查看日志等。</p><p>Linux中安装方法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/derailed/k9s/releases/download/v0.32.4/k9s_Linux_amd64.tar.gz</span><br><span class="line">tar -xzvf k9s_Linux_amd64.tar.gz k9s &amp;&amp; <span class="built_in">chmod</span> +x k9s &amp;&amp; <span class="built_in">mv</span> k9s /usr/bin </span><br></pre></td></tr></table></figure><p>使用k9s：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">k9s <span class="comment"># 使用默认 kubeconfig</span></span><br><span class="line">k9s --context ~/.kube/config <span class="comment"># 指定 kubeconfig</span></span><br></pre></td></tr></table></figure><p>刚打开k9s界面，点击enter可能会提示 no connection to cached dial ，需要稍等一会再次点击enter。</p><p>使用方法参考文档：</p><ul><li><a href="https://rainfd.com/post/19_k9s%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/">K9s简易教程</a></li><li><a href="https://k9scli.io/topics/commands/">k9s - Commands</a></li></ul><h2 id="stern"><span class="post-title-index">2.3. </span><a href="#stern" class="headerlink" title="stern"></a>stern</h2><p><a href="https://github.com/stern/stern">stern</a> 是一个 Kubernetes 的日志跟踪工具，它可以同时跟踪一个或多个 pod 的日志，支持颜色高亮、自定义模板、自动刷新等功能。</p><h1 id="GUI工具"><span class="post-title-index">3. </span><a href="#GUI工具" class="headerlink" title="GUI工具"></a>GUI工具</h1><h2 id="k8slens"><span class="post-title-index">3.1. </span><a href="#k8slens" class="headerlink" title="k8slens"></a>k8slens</h2><p><a href="https://github.com/lensapp/lens">k8slens（Lens）</a> 是一个具有丰富功能的 Kubernetes IDE，它可以直接运行在桌面环境中，为用户提供直观的图形化界面对 Kubernetes 集群进行管理。</p><h2 id="octant"><span class="post-title-index">3.2. </span><a href="#octant" class="headerlink" title="octant"></a>octant</h2><p><a href="https://octant.dev/">Octant</a> 是由 VMware 开发的一款 Kubernetes 辅助工具，它提供了一个 Web 界面，可以帮助理解 Kubernetes 工作负载和集群，支持自定义插件，增强其功能。</p><p>目前已经停止维护。</p><h1 id="GUI平台"><span class="post-title-index">4. </span><a href="#GUI平台" class="headerlink" title="GUI平台"></a>GUI平台</h1><h2 id="kubesphere"><span class="post-title-index">4.1. </span><a href="#kubesphere" class="headerlink" title="kubesphere"></a>kubesphere</h2><p><a href="https://kubesphere.io/zh/">KubeSphere</a> 是一个以 Kubernetes 为基础的开源平台，提供更高级的多租户服务、更友好的 API 和 UI、应用市场、DevOps、微服务管理等功能。</p><h2 id="rancher"><span class="post-title-index">4.2. </span><a href="#rancher" class="headerlink" title="rancher"></a>rancher</h2><p><a href="https://www.rancher.com/">Rancher</a> 是一个全功能的 Kubernetes 管理平台，它可以在任何基础设施上运行 Kubernetes，同时提供集群管理、应用管理、监控、日志、CI/CD、网络、存储等功能。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;kubectl 在 Kubernetes 环境中发挥了关键的管理作用，但随着 Kubernetes 的复杂性增加，管理者可能需要更直观、更便捷的工具。&lt;/p&gt;
&lt;p&gt;本文介绍一些可替代或补充 kubectl 的工具，可以分为命令行工具、GUI工具、GUI平台三类。&lt;br&gt;其中命令行工具和GUI工具是指适合个人使用的Kubernetes管理工具，GUI平台是指适合多人同时使用的Kubernetes管理系统。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令行工具：kube-shell、k9s、stern&lt;/li&gt;
&lt;li&gt;GUI工具：k8slens、octant&lt;/li&gt;
&lt;li&gt;GUI平台：kubesphere、rancher&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="k8s" scheme="https://www.voidking.com/categories/engineering/k8s/"/>
    
    
    <category term="k8s" scheme="https://www.voidking.com/tags/k8s/"/>
    
    <category term="好好学K8S" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6K8S/"/>
    
    <category term="kubectl" scheme="https://www.voidking.com/tags/kubectl/"/>
    
  </entry>
  
  <entry>
    <title>好好学Linux：Linux中拷贝硬盘</title>
    <link href="https://www.voidking.com/dev-linux-copy-disk/"/>
    <id>https://www.voidking.com/dev-linux-copy-disk/</id>
    <published>2024-03-23T08:00:00.000Z</published>
    <updated>2024-03-23T08:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="需求描述"><span class="post-title-index">1. </span><a href="#需求描述" class="headerlink" title="需求描述"></a>需求描述</h1><p>Linux主机中原本有一块数据盘 /dev/sdb，挂载到了 /data 目录，存储了大量数据。<br>现在新增了一块数据盘 /dev/sdc，想要把sdb的数据完全拷贝到sdc，然后用sdb替换sdc，这个需求该怎样处理？</p><span id="more"></span><h1 id="实现思路"><span class="post-title-index">2. </span><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h1><p>1、把sdb的数据拷贝到sdc<br>2、检查sdc数据<br>3、修改挂载配置，sdc替换sdb，重启主机</p><h1 id="拷贝硬盘全部数据"><span class="post-title-index">3. </span><a href="#拷贝硬盘全部数据" class="headerlink" title="拷贝硬盘全部数据"></a>拷贝硬盘全部数据</h1><h2 id="拷贝硬盘全部数据概述"><span class="post-title-index">3.1. </span><a href="#拷贝硬盘全部数据概述" class="headerlink" title="拷贝硬盘全部数据概述"></a>拷贝硬盘全部数据概述</h2><p>拷贝硬盘全部数据，有三种方法：</p><ul><li>使用cp命令。不推荐，因为cp不能断点续传，所以拷贝大量文件时如果出错会浪费时间重传。</li><li>使用rsync命令。备选，支持断点续传，但是如果存在大量小文件时拷贝速度会很慢。</li><li>使用dd命令。首选，拷贝整个磁盘的数据，速度非常快且数据完整。</li></ul><p>因此，这里选择使用dd命令来拷贝磁盘数据。</p><h2 id="dd命令拷贝数据"><span class="post-title-index">3.2. </span><a href="#dd命令拷贝数据" class="headerlink" title="dd命令拷贝数据"></a>dd命令拷贝数据</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/dev/sdc bs=64K conv=noerror,<span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li>if：input file，输入文件，这里就是要复制的源盘/dev/sdb。</li><li>of：output file，输出文件，这里就是要复制的目标盘/dev/sdc。</li><li>bs：block size，块大小，这里我们设置为64K。</li><li>conv：convert，转换选项，这里我们设置为noerror（读写出错不停止）和sync（输入输出不足块大小时，会用空字符补足）。</li></ul><p>dd命令默认的块大小是512字节，这意味着默认情况下，dd命令每次读取和写入的数据大小是512字节。如果我们的磁盘支持更大的块大小，那么增加块大小可以帮助提高数据复制的速度。在这个例子中，我们设定块大小为64K，这意味着dd命令每次读取和写入的数据大小是64K字节。</p><p>注意：在执行这个命令之前，确保/dev/sdc 没有被挂载并且没有其他程序正在使用。此外，这个操作可能会需要一些时间，需要耐心等待。</p><h2 id="查看dd进度"><span class="post-title-index">3.3. </span><a href="#查看dd进度" class="headerlink" title="查看dd进度"></a>查看dd进度</h2><p>dd命令在复制数据完成后会自动结束。有时候，dd命令可能会运行非常长的时间，此时可以通过向dd命令发送SIGUSR1信号来查看它当前的进度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">kill</span> -USR1 $(pgrep ^<span class="built_in">dd</span>)</span><br></pre></td></tr></table></figure><p>这条命令会找到dd命令的进程ID并向其发送SIGUSR1信号，这将导致dd命令打印出其当前的复制进度。</p><p>输出内容类似于：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6525616+0 records in</span><br><span class="line">6525616+0 records out</span><br><span class="line">427662770176 bytes (428 GB) copied, 3034.84 s, 141 MB/s</span><br></pre></td></tr></table></figure><p>这个输出中，6525616 指的是已经复制的块数量，块大小为64K（默认512），<code>6525616*64*1024 = 427662770176</code></p><h2 id="dd断点续传"><span class="post-title-index">3.4. </span><a href="#dd断点续传" class="headerlink" title="dd断点续传"></a>dd断点续传</h2><p>dd命令本身并不支持断点续传。如果执行 dd 命令过程中出现了中断，那么重新执行dd命令会从头开始复制，比较浪费时间。<br>但是，我们可以使用一些参数来模拟断点续传的功能。<br>skip 参数可以让 dd 在复制数据前跳过源文件/设备的一定数量的块，seek 参数可以让 dd 在开始写入数据前跳过目标文件/设备的一定数量的块。</p><p>假设我们确认已知的dd进度为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">6525616+0 records in</span><br><span class="line">6525616+0 records out</span><br><span class="line">427662770176 bytes (428 GB) copied, 3034.84 s, 141 MB/s</span><br></pre></td></tr></table></figure><p>那么，断点续传可以使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/dev/sdc bs=64K skip=6525616 seek=6525616 conv=noerror,<span class="built_in">sync</span></span><br></pre></td></tr></table></figure><h2 id="修改UUID"><span class="post-title-index">3.5. </span><a href="#修改UUID" class="headerlink" title="修改UUID"></a>修改UUID</h2><p>使用dd拷贝一个设备到另一个设备，那么设备的UUID也被同时复制过去。这将导致两个设备拥有相同的UUID，这样在一些情况下可能会引发问题，比如在/boot/grub/grub.cfg文件或者/etc/fstab里面用UUID来标识设备。</p><p>要修改一个文件系统的UUID，需要使用对应文件系统的工具。</p><p>查看UUID命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid /dev/sdc</span><br></pre></td></tr></table></figure><p>对于ext2，ext3，ext4文件系统，可以使用tune2fs命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tune2fs -U random /dev/sdc</span><br></pre></td></tr></table></figure><p>对于xfs文件系统，可以使用xfs_admin命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_admin -U generate /dev/sdc</span><br></pre></td></tr></table></figure><p>对于btrfs文件系统，可以使用btrfstune命令，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btrfstune -f -u /dev/sdc</span><br></pre></td></tr></table></figure><p>注意：上述所有命令在执行之前，需要先确保该设备已经被卸载。</p><h2 id="修改UUID报错问题"><span class="post-title-index">3.6. </span><a href="#修改UUID报错问题" class="headerlink" title="修改UUID报错问题"></a>修改UUID报错问题</h2><p>1、执行修改UUID的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_admin -U generate /dev/sdc</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ERROR: The filesystem has valuable metadata changes in a log which needs to</span><br><span class="line">be replayed.  Mount the filesystem to replay the log, and unmount it before</span><br><span class="line">re-running xfs_admin.  If you are unable to mount the filesystem, then use</span><br><span class="line">the xfs_repair -L option to destroy the log and attempt a repair.</span><br><span class="line">Note that destroying the log may cause corruption -- please attempt a mount</span><br><span class="line">of the filesystem before doing this.</span><br></pre></td></tr></table></figure><p>2、根据报错提示挂载磁盘，然后卸载磁盘。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /sdc</span><br><span class="line">mount /dev/sdc /sdc</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mount: wrong fs type, bad option, bad superblock on /dev/sdc,</span><br><span class="line">       missing codepage or helper program, or other error</span><br><span class="line"></span><br><span class="line">       In some cases useful info is found in syslog - try</span><br><span class="line">       dmesg | tail or so.</span><br></pre></td></tr></table></figure><p>3、尝试修复磁盘问题</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_repair -L /dev/sdc</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Phase 1 - find and verify superblock...</span><br><span class="line">Phase 2 - using internal log</span><br><span class="line">        - zero log...</span><br><span class="line">...</span><br><span class="line">Phase 7 - verify and correct link counts...</span><br><span class="line">Maximum metadata LSN (12:673358) is ahead of log (1:2).</span><br><span class="line">Format log to cycle 15.</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>4、再次尝试修改UUID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_admin -U generate /dev/sdc</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Clearing log and setting UUID</span><br><span class="line">writing all SBs</span><br><span class="line">new UUID = 25b43fed-781f-419e-b5a9-273042c7f1e1</span><br></pre></td></tr></table></figure><p>5、尝试挂载和卸载</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount /dev/sdc /sdc</span><br><span class="line"><span class="built_in">ls</span> -l /sdc</span><br><span class="line">umount /sdc</span><br></pre></td></tr></table></figure><h1 id="检查sdc数据（可选）"><span class="post-title-index">4. </span><a href="#检查sdc数据（可选）" class="headerlink" title="检查sdc数据（可选）"></a>检查sdc数据（可选）</h1><p>1、挂载 sdc</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /sdc</span><br><span class="line">mount /dev/sdc /sdc</span><br></pre></td></tr></table></figure><p>2、比较数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rsync -P -avz /data/ /sdc</span><br></pre></td></tr></table></figure><h1 id="修改挂载配置"><span class="post-title-index">5. </span><a href="#修改挂载配置" class="headerlink" title="修改挂载配置"></a>修改挂载配置</h1><p>1、查看 sdc UUID</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blkid /dev/sdc</span><br></pre></td></tr></table></figure><p>2、修改 /etc/fstab 配置</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID=xxx /data xfs  defaults 0 0</span><br></pre></td></tr></table></figure><p>其中 xxx 修改为 sdc 的 UUID</p><p>3、重启主机 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;需求描述&quot;&gt;&lt;a href=&quot;#需求描述&quot; class=&quot;headerlink&quot; title=&quot;需求描述&quot;&gt;&lt;/a&gt;需求描述&lt;/h1&gt;&lt;p&gt;Linux主机中原本有一块数据盘 /dev/sdb，挂载到了 /data 目录，存储了大量数据。&lt;br&gt;现在新增了一块数据盘 /dev/sdc，想要把sdb的数据完全拷贝到sdc，然后用sdb替换sdc，这个需求该怎样处理？&lt;/p&gt;</summary>
    
    
    
    <category term="engineering" scheme="https://www.voidking.com/categories/engineering/"/>
    
    <category term="storage" scheme="https://www.voidking.com/categories/engineering/storage/"/>
    
    <category term="devops" scheme="https://www.voidking.com/categories/engineering/devops/"/>
    
    <category term="linux" scheme="https://www.voidking.com/categories/engineering/linux/"/>
    
    <category term="troubleshooting" scheme="https://www.voidking.com/categories/engineering/troubleshooting/"/>
    
    
    <category term="linux" scheme="https://www.voidking.com/tags/linux/"/>
    
    <category term="好好学Linux" scheme="https://www.voidking.com/tags/%E5%A5%BD%E5%A5%BD%E5%AD%A6Linux/"/>
    
    <category term="问题排查" scheme="https://www.voidking.com/tags/%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    
    <category term="shell" scheme="https://www.voidking.com/tags/shell/"/>
    
  </entry>
  
</feed>
