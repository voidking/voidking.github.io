<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://www.voidking.com").hostname,root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1,cdn:{enable:!0,url:"//cdn.jsdelivr.net/gh/voidking/voidking.github.io/search.xml"}},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="理论没有找到关于图像倾斜矫正的综述性文献，那就自己整理一下吧。 图像倾斜可以分为两种情况，一种是平面倾斜，这种情况下拍照设备与试卷平行，拍出来的图像只需要进行旋转即可完成矫正；另一种是Z轴倾斜，这种情况下拍照设备与试卷存在一定的角度，拍出来的图像要先进行透视变换，然后再进行旋转等操作才可以完成矫正。 图像倾斜矫正关键在于根据图像特征自动检测出图像倾斜方向和倾斜角度。 对于平面倾斜，先利用边缘（轮廓"><meta property="og:type" content="article"><meta property="og:title" content="图像倾斜矫正"><meta property="og:url" content="https://www.voidking.com/dev-gp-image-tilt-correction/index.html"><meta property="og:site_name" content="好好学习的郝"><meta property="og:description" content="理论没有找到关于图像倾斜矫正的综述性文献，那就自己整理一下吧。 图像倾斜可以分为两种情况，一种是平面倾斜，这种情况下拍照设备与试卷平行，拍出来的图像只需要进行旋转即可完成矫正；另一种是Z轴倾斜，这种情况下拍照设备与试卷存在一定的角度，拍出来的图像要先进行透视变换，然后再进行旋转等操作才可以完成矫正。 图像倾斜矫正关键在于根据图像特征自动检测出图像倾斜方向和倾斜角度。 对于平面倾斜，先利用边缘（轮廓"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://cdn.voidking.com//imgs/gp-image-tilt-correction/gray.jpg?imageView2/0/w/700"><meta property="og:image" content="http://cdn.voidking.com//imgs/gp-image-tilt-correction/canny.jpg?imageView2/0/w/700"><meta property="og:image" content="http://cdn.voidking.com//imgs/gp-image-tilt-correction/edge.jpg?imageView2/0/w/700"><meta property="og:image" content="http://cdn.voidking.com//imgs/gp-image-tilt-correction/right.jpg?imageView2/0/w/700"><meta property="og:image" content="http://cdn.voidking.com//imgs/gp-image-tilt-correction/init.jpg?imageView2/0/h/700"><meta property="og:image" content="http://cdn.voidking.com//imgs/gp-image-tilt-correction/perspective.jpg?imageView2/0/h/700"><meta property="article:published_time" content="2019-01-07T09:00:00.000Z"><meta property="article:modified_time" content="2019-01-07T09:00:00.000Z"><meta property="article:author" content="好好学习的郝"><meta property="article:tag" content="python"><meta property="article:tag" content="毕设"><meta property="article:tag" content="opencv"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://cdn.voidking.com//imgs/gp-image-tilt-correction/gray.jpg?imageView2/0/w/700"><link rel="canonical" href="https://www.voidking.com/dev-gp-image-tilt-correction/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>图像倾斜矫正 | 好好学习的郝</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="好好学习的郝" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">好好学习的郝</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">好好学习，天天向上！</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/voidking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.voidking.com/dev-gp-image-tilt-correction/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="好好学习的郝"><meta itemprop="description" content="学而不思则罔，思而不学则殆！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="好好学习的郝"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> 图像倾斜矫正</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-01-07 09:00:00" itemprop="dateCreated datePublished" datetime="2019-01-07T09:00:00+00:00">2019-01-07</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/" itemprop="url" rel="index"><span itemprop="name">engineering</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h1><p>没有找到关于图像倾斜矫正的综述性文献，那就自己整理一下吧。</p><p>图像倾斜可以分为两种情况，一种是平面倾斜，这种情况下拍照设备与试卷平行，拍出来的图像只需要进行旋转即可完成矫正；另一种是Z轴倾斜，这种情况下拍照设备与试卷存在一定的角度，拍出来的图像要先进行透视变换，然后再进行旋转等操作才可以完成矫正。</p><p>图像倾斜矫正关键在于根据图像特征自动检测出图像倾斜方向和倾斜角度。</p><p>对于平面倾斜，先利用边缘（轮廓）检测算法算法找到图像的边界，然后利用<a target="_blank" rel="noopener" href="https://blog.csdn.net/corilei/article/details/80560608">Radon变换法（基于投影的方法）</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/feilong_csdn/article/details/81586322">Hough变换法</a>、线性回归法等找到倾斜角度，然后再利用<a target="_blank" rel="noopener" href="http://www.opencv.org.cn/opencvdoc/2.3.2/html/doc/tutorials/imgproc/imgtrans/warp_affine/warp_affine.html">仿射变换</a>进行旋转。</p><p>对于Z轴倾斜，先利用边缘（轮廓）检测算法找到图像的边界，然后利用<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiaowei_cqu/article/details/26471527">透视变换</a>把视平面上的点投影到现实平面，然后再利用仿射变换进行旋转。</p><span id="more"></span><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h2 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: utf-<span class="number">8</span> -*-</span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">img = cv2.<span class="built_in">imread</span>(<span class="string">&#x27;../image/tilt.jpg&#x27;</span>)</span><br><span class="line">GrayImage = cv2.<span class="built_in">cvtColor</span>(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">CannyImage = cv2.<span class="built_in">Canny</span>(GrayImage,<span class="number">50</span>, <span class="number">150</span>, apertureSize=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">cv2.<span class="built_in">imshow</span>(<span class="string">&#x27;gray&#x27;</span>,GrayImage)</span><br><span class="line">cv2.<span class="built_in">imshow</span>(<span class="string">&#x27;canny&#x27;</span>,CannyImage)</span><br><span class="line">cv2.<span class="built_in">waitKey</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="http://cdn.voidking.com//imgs/gp-image-tilt-correction/gray.jpg?imageView2/0/w/700"><br><img src="http://cdn.voidking.com//imgs/gp-image-tilt-correction/canny.jpg?imageView2/0/w/700"></p><p><code>edges=cv.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]])</code>参数说明：</p><ul><li>image：输入图像。</li><li>threshold1：最小阈值。</li><li>threshold2：最大阈值。</li><li>apertureSize：Sobel算子的孔径大小。</li></ul><p>更多内容参考：</p><ul><li><a target="_blank" rel="noopener" href="https://docs.opencv.org/master/dd/d1a/group__imgproc__feature.html#ga04723e007ed888ddf11d9ba04e2232de">OpenCV Canny</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/sunny2038/article/details/9202641">Canny边缘检测</a></li><li><a target="_blank" rel="noopener" href="https://blog.csdn.net/mingtian715/article/details/53343680">基于Sobel和Canny边缘检测</a></li><li><a target="_blank" rel="noopener" href="http://python.jobbole.com/85253/">Python-OpenCV 处理图像（五）：图像中边界和轮廓检测</a></li></ul><p>以上代码，调用了OpenCV中的canny方法找到了边缘，但是，文字的边缘也被显示出来了。那么，怎么去掉文字边缘，只要长方形框的边缘呢？OpenCV也提供了方法，使用findContours来查找轮廓，使用drawContours来绘制轮廓。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line"></span><br><span class="line">img = cv2.imread(&#x27;../image/tilt.jpg&#x27;)</span><br><span class="line">GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line">CannyImage = cv2.Canny(GrayImage,50, 150, apertureSize=3)</span><br><span class="line">ret,BinImage=cv2.threshold(CannyImage,127,255,cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line">_, contours, _= cv2.findContours(BinImage, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line"></span><br><span class="line">cv2.imshow(&#x27;bin&#x27;,BinImage)</span><br><span class="line">cv2.drawContours(img, contours, -1, (0,255, 0), 1)</span><br><span class="line">cv2.imshow(&#x27;edge&#x27;,img)</span><br><span class="line">cv2.waitKey(0)</span><br></pre></td></tr></table></figure><p><img src="http://cdn.voidking.com//imgs/gp-image-tilt-correction/edge.jpg?imageView2/0/w/700"></p><p><code>contours, hierarchy = cv.findContours(image, mode, method[, contours[, hierarchy[, offset]]])</code>参数说明：</p><ul><li>image：输入图像，二值化图像。</li><li>mode：轮廓检索模式，请参阅<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/d3/dc0/group__imgproc__shape.html#ga819779b9857cc2f8601e6526a3a5bc71">RetrievalModes</a>。</li><li>method：轮廓近似方法，请参见<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/d3/dc0/group__imgproc__shape.html#ga4303f45752694956374734a03c54d5ff">ContourApproximationModes</a>。</li></ul><p>如果按照<a target="_blank" rel="noopener" href="https://docs.opencv.org/master/d3/dc0/group__imgproc__shape.html#gadf1ad6a0b82947fa1fe3c3d497f260e0">官方文档</a>调用，会报错，参考<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/25504964/opencv-python-valueerror-too-many-values-to-unpack">ValueError: too many values to unpack</a>解决。实际上，这是因为opencv3之后该函数的返回值有三个，而官方文档有多个版本，比如<a target="_blank" rel="noopener" href="https://docs.opencv.org/3.4/d3/dc0/group__imgproc__shape.html#ga17ed9f5d79ae97bd4c7cf18403e1689a">这一版</a>中就说明了有三个参数。</p><h2 id="计算倾斜角"><a href="#计算倾斜角" class="headerlink" title="计算倾斜角"></a>计算倾斜角</h2><p>以上，已经找到了图片的边缘，接下来计算倾斜角度。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">import</span> numpy as np</span><br><span class="line"><span class="attribute">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="attribute">img</span> = cv2.imread(&#x27;../image/tilt.jpg&#x27;)</span><br><span class="line"><span class="attribute">GrayImage</span> = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)</span><br><span class="line"><span class="attribute">CannyImage</span> = cv2.Canny(GrayImage,<span class="number">50</span>, <span class="number">150</span>, apertureSize=<span class="number">3</span>)</span><br><span class="line"><span class="attribute">ret</span>,BinImage=cv2.threshold(CannyImage,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line"></span><br><span class="line"><span class="attribute">lines</span> = cv2.HoughLinesP(BinImage, <span class="number">1</span>, np.pi / <span class="number">180</span>, <span class="number">160</span>, minLineLength=<span class="number">200</span>, maxLineGap=<span class="number">180</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 寻找长度最长的线</span></span><br><span class="line"><span class="attribute">distance</span> =<span class="meta"> []</span></span><br><span class="line"><span class="attribute">for</span> line in lines:</span><br><span class="line">    <span class="attribute">x1</span>, y1, x2, y2 = line[<span class="number">0</span>]</span><br><span class="line">    <span class="attribute">dis</span> = np.sqrt(pow((x2 - x1), <span class="number">2</span>) + pow((y2 - y1), <span class="number">2</span>))</span><br><span class="line">    <span class="attribute">distance</span>.append(dis)</span><br><span class="line"><span class="attribute">max_dis_index</span> = distance.index(max(distance))</span><br><span class="line"><span class="attribute">max_line</span> = lines[max_dis_index]</span><br><span class="line"><span class="attribute">x1</span>, y1, x2, y2 = max_line[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取旋转角度</span></span><br><span class="line"><span class="attribute">angle</span> = cv2.fastAtan2((y2 - y1), (x2 - x1))</span><br><span class="line"><span class="attribute">print</span>(angle)</span><br></pre></td></tr></table></figure><p>以上代码，很尴尬，并不是利用findContours的结果进行计算的，而是一个新的思路。为什么没有使用contours？因为不会写代码。。。如果要继续findContours思路，那么可以参考<a target="_blank" rel="noopener" href="https://www.cnblogs.com/skyfsm/p/6902524.html">图像矫正技术深入探讨</a>进行改写。</p><h2 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h2><p>求出倾斜角度之后，利用仿射变换进行旋转。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算图片中心</span></span><br><span class="line"><span class="attribute">centerpoint</span> = (img.shape[<span class="number">1</span>]/<span class="number">2</span>,img.shape[<span class="number">0</span>]/<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 获取旋转矩阵</span></span><br><span class="line"><span class="attribute">rotate_mat</span> = cv2.getRotationMatrix2D(centerpoint,angle,<span class="number">1</span>.<span class="number">0</span>)</span><br><span class="line"><span class="attribute">correct_image</span> = cv2.warpAffine(img,rotate_mat,(img.shape[<span class="number">1</span>],img.shape[<span class="number">0</span>]),borderValue =(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>) )</span><br><span class="line"></span><br><span class="line"><span class="attribute">cv2</span>.imshow(&#x27;right&#x27;,correct_image)</span><br><span class="line"><span class="attribute">cv2</span>.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="http://cdn.voidking.com//imgs/gp-image-tilt-correction/right.jpg?imageView2/0/w/700"></p><h2 id="Z轴倾斜"><a href="#Z轴倾斜" class="headerlink" title="Z轴倾斜"></a>Z轴倾斜</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">import cv2</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line">def <span class="built_in">gray_and_bin</span>(init_img):</span><br><span class="line">    gray_img = cv2.<span class="built_in">cvtColor</span>(init_img, cv2.COLOR_BGR2GRAY)</span><br><span class="line">    blur_img = cv2.<span class="built_in">GaussianBlur</span>(gray_img, (<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>)                     # 高斯模糊去噪（设定卷积核大小影响效果）</span><br><span class="line">    canny_img = cv2.<span class="built_in">Canny</span>(blur_img, <span class="number">35</span>, <span class="number">189</span>, apertureSize=<span class="number">3</span>)</span><br><span class="line">    _, bin_img = cv2.<span class="built_in">threshold</span>(canny_img, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)  # 设定阈值<span class="number">165</span>（阈值影响开闭运算效果）</span><br><span class="line">    return gray_img, bin_img</span><br><span class="line"></span><br><span class="line">def <span class="built_in">points_and_box</span>(init_img, bin_img):</span><br><span class="line">    image, contours, hierarchy = cv2.<span class="built_in">findContours</span>(bin_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)</span><br><span class="line">    c = <span class="built_in">sorted</span>(contours, key=cv2.contourArea, reverse=True)[<span class="number">0</span>]   # 计算最大轮廓的旋转包围盒</span><br><span class="line">    rect = cv2.<span class="built_in">minAreaRect</span>(c)                                    # 获取包围盒（中心点，宽高，旋转角度）</span><br><span class="line">    box = np.<span class="built_in">int0</span>(cv2.<span class="built_in">boxPoints</span>(rect))                           # box</span><br><span class="line">    # box_img = cv2.<span class="built_in">drawContours</span>(init_img.<span class="built_in">copy</span>(), [box], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">    # cv2.<span class="built_in">imshow</span>(<span class="string">&#x27;box&#x27;</span>,box_img)</span><br><span class="line"></span><br><span class="line">    empty_img = np.<span class="built_in">zeros</span>(init_img.shape, np.uint8) # 创建空白图像</span><br><span class="line">    empty_img[...] = <span class="number">255</span> # 设置白底</span><br><span class="line">    # cv2.<span class="built_in">imshow</span>(<span class="string">&#x27;test&#x27;</span>,empty_img)</span><br><span class="line">    cv2.<span class="built_in">drawContours</span>(empty_img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>), <span class="number">1</span>) # 在空白图像上绘制试卷轮廓</span><br><span class="line">    # cv2.<span class="built_in">imshow</span>(<span class="string">&#x27;edge&#x27;</span>, empty_img)</span><br><span class="line">    _, bin_img2 = <span class="built_in">gray_and_bin</span>(empty_img)</span><br><span class="line">    # cv2.<span class="built_in">imshow</span>(<span class="string">&#x27;bin&#x27;</span>,bin_img2)</span><br><span class="line">    lines = cv2.<span class="built_in">HoughLinesP</span>(bin_img2, <span class="number">1</span>, np.pi / <span class="number">180</span>, <span class="number">100</span>, minLineLength=<span class="number">200</span>, maxLineGap=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    for i in <span class="built_in">range</span>(<span class="built_in">int</span>(np.<span class="built_in">size</span>(lines) / <span class="number">4</span>)):</span><br><span class="line">        for x1, y1, x2, y2 in lines[i]:</span><br><span class="line">            cv2.<span class="built_in">line</span>(empty_img, (x1, y1), (x2, y2), (<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">1</span>)</span><br><span class="line">    # cv2.<span class="built_in">imshow</span>(<span class="string">&#x27;line&#x27;</span>,empty_img)</span><br><span class="line"></span><br><span class="line">    points = None</span><br><span class="line">    if <span class="built_in">len</span>(contours) &gt; <span class="number">0</span>:</span><br><span class="line">        contours = <span class="built_in">sorted</span>(contours, key=cv2.contourArea, reverse=True)</span><br><span class="line">        for c in contours:</span><br><span class="line">            peri = cv2.<span class="built_in">arcLength</span>(c, True)  # 轮廓按大小降序排序</span><br><span class="line">            approx = cv2.<span class="built_in">approxPolyDP</span>(c, <span class="number">0.02</span> * peri, True)  # 获取近似的轮廓</span><br><span class="line">            if <span class="built_in">len</span>(approx) == <span class="number">4</span>:  # 近似轮廓有四个顶点</span><br><span class="line">                points = approx</span><br><span class="line">                break</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;piont[0]&#x27;</span>, points[<span class="number">0</span>]) # 左下</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;piont[1]&#x27;</span>, points[<span class="number">1</span>]) # 左上</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;piont[2]&#x27;</span>, points[<span class="number">2</span>]) # 右上</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;piont[3]&#x27;</span>, points[<span class="number">3</span>]) # 右下</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;box[0]:&#x27;</span>, box[<span class="number">0</span>]) # 右下</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;box[1]:&#x27;</span>, box[<span class="number">1</span>]) # 右上</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;box[2]:&#x27;</span>, box[<span class="number">2</span>]) # 左上</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;box[3]:&#x27;</span>, box[<span class="number">3</span>]) # 左下</span><br><span class="line"></span><br><span class="line">    return points,box</span><br><span class="line"></span><br><span class="line">def <span class="built_in">perspective_transform</span>(box,points,init_img):</span><br><span class="line"></span><br><span class="line">    # 原图中试卷的四个顶点</span><br><span class="line">    pts1 = np.<span class="built_in">float32</span>([points[<span class="number">0</span>], points[<span class="number">1</span>], points[<span class="number">2</span>], points[<span class="number">3</span>]])</span><br><span class="line">    # box中的四个顶点</span><br><span class="line">    pts2 = np.<span class="built_in">float32</span>([box[<span class="number">3</span>], box[<span class="number">2</span>], box[<span class="number">1</span>], box[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line">    # 生成透视变换矩阵；进行透视变换</span><br><span class="line">    M = cv2.<span class="built_in">getPerspectiveTransform</span>(pts1,pts2)</span><br><span class="line">    result_img = cv2.<span class="built_in">warpPerspective</span>(init_img, M, (<span class="number">1200</span>, <span class="number">1300</span>))</span><br><span class="line"></span><br><span class="line">    return result_img</span><br><span class="line"></span><br><span class="line">if __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    init_img = cv2.<span class="built_in">imread</span>(<span class="string">&#x27;../image/init.jpg&#x27;</span>)</span><br><span class="line">    gray_img, bin_img = <span class="built_in">gray_and_bin</span>(init_img)</span><br><span class="line">    points, box = <span class="built_in">points_and_box</span>(init_img,bin_img)</span><br><span class="line">    result_img = <span class="built_in">perspective_transform</span>(box,points,init_img)</span><br><span class="line">    # cv2.<span class="built_in">imshow</span>(<span class="string">&#x27;init&#x27;</span>,init_img)</span><br><span class="line">    cv2.<span class="built_in">namedWindow</span>(<span class="string">&#x27;result&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    cv2.<span class="built_in">resizeWindow</span>(<span class="string">&#x27;result&#x27;</span>, <span class="number">640</span>, <span class="number">1200</span>)</span><br><span class="line">    cv2.<span class="built_in">imshow</span>(<span class="string">&#x27;result&#x27;</span>, result_img)</span><br><span class="line">    # cv2.<span class="built_in">imwrite</span>(<span class="string">&#x27;result.jpg&#x27;</span>,result_img)</span><br><span class="line">    cv2.<span class="built_in">waitKey</span>(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><img src="http://cdn.voidking.com//imgs/gp-image-tilt-correction/init.jpg?imageView2/0/h/700"></p><p><img src="http://cdn.voidking.com//imgs/gp-image-tilt-correction/perspective.jpg?imageView2/0/h/700"><br>以上结果，并不是很理想。透视矫正完成了，但是存在黑边白边，试卷长宽比例也有问题，也没有进行平面倾斜矫正。就先这样吧，作为一个小白，做成这样已经很不容易了。</p><p>更多内容参考<a target="_blank" rel="noopener" href="https://github.com/joece/Image-Correction">利用opencv库，实现校正图片中的A4纸</a>、<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40855366/article/details/81177176">用numpy+OpenCV快速实现矫正图像的功能</a>、<a target="_blank" rel="noopener" href="https://www.codetd.com/article/3777795">OpenCV—python图像矫正</a>和<a target="_blank" rel="noopener" href="https://blog.csdn.net/MrCharles/article/details/73739693">对倾斜的图像进行修正——基于opencv透视变换</a>。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>图像倾斜矫正这部分，是图像预处理中的一个难点。以上，虽然实现了基本的图像倾斜矫正算法，但是算法原理还需要进一步学习。而且，上面的代码中使用的图片都是理想的，干扰很小，而实际拍摄的图片，除了目标物体（试卷），还会出现其他物体，比如签字笔文具盒等等。所以，后续还需要考虑其他物体的干扰。</p><p>另外，发现OpenCV成为了开发过程中的瓶颈，想要实现一些功能，每次都要求助于百度谷歌。因此，必须找时间系统学习一下OpenCV。</p><h1 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h1><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/polly333/p/7238197.html">图像矫正原理说明</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/polly333/p/7240475.html">图像矫正-基于opencv实现</a></p><p><a target="_blank" rel="noopener" href="http://jeffpu.github.io/2017/06/25/%E5%88%A9%E7%94%A8%E5%8C%85%E5%9B%B4%E8%BD%AE%E5%BB%93%E5%92%8C%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2%E8%BF%9B%E8%A1%8C%E5%9B%BE%E5%83%8F%E5%80%BE%E6%96%9C%E6%A0%A1%E6%AD%A3/">利用包围轮廓和仿射变换进行图像倾斜校正</a></p><p><a target="_blank" rel="noopener" href="http://jeffpu.github.io/2017/07/02/%E5%AF%B9Z%E8%BD%B4%E5%80%BE%E6%96%9C%E7%9A%84%E5%9B%BE%E5%83%8F%E8%BF%9B%E8%A1%8C%E6%A0%A1%E6%AD%A3-%E5%9F%BA%E4%BA%8EOpenCV%E9%80%8F%E8%A7%86%E5%8F%98%E6%8D%A2/">对Z轴倾斜的图像进行校正–基于OpenCV透视变换</a></p><p><a target="_blank" rel="noopener" href="http://johnhany.net/2013/11/dft-based-text-rotation-correction/">OpenCV实现基于傅里叶变换的旋转文本校正</a></p><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36387683/article/details/80539635">Python+OpenCV实现旋转文本校正</a></p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 好好学习的郝</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.voidking.com/dev-gp-image-tilt-correction/" title="图像倾斜矫正">https://www.voidking.com/dev-gp-image-tilt-correction/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！源站会及时更新知识点及修正错误，阅读体验也更好。欢迎分享，欢迎收藏~</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/python/" rel="tag"># python</a> <a href="/tags/%E6%AF%95%E8%AE%BE/" rel="tag"># 毕设</a> <a href="/tags/opencv/" rel="tag"># opencv</a></div><div class="post-nav"><div class="post-nav-item"><a href="/dev-gp-image-denoise/" rel="prev" title="图像去噪"><i class="fa fa-chevron-left"></i> 图像去噪</a></div><div class="post-nav-item"> <a href="/dev-hexo-baidustatistic/" rel="next" title="Hexo添加百度统计">Hexo添加百度统计<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODU3Mi8xNTEwMA=="></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%90%86%E8%AE%BA"><span class="nav-number">1.</span> <span class="nav-text">理论</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E8%B7%B5"><span class="nav-number">2.</span> <span class="nav-text">实践</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%B9%E7%BC%98%E6%A3%80%E6%B5%8B"><span class="nav-number">2.1.</span> <span class="nav-text">边缘检测</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E5%80%BE%E6%96%9C%E8%A7%92"><span class="nav-number">2.2.</span> <span class="nav-text">计算倾斜角</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BF%E5%B0%84%E5%8F%98%E6%8D%A2"><span class="nav-number">2.3.</span> <span class="nav-text">仿射变换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Z%E8%BD%B4%E5%80%BE%E6%96%9C"><span class="nav-number">2.4.</span> <span class="nav-text">Z轴倾斜</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%90%8E%E8%AE%B0"><span class="nav-number">3.</span> <span class="nav-text">后记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B9%A6%E7%AD%BE"><span class="nav-number">4.</span> <span class="nav-text">书签</span></a></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="好好学习的郝" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">好好学习的郝</p><div class="site-description" itemprop="description">学而不思则罔，思而不学则殆！</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">645</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">242</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:voidking@qq.com" title="E-Mail → mailto:voidking@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://github.com/voidking" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/voidking" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/voidking" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i> Zhihu</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 – <span itemprop="copyrightYear">2023</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">好好学习的郝</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="footer-beian"> <a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备14021030号</a>&nbsp;|&nbsp; <img src="/images/beian.png" alt=""> <a target="_blank" href="http://www.beian.gov.cn/">苏公网安备 32032202000223号</a></div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={iconStyle:"box",boxForm:"horizontal",position:"bottomCenter",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={iconStyle:"box",boxForm:"horizontal",position:"topRight",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-float",flOptions)</script><script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  // window.livereOptions = {
  //   refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  // };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>