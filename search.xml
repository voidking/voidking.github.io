<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>64位Oracle11gR2无法启动sqldeveloper</title>
    <url>/dev-64bit-oracle-r2-cannot-start-sqldeveloper/</url>
    <content><![CDATA[详细问题描述安装好Oracle11gR2之后，启动SOL Developer：开始，所有程序，Oracle-OraDb11g_home1，应用程序开发，SQL Developer。第一次使用，需要选择与Oracle配套安装的jave.exe的路径，郝同学的安装路径为D:\Oracle\dbhome\jdk\bin\java.exe。此时，错误出现了，Unable to find a java Virtual Machineto point to a location of a java virtual machine,please refer to the oracle9i Jdeveloper Install guide(jdev\install.html)


解决思路经百度，原来Oracle在制造64位版的时候没注意Oracle11gR2所带的SQL Developer是1.5.5.59.69版，不支持64位版的JDK，恰好64位Oracle带的JDK是64位的。
知道了这个就好办了，下载安装一个32位的jdk，重新设置一下路径。
我的实际操作在使用32位Oracle的小伙伴那里，从dbhome目录下，把整个jdk文件夹拷贝出来，重命名为jdk32。拷贝到自己电脑上的dbhome文件夹下。然后，打开sqldeveloper.conf（路径为D:\Oracle\dbhome\sqldeveloper\sqldeveloper\bin\sqldeveloper.conf），修改SetJavaHome D:\Oracle\dbhome\jdk，为SetJavaHome D:\Oracle\dbhome\jdk32。至此，SQL Developer已经可以正常使用了。
但是，初始的开始菜单中的SQL Developer，链接到的是一个bat文件，这个bat文件，又打开了sqldeveloper.exe。郝同学窃以为此步画蛇添足，而且打开了两个窗口，让我很不爽。于是，郝同学果断删掉了开始菜单中的SQL Developer这个超链，然后右击Oracle-OraDb11g_home1下的应用程序开发，属性，复制下位置，打开此位置（C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Oracle - OraDb11g_home1），进入应用程序开发文件夹。然后，把sqldeveloper.exe的快捷方式拷贝进刚才打开的应用程序开发文件夹。
题外记Oracle11g的安装包压缩文件有两个，win64_11gR2_database_1of2.zip和win64_11gR2_database_2of2.zip，安装时，要把它们解压到同一个文件夹。解压完成，点击setup.exe，根据喜好设置一下，等待一会儿就安装成功了。
当年，第一次接触Oracle，使用的是Oracle10g，各种安装报错，泪流满面。年轻不懂事，不止安装了database，还安装了client。想想真是多余，用来学习，安装database就够了，咱又不连接远程服务器。哪怕连接远程服务器，使用database里的工具也足够了，比如sqldeveloper。当年，还独立安装了一款PL/SQL Developer，解决完各种报错，微微一笑，这个工具真不错！如今，郝同学会毫不犹豫地会选择database里的自带工具！一言以蔽之，Oracle的安装和使用更简单了。（侧面反映了郝同学对于Oracle的使用更加得心应手，哇哈哈哈）
参考文档http://caogenit.com/caogenxueyuan/yingyongfangxiang/shujuku/2343.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>绝对定位居中布局</title>
    <url>/dev-absolute-center-layout/</url>
    <content><![CDATA[前言绝对定位并且居中显示，在开发中经常用到。总结了一下这种布局的三种方法，备忘。
方法一position: absolute;top: 0;left: 0;right: 0;bottom: 0;margin: auto;width: 82%;height: 40%;



方法二position: absolute;left: 50%; top: 50%;margin-top: -20%;margin-left: -41%;width: 82%;height: 40%;

方法三position: absolute;left: 50%; top: 50%;transform: translate(-50%, -50%);    /* 50%为自身尺寸的一半 */margin: auto;

后记以上三种绝对定位居中布局方法，同样适用于固定定位，即position:fixed;，只不过是相对的容器变成了浏览器。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>蚁群算法</title>
    <url>/dev-aco/</url>
    <content><![CDATA[来龙去脉知识工程这门课，主要讲三类算法：演化计算、群智能计算和神经计算。
演化计算，包括遗传算法、遗传规划、进化策略和进化规划。群智能计算，包括蚁群算法和粒子群算法。神经计算，包括人工神经网络和深度学习神经网络。
本文，主要介绍一下群智能计算中的蚁群算法。


什么是蚁群算法？蚁群算法（ant colony optimization， ACO），又称蚂蚁算法，是一种用来在图中寻找优化路径的机率型算法。它由Marco Dorigo于1992年在他的博士论文中提出，其灵感来源于蚂蚁在寻找食物过程中发现路径的行为。蚁群算法是一种模拟进化算法，初步的研究表明该算法具有许多优良的性质，并且现在已用于我们生活的方方面面。
主要内容基本概念（最好举例说明）、蚁群算法描述、蚁群算法实例、蚁群算法特点等。（细节介绍，通常20分钟左右）
应用领域利用文献法来总结蚁群算法各种领域的应用现状，把你阅读的文献（至少3篇）提前3天发到云盘中. （重点内容介绍，通常讲解20分钟左右），比如，a)蚁群算法具体如何实现的？b)性能如何？存在怎样的问题？改进方向如何？c)在哪些领域的哪些方面应用了蚁群算法？
蚁群算法实现蚂蚁在运动过程中，会留下一种称为信息素的东西，并且会随着移动的距离，播散的信息素越来越少，所以往往在家或者食物的周围，信息素的浓度是最强的，而蚂蚁自身会根据信息素去选择方向，当然信息素越浓，被选择的概率也就越大，并且信息素本身具有一定的挥发作用。蚂蚁的运动过程可以简单归纳如下：
1、当周围没有信息素指引时，蚂蚁的运动具有一定的惯性，并有一定的概率选择其他方向。2、当周围有信息素的指引时，按照信息素的浓度强度概率性的选择运动方向。3、找食物时，蚂蚁留下家相关的A信息素，找家时，蚂蚁留下食物相关的B信息素，并随着移动距离的增加，洒播的信息素越来越少。4、随着时间推移，信息素会自行挥发。
一个简单的例子，如果现在有两条通往食物的路径，一条较长路径A，一条较短路径B，虽然刚开始A，B路径上都有蚂蚁，又因为B比A短，蚂蚁通过B花费的时间较短，随着时间的推移和信息素的挥发，逐渐的B上的信息素浓度会强于A，这时候因为B的浓度比A强，越来越多的蚂蚁会选择B，而这时候B上的浓度只会越来越强。如果蚂蚁一开始只在A上呢，注意蚂蚁的移动具有一定小概率的随机性，所以当一部分蚂蚁找到B时，随着时间的推移，蚂蚁会收敛到B上，从而可以跳出局部最优。
性能、问题和改进问题当蚂蚁在一条路径上觅食很久时，再放置一个近的食物基本没有效果。可以理解为当一只蚂蚁找到一条路径时，过了很久的时间，大多数蚂蚁都选择了这条路径，就在这时候，突然有一只蚂蚁找到了较近的食物，但因为时间过得太久，两条路径上浓度相差太大（浓度越大，被选择的概率就越大），整个系统基本已经停滞了，陷入了局部最优。所以简单的蚂蚁系统是存在一些问题的，如：
1、搜索到一定程度，会出现停滞状态，陷入局部最优的情况。2、盲目的随机搜索，搜索时间较长。
改进解决以上问题的办法：
1、增加蚂蚁的数量。2、减小残留的信息素（所有蚂蚁都减小，部分蚂蚁减小）。3、减小蚂蚁选择信息素强的路径的概率。4、给蚂蚁和环境一定的记忆能力，减少搜索空间，从而减少搜索时间。
改进小结
1、蚂蚁数量的选择。蚂蚁数量 m 是蚁群算法的重要参数之一。蚂蚁数量多，可以提高蚁群算法的全局搜索能力以及算法的稳定性，但大量被搜索过的路径信息素变得平均，会减弱信息正反馈的作用，使搜索的随机性增强，从而降低收敛速度；反之，蚂蚁数量少，特别是当要处理的问题规模比较大时，而从未搜索过的路径信息素接近0，蚁群会倾向选择信息量大的路径，会使搜索的随机性减弱，虽然收敛速度加快，但会使算法的全局搜索能力降低，稳定性差，容易出现停滞现象（局部最优）。
2、信息启发式因子的选择。信息启发式因子α的大小反映了信息素因素作用的强度。其值越大，蚂蚁选择以前走过路径的可能性越大，搜索的随机性减弱。当α值过大时会使蚁群的搜索过早陷于局部最优；当α值较小时，搜索的随机性增强，算法收敛速度减慢。
3、期望值启发式因子的选择。期望值启发式因子β的大小反映了先验性、确定性因素作用的强度。其值越大，蚂蚁在某个局部点上选择局部最短路径的可能性越大，算法的随机性减弱，易于陷入局部最优；而β过小，将导致蚂蚁群体陷入纯粹的随机搜索，很难找到最优解。
4、信息素挥发因子的选择。信息素挥发因子 ρ 的大小直接关系到蚁群算法的全局搜索能力及其收敛速度。 ρ 就是信息素残留系数，反映了信息消逝程度。较大时，由于信息正反馈的作用占主导地位，以前搜索过的路径被再次选择的可能性过大，搜索的随机性减弱；反之，当 ρ 很小时，信息正反馈的作用相对较弱，搜索的随机性增强，因此蚁群算法收敛速度很慢。
改进方法：最大最小蚁群算法、最优最差蚁群算法、分段变异蚁群算法、排序蚁群算法、基于遗传算法的蚁群算法等。
蚁群算法应用组合优化问题旅行商问题、0-1背包问题、加工调度问题、装箱问题、图着色问题、聚类问题、最大团问题、最大割问题。理论上每个组合优化问题都可以通过枚举的方法得到最优解，但枚举是以时间为代价的。有的枚举时间还能接受，有的则不可能接受，即所谓的“组合爆炸”。对于NP完全的组合优化问题，至今尚无很好的解析算法，一般采用启发式算法来解决。
参考文档自话蚁群算法
自话粒子群算法
自话遗传算法
NP完全问题
]]></content>
      <categories>
        <category>专业</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>知识工程</tag>
      </tags>
  </entry>
  <entry>
    <title>支付宝签名与验签</title>
    <url>/dev-alipay-sign-and-checksign/</url>
    <content><![CDATA[前言支付宝提供了DSA、RSA、MD5三种签名方式，本文仅讨论RSA签名。

RSA公钥加密算法是1977年由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）一起提出的。1987年首次公布，当时他们三人都在麻省理工学院工作。RSA就是他们三人姓氏开头字母拼在一起组成的。



RSA理解以下内容转载自21aspnet的《公钥，私钥和数字签名这样最好理解》，原作者举的例子通俗易懂，郝同学偷了过来，大家不要告诉他。
公钥加密假设一下，我找了两个数字，一个是1，一个是2。我喜欢2这个数字，就保留起来，不告诉你们(私钥），然后我告诉大家，1是我的公钥。我有一个文件，不能让别人看，我就用1加密了。别人找到了这个文件，但是他不知道2就是解密的私钥啊，所以他解不开，只有我可以用数字2，就是我的私钥，来解密。这样我就可以保护数据了。我的好朋友x用我的公钥1加密了字符a，加密后成了b，放在网上。别人偷到了这个文件，但是别人解不开，因为别人不知道2就是我的私钥，只有我才能解密，解密后就得到a。这样，我们就可以传送加密的数据了。
私钥签名如果我用私钥加密一段数据（当然只有我可以用私钥加密，因为只有我知道2是我的私钥），结果所有的人都看到我的内容了，因为他们都知道我的公钥是1，那么这种加密有什么用处呢？但是我的好朋友x说有人冒充我给他发信。怎么办呢？我把我要发的信，内容是c，用我的私钥2，加密，加密后的内容是d，发给x，再告诉他解密看是不是c。他用我的公钥1解密，发现果然是c。这个时候，他会想到，能够用我的公钥解密的数据，必然是用我的私钥加的密。只有我知道我得私钥，因此他就可以确认确实是我发的东西。这样我们就能确认发送方身份了。这个过程叫做数字签名。当然具体的过程要稍微复杂一些。用私钥来加密数据，用途就是数字签名。
小结总结：公钥和私钥是成对的，它们互相解密。公钥加密，私钥解密。私钥数字签名，公钥验证。
支付宝签名与验签请求参数签名签名的目的：为了支付宝能够确定请求是由开发者发出的。
1、筛选获取所有请求参数，不包括字节类型参数，如文件、字节流，剔除sign与sign_type参数。
2、排序将筛选的参数按照第一个字符的键值ASCII码递增排序（字母升序排序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。
3、拼接将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。
4、签名MD5签名的商户需要将key的值拼接在字符串后面，调用MD5算法生成sign；RSA签名的商户将待签名字符串和商户私钥带入SHA1算法中得出sign。
返回参数验证签名验签的目的：为了开发者能够确定请求是由支付宝发出的。
1、筛选获取所有支付宝返回的参数，不包括字节类型参数，如文件、字节流。验签参数剔除sign与sign_type参数。
2、排序将筛选的参数按照第一个字符的键值ASCII码递增排序（字母升序），如果遇到相同字符则按照第二个字符的键值ASCII码递增排序，以此类推。
3、拼接将排序后的参数与其对应值，组合成“参数=参数值”的格式，并且把这些参数用&amp;字符连接起来，此时生成的字符串为待签名字符串。
4、验签MD5：把MD5密钥（Key）拼接在待验证签名的字符串尾部，然后使用各自语言对应的MD5加密函数进行加密，得到的加密值与支付宝返回的参数sign做“相等”判断，同时对返回参数中的notify_id进行验证，如果这两个数据同时为true，则验证通过。
啊嘞，为什么没有RSA验签的说明？沈晨帅哥解释说，人家支付宝就只给你一种MD5！发送请求可选的签名方式有三种，接受请求只有一种签名方式，很合理。
问题假设支付宝返回参数的签名方式也是RSA，那么怎么验证签名？猜测解：筛选、排序、拼接后，利用RSA公钥对待签名字符串进行加密，得到的加密值与支付宝返回的参数sign做“相等”判断，同时对返回参数中的notify_id进行验证，如果这两个数据同时为true，则验证通过。
前提是，对同一个字符串进行加密和签名，得到的sign是一样的！比如，利用公钥对“a”进行加密得到sign1，利用私钥对“a”进行签名得到sign2，那么，sign1=sign2！
那么，这个前提对不对呢？不好意思，不对！
公钥加密，通过私钥解密可以得到明文；私钥加密，通过公钥解密可以得到明文。然而，对于同一个字符串，公钥加密和私钥加密得到的密文是不同的！
对称加密对称加密算法中，使用的密钥只有一个，发收信双方都使用这个密钥对数据进行加密和解密。
MD5加密算法就属于对称加密算法，因为无法进行解密，所以MD5加密算法也属于单向加密算法。常用于用户密码的存储和签名验签。
非对称加密不对称加密算法使用两把完全不同但又是完全匹配的一把钥匙——公钥和私钥。在使用不对称加密算法加密文件时，只有使用匹配的一对公钥和私钥，才能完成对明文的加密和解密过程。
RSA加密算法就属于非对称加密算法，常用于加密解密和git服务器验签。
书签签名与验签
公钥，私钥和数字签名这样最好理解http://blog.csdn.net/21aspnet/article/details/7249401
RSA算法原理（一）http://www.ruanyifeng.com/blog/2013/06/rsa_algorithm_part_one.html
RSA算法原理（二）http://www.ruanyifeng.com/blog/2013/07/rsa_algorithm_part_two.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>支付宝</tag>
        <tag>rsa</tag>
      </tags>
  </entry>
  <entry>
    <title>Alpine修改时区</title>
    <url>/dev-alpine-timezone/</url>
    <content><![CDATA[Alpine简介Alpine Linux是基于musl libc和busybox的面向安全的轻量级Linux发行版。Alpine镜像113M，不稀奇，毕竟CirrOS镜像只有12M。但是Alpine的Docker镜像大小只有5M！而CirrOS的Docker镜像大小为10M。
Alpine由非商业组织维护的，支持广泛场景的Linux发行版，它特别为资深/重度Linux用户而优化，关注安全，性能和资源效能。Alpine 镜像可以适用于更多常用场景，并且是一个优秀的可以适用于生产的基础系统/环境。
第一次接触alpine，是使用它跑单测。gitlab设置代码提交后触发单测，而这个单测，可以使用alpine来进行。但是因为时区问题，跑出的单测结果和预期不同。因此，本文以修改Alpine时区为引子，简单学习了解一下Alpine。


Alpine包管理Alpine采用了 musl libc 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，因此得到开源社区越来越多的青睐。在保持瘦身的同时，Alpine还提供了自己的包管理工具apk。更多参考Alpine Linux package management和Alpine Linux下的包管理工具。
常用命令：
# 更新最新本地镜像源apk update # 升级软件apk upgrade # 指定升级部分软件包apk add --upgrade xxx # 安装包apk add xxx# 搜索包，支持正则apk search xxxapk search -v 'xx*'apk search -v -d 'xxx'# 查看包详细信息apk info -a xxx# 查看包列表apk show# 卸载并删除包apk del xxx

使用apk add命令时，往往下载缓慢或者下载失败。参考清华大学Alpine镜像使用帮助，修改镜像源。
sed -i 's/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g' /etc/apk/repositories

修改时区Alpine修改时区，主要参考修改使用Alpine Linux的Docker容器的时区。
1、下载镜像docker pull alpine
2、启动镜像docker run --name alpine_timezone -it alpine:latest /bin/sh
3、安装timezone
apk add -U tzdatals /usr/share/zoneinfo

4、拷贝需要的时区文件到localtimecp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
5、验证时区date
6、精简镜像apk del tzdata
7、保存镜像
exitdocker commit alpine_timezone voidking/alpine:v1.0docker logindocker push

以上，完成了Alpine镜像时区的修改。此外，还有一种更简单的方法，在启动Alpine容器时映射宿主机的时区文件。
docker run --name alpine -it -d -v /etc/localtime:/etc/localtime alpine:lastest


]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发——帧动画</title>
    <url>/dev-android-frameanimation/</url>
    <content><![CDATA[前言获得成就感是学习的灵魂！对于编程，尤其如此。模仿着做一些简单的应用先，之后再补充知识点。This is the plan !
应用简介单击手机屏幕，播放动画。
设计思路1、拷贝关键帧（图片）到资源文件夹。2、在xml文件中定义关键帧、帧顺序、切换时间。PS：一般切换时间为1/24秒，我们这里用0.1秒。3、图片显示在ImageView。4、响应单击事件。5、使用AnimationDrawable绘制动画。


实现流程新建Project新建Project，命名为Demo。
重命名appapp重命名为frameanimation，或者删除app，新建Module，命名为frameanimation。
准备素材1、百度“帧图片素材”，找到一套自己喜欢的帧图片。2、图片重命名为以字母开头，这里郝同学准备的图片名称为fight_01.png到fight_16.png。3、将图片拷贝到src/main/res/drawable文件夹。PS：郝同学尝试在res新建image文件夹，结果不可以使用，不知道为什么。
新建xml文件右击drawable文件夹，New，Drawable resource file，File name随意（郝同学起名为frameanimation.xml），Root element选择animation-list。frameanimation.xml内容如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;animation-list xmlns:android="http://schemas.android.com/apk/res/android"    android:oneshot="true"&gt;    &lt;item android:drawable="@drawable/fight_01" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_02" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_03" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_04" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_05" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_06" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_07" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_08" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_09" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_10" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_11" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_12" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_13" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_14" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_15" android:duration="100" /&gt;    &lt;item android:drawable="@drawable/fight_16" android:duration="100" /&gt;&lt;/animation-list&gt;

一起来分析一下这个文件：

android:oneshot=”true”，默认循环播放，加上这个属性，只播放一遍。

android:drawable=”@drawable/fight_01”，原来，.png是需要省略掉的。

android:duration=”100”，切换间隔时间100ms。


添加ImageView控件1、打开activity_main.xml，Design，在Widgets中选中ImageView放到布局中。2、双击，在src中选择Project&gt;Drawable&gt;frameanimation，OK。3、指定一个id，添加的第一个ImageView默认为imageView，第二个默认为imageView2，依次类推。4、拖拉一下，修改一下长宽和大小。
修改activity_main.xml&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"    xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent"    android:layout_height="match_parent" android:paddingLeft="0dp"    android:paddingRight="0dp"    android:paddingTop="0dp"    android:paddingBottom="0dp" tools:context=".MainActivity"&gt;    &lt;ImageView        android:layout_width="match_parent"        android:layout_height="match_parent"        android:scaleType="fitXY"        android:id="@+id/imageView"        android:src="@drawable/frameanimation"        android:layout_alignParentLeft="true"        android:layout_alignParentStart="true"        android:layout_alignParentRight="true"        android:layout_alignParentEnd="true"        android:layout_alignParentBottom="true"        android:layout_alignParentTop="true" /&gt;&lt;/RelativeLayout&gt;
这一步主要修改了一下ImageView的布局，使其填充整个界面，看起来效果比较好。非必要步骤，可不做。
修改MainActivity.javapackage com.voidking.android.demo;import android.graphics.drawable.AnimationDrawable;import android.support.v7.app.ActionBarActivity;import android.os.Bundle;import android.view.Menu;import android.view.MenuItem;import android.view.View;import android.widget.ImageView;public class MainActivity extends ActionBarActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        ImageView imageView = (ImageView) findViewById(R.id.imageView);        final AnimationDrawable animationDrawable = (AnimationDrawable)imageView.getDrawable();        imageView.setOnClickListener(new View.OnClickListener() &#123;            @Override            public void onClick(View v) &#123;                animationDrawable.stop();                animationDrawable.start();            &#125;        &#125;);    &#125;    @Override    public boolean onCreateOptionsMenu(Menu menu) &#123;        // Inflate the menu; this adds items to the action bar if it is present.        getMenuInflater().inflate(R.menu.menu_main, menu);        return true;    &#125;    @Override    public boolean onOptionsItemSelected(MenuItem item) &#123;        // Handle action bar item clicks here. The action bar will        // automatically handle clicks on the Home/Up button, so long        // as you specify a parent activity in AndroidManifest.xml.        int id = item.getItemId();        //noinspection SimplifiableIfStatement        if (id == R.id.action_settings) &#123;            return true;        &#125;        return super.onOptionsItemSelected(item);    &#125;&#125;
我们修改的，其实只有OnCreate函数，在里面添加了对ImageView的单击事件的监听和动作。之所以先stop再start，是因为animationDrawable.start()之后，显示到了最后一个帧，停留在最后一个帧，但是，这时候animationDrawable的运行并没有结束，必须stop之后，才能开始新一轮动画播放。
运行单击工具栏上的绿色三角形，选择一个AVD，运行即可。
效果展示
代码分享https://github.com/voidking/android-frameanimation ，需要的同学移步自取。
后记一步一步，不怕慢，胜在不止！
参考资料7天学会Androidhttp://www.duobei.com/room/trial/9152038430
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发——helloworld</title>
    <url>/dev-android-helloworld/</url>
    <content><![CDATA[前言Android的学习，拖拉了太久太久，这个夏天，搞个作品出来吧！从0开始，用博客记录进度！
工具之前使用adt，断断续续学习过安卓开发。今年谷歌宣布Android Studio将取代Eclipse，正式成为官方集成开发软件，中止对后者支持。郝同学也紧跟潮流，换用Android Studio（以后简称AS）。


步骤下载安装1、Android Studio中文社区http://www.android-studio.org/
2、百度“Android Studio”，从百度软件中心下载即可。
新建工程打开AS，选择工作路径，输入工程名（首字母习惯大写），选择sdk版本，选择一个模板，finish即可。（和Eclipse非常类似）
新建模拟器点击AVD Manager，Create Virtual Device，选择一款模拟器，next，输入模拟器名称，finish即可。
运行点击Run ‘app’，Choose Device，OK。正常情况下，就可以看到经典的“helloworld”了。郝同学在启动AVD的时候出现了端口冲突，下面是解决办法。
端口冲突详细描述启动AVD报错：
解决办法查看端口netstat -ano|findstr &quot;5037&quot;看到PID为20968。
kill进程ctrl+shift+esc，打开任务管理器，详细信息，找到PID为20968的进程，结束进程。
运行结果解决完上述错误，再次Run ‘app’，就可以看到：
后记安卓开发，就当做娱乐来搞吧。白天复习备考，晚上搞搞开发，也是一件很有意思的事情。贵在坚持，不出作品不止！
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发——常见开源项目</title>
    <url>/dev-android-open-sourse/</url>
    <content><![CDATA[前言见多识广，方便模仿。
看的多了，写的多了，懂的多了。也就怕的少了，思路广了，境界高了。。。
今天我们来聊聊拓宽世界的途径之一，学习那些牛逼的开源项目！
雨辰推荐
ActionBarSherlock
HoloEverywhere
ViewPagerIndicator




Android-Universal-Image-Loader
Sliding Menu
Android-PullToRefresh
ViewBader
Progress Wheel
Cards UI
SmoothProgressBar
SataliteMenu
Radial Menu Widget
Indexable ListView
Sticky ListHeaders
Slide ExpandableListView
Jazzy ListView
PinterestListView
SwipeListView

后记初入Android世界，便看到高山景行，突然感觉热血被点燃！也许，我会在这条路上走很远。。。
参考资源7天学会Androidhttp://www.duobei.com/room/trial/9118721751
直接拿来用！最火的Android开源项目（一）http://www.csdn.net/article/2013-05-03/2815127-Android-open-source-projects
直接拿来用！最火的Android开源项目（二）http://www.csdn.net/article/2013-05-06/2815145-Android-open-source-projects-two
直接拿来用！最火的Android开源项目（完结篇）http://www.csdn.net/article/1970-01-01/2815370
直接拿来用！最火的Android开源项目整理http://blog.csdn.net/djun100/article/details/13776005
直接拿来用！十大Material Design开源项目http://www.csdn.net/article/2014-11-21/2822753-material-design-libs
Android开源项目分类汇总【老外汇总版本】http://blog.csdn.net/forlong401/article/details/26848951
安卓巴士总结了近百个Android优秀开源项目http://www.apkbus.com/android-17627-1-1.html
GitHub 优秀的 Android 开源项目http://blog.csdn.net/shulianghan/article/details/18046021http://www.cnblogs.com/hawkon/p/3593709.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发——-Android Source&amp;SDK的国内镜像</title>
    <url>/dev-android-source-and-sdk/</url>
    <content><![CDATA[前言谷歌被墙，在下载安卓源码和SDK时，各种没有进度。这时，就要感谢国内镜像站了。
Android Source清华大学TUNA镜像源https://aosp.tuna.tsinghua.edu.cn/https://wiki.tuna.tsinghua.edu.cn/MirrorUsage/android
为什么要下载Android Source研究Android尤其是Android系统核心或者是驱动的开发，首先需要做的就是克隆建立本地Android Source版本库。


AOSP、AOKP、CMAOSP是“Android Open-Source Project”的缩写，中文名称为Android开放源代码项目。大家都知道Android是开源操作系统，所以Google每发布一个Android版本，都会给开源社区发放对应版本的源代码，也就是我们所说的AOSP ROM，这可以称得上是最为纯净的Android系统。可以用类比来让大家更清楚一些，例如国内多数盗版的Windows系统，几乎都是基于微软的MSDN制作，AOSP ROM即等相当于微软MSDN母盘的角色。
AOKP是“Android Open-Source Kang Project”，比AOSP多了一个“Kang”。在Android社区中，Kang表示这是一个被别人定制过的ROM，是一个来自民间的ROM。
CM是CyanogenMod的简称，Cyanogen团队是全球最大的第三方ROM编译团队，覆盖机型范围特别广，国内知名的ROM例如MIUI、锤子ROM都是基于CM实现的。严格意义上来说，CM ROM属于AOKP的范畴。CM ROM虽然一直遵从原生Android，但只有Google官方的才算真正的AOSP。
为什么使用RepoAndroid使用Git作为代码管理工具，开发了Gerrit进行代码审核以便更好的对代码进行集中式管理，还开发了Repo命令行工具，对Git部分命令封装，将百多个Git库有效的进行组织。
AOSP是由许许多多有Git管理的项目组成的，例如，在Android4.2中，就包含了329个项目，每一个项目都是一个独立的Git仓库。这意味着，如果我们要创建一个AOSP分支来做新的feature开发，那么就需要到每一个子项目去创建对应的分支。这显然不能手动地到每一个子项目里面去创建分支，必须要采用一种自动化的方式来处理。这些自动化处理工作就是由Repo工具来完成的。当然，Repo工具所负责的自动化工作不只是创建分支那么简单，查看分支状态、提交代码、更新代码等基础的Git操作都可以用Repo来替代完成。
下载安装配置Repo假设在VirtualBox Ubuntu环境下，打开终端：mkdir ~/binPATH=~/bin:$PATHgit clone git://aosp.tuna.tsinghua.edu.cn/android/git-repo.gitcp git-repo/repo ~/bin/gedit ~/bin/repo在该文件中修改
REPO_URL = 'git://aosp.tuna.tsinghua.edu.cn/android/git-repo'

初始化Repomkdir anroidcd androidgit config --global user.email &quot;voidking@qq.com&quot;git config --global user.name &quot;voidking&quot;repo init -u git://aosp.tuna.tsinghua.edu.cn/android/platform/manifest -b android-5.0.2_r1这一步大概有一分多钟就完成了。如果需要下载其他分支将android-5.0.2_r1改成其他分支名称就可以了。
Android官网详细地介绍了当前Android的各个版本名称、Version、对应的API Level、Branch TAG、以及Supported devices，该链接地址如下：http://source.android.com/source/build-numbers.html
如果谷歌北墙，请查看https://github.com/Jhuster/AOSP/tree/master/documents 的build-numbers.html，雷锋哥哥在这里备份了一份。
开始下载repo sync然后就是漫长的等待了，大约32G的数据，有点大！
使用1、查看源码

在Ubuntu下，查看没有问题。
如果想要在Windows下查看，那么不妨建立一个Ubuntu和Windows的共享文件夹，具体方法见《VirtualBox Ubuntu共享文件夹》。

2、开发按照曾经修改Linux内核的经验，郝同学推测，Android的内核开发最好在Linux下进行；Mac是程序猿的最爱，估计也可以；各种编译工具和依赖包，Windows折腾不起哇！
Android SDK北京化工大学镜像站http://ubuntu.buct.edu.cn/http://ubuntu.buct.edu.cn/android/repository/
We - 开源镜像站http://mirrors.neusoft.edu.cn/http://mirrors.neusoft.edu.cn/android/repository/
配置1、启动Android SDK Manager，Tools，Options。2、在弹出的Android SDK Manager-Settings中

HTTP Proxy Server填入mirrors.neusoft.edu.cn
HTTP Proxy Port填入80
选中Force https://... sources to be fetched using http://...复选框。

3、单击Close返回主界面，Packages，Reload。
后记Android Source，前期用不上，郝同学还没有深入底层的打算。Android的SDK，这是个好东西！最喜欢里面的官方文档和例子，实在是学习Android的最好资料啊！
参考文档同步、更新、下载Android Source &amp; SDK from 国内镜像站http://www.cnblogs.com/bluestorm/p/4419051.html
Android A to Z: What is the AOSP?http://www.androidcentral.com/android-z-what-aosp
Android源代码仓库及其管理工具Repo分析http://blog.csdn.net/luoshengyang/article/details/18195205
Android源码仓库和Repo工具使用http://www.2cto.com/kf/201409/336722.html
windows系统中国国内镜像网站上用repo下载Android5.0源码http://jileniao.net/post-156.html
repo用法详解http://blog.csdn.net/sunweizhong1024/article/details/8055372
关于Android Repohttp://www.cnblogs.com/hongzg1982/articles/2101980.html
Android内核开发：源码的版本与分支详解http://ticktick.blog.51cto.com/823160/1654759http://www.tuicool.com/articles/RjeEZb
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>AngularJS按需加载js</title>
    <url>/dev-angularjs-dynamic-js/</url>
    <content><![CDATA[前言Angular是一个单页面应用，随着系统的迭代，首屏代码会越来越大，所以对《AngularJS入门》中的代码进行改造，实现AngularJS可以按需加载js和css。实现这个需求，有三个方案：1、利用requirejs。requirejs并不是按照angular规范开发的第三方插件，后期估计会有很多坑，放弃。
2、利用ui-router和ocLazyLoad。

每次“页面跳转”都要额外请求js并加载，浪费带宽增加页面加载时间，基本抛弃了预加载。
每一个路由都需要配置resolve属性，太low。
模块化程度太低，不利于以后代码移植和维护。

3、自己写需要的组件。最好的方案，然而技术要求太高，放弃。


综上，第三种方案暂时无法实现，放弃；第一种方案坑太多，放弃；第二种方案也不好，但是相对容易，而且是针对angular的插件，就它了。
bower install angular#1.5.8bower install angular-ui-routerbower install oclazyloadbower install bootstrap

核心代码&lt;!--dynamic/index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;link rel="stylesheet" href="bower_components/bootstrap/dist/css/bootstrap.min.css"&gt;     &lt;style&gt;        body&#123;            font-family: "Microsoft Yahei";        &#125;        .navigator&#123;            width: 500px;margin: 0 auto        &#125;        .navigator li&#123;           color: #000;font-size: 14px;        &#125;    &lt;/style&gt;    &lt;title&gt;按需加载js&lt;/title&gt;&lt;/head&gt;&lt;body ng-app="myApp"&gt;    &lt;ul class="navigator nav nav-pills"&gt;        &lt;li role="presentation" class="active"&gt;&lt;a href="#home" ng-click="isActive($event)"&gt;主页&lt;/a&gt;&lt;/li&gt;        &lt;li role="presentation" class="active"&gt;&lt;a href="#page2"&gt;Page2&lt;/a&gt;&lt;/li&gt;        &lt;li role="presentation" class="active"&gt;&lt;a href="#page3" ng-click="isActive($event)"&gt;Page3&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;div ui-view style="width: 500px;margin: 50px auto 0"&gt;&lt;/div&gt;&lt;script src="bower_components/angular/angular.min.js"&gt;&lt;/script&gt;&lt;script src="bower_components/angular-ui-router/release/angular-ui-router.min.js"&gt;&lt;/script&gt;&lt;script src="bower_components/oclazyload/dist/ocLazyLoad.min.js"&gt;&lt;/script&gt;&lt;script src="public/js/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

/* *dynamic/public/js/index.js*/var myApp=angular.module("myApp",["ui.router","oc.lazyLoad"]);myApp.config(function ($stateProvider,$urlRouterProvider) &#123;    $urlRouterProvider.when("","/home");    $stateProvider.state('home',&#123;        url:"/home",        templateUrl: 'views/homepage.html',        controller: 'homeController',        resolve:&#123;            loadMyCtrl:['$ocLazyLoad',function ($ocLazyLoad) &#123;                return $ocLazyLoad.load(&#123;                    name:"homeApp",                    files:["public/js/homepage.js"]                &#125;)            &#125;]         &#125;    &#125;);    $stateProvider.state('page2',&#123;        url:"/page2",        templateUrl:'views/page2.html',        resolve:&#123;            loadMyCtrl:function ($ocLazyLoad) &#123;                return $ocLazyLoad.load(&#123;                    name:'page2App',                    files:["public/js/page2.js"]                &#125;)            &#125;        &#125;    &#125;)    $stateProvider.state('page3',&#123;        url:"/page3",        templateUrl:'views/page3.html',        resolve:&#123;            loadMyCtrl:function ($ocLazyLoad) &#123;                return $ocLazyLoad.load(&#123;                    name:'page3App',                    files:["public/js/page3.js","public/js/page3-ext.js"]                &#125;)            &#125;        &#125;    &#125;)    &#125;);

&lt;!--dynamic/views/homepage.html--&gt;&lt;div id="home" ng-controller="homeController"&gt;    &lt;h1&gt;首页&lt;/h1&gt;    &#123;&#123;content&#125;&#125;&lt;/div&gt;

/* *dynamic/public/js/homepage.js*/angular.module('myApp').controller('homeController', function ($scope) &#123;     $scope.content = '这是主页的内容';&#125;);

完整代码github自取：https://github.com/voidking/angulardemo/tree/master/dynamic
书签RequireJS官方文档http://requirejs.org/docs/start.html
Dynamically Loading Controllers and Views with AngularJShttp://weblogs.asp.net/dwahlin/dynamically-loading-controllers-and-views-with-angularjs-and-requirejs
angular应用如何实现按需加载http://www.alloyteam.com/2015/10/angular-application-how-to-load-on-demand/
尝试通过AngularJS模块按需加载搭建大型应用（上）http://web.jobbole.com/86915/
尝试通过AngularJS模块按需加载搭建大型应用（下）http://web.jobbole.com/87025/
angularjs ocLazyLoad分步加载js文件,angularjs ocLazyLoad按需加载jshttp://m.w2bc.com/article/158713
按需加载 AngularJS 的 Controllerhttp://beginor.github.io/angularjs-controller-load-on-demand.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angularjs</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache与Tomcat区别联系</title>
    <url>/dev-apache-and-tomcat/</url>
    <content><![CDATA[概述Apache 和 Tomcat 都是web网络服务器，两者既有联系又有区别，在进行HTML、PHP、JSP、Perl等开发过程中，需要准确掌握其各自特点，选择最佳的服务器配置。
Apache是web服务器（静态解析，如HTML），tomcat是java应用服务器（动态解析，如JSP、PHP）。
Tomcat只是一个servlet(jsp也翻译成servlet)容器，可以认为是apache的扩展，但是可以独立于apache运行。
两者从以下几点可以比较的：1、两者都是apache组织开发的2、两者都有HTTP服务的功能3、两者都是开源免费的
联系1）Apache是普通服务器，本身只支持html即普通网页，可以通过插件支持php，还可以与Tomcat连通(Apache单向连接Tomcat，就是说通过Apache可以访问Tomcat资源，反之不然)。　　
2）Apache只支持静态网页，但像asp、jsp、php、cgi等动态网页就需要Tomcat来处理。
3）Apache和Tomcat整合使用：如果客户端请求的是静态页面，则只需要Apache服务器响应请求；如果客户端请求动态页面，则是Tomcat服务器响应请求，将解析的JSP等网页代码解析后回传给Apache服务器，再经Apache返回给浏览器端。这是因为jsp是服务器端解释代码的，Tomcat只做动态代码解析，Apache回传解析好的静态代码，Apache+Tomcat这样整合就可以减少Tomcat的服务开销。
4）Apache和Tomcat是独立的，在同一台服务器上可以集成。
区别Apache是有C语言实现的，支持各种特性和模块从而来扩展核心功能；Tomcat是Java编写的，更好的支持Servlet和JSP。1、Apache是Web服务器，Web服务器传送(serves)页面使浏览器可以浏览，Web服务器专门处理HTTP请求(request)，但是应用程序服务器是通过很多协议来为应用程序提供 (serves)商业逻辑(business logic)。Tomcat是运行在Apache上的应用服务器，应用程序服务器提供的是客户端应用程序可以调用(call)的方法 (methods)。它只是一个servlet(jsp也翻译成servlet)容器，可以认为是Apache的扩展，但是可以独立于apache运行。
2、Apache是普通服务器，本身只支持html静态普通网页。不过可以通过插件支持PHP，还可以与Tomcat连通(单向Apache连接Tomcat,就是说通过Apache可以访问Tomcat资源，反之不然)，Tomcat是jsp/servlet容器，同时也支持HTML、JSP、ASP、PHP、CGI等，其中CGI需要一些手动调试，不过很容易的。
3、Apache侧重于http server，Tomcat侧重于servlet引擎，如果以standalone方式运行，功能上Tomcat与apache等效支持JSP，但对静态网页不太理想。
4、Apache可以运行一年不重启，稳定性非常好，而Tomcat则不见得。
5、首选web服务器是Apache，但Apache解析不了的jsp、servlet才用tomcat。
6、Apache是很最开始的页面解析服务，tomcat是后研发出来的，从本质上来说tomcat的功能完全可以替代Apache，但Apache毕竟是tomcat的前辈级人物，并且市场上也有不少人还在用Apache，所以Apache还会继续存在，不会被取代，apache不能解析java的东西，但解析html速度快。
两者例子：Apache是一辆车，上面可以装一些东西如html等，但是不能装水，要装水必须要有容器（桶），而这个桶也可以不放在卡车上，那这个桶就是TOMCAT。
两者整合：Apache是一个web服务器环境程序，启用他可以作为web服务器使用不过只支持静态网页，不支持动态网页，如asp、jsp、php、cgi
如果要在Apache环境下运行jsp就需要一个解释器来执行jsp网页，而这个jsp解释器就是Tomcat。
那为什么还要JDK呢？因为jsp需要连接数据库的话就要jdk来提供连接数据库的驱程，所以要运行jsp的web服务器平台就需要APACHE+TOMCAT+JDK。
整合的好处：
如果客户端请求的是静态页面，则只需要Apache服务器响应请求
如果客户端请求动态页面，则是Tomcat服务器响应请求
因为jsp是服务器端解释代码的，这样整合就可以减少Tomcat的服务开销
转载自：http://www.admin10000.com/document/974.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>apache</category>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>APP第三方登录QQ和微博配置</title>
    <url>/dev-app-login-qq-sina/</url>
    <content><![CDATA[需求使用hbuilder修改东北高师就业联盟网的app，完成了qq和微博第三方登录，真机调试正常。但是打包发布后，问题来了。使用qq登录时，会提示错误“该应用非官方正版应用，请去应用宝下载正版后进行qq登陆。（错误码：100044）”。使用微博登录时，会提示错误“21338:sso package or sign error”。
因为就业联盟网在开放平台上是一个web应用，但是我们的app打包后是一个android应用和一个ios应用。所以，要解决这个问题，我们要在开放平台上添加android应用和ios应用。


android打包签名在配置开放平台之前，我们先把android app打包发布，具体流程如下：
安装java环境参考《全平台安装JDK》。
生成keystorekeytool -genkey -alias dsjyw.keystore -keyalg RSA -validity 1000 -keystore dsjyw.keystore
说明：keytool -genkey -alias 别名.keystore -keyalg RSA -validity 有效期限(天数) -keystore 别名.keystore
dsjyw.store参数输入密钥库口令: voidking再次输入新口令: voidking您的名字与姓氏是什么?  [Unknown]:  VoidKing您的组织单位名称是什么?  [Unknown]:  Nenu您的组织名称是什么?  [Unknown]:  Nenu您所在的城市或区域名称是什么?  [Unknown]:  ChangChun您所在的省/市/自治区名称是什么?  [Unknown]:  JiLin该单位的双字母国家/地区代码是什么?  [Unknown]:  CNCN=VoidKing, OU=Nenu, O=Nenu, L=ChangChun, ST=JiLin, C=CN是否正确?  [否]:  y输入 &lt;dsjyw.keystore&gt; 的密钥口令        (如果和密钥库口令相同, 按回车):

打包1、打开Hbuilder，发行，发行为原生安装包。
2、使用自有证书；Android包名是自动生成的，不需要修改，也可以修改为自己喜欢的包名；证书别名和私钥密码是生成keystore时配置的；证书文件选择生成的keystore文件。
3、打包，之后会自动上传源码，打包好后下载到app存放目录中。
签名1、复制打包下载好的apk文件到dsjyw.keystore相同的目录，重命名apk文件为android-release-unsigned.apk。
2、打开cmd，执行签名命令jarsigner -verbose -keystore dsjyw.keystore -signedjar dsjyw.apk android-release-unsigned.apk dsjyw.keystore
说明：jarsigner -verbose -keystore 别名.keystore(密钥库位置) -signedjar 签名后产生的文件.apk要签名的文件.apk 别名.keystore(密钥库)
查看签名keytool -v -list -keystore dsjyw.keystore
找到MD5: 70:1D:81:1E:D3:A6:8B:28:66:82:BA:D8:EB:79:DC:63
新浪创建移动应用时要求的是32位数字小写字母，把前面的这串数字中的冒号去掉，字母小写即可。
腾讯开放平台创建安卓应用1、登录腾讯开放平台
2、安卓应用，创建应用。
3、关联QQ互联，输入联盟网web应用的appid和appkey，确定。之所以关联QQ互联，是为了统一appid，否则，web登录和app登录获得的是不同的openid。
如果关联QQ互联后，创建应用失败，提示“对不起，您不是应用的创建者或协作者(1500401)”。
可能一：不是协作者。请先使用联盟网web应用所在账号登录，在管理中心页面，滑动鼠标到右上角用户名，单击权限权限管理，添加协作者。
可能二：账号冲突。之前的web应用在QQ互联上，此时，不要在浏览器中同时打开腾讯开放平台和QQ互联，也不要登录其他的QQ邮箱，有可能账号冲突。
可能三：开发者资料未提交审核。
4、选择移动应用 安卓，创建应用，选择应用类型，确定。此时创建的安卓应用，它的appid和appkey就和联盟网web应用相同了。
5、按照提示，填写需要的字段即可。需要注意的是，上传安装包时，需要上传签名后的apk文件。
6、填写好信息，保存即可，不需要提交审核。如果需要提交审核的话，请先根据提示加固应用。
创建ios应用1、在安卓应用中，可以看到我们创建的联盟网app，单击它。
2、鼠标滑到右上角平台信息，单击IOS应用，即可创建IOS应用。该IOS应用的appid和appkey就和联盟网web应用相同，也和安卓应用相同。
警告，创建ios应用后，此时安卓应用和ios应用实际上是同一个应用。删除任意一个，两个应用就都没有了。
3、按照提示填写各字段即可。其中比较难的是URL scheme、AppStore ID和Bundle ID，这些信息可以到Apple Developer和itunes connect上查看到。
新浪开放平台1、登录新浪开放平台
2、微连接，移动应用，立即接入。勾选Iphone和Android两个平台，创建。
3、填写应用基本信息。其中比较难的是Android签名，不必使用新浪提供的签名工具，参考本文中的“查看签名”小节，填入得到的32位字符串。
4、保存信息，提交审核。审核不通过会有详细提示，参考提示修改后再次提交审核。
5、单击左侧导航栏应用信息，高级信息。OAuth2.0 授权设置中点击编辑，授权回调页和取消授权回调页都填入https://api.weibo.com/oauth2/default.html。
书签HBuilder 打包流程
腾讯开放平台创建应用的坑，安卓和iOS端如何共用同一个Appid？
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>hbuilder</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>百度公共DNS</title>
    <url>/dev-baidu-dns/</url>
    <content><![CDATA[基本概念http://dudns.baidu.com/intro.html
使用说明http://dudns.baidu.com/useDoc.html
百度DNS地址主DNS服务器地址180.76.76.76辅助DNS服务器的地址114.114.114.114
GoogleDNS地址主DNS服务器地址8.8.8.8辅助DNS服务器的地址8.8.4.4


114DNS114.114.114.114114.114.115.115
阿里DNS223.5.5.5223.6.6.6
OneDNS112.124.47.27114.215.126.16
DNS派101.226.4.6123.125.81.6
OpenDNS208.67.222.222208.67.220.220
小结不同的DNS，各有特点，个人感觉百度公共DNS不错。
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>百度搜索结果页</title>
    <url>/dev-baidu-search-result/</url>
    <content><![CDATA[前言1月18日，入职艾佳，办好了各种手续。从海哥那里，接到了第一个任务——周一到周三（18到20），高仿一个百度搜索结果页。郝同学随手挖了一个坑：“上海”，接着便开始填坑。


界面布局浏览器，是一个长方体的不透明的可变体积的盒子，盒子上面开了一个长方形的窗口。从这个窗口，我们可以看到盒子里的内容。盒子有很多层，IE、FireFox、Safari有2147483647层，Opera有2147483584层。一般情况下，10层，就足够我们使用了。 
界面布局，也就是在浏览器盒子里面摆放东西的方式。一般分为三种：标准文档流、浮动和定位。
标准文档流标准文档流，就是在盒子的第一层摆放东西，按照从左到右，从上到下的方式，符合我们平时的思维习惯。
浮动浮动会脱离标准文档流，不再按照从左到右，从上到下的方式。但是，浮动的元素，仍然处于第一层。
对于浮动，最认同张鑫旭的看法。浮动出现的意义其实只是用来让文字环绕图片而已，仅此而已。浮动的本质为“包裹与破坏”！
1、包裹撇开浮动的“破坏性”，浮动就是个带有方位的display:inline-block属性。
2、破坏文字之所以会环绕含有float属性的图片，是因为浮动破坏了正常的line boxes。
定位static元素出现在标准文档流中。
relative生成相对定位的元素，相对于其正常位置进行定位。
因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。
absolute生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。
元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。
fixed生成绝对定位的元素，相对于浏览器窗口进行定位。
元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。
盒子模型上面我们说，要在浏览器这个盒子里摆放东西。那么，摆放什么东西呢？盒子！没有顶的盒子。

margin：盒子间的距离。
border：盒子的板厚度。
padding：盒子里的减震泡沫厚度。
content：盒子里可以摆放物品的空间尺寸。

全局设置排版的时候，郝同学发现，在内容和浏览器窗口之间，会存在缝隙。所以，一般会设置一个全局样式：
*&#123;    margin: 0;    padding: 0;&#125;

下拉菜单鼠标移动到顶部的“设置”或者“用户名”下面，会出现下拉菜单。这个效果，就需要用到定位中的“absolute”了，
块级元素行内元素1、行内元素与块级元素直观上的区别行内元素会在一条直线上排列，都是同一行的，水平方向排列块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。
2、块级元素可以包含行内元素和块级元素，行内元素不能包含块级元素。
3、行内元素与块级元素属性的不同，主要是盒模型属性上行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效
line-height和vertical-alignline-height适用于所有元素，设置元素中行的高度。vertical-align适用于行内元素和单元格（table-cell）元素，设置元素内容的垂直对齐方式。
后记本次任务，遵循一个原则：能用HTML+CSS实现的，不用JavaScript；能用JavaScript实现的，不用jQuery。上面主要记录了这次任务用到的技术和原理，细节方面的东西，看代码吧，完成度80%：https://github.com/voidking/baidu-search-result.git
参考文档如何利用 CSS 製作多級選單？https://zespia.tw/blog/css-multi-level-menu/
网页布局基础http://www.imooc.com/learn/95
css知多少（7）——盒子模型http://www.cnblogs.com/wangfupeng1988/p/4287292.html
CSS+DIV定位分析http://blog.163.com/love_heartbreaking/blog/static/124561901201211334714800/
DOM中关于脱离文档流的几种情况分析http://www.tuicool.com/articles/IBJvyy7http://www.cnblogs.com/chuaWeb/p/html_css_position_float.html
CSS float浮动的深入研究、详解及拓展(一)
CSS深入理解之float浮动http://www.imooc.com/view/121
行内元素与块级元素比较全面的区别和转换http://blog.csdn.net/sykent/article/details/7738408
line-height 和 vertical-align 行高与行对齐精解 （图文）http://www.jb51.net/css/29328.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>艾佳生活</tag>
      </tags>
  </entry>
  <entry>
    <title>bash_profile和bashrc的区别</title>
    <url>/dev-bashprofile-bashrc/</url>
    <content><![CDATA[bash_profile和bashrc是啥？bash_profile和bashrc都是linux里的初始化脚本，作用是对shell环境进行初始化。在安装和配置软件的时候，经常需要修改这两个配置文件，以便每次登录自动生效或者每次执行脚本都自动生效。
这两个文件的区别是什么？它们有什么联系？什么情况下需要修改bash_profile？什么情况下需要修改bashrc？本文就来详细了解一下，主要引用阮一峰大佬的Bash 启动环境。


Session用户每次使用 Shell，都会开启一个与 Shell 的 Session（对话）。
Session 有两种类型：登录 Session 和非登录 Session，也可以叫做 login shell 和 non-login shell。
登录 Session登录 Session 是用户登录系统以后，系统为用户开启的原始 Session，通常需要用户输入用户名和密码进行登录。
登录 Session 一般进行整个系统环境的初始化，启动的初始化脚本依次如下。

/etc/profile：所有用户的全局配置脚本。
/etc/profile.d：目录里面所有.sh文件
~/.bash_profile：用户的个人配置脚本。如果该脚本存在，则执行完就不再往下执行。
~/.bash_login：如果~/.bash_profile没找到，则尝试执行这个脚本（C shell 的初始化脚本）。如果该脚本存在，则执行完就不再往下执行。
~/.profile：如果~/.bash_profile和~/.bash_login都没找到，则尝试读取这个脚本（Bourne shell 和 Korn shell 的初始化脚本）。

Linux 发行版更新的时候，会更新/etc里面的文件，比如/etc/profile，因此不要直接修改这个文件。如果想修改所有用户的登陆环境，就在/etc/profile.d目录里面新建.sh脚本。
如果想修改你个人的登录环境，一般是写在~/.bash_profile里面。下面是一个典型的.bash_profile文件。
# .bash_profilePATH=/sbin:/usr/sbin:/bin:/usr/bin:/usr/local/binPATH=$PATH:$HOME/binSHELL=/bin/bashMANPATH=/usr/man:/usr/X11/manEDITOR=/usr/bin/viPS1='\h:\w\$ 'PS2='&gt; 'if [ -f ~/.bashrc ]; then. ~/.bashrcfiexport PATHexport EDITOR
可以看到，这个脚本定义了一些最基本的环境变量，然后执行了~/.bashrc
bash命令的 –login 参数，会强制执行登录 Session 会执行的脚本。bash --loginbash命令的 –noprofile 参数，会跳过上面这些 Profile 脚本。bash --noprofile
非登录 Session非登录 Session 是用户进入系统以后，手动新建的 Session，这时不会进行环境初始化。比如，在命令行执行bash命令，就会新建一个非登录 Session。
非登录 Session 的初始化脚本依次如下。

/etc/bash.bashrc：对全体用户有效。
~/.bashrc：仅对当前用户有效。

对用户来说，~/.bashrc通常是最重要的脚本。非登录 Session 默认会执行它，而登录 Session 一般也会通过调用执行它。每次新建一个 Bash 窗口，就相当于新建一个非登录 Session，所以~/.bashrc每次都会执行。
注意，执行脚本相当于新建一个非互动的 Bash 环境，但是这种情况不会调用~/.bashrc。
bash命令的 –norc 参数，可以禁止在非登录 Session 执行~/.bashrc脚本。bash --norcbash命令的 –rcfile 参数，指定另一个脚本代替.bashrc。bash --rcfile testrc
bash_logout~/.bash_logout脚本在每次退出 Session 时执行，通常用来做一些清理工作和记录工作，比如删除临时文件，记录用户在本次 Session 花费的时间。
如果没有退出时要执行的命令，这个文件也可以不存在。
小结
全局配置修改 /etc/profile 、/etc/profile.d 和 /etc/bash.bashrc
个人配置修改 ~/.bash_profile 和 ~/.bashrc
~/.bash_profile登录session的初始化脚本，每次登录系统后都会执行它，它会调用bashrc。
~/.bashrc是非登录session的初始化脚本，执行 bash 命令后进入新的bash环境时会执行它。
macos上的初始化脚本是~/.bash_profile，没有~/.bashrc。
一般情况下，修改~/.bash_profile即可，~/.bashrc修改较少。

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>批量重命名和批量替换字符串</title>
    <url>/dev-batch-rename-and-replace/</url>
    <content><![CDATA[前言完成了Hexo添加categories页面，接下里的工作，就是给以前写的文章进行重新分类。以前分为五大类：设计开发、点滴发现、生活札记、精华转载和读者集萃。现在打算分成四大类：随笔（essay）、专业（dev）、英语（en）和爱好（hobby），然后在每个大类下再按需要细分为小类。


分类分类需要修改md文件的文件名和文件内容，面对近五百篇文章，我表示想要放弃。不过，作为一名极客，肯定还是有偷懒的办法的。
批量修改文件名假设要把所有以“disc-”开头的文件改为“dev-”开头，那么在linux下执行命令：
# ubunturename 's/disc-/dev-/' *# centosrename disc- dev- *

批量修改文件内容1、假设我们要把文件中的“设计开发”改为“专业”，那么执行命令：
sed -i "s/设计开发/专业/g" `grep 设计开发 -rl .`

2、假设我们要把文件中的http://7oxjrx.com1.z0.glb.clouddn.com改为http://cdn.voidking.com，那么执行命令：
sed -i "s/http:\/\/7oxjrx.com1.z0.glb.clouddn.com/http:\/\/cdn.voidking.com/g" `grep http:\/\/7oxjrx.com1.z0.glb.clouddn.com -rl .`# 或者sed -i 's!http://7oxjrx.com1.z0.glb.clouddn.com!http://cdn.voidking.com!g' `grep http:\/\/7oxjrx.com1.z0.glb.clouddn.com -rl .`

3、假设我们要把文件中的https://www.voidking.com/2018/06/11/dev-hexo-categories/改为https://www.voidking.com/dev-hexo-categories/，这个就比较难了，可以先进行调试：
grep -P '\d&#123;4&#125;\/\d&#123;2&#125;\/\d&#123;2&#125;\/' -rl .echo "https://www.voidking.com/2018/06/11/dev-hexo-categories/" | sed "s/\d&#123;4&#125;\/\d&#123;2&#125;\/\d&#123;2&#125;\///g"echo "https://www.voidking.com/2018/06/11/dev-hexo-categories/" | sed "s/\([0-9][0-9][0-9][0-9]\)\/\([0-9][0-9]\)\/\([0-9][0-9]\)\///g"

因为grep和sed都不支持完全的正则表达式，所以grep要加P参数，sed要改写正则表达式。最后得到的命令为：
sed -i "s/\([0-9][0-9][0-9][0-9]\)\/\([0-9][0-9]\)\/\([0-9][0-9]\)\///g" `grep -P '\d&#123;4&#125;\/\d&#123;2&#125;\/\d&#123;2&#125;\/' -rl .`

4、假设我们想要把 [专业,运维,nginx] 替换成 [专业,开发,nginx]，那么执行命令（请使用linux而不是mac）：
sed -i "s/专业,开发,nginx/专业,运维,nginx/g" `grep '专业,开发,nginx' -rl .`

后记这个分类过程，花费了很多时间，不过还是值得的。以上分类，看起来就合理了很多。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>shell</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>beego入门篇——上</title>
    <url>/dev-beego-start-0/</url>
    <content><![CDATA[beego简介beego 是一个快速开发 Go 应用的 HTTP 框架，他可以用来快速开发 API、Web 及后端服务等各种应用，是一个 RESTful 的框架，主要设计灵感来源于 tornado、sinatra 和 flask 这三个框架，但是结合了 Go 本身的一些特性（interface、struct 嵌入等）而设计的一个框架。


beego架构beego模块beego 是基于八大独立的模块构建的，是一个高度解耦的框架。当初设计 beego 的时候就是考虑功能模块化，用户即使不使用 beego 的 HTTP 逻辑，也依旧可以使用这些独立模块。这些模块分别是cache、config、context、httplibs、logs、orm、session和toolbox。
beego执行逻辑beego 是一个典型的 MVC 架构，它的执行逻辑如下图所示：
beego项目结构一般的 beego 项目的目录如下所示：
├── conf│   └── app.conf├── controllers│   ├── admin│   └── default.go├── main.go├── models│   └── models.go├── static│   ├── css│   ├── ico│   ├── img│   └── js├── routers│   ├── router.go└── views    ├── admin    └── index.tpl

MVC中的M在models目录、V在views目录、C在controllers目录，main.go是入口文件。
beego安装1、安装beego安装包go get github.com/astaxie/beego
2、安装bee工具命令行执行 go get github.com/beego/bee
3、创建新项目vkbeego命令行执行 bee new vkbeego$GOPATH/src目录下就生成了vkbeego项目。
4、运行项目在vkbeego目录下执行 bee run
5、访问项目浏览器访问 http://localhost:8080
入口文件main.go是beego项目的入口文件，内容为：
package mainimport (    _ "vkbeego/routers"    "github.com/astaxie/beego")func main() &#123;    beego.Run()&#125;
入口文件中引入了routers模块和beego模块，然后在main函数中调用了beego模块的Run()函数。整个初始化过程如下图：
路由路由模块负责路由转发，转发请求给对应的控制器。beego的入口文件中引入了routers模块，查看routers/router.go文件，内容为：
package routersimport (    "vkbeego/controllers"    "github.com/astaxie/beego")func init() &#123;    beego.Router("/", &amp;controllers.MainController&#123;&#125;)&#125;

路由注册beego.Router，这个函数的功能是映射 URL 到 Controller，第一个参数是 URL （用户请求的地址），这里我们注册的是 /，也就是我们访问的不带任何参数的 URL，第二个参数是对应的 Controller，也就是我们即将把请求分发到那个控制器来执行相应的逻辑，我们可以执行类似的方式注册如下路由：
beego.Router("/test", &amp;controllers.TestController&#123;&#125;)

控制器控制器接收到请求后，解析请求参数，负责实现具体的处理逻辑。上面的代码，在router中注册了路由，但是，我们并没有TestController控制器，因此需要创建该控制器。打开controllers/default.go文件，添加：
type TestController struct &#123;    beego.Controller&#125;func (c *TestController) Get() &#123;    c.Data["Website"] = "beego.me"    c.Data["Email"] = "astaxie@gmail.com"    c.Data["IsMale"] = true    c.Data["LuckyNumbers"] = [...]int&#123;0,1,3,4&#125;    c.TplName = "test.tpl"&#125;

新建views/test.tpl文件，内容为：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;Test Page&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

浏览器访问 http://localhost:8080/test ，即可看到“Test Page”。
模板引擎模板引擎负责页面的渲染，比如上面的test.tpl就是一个模板，模板引擎把控制器处理后的数据传递给模板，然后根据模板结构生成html页面。TestController把Website等参数传递给test.tpl，但是test.tpl并没有显示，这里对test.tpl进行改造，显示参数。
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;Test Page&lt;/h2&gt;    &lt;p&gt;Website: &#123;&#123;.Website&#125;&#125;&lt;/p&gt;    &lt;p&gt;Email: &#123;&#123;.Email&#125;&#125;&lt;/p&gt;    &lt;p&gt;        Gender:        &#123;&#123;if .IsMale&#125;&#125;        Male        &#123;&#123;else&#125;&#125;        Female        &#123;&#123;end&#125;&#125;    &lt;/p&gt;    &lt;p&gt;        Lucky Numbers:        &#123;&#123;range .LuckyNumbers&#125;&#125;        &#123;&#123;.&#125;&#125;&amp;nbsp;&amp;nbsp;        &#123;&#123;end&#125;&#125;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

更多详细的模板语法参考beego 模板语法指南。
路径美化以上，已经实现了基本的页面访问逻辑，但是路径不友好，比如所有的路由都写在routers/router.go中，所有的处理逻辑都写在controller/default.go中，所有的模板都写在views路径下。本节中对路径进行美化，使之看起来更加友好合理。假设现在要添加两个路由，分别用来显示登录页面和注册页面。以此为例，说明路径该怎样设计。
总体设计因为登录和注册都属于用户管理，因此可以把它们归类到一个模块user，设计路径结构如下。
vkbeego├─controllers│  │  default.go│  └─user│      login.go│      reg.go├─routers│   router.go│   user.go└─views  │  index.tpl  │  test.tpl  └─user      login.tpl      reg.tpl

路由一个模块对应一个路由文件，因此新建routers/user.go文件，内容为：
package routersimport (    "vkbeego/controllers/user"    "github.com/astaxie/beego")func init() &#123;    beego.Router("/user/login", &amp;user.LoginController&#123;&#125;)    beego.Router("/user/reg", &amp;user.RegController&#123;&#125;)&#125;

控制器一个模块对应一个控制器目录，因此新建controllers/user目录，目录中创建文件login.go和reg.go。
package userimport (    "github.com/astaxie/beego")type LoginController struct &#123;    beego.Controller&#125;func (c *LoginController) Get() &#123;    c.TplName = "user/login.tpl"&#125;

package userimport (    "github.com/astaxie/beego")type RegController struct &#123;    beego.Controller&#125;func (c *RegController) Get() &#123;    c.TplName = "user/reg.tpl"&#125;

当前login.go和reg.go中，只有一个Get请求的控制器，负责页面显示。在实际项目中，这两个文件中还可以添加Post请求的控制器，用来处理Post请求。
模板一个模块对应一个视图目录，因此新建views/user目录，目录中创建文件login.tpl和reg.tpl。
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Login&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;Login Page&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Register&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;Register Page&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

执行命令 bee run，然后就可以浏览器访问URL了。
后记本文中，首先学习了beego的模块构成、执行逻辑和项目结构，然后使用bee工具构建了第一个beego项目vkbeego，接着学习了beego的路由、控制器和模板引擎，最后美化了项目路径。接下来，学习使用beego对数据库进行增删查改。
源码分享：v0.0.0
书签beego官网beego开发文档GoWeb开发实战(Beego框架实现项目)Qihoo360/wayne
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>beego</tag>
      </tags>
  </entry>
  <entry>
    <title>beego入门篇——下</title>
    <url>/dev-beego-start-2/</url>
    <content><![CDATA[前言本文中研究学习beego的静态文件配置使用方法，请求返回值的json化处理，使用goland调试beego框架，数据库从sqlite迁移到mysql。


静态文件配置使用bee工具生成的vkbeego项目，index.tpl中包含css。实际项目中，静态文件是和模板文件分离的，下面分离出index.tpl中的css，改成引用的方式。
1、图片准备index.tpl中的两个base64格式的图片，另存为icon.png和background.png，放到在static/img目录下。
2、在static/css目录下新建index.css文件，内容从index.tpl中拷贝，详见源码v0.0.2。
3、修改views/index.tpl文件为：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;  &lt;title&gt;Beego&lt;/title&gt;  &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"&gt;  &lt;link rel="icon" href="/static/img/icon.png" /&gt;  &lt;link rel="stylesheet" href="/static/css/index.css"&gt;&lt;/head&gt;&lt;body&gt;  &lt;!--keep the same--&gt;&lt;/body&gt;&lt;/html&gt;

启动beego，此时看到的首页和原首页相同。
json处理当今，json已经成为了Web开发中前后端交互的标准格式。本节中修改《beego入门篇——中》一文中的增删查改接口，使返回数据变成json格式。为节省篇幅，下文中省略了文件头部。
1、修改controllers/user/add.go，内容为：
// omit the headfunc (c *AddController) Get() &#123;    var username = c.GetString("username")    fmt.Println(username)    c.Ctx.WriteString("Please add user by post request.")&#125;func (c *AddController) Post() &#123;    var username = c.GetString("username")    var password = c.GetString("password")    var o = orm.NewOrm()    o.Using("default")    exist := o.QueryTable("user").Filter("UserName", username).Exist()    if exist&#123;        c.Data["json"] = map[string]interface&#123;&#125;&#123;"code": 1, "ext": "Username has been existed!"&#125;        c.ServeJSON()        return    &#125;    var user = new(models.User)    user.Username = username    user.Password = password    id,err := o.Insert(user)    if err == nil &#123;        fmt.Println(id)        c.Data["json"] = map[string]interface&#123;&#125;&#123;"code": 0, "userid": id,"ext": "User has been added!"&#125;        c.ServeJSON()    &#125;else &#123;        c.Data["json"] = map[string]interface&#123;&#125;&#123;"code": 2, "ext": "Write to database failed!"&#125;        c.ServeJSON()    &#125;    //c.Ctx.WriteString("add user: " + username)    return&#125;

2、修改controllers/user/list.go，内容为：
// omit the headfunc (c *ListController) Get() &#123;    var o = orm.NewOrm()    o.Using("default")    var qs orm.QuerySeter    qs = o.QueryTable("user")    var users []*models.User    //num, err := qs.All(&amp;users)    num, err := qs.All(&amp;users,"Id", "Username")    fmt.Printf("Returned Rows Num: %d, %s \n", num, err)    fmt.Println(users[0].Username)    c.Data["users"] = users    c.TplName = "user/list.tpl"&#125;func (c *ListController) Post() &#123;    var o = orm.NewOrm()    o.Using("default")    var qs orm.QuerySeter    qs = o.QueryTable("user")    var users []*models.User    //num, err := qs.All(&amp;users)    qs.All(&amp;users,"Id", "Username")    c.Data["json"] = map[string]interface&#123;&#125;&#123;"code": 0, "ext": "success", "userlist": users&#125;    c.ServeJSON()    return&#125;

3、修改controllers/user/update.go，内容为：
// omit the headfunc (c *UpdateController) Post() &#123;    //id,_ := c.GetInt("id")    username := c.GetString("username")    password := c.GetString("password")    new_password := c.GetString("new_password")    var o = orm.NewOrm()    o.Using("default")    exist := o.QueryTable("user").Filter("UserName", username).Exist()    if !exist&#123;        c.Data["json"] = map[string]interface&#123;&#125;&#123;"code": 1, "ext": "Username doesn't exist!"&#125;        c.ServeJSON()        return    &#125;    var user models.User    o.QueryTable("user").Filter("Username",username).Filter("Password",password).One(&amp;user)    if o.Read(&amp;user) == nil &#123;        user.Password = new_password        if num, err := o.Update(&amp;user); err == nil &#123;            if num != 0 &#123;                c.Data["json"] = map[string]interface&#123;&#125;&#123;"code": 0, "ext": "Password has been updated!"&#125;                c.ServeJSON()            &#125;        &#125;    &#125;else &#123;        c.Data["json"] = map[string]interface&#123;&#125;&#123;"code": 2, "ext": "Username or password is wrong!"&#125;        c.ServeJSON()    &#125;    return&#125;

4、修改controllers/user/del.go，内容为：
// omit the headfunc (c *DelController) Get() &#123;    c.Ctx.WriteString("Please use post request.")&#125;func (c *DelController) Post() &#123;    id,_ := c.GetInt("id")    var o = orm.NewOrm()    o.Using("default")    num,err := o.QueryTable("user").Filter("Id",id).Delete()    fmt.Printf("Returned Rows Num: %d, %s \n", num, err)    if num != 0 &#123;        c.Data["json"] = map[string]interface&#123;&#125;&#123;"code": 0, "ext": "User has been deleted!"&#125;        c.ServeJSON()    &#125;else&#123;        c.Data["json"] = map[string]interface&#123;&#125;&#123;"code": 1, "ext": "User Id doesn't exist! Can't delete!"&#125;        c.ServeJSON()    &#125;    return&#125;

修改之后，四个接口都能够返回json格式的数据，使用Postman测试通过，可供js进行调用。
调试以调试controllers/user/add.go中的Post方法为例。1、设置调试环境Run，Edit Configuration，Add New Configuration，Go Build。Run kind选择Directory，Directory、Output directory、Working directory都选择项目目录，OK。点击工具栏的Debug按钮，进入调试模式。
2、在Post方法中添加断点在代码左侧，单击添加断点。
3、测试调试使用Postman，发送Post请求到 http://localhost:8080/user/add ，请求参数包括username和password。查看Goland面板，可以看到面板中显示出了请求的参数等信息。使用F8进入下一步，F7进入函数，Shift+F8退出函数。
数据库迁移前文中，使用sqlite数据库，而在生产环境中，大多是使用mysql。本节中研究学习数据库的迁移，把sqlite数据库中的数据移动到mysql数据库中。
表结构迁移1、创建数据库使用mysql时，beego不会自动生成数据库，因此需要手动创建vkbeego数据库。
2、修改models/model.go文件，修改注册驱动和注册数据库为mysql：
import (    _ "github.com/go-sql-driver/mysql")orm.RegisterDriver("mysql", orm.DRMySQL)orm.RegisterDataBase("default", "mysql", "root:voidking@tcp(192.168.56.104:3306)/vkbeego?charset=utf8")

3、生成表结构运行bee run，即可在beego数据库中生成表结构。
表结构迁移2.01、创建beego/database/migrations/vkbeego.sql文件，内容为：
CREATE TABLE IF NOT EXISTS `user` (    `id` integer NOT NULL PRIMARY KEY AUTOINCREMENT,    `username` varchar(255) NOT NULL DEFAULT '' ,    `password` varchar(255) NOT NULL DEFAULT '' );

2、生成表结构创建数据库，修改models/model.go使用mysql后，执行命令：bee migrate [-driver=mysql] [-conn=&quot;root:voidking@tcp(127.0.0.1:3306)/vkbeego&quot;]
数据迁移sqlite和mysql的SQL语句不兼容，参考sqlite导入到mysql进行数据迁移，此处不再展开。
后记以上，学习了beego静态文件配置、json处理、调试和数据库迁移。beego还有好多内容值得学习，比如模块使用、进程监控、应用部署、第三方库等等，但是入门篇到这里就告一段落，see you。
源码分享：v0.0.2
书签beego官网beego开发文档
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>beego</tag>
        <tag>debug</tag>
      </tags>
  </entry>
  <entry>
    <title>大数据知识结构</title>
    <url>/dev-big-data-structure/</url>
    <content><![CDATA[大数据脑图


大数据云计算1、云服务

SaaS
PaaS
LaaS

2、Openstack
3、Docker
分布式计算1、hadoop

HDFS（分布式文件系统）
Mapreduce（计算框架）
yarn（资源管理平台）
pig（piglatin语句到mapreduce的映射）
hive（数据仓库，提供SQL）
mahout（机器学习算法的mapreduce实现库）

2、spark

RDO
Spark SQL
Spark Streaming（流处理）
MLlib（用于机器学习）

3、storm

Topology
和KAFKA集合

数据分析工具1、R语言2、matlab3、SAS
算法1、机器学习

聚类
时间序列
推荐系统
回归分析
文本挖掘
决策树
支持向量机
贝叶斯分类
神经网络

2、一致性

paxos
raft
gossip

3、数据结构

栈、队列、链表
散列表
二叉树、红黑树、B树
面

4、常用算法

排序
最大子数组
最长公共子序列
最小生成树
最短路径
矩阵的存储和运算

书签大数据资源整理http://www.toutiao.com/i6361620880396648962/
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>图书管理系统之logic</title>
    <url>/dev-bookmanage-logic/</url>
    <content><![CDATA[前言persist层基本搞清楚了，下面我们接着看logic层。
新建工程1、打开Eclipse，File，New，Maven Project，勾选Create a simple project，Next。
2、填写Group Id和Artifact Id，Packaging选择jar。


pom.xml&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;parent&gt;		&lt;groupId&gt;com.voidking.book&lt;/groupId&gt;		&lt;artifactId&gt;book-parent&lt;/artifactId&gt;		&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;		&lt;relativePath&gt;../book-parent/pom.xml&lt;/relativePath&gt;	&lt;/parent&gt;	&lt;artifactId&gt;book-logic&lt;/artifactId&gt;	&lt;dependencies&gt;		&lt;!-- Spring 核心库 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-core&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-orm&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- Spring MVC 库 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt; org.aspectj&lt;/groupId&gt;			&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- persist --&gt;		&lt;dependency&gt;			&lt;groupId&gt;com.voidking.book&lt;/groupId&gt;			&lt;artifactId&gt;book-persist&lt;/artifactId&gt;			&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;		&lt;/dependency&gt;		&lt;!-- 日志打印 --&gt;		&lt;!-- junit --&gt;		&lt;dependency&gt;			&lt;groupId&gt;junit&lt;/groupId&gt;			&lt;artifactId&gt;junit&lt;/artifactId&gt;			&lt;scope&gt;test&lt;/scope&gt;		&lt;/dependency&gt;		&lt;!-- hibernate --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.hibernate&lt;/groupId&gt;			&lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;			&lt;scope&gt;provided&lt;/scope&gt;		&lt;/dependency&gt;	&lt;/dependencies&gt;  &lt;/project&gt;

logic包新建包com.voidking.book.logic，在该包下，新建AdminLogicService.java，内容如下。
package com.voidking.book.logic;import com.voidking.book.entity.Admin;public interface AdminLogicService &#123;		String login(Admin admin);	&#125;
新建BookBaseLogicService.java、BookKindLogicService.java、ReaderBaseLogicService.java、ReaderKindLogicService.java、BorrowInfoLogicService.java、SearchLogicService.java、StatisticsLogicService.java，详细代码移步https://github.com/voidking/bookmanage.git
logic.impl包新建包com.voidking.book.logic.impl，在该包下，新建AdminLogicServiceImpl.java，内容如下。
package com.voidking.book.logic.imp;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import com.voidking.book.entity.Admin;import com.voidking.book.logic.AdminLogicService;import com.voidking.book.repository.AdminRepository;import com.voidking.book.service.AdminService;@Servicepublic class AdminLogicServiceImpl implements AdminLogicService &#123;	@Autowired	private AdminService adminService;		@Autowired	private AdminRepository adminRepository;	public String login(Admin admin) &#123;		if (admin == null) &#123;			return "表现层错误";		&#125;		if (admin.getName() == null || admin.getName().equals("")) &#123;			return "用户名错误";		&#125;		if (admin.getPwd() == null || admin.getPwd().equals("")) &#123;			return "密码错误";		&#125;//		AdminBase tmp = this.adminBaseService.findByNameAndPwd(//				adminBase.getName(), adminBase.getPwd());		Admin tmp = this.adminRepository.findByNameAndPwd(admin.getName(), admin.getPwd());				if (tmp == null) &#123;			return "用户名或者密码错误";		&#125;		admin.setId(tmp.getId());		//this.adminBaseService.save(adminBase);		return "登录成功";	&#125;&#125;
新建BookBaseLogicServiceImpl.java、BookKindLogicServiceImpl.java、ReaderBaseLogicServiceImpl.java、ReaderKindLogicServiceImpl.java、BorrowInfoLogicServiceImpl.java、SearchLogicServiceImpl.java、StatisticsLogicServiceImpl.java，详细代码移步https://github.com/voidking/bookmanage.git
配置文件spring-persist.xml、database-conn.properties、log4j.properties，和persist层相同。
context:component-scan范围book-persist工程下含有com.voidking.book.entity、com.voidking.book.repository、com.voidking.book.service、com.voidking.book.service.impl四个包。book-persist工程中Spring的配置文件，有这么一句：
&lt;context:component-scan base-package="com.voidking.book" /&gt;
这个配置，会自动扫描com.voidking.book包及其子包下的注解，@Repository、@Service、@Controller 和 @Component，并把它们注册为Spring Bean。在book-persist工程中，似乎没有什么问题。
下面注意，问题来了！！！
在book-logic工程中，含有com.voidking.book.logic、com.voidking.book.logic.impl两个包。同时，引入了book-persist打包成的jar文件，jar文件中并没有Spring的配置文件，更没有加载配置文件这一过程。而book-logic工程中Spring的配置文件，也有这么一句：
&lt;context:component-scan base-package="com.voidking.book" /&gt;
这时，请问，这里的com.voidking.book是指在当前工程下，还是jar文件里面，又或是两者都包括？郝同学猜测两者都包括，那么怎么证明？1、由book-persist工程，可以看出，当前工程下的包，是肯定会被扫描的。2、由book-logic工程，可以看出，它使用了jar文件中的类，而且没有“new”，而是“@Autowired”，说明jar包中的包也是会被扫描的。
这时新的问题出现了，book-persist和book-logic这两个工程，是否需要什么必然的要求？比如必须在同一个groupId下面？
答案是没有特殊要求！证明过程如下：1、新建任意Maven工程（以book-jpa为例）。2、在pom.xml中，像book-logic一样，引入book-persist的jar文件。3、拷贝book-logic的Spring配置文件到book-jpa的对应位置。4、在src/test/java下新建任意包，包中新建任意java文件。5、在Test方法中，加载配置文件，使用book-persist中的Bean。最后运行结果和预期一致，答案得证！
总结：context:component-scan扫描的范围包括当前工程和引入的jar文件，而且不要求当前工程和jar文件同处于一个groupId。
单元测试在src/test/java文件夹下，新建包com.voidking.book.logic，新建AdminLogicServiceTest.java文件，内容如下。
package com.voidking.book.logic;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.voidking.book.entity.Admin;public class AdminLogicServiceTest &#123;	private AdminLogicService adminLogicService;	@Before	public void prepare()&#123;		ApplicationContext ctx = new ClassPathXmlApplicationContext("spring-persist.xml");		adminLogicService = ctx.getBean(AdminLogicService.class);	&#125;		@Test	public void testLogin() &#123;		Admin admin = new Admin("haojin","haojin");		System.err.println(this.adminLogicService.login(admin));	&#125;&#125;
其他服务类的测试用例，自行编写。
注：打包jar文件时，src/test/java下的配置文件和src/test/resources下的类，不会被打包。
后记没有人能随随便便成功，踏踏实实，一点一滴。。。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建自己的云盘服务</title>
    <url>/dev-build-owncloud/</url>
    <content><![CDATA[前言
继华为、迅雷、新浪，115等网盘之后，近日360云盘也宣布关闭个人云存储服务。这场发起于2013年的个人网盘大战至今，排名靠前的常用网盘已经只剩下百度云盘和腾讯微云，真是令人唏嘘不已……

360云盘即将停止服务，所有用户数据将只保存到明年2月1日，可怜我的38T数据！！！首先，没有硬盘存储这么多数据，只能选择下载；其次，大家争相下载，360云盘限速，怎一个慢字了得！
考虑到别人的云盘不靠谱，郝同学决定自己搭建一个。


ubuntu安装owncloud1、安装lamp-server，tasksel install lamp-server，报错tasksel: apt-get failed (100)。就知道不会一帆风顺，先更新个软件源，apt-get update，然而，接着报错：E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?
删除两个文件：
rm /var/cache/apt/archives/lockrm /var/lib/dpkg/lock

再次更新软件源，apt-get update，再次安装lamp-server，tasksel install lamp-server。
2、下载安装owncloud
wget -nv https://download.owncloud.org/download/repositories/9.1/Ubuntu_16.04/Release.key -O Release.keyapt-key add - &lt; Release.keysh -c "echo 'deb http://download.owncloud.org/download/repositories/9.1/Ubuntu_16.04/ /' &gt; /etc/apt/sources.list.d/owncloud.list"apt-get updateapt-get install owncloud

3、访问owncloud访问http://192.168.56.102/owncloud，进入owncloud初始页面。
安装到这一步就完成了，已经可以通过服务器使用ownCloud的服务来存储同步分享文件了。
绑定域名在/etc/apache2/sites-available文件夹下添加新的虚拟主机配置文件，备份000-default.conf文件，然后在其中添加：
&lt;VirtualHost *:80&gt;  ServerName yun.voidking.com  DocumentRoot /var/www/owncloud  &lt;IfModule mod_headers.c&gt;    Header always set Strict-Transport-Security "max-age=15552000; includeSubDomains; preload"  &lt;/IfModule&gt;&lt;/VirtualHost&gt;
然后域名解析yun.voidking.com到服务器ip地址。
安装插件ubuntu安装ftp服务，apt-get install vsftpd。vi /etc/vsftpd.conf，启用如下配置：
write_enable=YESlocal_umask=022utf8_filesystem=YES
然后service vsftpd restart。
下载owncloud的插件，下载的压缩包解压到/var/www/owncloud/apps，然后在浏览器中打开owncloud，选择应用页面，启用插件。离线下载：https://apps.owncloud.com/content/show.php/ocDownloader+%28NG%29?content=169974
在线看视频：https://apps.owncloud.com/content/show.php/Video+Viewer+Plus?content=174666
书签云盘一个个倒下怎么办？无需编码，手把手教你搭建至尊私享云盘https://zhuanlan.zhihu.com/p/23156514
天下没有免费的午餐！是时候搭建起自己的云盘服务了https://zhuanlan.zhihu.com/p/23179293
owncloud-fileshttp://download.owncloud.org/download/repositories/9.1/owncloud/
Installation Wizardhttps://doc.owncloud.org/server/9.1/admin_manual/installation/installation_wizard.html
ownCloud Applicationshttps://apps.owncloud.com/
客户端https://owncloud.org/install/#install-clients
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建个人网站之概述</title>
    <url>/dev-build-personal-website-start/</url>
    <content><![CDATA[搭建个人网站之概述每个学计算机的小伙伴，都想过搭建个人网站吧？毕竟，这是一件拉风的事情。也有几个学弟向我请教过，一个个教，很麻烦。在此，写一篇短文，给后来者扫平一些障碍。
不喜欢使用各种拗口的术语，尽量举例、类比、比喻、画图，说的不够专业的地方，小伙伴们见谅！
域名voidking.com、baidu.com、qq.com、jd.com、csdn.net等等，这些，就是所谓的顶级域名。在浏览器地址栏，输入这些域名，就能访问到相应的网站。简单介绍一下原理：访问请求先被发送到DNS服务器，然后这些域名会被解析成IP地址，实际访问的，就是IP地址。

没有域名可不可以做网站？可以！但是，访问的时候就麻烦了。一些服务器，会提供给你二级域名，比如voidking.gitcafe.com；而另外一些，只能通过IP地址访问，非常不人道！所以，想做网站的小伙伴，先注册个域名吧，这笔投资不要省！也许若干年后，你的域名会被十倍百倍的价格收购，或者成为一个品牌！
注册域名的网站很多，国内，最欣赏万网；国外，最欣赏godaddy。这两个网站，都使用过，相较而言，还是万网更适合国内用户。
前些年，万网的问题较多，我对它也存在一些质疑。但是，现在，万网在阿里旗下，无论是其访问速度、安全性、解析速度、迁移、客服等方面，都做的非常好。
godaddy的口碑非常好，很多前辈都推荐。但是个人体验发现，godaddy的访问速度和万网相比就是个渣，这让国内的我难以忍受。另外，域名解析界面真心难找，解析速度也没有万网快。值得夸奖的是，客服很有水平。还记得，曾经遇到域名消失问题，在我的poor English描述下，客服帮助我完美解决了问题！
总而言之，在哪注册域名都可以，个人推荐万网。
服务器没有域名，别人可以访问到你的网站，但是没有服务器，就真的不行了！除非你打算只是局域网使用！服务器的用途，除了部署你的网站外，还可以部署很多其他服务。
使用过很多服务器，简单描述一下它们！
免费服务器BAE、CAE、GAE、JAE、SAE等等，之前都是免费的，现在，只有GAE、JAE、SAE还算得上免费。他们的用法比较死板，基本都是建立某个类型的应用，然后把代码部署上去。重点在于免费，或者免费一段时间，对于学生党，还是值得花时间研究一下的。
此外，openshift空间也不错，但是国内的访问速度，实在是无法忍受！曾经搭建过一个wordpress项目，那速度。。。还是先去泡杯茶吧。。。
还有heroku、appfog、mongolab等等。
收费服务器收费的服务器，那就多了去了。推荐阿里云，使用中，各项性能都很满意。各种集成系统镜像可供选择，安全性也很好。而且，备案服务做得非常好！突然感觉自己有做广告的嫌疑，阿里云没给我钱，我是不是吃亏了？
备案为什么需要备案？证明你的网站是合法的！万一犯了事，方便抓捕。。。我不会告诉你，使用国外空间不要备案；我更不会告诉你，国内空间想要使用域名，必须备案！
不久前，万网备案系统和阿里云备案系统合一，备案要求也更加严格。曾经备案过两次，每次需要的时间，前前后后大概半个月。
技术难度系数从高到低：全部自己做 &gt; hexo &gt; octopress &gt; wordpress。
全部自己做自己做网站，可以选各种语言，后台Jave EE、JSP、ASP、PHP、Node.js等等，前台Html/XHtml、CSS、JavaScript、JQuery、AngularJs等等。自己做网站，适合计算机专业的小伙伴。
hexo这是一个静态化博客系统，也就是说，它的页面只需要html，不需要服务器的编译，不需要数据库等。现在你看到的这篇小文，就是使用hexo做的。准确的说，这并不是一个网站，只是一个个人主页。可以存储在github、gitcafe，或者任何可访问的空间。
octopress这也是一个静态化博客系统。并没有使用过这个博客系统，但是网上教程很多，口碑不错哦！也可以存储在任何可访问的空间。
wordpress非常强大的一个博客系统，主题非常多，总有一款适合你。甚至，可以做企业官网！
小结这篇文章，没有展开论述每一个点，有不懂的地方，百度会告诉你答案。同时欢迎大家留言讨论，一定尽快回复！
参考文档2014年十大优秀免费空间排行http://www.freehao123.com/2014-top-ten-web-hosting/

使用github + Octopress 搭建免费博客http://www.yanjiuyanjiu.com/blog/20130401/http://www.tuicool.com/articles/QRBFB3

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>网站</tag>
        <tag>域名</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS安装Apache和PHP环境</title>
    <url>/dev-centos-apache-php/</url>
    <content><![CDATA[前言《在CentOS7上配置PHP运行环境》一文中，已经配置好了PHP环境。但是，Nginx和PHP的配合不是很好，所以，郝同学决定在原本的环境中加入Apache。



安装Apache1、安装apacheyum install httpd
2、查看httpd安装位置rpm -ql httpd
3、启动apachesystemctl restart httpd.service
如果启动失败，很有可能是因为80端口被占用。此时，需要修改监听端口。cd /etc/httpd/conf， vim httpd.conf，找到 Listen 80，修改为 Listen 8080。
4、设置开机启动systemctl enable httpd.service
5、测试访问访问地址 http://host_ip:8080，即可看到“Testing 123”。
cd /var/www/html，vim index.html，输入hello。
再次访问 http://host_ip:8080，即可看到“hello”。
PS：如果无法访问，请先关闭防火墙。systemctl stop firewalld.service ，关闭防火墙。
systemctl disable firewalld.service ，禁止开机启动。
安装php5.6能不能使用原来环境中的php和apache配合？理论上是能的，但是配置麻烦，郝同学决定再安装一个php。
如果直接执行yum install php，centos7默认安装php5.4版本。如果需要安装更高版本，我们需要如下操作。
1、追加epel及remi源
rpm -Uvh http://ftp.iij.ad.jp/pub/linux/fedora/epel/7/x86_64/e/epel-release-7-10.noarch.rpmrpm -Uvh http://rpms.famillecollet.com/enterprise/remi-release-7.rpm

2、确认安装的php版本yum list --enablerepo=remi --enablerepo=remi-php56 | grep php
如果报错，就先执行yum install epel-release
3、安装php5.6
yum install --enablerepo=remi --enablerepo=remi-php56 php php-opcache php-pecl-apcu php-devel php-mbstring php-mcrypt php-mysqlnd php-phpunit-PHPUnit php-pecl-xdebug php-pecl-xhprof php-pdo php-pear php-fpm php-cli php-xml php-bcmath php-process php-gd php-common

4、确认php版本php -v
5、查看php安装位置rpm -ql php
whereis php
which php
php配置文件的默认位置为/etc/php.ini
Apache使用PHP1、重启apachesystemctl stop httpd.service
systemctl start httpd.service
2、在/var/www/html，新建文件index.php，内容如下：
&lt;?php    echo 'hello php5.6';?&gt;

3、测试访问访问地址 http://host_ip:8080/index.php，即可看到“hello php5.6”。
书签如何搭建lamp(CentOS7+Apache+MySQL+PHP)环境
Install Apache, PHP And MySQL On CentOS 7 (LAMP)
在CentOS7.0安装php5.6
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>apache</category>
        <category>centos</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>php</tag>
        <tag>centos</tag>
        <tag>yum源</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7搭建Atlassian Jira</title>
    <url>/dev-centos-atlassian-jira/</url>
    <content><![CDATA[前言Jira是Atlassian公司出品的项目与事务跟踪工具，被广泛应用于缺陷跟踪（bug管理）、客户服务、需求收集、流程审批、任务跟踪、项目跟踪和敏捷管理等工作领域。
写完了《自动部署工具Jenkins》和《CentOS7搭建Confluence Wiki》，感觉有些缺憾，决定把Jira的搭建方法也记录一下。


准备下载软件包开始搭建Jira前，需要下载一些软件包。

atlassian-jira-software-7.2.2-x64
JIRA Core-7.2.1-language-pack-zh_CN
mysql-connector-java-5.1.39-bin
atlassian-extras-3.1.2

安装配置javayum install javajava -version

安装配置mysql1、安装mysql后，登录mysql控制台，执行如下命令：
create database jira default character set utf8;grant all on jira.* to 'jirauser'@'%' identified by 'jirapasswd' with grant option;grant all on jira.* to 'jirauser'@localhost identified by 'jirapasswd' with grant option;flush privileges;

2、进入/usr/local/mysql文件夹，在my.cnf中添加：
binlog_format=mixed

3、重启mysql
service mysqld stopservice mysqld start

关闭防火墙systemctl stop firewalld.service


详细步骤安装jira1、使用xftp，上传atlassian-jira-software-7.2.2-x64.bin到/root文件夹。
2、上传完成后，执行命令：
chmod 755 atlassian-jira-software-7.2.2-x64.bin./atlassian-jira-software-7.2.2-x64.bin
jira默认安装到/opt/atlassian/jira和/var/atlassian/application-data/jira目录下，并且jira监听的端口是8080。
3、jira的主要配置文件，是/opt/atlassian/jira/conf/server.xml。
4、此时不要测试访问，切记。
破解jira1、关闭jira
/etc/init.d/jira stop

2、把atlassian-extras-3.1.2.jar和mysql-connector-java-5.1.39-bin.jar两个文件上传到/opt/atlassian/jira/atlassian-jira/WEB-INF/lib/里。其中atlassian-extras-3.1.2.jar是用来替换原来的atlassian-extras-3.1.2.jar文件，用作破解jira系统的；mysql-connector-java-5.1.39-bin.jar是用来连接mysql数据库的驱动软件包。
3、启动jira
/etc/init.d/jira start

4、测试访问，假设CentOS7的ip地址为192.168.56.101，那么在浏览器输入http://192.168.56.101:8080，即可看到jira的安装页面。
5、选择I’ll set it up myself，然后“Next”，进入数据库设置页面。
6、选择MySQL数据库，输入安装配置mysql中设置的账号和密码。点击“Test Connection”，确认数据库连接是否成功。 
7、点击“Next”，向数据库写入数据，这一步花费时间较长，请耐心等待。数据库的配置文件，是/var/atlassian/application-data/jira/dbconfig.xml
8、报错。
9、忽略以上错误，重启jira服务。
/etc/init.d/jira start/etc/init.d/jira stop

10、再次访问http://192.168.56.101:8080，进入jira配置页面。
试用jira1、选择Private模式，在这个模式下，用户需要由管理员创建。而在Public模式下，用户可以自己进行注册。
2、点击generate a JIRA trial license，登录atlassian，获取试用license。
3、获取license后在这个页面查看。
4、拷贝license，粘贴到jira配置页面，“Next”。
5、再次报错，不过不要放弃。
6、重启，再次拷贝license，粘贴到jira配置页面，“Next”。
配置管理员1、上一步后，成功进入管理员配置页。
2、配置管理员后，下一步进入邮件设置页面。
3、点击“Finish”，进入欢迎页面。
4、创建新项目，选择Scrum software development，“Next”。
5、稍等片刻，便会跳转到管理页面。
查看破解点击右上角齿轮形状的管理图标，选择“Applications”，查看破解信息。可以看到，到期日期是2033年2月8日，破解成功。
汉化1、点击右上角齿轮形状的管理图标，选择“Add-ons”，再选择“Manage add-ons”。
2、点击“Upload add-on”，选择上传JIRA Core-7.2.1-language-pack-zh_CN.jar。
3、依次点击“System”，“Edit Settings”。
4、找到Internationalization，修改Indexing language和Default language为中文，修改Default user time zone为亚洲上海。然后点击页面底部的“Update”按钮。
后记至此，jira破解和汉化完成。虽然中途有些波折，但总归是安装成功了，吼吼！
书签烂泥：jira7.2安装、中文及破解http://blog.chinaunix.net/uid-21710354-id-5756990.html
jira下载页https://www.atlassian.com/software/jira/download
jira语言包下载页https://translations.atlassian.com/dashboard/download?lang=zh_CN#/JIRA Core/7.2.1
JIRA数据库切换（HSQL Database到MySQL）http://www.tuicool.com/articles/7feMjqy
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>jira</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7搭建Confluence Wiki</title>
    <url>/dev-centos-confluence-wiki/</url>
    <content><![CDATA[前言在艾佳生活实习时，有三款团队协作系统特别喜欢：Wiki、Jira和Jenkins。对于Jenkins的搭建，之前《自动部署工具Jenkins》有过记录。这次，搭建一个Wiki，作为知识管理的工具，实现团队成员之间的协作和知识共享。


准备下载软件包开始搭建Wiki前，需要下载一些软件包。

atlassian-confluence-5.6.6-x64
Confluence-5.6.6-language-pack-zh_CN
mysql-connector
confluence_keygen

安装配置javayum install javajava -version

安装配置mysql1、安装mysql后，登录mysql控制台，执行如下命令：
create database confluence default character set utf8;grant all on confluence.* to 'confluenceuser'@'%' identified by 'confluencepasswd' with grant option;grant all on confluence.* to 'confluenceuser'@localhost identified by 'confluencepasswd' with grant option;flush privileges;

2、进入/usr/local/mysql文件夹，在my.cnf中添加：
binlog_format=mixed

3、重启mysql
service mysqld stopservice mysqld start

关闭防火墙systemctl stop firewalld.service


详细步骤安装confluence1、使用xftp，上传atlassian-confluence-5.6.6-x64.bin到/root文件夹。
2、上传完成后，执行命令：
chmod 755 atlassian-confluence-5.6.6-x64.bin./atlassian-confluence-5.6.6-x64.bin
confluence默认安装到/opt/atlassian/confluence和/var/atlassian/application-data/confluence目录下，并且confluence监听的端口是8090。
3、confluence的主要配置文件，存放在/opt/atlassian/confluence/conf/server.xml文件中。
4、测试访问，假设CentOS7的ip地址为192.168.56.101，那么在浏览器输入http://192.168.56.101:8090，即可看到Confluence的欢迎界面。
破解confluence1、点击“Start setup”，看到如下界面。
2、复制Server ID并保存，然后关闭confluence。
/etc/init.d/confluence stop

3、从/opt/atlassian/confluence/confluence/WEB-INF/lib中，拷贝atlassian-extras-decoder-v2-3.2.jar到windows，并重命名为atlassian-extras-2.4.jar。
4、在windows下，生成License Key。
java -jar confluence_keygen.jar
把第二步中复制的Server ID粘贴进去，然后点击“.gen!”，保存生成的key。
5、打补丁。点击“.patch!”，选择第3步中重命名的atlassian-extras-2.4.jar，会生成新的atlassian-extras-2.4.jar。
6、上传新的atlassian-extras-2.4.jar、Confluence-5.6.6-language-pack-zh_CN.jar、mysql-connector-java-5.1.39-bin.jar到/opt/atlassian/confluence/confluence/WEB-INF/lib，并且删除atlassian-extras-decoder-v2-3.2.jar。
5、启动confluence
/etc/init.d/confluence start

7、把生成的key复制粘贴到License Key框中，点击“Next”，如果顺利进入选择数据库页面，说明破解成功。
配置数据库1、数据库选择MySQL，然后点击“External Database”，进入数据库配置页面。
2、点击“Direct JDBC”，User Name和Password填写安装配置mysql中设置的用户名和密码。
3、点击“Next”，这一步花费时间较长，请耐心等待。数据写入成功，进入如下页面。
4、第3步如果报错，请检查mysql数据库配置，然后卸载后重新安装，卸载命令如下。
/etc/init.d/confluence stopcd /opt/atlassian/confluence/./uninstall
或者：
/etc/init.d/confluence stoprm -rf /opt/atlassian/rm -rf /var/atlassian/

配置管理员初始化一个样例站点，根据提示进行配置。
书签wiki系统confluence5.6.6安装、中文、破解及迁移http://www.ilanni.com/?p=11989
confluence wiki搭建使用http://www.cnblogs.com/guigujun/p/6137673.html
confluence下载页https://www.atlassian.com/software/confluence/download-archives
confluence语言包下载页https://translations.atlassian.com/dashboard/download?lang=zh_CN#/Confluence/6.1.0
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
        <category>工具</category>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS安装多版本MySQL</title>
    <url>/dev-centos-multiple-mysql/</url>
    <content><![CDATA[前言卓音工作室的服务器中，已经安装了MySQL5.7。但是，confluence和jira不支持MySQL5.7，为了安装这两款软件，必须安装MySQL5.6或更低的版本。


安装详解安装开发包yum -y install wget gcc-c++ ncurses ncurses-devel cmake make perl bison openssl openssl-devel gcc* libxml2 libxml2-devel curl-devel libjpeg* libpng* freetype* --setopt=protected_multilib=false

下载MySQL搜狐镜像：http://mirrors.sohu.com/mysql/MySQL-5.6/选择下载：mysql-5.6.34.tar.gz
安装前准备1、创建一个Mysql用户，useradd mysql。
2、新建mysql下data和log子目录
mkdir -p /usr/local/mysql&#123;3306,3307&#125;/data            mkdir -p /usr/local/mysql&#123;3306,3307&#125;/log

3、修改目录的所属者以及所属组权限 
chown -R mysql:mysql /usr/local/mysql&#123;3306,3307&#125;/data/  chown -R mysql:mysql /usr/local/mysql&#123;3306,3307&#125;/log/  chmod 750 /usr/local/mysql&#123;3306,3307&#125;/data        chmod 750 /usr/local/mysql&#123;3306,3307&#125;/log

4、创建mysql相关目录并配置权限
mkdir -p /usr/local/mysql&#123;3306,3307&#125;/etc  chown -R mysql.mysql /usr/local/mysql&#123;3306,3307&#125;/etc  mkdir -p /var/run/mysqld&#123;3306,3307&#125;  chown -R mysql.mysql /var/run/mysqld&#123;3306,3307&#125;  mkdir -p /var/lib/mysqld&#123;3306,3307&#125;  chown -R mysql.mysql /var/lib/mysqld&#123;3306,3307&#125;

5、创建mysql.sock文件
touch /tmp/mysql&#123;3306,3307&#125;.sock

解压MySQL1、使用xftp上传mysql-5.6.34.tar.gz到CentOS服务器。2、tar -zxvf mysql-5.6.34.tar.gz，解压mysql。
编译安装MySQL1、cd mysql-5.6.34，进入mysql源文件目录。2、配置编译。
cmake \-DCMAKE_INSTALL_PREFIX=/usr/local/mysql3307 \-DMYSQL_DATADIR=/usr/local/mysql3307/data \-DSYSCONFDIR=/usr/local/mysql3307/etc \-DWITH_MYISAM_STORAGE_ENGINE=1 \-DWITH_INNOBASE_STORAGE_ENGINE=1 \-DWITH_MEMORY_STORAGE_ENGINE=1 \-DWITH_READLINE=1 \-DMYSQL_TCP_PORT=3307 \-DENABLED_LOCAL_INFILE=1 \-DWITH_PARTITION_STORAGE_ENGINE=1 \-DEXTRA_CHARSETS=all \-DDEFAULT_CHARSET=utf8 \-DDEFAULT_COLLATION=utf8_general_ci \-DMYSQL_USER=mysql \-DWITH_DEBUG=0 \-DWITH_SSL=system

3、编译安装
makemake install
这一步时间较长，请耐心等待。
配置MySQL1、拷贝模板，作为配置文件。
cp /usr/local/mysql3307/support-files/my-default.cnf /usr/local/mysql3307/etc/my.cnf

2、设置开机启动。
cp /usr/local/mysql3307/support-files/mysql.server /etc/init.d/mysqld3307


3、修改my.cnf
# For advice on how to change settings please see# http://dev.mysql.com/doc/refman/5.6/en/server-configuration-defaults.html# *** DO NOT EDIT THIS FILE. It's a template which will be copied to the# *** default location during install, and will be replaced if you# *** upgrade to a newer version of MySQL.[mysqld]# Remove leading # and set to the amount of RAM for the most important data# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.# innodb_buffer_pool_size = 128M# Remove leading # to turn on a very important data integrity option: logging# changes to the binary log between backups.# log_bin# These are commonly set, remove the # and set as required.basedir = /usr/local/mysql3307datadir = /usr/local/mysql3307/dataport = 3307# server_id = .....socket = /tmp/mysql3307.sock# Remove leading # to set options mainly useful for reporting servers.

4、初始化mysql数据库。
/usr/local/mysql3307/scripts/mysql_install_db --basedir=/usr/local/mysql3307 --datadir=/usr/local/mysql3307/data --user=mysql


启动MySQL1、启动mysqlservice mysqld3307 start
2、设置超级管理员密码/usr/local/mysql3307/bin/mysqladmin -u root password voidking -S /tmp/mysql3307.sock
3、登录mysqlmysql -u root -p -S /tmp/mysql3307.sock，然后输入密码voidking，成功登录mysql5.6。
至此，多版本mysql安装配置成功！
远程连接1、关闭防火墙systemctl stop firewalld.service
2、登录mysql控制台：mysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;voidking&#39; with grant option;
3、远程连接测试方案一：使用navicat等图形化工具。方案二：使用mysql命令，比如mysql -h 192.168.56.101 -P 3307 -u root -pvoidking
书签MySQL之——Centos中安装多个mysql数据库的配置实例http://blog.csdn.net/l1028386804/article/details/48368937
centos6.5 MySQL多实例安装与配置http://jingyan.baidu.com/article/9faa723187a5ab473c28cba8.html
centos编译安装mysql 5.6及安装多个mysql实例http://blog.chinaunix.net/xmlrpc.php?r=blog/article&amp;uid=29792372&amp;id=5759878
centos7安装运行多个mysql实例笔记https://my.oschina.net/hollowj/blog/796146
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>centos</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7设置mysql开机自启动</title>
    <url>/dev-centos-mysql-autostart/</url>
    <content><![CDATA[yum安装mysql参考《CentOS 7.0下使用yum安装MySQL》，安装步骤如下：
1、下载mysql的repo源wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm
2、安装mysql-community-release-el7-5.noarch.rpm包rpm -ivh mysql-community-release-el7-5.noarch.rpm
安装这个包后，会获得两个mysql的yum repo源：/etc/yum.repos.d/mysql-community.repo，/etc/yum.repos.d/mysql-community-source.repo。


3、安装mysqlyum install mysql-server
4、登录mysqlmysql -u root
登录时报错：ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2)原因是/var/lib/mysql的访问权限问题，解决办法是把/var/lib/mysql的拥有者改为当前用户，并重启服务：
chown -R root:root /var/lib/mysqlservice mysqld restart
5、重置密码，设置远程访问，参考《MySQL重置密码》
PS：查看mysql版本mysql -V
这种方法安装的mysql，默认自启动。
手动安装mysql手动安装mysql的方法，参考《CentOS安装多版本MySQL》。设置自启动的方法（也适用于CentOS6），参考《MySQL—-【开机自启】Linux下设置MySql自动启动》。
1、将服务文件拷贝到init.d下，并重命名为mysqlcp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
2、赋予可执行权限chmod +x /etc/init.d/mysqld
3、添加服务chkconfig --add mysqld
4、显示服务列表chkconfig --list
如果看到mysql的服务，并且3、4、5都是on的话则成功。如果是off，则执行chkconfig --level 345 mysql on
5、重启电脑reboot
6、验证netstat -na | grep 3306
如果看到有监听说明服务启动了。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>centos</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS下Mysql数据库导出和导入</title>
    <url>/dev-centos-mysql-dump-source/</url>
    <content><![CDATA[前言mysql数据库导出和导入，在使用navicat等图形化管理工具的情况下很方便。但是，学校服务器上3306端口禁止远程访问，所以，我们只能采用如下两种方案：

在shell中导出导入
安装phpmyadmin



使用shell导出假设我们要导出的数据库名为vkphp。
mysqldump -uroot -ppassword vkphp &gt; /root/vkphp.sql
执行该命令，则会在/root目录下导出vkphp.sql文件。
导入1、使用xftp上传vkphp.sql到/root目录下。
2、登录mysql
mysql -u root -p
3、新建数据库CREATE DATABASE vkphp DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;
PS：删除数据库DROP DATABASE vkphp;
4、导入数据use vkphp;
source /root/vkphp.sql;
使用phpmyadmin安装phpmyadmin1、到phpmyadmin官网下载phpmyadmin源码，比如phpMyAdmin-4.7.4-all-languages.tar.gz。
2、上传phpMyAdmin-4.7.4-all-languages.tar.gz到/root目录下。
3、解压安装tar -xvf phpMyAdmin-4.7.4-all-languages.tar.gz
mv phpMyAdmin-4.7.4-all-languages phpmyadmin
mv phpmyadmin [web_path]，web_path是web根目录，比如/home/wwwroot。
4、配置
cd /home/wwwroot/phpmyadmin/libraries
vim config.default.php
// localhost =&gt; 127.0.0.1$cfg['Servers'][$i]['host'] = '127.0.0.1';$cfg['Servers'][$i]['user'] = 'root';$cfg['Servers'][$i]['password'] = 'password';

nginx配置1、在phpmyadmin目录中mkdir log
touch log/phpmyadmin-nginx.log
2、查找php-cgi.sockfind / -name &#39;php-cgi.sock&#39;
看到的结果为/tmp/php-cgi.sock
3、在nginx的conf/vhost目录中，新建phpmyadmin.voidking.com.conf，内容如下：
server &#123;    listen 80;    server_name  phpmyadmin.voidking.com;    root /home/wwwroot/phpmyadmin;  access_log  /home/wwwroot/phpmyadmin/log/phpmyadmin-nginx.log  main;    set $php_upstream 'unix:/tmp/php-cgi.sock';    location / &#123;     index index.php;    &#125;      location ~ \.php$ &#123;       fastcgi_pass   $php_upstream;      fastcgi_index  index.php;      fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;      include     fastcgi_params;    &#125;      location ~ /\.ht &#123;      deny  all;    &#125;  &#125;

4、重启nginx./nginx -t
./nginx -s reload
如果报错 nginx: [emerg] unknown log format &quot;main&quot; in... ，那么最简单的方法是去掉main。
access_log  /home/wwwroot/phpmyadmin/log/phpmyadmin-nginx.log;
5、在万网添加域名解析phpmyadmin。
6、测试访问 http://phpmyadmin.voidking.com
导出导入1、登录phpmyadmin。
2、进入vkphp数据库。
3、单击导航栏“导出”，格式选择SQL，执行。即可导出sql文件到本地。
4、单击导航栏“导入”，选择文件，执行。但是，最大文件限制为50MB。此时，我们需要修改php.ini和nginx.conf。
（1）查找php.ini和nginx.conffind / -name &#39;php.ini&#39;
find / -name &#39;nginx.conf&#39;
（2）编辑php.inivim /usr/local/php/etc/php.ini
输入/upload，查找“upload”的位置，按N键跳转下一个匹配。
修改upload_max_filesize和post_max_size为
upload_max_filesize = 500Mpost_max_size = 500M

（3）编辑nginx.confvim /usr/local/nginx/conf/nginx.conf
修改client_max_body_size为
client_max_body_size 500m

（4）重启php/etc/init.d/php-fpm restart
（5）重启nginx./nginx -t
./nginx -s reload
5、再次查看最大文件限制，就变成了500MB。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>centos</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mysql</tag>
        <tag>phpmyadmin</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>在CentOS7上配置PHP运行环境</title>
    <url>/dev-centos-php-envirenment/</url>
    <content><![CDATA[前言阿里云到期了，穷人买不起服务器，以后只能在虚拟机中练手了。VMware和VirtualBox都很好用，VMware可以安装MacOS，VirtualBox更轻量。
CentOS7安装到了VirtualBox中，下面，来学习配置一下PHP的运行环境。假设采用桥接，CentOS7的IP地址为192.168.1.114。



php环境配置常用的PHP环境为LAMP和LNMP，这次郝同学选择LNMP，也就是Linux、Nginx、Mysql和PHP。听说EZHTTP可以简化安装配置过程，尝试一下。
安装screen(可选)由于编译安装Nginx Apache PHP MySQL等软件会花费比较长的时间，难免会出现由于网络意外中断而导致安装也中断了，所以为了避免此问题，可以用screen来安装。yum install -y screen
安装unzip和wget执行ezhttp安装程序，至少需要unzip及wget工具。yum install -y wget unzip
安装gityum install -y git
安装EZHTTPgit clone https://github.com/centos-bz/ezhttp.gitcd ezhttpchmod +x start.sh./start.sh
软件选择问题，参见书签中《使用EZHTTP安装LNMP(Nginx MySQL PHP) 》。网络条件良好的话，一个小时左右就可以安装完成。
测试在浏览器地址栏输入http://192.168.1.114，可以看到，EZHTTP已经安装成功。
上传thinkphp1、下载thinkphp，解压到thinkphp_3.2.3_full。2、重命名thinkphp_3.2.3_full文件夹为thinkphp。3、利用xftp上传thinkphp文件夹到/home/wwwroot目录下。
测试在浏览器栏输入http://192.168.1.114/thinkphp/，可以看到，thinkphp已经可以访问。
后记再次启动centos，利用ip add命令查看到ip地址，在浏览器地址栏输入该ip地址。然后，神奇的事情发生了——网站无法访问！打开命令提示符，ping该ip，提示“无法访问目标主机”。
解决办法：关闭centos防火墙，执行命令systemctl stop firewalld.service。
书签在CentOS上搭建PHP服务器环境
EZHTTP使用教程
EZHTTP安装前准备工作
使用EZHTTP安装LNMP(Nginx MySQL PHP)
EZHTTP相关进程管理及目录位置
LAMP一键安装包
LNMP一键安装包
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>centos</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS安装配置pyenv</title>
    <url>/dev-centos-pyenv/</url>
    <content><![CDATA[pyenv简介pyenv使我们可以轻松地在多个版本的Python之间切换。它用法简单，遵循UNIX的一站式工具传统，可以很好地完成不同Python版本之间的切换。与之类似的，还有Anaconda。
更多内容参考Simple Python Version Management和Command Reference。


pyenv安装1、安装pyenv套装curl -L https://raw.githubusercontent.com/pyenv/pyenv-installer/master/bin/pyenv-installer | bash内容除了包含 pyenv 以外，还包含如下插件：

pyenv-doctor
pyenv-installer
pyenv-update
pyenv-virtualenv
pyenv-which-ext

2、路径添加vim ~/.bash_profile，添加：
export PATH="/root/.pyenv/bin:$PATH"eval "$(pyenv init -)"eval "$(pyenv virtualenv-init -)"

3、使配置立即生效source ~/.bash_profile
4、查看安装情况pyenv -v
5、常用命令

查看可安装的python版本列表：pyenv install -l
安装指定版本的python：pyenv install 3.6.1
查看已安装的python：pyenv versions
查看当前设为默认的python版本：pyenv version

使用pyenv安装python3.61、配置pyenv下载源为本地目录（可选操作，不做的话下载速度会很慢）
mkdir /root/python/ &amp;&amp; cd /root/python/# 设置变量export PYTHON_BUILD_CACHE_PATH=/root/python# 设置变量export PYTHON_BUILD_MIRROR_URL=/root/python# 查看变量设置env | grep PYTHON_BUILD_MIRROR_URLwget https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tar.xz

2、安装python3.6.1，pyenv install 3.6.1报错，ERROR: The Python ssl extension was not compiled. Missing the OpenSSL lib? 需要安装依赖包：
yum install readline readline-devel readline-static -yyum install openssl openssl-devel openssl-static -yyum install sqlite-devel -yyum install bzip2-devel bzip2-libs -y

3、改变全局版本pyenv global 3.6.1，python -V
附：改变回原版本pyenv global system，python -V
4、刷新数据库python rehash
使用pyenv安装python2.71、配置pyenv下载源为本地目录
mkdir /root/python/ &amp;&amp; cd /root/python/# 设置变量export PYTHON_BUILD_CACHE_PATH=/root/python# 设置变量export PYTHON_BUILD_MIRROR_URL=/root/python# 查看变量设置env | grep PYTHON_BUILD_MIRROR_URLwget https://www.python.org/ftp/python/2.7.13/Python-2.7.13.tar.xz

2、安装python2.7.13pyenv install 2.7.13
3、改变全局版本pyenv global 2.7.13，python -V
4、刷新数据库python rehash
pyenv实战《Django部署到线上》《Django部署到线上（修改版）》
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>python</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>centos</tag>
        <tag>pyenv</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS的一些技巧</title>
    <url>/dev-centos-skill/</url>
    <content><![CDATA[安装中文输入法1、安装中文支持包yum install &quot;@Chinese Support&quot;
2、回到桌面，system-&gt;preferences-&gt;input method
3、如果没有，先注销一下。


4、到里面add输入法到列表里。
5、最后再注销、登录。
在centOS 6.4下面测试无误。
挂载NTFS有时候做大数据量迁移时，为了快速迁移大数据，有可能在Linux服务器上临时挂载NTFS格式的移动硬盘， 一般情况下，Linux是识别不了NTFS格式移动硬盘的（需要重编译Linux核心才能，加挂NTFS分区），这时候为了能让Linux服务器能够识别NTFS的移动硬盘，就必须安装ntfs-3g（Third Generation Read/Write NTFS Driver）的包。
官方网址：http://www.tuxera.com/文档手册：http://www.tuxera.com/community/ntfs-3g-manual/下载地址：http://www.tuxera.com/community/ntfs-3g-download/
1、解压安装NTFS-3G。
tar -xvzf ntfs-3g_ntfsprogs-2012.1.15.tgzcd ntfs-3g_ntfsprogs-2012.1.15./configure make make install

之后系统会提示安装成功，下面就可以用ntfs-3g来实现对NTFS分区的读写了
2、配置挂载NTFS格式的移动硬盘（1）首先得到NTFS分区的信息sudo fdisk -l | grep NTFS
（2）设置挂载点，用如下命令实现挂载mount -t ntfs-3g &lt;NTFS Partition&gt; &lt;Mount Point&gt;
例如得到的NTFS分区信息为/dev/sdc1，挂载点设置在/mnt/usb下，可以用mount -t ntfs-3g /dev/sdc1 /mnt/usb或者直接用ntfs-3g ntfs-3g /dev/sdc1 /mnt/usb 
3、如果想实现开机自动挂载，可以在/etc/fstab里面添加如下格式语句
&lt;NTFS Partition&gt; &lt;Mount Point&gt; ntfs-3g silent,umask=0,locale=zh_CN.utf8 0 0

这样可以实现NTFS分区里中文文件名的显示。 
4、卸载分区可以用umount实现umount &lt;NTFS Partition&gt;或者 　　umount &lt;Mount Point&gt;
U盘安装最近要给服务器重装系统，由于使用dvd安装刻盘比较麻烦，所以决定采用U盘安装，U盘下安装CentOS/Red Hat比较麻烦，相对于Ubuntu来说要麻烦很多（Ubuntu只需要使用Universal USB Installer即可，非常简单），此方法经过本人亲测，真实有效。
这里选择在windows下使用UltraISO进行安装，建议使用bin DVD版的CentOS，不用live版本的，同时我们需要一个8GB及以上容量的U盘，因为完整版的安装包需要4G，加上启动引导部分，4G的U盘是不够的。这里简单介绍一下原理，首先使用UltraISO将DVD版的iso镜像写入U盘来制作启动盘，然后将完整的CentOS的DVD版安装iso复制到U盘根目录，待安装程序启动之后有一步会提示寻找安装镜像，选择U盘对应的目录就能找到。
具体步骤：1、下载UltraISO，选择“文件”-&gt;“打开”，找到CentOS安装文件，我的为CentOS-6.3-x86_64-bin-DVD1.iso（iso格式的）
2、选择“启动”-&gt;“写入硬盘映像…”，“硬盘驱动器”选择要安装的U盘，“写入方式”选择“USB-HDD+”，在这之前最好将U盘格式化，默认的为FAT32，最后选择“写入”，再选择“是”即可，具体过程见下图。
3、在U盘写入完毕之后，打开U盘，将Packages目录全部删除，其实那4G的安装镜像大部分都是相关系统软件以及服务的安装包，这里我们只是制作U盘引导系统安装，所以Packages目录不需要，删除之后再将CentOS-6.3-x86_64-bin-DVD1.iso复制到U盘的根目录即可。
将U盘插上电脑选择U盘启动之后就可以参考网上大量的安装步骤，不过这里有一点要注意的是：从U盘启动之后U盘被系统识别为/dev/sda，而电脑的SATA硬盘被识别为/dev/sdb。因此到了有一步让你选择安装镜像(install image)的时候请选择sda（即U盘），后面要求选择安装引导程序的时候请安装在SATA硬盘对应的设备名称上，否则如果选择安装在U盘上了之后拔掉U盘就不能启动系统了。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS安装配置Supervisor</title>
    <url>/dev-centos-supervisor/</url>
    <content><![CDATA[Supervisor简介Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。
更多参考Supervisor官网和Supervisor使用详解。
Supervisor安装本文中，在CentOS7系统上安装配置Supervisor。
1、安装
# 方法一yum install epel-releaseyum install supervisor# 方法二yum install python-pippip install supervisor

2、创建sock
touch /tmp/supervisor.sockchmod 777 /tmp/supervisor.sock

3、开机启动systemctl enable supervisord
4、生成配置文件
mkdir -p /etc/supervisor/echo_supervisord_conf &gt; /etc/supervisord.conf

5、修改配置文件，vim /etc/supervisord.conf，添加：
[include]files = /etc/supervisor/*.conf

6、运行
systemctl start supervisord# orsupervisor -c /etc/supervisord.conf

常用命令# 重启supervisorsystemctl retart supervisord# 重启被管理的服务supervisorctl -c /etc/supervisord.conf restart service_name# 查看被管理的服务状态supervisorctl status

Supervisor安装2.0参考《CentOS安装配置pyenv》，安装好python2.7.13。
1、新建supervisor虚拟环境pyenv virtualenv 2.7.13 supervisor
2、激活虚拟环境source /root/.pyenv/versions/2.7.13/envs/supervisor/bin/activate supervisor或者source activate supervisor
3、安装supervisoryum install supervisorpip install supervisor
4、生成配置文件
mkdir -p /etc/supervisor/echo_supervisord_conf &gt; /etc/supervisord.conf

5、修改配置文件vim /etc/supervisord.conf，添加：
[include]files = /etc/supervisor/*.conf

6、运行/root/.pyenv/versions/2.7.13/envs/supervisor/bin/supervisord -c /etc/supervisord.conf
7、编辑supervisord.servicevi /usr/lib/systemd/system/supervisord.service，修改为：
[Unit]Description=Process Monitoring and Control DaemonAfter=rc-local.service nss-user-lookup.target[Service]Type=forkingExecStart=/root/.pyenv/versions/2.7.13/envs/supervisor/bin/supervisord -c /etc/supervisord.conf  ExecReload=/root/.pyenv/versions/2.7.13/envs/supervisor/bin/supervisorctl reload       ExecStop=/root/.pyenv/versions/2.7.13/envs/supervisor/bin/supervisorctl shutdown      [Install]WantedBy=multi-user.target

8、重启supervisor
ps aux | grep supervisordsystemctl stop supervisordsystemctl start supervisord

9、开机启动systemctl enable supervisord
Supervisor实战管理tomcat参考《CentOS7设置tomcat开机自启动》。
管理Jupyter参考《CentOS安装配置Jupyter》。
管理Django参考Django部署到线上（修改版）。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>centos</tag>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7设置tomcat开机自启动</title>
    <url>/dev-centos-tomcat-autostart/</url>
    <content><![CDATA[安装tomcat首先参考《全平台安装JDK》，安装配置好JDK，然后按照下面的流程安装tomcat。
1、下载tomcat8.0.50wget http://www-eu.apache.org/dist/tomcat/tomcat-8/v8.0.50/bin/apache-tomcat-8.0.50.tar.gz
2、解压tomcat到/opt目录tar -xzvf apache-tomcat-8.0.50.tar.gz -C /opt
3、启动tomcatcd /opt/apache-tomcat-8.0.50/bin/
./startup.sh


4、测试访问curl localhost:8080至此，遇到一个大坑。curl命令卡在那里不动了，浏览器访问也是一直转圈，转啊转，十几分钟了还在转。。。莫非，tomcat版本有问题？换了8.5.29，不行；换了7.0.85，不行。莫非是jdk版本有问题？毕竟第一次是使用yum命令安装的。换了1.8.0_161，依然不行。
好在，最终找到了答案：Centos7+Tomcat8配置javaweb环境，tomcat启动巨慢的问题，安装rng服务。
（1）安装熵服务yum install rng-tools（2）启动服务systemctl start rngd然后，tomcat就启动成功了。（3）赶紧把rng服务放进开机自启动systemctl enable rngd
5、关闭tomcat。./shutdown.sh
设置开机自启动参考《在CentOS7中设置Tomcat开机自启动》，设置步骤如下：
假设tomcat目录为/opt/apache-tomcat-8.0.50
1、为Tomcat添加启动参数
catalina.sh在执行的时候会调用同级路径下的setenv.sh来设置额外的环境变量，因此在/opt/tomcat/bin路径下创建setenv.sh文件，内容如下：
# 设置JAVA_HOMEexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_161export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATHexport CATALINA_HOME=/opt/apache-tomcat-8.0.50export CATALINA_BASE=/opt/apache-tomcat-8.0.50# 设置Tomcat的PID文件CATALINA_PID="$CATALINA_BASE/tomcat.pid"# 添加JVM选项JAVA_OPTS="-server -XX:PermSize=256M -XX:MaxPermSize=1024m -Xms512M -Xmx1024M -XX:MaxNewSize=256m"

2、在/usr/lib/systemd/system路径下添加tomcat.service文件，内容如下：
[Unit]Description=tomcatAfter=syslog.target network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/opt/apache-tomcat-8.0.50/tomcat.pidExecStart=/opt/apache-tomcat-8.0.50/bin/startup.shExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target

3、把tomcat加入开机自启动systemctl enable tomcat.service
4、重启服务器reboot
5、再次连接后，查看服务状态systemctl status tomcat.service
看到tomcat已经启动，正想着大功告成，却发现浏览器访问又开始转圈了。检查rng服务，启动正常。直接使用./startup.sh启动正常，而使用systemctl start tomcat就转圈，还能是什么原因？参照《CentOS7下Tomcat启动慢的原因及解决方案》一文，修改java.security，无效；修改catalina.sh，无效。是不是tomcat.service写的有问题，参照其他配置方案修改，依然无效。想到《Dockerfile使用Supervisor管理Tomcat》一文中，supervisor启动tomcat也会有些问题。那么，修改startup.sh呢？依然无效。
万万没想到，最后一步还有这么个深坑，沉思良久，莫非，要换init.d方法来设置启动？目前看来，只能这样了。
删除开机自启动1、删除tomcat.servicefind / -name &quot;tomcat*&quot;rm /usr/lib/systemd/system/tomcat.servicerm /etc/systemd/system/multi-user.target.wants/tomcat.servicerm /etc/selinux/targeted/active/modules/100/tomcat
2、测试启动systemctl daemon-reloadsystemctl start tomcat.service出现提示Failed to start tomcat.service: Unit not found.说明删除成功。
设置开机自启动之init.d1、在/etc/init.d下创建服务脚本vim /etc/init.d/tomcat写入内容如下：
#!/bin/bash## tomcat startup script for the Tomcat server### chkconfig: 345 80 20# description: start the tomcat deamon## Source function library. /etc/rc.d/init.d/functionsprog=tomcat# 根据自己的路径改写JAVA_HOMEJAVA_HOME=/usr/lib/jvm/jdk1.8.0_161/  export JAVA_HOME# 根据自己的路径改写CATALANA_HOMECATALANA_HOME=/opt/apache-tomcat-8.0.50/   export CATALINA_HOMEcase "$1" instart)    echo "Starting Tomcat..."    $CATALANA_HOME/bin/startup.sh    ;;stop)    echo "Stopping Tomcat..."    $CATALANA_HOME/bin/shutdown.sh    ;;restart)    echo "Stopping Tomcat..."    $CATALANA_HOME/bin/shutdown.sh    sleep 2    echo    echo "Starting Tomcat..."    $CATALANA_HOME/bin/startup.sh    ;;*)    echo "Usage: $prog &#123;start|stop|restart&#125;"    ;;esacexit 0

2、更改权限chmod a+x /etc/init.d/tomcat
3、测试启动service tomcat start启动成功，然而，还是转圈。。。
实际上，init.d方法添加的自启动服务，也会加入到systemctl的管理。因为，这时也可以用systemctl start tomcat来启动服务。
无奈，决定换成supervisor来设置自启动。
设置开机自启动之supervisor开始设置前最好先删除init.d方法设置的自启动文件，虽然不影响使用，但是看着闹心。参考《CentOS安装配置Supervisor》，安装配置好supervisor。
1、在/etc/supervisor中新建tomcat.conf文件
[program:tomcat]directory=/opt/apache-tomcat-8.0.50command=/opt/apache-tomcat-8.0.50/bin/catalina.sh runenvironment=JAVA_HOME="/usr/lib/jvm/jdk1.8.0_161",JAVA_BIN="/usr/lib/jvm/jdk1.8.0_161/bin"user=rootautostart=trueautorestart=truestdout_logfile=/var/log/supervisor/%(program_name)s.logstderr_logfile=/var/log/supervisor/%(program_name)s.log

2、重启supervisorsystemctl retart supervisord
3、重启tomcatsupervisorctl -c /etc/supervisord.conf restart tomcat
4、测试访问curl localhost:8080，成功。浏览器访问，成功。换了三种自启动方式，总算成功了，不容易。。。
5、重启reboot
6、二次测试重启后执行supervisorctl status，tomcat正常运行。curl命令和浏览器测试，正常。至此，tomcat自启动配置成功。其实，systemd和init.d两种方法，理论上也是可以成功的，访问转圈的锅肯定是机器和系统的。嗯，就是这样。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>centos</category>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>centos</tag>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS6.8上Python2.6.6升级Python2.7.15</title>
    <url>/dev-centos68-python26-to-python27/</url>
    <content><![CDATA[前言
Python 2.6 is no longer supported by the Python core team, please upgrade your Python.

虽然Python2.6已经不再维护，但是CentOS6.8系统里默认的Python版本依然是2.6.6。这就很尴尬了，要么凑合用，但是没有pip命令，常规安装pip的方法还会失败。要么进行升级，但是整个过程很麻烦。本文记录一下2.6.6凑合用的方法，以及升级2.7.15的方法。


凑合用参考python2.6安装pip。
curl https://bootstrap.pypa.io/2.6/get-pip.py -o get-pip.pypython get-pip.py

升级参考centos6.5升级到python2.7。
1、安装编译依赖
yum -y install gcc openssl-devel bzip2-devel

2、下载安装包并解压
cd /optwget https://www.python.org/ftp/python/2.7.15/Python-2.7.15.tgztar xvzf Python-2.7.15.tgz

3、安装
cd Python-2.7.15./configure --enable-optimizationsmake &amp;&amp; make altinstall
configure时加上enable-optimizations，启用PGO优化，让Python在运行时能变得更快。make 加altinstall参数，避免覆盖原来安装在/usr/bin/python 的版本。
4、检查安装/usr/local/bin/python2.7 -V
5、修改系统默认python
mv /usr/bin/python /usr/bin/python2.6.6 ln -s /usr/local/bin/python2.7 /usr/bin/python

6、解决yum不支持python2.7的问题sed -i &#39;s/python/python2.6.6/&#39; /usr/bin/yum
7、安装pip
python -m ensurepippip -V

或者：
wget https://bootstrap.pypa.io/get-pip.pypython get-pip.py -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com

以上，升级完成。
报错解决pippip -V 如果报错：pkg_resources.DistributionNotFound: The ‘pip==7.1.0’ distribution was not found and is required by the application
那么根据 python -m ensurepip 输出的版本，修改 /usr/bin/pip 文件里pip的版本。这里我的输出为 pip-9.0.3 ，那么修改结果如下：
#!/usr/bin/python# EASY-INSTALL-ENTRY-SCRIPT: 'pip==7.1.0','console_scripts','pip'__requires__ = 'pip==9.0.3'import sysfrom pkg_resources import load_entry_pointif __name__ == '__main__':    sys.exit(        load_entry_point('pip==9.0.3', 'console_scripts', 'pip')()    )

再次执行 pip -V ，即可看到升级后的pip版本。
easy_installeasy_install -h 如果报错：pkg_resources.DistributionNotFound: The ‘distribute==0.6.10’ distribution was not found and is required by the application
那么安装distribute模块：
wget https://pypi.python.org/packages/source/d/distribute/distribute-0.6.10.tar.gztar -zxvf distribute-0.6.10.tar.gzcd distribute-0.6.10python setup.py install
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>centos</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7部署beego项目</title>
    <url>/dev-centos7-beego-env/</url>
    <content><![CDATA[前言《beego入门篇——上、中、下》三篇文章中，记录了beego的基本用法。假设已经完成了beego项目的代码，此时我们需要把项目部署到服务器上，本文就研究一下怎样在CentOS7环境里部署beego服务。


环境安装golang安装golang，主要参考centos7安装golang环境。
1、golang官网查找安装包
2、安装golangwget https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz
3、解压至/usr/local目录tar -C /usr/local -xzf go1.12.7.linux-amd64.tar.gz
4、配置环境变量vim /etc/profile，添加：
export GOROOT=/usr/local/goexport GOPATH=$HOME/goexport PATH=$PATH:$GOROOT/bin:$GOPATH/bin

source /etc/profile使修改生效。
5、查看安装
go versiongo env

beego安装1、安装beegogo get -v github.com/astaxie/beego
如果下载缓慢，可以设置GOPROXY。
export GOPROXY=https://goproxy.ioexport GO111MODULE=on

2、安装bee工具go get -v github.com/beego/bee
3、创建测试项目testbee new test
4、运行项目
cd $GOPATH/src/testbee run

5、访问项目curl http://localhost:8080
数据库依赖1、安装go-sqlite3
go get -v github.com/mattn/go-sqlite3

部署项目测试项目1、下载vkbeego
cd $GOPATH/src/git clone https://github.com/voidking/vkbeego.git

2、运行项目
cd vkbeegobee run
第一次运行后会在项目下生成db.sqlite3文件，里面是user表。如果已经有了db.sqlite3文件，则会进行校验。或者使用bee migrate命令生成表结构，具体参考bee 工具命令详解。
3、访问项目curl http://localhost:8080
其他机器如果无法访问，就先关闭防火墙。systemctl stop firewalld
编译部署1、编译命令go build项目下生成名为vkbeego的二进制文件。
2、运行项目./vkbeego
3、后台运行nohup ./vkbeego &gt; nohup.out 2&gt;&amp;1 &amp;
4、关闭fg，然后Ctrl+C。
以上，就在CentOS7上部署好了beego项目。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>golang</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>beego</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7更换软件安装源</title>
    <url>/dev-centos7-change-repo/</url>
    <content><![CDATA[前言之前整理过《Ubuntu更换源列表》，更换了软件安装源，可以加快软件的安装速度。同样的，在CentOS下也需要更换一下软件安装源。主要参考CentOS7系统更换软件安装源。


更换方法1、备份原安装源cp /etc/yum.repos.d/CentOS-Base.repo{,.bak}
2、下载阿里云的安装源
wget http://mirrors.aliyun.com/repo/Centos-7.repomv Centos-7.repo /etc/yum.repos.d/Centos-Base.repo

常用的安装源还有：

网易镜像 http://mirrors.163.com/
搜狐镜像 http://mirrors.sohu.com/

其他安装源参考《开源镜像站》。
3、更新安装源
yum clean allyum makecache

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装配置GitLab</title>
    <url>/dev-centos7-install-gitlab/</url>
    <content><![CDATA[GitLab简介GitLab是GitLab公司开发的基于Rails的开源存储库管理器。它是一个基于Web的git存储库管理器，允许团队协作编写、测试和部署应用程序。GitLab提供了多种功能，包括wiki、问题跟踪、代码审查和活动源。GitLab Inc提供4种产品：

Gitlab CE（社区版）：自托管和免费，社区论坛的支持。
Gitlab EE（企业版）：自托管和付费，附带其他功能。
GitLab.com：SaaS和免费。
GitLab.io：由GitLab Inc.管理的私有GitLab实例。

在本文中，我们将在具有2GB RAM的CentOS7服务器上逐步安装GitLab CE（Community Edition），服务器IP为192.168.56.103。


环境准备首先安装GitLab依赖的相关软件。
1、软件安装yum -y install curl policycoreutils openssh-server openssh-clients postfix
2、postfix设置开机自启动
systemctl start postfixsystemctl enable postfixsystemctl status postfix

安装GitLab1、添加GitLab CE repositorycurl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash
2、安装gitlabyum -y install gitlab-ce软件642M，需要下载一会，耐心等待，安装完成会出现提示。
3、配置gitlab urlvim /etc/gitlab/gitlab.rb，修改external_url为：
external_url 'http://gitlab.voidking.com'

使gitlab配置生效，gitlab-ctl reconfigure。但是，这个命令执行时间特别久，因此建议在安装的时候就指定external_url：EXTERNAL_URL=&quot;http://gitlab.voidking.com&quot; yum -y install gitlab-ce
4、开放端口
firewall-cmd --add-port=80/tcp --permanentfirewall-cmd --add-port=443/tcp --permanentsystemctl reload firewalld

5、测试访问浏览器访问 http://192.169.56.103 ，即可跳转到gitlab登录页面。重置密码之后，使用root用户登录，即可进行项目管理。
6、域名访问修改本机host，添加：
192.168.56.103  gitlab.voidking.com
然后就可以通过域名访问gitlab了，奇怪的是，域名哪怕不是设置成external_url中的url，也可以通过域名访问。
添加SSL生成SSL参考安装及使用mkcert在Linux和macOS中创建本地受信任的SSL证书和mkcert githut，安装mkcert并使用它生成SSL证书。
1、安装nss-tools工具yum install nss-tools
2、下载二进制包wget -O mkcert https://github.com/FiloSottile/mkcert/releases/download/v1.3.0/mkcert-v1.3.0-linux-amd64
3、添加执行权限并移入bin
chmod +x  mkcertmv mkcert /usr/local/bin

4、获取CA根目录mkcert -CAROOT
5、安装本地CAmkcert -install，输出：
Using the local CA at "/root/.local/share/mkcert" ✨The local CA is now installed in the system trust store! ⚡ERROR: no Firefox and/or Chrome/Chromium security databases foundThe local CA is now installed in Java's trust store! ☕

6、生成证书mkcert gitlab.voidking.com localhost 127.0.0.1，输出：
Using the local CA at "/root/.local/share/mkcert" ✨Warning: the local CA is not installed in the Firefox and/or Chrome/Chromium trust store! ⚠Run "mkcert -install" to avoid verification errors ‼ Created a new certificate valid for the following names 📜 - "gitlab.voidking.com" - "localhost" - "127.0.0.1"The certificate is at "./gitlab.voidking.com+2.pem" and the key at "./gitlab.voidking.com+2-key.pem" ✅

7、创建证书目录并且移动证书
mkdir -p /etc/gitlab/ssl/mv gitlab.voidking.com* /etc/gitlab/ssl/

生成DHPARAM1、使用OpenSSL生成DHPARAM证书pem文件openssl dhparam -out /etc/gitlab/ssl/dhparams.pem 2048
2、将证书文件的权限更改为600chmod 600 /etc/gitlab/ssl/dhparams.pem
使用1、修改gitlab urlvim /etc/gitlab/gitlab.rb，如下修改：
external_url 'https://gitlab.voidking.com'nginx['redirect_http_to_https'] = truenginx['ssl_certificate'] = "/etc/gitlab/ssl/gitlab.voidking.com+2.pem"nginx['ssl_certificate_key'] = "/etc/gitlab/ssl/gitlab.voidking.com+2-key.pem"nginx['ssl_dhparam'] = "/etc/gitlab/ssl/dhparams.pem"

2、重新配置gitlabgitlab-ctl reconfigure
3、测试访问服务器上测试，curl localhost -L，正常。本地浏览器访问 https://gitlab.voidking.com/users/sign_in ，出现安全提示。这是因为，这是因为浏览器不信任刚才自建的CA，解决办法是安装rootCA，更多内容参考https 以及内网如何使用。 
4、下载rootCA.pem从/root/.local/share/mkcert目录中下载rootCA.pem到本地。
5、Chrome添加证书设置，高级设置，管理证书，导入，选择rootCA.pem，证书存储选择受信任的根证书颁发机构，完成，出现警告点确定。重启Chrome，再次访问就没有警告了。
6、Firefox添加证书选项，隐私与安全，证书，查看证书，导入，选择rootCA.pem。重启Firefox，再次访问就没有警告了。
7、创建项目Create a Project，Project name填入voidking，选择Public，勾选Initialize repository with a README。
8、clone项目
git config --global http.sslVerify falsegit clone https://gitlab.voidking.com/root/voidking.git

9、上传代码
# 添加test.txt文件git add .git commit -m "add new file"git push
查看项目，代码已经上传成功。
错误排查关闭服务器之后重启，发现无法访问gitlab服务。1、关闭防火墙
systemctl stop firewalldsystemctl disable firewalld
关闭防火墙之后，依然无法访问。
2、查看服务和端口
ps aux | grep nginxnetstat -nlpt | grep 80
没有找到nginx服务，说明nginx出了问题。gitlab-ctl restart nginx，无效，80端口依然没有监听。
3、查看gitlab日志gitlab-ctl tail这次定位到了问题，缺少pem文件。
2019-08-06_09:26:08.31983 nginx: [emerg] BIO_new_file("/etc/gitlab/ssl/gitlab.voidking.com+2.pem") failed (SSL: error:02001002:system library:fopen:No such file or directory:fopen('/etc/gitlab/ssl/gitlab.voidking.com+2.pem','r') error:2006D080:BIO routines:BIO_new_file:no such file)

查看/etc/gitlab/ssl/目录，发现gitlab.voidking.com+2.pem变成了gitlab.voidking.com+3.pem！虽然不知道为什么2变成了3，但是改回来应该就可以了。改回原文件名，问题解决。
后记至此，局域网的gitlab安装配置完成，可以正常使用了。在公网环境下，配置更加简单，gitlab.rb中配置公认的证书颁发机构颁发的SSL证书即可，SSL证书的申请可以参考《Hexo启用https加密连接》。
书签How to Install and Configure GitLab CE on CentOS 7
How to Install and Configure GitLab on CentOS 7
CentOS 7 搭建CA认证中心实现https取证
Https原理及流程
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>git</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装SVN</title>
    <url>/dev-centos7-install-svn/</url>
    <content><![CDATA[SVN简介Apache Subversion 通常被缩写成 SVN，是一个开放源代码的版本控制系统，Subversion 在 2000 年由 CollabNet Inc 开发，现在发展成为 Apache 软件基金会的一个项目，拥有丰富的开发者和用户社区。
SVN相对于的RCS、CVS，采用了分支管理系统，它的设计目标是取代CVS。互联网上免费的版本控制服务大多基于Subversion。
本文中，在CentOS7中安装配置SVN。


安装SVN1、安装SVN：
yum install subversionsvnserve --version

2、创建版本库：
mkdir -p /var/svn/svnrepossvnadmin create /var/svn/svnrepos

3、进入conf目录（该svn版本库配置文件），cd /var/svn/svnrepos/conf。

authz文件是权限控制文件
passwd是帐号密码文件
svnserve.conf SVN服务配置文件

4、设置帐号密码，vi passwd。在[users]块中添加用户和密码，格式：帐号=密码，如voidking=woaixuexi。
### This file is an example password file for svnserve.### Its format is similar to that of svnserve.conf. As shown in the### example below it contains one section labelled [users].### The name and password for each user follow, one account per line.[users]# harry = harryssecret# sally = sallyssecretvoidking=woaixuexi

5、设置权限，vi authz。在末尾添加如下代码：
[/]voidking=rw
意思是版本库的根目录quwenzhe对其有读写权限。
6、修改svnserve.conf文件，vi svnserve.conf。打开下面的几个注释：
anon-access = read #匿名用户可读auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为账号文件authz-db = authz #使用哪个文件作为权限文件realm = /var/svn/svnrepos # 认证空间名，版本库所在目录

7、启动svn版本库，svnserve -d -r /var/svn/svnrepos。（停止SVN命令，killall svnserve）
8、使用SVNWindows上右键，SVN Checkout。
书签CentOS 7搭建SVN服务器
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome插件开发基础</title>
    <url>/dev-chrome-extension-start/</url>
    <content><![CDATA[前言前些天，小伙伴问我会不会开发chrome插件。突然意识到，这是个有趣的事情，那就搞一搞。
最开始想做一个批量下载图片插件，很快找到一个fatkun。做一个视频广告屏蔽插件？太难，放弃。要不做一个翻墙插件？更难，放弃。做一个划词翻译插件怎么样？已经有了Google翻译和划词翻译。做一个页面截图插件？已经有了捕捉网页截图 - FireShot的。做一个markdown编辑器？已经有了Markdown Here。
果然是前人种树，后人没地种哇！后来想做一个柯林斯词典翻译，然而没有平台提供这个词典的接口，唯一的办法是抓取百度翻译的页面，然后截取结果。太麻烦，还要搭个服务器。
最终，决定做一个获取公网IP的插件。开发工具：sublime；开发语言：html+css+js。


官方入门demo目录结构chrome-extention-start|-icon.png|-manifest.json|-popup.html|-popup.js
其中，icon.png是插件的图标；manifest.json是插件的配置文件；popup.html是单击插件图标后弹出的页面；popup.js是业务处理的js。
启用插件访问chrome://extensions，勾选开发者模式，加载已解压的扩展程序，选择chrome-extention-start文件夹。
试用官方给出的效果是这样的：
郝同学满怀期待打开YouTube，结果是这样的：不要在意这些细节，至少第一个插件已经跑起来了！
查询公网IPmanifest.json&#123;  "manifest_version": 2,  "name": "Public IP",  "description": "This extension shows your public IP",  "icons": &#123;    "16": "icon_16.png",    "48": "icon_48.png",    "64": "icon_64.png",    "128": "icon_128.png"  &#125;,  "version": "1.0",  "browser_action": &#123;    "default_icon": "icon_19.png",    "default_title": "查看公网IP",    "default_popup": "popup.html"  &#125;,  "permissions": [    "http://ip.chinaz.com/getip.aspx"  ]&#125;
需要注意的是，permissions中的url是允许跨域的。
popup.js$(function()&#123;  String.prototype.replaceAll  = function(s1,s2)&#123;         return this.replace(new RegExp(s1,"gm"),s2);       &#125;  $.ajax(&#123;    url: 'http://ip.chinaz.com/getip.aspx',    type: 'GET',    data: &#123;&#125;,    success: function(data)&#123;      console.log(data);      data = data.replace("ip","'ip'");      data = data.replace("address","'address'");      data = data.replaceAll("\'","\"");      console.log(data);      var dataJson = JSON.parse(data);      $('#ip').val(dataJson.ip);      $('#address').val(dataJson.address);    &#125;,    error: function(xhr)&#123;      console.log(xhr);    &#125;  &#125;);  &#125;);



效果
发布插件的发布非常简单，上传项目的zip压缩包之后，填写一些信息即可。但是，想要获得发布插件的权限，非常麻烦，具体我会在后记部分吐槽。
本地插件安装假设电脑被墙，又需要安装Chrome插件，那么下载crx文件，然后在Chrome地址栏输入chrome://extensions/，并将下载的crx拖入该页面即可。
后记谷歌，你妹！这特么歧视也太明显了吧！大陆开发者，无法发布应用。要想发布，只能使用除了中国大陆外的信用卡支付！我*&amp;……%￥#@！
历经波折，终于拿到一张全球付的卡。然而由于激动，进错了页面，到了Google Play的支付页面，填写信息时居然有中国的选项，理所当然选了中国，填了真实信息。
后来，发现进错页面，回到开发者信息中心，却再也无法点出付款的页面！！！当我转到google payment center，却提示遇到了一个问题！What the fuck！这是摆明了不给修改的机会哇！
万般无奈，注册了小号，才支付成功。最后，附上插件链接：https://chrome.google.com/webstore/detail/public-ip/cdpgbfmmhnbmkdnhlgjpbjdgblggnhck
书签Getting Started: Building a Chrome Extensionhttps://developer.chrome.com/extensions/getstarted
360极速浏览器应用开放平台http://open.chrome.360.cn/extension_dev/overview.html
Chrome扩展技术手册http://crxdoczh.readthedocs.io/en/latest/
Chrome扩展及应用开发（首发版）http://www.ituring.com.cn/book/1421
如何从零开始写一个 Chrome 扩展？https://www.zhihu.com/question/20179805
2016年最实用的七款chrome浏览器“神器”级别插件http://mt.sohu.com/20160621/n455512782.shtml
如何发布一款Chrome Apphttps://segmentfault.com/a/1190000000354014
发布了几个自己制作的Chrome插件http://www.jianshu.com/p/NpjteJ
Chrome插件（Extensions）开发攻略http://www.cnblogs.com/guogangj/p/3235703.html
Google Play Developer Consolehttps://play.google.com/apps/publish/signup/
开发者信息中心https://chrome.google.com/webstore/developer/dashboard/
Google payment centerhttps://payments.google.com/payments/home#settings
全球付 -国际购物-在线消费新体验https://www.globalcash.hk/index-welcome.do
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络摘要（杨鲲教授）</title>
    <url>/dev-computer-network/</url>
    <content><![CDATA[前言英国essex大学杨鲲教授，给我们上了一周的计算机网络课程，收获了很多“common sense”。以下简单记录一下，备忘。


三个重要概念协议协议即约定，对等层之间的约定。
服务相邻两层之间，下层为上层提供服务。
地址网卡地址、IP地址、网址等等。
网络分层分几层不重要，为什么分层？
拿到协议、设备、地址，先看在哪一层。
TCP和UDPTCP可靠，有连接。
UDP实时，没必要重传，无连接。
socketsocket，套接字，48位。IP（32位）+ 端口号（16位） = 48位。
其他多用图片，解释原理。
大学里，最重要的是收获“common sense”。
优等生和差生，最大的区别，在于思考问题的方式。优等生不是为了研究而研究，而是为了解决问题而研究。而差生，在论文中用了很多方法，但是连问题是什么都没搞清楚。很多时候，提出问题比解决问题更重要。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>人脉管理系统功能需求（二）</title>
    <url>/dev-connection-management-system-feature-request-2/</url>
    <content><![CDATA[名片1、扫描纸质名片，生成电子名片
2、输入信息，制作电子名片
3、名片可以发送给他人，当两个人或者更多人距离比较近时，一个人点击发送名片，其他人保持接收名片状态，就可以实现名片的发送。
4、名片同步。当他人的名片发生变化时，用户点击名片同步到本地，就可以从服务器获取最新的名片信息；当自己的名片、自己制作的名片、自己添加的名片附加信息发生变化时，用户点击名片同步到云端，就可以在服务器端变更数据。PS：每个用户ID和自己的名片ID相同。

5、名片附加信息。朋友的生日、朋友的纪念日、下次应该和他联系的时间、毕业的学校、所属的圈子（高尔夫、同学等）、爱好、照片、合作关系。。。这些，都可以手动输入到名片附加信息中。部分信息关联到日程，比如好友生日，联系时间等。
6、名片搜索
7、时间轴。选择日期，事件（会面、吃饭、游玩），地点，名片（一张或多张）等信息，保存记录。一段时间之后，就和名片上的朋友有了用来记录交往过程时间轴。
短信群发1、姓名替换。短信群发，别人会感觉你不够用心。如果在短信中使用到了对方的名字，这条短信的意义，就完全不一样了。比如，我们写一条短信：“[姓名]，天冷加衣！”点击群发，每个联系人收到的都是替换过姓名的短信。张三同学收到的短信就是“张三，天冷加衣！”，李四同学收到的就是“李四，天冷加衣！”。
日程1、好友生日提醒
2、联系提醒
3、会面提醒
4、任务提醒
目标规划1、制订目标例：拉到100万投资。
2、为目标制订任务
3、安排任务到日程
社交技能1、谈资话题
2、社交礼仪
]]></content>
      <categories>
        <category>专业</category>
      </categories>
  </entry>
  <entry>
    <title>Cookie、localStorage和sessionStorage</title>
    <url>/dev-cookie-localstorage-and-sessionstorage/</url>
    <content><![CDATA[前言在《使用accessToken记录登录状态》一文中，已经讨论了Cookie的增删查改。本文详细探讨一下Cookie、localStorage和sessionStorage的概念差别，以及localStorage的用法。


CookieCookie的特点是小，只有4k，常用来存储辨别用户信息的数据，比如accessToken。而且，Cookie有数量限制，每个特定的域名下，最多生成50个Cookie（IE7+）。最大的优势是几乎所有的浏览器都支持。
localStoragelocalStorage 是 HTML5 标准中新加入的技术，拥有5M的存储空间，主流浏览器都支持。
存储if(window.localStorage)&#123;    var x = window.localStorage.userInfo? JSON.parse(window.localStorage.userInfo):&#123;&#125;;    if((x.unionid == undefined) || (x.unionid == "undefined"))&#123;        var temp = &#123;            unionid: $('#unionid').val(),            openid: $('#openid').val(),            nickname: $('#nickname').val(),            headimgurl:$ ('#headimgurl').val()        &#125;;        window.localStorage.userInfo = JSON.stringify(temp);    &#125;&#125;

读取var temp = (window.localStorage &amp;&amp; window.localStorage.userInfo)?JSON.parse(window.localStorage.userInfo):&#123;&#125;var unionid = temp.unionid;console.log(unionid);

sessionStoragesessionStorage和localStorage非常相似，最主要的差别，是生命周期。localStorage除非被清除，否则永久保存；sessionStorage关闭页面或浏览器后被清除。
异同


特性
Cookie
localStorage
sessionStorage



数据的生命期
可设置失效时间，默认是关闭浏览器后失效
除非被清除，否则永久保存
仅在当前会话下有效，关闭页面或浏览器后被清除


存放数据大小
4K左右
一般为5MB
一般为5MB


与服务器端通信
每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题
仅在客户端（即浏览器）中保存，不参与和服务器的通信
仅在客户端（即浏览器）中保存，不参与和服务器的通信


易用性
需要程序员自己封装，源生的Cookie接口不友好
源生接口可以接受，亦可再次封装来对Object和Array有更好的支持
源生接口可以接受，亦可再次封装来对Object和Array有更好的支持


书签详说 Cookie, LocalStorage 与 SessionStoragehttps://segmentfault.com/a/1190000002723469
HTML5 localStorage本地存储实际应用举例
谈谈本地存储利弊Cookie、localStorage、sessionStoragehttp://www.tuicool.com/articles/fM32ier
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>cookie</tag>
        <tag>localstorage</tag>
        <tag>sessionstorage</tag>
      </tags>
  </entry>
  <entry>
    <title>制作Ubuntu安装源方法小结</title>
    <url>/dev-create-ubuntu-installer/</url>
    <content><![CDATA[前言《安装系统之不同平台》和《Ubuntu 14.04.5 Server物理机安装》两篇文章中，都提过Linux安装源的制作方法，但是没有详细的说明。
Linux系统安装源可以分为U盘、光盘、硬盘、网络四个大类，其中最常用的是U盘和光盘，本文会针对这两种安装源进行总结。硬盘安装源的制作方法参考《安装系统之三种方式》和《安装系统之双系统》，网络安装源的制作方法参考《Ubuntu系统批量自动安装》。


制作工具可选的制作工具主要有：

Universal USB Installer，一个专门制作各种Linux的USB系统启动盘的工具。
Win32DiskImager，用于制作Ubuntu的USB系统启动盘，使用教程参考Win32DiskImager makes an Ubuntu family USB boot drive in Windows。
UltraISO，一款强大的光盘映像文件制作、编辑和转换工具。

U盘制作USB Installer1、下载Universal USB Installer，不需要安装就可以启动。
2、选择镜像类型，选择镜像，选择U盘，create即可。不过，正如《Ubuntu 14.04.5 Server物理机安装》一文中所说，usb installer制作的安装源会有些问题，还容易损坏U盘，这里不推荐。
Win32DiskImager1、下载Win32DiskImager，安装后启动。
2、选择镜像，选择设备，写入即可。写入完成后，U盘空间变小了，变成了2.18MB。而且U盘里只有一个文件夹：efi。不过不用担心，使用这个U盘确实可以安装Ubuntu系统。这里也不推荐，因为U盘现在只能用于安装系统，无法再存储其他文件，除非重新格式化。
UltraISO1、右键ubuntu-16.04.4-server-amd64.iso镜像，装载。这一步是必须的，因为如果直接使用UltraISO“打开”镜像，只能看到EFI文件夹。只有装载后的镜像，使用UltraISO“打开光盘”，才可以看到全部文件。需要注意的是，只有win8之后的系统才支持装载，更早的系统可以使用虚拟光驱进行镜像挂载。
2、下载UltraISO，安装后右键以管理员身份启动。
3、打开光盘，选择装载的镜像。
4、菜单栏点击启动，写入硬盘映像。
5、在写入硬盘映像对话框中，硬盘驱动器选择U盘，写入方式选择默认的USB-HDD+。
6、（可选操作）依次点击便捷启动，写入新的驱动器引导扇区，Syslinux。
7、点击“写入”，弹出警告U盘中的数据会丢失，确认后等待几分钟即可制作完成。
制作完成后，U盘还可以继续作为移动存储设备使用，这种方法是最推荐的一种方法。
光盘制作1、下载UltraISO，安装后右键以管理员身份启动。
2、光驱中放入空白光盘，容量要大于镜像大小。
3、菜单栏点击工具，刻录光盘映像。
4、映像文件选择ubuntu-16.04.4-server-amd64.iso，然后点击“刻录”，等待几分钟即可制作完成。
后记以上，就是U盘安装源和光盘安装源的制作方法。这两种安装源的使用方法都很常规，启动主机的时候进入BIOS选择启动项，然后正常安装即可。安装过程中会有很多交互设置，个人觉得很麻烦，没有GHOST安装方便。
因此，U盘和光盘无人值守自动安装也是一个很好的研究点，有时间了可以搞一下。主要思路是修改isolinux/txt.cfg文件，参考ubuntu-server.seed的引入方式，创建并引入ks.cfg文件。ks.cfg文件的配置参考ks.cfg参数详解，ubuntu-server.seed的配置参考《Ubuntu系统批量自动安装》。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>css阴影效果</title>
    <url>/dev-css-box-shadow/</url>
    <content><![CDATA[有阴影的图，看上去高大上些？不管怎样，UI设计了阴影，咱就照做好了。
语法：
box-shadow: h-shadow v-shadow blur spread color inset;



解释：



值
描述



h-shadow
必需。水平阴影的位置。允许负值。


v-shadow
必需。垂直阴影的位置。允许负值。


blur
可选。模糊距离。


spread
可选。阴影的尺寸。


color
可选。阴影的颜色。请参阅 CSS 颜色值。


inset
可选。将外部阴影 (outset) 改为内部阴影。


常见用法：
div&#123;    box-shadow: 10px 10px 5px #0cc;&#125;
四个值分别是水平阴影位置、垂直阴影位置、模糊距离、颜色。
实际案例：
&lt;a href="" class="confirm"&gt;    &lt;span&gt;马上去抢2G流量&lt;/span&gt;&lt;/a&gt;

.confirm&#123;    display: inline-block;    box-shadow: 0 .5rem 1.5rem #0cc;    border-radius: 5px;    margin-top: 12%;    width: 98%;    height: 17%;    background: url(../../img/flowrate/blue.jpg) no-repeat;    background-size: 100% 100%;    color: #fff;    span&#123;        display: inline-block;        margin-top: 3%;        font-size: 1.5rem;    &#125;&#125;

最终效果如下：
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>css雪碧图</title>
    <url>/dev-css-sprite/</url>
    <content><![CDATA[前言CSS雪碧 即CSS Sprite，也有人叫它CSS精灵，是一种CSS图像合并技术，该方法是将小图标合并到一张图片上，然后利用css的背景定位来显示需要显示的图片部分。
优点：减少加载网页图片时对服务器的请求次数，提高页面的加载速度，减少鼠标滑过的一些bug。


制作雪碧图的制作，可以使用PS，也可以使用专门的雪碧图制作工具。制作时，最好制作成一列或者一行，定位时会方便一些。下面这个工具挺好用，分享给大家：https://yunpan.cn/cMKygj2hnrBBe  访问密码 f516
css雪碧图简单制作工具（源码）https://github.com/iwangx/sprite
如果要制作svg雪碧图，推荐使用AI。
定位位置雪碧图定位的关键，在于background-position。诀窍在于“调试”，在页面控制背景图上下左右移动，很快就定位好了。
以上面的雪碧图为例，假设我们要显示微博的图标，那么scss代码如下：
.icon-weibo&#123;    width: 20px;    height: 20px;    background: url(../../img/test/index/icon.png) no-repeat;    background-position: 0px -60px;&#125;

大小假设我们的要显示的图标比雪碧图大，或者比雪碧图小，该怎么办？background-size。
.icon-weibo&#123;    width: 40px;    height: 40px;    background: url(../../img/test/index/icon.png) no-repeat;    background-position: -2px -116px;    background-size: 118%;&#125;

移动端很多时候，我们并不使用px作为单位，而是rem或者百分比，这时候，该怎么控制雪碧图的位置和大小？利用svg图片。
&lt;span class="i i_menu_0"&gt;&lt;/span&gt;

.i &#123;    width: 0.8rem; height: 0.8rem;    background: url(../images/ico_global.svg) no-repeat;    display: inline-block;    background-size: 1100%;&#125;.i_menu_0 &#123; background-position: 0% 0%; &#125;.i_menu_1 &#123; background-position: 10% 0%; &#125;.i_menu_2 &#123; background-position: 20% 0%; &#125;.i_menu_3 &#123; background-position: 30% 0%; &#125;.i_menu_4 &#123; background-position: 40% 0%; &#125;.i_menu_5 &#123; background-position: 50% 0%; &#125;

后记至于PS和AI的使用，在慕课网和网易云课堂上有很多优秀教程，不要错过。
书签CSS雪碧图的实现方法（即背景定位）http://www.suixin8.com/59.html
CSS3技术-雪碧图自适应缩放http://www.imooc.com/wiki/detail/id/183
利用动态viewport+rem制作一张自适应的svg雪碧图iconhttp://www.open-open.com/lib/view/open1452229325136.html
SVG的用法http://www.webhek.com/svg/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>前端</tag>
        <tag>sprite</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS实现文本溢出显示省略号</title>
    <url>/dev-css-text-overflow-omit/</url>
    <content><![CDATA[单行文本溢出显示省略号width: 300px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;

如果字符串长度超过300px，那么超出部分就变成...。
多行文本溢出显示省略号display: -webkit-box;-webkit-box-orient: vertical;-webkit-line-clamp: 3;overflow: hidden;
因为使用了WebKit的CSS扩展属性，该方法适用于WebKit浏览器及移动端；
-webkit-line-clamp用来限制在一个块元素显示的文本的行数。为了实现该效果，它需要组合其他的WebKit属性。常见结合属性：display: -webkit-box; 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 。-webkit-box-orient 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 。
怎样在js中判断文本是否溢出问题描述：一段文字限定行数，使用css把多余文字显示为省略号，请问怎么通过js判断这段文字是否有文字显示为省略号？
思路一王晨帅哥提供了一个思路：取消css的-webkit-line-clamp属性，看看元素高度是否发生了变化，变化了就是有文字显示为省略号。
好想法，最后郝同学改进后如下：这段文字在页面上放两份，一份限定行数，正常显示；另一份不限定行数，隐藏起来。然后，对比这两段文字的高度是否相同。具体实现：
// scss部分.info&#123;    font-size: 1.2rem;    margin-top: .6rem;    display: -webkit-box;    -webkit-box-orient: vertical;    -webkit-line-clamp: 4;    overflow: hidden;    p&#123;        &amp;:not(:first-child)&#123;            margin-top: .4rem;        &#125;;          line-height: 1.8rem;    &#125;&#125;.info-hidden&#123;    position: fixed;    z-index: -10;    visibility: hidden;    font-size: 1.2rem;    margin-top: .6rem;    p&#123;        &amp;:not(:first-child)&#123;            margin-top: .4rem;        &#125;;          line-height: 1.8rem;    &#125;&#125;

// js部分var $info = $('.info');var $info_hidden = $('.info-hidden');if($info.height() === $info_hidden.height())&#123;    $('.more').hide();&#125;

思路二后来张伟林帅哥提供了一个更好的思路：既然已经知道了限定的行数，那么判断一个高度就可以了。结合line-height，高度用scrollheight，判断scrollheight &gt; line-height*你决定的行数。
郝同学马上搜索了一个scrollheight，发现，原来scrollHeight可以返回元素的完整高度。那么，比较一下scrollHeight和height不就可以了么？具体实现：
// js部分var $info = $('.info');console.log($info.height());console.log($info[0].scrollHeight);if($info.height() &gt;= $info[0].scrollHeight)&#123;    $('.more').hide();&#125;

后记利用js也可以实现文本溢出显示省略号，可以参考书签中的dotdotdot，很形象的名字。。。
书签CSS实现单行、多行文本溢出显示省略号（…）http://www.daqianduan.com/6179.html
jQuery.dotdotdothttp://www.bootcdn.cn/jQuery.dotdotdot/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>使用curl访问k8s的apiserver</title>
    <url>/dev-curl-k8s-api-server/</url>
    <content><![CDATA[k8s管理工具管理k8s集群，除了kubectl和go-client，其实还可以使用curl命令。本文，我们就学习一下怎样使用curl访问k8s的apiserver，实现k8s集群的管理。主要参考如何使用curl访问k8s的apiserver。
需求：使用curl命令，实现 kubectl get pod 同样的效果。使用curl命令访问k8s集群时，分别使用证书和token两种认证方式。


使用证书假设我们拥有集群的kubeconfig文件，我们需要从中拿出ca cert、client cert和client key，保存为文件。并且拿出apiserver，保存为变量。
cat config | grep certificate-authority-data | awk '&#123;print $2&#125;' | base64 -d &gt; ca.crtcat config | grep client-certificate-data | awk '&#123;print $2&#125;' | base64 -d &gt; client.crtcat config | grep client-key-data | awk '&#123;print $2&#125;' | base64 -d &gt; client.keyAPISERVER=$(cat config | grep server | awk '&#123;print $2&#125;')

查看API的url，使用curl命令调用API
kubectl get pods -v8curl --cert ./client.crt --cacert ./ca.crt --key ./client.key $APISERVER/api/v1/namespaces/default/pods/

以上，拿到了default空间下的pod信息，和 kubectl get pod 等同。
使用Token获取token想要使用curl命令访问apiserver，首先要获得一个具有权限的token。
kubectl get secrets --all-namespaces | grep adminkubectl describe secrets admin-token-vmv2c -n kube-system

输出结果为：
Name:         admin-token-vmv2cNamespace:    kube-systemLabels:       &lt;none&gt;Annotations:  kubernetes.io&#x2F;service-account.name: admin              kubernetes.io&#x2F;service-account.uid: a75b4cdc-e120-11e9-8695-00163e300424Type:  kubernetes.io&#x2F;service-account-tokenData&#x3D;&#x3D;&#x3D;&#x3D;ca.crt:     1419 bytesnamespace:  11 bytestoken:      xxxthisisatokenxxx
最后一个字段就是token，那么这个token有哪些权限呢？
查看token权限根据annotations中的key value，可以看到这个secrets绑定了一个service-account(sa)，name为admin。等同于这个token绑定了一个sa，name为admin。
查看admin这个service-account的信息。
kubectl get sa --all-namespaces | grep adminkubectl describe sa admin -n kube-system

输出结果为：
Name:                adminNamespace:           kube-systemLabels:              &lt;none&gt;Annotations:         kubectl.kubernetes.io&#x2F;last-applied-configuration:                       &#123;&quot;apiVersion&quot;:&quot;v1&quot;,&quot;kind&quot;:&quot;ServiceAccount&quot;,&quot;metadata&quot;:&#123;&quot;annotations&quot;:&#123;&#125;,&quot;name&quot;:&quot;admin&quot;,&quot;namespace&quot;:&quot;kube-system&quot;&#125;&#125;Image pull secrets:  &lt;none&gt;Mountable secrets:   admin-token-vmv2cTokens:              admin-token-vmv2cEvents:              &lt;none&gt;
没有关于admin的权限信息，那么我们再看一下admin绑定了哪些role和clusterrole。
kubectl get rolebindings --all-namespaces -oyaml | grep "name: admin" -A10 -B10kubectl get clusterrolebindings --all-namespaces -oyaml | grep "name: admin" -A10 -B10

找到有用信息为：
- apiVersion: rbac.authorization.k8s.io/v1  kind: ClusterRoleBinding  metadata:    annotations:      kubectl.kubernetes.io/last-applied-configuration: |        &#123;"apiVersion":"rbac.authorization.k8s.io/v1beta1","kind":"ClusterRoleBinding","metadata":&#123;"annotations":&#123;&#125;,"name":"admin"&#125;,"roleRef":&#123;"apiGroup":"rbac.authorization.k8s.io","kind":"ClusterRole","name":"cluster-admin"&#125;,"subjects":[&#123;"kind":"ServiceAccount","name":"admin","namespace":"kube-system"&#125;]&#125;    creationTimestamp: "2019-09-27T12:16:37Z"    name: admin    resourceVersion: "1317"    selfLink: /apis/rbac.authorization.k8s.io/v1/clusterrolebindings/admin    uid: a75e1ef9-e120-11e9-8695-00163e300424  roleRef:    apiGroup: rbac.authorization.k8s.io    kind: ClusterRole    name: cluster-admin  subjects:  - kind: ServiceAccount    name: admin    namespace: kube-system

可知admin绑定了一个名为cluster-admin的clusterrole，接着查看cluster-admin的权限。
kubectl describe clusterrole cluster-admin -n kube-system

结果为：
Name:         cluster-adminLabels:       kubernetes.io&#x2F;bootstrapping&#x3D;rbac-defaultsAnnotations:  rbac.authorization.kubernetes.io&#x2F;autoupdate: truePolicyRule:  Resources  Non-Resource URLs  Resource Names  Verbs  ---------  -----------------  --------------  -----  *.*        []                 []              [*]             [*]                []              [*]

cluster-admin这个角色拥有集群的所有权限，因此admin这个sa拥有集群的所有权限。
使用token1、设置token和apiserver作为变量
TOKEN=$(kubectl describe secrets $(kubectl get secrets -n kube-system |grep admin |cut -f1 -d ' ') -n kube-system |grep -E '^token' |cut -f2 -d':'|tr -d '\t'|tr -d ' ')APISERVER=$(kubectl config view |grep server|cut -f 2- -d ":" | tr -d " ")``` 2、查看API的url，使用curl命令调用API```shellkubectl get pods -v8curl -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces/default/pods/  --insecure

以上，拿到了default空间下的pod信息，和 kubectl get pod 等同。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>行为型模式之迭代器模式</title>
    <url>/dev-design-pattern-iterator/</url>
    <content><![CDATA[需求场景在Java中，经常需要将一类对象放到List、Set、Map等容器中，而且通常需要对容器中的对象进行遍历访问。那么如何实现对这些容器的遍历呢？当然，每个容器本身都提供了遍历的方法。但是这些方法是不统一的，客户端的使用变得麻烦。


解决办法其实，在Java中不管是采用List、Set方式存储的对象，还是采用Map方式存储对象，都可以使用迭代器进行遍历。
总结迭代器模式提供一种方法，可以顺序访问一个集合中的对象，而又不需要暴露该对象的内部表示。
迭代器模式分离了集合对象的遍历行为，抽象出一个迭起器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。
迭代器模式主要由4部分组成：迭代器角色、具体迭代器角色、容器角色和具体容器角色。

迭代器角色负责定义访问和遍历元素的接口。
具体迭代器角色要实现迭代器接口，并要记录遍历中的当前位置。
容器角色负责提供创建具体迭代器角色的接口。
具体容器角色实现创建具体迭代器角色的接口，这个具体迭代器角色与该容器的结构无关。

源码分享https://github.com/voidking/design-pattern-behavior.git
参考文献《易学设计模式》《大话设计模式》接口设计六大原则软件设计六大设计原则讲解Java中如何遍历Map对象的4种方法Java容器集合类的区别用法
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>行为型模式之观察者模式</title>
    <url>/dev-design-pattern-observer/</url>
    <content><![CDATA[现实场景每当有最新一期的报纸出版时，送报员都会按照订阅者的名单，把最新的报纸按时送到订阅者手里。而且订阅者也可以随时退订或者订阅其他的报纸，这就是观察者在现实生活中的应用。


需求场景用户可以在电脑端、安卓端查看股票行情，当股票价格和买卖数量发生变化时，要通知这两个客户端。
一般思路：
public class ComputerClient&#123;    public void updatePrice(String name)    &#123;        System.out.println(name + "股票在电脑上的价格更新了");    &#125;    public void updateCount(String name)    &#123;        System.out.println(name + "股票在电脑上的买卖数量更新了");    &#125;&#125;

public class AndroidClient&#123;    public void updatePrice(String name)    &#123;        System.out.println(name + "股票在安卓上的价格更新了");    &#125;    public void updateCount(String name)    &#123;        System.out.println(name + "股票在安卓上的买卖数量更新了");    &#125;&#125;

public class Stock&#123;    private String stockName = "中信证券";    public void changeCount()    &#123;        ComputerClient computerClient = new ComputerClient();        computerClient.updateCount(stockName);                AndroidClient androidClient = new AndroidClient();        androidClient.updateCount(stockName);    &#125;    public void changePrice()    &#123;        ComputerClient computerClient = new ComputerClient();        computerClient.updatePrice(stockName);                AndroidClient androidClient = new AndroidClient();        androidClient.updatePrice(stockName);    &#125;&#125;

public class Client&#123;    public static void main(String[] args)    &#123;        Stock stock = new Stock();        stock.changePrice();        stock.changeCount();    &#125;&#125;

上面的代码没什么问题，但是，如果要增加一个苹果客户端，就要修改Stock类的代码，增加对苹果客户端的支持。而且，苹果客户端要写很多重复代码。
后来又不想支持苹果客户端了，这时又要修改Stock类的代码。
一个苹果客户端还好，如果还有更多其他的客户端呢？
解决办法如果能够在股票类增加一个功能，可以动态、随意地添加或删除客户端，是不是就可以解决这个问题呢？要实现动态、随意地添加或删除客户端，就必须面向接口编程，即把各种客户端抽象处理，在股票类里针对抽象的客户端编程。
总结观察者模式就是定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知并自动更新。观察者模式主要由4个部分组成：抽象目标类、具体目标类、抽象观察者类、具体观察者类。
源码分享https://github.com/voidking/design-pattern-behavior.git
参考文献《易学设计模式》《大话设计模式》接口设计六大原则软件设计六大设计原则讲解
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>行为型模式之策略模式</title>
    <url>/dev-design-pattern-strategy/</url>
    <content><![CDATA[现实场景在销售产品时，为了促销，经常会进行打折。针对不同的时间、不同的消费群体，采用的打折策略也会不同。比如有的打八折，有的买一送一。这种动态的调整销售策略的行为，就是策略模式在现实生活中的应用。


需求场景一个大公司有两个子公司，吉林子公司和河北子公司，每个子公司都要计算薪资。薪资的计算包括基本工资、社会保险和个人所得税。
一般思路，使用模板方法模式。
public abstract class SalaryTemplate&#123;    public void Compute()    &#123;        computeSalary();        computeInsurance();        computeTax();    &#125;    public abstract void computeSalary();    public abstract void computeInsurance();    public abstract void computeTax();&#125;

public class JiLinSalary extends SalaryTemplate&#123;    public void computeSalary()    &#123;        System.out.println("采用吉林算法计算基本工资");    &#125;    public void computeInsurance()    &#123;        System.out.println("采用吉林算法计算保险");    &#125;    public void computeTax()    &#123;        System.out.println("采用吉林算法计算所得税");    &#125;&#125;

public class HeBeiSalary extends SalaryTemplate&#123;    public void computeSalary()    &#123;        System.out.println("采用河北算法计算基本工资");    &#125;    public void computeInsurance()    &#123;        System.out.println("采用河北算法计算保险");    &#125;    public void computeTax()    &#123;        System.out.println("采用河北算法计算所得税");    &#125;&#125;

public class Client &#123;    public static void main(String[] args) &#123;        SalaryTemplate jilin = new JiLinSalary();        SalaryTemplate hebei = new HeBeiSalary();                jilin.computeSalary();        jilin.computeInsurance();        jilin.computeTax();                hebei.computeSalary();        hebei.computeInsurance();        hebei.computeTax();    &#125;&#125;

解决办法但是，如果实现到这里，还是有问题的，那就是类的职责不清。这个模板类，既要计算基本工资，又要计算社会保险，还要计算个人所得税。违反了单一职责原则。那该如何设计呢？很明显，需要把计算基本工资、社会保险、个人所得税的功能进行拆分。
总结策略模式就是定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户端而独立变化。
策略模式主要由3部分组成：抽象策略类、具体策略类、上下文场景类。
优点：使用策略模式，可以替换继承关系的办法，也可以避免使用多重条件转移语句。缺点：使用策略模式时客户端必须知道所有的策略类，并自行决定使用哪一个策略类，如果算法比较多，则会造成很多的策略类。
源码分享https://github.com/voidking/design-pattern-behavior.git
参考文献《易学设计模式》《大话设计模式》接口设计六大原则软件设计六大设计原则讲解
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式概述</title>
    <url>/dev-design-pattern-summary/</url>
    <content><![CDATA[设计模式简介1979年，建筑师亚历山大编写了《建筑的永恒之道》，这本书阐述了建筑与规划的新观点。作者通过对当代建筑的研究发现：优秀的建筑中，总是存在着一些相似之处。如果能够找出这些优秀建筑的特征，就能够找到这些建筑是采用了哪些方法，如何设计才变得优秀的，从而也就能够客观评价一个建筑设计的好坏。通过找出并掌握这些优秀建筑的设计方法，建筑师就可以把这些方法复制到其他的建筑设计中，从而设计出同样优秀的建筑来。
建筑行业中存在的情况和软件行业存在的情况类似。在软件行业，是否也能够从那些优秀的软件中，找到一些相同的特征、优秀的设计方法，从而使软件开发人员能够掌握这些方法，并将其应用到其他的软件开发中，从而也开发出同样优秀的软件呢？
为了探讨这个问题，很多软件开发人员开始了这方面的研究，其中影响最大的文献是《设计模式》一书，该书的四个作者被称为GoF或Gang of Four。这本书总结了人类历史上软件开发的经验，给出了描述模式的一些特征，并提炼出用于指导软件设计的23种模式和一些面向对象的设计方法。


设计模式分类设计模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。
创建型模式软件设计方面，分工越来越细，因此对象的创建和对象的使用分开也就成了必然趋势。因为对象的创建会消耗很多资源，所以对对象的创建进行研究，能够高效地创建对象就是创建型模式要探讨的问题。创建型模式有6个：

简单工厂模式（Simple Factory）
工厂方法模式（Factory Method）
抽象工厂模式（Abstract Factory）
创建者模式（Builder）
原型模式（Prototype）
单例模式（Singleton）

结构型模式在解决了对象的创建问题后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低。结构型模式有7个：

外观模式（Facade）
适配器模式（Adapter）
代理模式（Proxy）
装饰模式（Decorator）
桥模式（Bridge）
组合模式（Composite）
享元模式（Flyweight）

行为型模式在对象的创建和对象的结构问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，那么对象的行为就会更清晰，它们之间的协作效率就会提高。行为型模式有11个：

模板方法模式（Template Method）
观察者模式（Observer）
状态模式（State）
策略模式（Strategy）
职责链模式（Chain of Responsibility）
命令模式（Command）
访问者模式（Visitor）
调停者模式（Mediator）
备忘录模式（Memento）
迭代器模式（Iterator）
解释器模式（Interpreter）

类之间关系在面向对象设计模式中，类与类之间主要有6种关系，分别是：依赖、关联、聚合、组合、继承、实现，耦合度依次增强。

依赖，一个类的方法里使用了另一个类。
关联，一个类里包含另一个类作为属性（成员变量）。
聚合，强的关联，整体与个体。
组合，更强的关联，同生共死。
继承
实现

staruml逆向问题使用staruml逆向生成类图的时候，提示错误：“Description: Unrecoverable Parse Error”。
原因1：java文件编码为包含BOM的UTF-8，而BOM在staruml中无法处理。解决办法：使用格式转换工具，转换为不包含BOM的UTF-8。或者，转换为GB2312。
原因2：java文件中包含@Override等标签，staruml无法识别。解决办法：去掉标签。或者换用其他逆向工具，比如WhiteStarUML、BOUML、UMLet等。
源码分享https://github.com/voidking/design.git
参考文献《易学设计模式》《大话设计模式》接口设计六大原则软件设计六大设计原则讲解了解这23种设计模式依赖、关联、聚合和组合及其之间区别的简单理解StarUML使用说明-指导手册使用StarUML画类图UML建模之时序图（Sequence Diagram）
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>staruml</tag>
      </tags>
  </entry>
  <entry>
    <title>行为型模式之模板方法模式</title>
    <url>/dev-design-pattern-template-method/</url>
    <content><![CDATA[场景有一个报表打印程序，用户规定必须要打印表头、正文、表尾三个部分。
一般思路：
public class Report &#123;    public void print()    &#123;        printTitle();        printBody();        printTail();    &#125;        public void printTitle()    &#123;        System.out.println("采用一种方式打印表头");    &#125;    public void printBody()    &#123;        System.out.println("采用一种方式打印正文");    &#125;    public void printTail()    &#123;        System.out.println("采用一种方式打印表尾");    &#125;&#125;



客户端调用的时候，直接new一个Report对象，然后调用print方法即可。现在看起来没什么问题，可是需求是不断变化的。如果用户提出需要把表头改一下样式，怎么办？最简单的方法就是在Report类里修改打印表头的代码。
修改完毕，用户又觉得还是原来的样式好看，要求再改回原来的样式，这时我们要再修改Report。
修改完毕，用户又要求修改正文和表尾，我们接着修改Report。
修改完毕，用户要求打印两套样式的报表，第一套就使用最初的样式，第二套使用修改过表头的样式。这时，我们没法通过仅仅修改Report来完成需求了，我们要添加一个Report2。以后也许还要添加Report3、Report4等等。
我们发现，改来改去非常麻烦，而且存在大量重复代码，还违反了开闭原则。那么怎么解决这个问题呢？
分析分析需求可以看出，打印表头、正文、表尾这个流程是不变的，而打印的方式是变化的。
根据开闭原则，一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。也就是说，一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。
那么我们最好把不变的部分和变化的部分分开，不变的部分作为软件实体，变化的部分作为扩展。
解决办法Report类作为抽象类，规定流程。子类继承Report类，实现不同样式。
public abstract class Report&#123;    public void print()    &#123;        printTitle();        printBody();        printTail();    &#125;    public abstract void printTitle();    public abstract void printBody();    public abstract void printTail();&#125;

public class ReportImpl extends Report&#123;    public void printTitle()    &#123;        System.out.println("采用一种方式打印表头");    &#125;    public void printBody()    &#123;        System.out.println("采用一种方式打印正文");    &#125;    public void printTail()    &#123;        System.out.println("采用一种方式打印表尾");    &#125;&#125;

总结模板方法可以总结为四个字：按部就班。适用于流程是固定的，而流程的具体实现是变化的情况。
应用Web开发中的HttpServlet类就是一个典型模板应用。如果没有HttpServlet，那么我们的MyServlet需要继承GenericServlet。
接下来的处理流程是确定的：1、转化ServletRequest和ServletResponse为HttpServletRequest和HttpServletResponse。2、判断请求类型是get、post或者其他类型。3、从HttpServletRequest中拿到请求参数，进行业务处理。
其中经常变化的是第3步。
而HttpServlet，规定了处理的流程。我们的MyServlet，如果继承HttpServlet，那么只要专注于第3步即可。
源码分享https://github.com/voidking/design-pattern-behavior.git
参考文献《易学设计模式》《大话设计模式》接口设计六大原则软件设计六大设计原则讲解
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>滴滴算法大赛</title>
    <url>/dev-didi-competition/</url>
    <content><![CDATA[前言本文转载自优达学城《机器学习工程师》
全球领先的出行方案提供商滴滴出行在2016年5月到7月成功举办了第一届算法大赛并取得了圆满的成功。优达学城作为协办方，也深刻地感受到了学生对解决基于企业真实数据题目的热情。为了让更多的学生能够有机会得到这样的锻炼，我们特地与滴滴出行协作，把算法比赛的题目作为纳米学位中的一个可选项目。
项目在设计时综合考量了纳米学位的内容与滴滴出行的招聘要求。让你能够把学到的内容应用在真实企业数据中。完成项目的优秀者可以得到滴滴出行的证书。为你的简历添砖加瓦。


项目制定原则：

滴滴出行按照自身招聘的需求设计项目。
优达学城结合机器学习纳米学位的课程内容进行微调。
留下足够多的自定空间给学生自由发挥，也可依此更好得区分学生水平。

项目介绍在出行问题上，中国市场人数多、人口密度大，总体的出行频率远高于其他国家，这种情况在大城市尤为明显。然而，截至目前中国拥有汽车的人口只有不到10%，这意味着在中国人们的出行更加依赖于出租车、公共交通等市场提供的服务。另一方面，滴滴出行占领了国内绝大部分的网络呼叫出行市场，面对着巨大的数据量以及与日俱增的数据处理需求。截至目前，滴滴出行平台日均需处理1100万订单，需要分析的数据量达到50TB，路径规划服务请求超过90亿。面对如此庞杂的数据，我们需要通过不断升级、完善与创新背后的云计算与大数据技术，从而保证数据分析及相关应用的稳定，实现高频出行下的运力均衡。供需预测就是其中的一个关键问题。
供需预测的目标是准确预测出给定地理区域在未来某个时间段的出行需求量及需求满足量。调研发现，同一地区不同时间段的订单密度是不一样的，例如大型居住区在早高峰时段的出行需求比较旺盛，而商务区则在晚高峰时段的出行需求比较旺盛。如果能预测到在未来的一段时间内某些地区的出行需求量比较大，就可以提前对营运车辆提供一些引导，指向性地提高部分地区的运力，从而提升乘客的整体出行体验。

问题定义、数据描述及常见问题
数据集下载

项目提交提交和评估你的项目将由优达学城项目导师根据此要求进行评估。 提交前请务必仔细查看此要求。所有标准必须“符合规格”才能通过。

需提交一份PDF格式的项目报告，要求见这里。
解题代码需使用 python 2.7 的 ipynb 或 py 为后缀的文件。（后续会开放更多编程语言）
代码运行说明文件。纯文本或markdown格式，写明运行你的代码所需要的库，他们的安装方法和运行方法
预测结果: 纯文本或CSV文件。

对项目要求有疑问请致信 support@youdaxue.com
准备好提交项目后，请点击下一项，在“项目提交”小节中提交。
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Django开发简单Blog系统——下</title>
    <url>/dev-django-blog-2/</url>
    <content><![CDATA[前言博客的基本功能完成了，接下来，我们来看一下还有哪些知识点可以加入我们的系统。


超链接template中可以使用：
&#123;% url 'app_name: url_name' param %&#125;


app_name：应用命名空间的名称
url_name：链接名
param：参数

app_name和url_name都在urls.py中配置。
djsite/djsite/urls.py中
url(r'^blog/', include('blog.urls', namespace='blog')),
其中namespace=&#39;blog&#39;代表的是app_name。
djsite/blog/urls.py中
url(r'^(?P&lt;article_id&gt;[0-9]+)$', views.detail, name='detail'),
其中name=&#39;detail&#39;代表的是url_name。
比如，我们想要访问views.detail方法，那么在页面中，可以使用：
&#123;% url 'blog:detail' article.id %&#125;

实际上，这种写法并没有我们上一篇文章中的写法方便，因为ajax得到数据后无法使用这种写法，建议弃用。
django shelldjango shell和python shell的不同，在于django shell里加入了项目的环境，这就方便了我们的调试。比如，我们在django shell输入：
from blog.models import ArticleArticle.objects.all()Article.objects.all().values()
即可打印出所有的文章。
Admin进阶在之前的后台管理系统中，点击进入Articles，发现里面有很多Article Object，因为我们在blog/models.py中添加了__str__方法，所以显示的名称是文章标题。
那么，怎样把标题、内容、发布时间都显示出来呢？答案是修改blog/admin.py：
from django.contrib import adminfrom . import models# Register your models here.class ArticleAdmin(admin.ModelAdmin):    # 显示在admin控制台中的列名    list_display = ('title', 'content', 'pub_time')    # 时间过滤器    list_filter = ('pub_time',)admin.site.register(models.Article, ArticleAdmin)

改用mysqlsqlite，做一些测试还可以，但是在实际开发中，我们通常使用mysql。
1、假设我们的数据库用户名为root，密码为空，数据库名为djsite。
2、安装pymysqlpip install pymysql
3、修改djsite/djsite/settings.py：
# Database# https://docs.djangoproject.com/en/1.11/ref/settings/#databases# DATABASES = &#123;#     'default': &#123;#         'ENGINE': 'django.db.backends.sqlite3',#         'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),#     &#125;# &#125;DATABASES = &#123;    'default': &#123;        'ENGINE': 'django.db.backends.mysql',        'HOST': '127.0.0.1',        'PORT': '3306',        'NAME': 'djsite',        'USER': 'root',        'PASSWORD': '',        'OPTIONS': &#123;            'init_command': "SET sql_mode='STRICT_TRANS_TABLES'",        &#125;,    &#125;&#125;

4、修改djsite/djsite/__init__.py：
import pymysqlpymysql.install_as_MySQLdb()

5、数据迁移python manage.py makemigrations
python manage.py migrate
6、创建超级用户python manage.py createsuperuser
源码分享https://github.com/voidking/djsite/releases/tag/v0.3.0
书签django入门与实践
Django 过滤器
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django入门</title>
    <url>/dev-django-start/</url>
    <content><![CDATA[Django简介Django是一个开放源代码的Web应用框架，由Python写成。采用了MVC的框架模式，即模型M，视图V和控制器C。它最初是被开发来用于管理劳伦斯出版集团旗下的一些以新闻内容为主的网站的，即是CMS（内容管理系统）软件。并于2005年7月在BSD许可证下发布。


安装Django安装方法一：pip install django
安装方法二：
git clone https://github.com/django/django.gitcd djangopip setup.py installpython -m django --version

创建项目1、创建django项目，命名为djsitedjango-admin startproject djsite
2、运行djsitecd djsite，python manage.py runserver
3、测试访问浏览器访问 http://localhost:8000/ ，即可看到第一个django页面。
4、运行djsite进阶python manage.py runserver 0.0.0.0:8080 ，此时，允许任意ip可以访问，端口为8080。
目录结构djsite│  db.sqlite3│  manage.py│└─djsite    │  settings.py    │  urls.py    │  wsgi.py    └─__init__.py


__init__.py，表示djsite是一个模块
manage.py，管理命令文件
settings.py，全局配置文件
urls.py，路由配置
wsgi.py，配置nginx、apache对接

django中的各种命令，都是在manage.py中完成的。

启动服务器，python manage.py runserver
创建应用，python manage.py startapp blog
进入shell，python manage.py shell
创建model，python manage.py makemigrations
根据model更新数据库表，python manage.py migrate

创建应用django中以应用来分割功能，使结构清晰，方便复用。
1、创建blog应用python manage.py startapp blog
2、添加blog应用到settings.py
# Application definitionINSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'blog',]

3、blog的目录结构如下
blog│  admin.py│  apps.py│  models.py│  tests.py│  views.py│  __init__.py│└─migrations        __init__.py


admin.py，当前应用后台管理配置
apps.py，当前应用配置
models.py，定义数据库表
tests.py，测试相关
views.py，执行响应
migrations，数据迁移模块

4、helloworld编辑views.py，修改为：
from django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def hello(request):    return HttpResponse('helloworld')

5、为了访问到views.py，我们要配置下路由，修改urls.py为：
from blog.views import hellourlpatterns = [    url(r'^admin/', admin.site.urls),    url(r'helloworld', hello),]

6、测试访问启动django，访问 http://localhost:8000/helloworld ，即可看到helloworld。
路由进阶1、修改djsite/urls.py为：
from django.conf.urls import url,includefrom django.contrib import adminurlpatterns = [    url(r'^admin/', admin.site.urls),    url(r'^blog/', include('blog.urls', namespace="blog")),]

2、在blog中添加urls.py为：
from django.conf.urls import urlfrom . import viewsurlpatterns = [    # url(r'^$', views.index, name='index'),    url(r'helloworld', views.hello, name='hello')]

3、测试访问启动django，访问 http://localhost:8000/blog/helloworld ，即可看到helloworld。
源码分享https://github.com/voidking/djsite/releases/tag/v0.0.0
书签django初体检
pycharm 教程（一）安装和首次使用
Django URL管理
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Django开发微信公众平台管理系统——第0章</title>
    <url>/dev-django-wechat-0/</url>
    <content><![CDATA[前言两年前，学习了Django的开发，整理了一个系列的文档，《Django入门》、《Django开发简单Blog系统》、《Django部署到线上》等。半年前，使用Django和图像处理方法完成了毕业设计。
最近，打算空闲时间打造一下自己的微信公众号，于是安装了微擎系统。但是发现微擎系统存在很多问题，最不能忍受的是添加自动回复，添加完成没有报错，但是数据库根本没有记录！找客服？对不起咱不是付费用户，没人给咱服务。看文档？对不起文档不涉及咱这个具体问题。找社区？对不起社区不活跃，没人遇到过咱这个问题，无人解答。学完微擎框架自己解决？有这个闲工夫，咱就自己写一个了！。。。行吧，拜拜了您哪！
找了一圈，没有找到特别满意的其他微信公众平台管理系统，那就，自己写一个吧！基于Django和WeRoBot，参考文档WeRoBot与其他 Web 框架集成。


开发环境准备1、Python版本3.6.3
2、Django版本2.1.7
3、PyCharm版本2018.1.4(Community Edition)
4、安装WeRoBotpip install werobot
创建项目首先给项目起个好名字吧，万一以后火了呢！就叫wecms吧，没错就是这么随意。
1、创建项目django-admin startproject wecms
2、运行wecms
cd wecmspython manage.py runserver# orpython manage.py runserver 0.0.0.0:8080

3、测试访问浏览器访问 http://localhost:8000/ ，即可看到项目首页。
创建应用1、创建应用前期所有的模块都放在一起，以后再进行拆分优化，因此创建应用名为main。python manage.py startapp main
2、注册应用编辑 wecms/wecms/settings.py，添加：
# Application definitionINSTALLED_APPS = [    'django.contrib.admin',    'django.contrib.auth',    'django.contrib.contenttypes',    'django.contrib.sessions',    'django.contrib.messages',    'django.contrib.staticfiles',    'main',]

3、第一个函数编辑 wecms/main/views.py，如下修改：
from django.shortcuts import renderfrom django.http import HttpResponse# Create your views here.def index(request):    return HttpResponse('welcome to wecms!')

4、添加路由编辑 wecms/wecms/urls.py，如下修改：
from django.contrib import adminfrom django.urls import path, includeurlpatterns = [    path('admin/', admin.site.urls),    path('', include('main.urls')),    path('main/', include('main.urls')),]

创建 wecms/main/urls.py，内容如下：
from django.urls import pathfrom . import viewsurlpatterns = [    path('',views.index, name='index'),    path('index/',views.index, name='index'),]

5、启动服务python manage.py runserver
6、测试访问浏览器访问http://127.0.0.1:8000/http://127.0.0.1:8000/main/http://127.0.0.1:8000/main/index/都可以看到welcome to wecms!
引入WeRoBot1、创建 wecms/main/views_wechat.py，内容为：
import werobotrobot = werobot.WeRoBot(token='vkwechat')@robot.handlerdef index(message):    return 'Today is wonderful day!'
收到的所有信息返回Today is wonderful day!
2、wecms/main/urls.py修改为：
from django.urls import pathfrom . import viewsfrom . import views_wechatfrom werobot.contrib.django import make_viewurlpatterns = [    path('',views.index),    path('index/',views.index),    path('wechat/',make_view(views_wechat.robot)),]

注意，make_views函数中的参数并不是函数，而是robot对象。
3、测试访问浏览器访问 http://127.0.0.1:8000/main/wechat/
微信配置1、使用内网穿透，把本地8000端口代理到 wecms-dev.voidking.com 域名。
2、测试访问http://wecms-dev.voidking.com/main/wechat/
3、配置微信公众号登录微信公众平台，开发，基本配置，服务器配置，修改配置。填入URL和代码中定义的Token，随机生成EncodingAESKey，消息加解密方式选择明文，提交。提交成功，就完成了微信公众号和服务器的绑定。用户发送给微信公众号的消息，会转发给我们的服务器；服务器处理完成后的信息返回给微信公众号，微信公众号再把消息转发给用户。
4、测试扫码关注自己的公众号，然后发送任意信息，看看返回了啥？Today is wonderful day!
源码分享https://github.com/voidking/wecms/releases/tag/v0.0.0
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>微信公众平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Django开发微信公众平台管理系统——第1章</title>
    <url>/dev-django-wechat-1/</url>
    <content><![CDATA[前言紧接着《Django开发微信公众平台管理系统——第0章》，本文学习一下微信公众平台各种消息的接收和回复，主要参考WeRoBot文档。
消息类型包括：TextMessage、ImageMessage、LinkMessage、LocationMessage、VoiceMessage、VideoMessage、UnknownMessage；事件类型包括：SubscribeEvent、UnSubscribeEvent、ScanEvent、ScanCodePushEvent、ScanCodeWaitMsgEvent、PicSysphotoEvent、PicPhotoOrAlbumEvent、PicWeixinEvent、LocationSelectEvent、ClickEvent、ViewEvent、LocationEvent、TemplateSendJobFinishEvent、UserScanProductEvent、UserScanProductEnterSessionEvent、UserScanProductAsyncEvent、UserScanProductVerifyActionEvent、CardPassCheckEvent、CardNotPassCheckEvent、UserGetCardEvent、UserGiftingCardEvent、UserDelCardEvent、UserConsumeCardEvent、UserPayFromPayCellEvent、UserViewCardEvent、UserEnterSessionFromCardEvent、UpdateMemberCardEvent、CardSkuRemindEvent、CardPayOrderEvent、SubmitMembercardUserInfoEvent、UnknownEvent；回复类型包括：TextReply、ImageReply、VoiceReply、VideoReply、ArticlesReply、MusicReply、TransferCustomerServiceReply、SuccessReply。


原理微信发给 /main/wechat/ 接口的信息（message），都传给了robot对象，robot对象根据消息类型调用自己的handler，处理后返回结果给微信。
实现根据消息类型返回信息修改 wecms/main/views_wechat.py ，内容为：
import werobotrobot = werobot.WeRoBot(token='vkwechat')@robot.handlerdef index(message):    return 'Today is wonderful day!'@robot.textdef text(message):    return '您发送了文本消息，内容为：' + message.content@robot.imagedef image(message):    return '您发送了图片消息，图片为：' + message.img@robot.linkdef link(message):    return '您发送了链接消息，链接为：' + message.url@robot.locationdef location(message):    return '您发送了位置消息，位置为：' + message.label@robot.voicedef voice(message):    return '您发送了声音消息，media_id为：' + message.media_id@robot.videodef video(message):    return '您发送了视频消息，media_id为：' + message.media_id

此时给公众号发送不同类型的消息，返回的内容也是不同的。
返回图片消息1、登录微信公众平台，查看“公众号开发信息”中的“开发者ID(AppID)”和“开发者密码(AppSecret)”，并记录下来。
2、修改 wecms/main/views_wechat.py ，添加AppID和AppSecret的配置，添加media函数：
import werobotfrom werobot.replies import ImageReplyrobot = werobot.WeRoBot(token='vkwechat')robot.config['APP_ID'] = 'app_id'robot.config['APP_SECRET'] = 'app_secret'client = robot.client@robot.handlerdef index(message):    return 'Today is wonderful day!'@robot.filter('image')def media(message):    media_id = client.upload_permanent_media('image', open(r'C:\Users\haojin\Desktop\favicon.png', 'rb'))['media_id']    reply = ImageReply(message=message, media_id=media_id)    return reply# other code

需要注意的是，robot.filter(‘image’)需要放在robot.text的前面。因为werobot是链式匹配的，如果robot.text在前，匹配上了“image”，就会被text()函数处理。
2、查看本机的出口IP，修改“公众号开发信息”中的“IP白名单”，把出口IP填进去。
此时给公众号发送“image”，会返回一张图片。
事件处理以订阅事件和取消事件为例，添加事件处理：
@robot.subscribedef subscribe(event):    print('用户' + event.source + '关注了公众号')    return '感谢关注voidking，您的ID为：' + event.source@robot.unsubscribedef unsubscribe(event):    print('用户' + event.source + '取消了关注')    return ''
此时关注公众号，会收到自己的OpenID。
配置文件前面的开发中，用到了token、APP_ID和APP_SECRET。这些信息应该写在配置文件中，而不是代码中，因此需要调整。
1、编辑 wecms/wecms/settings.py，添加：
# Wechat ConfigTOKEN = 'vkwechat'APP_ID = 'app_id'APP_SECRET = 'app_secret'

2、编辑 wecms/main/views_wechat.py ，修改为：
from django.conf import settingsimport werobotfrom werobot.replies import ImageReplyrobot = werobot.WeRoBot(token=settings.TOKEN)robot.config['APP_ID'] = settings.APP_IDrobot.config['APP_SECRET'] = settings.APP_SECRETclient = robot.client# other code

源码分享https://github.com/voidking/wecms/releases/tag/v0.1.0
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>微信公众平台</tag>
      </tags>
  </entry>
  <entry>
    <title>Django开发微信公众平台管理系统——发布篇</title>
    <url>/dev-django-wechat-deploy/</url>
    <content><![CDATA[前言《Django开发微信公众平台管理系统——第0章》一文中完成了wecms项目初始框架的搭建，并且绑定了微信公众号，实现了回复用户的任意消息。但是，wecms项目是运行在本地的，关机后服务就不可用了，因此需要把项目部署到线上。本文中会使用docker搭建django环境，并且部署wecms项目。


安装django1、登录dockerhub查看需要的Django - Docker Official Images。wecms依赖django2.1.7，但是没有对应版本，因此需要采用Plan B，自己安装Django。
2、登录dockerhub查看需要的Python - Docker Official Images。
3、下载python镜像（wecms依赖python3.6.3）docker pull python:3.6.3
4、导出本地依赖信息
pip freeze &gt; requirements.txt
导出后把requirements.txt上传到服务器。
5、编写Dockerfile安装django2.1.7，指定工作目录，添加启动命令
FROM python:3.6.3COPY requirements.txt /tmpRUN pip install --no-cache-dir -i https://pypi.doubanio.com/simple/ -r /tmp/requirements.txtWORKDIR /opt/wecmsEXPOSE 8000CMD ["python", "manage.py", "runserver", "0.0.0.0:8000"]

6、生成wecms镜像并上传
docker build -t voidking/wecms:v1.0 .docker logindocker push voidking/wecms:v1.0

7、下载项目源码
cd /optgit clone https://github.com/voidking/wecms.gitcd wecmsgit checkout v0.0.0

8、启动wecms服务
docker run --name vk-wecms -d \-p 8000:8000 \-v /opt/wecms:/opt/wecms \voidking/wecms:v1.0

以上命令：

命名容器为vk-wecms，后台运行
映射宿主机8000端口到容器的8000端口
挂载宿主机目录/opt/wecms到容器目录/opt/wecms

更多启动命令参数可以参考python - How to use this image和django - How to use this image。
9、验证安装docker ps，nginx启动正常的话就可以看到vk-wecms容器。curl localhost:8000，可以看到welcome to wecms!
浏览器访问 http://hostip:8000/ ，提示You may need to add ‘hostip’ to ALLOWED_HOSTS.因此修改 wecms/wecms/settings.py ，添加：
ALLOWED_HOSTS = ['*']
修改后的tag为v0.0.1。
安装mysql当前项目还没有使用到数据库，而且默认使用sqlite3，不过后期会改成mysql，所以这里做个铺垫。mysql安装配置参考《使用Docker安装配置Mysql》。
域名配置域名解析dnspod添加A记录，wecms记录值解析到hostip。
配置Nginx创建 /etc/nginx/conf.d/wecms.voidking.com.conf ，内容为：
server &#123;    server_name wecms.voidking.com;     listen 80;    location / &#123;        proxy_set_header Host $host;        proxy_set_header X-Forward-For $remote_addr;        proxy_set_header X-Real-IP $remote_addr;        proxy_pass http://127.0.0.1:8000;     &#125;&#125;
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>docker</category>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>微信公众平台</tag>
        <tag>dokcer</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-Compose入门篇</title>
    <url>/dev-docker-compose/</url>
    <content><![CDATA[Docker-Compose简介Compose是用于定义和运行多容器Docker应用程序的工具。通过Compose，可以使用YAML文件来配置应用程序的服务。然后使用一个命令，就可以从配置中创建并启动所有服务。Compose可在所有环境中工作：生产、模拟、开发、测试以及CI工作流。
使用Compose基本上是三步流程：

使用Dockerfile定义应用程序的环境，以便可以在任何地方复制它。
在docker-compose.yml中定义组成您的应用程序的服务，以便它们可以在隔离的环境中一起运行。
运行docker-compose up，然后Compose启动并运行整个应用程序。

Docker-Compose项目由Python编写，调用Docker服务提供的API来对容器进行管理。因此，只要所操作的平台支持Docker API，就可以在其上利用Compose来进行编排管理。更多内容参考Overview of Docker Compose。


安装Compose在CentOS7机器上，假设已经了Docker，参考Install Docker Compose安装Compose-Docker。如果没有安装Docker，那么参考Docker入门进行安装。
1、安装docker-compose
sudo curl -L "https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose

2、添加执行权限
sudo chmod +x /usr/local/bin/docker-composesudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose

3、验证安装docker-compose --version
Hello World1、创建测试目录
mkdir composetestcd composetest

2、在项目目录中创建一个名为app.py的文件，内容为：
import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host='redis', port=6379)def get_hit_count():    retries = 5    while True:        try:            return cache.incr('hits')        except redis.exceptions.ConnectionError as exc:            if retries == 0:                raise exc            retries -= 1            time.sleep(0.5)@app.route('/')def hello():    count = get_hit_count()    return 'Hello World! I have been seen &#123;&#125; times.\n'.format(count)
在此示例中，redis是应用程序网络上的redis容器的主机名，使用默认端口6379。
3、创建requirements.txt文件，内容为：
flaskredis

4、创建Dockerfile，内容为：
FROM python:3.7-alpineWORKDIR /codeENV FLASK_APP app.pyENV FLASK_RUN_HOST 0.0.0.0RUN apk add --no-cache gcc musl-dev linux-headersCOPY requirements.txt requirements.txtRUN pip install -r requirements.txtCOPY . .CMD ["flask", "run"]

该文件说明：

从Python 3.7映像开始构建映像。
将工作目录设置为/code。
设置flask命令使用的环境变量。
安装gcc，以便诸如MarkupSafe和SQLAlchemy之类的Python包可以编译加速。
复制requirements.txt并安装Python依赖项。
复制当前目录中的所有文件到工作目录。
将容器的默认命令设置为flask run。

有关如何编写Dockerfile的更多信息，参考Docker用户指南和Dockerfile参考。
5、创建docker-compose.yml，内容为：
version: '3'services:  web:    build: .    ports:      - "15000:5000"  redis:    image: "redis:alpine"
该Compose文件定义了两个服务：Web和Redis。Web服务从Dockerfile构建镜像，启动后容器在5000端口提供服务，然后将容器端口5000绑定到主机端口15000。
6、使用Compose构建和运行应用docker-compose up
7、测试应用curl http://127.0.0.1:15000
Hello World 2.01、编辑docker-compose.yml，挂载当前目录到/code
version: '3'services:  web:    build: .    ports:      - "5000:5000"    volumes:      - .:/code    environment:      FLASK_ENV: development  redis:    image: "redis:alpine"

2、运行应用docker-compose up
3、修改app.py
import timeimport redisfrom flask import Flaskapp = Flask(__name__)cache = redis.Redis(host='redis', port=6379)def get_hit_count():    retries = 5    while True:        try:            return cache.incr('hits')        except redis.exceptions.ConnectionError as exc:            if retries == 0:                raise exc            retries -= 1            time.sleep(0.5)@app.route('/')def hello():    count = get_hit_count()    return 'Hello World 2.0! I have been seen &#123;&#125; times.\n'.format(count)

4、测试应用curl http://127.0.0.1:15000
常用命令# 构建和运行应用docker-compose up# 构建和后台运行应用docker-compose up -d# 关闭应用docker-compose down# 关闭应用，并删除Redis容器内数据docker-compose down --volumes# 查看容器docker-compose ps# 查看web服务的环境变量docker-compose run web env

书签Overview of Docker Compose
Docker 入门教程
docker/compose
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker中使用定时任务</title>
    <url>/dev-docker-crontab/</url>
    <content><![CDATA[前言《Linux设置定时任务》一文中学习了crontab的使用方法，但是同样的配置方法，在Docker中是不会生效的。因为Docker中默认只会启动一个进程，crond并不会启动。本文研究一下在Docker中配置定时任务的方法，踩踩坑。


启动crond要想在容器中使用定时任务，有三个办法：

把crond作为一号进程启动。
supervisor作为一号进程启动，使用supervisor启动crond。
进入容器手动启动crond。

本文使用第一个方法启动crond，启动命令为：
docker run --name vkcrond -d -it voidking/crond:v1.0 "/bin/bash" "-c" "/usr/sbin/crond &gt; start.log &amp;&amp; tail -f start.log"

crond日志1、查看crond日志tail /var/log/cron报错没有这个文件，这是因为没有打开rsyslog。
2、打开rsyslog
# centos/etc/init.d/rsyslog start# centos7systemctl restart rsyslog.service# centos6service rsyslog restart

再次查看，crond日志文件就存在了。
使用crondcrond启动后，其他的配置参考《Linux设置定时任务》即可。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置GateOne</title>
    <url>/dev-docker-gateone/</url>
    <content><![CDATA[GateOne简介
Gate One is a web-based Terminal Emulator and SSH client that brings the power of the command line to the web. It requires no browser plugins and is built on top of a powerful plugin system that allows every aspect of its appearance and functionality to be customized.

本文使用Docker安装配置GateOne，搭建一个Web Shell环境。前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为192.168.56.130。


安装GateOne1、登录dockerhub查看需要的liftoff/gateone版本，实际上只有一个版本。
2、下载gateone镜像docker pull liftoff/gateone
3、启动gateone服务
docker run --name=vk-gateone -d \-p 8000:8000 \liftoff/gateone gateone

以上命令：命名容器为vk-gateone，后台运行；映射宿主机8000端口到容器8000端口。
更多命令参考Using this Image。
4、验证安装docker psgateone启动正常的话就可以看到vk-gateone容器。如果启动失败，可以使用docker logs vk-gateone查看失败原因并进行解决。
使用nc命令验证：
yum install ncnc -v localhost 8000

浏览器访问： https://192.168.56.130:8000
5、使用点击 Terminal:SSH ，输入主机IP、端口号、用户名和密码，即可登录主机。
如果想要添加鉴权验证，参考archlinux-Gateone和API Authentication。
开放端口如果浏览器无法访问8000端口，那么需要对防火墙进行设置。
firewall-cmd --add-port=8000/tcp --permanentsystemctl reload firewalld# 或者systemctl stop firewalld

安装openssh-server1、进入vk-gateonedocker exec -it vk-gateone /bin/bash
2、安装openssh-server
apt updateapt install openssh-server

3、vim /etc/ssh/sshd_config，如下修改：
PasswordAuthentication yes

4、重启sshservice ssh restart
5、添加用户
useradd -m voidking -s /bin/bashpasswd voidkingadduser voidking sudo# 安装sudo命令（该容器内没有sudo）apt install sudo

6、登录vk-gateone容器点击 Terminal:SSH ，主机名和端口使用默认，输入用户名voidking和密码，即可登录vk-gateone。
小技巧在gateone shell里，可以使用 ctrl+insert 进行复制，使用 shift+insert 进行粘贴。如果在界面无法使用鼠标光标选中一些区域，那么可以在任意位置进行双击，即可激活光标选择。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>shell</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置GitLab</title>
    <url>/dev-docker-gitlab/</url>
    <content><![CDATA[前言《CentOS7安装配置GitLab》一文中学习了GitLab的安装方法，如果使用Docker来安装GitLab，可以简单很多。
前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为192.168.56.130。


安装GitLab1、登录dockerhub查看需要的GitLab Docker images。
2、下载gitlab镜像（以12.6.1-ce.0版本为例）docker pull gitlab/gitlab-ce:12.6.1-ce.0
3、启动gitlab服务
docker run --name vk-gitlab -d  \-p 80:80 -p 443:443 -p 3422:22  \--restart always \-v /opt/gitlab/config:/etc/gitlab \-v /opt/gitlab/logs:/var/log/gitlab \-v /opt/gitlab/data:/var/opt/gitlab \gitlab/gitlab-ce:12.6.1-ce.0
以上命令：

命名容器为vk-gitlab，后台运行
映射宿主机80、443、3422端口到容器80、443、22端口
意外关闭后自动重启
挂载三个宿主机目录到容器

4、验证安装docker psgitlab启动正常的话就可以看到vk-gitlab容器。如果启动失败，可以使用docker logs vk-gitlab查看失败原因并进行解决。
验证GitLab开放端口firewall-cmd --add-port=80/tcp --permanentfirewall-cmd --add-port=443/tcp --permanentfirewall-cmd --add-port=3422/tcp --permanentsystemctl reload firewalld# 或者systemctl stop firewalld

端口验证nc -v localhost 22nc -v localhost 3422
可以看到两个端口的返回结果不同：SSH-2.0-OpenSSH_7.4SSH-2.0-OpenSSH_7.2p2 Ubuntu-4ubuntu2.8
服务验证宿主机测试：curl localhost -L浏览器测试：http://192.168.56.130
配置GitLabhttp域名访问1、配置url和ssh协议端口vim /opt/gitlab/config/gitlab.rb，如下修改：
# line 23, uncomment and changeexternal_url 'http://gitlab.voidking.com'# line 56, uncomment and changegitlab_rails['gitlab_ssh_host'] = 'gitlab.voidking.com'# line 456, uncomment and changegitlab_rails['gitlab_shell_ssh_port'] = 3422

该配置的效果是，当用户在gitlab项目页面点击Clone时，Clone with HTTP和Clone with SSH的结果类似于：
http://gitlab.voidking.com/root/voidking.gitssh://git@gitlab.voidking.com:3422/root/voidking.git

2、重启vk-gitlabdocker restart vk-gitlab
3、修改主机hosts
192.168.56.130  gitlab.voidking.com

4、测试访问浏览器访问：http://gitlab.voidking.com
https域名访问参考《CentOS7安装配置GitLab》添加SSL一节，生成证书，配置gitlab使用证书，并且添加到浏览器。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置Grafana</title>
    <url>/dev-docker-grafana/</url>
    <content><![CDATA[Grafana简介
Grafana allows you to query, visualize, alert on and understand your metrics no matter where they are stored.

本文中，我们会使用Docker来安装配置grafana，并且显示prometheus中的数据。前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为192.168.56.102。


安装Grafana1、登录dockerhub查看需要的grafana版本。
2、下载grafana镜像（以grafana6.7.4为例）docker pull grafana/grafana:6.7.4
3、启动grafana服务
docker run --name=vk-grafana -d \-p 3000:3000 \grafana/grafana:6.7.4

以上命令：

命名容器为vk-grafana，后台运行
映射宿主机3000端口到容器3000端口

grafana的配置文件为 /etc/grafana/grafana.ini ，可以进入容器进行修改，或者挂出到宿主机。
更高级的启动命令参考How to use the container。
4、验证安装docker psmysql启动正常的话就可以看到vk-grafana容器。如果启动失败，可以使用docker logs vk-grafana查看失败原因并进行解决。
开放端口firewall-cmd --add-port=3000/tcp --permanentsystemctl reload firewalld# 或者systemctl stop firewalld

测试服务1、本机测试curl localhost:3000
2、浏览器测试访问 http://192.168.56.102:3000用户名密码默认都是admin，第一次登录会提示修改。
配置Prometheus数据假设我们已经安装配置好了prometheus，参考《使用Docker安装配置Prometheus》。
1、添加数据资源
2、配置Prometheus数据Name填入 Prometheus ，URL填入 http://192.168.56.102:9090，其他不用变。Save&amp;Test。
3、选择dashboard点击Dashboards，点击三个Import，引入三个dashboard。
4、引入其他dashboard比如可以填入URL https://grafana.com/grafana/dashboards/405 ，点击Load，就可以下载Node Exporter的dashboard。选择Folder，选择Prometheus数据源，Import。
5、查看dashboard左上角HOME，出现下拉框，即可选择dashboard。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos</tag>
        <tag>grafana</tag>
        <tag>监控</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置Jenkins</title>
    <url>/dev-docker-jenkins/</url>
    <content><![CDATA[前言《CentOS7安装部署Jenkins》一文中学习了Jenkins的安装方法，如果使用Docker来安装Jenkins，同样可以简单很多。
前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为192.168.56.130。


安装Jenkins1、登录dockerhub查看需要的jenkins-Docker Official Images。需要注意，官方的jenkins最新版本是2.60.3，版本太低！如果安装该版本，安装后会出现各种插件使用不了的情况。因此，这里真正需要使用的jenkins命名空间下的jenkins。
2、下载jenkins镜像（以2.210为例）docker pull jenkins/jenkins:2.210
3、启动jenkins服务
docker run --name vk-jenkins -d \-p 8080:8080 -p 50000:50000 \-v /opt/jenkins_home:/var/jenkins_home \jenkins/jenkins:2.210
以上命令：

命名容器为vk-jenkins，后台运行
映射宿主机8080、50000端口到容器8080、50000端口
挂载宿主机目录/opt/jenkins_home到容器目录/var/jenkins_home

更多启动命令参数可以参考How to use this image。
启动报错：
docker: Error response from daemon: driver failed programming external connectivity on endpoint vk-jenkins (d95f7502bb87d6795547061a2f13b5e2ba44648977399fcde1c05640f678554a):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 50000 -j DNAT --to-destination 172.17.0.2:50000 ! -i docker0: iptables: No chain/target/match by that name. (exit status 1)).

解决办法：重启docker，然后重新执行启动命令。
systemctl restart dockerdocker rm vk-jenkinsdocker run --name vk-jenkins -d \-p 8080:8080 -p 50000:50000 \-v /opt/jenkins_home:/var/jenkins_home \jenkins/jenkins:2.210

4、验证安装docker psjenkins启动正常的话就可以看到vk-jenkins容器。如果启动失败，可以使用docker logs vk-jenkins查看失败原因并进行解决。本例中确实报错了，提示目录权限问题：
touch: cannot touch '/var/jenkins_home/copy_reference_file.log': Permission deniedCan not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?

这是因为/opt/jenkins_home目录的拥有者为root用户，而容器中jenkins user的uid为1000，因此需要修改目录权限。
chown -R 1000:1000 /opt/jenkins_homedocker start vk-jenkins

配置使用Jenkins1、加速插件安装（推荐）参考Jenkins安装插件提速，修改/opt/jenkins_home/updates/default.json。
sed -i 's/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g' default.jsonsed -i 's/http:\/\/www.google.com/https:\/\/www.baidu.com/g' default.json
修改完成重启vk-jenkins，正常进入安装流程，直观感觉就是“安装推荐的插件”这一步速度能够提高一百倍。
2、查看初始密码cat /opt/jenkins_home/secrets/initialAdminPassword
3、jenkins配置浏览器访问：http://192.168.56.130:8080/初始密码填入页面，开始进行jenkins配置。
4、后续接下来的配置和使用参考《CentOS7安装部署Jenkins》即可。
至此，docker安装配置jenkins完成。因为第一次使用的是官方的jenkins2.60.3镜像，所以遇到了一些坑，下面一节中进行记录。
jenkins2.60.3问题解决1、安装推荐的插件，会卡在Getting Started。。这是因为安装插件前会尝试连接 www.google.com ，来判断网络是否连通。国内用户需要改成 www.baidu.com ，vim /opt/jenkins_home/updates/default.json，找到google，修改为baidu。
# 修改前"connectionCheckUrl":"http://www.google.com/",# 修改后"connectionCheckUrl":"http://www.baidu.com/",

2、重启jenkins特别慢docker restart vk-jenkins发现重启特别特别慢，大概要10分钟左右才能重启成功。而且，重启后connectionCheckUrl中的baidu又变成了google！！！
3、修改updatecenter怀疑在jenkins启动时会根据其他地方的配置更改default.json，但是没有找到。查找资料发现了一篇update jenkins Updatecenter from CLI，其中一行：
wget -O default.json http://updates.jenkins-ci.org/update-center.json
那么，如果修改updatecenter为中国的镜像站，是不是就会使用中国的update-center.json代替default.json？试一试，vim /opt/jenkins_home/hudson.model.UpdateCenter.xml，原文为：
&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;sites&gt;  &lt;site&gt;    &lt;id&gt;default&lt;/id&gt;    &lt;url&gt;http://updates.jenkins-ci.org/update-center.json&lt;/url&gt;  &lt;/site&gt;&lt;/sites&gt;
中国镜像站去哪里找呢？可以在the status of Jenkins mirrors网站上选择。hudson.model.UpdateCenter.xml修改为：
&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;sites&gt;  &lt;site&gt;    &lt;id&gt;default&lt;/id&gt;    &lt;url&gt;https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json&lt;/url&gt;  &lt;/site&gt;&lt;/sites&gt;
删除/opt/jenkins_home/updates目录，再次重启vk-jenkins。重启速度飞快，10秒左右，但是default.json中依然是google，因为镜像站里的update-center.json和jenkins源站里的update-center.json相同。既然jenkins启动时都会使用远端的update-center.json替代本地的default.json，那么解决该问题的方法就是给hudson.model.UpdateCenter.xml一个远端的修改后的update-center.json，或者不让jenkins获取到远端update-center.json。
4、填写假的updatecenter修改hudson.model.UpdateCenter.xml为：
&lt;?xml version='1.0' encoding='UTF-8'?&gt;&lt;sites&gt;  &lt;site&gt;    &lt;id&gt;default&lt;/id&gt;    &lt;url&gt;http://localhost&lt;/url&gt;  &lt;/site&gt;&lt;/sites&gt;
因为获取不到update-center.json，然后就可以跳过安装插件的步骤。
5、更换新版jenkins镜像jenkins安装成功，但是在jenkins的系统配置页面，可以看到很多插件报错，而且无法修复，系统建议进行jenkins升级。此时，郝同学才意识到，官方jenkins镜像不是最新版！！！需要改用jenkins命名空间下的新版jenkins镜像，但是“安装推荐的插件”这一步依然很慢，几个小时甚至更久才能安装成功。加速方法可以参考本文 配置使用Jenkins 一节中的 加速插件安装。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置Jupyter</title>
    <url>/dev-docker-jupyter/</url>
    <content><![CDATA[前言《Jupyter notebook》一文中学习了jupyter的使用，本文学习一下怎样使用docker安装jupyter，并且配置访问密码。
前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为192.168.56.130。


安装jupyter1、登录dockerhub查看需要的Jupyter - Docker Official Images。
2、下载jupyter镜像（以6.1.1为例）docker pull jupyter/base-notebook:notebook-5.7.8
注意不要使用6.x.x，存在页面无法显示扩展插件的bug，详情参考Jupyter nbextensions_configurator not shown。
3、创建配置目录
mkdir -p /opt/jupyter/jovyanmkdir -p /opt/jupyter/jovyan/.jupyterchmod 777 -R /opt/jupyter/jovyan

4、启动jupyter服务
docker run --name vk-jupyter -d \-p 8888:8888 \-v /opt/jupyter/jovyan:/home/jovyan \jupyter/base-notebook:notebook-5.7.8

以上命令：

命名容器为vk-jupyter，后台运行
映射宿主机8888端口到容器的8888端口
挂载宿主机目录/opt/jupyter/jovyan到容器目录/home/jovyan

更多启动命令参数可以参考Jupyter Docker Stacks。
5、验证安装docker ps，jupyter启动正常的话就可以看到vk-jupyter容器。
浏览器访问 http://192.168.56.130:8888 ，可以看到Jupyter登录页面。
6、登录docker exec -it vk-jupyter jupyter notebook list可以查看到登录需要的token，使用token即可登录进入jupyter编辑页面。
配置jupyter1、设置密码
docker exec -it vk-jupyter jupyter notebook passworddocker restart vk-jupyter

2、使用密码浏览器访问 http://192.168.56.130:8888此时使用自己设置的密码就可以访问jupyter了。
3、根目录jupyter编辑器的默认根目录为 /home/jovyan ，对应宿主机目录 /opt/jupyter/jovyan ，创建的目录和文件都去这个路径下面去找。
4、安装ipywidgets 如果不安装ipywidgets，页面加载 /nbextensions/widgets/notebook/js/extension.js 文件时会报错404。
docker exec -it vk-jupyter pip install ipywidgets

配置Nginxjupyter 使用了 websocket 协议，所以需要配置支持 websocket。如果不配置的话，通过域名访问时会报错无法连接内核，也就无法运行python脚本。
server &#123;    listen 80;    server_name jupyter.voidking.com;    charset utf-8;    location /&#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_pass http://172.17.12.85:8888;        # WebSocket support        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection "upgrade";    &#125;&#125;

jupyter小技巧执行bash在代码框里输入叹号+bash命令，即可执行bash，例如：!ls -l
登录进容器docker exec -it vk-jupyter /bin/bashdocker exec --user root -it vk-jupyter /bin/bash

安装常用命令docker exec --user root -it vk-jupyter /bin/bashapt updateapt install curlapt install unzip

安装插件Jupyter Notebook 扩展插件（nbextensions）是一些 JavaScript 模块，我们可以使用插件强化 Notebook 的功能。扩展插件本质上修改了 Jupyter UI，以实现更强大的功能。1、界面添加 Nbextensions
docker exec -it vk-jupyter conda install -c conda-forge jupyter_nbextensions_configurator#docker exec -it vk-jupyter pip install jupyter_nbextensions_configurator -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/docker exec -it vk-jupyter jupyter nbextensions_configurator enable --userdocker exec -it vk-jupyter jupyter nbextension listdocker restart vk-jupyter

2、安装常用扩展集合
docker exec -it vk-jupyter pip install jupyter_contrib_nbextensions -i https://mirrors.tuna.tsinghua.edu.cn/pypi/web/simple/#docker exec -it vk-jupyter conda install -c conda-forge jupyter_contrib_nbextensionsdocker exec -it vk-jupyter jupyter contrib nbextension install --userdocker exec -it vk-jupyter jupyter nbextension list

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置Mysql</title>
    <url>/dev-docker-mysql/</url>
    <content><![CDATA[前言《CentOS7设置mysql开机自启动》和《CentOS安装多版本MySQL》中都涉及了Mysql的安装方法，本文中会提供一个更好的Mysql安装方法。
前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为192.168.56.130。


安装Mysql安装mysql-server1、登录dockerhub查看需要的mysql版本。
2、下载mysql镜像（以mysql5.6为例）docker pull mysql:5.6
3、启动mysql服务
docker run --name vk-mysql -d \-p 3306:3306 \-v /opt/data/mysql:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=voidking \mysql:5.6

以上命令：

命名容器为vk-mysql，后台运行
映射宿主机3306端口到容器3306端口
映射宿主机/opt/data/mysql目录（不需要提前创建目录）到容器/var/lib/mysql，用于存储mysql数据到宿主机
设置数据库密码为voidking

更高级的启动命令参考How to use this image。
4、验证安装docker psmysql启动正常的话就可以看到vk-mysql容器。如果启动失败，可以使用docker logs vk-mysql查看失败原因并进行解决。
开放端口firewall-cmd --add-port=3306/tcp --permanentsystemctl reload firewalld# 或者systemctl stop firewalld

安装mysql-client1、在宿主机或者其他机器上，安装mysql-clientyum install -y mariadb.x86_64 mariadb-libs.x86_64
2、连接mysql-servermysql -h 192.168.56.130 -P 3306 -u root -p输入密码，即可连接到vk-mysql容器服务。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>docker</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置Nginx</title>
    <url>/dev-docker-nginx/</url>
    <content><![CDATA[前言《CentOS7设置nginx开机自启动》一文中学习了在CentOS7中安装配置Nginx的方法，本文学习一下使用Docker安装配置Nginx的方法。
前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为8.136.13.58。


安装Nginx1、登录dockerhub查看需要的Nginx - Docker Official Images。
2、下载nginx镜像（以1.17.7为例）docker pull nginx:1.17.7
3、拷贝nginx镜像中的文件到宿主机
docker run --name tmp-nginx -d nginx:1.17.7mkdir -p /opt/nginxdocker cp tmp-nginx:/etc/nginx/conf.d /opt/nginx/docker cp tmp-nginx:/usr/share/nginx/html /opt/nginx/docker stop tmp-nginxdocker rm tmp-nginx

4、启动nginx服务
docker run --name vk-nginx -d --privileged=true \-p 80:80 -p 443:443 \-v /opt/nginx/conf.d:/etc/nginx/conf.d:ro \-v /opt/nginx/ssl:/etc/nginx/ssl:ro \-v /opt/nginx/html:/usr/share/nginx/html:ro \-v /opt/nginx/work:/usr/share/nginx/work:ro \-v /opt/nginx/log:/var/log/nginx:rw \nginx:1.17.7

以上命令：

命名容器为vk-nginx，后台运行
映射宿主机80、443端口到容器的80、443端口
挂载宿主机目录/opt/nginx/conf.d到容器目录/etc/nginx/conf.d
挂载宿主机目录/opt/nginx/ssl到容器目录/etc/nginx/ssl
挂载宿主机目录/opt/nginx/html到容器目录/usr/share/nginx/html
挂载宿主机目录/opt/nginx/work到容器目录/usr/share/nginx/work
挂载宿主机目录/opt/nginx/log到容器目录/var/nginx/log

更多启动命令参数可以参考How to use this image。
5、验证安装docker ps，nginx启动正常的话就可以看到vk-nginx容器。curl localhost，可以看到html文本。浏览器访问 http://8.136.13.58 ，可以看到Welcome to nginx!
配置使用Nginx以添加 www.voidking.com 域名为例，参考《Hexo启用https加密连接》和《Hexo加速访问》。
1、下载博客项目
mkdir /opt/nginx/workgit clone https://gitee.com/voidking/voidking.github.io.git voidking

2、上传证书上传 1_www.voidking.com_bundle.crt 和 2_www.voidking.com.key 到/opt/nginx/conf.d/ssl目录
3、创建配置文件
cd /opt/nginx/conf.dvim www.voidking.com.conf

内容为：
server &#123;    listen 80;    listen 443 ssl;    server_name www.voidking.com;    charset utf-8;    ssl_certificate /etc/nginx/ssl/1_www.voidking.com_bundle.crt;    ssl_certificate_key  /etc/nginx/ssl/2_www.voidking.com.key;    ssl_session_timeout  5m;    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers  HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM;    ssl_prefer_server_ciphers on;    if ($ssl_protocol = "") &#123;        return 301 https://$host$request_uri;    &#125;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;        root /usr/share/nginx/work/voidking/;        index index.html;    &#125;    error_page 404 /404.html;    location = /404.html &#123;        root /usr/share/nginx/work/voidking/;        index 404.html;    &#125;    location ~ /\.git &#123;        return 404;    &#125;&#125;

4、重启nginxdocker restart vk-nginx
5、查看是否启动成功
docker psdocker logs vk-nginxdocker logs --tail 10 vk-nginx

至此， www.voidking.com 域名配置完成，在dnspod添加好解析即可访问，nice。
七牛图床配置七牛图床，http访问不收费，https收费。为了给图床省钱，使用nginx配置了一层代理，添加了域名 cdn.voidking.com.conf 的配置：
server &#123;    listen 80;    listen 443 ssl;    server_name cdn.voidking.com;    charset utf-8;    #ssl配置    ssl_certificate /etc/nginx/ssl/1_cdn.voidking.com_bundle.crt;    ssl_certificate_key  /etc/nginx/ssl/2_cdn.voidking.com.key;    ssl_session_timeout  5m;    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers  HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM;    if ($ssl_protocol = "") &#123;        return 301 https://$host$request_uri;    &#125;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_pass http://qiniu.cdn.voidking.com;    &#125;&#125;

重定向问题排查有一天，通过chrome浏览器访问 http://8.136.13.58 ，发现报错 403
仔细看了下地址栏，原来是 http 自动转到了 https。本地curl验证一下是否是chrome的问题：
curl http://8.136.13.58curl http://8.136.13.58 -L
由上图可以看出，确实是nginx对请求进行了重定向。
那么，为什么通过ip访问会进行重定向？在 default.conf 的配置中，没有进行修改，没有配置任何重定向！这样看来，问题只能出在 www.voidking.com.conf 和 cdn.voidking.com.conf 这两个文件。
删除 www.voidking.com.conf ，重启nginx，问题依然存在。删除 cdn.voidking.com.conf ，重启nginx，问题解决！那么，问题就肯定出在 cdn.voidking.com.conf 这个文件上。从配置上看，没有任何问题，但是为什么会导致IP访问nginx被重定向呢？找了很多资料，没有找到答案。后来灵光一现：cdn.voidking.com.conf 比 default.conf 优先级更高！因为c开头的配置文件要比d开头的配置文件先加载，而 default.conf 并没有特殊的优先级配置。所以，最终结果就是 cdn.voidking.com.conf 才是真正意义上的 default ！
解决方案：重命名 default.conf 为 0.default.conf 。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>docker</category>
        <category>hexo</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker静态IP设置</title>
    <url>/dev-docker-static-ip/</url>
    <content><![CDATA[前言Docker容器运行的时候默认会自动分配一个默认网桥所在网段的IP地址。但很多时候我们可能需要让容器运行在预先指定的静态IP地址上，因为早期的版本不支持静态IP，因此网上大部分方法都是借助pipework等去实现，然而在最新的版本中，Docker已经内嵌支持在启动时指定静态IP了。
Docker守护进程启动以后会创建默认网桥docker0，其IP网段通常为172.17.0.1。在启动Container的时候，Docker将从这个网段自动分配一个IP地址作为容器的IP地址。最新版(1.10.3)的Docker内嵌支持在启动容器的时候为其指定静态的IP地址。


创建自定义网络选取了192.168.34.0网段，也可以指定其他任意空闲的网段。
docker network create --subnet=192.168.34.0/24 voidkingnet

注：voidkingnet为自定义网桥的名字，可自己任意取名。
查看所有docker网段：
docker network ls


设置静态IP在创建的网段中选取了192.168.34.10作为静态IP地址。这里以启动learn/ping为例。
docker run -d -p 2001:2001 --net voidkingnet --ip 192.168.34.10 learn/ping ping www.baidu.com

查看容器ip方法一：
docker inspect $(docker ps -q) | grep IPAddress

方法二：
docker inspect --format='&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;' $(docker ps -q)


关闭容器方法一：
docker stop $(docker ps -q)
关闭所有容器。
方法二：
docker psdocker stop 3e2efd019b9a
查询容器id，关闭指定id的容器。
书签为Docker容器指定自定义网段的固定IP/静态IP地址http://blog.csdn.net/gobitan/article/details/51104362
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker内部使用Supervisor</title>
    <url>/dev-docker-supervisor/</url>
    <content><![CDATA[问题描述使用docker run启动一个beego服务，命令为：
docker run --name bservice -d -p 8080:8080 voidking/bservice:v1 "/bin/bash" "-c" "cd /opt/bservice &amp;&amp; nohup ./bservice"
启动后，beego服务是容器内PID为1的前台进程。假设该服务不是那么健壮，出了bug会停止服务，那么容器也会随之停止。如果想要服务停止后自动启动，那么就需要supervisor出马了。


解决方案参考《CentOS安装配置Supervisor》，在容器中安装supervisor。
1、在/etc/supervisor中新建bservice.conf文件
[program:bservice]directory=/opt/bservicecommand=/opt/bservice/bserviceuser=rootautostart=trueautorestart=truestdout_logfile=/var/log/supervisor/%(program_name)s.logstderr_logfile=/var/log/supervisor/%(program_name)s.log

2、测试启动
systemctl retart supervisordsupervisorctl statusps aux | grep bservice

3、编辑/etc/supervisord.conf，设置supervisor为前台进程
nodaemon=true

4、把容器保存为镜像
docker commit container_id voidking/bservice:v2

5、修改启动命令为
docker run --name bservice -d -p 8080:8080 voidking/bservice:v2 "/bin/bash" "-c" "supervisord -c /etc/supervisord.conf"

使用这种启动方式，哪怕服务因为意外停止，也会马上被supervisor拉起，提高了服务的可用性。
扩展应用再来看另外一个场景：npm run start原本可以正常启动node服务进入后台运行，容器化后通过docker run启动，命令为：
docker run --name fservice -d -p 80:80 voidking/fservice:v1 "/bin/bash" "-c" "cd /opt/fservice &amp;&amp; npm run start"
尴尬的是，容器启动后就会自动退出，这是因为容器运行必须要一个前台进程。因此一个简单的解决办法是修改启动命令，添加tail -f：
docker run --name fservice -d -p 80:80 voidking/fservice:v1 "/bin/bash" "-c" "cd /opt/fservice &amp;&amp; npm run start &gt; ./start.log &amp;&amp; tail -f ./start.log"

但是，更好的办法还是使用supervisor进行node服务的管理。同样需要在容器中安装supervisor，然后进行配置。
1、在/etc/supervisor中新建fservice.conf文件
[program:fservice]directory=/opt/fservicecommand=npm run startuser=rootautostart=trueautorestart=truestdout_logfile=/var/log/supervisor/%(program_name)s.logstderr_logfile=/var/log/supervisor/%(program_name)s.log

2、测试启动
systemctl retart supervisordsupervisorctl statusps aux | grep fservice

3、编辑/etc/supervisord.conf，设置supervisor为前台进程
nodaemon=true

4、把容器保存为镜像
docker commit container_id voidking/fservice:v2

5、修改启动命令为
docker run --name bservice -d -p 8080:8080 voidking/fservice:v2 "/bin/bash" "-c" "supervisord -c /etc/supervisord.conf"]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Swarm</title>
    <url>/dev-docker-swarm/</url>
    <content><![CDATA[Docker Swarm简介Docker Swarm是一个Docker集群调度管理工具。相比于Kubernetes，Swarm内置于Docker，更加轻量，更加简单方便；相应的，就没有Kubernetes那么多强大的特性。
本文搭建使用Swarm，主要参考Swarm mode overview 和 docker swarm（一） 入门 – 搭建一个简单的swarm集群。
已有两个安装好Docker的机器（swarm-manager和swarm-worker），IP分别为 192.168.56.104 和 192.168.56.105 ，两台主机的hosts都添加：
192.168.56.104 swarm-manager192.168.56.105 swarm-worker



Swarm集群搭建manager node在swarm-manager节点：
1、创建swarm manager
docker swarm init --advertise-addr 192.168.56.104

这一步会生成join命令，复制记录一下。
2、验证安装
docker infodocker node ls

3、关闭防火墙，方便其他主机加入成为worker
systemctl stop firewalldsystemctl disable firewalld

worker node在swarm-worker节点：1、关闭防火墙，方便manager调用
systemctl stop firewalldsystemctl disable firewalld

2、加入swarm成为worker
docker swarm join --token SWMTKN-1-21v9lvwrzapfzdzhq4js6xbtyasak4hdcdhz9p13fch23zdbn9-bneduvi9fi4ba05eywhqbe94z 192.168.56.104:2377

PS：脱离swarmdocker swarm leave
验证docker node ls，查看节点状态。
使用Swarm1、部署一个服务
docker service create \--name=vk-nginx \--publish published=80,target=80 \--replicas 1  \voidking/nginx:v1.0

2、查看服务
docker service lsdocker inspect vk-nginx

3、访问服务
curl 192.168.56.104curl 192.168.56.105
如果此时有一个ip是curl不通的，那么说明有问题，因为所有节点都应该添加端口映射关系。
4、服务扩容
docker service scale vk-nginx=4

5、查看服务在节点的分布
docker service ps vk-nginx

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>swarm</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置Tomcat</title>
    <url>/dev-docker-tomcat/</url>
    <content><![CDATA[前言《CentOS7设置tomcat开机自启动》一文中，学习了常规的tomcat安装配置方法；《Docker安装tomcat服务》一文中，学习了在Docker容器中安装配置tomcat的方法；《Dockerfile构建Tomcat》一文中，学习了使用Dockerfile安装配置tomcat的方法。本文是对前三种方法的升级，更加简单。不需要自己制作tomcat镜像，而是使用dockerhub提供的tomcat镜像。
前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为192.168.56.130。


安装Tomcat安装Tomcat1、登录dockerhub查看需要的tomcat版本。
2、下载tomcat镜像（以tomcat8.5.51为例）docker pull tomcat:8.5.51-jdk8-openjdk
3、启动tomcat服务
docker run --name vk-tomcat -d \-p 8080:8080 \-v /opt/tomcat/webapps:/usr/local/tomcat/webapps \tomcat:8.5.51-jdk8-openjdk

以上命令：

命名容器为vk-tomcat，后台运行
映射宿主机8080端口到容器8080端口
映射宿主机/opt/tomcat/webapps目录（不需要提前创建目录）到容器/usr/local/tomcat/webapps目录

更高级的启动命令参考How to use this image。
4、验证安装docker pstomcat启动正常的话就可以看到vk-tomcat容器。如果启动失败，可以使用docker logs vk-tomcat查看失败原因并进行解决。
使用nc命令验证：
yum install ncnc -v localhost 8080

使用curl命令验证：curl localhost:8080
开放端口firewall-cmd --add-port=8080/tcp --permanentsystemctl reload firewalld# 或者systemctl stop firewalld

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>docker</category>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装tomcat服务</title>
    <url>/dev-docker-ubuntu-tomcat/</url>
    <content><![CDATA[部署要求宿主机为CentOS7，上面安装了docker。
1、docker镜像选择ubuntu，在ubuntu中安装tomcat。2、容器8080端口映射为宿主机18080端口。


软件准备1、ubuntu下可以使用的jdk一份，jdk-8u131-linux-x64.tar.gz。下载地址：http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
2、ubuntu下可以使用的tomcat一份，apache-tomcat-8.0.44.tar.gz。下载地址：http://tomcat.apache.org/download-80.cgi
3、使用xftp，上传jdk和tomcat到CentOS7的/download目录下。
docker准备下载镜像docker search ubuntu
docker pull ubuntu
docker images
启动镜像假设我们的所有安装程序都放在了宿主机的/download目录下，现在需要将其挂载到容器的/mnt/software目录下。
docker run -i -t -v /download/:/mnt/software/ ubuntu /bin/bash
注意，上面的ubuntu也可以换成ubuntu的镜像ID。

-i：表示以“交互模式”运行容器。
-t：表示容器启动后会进入其命令行。  
-v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt; 。

启动容器退出容器后，可以再次启动容器（使用容器ID或容器NAMES）。docker ps -l
docker start 87be
注意，先运行docker run，然后被stop掉的容器才可以使用上面的命令。
上面的命令不能进入容器，要进入容器还需要使用：docker attach 87be
安装jdk1、进入容器环境。
2、更新vim，否则上下左右和退格键无法使用。apt-get update
apt-get remove vim-common
apt-get install vim
3、进入jdk所在目录cd /mnt/software
然后参考《全平台安装JDK》，完成剩下的配置。
安装tomcat1、进入容器环境。
2、解压tomcat到/opt目录。cd /mnt/software
tar zxvf apache-tomcat-8.0.44.tar.gz -C /opt
3、启动tomcat。cd /opt/apache-tomcat-8.0.44/bin/
./startup.sh
4、测试访问。apt-get install curl
curl localhost:8080
5、关闭tomcat。./shutdown.sh
编写启动脚本1、进入根目录，新建run.sh文件。cd /
vim run.sh
2、编辑run.sh内容为：
#!/bin/shexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_131export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATHsh /opt/apache-tomcat-8.0.44/bin/catalina.sh run

注意：run.sh中的启动脚本不可以写为：
sh /opt/apache-tomcat-8.0.44/bin/startup.sh run

如果这么写的话，在使用docker run的时候，会自动退出。
因为想要Docker容器后台运行，就必须有一个前台进程。容器运行的命令如果不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。
3、更改run.sh权限chmod 777 run.sh
4、测试访问。./run.sh
curl localhost:8080
保存容器1、退出容器exit
2、查看dockeriddocker ps -l
3、保存容器为ubuntu/tomcat镜像。docker commit 87be ubuntu/tomcat
启动镜像1、启动ubuntu/tomcat镜像docker run -d -p 18080:8080 --name tomcat8.0 ubuntu/tomcat /run.sh

-d：表示以守护模式执行/run.sh脚本，此时 Tomcat 控制台不会出现在输出终端上。  
-p：表示宿主机与容器的端口映射，此时将容器内部的 8080 端口映射为宿主机的 18080 端口。  
–name：表示容器名称，用一个有意义的名称命名即可。  

2、查看容器运行状态docker ps
3、关闭容器docker kill tomcat8.0 或者 docker stop tomcat8.0
4、再次启动容器docker start tomcat8.0
5、测试访问在宿主机中，执行命令 curl localhost:18080。
或者，查到容器IP后，执行命令 curl &lt;容器IP&gt;:8080。
或者，在宿主机中关闭防火墙，systemctl stop firewalld.service。然后，在宿主机同局域网PC浏览器中输入http://&lt;宿主机IP&gt;:18080。
书签Docker部署JavaWeb项目实战
使用 Docker 搭建 Java Web 运行环境
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>docker</category>
        <category>ubuntu</category>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>tomcat</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Dockerfile构建Tomcat镜像</title>
    <url>/dev-dockerfile-build-tomcat/</url>
    <content><![CDATA[前言如果只是想要一个tomcat环境，很简单，直接拉取一个tomcat镜像就可以了。本文中，我们在centos7镜像的基础上，学习使用Dockerfile构建Tomcat镜像。更多的是为了对比，对比了手工构建镜像和使用Dockerfile构建镜像的不同，以便我们更好地理解构建过程。


手工构建镜像启动容器假设我们的所有安装程序都放在了宿主机的/download目录下，现在需要将其挂载到容器的/mnt/software目录下。service docker start
docker run -i -t -v /download/:/mnt/software/ centos:7 /bin/bash
安装jdk1、进入容器环境。
2、可选操作，安装vim增强版。yum install vim-enhanced
3、解压jdk到/usr/lib/jvm目录。cd /mnt/software
mkdir -p /usr/lib/jvm
tar zxvf jdk-8u131-linux-x64.tar.gz -C /usr/lib/jvm/
4、配置JAVA_HOME和JRE_HOME，vi /etc/profile，在最后添加：
export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_131export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH

然后使配置文件生效，source /etc/profile。
5、测试jdk是否配置成功。java，javac
安装tomcat1、进入容器环境。
2、解压tomcat到/opt目录。cd /mnt/software
tar zxvf apache-tomcat-8.0.44.tar.gz -C /opt
3、启动tomcat。cd /opt/apache-tomcat-8.0.44/bin/
./startup.sh
4、测试访问。yum install curl
curl localhost:8080
编写启动脚本1、进入根目录，新建run.sh文件。cd /
vi run.sh
2、编辑run.sh内容为：
#!/bin/shexport JAVA_HOME=/usr/lib/jvm/jdk1.8.0_131export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATHsh /opt/apache-tomcat-8.0.44/bin/catalina.sh run

3、更改run.sh权限chmod 777 run.sh
保存容器1、退出容器exit
2、查看dockeriddocker ps -l
3、保存容器为centos/tomcat。docker commit 206f centos/tomcat
使用镜像1、启动镜像docker run -d -p 18080:8080 centos/tomcat /run.sh
2、测试访问curl localhost:18080
使用Dockerfile构建镜像编写dockerfile1、下载dockerfile项目在宿主机中，git clone https://github.com/voidking/dockerfile.git。
2、进入tomcat文件夹cd dockerfile/tomcat
3、拷贝/download目录到tomcat目录cp -r /download download
4、查看Dockerfile，内容为
## MAINTAINER        VoidKing &lt;voidking@qq.com&gt;# DOCKER-VERSION    17.03.1-ce## Dockerizing Tomcat: Dockerfile for building Tomcat images#FROM centos:7MAINTAINER VoidKing &lt;voidking@qq.com&gt;ENV TZ "Asia/Shanghai"ADD download/jdk-8u131-linux-x64.tar.gz /usr/lib/jvm/ADD download/apache-tomcat-8.0.44.tar.gz /optADD run.sh /run.shRUN chmod 777 /run.shEXPOSE 8080ENTRYPOINT ["/run.sh"]

5、使用当前目录下的Dockerfile，构建一个名为centos/tomcat8.0的镜像docker build -t centos/tomcat8.0 .
docker镜像的命名规则 registry_url/namespace/image_name:tag 默认tag是latest。
使用镜像1、启动镜像docker run -d -p 28080:8080 centos/tomcat8.0 /run.sh
2、测试访问curl localhost:28080
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>docker</category>
        <category>centos</category>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>tomcat</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile中的CMD和ENTRYPOINT</title>
    <url>/dev-dockerfile-cmd-entrypoint/</url>
    <content><![CDATA[前言Dockerfile中的CMD和ENTRYPOINT有什么区别？docker run时默认执行什么命令，怎样覆盖默认命令？pod定义中的args和command字段有什么作用？本文，我们来回答一下这些问题。主要参考Docker RUN vs CMD vs ENTRYPOINT和Mumshad Mannambeth的课程。


指令执行方式RUN和ENTRYPOINT指令都可以有两种执行方式：shell方式和exec方式。
shell方式shell方式格式：&lt;instruction&gt; &lt;command&gt;
例子：
RUN apt-get install python3CMD echo "Hello world"ENTRYPOINT echo "Hello world"

当指令以shell方式执行时，它会在后台调用 /bin/sh -c &lt;command&gt;，并且会进行常规的shell处理。例如，Dockerfile中的以下定义：
ENV name voidkingENTRYPOINT echo "Hello, $name"
docker run 会输出 Hello, voidking ，变量会被替换。
exec方式exec方式格式：&lt;instruction&gt; [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;, ...]例子：
RUN ["apt-get", "install", "python3"]CMD ["/bin/echo", "Hello world"]ENTRYPOINT ["/bin/echo", "Hello world"]
当指令以exec方式执行时，它将直接调用可执行文件，并且不会进行shell处理。例如，Dockerfile中的以下定义：
ENV name voidkingENTRYPOINT ["/bin/echo", "Hello, $name"]
docker run 会输出 Hello, $name ，变量不会被替换。
如果需要运行bash而不是sh，需要使用exec方式。在这种情况下，将进行常规的shell处理。例如，Dockerfile中的以下定义：
ENV name voidkingENTRYPOINT ["/bin/bash", "-c", "echo Hello, $name"]
docker run 会输出 Hello, voidking ，变量会被替换。
CMD和ENTRYPOINTCMD定义访问dockerhub ubuntu，Supported tags and respective Dockerfile links，随便选择一个系统版本，这里选择 16.04 。点击链接，可以看到Dockerfile的定义。
FROM scratchADD ubuntu-xenial-core-cloudimg-amd64-root.tar.gz /# overlook all the definitionCMD ["/bin/bash"]

可以看到，Dockerfile中定义了CMD为 /bin/bash ，也就是定义了默认命令为 /bin/bash。
docker run ubuntu:16.04 会执行默认命令 /bin/bash 。
执行特定命令我们想要执行命令，那么需要在docker run时指定命令，覆盖默认命令。docker run ubuntu:16.04 sleep 3600，会执行 sleep 3600 。
如果想要使这个特定命令永久生效，那么需要使用Dockerfile定义一个新的镜像。
FROM ubuntu:16.04CMD ["sleep","3600"]

docker build -t ubuntu-sleeper .，生成新的镜像。
docker run ubuntu-sleeper，执行默认命令 sleep 3600 。
特定参数如果我们想要修改sleep的时间，该怎么做？
docker run ubuntu:16.04 sleep 3600docker run ubuntu:16.04 sleep 1200

sleep命令没有变，变化的只有参数，sleep是否可以省略？可以的，定义一个新的镜像。
FROM ubuntu:16.04ENTRYPOINT ["sleep"]CMD ["3600"]

docker build -t ubuntu-sleeper .，生成新的镜像。
docker run ubuntu-sleeper，执行默认命令 sleep 3600 。
docker run ubuntu-sleeper 1200，执行命令 sleep 1200 。
那么，ENTRYPOINT里的命令是否可以被替换的呢？也是可以的。docker run --entrypoint sleep2.0 ubuntu-sleeper 1200，执行命令 sleep2.0 1200 。
综上，docker run会默认执行 ENTRYPOINT + CMD。通常情况下，我们会在Dockerfile中定义ENTRYPOINT作为固定命令，定义CMD作为默认参数。
args和command在k8s中定义pod时，有args和command两个字段。这两个字段，分别覆盖CMD和ENTRYPOINT。
apiVersion: v1kind: Podmetadata:  creationTimestamp: null  labels:    run: ubuntu  name: ubuntuspec:  containers:  - image: ubuntu:16.04    name: ubuntu    resources: &#123;&#125;    command: ["sleep"]    args: ["1200"]  dnsPolicy: ClusterFirst  restartPolicy: Alwaysstatus: &#123;&#125;
该pod启动后的执行命令为 sleep 1200 。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile入门篇</title>
    <url>/dev-dockerfile-start/</url>
    <content><![CDATA[什么是Dockerfile？正如《Docker入门篇》一文中所说，容器技术包括容器镜像和容器运行时。其中容器镜像是一个软件集装箱，包含软件运行需要的所有文件。那么，怎样制作一个容器镜像呢？两个方法：第一个方法是修改容器运行时，然后提交修改变成新容器镜像。第二个方法就是使用Dockerfile。

Dockerfile是一个文本文档，其中包含一些指令（类似于shell命令）。Docker可以通过阅读Dockerfile中的指令，来自动构建镜像。

更多内容，参考Dockerfile reference 、菜鸟Docker Dockerfile 和 Dockerfile 使用介绍。
本文，我们就来学习一下Dockerfile的编写和使用。


helloworld1、创建一个Dockerfile文件，内容为
FROM busybox:1.25ENTRYPOINT ["echo"]CMD ["helloworld"]

2、打包新镜像docker build -t busybox-echo:1.25 .
3、运行新镜像docker run busybox-echo:1.25可以看到输出了helloworld，至此，入门仪式完成。
Dockerfile简析Dockerfile可以分为四部分：

基础镜像信息
维护者信息
镜像操作命令
容器启动命令

其中必要的是基础镜像信息，其他都可以不要。只不过这种情况下，构建时就相当于拷贝了一个镜像。
以一个完整的例子说明Dockerfile的四个部分：
# This dockerfile is a demo.# 基础镜像信息FROM ubuntu:16.04# 维护者信息MAINTAINER voidking voidking@qq.com# 镜像操作命令ENV TZ="Asia/Shanghai"RUN apt update &amp;&amp; apt install -y tzdata jq# 容器启动命令CMD ["/bin/bash","-c","echo $(date) &amp;&amp; echo '&#123;\"name\":\"voidking\"&#125;' | jq ."]
FROM：定制的镜像都是基于 FROM 的镜像，这里的 ubuntu:16.04 就是需要的基础镜像。MAINTAINER：维护者信息。ENV：设置环境变量，设置docker容器的时区为Shanghai。RUN：用于执行后面跟着的命令行命令。CMD：容器启动时默认执行的命令。
此外，常用的镜像命令还有COPY和ADD。COPY命令格式：COPY  源路径  目标路径源路径如果是文件，COPY命令拷贝文件到目标路径下。源路径如果是目录，COPY命令拷贝目录下所有文件到目标路径下，目标路径不存在则自动创建。
ADD指令是COPY命令的加强版（addition）：拷贝压缩文件会自动解压，支持从url中拷贝文件。
PS：构建并运行镜像
docker build -t ubuntu-jq:16.04 .docker run ubuntu-jq:16.04

从镜像还原DockerfileDockerImage="busybox-echo:1.25"docker history --format &#123;&#123;.CreatedBy&#125;&#125; --no-trunc=true $DockerImage |sed "s/\/bin\/sh\ -c\ \#(nop)\ //g"|sed "s/\/bin\/sh\ -c/RUN/g" | tac

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile使用Supervisor管理Tomcat</title>
    <url>/dev-dockerfile-supervisor/</url>
    <content><![CDATA[supervisor管理tomcat使用supervisor监控管理的进程必须以nodaemon启动，而tomcat的startup.sh脚本是daemon方式的，如果不做修改的话，supervisor会一直报错。
解决办法一： 
在startup.sh的最后的
exec "$PRGDIR"/"$EXECUTABLE" start "$@"
改为    
exec "$PRGDIR"/"$EXECUTABLE" run "$@"



然后supervisor_tomcat.conf内容为：
[program:tomcat]directory=/opt/apache-tomcat-8.0.44command=/opt/apache-tomcat-8.0.44/bin/startup.shenvironment=JAVA_HOME="/usr/lib/jvm/jdk1.8.0_131",JAVA_BIN="/usr/lib/jvm/jdk1.8.0_131/bin"user=rootautostart=trueautorestart=truestdout_logfile=/var/log/supervisor/%(program_name)s.logstderr_logfile=/var/log/supervisor/%(program_name)s.log

解决办法二：不需要修改startup.sh，还是使用catalina.sh。然后supervisor_tomcat.conf内容为：
[program:tomcat]directory=/opt/apache-tomcat-8.0.44command=/opt/apache-tomcat-8.0.44/bin/catalina.sh runenvironment=JAVA_HOME="/usr/lib/jvm/jdk1.8.0_131",JAVA_BIN="/usr/lib/jvm/jdk1.8.0_131/bin"user=rootautostart=trueautorestart=truestdout_logfile=/var/log/supervisor/%(program_name)s.logstderr_logfile=/var/log/supervisor/%(program_name)s.log

使用Dockerfile构建镜像1、下载dockerfile项目在宿主机中，git clone https://github.com/voidking/dockerfile.git。
2、进入supervisor文件夹cd dockerfile/supervisor
3、拷贝/download目录到supervisor目录cp -r /download download
4、构建一个名为centos/supervisor的镜像docker build -t centos/supervisor .
5、测试启动镜像docker run centos/supervisor
6、正式启动镜像docker run -d -p 18080:8080 centos/supervisor
6、测试访问curl localhost:18080
源码分享https://github.com/voidking/dockerfile.git
书签中国第一套Docker实战案例视频课程（入门到高级）
Docker实战案例源码
Docker实战案例文档
Linux后台进程管理利器：supervisor
tomcat使用supervisor管理
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>docker</category>
        <category>centos</category>
        <category>tomcat</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>tomcat</tag>
        <tag>centos</tag>
        <tag>supervisor</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo入门</title>
    <url>/dev-dubbo-start/</url>
    <content><![CDATA[Dubbo简介Dubbo是阿里巴巴公司开源的一个高性能的分布式服务框架，使得应用可通过高性能的RPC实现服务的输出和输入功能，可以和Spring框架无缝集成。
RPC（Remote Procedure Call）——远程过程调用，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP或UDP，为通信程序之间携带信息数据。在OSI网络通信模型中，RPC跨越了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。


服务调用流程
1、服务容器负责启动，加载，运行服务提供者。2、服务提供者在启动时，向注册中心注册自己提供的服务。3、服务消费者在启动时，向注册中心订阅自己所需的服务。4、注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。5、服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。6、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心
ZookeeperDubbo提供的注册中心有如下几种类型可供选择：

Multicast注册中心
Zookeeper注册中心
Redis注册中心
Simple注册中心

接下来，我们安装一个Zookeeper，用来管理服务。
下载安装1、访问zookeeper官网，下载一个喜欢的zookeeper版本，这里郝同学下载的是zookeeper-3.4.10.tar.gz。
2、解压zookeeper-3.4.10.tar.gz到D:\Server目录。
配置1、zookeeper 的配置文件在 conf 目录下，有 zoo_sample.cfg 和 log4j.properties。
2、将zoo_sample.cfg复制一份，重命名成zoo.cfg，因为zookeeper在启动时会找这个文件作为默认配置文件。下面介绍zoo.cfg文件里面几个配置的意义：

tickTime：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。 
dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里。 
clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。

3、在zookeeper的根目录下，新建文件夹data。然后修改配置文件dataDir为：
dataDir=D:\\Server\\zookeeper-3.4.10\\data

启动1、zookeeper-3.4.10/bin下存在zkServer.cmd，双击它，即可启动zookeeper。
2、打开命令行，输入jsp，如果看到如下提示，说明启动成功。
10336 RemoteMavenServer13488 Jps12268 QuorumPeerMain13052

3、启动之后一直开着，不要关掉这个cmd，记得要在Dubbo消费者和提供者运行之前就开启Zookeeper。
dubbo-admindubbo的使用，其实只需要有注册中心、提供者、消费者这三个就可以使用了，但是并不能看到有哪些消费者和提供者，为了更好的调试，发现问题，解决问题，因此引入dubbo-admin。通过dubbo-admin可以对消费者和提供者进行管理。
1、源码下载git clone https://github.com/alibaba/dubbo.git
这份源码，不止包含dubbo-admin，还有很多其他代码，比如dubbo-demo、dubbo-config等。
2、编译dubbo-admin进入dubbo-admin目录，打开命令行，执行：mvn package -Dmaven.skip.test=true即可在当前目录下生成target文件夹，文件夹中的war包就是我们需要的文件。
3、部署dubbo-admin把war包放到tomcat的webapps目录下，重命名为dubbo-admin.war。
4、启动tomcat进入tomcat的bin目录，然后双击startup.bat。
5、测试访问tomcat会自动解压war包，这时访问 http://localhost:8080/dubbo-admin ，即可看到部署后的效果。
6、用户名密码页面提示输入用户名密码，我们到tomcat/webapps/dubbo-admin/WEB-INF/dubbo.properties中查看，默认用户名密码都是root。
dubbo-demo在上面下载的源码中，包含dubbo-demo。
1、打开dubbo文件夹，构建源码，生成IDEA支持的项目文件
mvn clean install -Dmaven.test.skipmvn idea:idea

编译时，报错：
Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project dubbo-demo-provider: Compilation failure -&gt; [Help 1]

改maven配置，失败。更换maven版本，失败。怒删C:\Users\voidking\.m2\repository中的所有文件，成功。
2、IDEA打开生成的dubbo-parent.ipr文件，就可以看到整个dubbo的工程了。
3、运行Provider.java
报错Error:Maven Resources Compiler: Maven project configuration required for module &#39;hessian-lite&#39; isn&#39;t available. Compilation of Maven projects is supported only if external build is started from an IDE.
打开窗口右侧Maven Project，点击加号选择dubbo根目录下的pom.xml，再次运行Provider.java。
如果没有报错，则说明Provider.java运行成功，它会保持在运行状态。
4、运行Consumer.java运行成功的话，可以看到Consumer控制台打印出 Hello world, response form provider: 169.254.36.242:20880，同时，Provider控制台打印出Hello world, request from consumer: /169.254.36.242:54924。
5、打开dubbo-admin，却看不到提供者。这是因为我们在运行Provider的时候，并没有指定Zookeeper作为注册中心。
6、修改dubbo-demo-provider.xml和dubbo-demo-consumer.xml中的registry。
&lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;&lt;!--&lt;dubbo:registry address="multicast://224.5.6.7:1234"/&gt;--&gt;&lt;dubbo:registry address="zookeeper://localhost:2181"/&gt;

7、重新运行Provider.java，即可看到提供者。重新运行Consumer.java，却看不到消费者，这是因为消费者消费后把socket关闭了。修改Consumer.java，添加System.in.read();并且抛出异常，重新运行即可在dubbo-admin中看到消费者。
小结至此，dubbo的最简单demo运行成功。dubbo支持多种协议，通过协议，可以实现不同语言间的相互调用。接下来，需要研究python调用dubbo服务。待续。。。
书签Dubbo官网
Dubbo官方文档
基于Dubbo框架构建分布式服务
Dubbo架构设计详解
Dubbo入门—搭建一个最简单的Demo框架
Dubbo源码学习（一）之dubbo-demo
pom.xml 缺少commons-pool依赖，导致编译失败

基于Dubbo的Hessian协议实现远程调用
Dubbo实现RPC调用使用入门
基于dubbo框架下的RPC通讯协议性能测试
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>dubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>eclipse实用设置</title>
    <url>/dev-eclipse-practical-setting/</url>
    <content><![CDATA[设置项目默认编码在eclipse中，Window，Preference，General，Workspace，Text file encoding，Other选择UTF-8。
设置JSP页面默认编码在eclipse中，Window，Preference，Web，JSP Files，Encoding选择ISO 10646/Uincode(UTF-8)。
设置代码提示在eclipse中，Window，Preference，Java，Editor，Content Assist，Auto Activation，Auto activation triggers for Java中输入“.”和52个英文字符。
设置快捷键在eclipse中，Window，Preference，General，Keys。


恢复默认布局Window，Perspective，Reset Perspective
eclipse查看JDK源代码eclipse查看JDK中的类，出现The jar file rt.jar has no source attachment。
解决办法：1、Window，Preferences，Java，Installed JREs，选中安装的JRE，Edit。2、JRE system libraries中展开rt.jar。3、Source Attachment…，选中JDK安装目录中的src.zip。
eclipse查看tomcat源代码eclipse源码查看tomcat中的类，出现Source not found。解决办法：1、下载相应版本tomcat源码，类似于apache-tomcat-8.0.44-src.zip。找不到相应版本的话，在页面上找到Quick Navigation，Archives，即可找到历史版本。2、单击Change Attached Source…，选中External location。3、Path选中apache-tomcat-8.0.44-src.zip，OK。
带源文件的jar包下载http://www.java2s.com/Code/Jar/CatalogJar.htm
反编译class文件1、下载相应版本的jadClipse，这里下载net.sf.jadclipse_3.3.0.jar。2、下载相应版本的jad，这里下载Jad 1.5.8g for Windows 9x/NT/2000 on Intel platform。3、将net.sf.jadclipse_3.3.0.jar移动到eclipse的plugins目录下。4、将jad.exe移动到JDK安装目录下的bin目录下（方便使用）。5、移动eclipse的configuration目录下的org.eclipse.update文件夹到其他位置（或者直接删除）。6、重启eclipse，Window-&gt;Preferences-&gt;Java，此时发现多了一个JadClipse。7、Path to decompiler填入jad.exe的路径。8、Window-&gt;Preferences-&gt;General-&gt;Editors-&gt;File Associations，查看.class文件的默认打开方式，已经变成了JadClipse。查看.class without sources文件的默认打开方式，修改为JadClipse。9、选择需要查看的类，点击F3查看源码。如果不能查看，请关闭tab然后重新查看（反编译可能需要一点时间）。
代码提示上屏设置例如：要新建一个String类型的变量value，则当输入到value的时候，eclipse会在候选列表中列出valueString，如果此时再输入空格的话，就会选中候选列表中的valueString，则新建的变量将会变成valueString。
解决办法：打开eclipse，Window，Show View，Plug-ins，找到org.eclipse.jface.text右击，import as，Source Project，导入完成后，在你的workspace就可以看到这个project了。
PS：修改插件，需要下载相同Version的Eclipse RCP（该版本修改源代码比较方便，能自动导入源代码），因为开发版、企业版等导出Plug-ins项目后无法编辑。
然后，在导入工程下的src文件夹下，找到包org.eclipse.jface.text.contentassist，类CompletionProposalPopup，函数verifyKey()。
if (contains(triggers, key)) &#123;	e.doit= false;	hide();	insertProposal(p, key, e.stateMask, fContentAssistSubjectControlAdapter.getSelectedRange().x);&#125;
修改为
if (key != '=' &amp;&amp; key != 0x20 &amp;&amp; key != ';' &amp;&amp; contains(triggers, key)) &#123;	e.doit= false;	hide();	insertProposal(p, key, e.stateMask, fContentAssistSubjectControlAdapter.getSelectedRange().x);&#125;
实现效果：等号键、空格键、分号键不上屏。
case '\t':	e.doit= false;	fProposalShell.setFocus();	return false;
修改为
case '\t':	e.doit= false;	insertSelectedProposalWithMask(e.stateMask);	return false;
实现效果：Tab键上屏。
修改完成后，项目右击，Export，Deployable plug-ins and fragments，勾选Available Plug-ins and Fragments，指定Destination的Directory，Finish。
使用导出的jar包，替换原eclipse/plugins下的jar包，即可实现插件的修改。
注意：最新版的eclipse，Neon.1a Release (4.6.1)，插件的所在目录变更如下：C:\Users\Administrator\.p2\pool\plugins\，使用导出的jar包，替换该目录下的jar包，即可实现插件的修改。
如果再次变更插件所在目录，请依次点击Window，Show View，Plug-ins。然后单击任意插件，在eclipse底部即可看到插件路径。
配置本地dtd文件我们以配置xwork-validator-1.0.dtd文件为例：
1、解压xwork-core-*.jar包，找到xwork-validator-1.0.dtd。
2、eclipse，Window，Preferences，XML，XML Catelog，Add，File System…，选中刚才解压的xwork-validator-1.0.dtd，打开，
3、Location已经选好D:\jar\struts2\xwork-validator-1.0.dtd，Key type选择Public ID，Key填-//OpenSymphony Group//XWork Validator Config 1.0//EN，Alternative web address填http://struts.apache.org/dtds/xwork-validator-1.0.dtd。（本地dtd不存在时回去web上去找dtd）
4、StrutsAction-validation.xml需要修改如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE validators PUBLIC        "-//OpenSymphony Group//XWork Validator Config 1.0//EN"        "D:\jar\struts2\xwork-validator-1.0.dtd"&gt;&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="name"&gt;		&lt;field-validator type="requiredstring"&gt;			&lt;!--去空格--&gt;			&lt;param name="trim"&gt;true&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;姓名是必须的&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

参考文档修改空格键”=”键不上屏比较全面的Eclipse配置详解
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK配置FileBeat</title>
    <url>/dev-elk-with-filebeat/</url>
    <content><![CDATA[前言《CentOS7安装部署ELK》一文中，已经安装部署了ELK的基本架构，实现了Logstash收集客户节点数据，传递给Elasticsearch，然后显示在Kibana中。本文中，配置使用FileBeat来收集客户节点数据，然后分别传递给Logstash、Elasticsearch，最后配置使用Kibana仪表盘来显示FileBeat的数据。


Beats简介Beats 平台集合了多种单一用途数据采集器。它们从成百上千或成千上万台机器和系统向 Logstash 或 Elasticsearch 发送数据。Packetbeat是最先出现的，用来收集网络数据。逐步衍生出了其他5个 Beats，分别是日志文件、系统信息、审计数据、Windows 系统日志和可用性监控，并且另外还有40多个社区维护的 Beats 来记录各种运营数据。
常见的Beats采集器包括：

Filebeat：日志文件。
Metricbeat：指标。
Packetbeat：网络数据。
Winlogbeat：Windows事件日志。
Auditbeat：审计数据。
Heartbeat：运行时间监控。
Functionbeat：无需服务器的采集器。

更多内容参考Beats: Elasticsearch的数据采集器。
配置Logstash首先配置Logstash，使之能够接收Beats发送的数据。
1、拷贝模板到配置目录cp /etc/logstash/logstash-sample.conf /etc/logstash/conf.d/filebeat.conf
2、编辑filebeat.confvim /etc/logstash/conf.d/filebeat.conf，修改为（实际上并不需要修改）：
input &#123;  beats &#123;    port =&gt; 5044  &#125;&#125;output &#123;  elasticsearch &#123;    hosts =&gt; ["http://localhost:9200"]    index =&gt; "%&#123;[@metadata][beat]&#125;-%&#123;[@metadata][version]&#125;-%&#123;+YYYY.MM.dd&#125;"    #user =&gt; "elastic"    #password =&gt; "changeme"  &#125;&#125;

3、检查配置
/usr/share/logstash/bin/logstash --path.settings /etc/logstash -t# or/usr/share/logstash/bin/logstash --path.settings /etc/logstash --config.test_and_exit

4、启动logstash并设置开机自启动
systemctl start logstashsystemctl enable logstash

5、查看5044端口服务情况netstat -nlpt | grep 5044找不到服务，哪里出了问题？没出啥问题，请等待3分钟以上，然后重新执行命令。
安装FileBeat参考Install Filebeat，安装FileBeat。
1、下载rpm安装包curl -L -O https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.2.0-x86_64.rpm
2、使用安装包安装FileBeatrpm -vi filebeat-7.2.0-x86_64.rpm
3、查看FileBeat安装信息rpm -qi filebeat
配置FileBeat到Logstash参考Configure Filebeat，配置FileBeat。
1、编辑filebeat.ymlvim /etc/filebeat/filebeat.yml，如下修改：
# line 24, change filebeat.inputfilebeat.inputs:- type: log  enabled: true  paths:    - /var/log/*.log# line 148 and 150, comment output.elasticsearch# line 158 and 160, uncomment output.logstashoutput.logstash:  # The Logstash hosts  hosts: ["localhost:5044"]

2、测试启动filebeatfilebeat -e -c /etc/filebeat/filebeat.yml -d &quot;publish&quot;与logstash建立了连接，启动成功。
3、此时可以在ES中查看到索引浏览器访问 http://192.168.56.101:9200/_cat/indices?v
4、查看filebeat收集的数据浏览器访问 http://192.168.56.101:9200/filebeat-7.2.0-2019.07.30/_search?pretty
5、在kibana中查看日志数据日志数据是/var/log/*.log，实际包括boot.log、yum.log和test.log。
6、查看并且启用filebeat modules
filebeat modules listfilebeat modules enable systemfilebeat modules list

7、启动filebeat并设置开机启动
systemctl start filebeatsystemctl enable filebeat
启用system module后，Kibana的event.dataset会多出system.syslog、system.auth。
PS：重建索引的方法（1）删除索引curl -XDELETE -u elastic:changeme http://localhost:9200/filebeat-7.2.0-2019.07.30（2）重建索引删除registry/filebeat，然后重新启动filebeat。
8、更新test.log在test.log中添加一行，FileBeat默认10秒reload一次文件，但是在ES中查询不到更新。神奇的是，在Kibana中可以查询到更新，不知道怎么肥四。留个坑，有缘再填。
配置FileBeat到ES1、编辑filebeat.ymlvim /etc/filebeat/filebeat.yml，如下修改：
# line 148 and 150, uncomment output.elasticsearchoutput.elasticsearch:  # Array of hosts to connect to.  hosts: ["localhost:9200"# line 158 and 160, comment output.logstash

2、测试启动filebeat
systemctl stop filebeatfilebeat -e -c /etc/filebeat/filebeat.yml -d "publish"`
与ES建立了连接，启动成功。
3、此时可以在ES中查看到索引浏览器访问 http://192.168.56.101:9200/_cat/indices?v
之后在ES和Kibana中查看数据的方法和上面相同。更新test.log，同样在ES中看不到，在Kibana中可以看到。
配置FileBeat仪表盘如果想要使用Filebeat提供的示例Kibana仪表盘，那么需要配置Kibana端点。如果Kibana与ES在同一主机上运行，​​则可以跳过此步骤。
1、编辑filebeat.ymlvim /etc/filebeat/filebeat.yml，如下修改：
# line 117 and 123, uncomment setup.kibanasetup.kibana:  # Kibana Host  host: "localhost:5601"

2、创建仪表盘filebeat setup --dashboards
3、测试启动filebeat（不启动也可以）filebeat -e -c /etc/filebeat/filebeat.yml -d &quot;publish&quot;
4、查看Kibana仪表盘打开dashboard仪表盘，可以选择filebeat相关的仪表盘。
后记至此，安装配置完成了FileBeat，其收集的数据可以传递给Logstash，也可以直接传递给ES。创建了FileBeat的仪表盘，成功显示数据。
书签How To Install ELK on CentOS 7
Load the index template in Elasticsearch
Filebeat命令参考
filebeat收集日志常见问题
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>英中机器文本翻译-第0章</title>
    <url>/dev-en-to-zh-translation-0/</url>
    <content><![CDATA[机器翻译机器翻译，即跨语言间的自动翻译，是机器学习社区最活跃的研究领域。在机器翻译的众多方法中，序列到序列（sequence-to-sequence，seq2seq）模型近期获得巨大成功。由于其可以使用深度神经网络获取句义，该模型成为谷歌翻译等多数商业翻译系统事实上的标准模型。
小生以参加《全球AI挑战赛-英中机器文本翻译》为导向，学习各种相关知识。


赛题简介英中文本机器翻译竞赛的目标是评测英中文本机器翻译的能力。本次文本机器翻译语言方向为英文到中文。参赛队伍需要根据评测方提供的数据，训练机器翻译系统，并且自由地选择机器翻译技术。例如，基于规则的翻译技术、基于实例的翻译技术、统计机器翻译及神经网络机器翻译技术等。
本次竞赛将利用机器翻译的客观考核指标（BLEU、NIST score、TER）进行评分，BLEU得分会作为主要的机器评价指标。组委会将通过客观指标，并结合答辩表现，综合评估参赛者的算法模型。
环境准备软件安装
win10
python3.6
tensorflow1.3.0

源码安装配置git clone https://github.com/tensorflow/nmt/
因为tensorflow的更新很快，nmt项目的更新也很快，所以，我们必须使用和tensorflow版本对应的nmt版本。git reset --hard 77e6c55
入门demo让我们开始训练第一个 NMT 模型，将越南语翻译为英语。代码的入口是nmt.py。
数据集我们将使用小规模的 Ted 演讲并行语料库（133k 的训练样本）进行训练。所有的数据都可从以下链接找到：https://nlp.stanford.edu/projects/nmt/ 。
我们将使用tst2012作为开发数据集，tst2013作为测试数据集。在linux下运行以下命令行下载数据：mkdir -p /tmp/nmt_data
nmt/scripts/download_iwslt15.sh /tmp/nmt_data
linux下载好数据集后，把数据集下载到win10中nmt目录中，路径为nmt/tmp/nmt_data。
训练model在根目录（nmt目录）下运行：
python -m nmt.nmt --src=vi --tgt=en --vocab_prefix=./tmp/nmt_data/vocab  --train_prefix=./tmp/nmt_data/train --dev_prefix=./tmp/nmt_data/tst2012  --test_prefix=./tmp/nmt_data/tst2013 --out_dir=./tmp/nmt_model --num_train_steps=12000 --steps_per_stats=100 --num_layers=2 --num_units=128 --dropout=0.2 --metrics=bleu

郝同学i5-3337U CPU@1.80GHz，8G内存，训练了将近两个小时才训练完成。下文我们要学习使用一下UCloud提供的免费GPU。
我们可以使用 Tensorboard 在训练过程中查看模型的总结：
tensorboard --port 22222 --logdir ./tmp/nmt_model/
通过以下简单的变化，就能逆向完成英语到越南语的翻译。
--src=en --tgt=vi
使用model1、从mnt/tmp/nmt_data/tst2013.vi中复制几句话，新建nmt/tmp/my_infer_file.vi，粘贴到里面。
2、运行model
python -m nmt.nmt --model_dir=./tmp/nmt_model --inference_input_file=./tmp/my_infer_file.vi --inference_output_file=./tmp/nmt_model/output_infer

3、查看结果打开nmt/tmp/nmt_model/output_infer文件，即可看到翻译结果。
书签全球AI挑战赛-英中机器文本翻译
谷歌开放GNMT教程：如何使用TensorFlow构建自己的神经机器翻译系统
Neural Machine Translation (seq2seq) Tutorial
用CNN做机器翻译？Facebook相关论文的PyTorch代码发布
从零开始：深度学习软件环境安装指南
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>英中机器文本翻译-第2章</title>
    <url>/dev-en-to-zh-translation-2/</url>
    <content><![CDATA[前言tensorflow/nmt项目，并不能直接在ucloud的AI训练服务上进行训练，我们需要对代码进行一些修改。


差异分析路径上文中，在AI训练服务上运行的mnist，它的输入输入都是到UFile上。而nmt项目，在运行时指定了训练文件的路径。
tensorflowmnist项目，使用的是tensorflow1.1.0。nmt项目，使用的是tensorflow1.3.0。
路径对于路径差异，需要修改nmt的运行命令和代码。
运行命令nmt项目的运行时的命令为：
python -m nmt.nmt --src=vi --tgt=en --vocab_prefix=./tmp/nmt_data/vocab  --train_prefix=./tmp/nmt_data/train --dev_prefix=./tmp/nmt_data/tst2012  --test_prefix=./tmp/nmt_data/tst2013 --out_dir=./tmp/nmt_model --num_train_steps=12000 --steps_per_stats=100 --num_layers=2 --num_units=128 --dropout=0.2 --metrics=bleu

其中，关于路径的参数有：–vocab_prefix–train_prefix–dev_prefix–test_prefix–out_dir
前四个路径是输入；最后一个路径是输出。
最后的命令要改成：
python -m nmt.nmt --src=vi --tgt=en --vocab_prefix=vocab  --train_prefix=train --dev_prefix=tst2012  --test_prefix=tst2013 --num_train_steps=12000 --steps_per_stats=100 --num_layers=2 --num_units=128 --dropout=0.2 --metrics=bleu

对于输入路径来说，去掉了./tmp/nmt_data/，默认为FLAGS.data_dir，也就是创建AI训练服务时输入的数据输入路径。
对于输出路径来说，去掉了./tmp/mnt_model，默认为FLAGS.output_dir，也就是创建AI训练服务时输入的数据输出路径。
UFile1、移动nmt_data目录到/data/nmt。
mkdir -p /data/nmtmv ~/tmp/nmt_data /data/nmt

2、上传/data/nmt到UFile。./filemgr --action mput --dir /data/nmt --bucket vk-ucloud --prefix nmt --trimpath /data/nmt
train.en文件地址如下，其他文件类似：CDN加速地址：http://vk-ucloud.ufile.ucloud.com.cn/nmt/nmt_data/train.en源站地址：http://vk-ucloud.cn-bj.ufileos.com/nmt/nmt_data/train.en
3、python tf_tool.py pack时，指定本地测试数据地址如下。
--test_data_path=/data/nmt/nmt_data --test_output_path=/data/nmt/nmt_model

代码tensorflow后记未完。。。不再续。。。
书签全球AI挑战赛-英中机器文本翻译
谷歌开放GNMT教程：如何使用TensorFlow构建自己的神经机器翻译系统
TensorFlow 训练镜像自定义包安装
MNIST开发案例
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>input绑定回车事件</title>
    <url>/dev-enter-event/</url>
    <content><![CDATA[html部分：
&lt;input id="search-key" type="text" placeholder="请输入关键字"&gt;



JavaScript部分：
$('#search-key').keypress(function(event) &#123;    var key = event.which;    console.log(key);    if(key == 13)&#123;        //do something    &#125;&#125;);
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>信息量&amp;信息熵&amp;信息增益</title>
    <url>/dev-entropy/</url>
    <content><![CDATA[信息量确定性是指事先可以准确知道某个事件或某种决策的结果。或者说，如果事件或决策的可能结果只有一种，就会产生确定性。
信息论创始人香农对信息的定义：信息是确定性的增加。

信息量是信息多少的度量，也就是确定性增加的多少的度量，单位是比特。

如何计算信息量的多少？在日常生活中，极少发生的事件一旦发生是容易引起人们关注的，而司空见惯的事不会引起注意，也就是说，极少见的事件所带来的信息量多。如果用统计学的术语来描述，就是出现概率小的事件信息量多。因此，事件出现得概率越小，信息量愈大。即信息量的多少是与事件发生频繁（即概率大小）成反比。


如已知事件$x_i$已发生，则表示$x_i$所含有或所提供的信息量$$I(x_i) = -\log 2^{p(x_i)}$$
例题：若估计在一次国际象棋比赛中谢军获得冠军的可能性为0.1（记为事件A），而在另一次国际象棋比赛中她得到冠军的可能性为0.9（记为事件B）。试分别计算当你得知她获得冠军时，从这两个事件中获得的信息量各为多少？$$I(A) = -\log 2^{p(0.1)} ≈ 3.32（比特）$$
$$I(B) = -\log 2^{p(0.9)} ≈ 0.152（比特）$$
信息熵不确定性是指事先不能准确知道某个事件或某种决策的结果。或者说，只要事件或决策的可能结果不止一种，就会产生不确定性。

信息熵就是用以消除事件的不确定性所需要的信息量，单位是比特。

根据郝同学的理解，给出两个对比描述：1、这个杯子的容量是2L，容量是指物体或者空间所能够容纳的单位物体的数量。2、这个事件的信息熵是3bit，信息熵是指消除事件的不确定性所需要的单位信息的数量。也就是说，就像容量是用来描述空间大小的度量一样，信息熵就是用来描述不确定性大小的度量。
通常我们使用H(X)表示随机变量（事件）的熵：$$H(X) = E(I(X))$$其中的 E 代表期望值函數， I(X) 代表信息量所形成的随机变量（变量X的函数结果表示I(X)也是变量）。
$$H(X) = E(I(X)) = \sum_{i=1}^n {p(x_i),I(x_i)} = -\sum_{i=1}^n {p(x_i) \log 2^{p(x_i)}}$$
其中$x_i$表示第i个状态（总共有n种状态），$p(x_i)$表示第i个状态出现的概率。

条件熵就是在事件X确定的条件下，用以消除事件Y的不确定性所需要的信息量。

以下推导，log函数默认以2为底数。
\begin{eqnarray}H(Y|X) &amp;=&amp; \sum_{x\in\mathcal X},p(x),H(Y|X=x)\&amp;=&amp; -\sum_{x\in\mathcal X}p(x)\sum_{y\in\mathcal Y},p(y|x),\log,p(y|x)\&amp;=&amp; -\sum_{x\in\mathcal X}\sum_{y\in\mathcal Y},p(y,x),\log,p(y|x)\&amp;=&amp; -\sum_{x\in\mathcal X, y\in\mathcal Y}p(x,y)\log,p(y|x).\end{eqnarray}
条件熵 H(Y|X) 相当于联合熵 H(Y,X) 减去单独的熵 H(X)，其数学式如下。
\begin{align}H(Y|X) = H(Y,X)-H(X)\end{align}

联合熵就是用以消除多个同时发生的事件的不确定性所需要的信息量。

以下证明联合熵和条件熵的关系。\begin{eqnarray}H(X,Y)&amp;=&amp; -\sum_{x\in\mathcal X, y\in\mathcal Y}p(x,y)log,p(x,y)\&amp;=&amp; -\sum_{x\in\mathcal X, y\in\mathcal Y}p(x,y)log\left(p(y|x)p(x)\right)\&amp;=&amp; -\sum_{x\in\mathcal X, y\in\mathcal Y}p(x,y)log,p(y|x) - \sum_{x\in\mathcal X, y\in\mathcal Y} p(x,y) log,p(x)\&amp;=&amp; H(Y|X)-\sum_{x\in\mathcal X, y\in\mathcal Y}p(x,y)log,p(x)\&amp;=&amp; H(Y|X)-\sum_{x\in\mathcal X}\sum_{y\in\mathcal Y}p(x,y)log,p(x)\ &amp;=&amp; H(Y|X)-\sum_{x\in\mathcal X}log,p(x)\sum_{y\in\mathcal Y}p(x,y)\ &amp;=&amp; H(Y|X)-\sum_{x\in\mathcal X}(log,p(x))p(x)\&amp;=&amp; H(Y|X)-\sum_{x\in\mathcal X}p(x)log,p(x)\&amp;=&amp; H(Y|X)+H(X)\ &amp;=&amp; H(X)+H(Y|X)\\end{eqnarray}
信息增益特征选择是指从全部特征中选择一个特征子集，使构造出来的模型更好。
在机器学习的实际应用中，特征数量往往较多，其中可能存在不相关的特征，特征之间也可能存在相互依赖，容易导致训练时间过长、维度灾难等。特征选择能剔除不相关或冗余的特征，从而达到减少特征个数，提高模型精确度，减少运行时间的目的。另一方面，选取出真正相关的特征，简化了模型。
在训练样本集上，运行C4.5或其他决策树生成算法，待决策树充分生长后，再在树上运行剪枝算法，则最终决策树各分支处的特征就是选出来的特征子集。决策树方法一般使用信息增益作为评价函数。
在信息增益中，衡量标准是看特征能够为分类系统带来多少信息，带来的信息越多，该特征就越重要。对一个特征而言，系统有它和没它时信息量将发生变化，而前后信息量的差值就是这个特征给系统带来的信息量。

信息增益定义为父项熵减去分割父项后生成的子项的熵的加权平均。

特征T给聚类C或分类C带来的信息增益为：$$IG(T) = H(C) - H(C|T)$$
书签信息量http://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E9%87%8F
信息熵http://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E7%86%B5
信息增益http://baike.baidu.com/item/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A
互資訊與條件熵http://ccckmit.wikidot.com/st:mutualinformation
c4.5为什么使用信息增益比来选择特征？https://www.zhihu.com/question/22928442/answer/117189907
信息增益到底怎么理解呢？https://www.zhihu.com/question/22104055/answer/67014456
优达学城-机器学习入门-熵和信息增益
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>JS转换HTML转义符</title>
    <url>/dev-escape-to-html/</url>
    <content><![CDATA[去掉html标签function removeHtmlTab(tab) &#123;    return tab.replace(/&lt;[^&lt;&gt;]+?&gt;/g,'');//删除所有HTML标签&#125;



普通字符转换成转意符function html2Escape(sHtml) &#123;    return sHtml.replace(/[&lt;&gt;&amp;"]/g,function(c)&#123;return &#123;'&lt;':'&amp;lt;','&gt;':'&amp;gt;','&amp;':'&amp;amp;','"':'&amp;quot;'&#125;[c];&#125;);&#125;

转意符换成普通字符function escape2Html(str) &#123;    var arrEntities=&#123;'lt':'&lt;','gt':'&gt;','nbsp':' ','amp':'&amp;','quot':'"'&#125;;    return str.replace(/&amp;(lt|gt|nbsp|amp|quot);/ig,function(all,t)&#123;return arrEntities[t];&#125;);&#125;

&nbsp;转成空格function nbsp2Space(str) &#123;    var arrEntities = &#123;'nbsp' : ' '&#125;;    return str.replace(/&amp;(nbsp);/ig, function(all, t)&#123;return arrEntities[t]&#125;)&#125;

回车转为br标签function return2Br(str) &#123;    return str.replace(/\r?\n/g,"&lt;br /&gt;");&#125;

去除开头结尾换行function trimBr(str) &#123;    str=str.replace(/((\s|&amp;nbsp;)*\r?\n)&#123;3,&#125;/g,"\r\n\r\n");//限制最多2次换行    str=str.replace(/^((\s|&amp;nbsp;)*\r?\n)+/g,'');//清除开头换行    str=str.replace(/((\s|&amp;nbsp;)*\r?\n)+$/g,'');//清除结尾换行    return str;&#125;

将多个连续空格合并成一个空格function mergeSpace(str) &#123;    str=str.replace(/(\s|&amp;nbsp;)+/g,' ');    return str;&#125;

转载自 http://www.cnblogs.com/leejersey/p/4568092.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Fedora的一些技巧</title>
    <url>/dev-fedora-skill/</url>
    <content><![CDATA[播放音乐1、audacious:
yum install Audaciousyum install audacious-plugins-*



2、RPM Fusion
因为专利许可证的原因，Fedora软件仓库不包含MP3,DVD和视频播放及解码库。正因为如此，你必须从第三方的软件仓库安装那些软件，请不要担心，这是非常容易的 :)
现在我们开始安装 RPM Fusion 软件仓库，RPM Fusion 是 Fedora 和 Red Hat企业版的软件仓库，是由Dribble, Freshrpms 和 RPM Fusion合并而来的。各种各样的应用程序包含在这个软件仓库中，比如MP3、未加密的 DVD 、Mplayer, VLX, Xine 等多媒体应用程序使用的解码库，以及闭源的 Nvidia 和 ATI 显卡驱动，RPM Fusion包含以下两个主要的软件仓库：一个被命名为“免费”，为开源软件提供（开源软件的含义通过Fedora授权指引定义），但因为美国专利保护法案又不能包含在 Fedora 中。另一个被命名为“非免费”，为非自由软件提供，就是其它所有那些不能被免费提供的，包括公开源代码的软件，但是有“非商业使用”之类的限制。
在这部分指南的最后，我保证你安装并启用了 RPM Fusion 软件仓库，所以，打开一个终端吧，输入：
rpm -ivh http://download1.rpmfusion.org/free/fedora/rpmfusion-free-release-stable.noarch.rpmrpm -ivh http://download1.rpmfusion.org/nonfree/fedora/rpmfusion-nonfree-release-stable.noarch.rpmyum update

输入上面的指令之后，只要选择一个mp3格式文件的双击播放，就能成功的找到mp3插件，选择安装，就好了，然后选择一个wma格式的文件双击 ，就会自动的去下载wma的插件。
删除图标以前在Fedora15中用wine安装了一个CS和迅雷7，但运行不太流畅，所以想要删掉面板上相关的图标。具体命令如下。
1、cd   ~/.local/share/applications/wine/Programs/2、ls 查看目录3、rm -r *递归删除所有的项目。
常用命令yum install gccyum install gcc-c++yum install vimrpm -ivh adobe-release-i386-1.0-1.noarch.rpm yum install flash-pluginyum install lib* --setopt=protect_multilib=false --skip broken
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7中firewall的使用</title>
    <url>/dev-firewall/</url>
    <content><![CDATA[firewall简介根据官方文档，firewall简介如下：

firewalld daemon provides a dynamically managed firewall with support for network “zones” to assign a level of trust to a network and its associated connections and interfaces. It has support for IPv4 and IPv6 firewall settings. It supports Ethernet bridges and IP set and has a separation of runtime and permanent configuration options. It also has an interface for services or applications to add firewall rules directly. The complete communication with firewalld is done using D-Bus.

firewalld守护进程提供了一个动态管理的防火墙，支持网络“区域”为网络及其关联的连接和接口分配信任级别。它支持ipv4和ipv6防火墙设置。它支持以太网桥和ip集，并且有运行时和永久配置选项的分离。它还具有用于直接添加防火墙规则的服务或应用程序的界面。与firewalld的完整通信是使用d-bus完成的。
简单来说，CentOS6中使用iptables作为防火墙；而在CentOS7中，firewall作为防火墙，是iptables的升级。本文只讨论自己常用的firewall命令和配置，不涉及高级用法。


firewall常用命令
systemctl start firewalld，启动。
systemctl stop firewalld，关闭。
systemctl status firewalld，查看状态。
systemctl enable firewalld，设置开机启动。
systemctl disable firewalld，关闭开机启动。


firewall-cmd --version，查看版本。 
firewall-cmd --help，查看帮助。
firewall-cmd --state，显示状态。
firewall-cmd --list-all，查看所有规则。
firewall-cmd --zone=public --list-ports，查看所有打开的端口。 
firewall-cmd --zone=public --add-port=8080/tcp --permanent，打开端口。
firewall-cmd --zone=public --remove-port=8080/tcp --permanent，关闭端口。
firewall-cmd --reload，更新防火墙规则。

firewall配置文件firewall的配置文件是xml格式的，存储在/usr/lib/firewalld/ 和 /etc/firewalld/ 两个目录下。
这样就有很大的灵活性，因为文件可以被编辑，写入，备份，用作其他安装的模板等等。
1、系统配置目录ll /usr/lib/firewalld/services
目录中存放定义好的网络服务和端口参数，系统参数，不能修改。
2、用户配置目录ll /etc/firewalld/
3、自定义添加端口常用命令中，我们知道用户可以通过命令的方式添加端口，添加的端口会写入/etc/firewalld 目录下的相应配置文件中。用户也可以通过直接修改配置文件的方式添加端口，比如添加8080端口。
vim /etc/firewalld/zones/public.xml，添加内容：
&lt;port protocol="tcp" port="8080"/&gt;
重启firewalld，即可生效。
4、public.xml文件中还可以配置放行的ip范围、端口范围等等，在此不作记录，需要的时候再说。
使用iptables很多同学在使用时，喜欢使用iptables代替firewall，毕竟iptables用习惯了。1、关闭firewall，禁止开机启动systemctl stop firewalldsystemctl disable firewalld
2、安装iptables防火墙yum install iptables-services
3、编辑iptables防火墙配置文件vi /etc/sysconfig/iptables添加开放22、80、3306端口：
iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPTiptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPTiptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT

4、启动iptables，设置开机启动systemctl start iptablessystemctl enable iptables
5、iptables常用命令

iptables --list，查看防火墙详情。
iptables-save，查看防火墙详情。
iptables -A INPUT -p tcp --dport 8080 -j ACCEPT，开放端口。
iptables -L -n --line-numbers，将所有规则以序号标记显示。
iptables -D INPUT 1，删除INPUT里序号为1的规则。
service iptables save，保存iptables设置（仅限RedHat系列）。

书签CentOS 7中firewall防火墙详解和配置以及切换为iptables防火墙
CentOS7使用firewalld打开关闭防火墙与端口
CentOS 7 开放3306端口访问
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>firewall</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>freemarker入门</title>
    <url>/dev-freemarker/</url>
    <content><![CDATA[前言昨天，郝同学介绍了一款前端模板引擎artTemplate。今天，介绍一款后端模板引擎freemarker。

Apache FreeMarker is a template engine: a Java library to generate text output (HTML web pages, e-mails, configuration files, source code, etc.) based on templates and changing data. 



基本语法定义和输出&lt;#assign answer=42/&gt;$&#123;answer&#125;
结果为：42
分支语句&lt;#assign age=23&gt;&lt;#if (age&gt;60)&gt;老年人&lt;#elseif (age&gt;40)&gt;中年人&lt;#elseif (age&gt;20)&gt;青年人&lt;#else&gt; 少年人&lt;/#if&gt;

循环语句&lt;#list books as book&gt;    &lt;tr&gt;        &lt;td&gt;$&#123;book.name&#125;&lt;/td&gt;        &lt;td&gt;作者:$&#123;book.author&#125;&lt;/td&gt;    &lt;/tr&gt;&lt;/#list&gt;

运算和函数&lt;#assign x=5&gt;$&#123; (x/2)?int &#125;$&#123; 1.1?int &#125;$&#123; 1.999?int &#125;$&#123; -1.1?int &#125;$&#123; -1.999?int &#125;
结果为:2 1 1 -1 -1
源码分享https://github.com/voidking/freemarker.git
参考文档FreeMarker Java Template Enginehttp://freemarker.org/
Download / Maven - Apache FreeMarkerhttp://freemarker.org/freemarkerdownload.html
Index (FreeMarker 2.3.24-incubating API)http://freemarker.org/docs/api/index-all.html
模板引擎freemarker的简单使用教程http://blog.csdn.net/stormwy/article/details/26172353
FreeMarker使用详解http://www.open-open.com/lib/view/open1394860597743.html
Freemarker由浅入深01-环境搭建、测试http://blog.csdn.net/it_wangxiangpan/article/details/17526869
ftl的使用http://blog.163.com/liuweiyoung@126/blog/static/1731310452012112755018198/
【FreeMarker】【模板文件FTL】模板自定义指令 macrohttp://blog.csdn.net/robinjwong/article/details/40427977
freemarker的使用心得http://blog.csdn.net/walkcode/article/details/40707997
Freemarker中Configuration的setClassForTemplateLoading方法参数问题http://www.cnblogs.com/fangjian0423/p/freemarker-templateloading-question.html
Servlet 3.0笔记之使用Freemarker替代JSP，更快更轻更高效http://www.blogjava.net/yongboy/archive/346224.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发常用插件</title>
    <url>/dev-front-end-plugin/</url>
    <content><![CDATA[前言最近在阅读公司官网的前端代码，使用了很多插件。挨个百度，简单记录下，看看他们都是干什么的。
jQuery UIjQuery UI API中文文档http://www.css88.com/jquery-ui-api/


SwiperSwiper是纯javascript打造的滑动特效插件，面向手机、平板电脑等移动终端。
Swiper能实现触屏焦点图、触屏Tab切换、触屏多图切换等常用效果。Swiper开源、免费、稳定、使用简单、功能强大，是架构移动终端网站的重要选择！
Swiper中文网http://www.swiper.com.cn/
官网http://www.idangero.us/swiper/
BlockUIjQuery BlockUI Pluginhttp://malsup.com/jquery/block/
blockui githubhttps://github.com/malsup/blockui/
jQuery遮罩插件jQuery.blockUI.js简介http://bookshadow.com/weblog/jquery-blockui-js-introduction/
email-autocompleteemail-autocompletehttps://github.com/10w042/email-autocomplete
jQuery-AutocompletejQuery-Autocompletehttps://github.com/devbridge/jQuery-Autocomplete
chosenchosenhttps://github.com/harvesthq/chosen
Chosen (v1.4.2)http://harvesthq.github.io/chosen/
ajaxfileuploadjQuery插件之ajaxFileUploadhttp://www.cnblogs.com/kissdodog/archive/2819025.html
html2canvashtml2canvashttp://www.bootcdn.cn/html2canvas/
百度地图百度地图APIhttp://lbsyun.baidu.com/
momentJavaScript 日期处理类库
Moment.js中文网http://momentjs.cn/
paginationjQuery Pagination pluginhttp://esimakin.github.io/twbs-pagination/
placeholderjquery-placeholderhttps://github.com/mathiasbynens/jquery-placeholder
romeromehttp://spmjs.io/package/rome
validationvalidation官方文档http://jqueryvalidation.org/documentation
zeptoZepto is a minimalist JavaScript library for modern browsers with a largely jQuery-compatible API.
zepto中文网http://www.zeptojs.cn/
tooltipsterA powerful, flexible jQuery plugin enabling you to easily create semantic, modern tooltips enhanced with the power of CSS.
官网http://iamceege.github.io/tooltipster/
lazyloadLazy Load Plugin for jQueryhttp://www.appelsiini.net/projects/lazyload
lazyload项目地址：https://github.com/tuupola/jquery_lazyload
MasonryMasonry官网http://masonry.desandro.com/
mosonry项目地址：https://github.com/desandro/masonry
imageLoadedimagesLoaded官网http://imagesloaded.desandro.com/
imagesloaded项目地址：https://github.com/desandro/imagesloaded
touch.jsTouch.js官网http://touch.code.baidu.com/
iscrolliScroll官网http://cubiq.org/iscroll-5
iScroll文档http://iscrolljs.com/
iScroll项目地址https://github.com/cubiq/iscroll
【iScroll源码学习00】模拟iScrollhttp://www.cnblogs.com/yexiaochai/p/3489676.html
后记优点：开发成本低、时间短；稳定性、兼容性良好。缺点：不懂原理，遇到问题不好解决。
提供给开发者的 20 款最棒的 jQuery Bootstrap 插件http://www.oschina.net/translate/20-best-jquery-bootstrap-plugins-for-developers
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title>使用frp进行内网穿透</title>
    <url>/dev-frp/</url>
    <content><![CDATA[前言《使用lanproxy进行内网穿透》一文中，郝同学使用lanproxy搭建了一个内网穿透服务，并且介绍了使用方法。
但是，不知道最近出了什么幺蛾子，居然无法再提供内网穿透服务。本文，就研究一下另外一个内网穿透工具frp。主要参考frp内网穿透搭建，超级简单实用。


准备1、一台公网服务器（centos7，运行frp-server）。2、一台内网pc或服务器（运行frp-client）。
服务端配置安装frp1、进入/opt目录cd /opt
2、访问frp项目，下载最新版的frp，这里下载frp_0.21.0_linux_amd64.tar.gz（包含服务端和客户端）。
wget https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz# orcurl -C - -O -L https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz

3、解压并重命名tar -xzvf frp_0.21.0_linux_amd64.tar.gz
mv frp_0.21.0_linux_amd64 frp
4、编辑frps.inicd frp &amp;&amp; vim frps.ini，参考frps_full.ini，修改如下：
[common]bind_addr = 0.0.0.0bind_port = 7000dashboard_addr = 0.0.0.0dashboard_port = 7500dashboard_user = voidkingdashboard_pwd = voidkingtoken = 12345678

5、启动frps./frps -c ./frps.ini
后台启动：screen ./frps -c ./frps.ini，然后ctrl+A+D。
6、测试访问在浏览器访问 http://120.77.36.182:7500 ，输入用户名和密码，即可看到frp dashboard。
7、设置开机自启动vim /etc/rc.local，在exit 0之前添加：
nohup /opt/frp/frps -c /opt/frp/frps.ini &amp;
其中nohup可以省略。
nginx反向代理1、添加域名解析frp到公网ip。
2、在/etc/nginx/conf.d/目录中，添加frp.voidking.com.conf，内容如下：
server &#123;    listen 80;    server_name frp.voidking.com;    charset utf-8;    location /&#123;        proxy_set_header Host $host;        proxy_set_header X-Forward-For $remote_addr;        proxy_set_header X-Real-IP $remote_addr;        proxy_pass http://127.0.0.1:7500;    &#125;&#125;

3、重启nginx/usr/sbin/nginx -t，如果提示缺少目录，那么mkdir -p创建。
/usr/sbin/nginx -s reload
4、测试访问访问 http://frp.voidking.com/ ，同样可以看到dashboard界面。
至此，服务端配置完成。
客户端配置windows1、访问frp项目，下载最新版的frp，这里下载frp_0.21.0_windows_amd64.zip（包含服务端和客户端）。
2、解压frp_0.21.0_windows_amd64.zip，并重命名为frp。
3、编辑frp/frpc.ini文件，修改为：
[common]server_addr = 120.77.36.182server_port = 7000token = 12345678[web_3480]type = tcplocal_ip = 127.0.0.1local_port = 80remote_port = 3480

server_addr是服务器端的公网IP地址，server_port是frp服务端口号，auto_token是连接服务器的口令，必须和服务器保持一致。
web_3480是客户端和服务端之间的通道名，每个客户端必须不一样，remote_port是服务器端对外提供本机服务的端口号。
4、启动客户端shift+右键，在此处打开powershell窗口，然后执行：.\frpc.exe -c .\frpc.ini
5、本地启动web服务，在80端口提供服务。
6、测试访问在浏览器访问 http://120.77.36.182:3480 ，即可看到本地80服务。
linux1、进入/opt目录cd /opt
2、访问frp项目，下载最新版的frp，这里下载frp_0.21.0_linux_amd64.tar.gz（包含服务端和客户端）。
curl -C - -O -L https://github.com/fatedier/frp/releases/download/v0.21.0/frp_0.21.0_linux_amd64.tar.gz

3、解压并重命名tar -xzvf frp_0.21.0_linux_amd64.tar.gz
mv frp_0.21.0_linux_amd64 frp
4、编辑frps.inicd frp &amp;&amp; vim frpc.ini，修改如下：
[common]server_addr = 120.77.36.182server_port = 7000token = 12345678[ssh_3422]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 3422

5、启动客户端./frpc -c ./frpc.ini
6、测试登录使用xshell连接本地服务器，IP填入120.77.36.182，端口填入3422，顺利连接。
7、设置开机自启动vim /etc/rc.local，在exit 0之前添加：
nohup /opt/frp/frpc -c /opt/frp/frpc.ini &amp;
其中nohup可以省略。
结语至此，大功告成，nice。frp和lanproxy相比，安装更加简便（不需要java环境），配置更加方便（客户端自己控制外网端口）。最重要的是，在使用centos7作为frp外网服务器的时候，不会出现无法代理22的问题。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>nginx</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/dev-functional-programming/</url>
    <content><![CDATA[概念以下内容转载自用心阁的回答，详见知乎。
1、什么是函数式编程？函数式编程是一种编程范式，我们常见的编程范式有命令式编程（Imperative programming），函数式编程，逻辑式编程，常见的面向对象编程是也是一种命令式编程。
命令式编程是面向计算机硬件的抽象，有变量（对应着存储单元），赋值语句（获取，存储指令），表达式（内存引用和算术运算）和控制语句（跳转指令），一句话，命令式程序就是一个冯诺依曼机的指令序列。
而函数式编程是面向数学的抽象，将计算描述为一种表达式求值，一句话，函数式程序就是一个表达式。


函数式编程中的函数这个术语不是指计算机中的函数（实际上是Subroutine），而是指数学中的函数，即自变量的映射。也就是说一个函数的值仅决定于函数参数的值，不依赖其他状态。比如sqrt(x)函数计算x的平方根，只要x不变，不论什么时候调用，调用几次，值都是不变的。
在函数式语言中，函数作为一等公民，可以在任何地方定义，在函数内或函数外，可以作为函数的参数和返回值，可以对函数进行组合。
纯函数式编程语言中的变量也不是命令式编程语言中的变量，即存储状态的单元，而是代数中的变量，即一个值的名称。变量的值是不可变的（immutable），也就是说不允许像命令式编程语言中那样多次给一个变量赋值。比如说在命令式编程语言我们写“x = x + 1”，这依赖可变状态的事实，拿给程序员看说是对的，但拿给数学家看，却被认为这个等式为假。
函数式语言的如条件语句，循环语句也不是命令式编程语言中的控制语句，而是函数的语法糖，比如在Scala语言中，if else不是语句而是三元运算符，是有返回值的。
严格意义上的函数式编程意味着不使用可变的变量，赋值，循环和其他命令式控制结构进行编程。
从理论上说，函数式语言也不是通过冯诺伊曼体系结构的机器上运行的，而是通过λ演算来运行的，就是通过变量替换的方式进行，变量替换为其值或表达式，函数也替换为其表达式，并根据运算符进行计算。λ演算是图灵完全（Turing completeness）的，但是大多数情况，函数式程序还是被编译成（冯诺依曼机的）机器语言的指令执行的。
2、为什么需要函数式编程？由于命令式编程语言也可以通过类似函数指针的方式来实现高阶函数，函数式的最主要的好处主要是不可变性带来的。没有可变的状态，函数就是引用透明（Referential transparency）的和没有副作用（No Side Effect）。
一个好处是，函数即不依赖外部的状态也不修改外部的状态，函数调用的结果不依赖调用的时间和位置，这样写的代码容易进行推理，不容易出错。这使得单元测试和调试都更容易。
不变性带来的另一个好处是：由于（多个线程之间）不共享状态，不会造成资源争用(Race condition)，也就不需要用锁来保护可变状态，也就不会出现死锁，这样可以更好地并发起来，尤其是在对称多处理器（SMP）架构下能够更好地利用多个处理器（核）提供的并行处理能力。
由于函数是引用透明的，以及函数式编程不像命令式编程那样关注执行步骤，这个系统提供了优化函数式程序的空间，包括惰性求值和并性处理。
还有一个好处是，由于函数式语言是面向数学的抽象，更接近人的语言，而不是机器语言，代码会比较简洁，也更容易被理解。
书签什么是函数式编程思维？https://www.zhihu.com/question/28292740
有趣的 Scala 语言: 使用递归的方式去思考http://www.ibm.com/developerworks/cn/java/j-lo-funinscala1/
函数式编程初探http://www.ruanyifeng.com/blog/2012/04/functional_programming.html
对函数式语言的误解http://blog.163.com/bowen_tong/blog/static/20681717420133142740252/
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Ganglia认证授权</title>
    <url>/dev-ganglia-auth/</url>
    <content><![CDATA[前言《Ubuntu14.04安装配置Ganglia》一文中，我们已经完成了Ganglia的安装配置。但是，我们并不想允许所有人都看到集群的使用情况，所以，本文就研究一下怎样给ganglia添加认证授权（加密设置），主要参照《使用 Ganglia 对 Linux 网格和集群服务器进行实时监控》。


原理在ganglia的wiki中包含对Authorization System的描述：

Ganglia contains a simple authorization system to selectively allow or deny users access to certain parts of the gweb application. We rely on the web server to provide authentication, so any Apache authentication system (htpasswd, LDAP, etc) is supported.

由此，我们可以得知，直接利用apache的认证机制即可完成对ganglia的加密设置。
详细步骤1、安装apache工具sudo apt-get install apache2-utils
2、创建密码文件sudo touch /usr/share/ganglia-webfrontend/auth.basic
sudo chmod a+rw /usr/share/ganglia-webfrontend/auth.basic
3、为ganglia创建用户并设定密码htpasswd -c /usr/share/ganglia-webfrontend/auth.basic adminganglia
会提示两次输入密码，以上命令创建了一个adminganglia的用户，密码存放在/usr/share/ganglia-webfrontend/auth.basic（可以任意目录或文件名，只要 Apache 对此有读取权限就可以。） 
4、修改配置文件ganglia.confsudo vim /etc/apache2/sites-enabled/ganglia.conf原配置文件为：
Alias /ganglia /usr/share/ganglia-webfrontend&lt;Directory "/usr/share/ganglia-webfrontend"&gt;        AllowOverride All        Order allow,deny        Allow from all        Deny from none&lt;/Directory&gt;

修改为：
Alias /ganglia /usr/share/ganglia-webfrontend&lt;Directory "/usr/share/ganglia-webfrontend"&gt;    AuthType basic    AuthName "Ganglia web UI"    AuthBasicProvider file    AuthUserFile "/usr/share/ganglia-webfrontend/auth.basic"    Require user adminganglia&lt;/Directory&gt;

5、重启apachesudo /etc/init.d/apache2 restart
6、测试访问访问 http://192.168.56.103/ganglia/ ，这次需要密码才能访问。
至此，给ganglia添加认证授权完成。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>ubuntu</tag>
        <tag>监控</tag>
        <tag>ganglia</tag>
      </tags>
  </entry>
  <entry>
    <title>Ganglia配置Grid架构</title>
    <url>/dev-ganglia-grid/</url>
    <content><![CDATA[Ganglia简介《Ubuntu14.04安装配置Ganglia》一文中，我们已经学会了安装配置ganglia的方法。但是，我们的配置方法，只适用于一个集群，如果我们有多个集群怎么办？本文就来探讨一下。


Ganglia层级参考YOUYOU深入学习Ganglia之一（建立Grid），可以得到如下结论：
Ganglia从数据中心的结构上划分了三个层次：Node，Cluster，Grid。一句话概括：多个Node组成一个Cluster，多个Cluster组成一个Grid。
配置Grid如果只有一个Cluster，没有添加Grid配置，那么这个Cluster默认在名为“Grid”的Grid下。
如上图，假设我们有两个Cluster，名为Cloud Computing和k8s，它们的管理机分别是cluster1-master和cluster2-master。除此之外，还有一台Grid管理机为grid-master。
cluster1-master的IP为192.168.56.101，cluster2-master的IP为192.168.56.201，grid-master的IP为192.168.56.56。
现在，我们想要把Cloud Computing和k8s这两个Cluster合并成一个Grid。
1、cluster1-master和cluster2-master配置允许共享gmated的XML文件，同时把grid-master地址设置为信任的主机IP。sudo vi /etc/ganglia/gmetad.conf
找到：
# List of machines this gmetad will share XML with. Localhost# is always trusted. # default: There is no default value# trusted_hosts 127.0.0.1 169.229.50.165 my.gmetad.org# If you want any host which connects to the gmetad XML to receive# data, then set this value to "on"# default: off# all_trusted on
修改为：
# List of machines this gmetad will share XML with. Localhost# is always trusted. # default: There is no default valuetrusted_hosts 192.168.56.56# If you want any host which connects to the gmetad XML to receive# data, then set this value to "on"# default: offall_trusted on

2、cluster1-master和cluster2-master重启gmetadsudo /etc/init.d/gmetad restart
3、grid-master的gmetad，要添加数据源。sudo vi /etc/ganglia/gmetad.conf
找到data_source，添加：
data_source "Cloud Computing" 10 192.168.56.101:8649 192.168.56.102:8649data_source "k8s" 10 192.168.56.201:8649 192.168.56.202:8649

4、grid-master重启gmetadsudo /etc/init.d/gmetad restart
然后，就能在grid-master的gweb上看到一个Grid，包含两个Cluster。
对比最开始时的图可以发现，cluster1-master的gweb标题为“Cloud Computing Cluster Report at…”，而grid-master的gweb标题为“unspecified Grid Report at…”。之所以unspecified，是因为我们在cluster1-master和cluster2-master的gmetad中没有指定Grid的名字。
5、在cluster1-master和cluster2-master上修改gmetad，设置Grid名称为”Center of Cloud Computing”。sudo vi /etc/ganglia/gmetad.conf
找到gridname，打开注释，修改为：
gridname "Center of Cloud Computing"

6、cluster1-master、cluster2-master、grid-master重启gmetadsudo /etc/init.d/gmetad restart
然后，访问grid-master的gweb，看到Grid有了名字。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>监控</tag>
        <tag>ganglia</tag>
      </tags>
  </entry>
  <entry>
    <title>git branch</title>
    <url>/dev-git-branch/</url>
    <content><![CDATA[前言Branches in Git are incredibly lightweight as well. They are simply pointers to a specific commit – nothing more. This is why many Git enthusiasts chant the mantra:

branch early, and branch often.

Because there is no storage / memory overhead with making many branches, it’s easier to logically divide up your work than have big beefy branches.
When we start mixing branches and commits, we will see how these two features combine. For now though, just remember that a branch essentially says “I want to include the work of this commit and all parent commits.”


创建分支1、创建本地bugFix分支git branch bugFix
2、切换到bugFix分支
git branch -agit checkout bugFix

3、创建远程bugFix分支git push origin HEAD:bugFix创建远程bugFix2分支git push origin HEAD:bugFix2
4、下载后切换到bugFix分支git checkout origin/bugFix
上传分支在bugFix分支下进行了修改，然后提交修改，命令如下：
git add .git commit -m "something"git push origin HEAD:bugFix

删除分支1、删除本地分支git branch -D bugFix
2、删除线上分支git push --delete origin bugFix
恢复已删除分支1、查看全局日志git reflog或者git log -g
2、新建分支git branch bugFix 3eac14d
3、上传分支git checkout bugFixgit push origin HEAD:bugFix
合并分支merge1、修改或添加文件，提交一次git add .，git commit
2、切换回mastergit checkout master
3、再次修改或添加文件，提交一次git add .，git commit
4、合并bugFix分支到mastergit merge bugFix如果有冲突，会有提示：
Auto-merging test.txtCONFLICT (content): Merge conflict in test.txtAutomatic merge failed; fix conflicts and then commit the result.

5、打开test.txt，可以看到类似如下冲突：
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADhello merge master=======hello merge bugFix&gt;&gt;&gt;&gt;&gt;&gt;&gt; bugFix
可以看到 ======= 隔开的上半部分，是 HEAD（即 master 分支，在运行 merge 命令时检出的分支）中的内容，下半部分是在bugFix分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。
6、修改test.txt如下：
hello merge master

7、在解决了所有文件里的所有冲突后，运行git add将把它们标记为已解决（resolved）。然后使用git commit命令进行提交，merge就算完成了。
8、切换到bugFix分支git checkout bugFix
9、合并master分支到bugFixgit merge master
rebase假设当前分支是bugFix，git rebase master进行的操作，把bugFix分支起点变成master分支的子节点。整个流程大致如下：
git branch bugFixgit checkout bugFixgit commitgit checkout mastergit commitgit checkout bugFixgit rebase master


书签Learn Git Branchinghttp://learngitbranching.js.org/
git merge简介http://blog.csdn.net/hudashi/article/details/7664382
Git Book 中文版 - rebasehttp://gitbook.liuhui998.com/4_2.html
]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>更好的 git commit message</title>
    <url>/dev-git-commit-message/</url>
    <content><![CDATA[还可以更好使用git很多年，也提交了很多代码，自以为使用习惯良好。因为每次提交代码，我都会在git commit message中说明清楚修改的内容。但是，偶然间读到一些关于commit message的文章，才发现还有很多进步的空间。
本文就来学习一下编写更高质量的提交信息，主要参考 Commit message 和 Change log 编写指南、优雅的提交你的 Git Commit Message 和 Conventional Commits。


约定式提交简介约定式提交规范是一种基于提交消息的轻量级约定。它提供了一组用于创建清晰的提交历史的简单规则；这使得编写基于规范的自动化工具变得更容易。 这个约定与 SemVer 相吻合， 在提交信息中描述新特性、bug 修复和破坏性变更。
约定式提交优点：

自动化生成 CHANGELOG。
基于提交的类型，自动决定语义化的版本变更。
向同事、公众与其他利益关系者传达变化的性质。
触发构建和部署流程。
让人们探索一个更加结构化的提交历史，以便降低对你的项目做出贡献的难度。

使用说明提交说明的结构如下所示：
&lt;类型&gt;[可选的作用域]: &lt;描述&gt;[可选的正文][可选的脚注]

提交方法：
git commit -m "dquote&gt; &lt;类型&gt;[可选的作用域]: &lt;描述&gt;dquote&gt;dquote&gt; [可选的正文]dquote&gt;dquote&gt; [可选的脚注]dquote&gt; "

提交说明包含了下面的结构化元素，以向类库使用者表明其意图：



类型
描述



fix
在代码库中修复了一个 bug（这和语义化版本中的 PATCH 相对应）。


feat
在代码库中新增了一个功能（这和语义化版本中的 MINOR 相对应）。


docs
文档相关的改动。


refactor
重构


improvement
性能提升


test
测试用例修改


style
代码格式修改, 注意不是 css 修改


chore
其他修改, 比如构建流程, 依赖管理。


Close
在可选的正文或脚注的起始位置，关闭issue


BREAKING CHANGE
在可选的正文或脚注的起始位置，表示引入了破坏性 API 变更（这和语义化版本中的 MAJOR 相对应）。 破坏性变更可以是任意类型提交的一部分。


以上类型都是可选的，其他类型也被允许，根据需要定义项目的提交规范就好。并且在语义化版本中没有隐式的影响（除非他们包含 BREAKING CHANGE）。可以为提交类型添加一个围在圆括号内的作用域，以为其提供额外的上下文信息。例如：
feat(parser): adds ability to parse arrays.

可以在类型/作用域前缀之后，: 之前，附加 ! 字符，以进一步提醒注意破坏性变更。当有 ! 前缀时，正文或脚注内必须包含 BREAKING CHANGE: description
约定式提交和 SemVer 的关联：fix 类型提交应当对应到 PATCH 版本。feat 类型提交应该对应到 MINOR 版本。带有 BREAKING CHANGE 的提交不管类型如何，都应该对应到 MAJOR 版本。
参考
yargs：广受欢迎的命令行参数解析器。
istanbuljs：一套为 JavaScript 测试生成测试覆盖率的开源工具和类库。
massive.js：一个用于 Node 和 PostgreSQL 的数据访问类库。
electron：用 JavaScript、HTML 和 CSS 构建跨平台应用。
scroll-utility：一个居中元素和平滑动画的滚屏工具包实例。
Blaze UI：无框架开源 UI 套件。
Monica：一个开源的人际关系管理系统。
mhy：一个零配置、开箱即用的、多用途工具箱与开发环境。
sharec：一个用于模板和配置文件版本化的极简工具。

提交帮助工具git commit提示1、修改 ~/.gitconfig ，添加
[commit]template = ~/.gitmessage

2、新建 ~/.gitmessage ，内容为
# head: &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;# - type: feat, fix, docs, style, refactor, test, chore# - scope: can be empty (eg. if the change is a global or difficult to assign to a single component)# - subject: start with verb (such as 'change'), 50-character line## body: 72-character wrapped. This should answer:# * Why was this change necessary?# * How does it address the problem?# * Are there any side effects?## footer: # - Include a link to the ticket, if any.# - BREAKING CHANGE#

3、使用提示git commit
commitizen参考 commitizen/cz-cli 。
]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git commit问题详解</title>
    <url>/dev-git-commit/</url>
    <content><![CDATA[怎样修改 commit user ？问题描述git的 user.name 和 user.email 配置错了，然后还提交了很多commit，怎么办？不要慌，git支持修改历史commit记录的用户名和邮箱。


思路参考Changing author info，使用脚本进行修改。
实现以macos上操作为例。
1、clone项目
git clone --bare https://github.com/user/repo.gitcd repo

2、创建修改用户名的脚本 change-author.sh
#!/bin/shgit filter-branch --env-filter 'OLD_EMAIL="your-old-email@example.com"CORRECT_NAME="Your Correct Name"CORRECT_EMAIL="your-correct-email@example.com"if [ "$GIT_COMMITTER_EMAIL" = "$OLD_EMAIL" ]thenexport GIT_COMMITTER_NAME="$CORRECT_NAME"export GIT_COMMITTER_EMAIL="$CORRECT_EMAIL"fiif [ "$GIT_AUTHOR_EMAIL" = "$OLD_EMAIL" ]thenexport GIT_AUTHOR_NAME="$CORRECT_NAME"export GIT_AUTHOR_EMAIL="$CORRECT_EMAIL"fi' --tag-name-filter cat -- --branches --tags

其中 OLD_EMAIL、CORRECT_NAME、CORRECT_EMAIL 三个变量需要替换。
3、执行脚本sh change-author.sh
4、检查结果，强制同步到远程仓库
git loggit push --force --tags origin 'refs/heads/*'

怎样修改上次 commit message ？问题描述git commit -m &quot;something&quot;，之后，想要修改“something”为“something_new”。
解决办法使用git commit --amend，可以修改最后一次commit的附加信息。
怎样合并多次 commit ？需求最近三次提交：

第一次以为完成了，commit message写了“完成了xxx功能”。
结果发现有bug，修复后第二次提交，commit message写了“修复xxx功能的bug”。
结果发现还有bug，修复后第三次提交，commit message写了“修复xxx功能的bug”。

这样的三次提交，没毛病，但是可以美化一下，合并成一次提交。
操作步骤1、合并最新三次的提交
git rebase -i HEAD~3
自动进入vi编辑模式，此时看到的commit信息是按照时间顺序排列的，最新的commit在最下面。按照提示的命令编辑commit信息，一般改成p s s即可。
如果修改完报错：error: cannot ‘squash’ without a previous commit那么可以继续修改：
git rebase --edit-todo

2、解决冲突后提交（不使用git commit）
git add .git rebase --continue

3、取消rebase
git rebase --abort

怎样删除某次 commit ？需求已知一些提交记录为：
commit efaec33c2a081e427c5201898b3fc61179475f69commit 5fdf644e089dcb245b1f3dde5e8942fc935ffccccommit 550ae58fc222c5c4cd99027a580423d2567969e6commit f3e9a940df8371d5282f151a5c6e6e74a1e3dead
现在想要删除 550ae58fc222c5c4cd99027a580423d2567969e6 这次commit，该怎么操作？
操作步骤1、rebase到要删除的commit的前一个commit
git rebase -i f3e9a940df8371d5282f151a5c6e6e74a1e3dead

2、找到删除的commit（第一个），标记为 drop，保存
drop 550ae58 add: xxxpick 5fdf644 modify: xxxpick efaec33 modify: xxx

3、解决冲突后提交（不使用git commit）
git statusgit rm &lt;conflict-file&gt;git add .git rebase --continue


]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git tag使用说明</title>
    <url>/dev-git-tag/</url>
    <content><![CDATA[打标签所谓打标签，就是对某一时间点上的版本打上标签。Git使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。



轻量标签。创建轻量标签不需要传递参数，直接指定标签名称即可。git tag v1.0.0_light

附注标签。参数a即annotated的缩写，指定标签名。参数m指定标签说明，说明信息会保存在标签对象中。git tag -a v1.0.0 -m &quot;v1.0.0&quot;


查看本地标签git taggit tag -l &#39;v1.0.*&#39;git show v1.0.0
删除本地标签git tag -d &lt;tagname&gt;
切换到标签git checkout &lt;tagname&gt;
给指定的commit打标签git log，我们看到的commit是一长串十六进制数，比如759f084c094a2e3930224b2dad389349e36ab083，我们要用到至少前4位。
git tag -a v0.0.0 759f -m &quot;v0.0.0&quot;，而且，每个commit可以打多个标签。
添加服务器端标签默认情况下，git push 并不会把标签传送到远端服务器上，只有通过显式命令才能分享标签到远端仓库。git push origin &lt;tagname&gt;git push origin --tag
删除服务器端标签方法一：git push --delete origin tag &lt;tagname&gt;
方法二：git tag -d &lt;tagname&gt;git push origin :refs/tags/&lt;tagname&gt;
完整例子打标签的操作发生在我们commit修改到本地仓库之后。git add .git commit -m &quot;fixed some bugs&quot;git tag -a 0.1.3 -m &quot;Release version 0.1.3&quot;
分享提交标签到远程服务器上git pushgit push --tags–tags参数表示提交所有tag至服务器端，普通的git push操作不会推送标签到服务器端。
删除本地标签git tag -d 0.1.3
删除远端服务器标签git push origin :refs/tags/0.1.3
参考文档Git 基础 - 打标签http://git-scm.com/book/zh/v1/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE
git命令之git tag 给当前分支打标签http://blog.csdn.net/wangjia55/article/details/8793577
git tag简介http://blog.csdn.net/hudashi/article/details/7664468
tag打标签http://blog.csdn.net/wh_19910525/article/details/7470850
git tag操作教程http://blog.csdn.net/waterforest_pang/article/details/9762863
]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>gitignore用法</title>
    <url>/dev-gitignore/</url>
    <content><![CDATA[前言有些时候，我们必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件、项目运行时生成的临时文件等等，每次git status都会显示Untracked files ...，让人不爽。
好在Git考虑到了大家的感受，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。


gitignore规则基本语法
以斜杠/开头表示目录
以星号*通配多个字符；
以问号?通配单个字符
以方括号[]包含单个字符的匹配列表
以叹号!表示不忽略(跟踪)匹配到的文件或目录

示例# 这是注释行，将被忽略.DS_Store # 忽略所有的.DS_Store*.a       # 忽略所有以.a为扩展名的文件    !lib.a    # 但是名为lib.a的文件或目录不要忽略，即使前面设置了对*.a的忽略/TODO     # 只忽略根目录下的TODO文件，子目录中的TODO文件不忽略/target/ # 只忽略根目录下的target目录中的全部文件target/  # 忽略所有target目录中的文件doc/*.txt # 忽略文件如doc/notes.txt，但是文件如doc/server/arch.txt不忽略

push之后添加gitignoregitignore只能作用于 Untracked Files，如果某些文件（add和commit过的文件）已经被纳入了版本管理中，则修改gitignore是无效的。解决方法就是先把本地缓存删除（改变成Untracked状态），然后再提交。
git pullgit rm -r --cached .git add .git commit -m 'update .gitignore'git push

如果是单个文件需要Untrack，git rm -r --cached .建议改成git rm -r --cached path/filename。
添加gitignore后pull错误push之后添加了gitignore，也就是一部分的Tracked Files，现在不再Track。这时，其他用户在pull代码的时候，会出现错误：“The following untracked working tree files would be overwritten by merge”
解决办法：
git reset --hard HEAD    git clean -f -d    git pull

自动生成gitignore1、访问网址：gitignore.io
2、输入操作系统、IDE、编程语言等，就能自动生成通用的gitignore文件。
3、根据自己的实际需要，增删一些配置。
一个Demo### macOS #### General.DS_Store.AppleDouble.LSOverride# Thumbnails._*# Files that might appear in the root of a volume.DocumentRevisions-V100.fseventsd.Spotlight-V100.TemporaryItems.Trashes.VolumeIcon.icns.com.apple.timemachine.donotpresent# Directories potentially created on remote AFP share.AppleDB.AppleDesktopNetwork Trash FolderTemporary Items.apdisk### End of macOS ###### Intellij #### Covers JetBrains IDEs: IntelliJ, RubyMine, PhpStorm, AppCode, PyCharm, CLion, Android Studio, WebStorm and Rider# Reference: https://intellij-support.jetbrains.com/hc/en-us/articles/206544839# General.idea/# mpeltonen/sbt-idea plugin.idea_modules/# File-based project format*.iws# IntelliJout/# CMakecmake-build-*/# Crashlytics plugin (for Android Studio and IntelliJ)com_crashlytics_export_strings.xmlcrashlytics.propertiescrashlytics-build.propertiesfabric.properties### End of Intellij ###

书签A collection of useful .gitignore templates
Github使用.gitignore文件忽略不必要上传的文件
Git忽略规则
忽略特殊文件
解决Git在添加ignore文件之前就提交了项目无法再过滤问题
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言入门篇</title>
    <url>/dev-go-start/</url>
    <content><![CDATA[Go语言简介Go（又称 Golang）是 Google 的 Robert Griesemer，Rob Pike 及 Ken Thompson 开发的一种静态强类型、编译型语言。Go 语言语法与 C 相近，但功能上有：内存安全，GC（垃圾回收），结构形态及 CSP-style 并发计算。
本文，我们开始学习Golang，主要参考：

Go 语言教程
Go标准库中文文档
Go程序设计语言（Go语言圣经）



开发环境1、访问Go官网，下载安装Golang环境。
2、把Golang的bin目录添加到Path环境变量。
3、访问Jetbrains-Go，下载安装Goland。
4、在Goland中配置好GOROOT和GOPATH。
helloworld按照国际惯例，学习新语言，先来一个helloworld。新建test.go文件，内容为：
package mainimport "fmt"func main() &#123;   fmt.Println("Hello, World!")&#125;

Shift+右键打开Powershell，使用go run test.go，运行代码。除了使用go run命令之外，还可以使用go build命令，先对代码进行编译，然后运行生成的二进制文件。
由上面这段代码可以看出，Go语言代码的基础组成有包声明、引入包、函数、语句和表达式。除此之外，还有注释、常量、变量、数组、结构体等。
Go基础语法Go的语法和C很像，这里和C进行对比，指出不同之处，方便记忆。

{不能单独放在一行
表达式不需要分号结尾
变量声明赋值，var age int = 0
数据类型有差异
强制类型转换时括号的位置不同
支持多变量赋值，按顺序赋值
:=操作符也可以声明变量，但是只能在函数体内
const声明可以使用iota
if和for后面不需要圆括号
switch不需要break
循环都用for，没有while
函数定义，func func_name([params]) [return_types]{}
数组声明，var arr [10] float32; var arr2 = [3]float32{1.0, 2.0, 3.4}
结构体定义，type先行，下面有demo
切片（动态数组），var slice1 []int = make([]int, 3, 9)
切片append，copy
字典map定义，var map1 map[string]string = make(map[string]string)
字典delete条目
for range循环切片和字典
定义接口，下面有demo
错误处理，error接口，下面有demo
并发，go语句开启新线程，下面有demo

结构体demo：
package mainimport "fmt"type Books struct &#123;   title string   author string   subject string   book_id int&#125;func main() &#123;    // 创建一个新的结构体    fmt.Println(Books&#123;"Go 语言", "www.voidking.com", "Go 语言教程", 6495407&#125;)    // 也可以使用 key =&gt; value 格式    fmt.Println(Books&#123;title: "Go 语言", author: "www.voidking.com", subject: "Go 语言教程", book_id: 6495407&#125;)    // 忽略的字段为 0 或 空    fmt.Println(Books&#123;title: "Go 语言", author: "www.voidking.com"&#125;)    // 结构体声明和赋值    var Book1 Books    Book1.title = "Go语言入门篇"    Book1.author = "www.voidking.com"    Book1.subject = "Go语言"    Book1.book_id = 123456    printBook(Book1)&#125;func printBook( book Books ) &#123;   fmt.Printf( "Book title : %s\n", book.title);   fmt.Printf( "Book author : %s\n", book.author);   fmt.Printf( "Book subject : %s\n", book.subject);   fmt.Printf( "Book book_id : %d\n", book.book_id);&#125;


接口demo：
package mainimport (    "fmt")type Phone interface &#123;    call()&#125;type NokiaPhone struct &#123;&#125;func (nokiaPhone NokiaPhone) call() &#123;    fmt.Println("I am Nokia, I can call you!")&#125;type IPhone struct &#123;&#125;func (iPhone IPhone) call() &#123;    fmt.Println("I am iPhone, I can call you!")&#125;func main() &#123;    var phone Phone    phone = new(NokiaPhone)    phone.call()    phone = new(IPhone)    phone.call()&#125;

错误处理demo：
package mainimport (    "fmt")// 定义一个 DivideError 结构type DivideError struct &#123;    dividee int    divider int&#125;// 实现 `error` 接口func (de *DivideError) Error() string &#123;    strFormat := `    Cannot proceed, the divider is zero.    dividee: %d    divider: 0`    return fmt.Sprintf(strFormat, de.dividee)&#125;// 定义 `int` 类型除法运算的函数func Divide(varDividee int, varDivider int) (result int, errorMsg string) &#123;    if varDivider == 0 &#123;        dData := DivideError&#123;            dividee: varDividee,            divider: varDivider,        &#125;        errorMsg = dData.Error()        return    &#125; else &#123;        return varDividee / varDivider, ""    &#125;&#125;func main() &#123;    // 正常情况    if result, errorMsg := Divide(100, 10); errorMsg == "" &#123;        fmt.Println("100/10 = ", result)    &#125;    // 当被除数为零的时候会返回错误信息    if _, errorMsg := Divide(100, 0); errorMsg != "" &#123;        fmt.Println("errorMsg is: ", errorMsg)    &#125;&#125;

并发demo：
package mainimport (    "fmt"    "time")func say(s string) &#123;    for i := 0; i &lt; 5; i++ &#123;        time.Sleep(100 * time.Millisecond)        fmt.Println(s)    &#125;&#125;func main() &#123;    say("hello")    go say("world")&#125;

后记Go语言入门篇，核心就是把Go语言当成C来写，和C不同的地方，留心注意即可。更多高阶的内容，用到的时候再去学习整理。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>Go语言开发的小技巧</title>
    <url>/dev-golang-skills/</url>
    <content><![CDATA[前言最近学到了一些Go语言开发时的小技巧，做下记录。
提高下载速度方法一：科学上网
方法二：配置代理，详情参考《Golang包管理工具》
# export GOPROXY=https://goproxy.cnexport GOPROXY=https://goproxy.ioexport GO111MODULE=ongo get -v golang.org/x/tools/cmd/goimports

方法三：使用gopm
go get -v github.com/gpmgo/gopmgopm get -v golang.org/x/tools/cmd/goimports



编译安装软件go build golang.org/x/tools/cmd/goimportsgo install golang.org/x/tools/cmd/goimports

自动格式化Golang希望统一代码风格，因此推出了gofmt工具。gofmt可以格式化单个文件，也可以格式化整个目录下的所有go文件。除了gofmt工具，go语言中还有一个go fmt命令，该命令是gofmt的简单封装。
在IDEA中，怎样使用gofmt呢？1、菜单栏，IntelliJ IDEA，Preferences…。2、Plugins，搜索File，找到File Watchers插件并安装。3、Tools，File Watchers，添加或修改gofmt模版。
File type：GoScope：Project filesProgram：/usr/local/go/bin/gofmtArguments：-l -w -s $FilePath$Output paths to refresh：$FilePath$
4、勾选Enabled。
保存源码时，就会执行代码格式化了。
自动引入依赖包参考上一节自动格式化，配置 goimports ，自动引入依赖包。
查看文档如果对一个包或者函数不熟悉，可以使用go doc命令查看文档。比如：
go doc http.ListenAndServe

如果想要看一个项目的帮助文档，可以使用godoc工具启动一个文档服务器。
go get -v golang.org/x/tools/cmd/godocgodoc -http :6060

测试Debugging Sucks! Testing Rocks!Go语言支持三种测试：单元测试、性能测试和http测试，下面分别来看一下。
单元测试Go语言单元测试函数以Test为前缀，详情参考测试函数。
实际开发中推荐使用表格驱动测试，就是把测试数据和测试逻辑分开。比如：
func TestShortFilename(t *testing.T) &#123;    tests := []struct &#123;        in       string        expected string    &#125;&#123;        &#123;"???", "???"&#125;,        &#123;"filename.go", "filename.go"&#125;,        &#123;"hello/filename.go", "filename.go"&#125;,        &#123;"main/hello/filename.go", "filename.go"&#125;,    &#125;    for _, tt := range tests &#123;        actual := getShortFilename(tt.in)        if strings.Compare(actual, tt.expected) != 0 &#123;            t.Fail()        &#125;    &#125;&#125;

在IDEA中查看代码覆盖率：在单元测试函数左边，会出现一个三角箭头，点击它，选择 Run ‘Testxxx’ with Coverage，即可看到代码覆盖率。绿线代表覆盖到了，红线代表没有覆盖到。
也可以使用命令查看代码覆盖率：
go test -coverprofile=c.outgo tool covergo tool cover html=c.out

性能测试1、编写性能测试函数，以Benchmark为前缀，详情参考基准测试。
2、运行基准测试
go test -bench .

3、详细分析（文本）
go test bench . -cpuprofile cpu.outgo tool pprof -text -nodecount=10 ./cpu.test cpu.out

4、详细分析（图表）
go tool pprof cpu.outweb
PS：需要安装graphviz，以便生成图表。
http测试Go语言的http测试使用 net/http/httptest 包，测试方法可以分为两种：一种是使用假的Request/Response，速度快，测试粒度小，适用于测试函数和方法；另外一种是启动http服务器，速度慢，代码覆盖量更大，适用于测试和模拟后端接口。
先说第一种，使用假的Request/Response：1、已知函数
func HelloHandler(w http.ResponseWriter, r *http.Request) &#123;	w.Write([]byte("hello world"))&#125;

2、测试代码
import (	"io/ioutil"	"net/http"	"net/http/httptest"	"testing")func TestHelloHandler(t *testing.T) &#123;	req := httptest.NewRequest("GET", "http://www.voidking.com/", nil)	w := httptest.NewRecorder()	HelloHandler(w, req)	bytes, _ := ioutil.ReadAll(w.Result().Body)	if string(bytes) != "hello world" &#123;		t.Fatal("expected hello world, but got", string(bytes))	&#125;&#125;

3、运行测试go test -v .
再说第二种，启动http服务器。1、已知函数
func HelloHandler(w http.ResponseWriter, r *http.Request) &#123;	w.Write([]byte("hello world"))&#125;

2、测试代码
import (	"io/ioutil"	"net/http"	"net/http/httptest"	"testing")func TestHelloHandler(t *testing.T) &#123;	ts := httptest.NewServer(http.HandlerFunc(HelloHandler))	defer ts.Close() 	res, err := http.Get(ts.URL)	if err != nil &#123;		t.Fatal(err)	&#125;	bytes, err := ioutil.ReadAll(res.Body)	res.Body.Close()	if err != nil &#123;		t.Fatal(err)	&#125; 	if string(bytes) != "hello world" &#123;		t.Fatal("expected hello world, but got", string(bytes))	&#125;&#125;

3、运行测试go test -v .
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>图像二值化</title>
    <url>/dev-gp-image-binary/</url>
    <content><![CDATA[理论图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果。
一幅图像包括目标物体、背景还有噪声，要想从多值的数字图像中直接提取出目标物体，常用的方法就是设定一个阈值T，用T将图像的数据分成两部分：大于T的像素群和小于T的像素群。这是研究灰度变换的最特殊的方法，称为图像的二值化（Binarization）。
常见的二值化方法有三种，分别是固定阈值法、平均值法、自适应阈值法和直方图法。
固定阈值法就是设定一个固定阈值K，小于等于K的像素值设为0(黑色)，大于K的像素值设为255(白色)。
平均值法计算像素的平均值K，然后扫描图像的每个像素值，小于等于K像素值设为0(黑色)，大于K的像素值设为255(白色)。
自适应阈值法对平均值法进行改进，规定一个区域大小，求区域平均值作为阈值K，然后区域中的像素值与K进行比较。
直方图方法主要是发现图像的两个最高的峰，然后阈值K取值在两个峰之间的峰谷最低处。图像的直方图用来表征该图像像素值的分布情况。用一定数目的小区间(bin)来指定表征像素值的范围，每个小区间会得到落入该小区间表示范围的像素数目。
更多内容参考图像的二值化之python+opencv和opencv python图像二值化。


实践固定阈值法import cv2from matplotlib import pyplot as pltimg=cv2.imread('../image/test.jpg')GrayImage=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)ret,thresh1=cv2.threshold(GrayImage,127,255,cv2.THRESH_BINARY)ret,thresh2=cv2.threshold(GrayImage,127,255,cv2.THRESH_BINARY_INV)ret,thresh3=cv2.threshold(GrayImage,127,255,cv2.THRESH_TRUNC)ret,thresh4=cv2.threshold(GrayImage,127,255,cv2.THRESH_TOZERO)ret,thresh5=cv2.threshold(GrayImage,127,255,cv2.THRESH_TOZERO_INV)titles = ['Gray Image','BINARY','BINARY_INV','TRUNC','TOZERO','TOZERO_INV']images = [GrayImage, thresh1, thresh2, thresh3, thresh4, thresh5]for i in range(6):   plt.subplot(2,3,i+1),plt.imshow(images[i],'gray')   plt.title(titles[i])   plt.xticks([]),plt.yticks([])plt.show()


如果报错没有matplotlib，那么先执行pip install matplotlib进行安装。
retval,dst = cv.threshold(src, thresh, maxval, type[, dst] )参数解释：

src：原图像，原图像应该是灰度图。
thresh：用来对像素值进行分类的阈值。
maxval：大于阈值置为maxval。
type：不同的阈值方法。

平均阈值法import cv2import numpy as npfrom matplotlib import pyplot as pltimg=cv2.imread('../image/test.jpg')GrayImage=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)k=np.mean(GrayImage)ret,thresh1=cv2.threshold(GrayImage,k,255,cv2.THRESH_BINARY)ret,thresh2=cv2.threshold(GrayImage,k,255,cv2.THRESH_BINARY_INV)ret,thresh3=cv2.threshold(GrayImage,k,255,cv2.THRESH_TRUNC)ret,thresh4=cv2.threshold(GrayImage,k,255,cv2.THRESH_TOZERO)ret,thresh5=cv2.threshold(GrayImage,k,255,cv2.THRESH_TOZERO_INV)titles = ['Gray Image','BINARY','BINARY_INV','TRUNC','TOZERO','TOZERO_INV']images = [GrayImage, thresh1, thresh2, thresh3, thresh4, thresh5]for i in range(6):   plt.subplot(2,3,i+1),plt.imshow(images[i],'gray')   plt.title(titles[i])   plt.xticks([]),plt.yticks([])plt.show()

自适应阈值法import cv2from matplotlib import pyplot as pltimg=cv2.imread('../image/test.jpg')GrayImage=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)ret,th1 = cv2.threshold(GrayImage,127,255,cv2.THRESH_BINARY)th2 = cv2.adaptiveThreshold(GrayImage,255,cv2.ADAPTIVE_THRESH_MEAN_C,\                    cv2.THRESH_BINARY,3,4)th3 = cv2.adaptiveThreshold(GrayImage,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,\                    cv2.THRESH_BINARY,3,4)titles = ['Gray Image', 'Global Thresholding (v = 127)','Adaptive Mean Thresholding', 'Adaptive Gaussian Thresholding']images = [GrayImage, th1, th2, th3]for i in range(4):   plt.subplot(2,2,i+1),plt.imshow(images[i],'gray')   plt.title(titles[i])   plt.xticks([]),plt.yticks([])plt.show()


dst = cv.adaptiveThreshold(src, maxValue, adaptiveMethod, thresholdType, blockSize, C[, dst] )参数解释：

src：指原图像，原图像应该是灰度图。
maxValue：大于阈值置为maxValue。
adaptiveMethod：要使用的自适应阈值算法。
thresholdType：阈值类型必须是THRESH_BINARY或THRESH_BINARY_INV。
blockSize：用于计算像素的阈值的像素邻域的大小：3,5,7等。
C：从平均值或加权平均值中减去常数。通常情况下，它是正数，但也可能为零或负数。

直方图法import cv2import numpy as npfrom matplotlib import pyplot as pltimg=cv2.imread('../image/test.jpg')img=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)# global thresholdingret1,th1 = cv2.threshold(img,127,255,cv2.THRESH_BINARY)# Otsu's thresholdingret2,th2 = cv2.threshold(img,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)# Otsu's thresholding after Gaussian filteringblur = cv2.GaussianBlur(img,(5,5),0)ret3,th3 = cv2.threshold(blur,0,255,cv2.THRESH_BINARY+cv2.THRESH_OTSU)# plot all the images and their histogramsimages = [img, 0, th1,          img, 0, th2,          blur, 0, th3]titles = ['Original Noisy Image','Histogram','Global Thresholding (v=127)',          'Original Noisy Image','Histogram',"Otsu's Thresholding",          'Gaussian filtered Image','Histogram',"Otsu's Thresholding"]for i in range(3):    plt.subplot(3,3,i*3+1),plt.imshow(images[i*3],'gray')    plt.title(titles[i*3]), plt.xticks([]), plt.yticks([])    plt.subplot(3,3,i*3+2),plt.hist(images[i*3].ravel(),256)    plt.title(titles[i*3+1]), plt.xticks([]), plt.yticks([])    plt.subplot(3,3,i*3+3),plt.imshow(images[i*3+2],'gray')    plt.title(titles[i*3+2]), plt.xticks([]), plt.yticks([])plt.show()

后记至此，实现了常用的四种图像二值化算法。根据不同的需要，选择不同的算法。比如对于这幅图，如果要最佳的二值化显示效果，那么平均值法最好；如果要提取轮廓，那么自适应阈值法最好；如果要获取兔斯基，那么直方图法最好。
书签OpenCV3.4官方文档
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>毕设</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>图像灰度化</title>
    <url>/dev-gp-image-graying/</url>
    <content><![CDATA[前言离研究生毕业只有六个月了，毕业设计也该动手了。去年开题，选择了《基于图像处理的客观题自动阅卷系统的设计与实现》这个题目。今年中期，考虑了很久，最终还是没有换题目。想要做AIOps，但是自己基础薄弱，也没有特定的方向，到了六月份也不一定能完成。保险起见，还是做阅卷系统吧！
阅卷系统主要有五个方面的研究内容，分别是图像预处理、目标检测、图像分割、手写识别和移动Web。其中图像预处理包括试卷图像的灰度化、二值化、去噪、倾斜矫正等；目标检测是为了定位学号和答案的位置，并且提取出这些信息；图像分割是为了分割学号和多选题的字符；手写识别是为了识别手写字符，包括数字和字母；移动Web是为了方便老师随时随地使用系统。
本文，就来研究一下图像的灰度化。


理论在RGB模型中，如果R=G=B时，则彩色表示一种灰度颜色，其中R=G=B的值叫灰度值，因此，灰度图像每个像素只需一个字节存放灰度值（又称强度值、亮度值），灰度范围为0-255。一般有以下四种方法对彩色图像进行灰度化：
1、分量法将彩色图像中的三分量的亮度作为三个灰度图像的灰度值，可根据应用需要选取一种灰度图像。f1(i,j)=R(i,j) f2(i,j)=G(i,j) f3(i,j)=B(i,j) 其中fk(i,j)(k=1,2,3)为转换后的灰度图像在(i,j)处的灰度值。
2、最大值法 　　将彩色图像中的三分量亮度的最大值作为灰度图的灰度值。f(i,j)=max(R(i,j),G(i,j),B(i,j))
3、平均值法 　　将彩色图像中的三分量亮度求平均得到一个灰度图。f(i,j)=(R(i,j)+G(i,j)+B(i,j))/3
4、加权平均法 　　根据重要性及其它指标，将三个分量以不同的权值进行加权平均。由于人眼对绿色的敏感最高，对蓝色敏感最低，因此，按下式对RGB三分量进行加权平均能得到较合理的灰度图像。f(i,j)=0.30R(i,j)+0.59G(i,j)+0.11B(i,j))
更多内容参考图像分析。
实践算法的实现，主要参考Python下OpenCV的使用 – 图像灰度化。
安装opencv这个毕业设计，打算使用python来实现，编辑器使用pycharm。图像处理方面，主要使用opencv。首先安装opencv，很简单，一条命令即可：pip install opencv-python
如果离线安装的话，不妨参考使用OpenCV实现实时视频目标检测。
安装完成后，命令行中输入python，进入python shell。输入import cv2回车，如果没有报错，说明安装成功。
简单灰度化在加载图片的时候，直接调用opencv的灰度化方法。
import cv2image = cv2.imread('image/test.jpg')grayimage = cv2.imread('image/test.jpg',cv2.IMREAD_GRAYSCALE)cv2.imshow('image',image)cv2.imshow('grayimage',grayimage)cv2.waitKey(0)

分量法import cv2image = cv2.imread('image/test.jpg')b,g,r = cv2.split(image)   # the order is not r,g,bcv2.namedWindow("Image")cv2.imshow("Image",image)cv2.namedWindow("ImageR")cv2.imshow("ImageR",r)cv2.namedWindow("ImageG")cv2.imshow("ImageG",g)cv2.namedWindow("ImageB")cv2.imshow("ImageB",b)cv2.waitKey(0)cv2.destroyAllWindows()

最大值法import cv2import numpyimage = cv2.imread('image/test.jpg')shape = (image.shape[0],image.shape[1])newImage = numpy.ndarray(shape,image.dtype)for i in range(image.shape[0]):    for j in range(image.shape[1]):       newImage[i,j] = max(image[i,j][0],image[i,j][1],image[i,j][2])cv2.namedWindow("NewImageMax")cv2.imshow("NewImageMax",newImage)cv2.waitKey(0)cv2.destroyAllWindows()

平均值法import cv2import numpyimage = cv2.imread('image/test.jpg')shape = (image.shape[0],image.shape[1])newImage = numpy.ndarray(shape,image.dtype)for i in range(image.shape[0]):    for j in range(image.shape[1]):       newImage[i,j] = (int(image[i,j][0]) + int(image[i,j][1]) + int(image[i,j][2])) / 3cv2.namedWindow("NewImageAver")cv2.imshow("NewImageAver",newImage)cv2.waitKey(0)cv2.destroyAllWindows()

加权平均法import cv2import numpyimage = cv2.imread('image/test.jpg')shape = (image.shape[0],image.shape[1])newImage = numpy.ndarray(shape,image.dtype)for i in range(image.shape[0]):    for j in range(image.shape[1]):        newImage[i,j] = 0.11 * image[i,j][0] + 0.59 * image[i,j][1] + 0.30 * image[i,j][2]cv2.namedWindow("NewImageWeightAver")cv2.imshow("NewImageWeightAver",newImage)cv2.waitKey(0)cv2.destroyAllWindows()

后记关于图像灰度化，就整理到这里，之后会继续研究其他知识点。
书签opencv-python快速入门篇
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>毕设</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>使用百度地图实现发帖时的定位</title>
    <url>/dev-graduation-project-baidumap/</url>
    <content><![CDATA[功能描述在发布帖子界面，用户可以选择是否在发布帖子时显示位置。位置图标默认灰色，不显示位置；用户选择位置后，位置图标变成绿色，同时把位置信息显示在发布帖子界面上。



原理百度地图，提供了四种定位的方式，分别是根据浏览器定位、根据IP定位、根据城市名定位、根据经纬度定位。本功能模块中，采用根据浏览器定位的方式。
浏览器通过js请求百度地图API，获取到地址信息后，发送给我的服务器。
代码html引入百度地图api，定义一个id，用来初始化BMap。
&lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=BC46e2b24290dba4d0267e2430f512fe"&gt;&lt;/script&gt;&lt;div id="allmap" style="display: none;"&gt;&lt;/div&gt;

js新建BMap对象，给一个初始化坐标，然后浏览器通过百度地图API获取到位置信息，获取到位置信息后，和帖子的其他信息一起，发送给服务端。
// 百度地图定位var baidu_position = &#123;&#125;;var map = new BMap.Map("allmap");var point = new BMap.Point(118.895144,31.92596);map.centerAndZoom(point,12);var geolocation = new BMap.Geolocation();geolocation.getCurrentPosition(function(r)&#123;    if(this.getStatus() == BMAP_STATUS_SUCCESS)&#123;        var mk = new BMap.Marker(r.point);        map.addOverlay(mk);        map.panTo(r.point);        //alert('您的位置：'+r.point.lng+','+r.point.lat);        console.log(r);        baidu_position = r;    &#125;    else &#123;        alert('failed'+this.getStatus());    &#125;&#125;,&#123;enableHighAccuracy: true&#125;)

源码https://github.com/voidking/nodeforum/blob/master/public/js/post/post-add.js
书签百度地图APIhttp://developer.baidu.com/map/reference/
百度地图API示例http://developer.baidu.com/map/jsdemo.htm#d0_2
百度LSB API开发指南http://developer.baidu.com/map/wiki/index.php?title=uri/api/web
拾取坐标系统http://api.map.baidu.com/lbsapi/getpoint/index.html
根据标注点坐标范围计算显示缩放级别zoom自适应显示地图http://www.aichengxu.com/view/2456553
百度地图API详解和运用http://blog.csdn.net/binyao02123202/article/details/7955803
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业专业环境的搭建</title>
    <url>/dev-graduation-project-dev-environment/</url>
    <content><![CDATA[Webstorm访问Jetbrains的Webstorm官网：http://www.jetbrains.com/webstorm/ ，下载Webstorm，双击安装。
Git访问Git官网：https://git-scm.com/download/ ，下载Git，双击安装。需要注意的是，在Select Components界面，点选Simple context menu，方便以后直接右键打开Git bash。
Node访问Node官网：https://nodejs.org/en/ ，下载稳定版的Node，双击安装。安装之后，win+R，cmd，打开命令提示符界面，输入node --version，如果可以看到版本号，就说明安装成功。
Express新建文件夹nodeforum，在文件夹下打开Git bash，npm install express。
测试运行在nodeforum下新建文件app.js，内容如下：
var express = require('express');var app = express();app.get('/', function (req, res) &#123;   res.send('Hello World');&#125;);var server = app.listen(3000, function () &#123;  console.log('应用启动在port:'+3000)&#125;);
在Git bash下输入：node app.js。然后访问http://localhost:3000 ，看到“Hello World”，就表明express安装成功！
MongoDB访问MongoDB官网：https://www.mongodb.com/download-center#community下载MongoDB，双击安装。之后，打开命令提示符界面，输入mongo，进入MongoDB shell，如果可以进入，说明安装成功。
项目结构│  .gitignore│  app.js│  bower.json│  config.js│  package.json│  README.md│  socket-event.js│  web-router.js├─bower_components├─controllers├─models├─node_modules├─public│  ├─css│  ├─img│  ├─js│  └─scss├─schemas└─views

.gitignore内写的是不需要上传到Git服务器的文件。
app.js是程序的入口。
bower.json是Bower配置文件，声明了一系列与前端包有关的内容。
config.js声明了一些全局配置。
package.json是Npm的配置文件，声明了一系列与Node依赖包有关的内容。
README.md是关于整个项目的说明。
socket-event.js里定义了一个函数，用来处理socket.io的服务器端。
web-router.js里写的是路由控制。
bower_components文件夹里是开发过程中需要依赖的一些前端软件包。
controllers文件夹里是处理请求，以及控制页面跳转的一些文件。
models文件夹里是一些Mongoose建立的Model文件。
node_modules文件夹里是开发过程中需要依赖的一些Node软件包。
public文件夹里存放自己写的scss文件、js文件、需要用到图片文件。
schemas文件夹里是一些Mongoose建立的Schema文件。
views文件里存放的是前端模板文件。

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>使用七牛管理图片</title>
    <url>/dev-graduation-project-qiniu/</url>
    <content><![CDATA[功能描述在发布帖子界面，用户可以选择图片上传，图片上传成功后显示在发布帖子界面上，上传失败则提示“上传失败”。


原理七牛是一个优秀的云存储平台，提供图片相关的缩略、剪裁、添加水印等功能。本系统的重心在于社区论坛，所以处理图片的工作就交给七牛了，避免重复造轮子。
在发布帖子页面，用户选择图片后，浏览器获取到图片数据imageData，发送给我的服务器，我的服务器转发图片数据给七牛服务器。上传成功后，七牛服务器返回数据给我的服务器，我的服务器返回数据给浏览器。
浏览器获得返回数据，如果获取到服务器返回的状态true和图片url，则把图片显示在页面上。否则，就把告知用户“上传失败”。
代码html&lt;div class="form-group"&gt;    &lt;label for="picture" class="col-sm-2 control-label"&gt;图片&lt;/label&gt;    &lt;div class="col-sm-9"&gt;        &lt;!--&lt;input id="image"  type="file" multiple&gt;--&gt;        &lt;input type="file" id="picture" style="display: none;" /&gt;        &lt;span class="icon-picture"&gt;&lt;/span&gt;        &lt;span class="icon-loading"&gt;&lt;/span&gt;        &lt;span class="addimage"&gt;添加图片&lt;/span&gt;    &lt;/div&gt;&lt;/div&gt;&lt;div class="form-group"&gt;    &lt;div class="col-sm-offset-2 col-sm-9"&gt;        &lt;div class="pictures"&gt;            &lt;!--动态插入图片--&gt;        &lt;/div&gt;    &lt;/div&gt;&lt;/div&gt;

js$('.icon-picture').click(function()&#123;    $('#picture').click();    $('#picture').unbind().on('change',function()&#123;        var fileNumber = $('#picture').get(0).files.length;        if(fileNumber==0)&#123;            return;        &#125;        var file = $('#picture').get(0).files[0];        console.log(file);        var fileReader = new FileReader();        fileReader.readAsDataURL(file);        fileReader.onload = function(e) &#123;//            var fileType = file.name.substring(file.name.lastIndexOf('.'), file.name.length);//            var now = new Date();//            var fileName = now.getTime() + 'langting' + parseInt(Math.random() * 20) + fileType;            $(".addimage").text("上传中...");            $('.icon-picture').hide();            $('.icon-loading').css(&#123;                'display': 'inline-block'            &#125;);            $.ajax(&#123;                type: 'POST',                dataType: 'json',                url: '/qn-upload',                data: &#123;                    imageData: e.target.result                &#125;,                success: function(data) &#123;                    if (data.state == true) &#123;                        setTimeout(function() &#123;                            $(".addimage").text("添加图片");                            $('.icon-loading').hide();                            $('.icon-picture').show();                            var html = template('pic_template',data);                            $('.pictures').append(html);                        &#125;, 1500);                    &#125; else &#123;                        alert("上传失败");                    &#125;                &#125;,                error: function()&#123;                &#125;            &#125;);        &#125;    &#125;);&#125;);// 删除图片$('.pictures').on('click','.icon-delete',function()&#123;    $(this).parents('.pic').remove();&#125;);

Node端exports.qn_upload = function(req,res)&#123;    var qn = require('qn');    var client = qn.create(&#123;        accessKey: 'JEBuh6qG9FPI6atoycgdoypwOZJWuzYk1YXnC-6c',        secretKey: 'IBAa_7Mkj2_ROefIRcwVjcVEK9PVFDvzrtPiL9nO',        bucket: 'forum',        domain: 'http://7xstti.com2.z0.glb.clouddn.com'    &#125;);    var imageData = req.body.imageData;    var key = uuid.v1();    imageData = imageData.replace(/^data:image\/\w+;base64,/, "");    var dataBuffer = new Buffer(imageData, 'base64');    client.upload(dataBuffer, &#123;        key: key    &#125;, function(err, result) &#123;        if (err) &#123;            res.json(&#123;                state: false,                imgname: imageName,                imgurl: "",                imghash: ""            &#125;);        &#125; else &#123;            res.json(&#123;                state: true,                imgname: result.key,                imgurl: result.url,                imghash: result.hash            &#125;);        &#125;    &#125;);&#125;

源码https://github.com/voidking/nodeforum/blob/master/views/post/post-add.htmlhttps://github.com/voidking/nodeforum/blob/master/public/js/post/post-add.jshttps://github.com/voidking/nodeforum/blob/master/controllers/post.js
后记上传的交互过程，是前端把图片数据传给Node端，Node端转发图片数据到七牛服务器。七牛服务器返回结果数据给Node端，Node端转发结果数据给前端。
这个过程比较麻烦，更好的做法，是前端能够直接把图片数据传给七牛服务器，七牛服务器返回结果给前端。按照七牛给的文档，是可以实现的，感兴趣的小伙伴请研读七牛的《JavaScript SDK使用指南》。
书签七牛开发者中心http://developer.qiniu.com/
JavaScript SDK使用指南http://developer.qiniu.com/code/v6/sdk/javascript.html
七牛 Node.js SDKhttps://www.npmjs.com/package/node-qiniu
File对象上传图片（nodejs版）http://www.html-js.com/article/NodejsDemoDemo-go
图片上传时input file change事件多次触发解决http://www.aichengxu.com/view/78921
用js获取上传前图片的宽高http://bbs.csdn.net/topics/390768571
HTML5 之文件操作(file)http://blog.csdn.net/oscar999/article/details/37499743
Using files from web applicationshttps://developer.mozilla.org/en-US/docs/Using_files_from_web_applications
图片基本处理 (imageView2)http://developer.qiniu.com/code/v6/api/kodo-api/image/imageview2.html
保存裁剪后的图片的疑问https://segmentfault.com/q/1010000003892579
base64百度百科
好文推荐：移动端图片格式调研http://www.cocoachina.com/ios/20151201/14478.html
Pluploadhttp://www.plupload.com/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>响应式布局</title>
    <url>/dev-graduation-project-responsive-layout/</url>
    <content><![CDATA[前言响应式布局，简单来说，就是利用CSS3的Media Query（媒介查询），来探测访问系统的终端的宽和高等属性，并以此来决定给用户展示什么样的页面。
毕设的社区网站系统设计了两套UI，以768px为两种UI的分割点。


界面展示
sass/* 超小屏幕（手机，小于 768px） */@media (max-width: 767px) &#123;&#125;/* 小屏幕（平板，大于等于 768px） */@media (min-width: 768px) &#123;&#125;

源码：https://github.com/voidking/nodeforum/blob/master/public/scss/partial/header.scss
书签Bootstrap v3中文文档http://v3.bootcss.com/getting-started/#examples
Bootstrap中文网开源项目免费 CDN 服务http://www.bootcdn.cn/
20分钟打造你的Bootstrap站点http://www.w3cplus.com/css/twitter-bootstrap-tutorial.html
程序员们最爱的12款Bootstrap模板 ！http://www.chinaz.com/free/2014/0924/368583.shtml
15个好看的Bootstrap HTML网站模板下载http://www.shejidaren.com/bootstrap-mo-ban.html
折腾响应式布局设计http://caibaojian.com/356.html
响应式设计的性能优化http://www.jianshu.com/p/193911ee72e2
Bootstrap File Input Demohttp://plugins.krajee.com/file-basic-usage-demo
彻底弄懂css中单位px和em,rem的区别http://www.cnblogs.com/leejersey/p/3662612.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Socket.IO实现实时私信功能</title>
    <url>/dev-graduation-project-socketio/</url>
    <content><![CDATA[功能描述在帖子详情页面，单击用户头像，可以发送私信给该用户。在消息页面，输入用户名，可以发送私信给该用户。如果该用户在线，则把私信实时发送给该用户，如果该用户不在线，则把私信存储到数据库，成为消息记录。


原理WebSocket protocol 是HTML5一种新的协议。使用WebSocket API，浏览器和服务器只需要做一个握手的动作，就形成了一条快速通道。借助这个通道，浏览器和服务器之间就可以互相传送数据。
Socket.IO是一个完全由JavaScript实现、基于Node.js、支持WebSocket的协议用于实时通信、跨平台的开源框架，它包括了浏览器端的JavaScript和服务器端的Node.js。 Socket.IO除了支持WebSocket通讯协议外，还支持许多种轮询（Polling）机制以及其它实时通信方式，并封装成了通用的接口，并且在服务端实现了这些实时机制的相应代码。
页面初始化时，浏览器和服务端建立一个连接，用来发送事件和接收事件。浏览器和服务端建立连接后，服务端会触发一个“adduser”事件，把当前用户添加到在线用户列表中。当用户离开页面时，会触发一个“deleteuser”事件，把当前用户从在线用户列表中删除。用户A发私信给用户B时，服务端接收到“privatemsg”事件，会把该信息存储到数据库。同时，如果用户B在线，则触发用户B的浏览器的“sendback”事件，把信息发送给用户B的浏览器。用户B的浏览器接收到“sendback”事件，说明收到了新的消息，该消息实时插入到聊天对话框。
代码js// 即时通讯// 建立连接var socket = io.connect();var from_user = $('#from-user').val();socket.emit("adduser",from_user,function(data)&#123;    console.log(data);&#125;);// 发送消息var from_user = $('#from-user').val();var to_user = friend_id;var content = $('#chat .reply-content').val();var data = &#123;    from_user: from_user,    to_user: to_user,    content: content&#125;;socket.emit("privatemsg",data,function(data)&#123;    console.log(data);&#125;);// 接受消息socket.on("sendback",function(data)&#123;    console.log(data);&#125;);// 断开连接window.onunload = function()&#123;    console.log('删除用户');    var from_user = $('#from-user').val();    socket.emit('deleteuser',from_user,function(data)&#123;        console.log(data);    &#125;);&#125;


Node端var User = require('./models/user-model');var Message = require('./models/message-model');var FriendCollect = require('./models/friend-collect-model');//var mongoose = require('mongoose');//mongoose.connect('mongodb://localhost/forum');var users = &#123;&#125;;var socket_event = function(socket) &#123;    socket.on('disconnect', function () &#123;        //console.log('user disconnected');    &#125;);    socket.on("adduser", function (from_user, callback) &#123;        if (from_user in users) &#123;            users[from_user] = socket;            callback(true);        &#125; else &#123;            socket.user_id = from_user;            users[socket.user_id] = socket;            callback(true);        &#125;    &#125;);    socket.on('deleteuser', function (from_user, callback) &#123;        if (from_user in users) &#123;            delete users[from_user];            callback(true);        &#125;    &#125;);    socket.on("privatemsg", function (data, callback) &#123;        var param = &#123;            from_user: data.from_user,            to_user: data.to_user,            content: data.content        &#125;;        var message = new Message(param);        message.save();        if (data.to_user in users) &#123;            User.findById(data.from_user,function(err,user)&#123;                users[data.to_user].emit('sendback', &#123;'content': data.content,'friend':user&#125;);                callback(true);            &#125;);        &#125; else &#123;            callback('对方未登录，已留言');        &#125;    &#125;);&#125;module.exports = socket_event;

源码https://github.com/voidking/nodeforum/blob/master/views/message/message.htmlhttps://github.com/voidking/nodeforum/blob/master/public/js/message/message.jshttps://github.com/voidking/nodeforum/blob/master/app.jshttps://github.com/voidking/nodeforum/blob/master/socket-event.js
参考文档Socket.IO官网http://socket.io/
Socke.IO项目地址https://github.com/socketio/socket.io
在线聊天Demohttp://chat.socket.io/http://socket.io/get-started/chat/
Socket.IO APIhttp://socket.io/docs/
Nodejs Socket.io 发送私信http://www.jenkihuang.com/job/2015/10/nodejs-socket-io-privatemsg.html
Socket.IO 和 Node.js 入门http://www.oschina.net/question/12_54009/?fromerr=pCDquuQy
Socket.io:有点意思http://www.cnblogs.com/edwardstudy/p/4358202.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>node</tag>
        <tag>socketio</tag>
      </tags>
  </entry>
  <entry>
    <title>毕业设计开始</title>
    <url>/dev-graduation-project-start/</url>
    <content><![CDATA[前言前前后后，投了有三十家公司了。然而，唯一的面试通知，居然听不到声音，回电也打不通。。。貌似，回家前很难找到工作了。没有工作，就专心做毕设，有个作品对找工作也有帮助。


毕设选题想了很久，最终决定，做一个社区网站系统。主要有注册、登陆、发帖、回帖、关注、收藏、@、私信、分享、个人信息管理、系统管理等功能，参考 http://named.cn/.mine
技术架构用的最熟练的是Java，但是，这一次，郝同学决定使用不够熟练的技术——Node.js。因为，这是我未来想要深入发展的方向——前端！
这个项目可能用到的技术和框架有：Node.js、Express、EJS、Bootstrap、MongoDB。
开发工具：Webstorm
后记从今天开始，记录下做毕设的点点滴滴。同时，本项目开源，希望能够对其他小伙伴有所帮助。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>毕设</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>H5跳转微信公众平台</title>
    <url>/dev-h5-jump-wechat-public-platform/</url>
    <content><![CDATA[微信公众平台发布了一篇文章，单击公众平台名称，能够直接跳转到微信公众平台的关注页面。就像这样：



请问，如果我们自己写了一篇文章，不是发布在微信公众平台上，能不能跳转到微信公众平台关注页面呢？答案是，不能，但是我们有替代方案。
显然，这样关注也是很方便的，关键点在于“艾佳生活志”的链接怎么搞出来。有个网站贴心的给出了方案：微信公众号一键关注页面生成器。将公众号发过的图文链接粘贴进去，点击生成即可得到我们需要的链接。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>artTemplate模板引擎</title>
    <url>/dev-arttemplate/</url>
    <content><![CDATA[前言在开发过程中，常常要实现这样一种效果：获取数据，并且插入到当前页面。最基本的做法是把获取到的数据拼接到一个字符串中，然后使用html()或者append()函数插入到页面中。这种做法，拼接字符串时很麻烦。本文中，郝同学要介绍一下ArtTemplate，一个超快的前端模板引擎。


快速上手编写模板&lt;script id="test" type="text/html"&gt;&lt;h1&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;&lt;ul&gt;    &#123;&#123;each list as value i&#125;&#125;        &lt;li&gt;索引 &#123;&#123;i + 1&#125;&#125; ：&#123;&#123;value&#125;&#125;&lt;/li&gt;    &#123;&#123;/each&#125;&#125;&lt;/ul&gt;&lt;/script&gt;

渲染模板var data = &#123;    title: '标签',    list: ['文艺', '博客', '摄影', '电影', '民谣', '旅行', '吉他']&#125;;var html = template('test', data);document.getElementById('content').innerHTML = html;

模板语法注意：简洁语法和原生语法引入的js文件不同。
简洁语法&#123;&#123;if admin&#125;&#125;    &#123;&#123;include 'admin_content'&#125;&#125;    &#123;&#123;each list&#125;&#125;        &lt;div&gt;&#123;&#123;$index&#125;&#125;. &#123;&#123;$value.user&#125;&#125;&lt;/div&gt;    &#123;&#123;/each&#125;&#125;&#123;&#123;/if&#125;&#125;

原生语法&lt;%if (admin)&#123;%&gt;    &lt;%include('admin_content')%&gt;    &lt;%for (var i=0;i&lt;list.length;i++) &#123;%&gt;        &lt;div&gt;&lt;%=i%&gt;. &lt;%=list[i].user%&gt;&lt;/div&gt;    &lt;%&#125;%&gt;&lt;%&#125;%&gt;

参考文档Arttemplate by auihttp://aui.github.io/artTemplate/
前端模版artTemplate的介绍及使用http://blog.csdn.net/playboyanta123/article/details/45536501
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>基于JQuery实现滚动到页面底端时自动加载更多信息</title>
    <url>/dev-auto-loading-when-scroll-to-the-bottom/</url>
    <content><![CDATA[这篇文章主要介绍了基于JQuery实现滚动到页面底端时自动加载更多信息，类似微博，新浪新闻的评论等，都采用了这方法,需要的朋友可以参考下关键代码：
var stop=true; $(window).scroll(function()&#123;     totalheight = parseFloat($(window).height()) + parseFloat($(window).scrollTop());     if($(document).height() &lt;= totalheight)&#123;         if(stop==true)&#123;             stop=false;             $.post("ajax.php", &#123;start:1, n:50&#125;,function(txt)&#123;                 $("#Loading").before(txt);                 stop=true;             &#125;,"text");         &#125;     &#125; &#125;);



HTML代码如下:
&lt;div id="Loading"&gt;Loading...&lt;/div&gt;

实现方法是比较页面总高度和下滚高度以判断是否到达底端，若到达底端则通过ajax读取更多的内容，用before插入到Loading之前。stop参数是考虑到ajax读取耗时，防止在一次ajax读取过程中多次触发事件，造成多次加载内容。
转载自http://www.3lian.com/edu/2014/02-10/127916.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>Axure入门篇</title>
    <url>/dev-axure-start/</url>
    <content><![CDATA[前言寒假，打算做一个自己使用的安卓app。那就学习安卓吧？这个是必须的，但是首先，我要明确需求。说的通俗一点，我要先明确一下，完成后的产品大概是什么样子。
用软件工程的思想来解释，就是使用原型开发方法。利用快速开发工具构建一个系统原型，以便分析用户需求和界面需求。
而Axure，就是一个快速开发工具。一周左右，利用Axure完成了自己的原型设计，在此总结一下。
Axure入门这款软件的界面如下：
菜单栏和工具栏不多解释，会使用word，这两栏一看就懂。


页面导航页面的目录，方便我们找到页面。
工作区每个页面对应一个工作区，我们在工作区进行设计。
组件组件是我们进行设计的“原料”。和做菜一样，各种原料经过处理成为一道菜，各种组件经过组合成为一个页面。
母版假设每个页面都有一个logo，上面写着“voidking”。等到完成之后，突然觉得不合适，想改成“帅哥”，这时候工作量太大了！
那么怎么避免这个问题？很简单，把这个logo作为母版！只要修改了母版，那么，所有使用了这个母版的页面，logo内容都会被修改。
页面交互举个例子，我们想要某个页面一闪而过。也就是说，不需要用户对这个页面进行任何操作，就跳转到下一个页面。这时候，就需要在页面交互这里进行设置。
组件交互举个例子，我们想要通过单击操作跳转到另一个页面。这个时候，就需要在组件交互这里这里进行设置。
Axure实践细致程度细致程度分为草图、低保真原型、高保真原型。这次原型设计，只是做了一个低保真原型。
额外技能首先，你要学会PS。否则，你会发现，寸步难行！其次，你要学会寻找资源。无论是安卓组件，还是需要的图片素材，都是需要寻找的。所以，学会使用搜索引擎，受益一生。最后，你要学会学习。在做原型的过程中，肯定有某些功能，你不知道如何实现，这时候，就需要你去学习。
部分成果不要认为自己不会，大胆去使用吧，用不了几个小时，你就会掌握这款工具。具体操作过程省略，给大家展示几张图片。
Axure高级应用学会使用Axure很简单，但是，要实现某些细节的效果（高保真原型），就需要高级的技巧了。比如完全模拟iPhone发送短信的过程，比如完全模拟微信聊天的过程等等。高级的内容，还没有学习。给大家推荐几个学习教程：网易云课堂Axure教程系列多贝公开课Axure教程系列《Axure快速原型设计》，提取码 f77c
小结类似Axure这样的工具有很多，重要的不是学会使用Axure，而是掌握设计的思路。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>axure</tag>
      </tags>
  </entry>
  <entry>
    <title>在CentOS7上安装Hadoop和Hive</title>
    <url>/dev-hadoop-hive-on-centos/</url>
    <content><![CDATA[前言《在Ubuntu16.04上安装Hadoop》一文中，我们已经学习了在Ubuntu中安装Hadoop，因为作业需要，郝同学要在CentOS上也安装Hadoop。同时，还要安装Hive。


安装Hadoop首先参考《全平台安装JDK》，安装配置JDK，然后按照下面的流程安装Hadoop。
1、下载解压
wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gzmv hadoop-1.2.1.tar.gz /opt/cd /opt/tar -zxvf hadoop-1.2.1.tar.gz

2、修改hadoop-env.sh
cd hadoop-1.2.1/conf/vim hadoop-env.sh

主要修改JAVA_HOME如下：
# The java implementation to use.  Required.export JAVA_HOME=/usr/lib/jvm/java-1.8.0

3、修改core-site.xml，内容如下：
&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;/hadoop&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;dfs.name.dir&lt;/name&gt;        &lt;value&gt;/hadoop/name&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;fs.default.name&lt;/name&gt;        &lt;value&gt;hdfs://master:9000&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;

4、修改hdfs-site.xml，内容如下：
&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;dfs.data.dir&lt;/name&gt;        &lt;value&gt;/hadoop/data&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;

5、修改mapred-site.xml，内容如下：
&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;mapred.job.tracker&lt;/name&gt;        &lt;value&gt;master:9001&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;

6、修改/etc/profile，修改PATH如下：
export HADOOP_HOME=/opt/hadoop-1.2.1export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$HADOOP_HOME/bin:$PATH

生效，source /etc/profile。
7、测试，hadoop，如果出现COMMAND提示，则表明安装配置成功。
8、在第7步测试时，出现“Warning: $HADOOP_HOME is deprecated.”，这是因为新版的hadoop废弃掉了HADOOP_HOME这个变量。若要除去这个警告，要么换用HADOOP_PREFIX，要么在hadoop-env.sh添加一句：
export HADOOP_HOME_WARN_SUPPRESS=1

9、namenode格式化，hadoop namenode -format。
10、启动hadoop，cd /opt/hadoop-1.2.1/bin，start-all.sh。
11、查看hadoop下有哪些文件，hadoop fs -ls /。
12、关闭hadoop，stop-all.sh
配置Mysql1、假设已经安装好了mysql，版本为5.6.29。
2、新建hive数据库，用来保存hive的元数据
create database hive;alter database hive character set latin1;

3、将hive数据库下的所有表的所有权限赋给hadoop用户，并配置mysql为hive-site.xml中的连接密码，然后刷新系统权限关系表。
create user 'hadoop'@'%' identified by 'mysql';grant all privileges on  *.* to 'hadoop'@'%' with grant option;flush privileges;

安装Hive1、下载解压hive
cd /optwget http://mirror.bit.edu.cn/apache/hive/hive-1.2.2/apache-hive-1.2.2-bin.tar.gztar -zxvf apache-hive-1.2.2-bin.tar.gz


2、配置HIVE_HOME，vim /etc/profile，在最后添加
export HIVE_HOME=/opt/apache-hive-1.2.2-binexport PATH=$HIVE_HOME/bin:$PATH
立即生效，source /etc/profile
3、修改hive-site.xml文件
cd /opt/apache-hive-1.2.2-bin/conf/cp hive-default.xml.template hive-site.xml  vim hive-site.xml
/ConnectionURL，找到ConnectionURL，修改为：
&lt;property&gt;  &lt;name&gt;javax.jdo.option.ConnectionURL&lt;/name&gt;  &lt;value&gt;jdbc:mysql://localhost:3306/hive?createDatabaseIfNotExist=true&lt;/value&gt;  &lt;description&gt;JDBC connect string for a JDBC metastore&lt;/description&gt;&lt;/property&gt;&lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionDriverName&lt;/name&gt;    &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt;  &lt;/property&gt;&lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionUserName&lt;/name&gt;    &lt;value&gt;hadoop&lt;/value&gt;  &lt;/property&gt;     &lt;property&gt;    &lt;name&gt;javax.jdo.option.ConnectionPassword&lt;/name&gt;    &lt;value&gt;mysql&lt;/value&gt;  &lt;/property&gt;&lt;property&gt;  &lt;name&gt;hive.support.sql11.reserved.keywords&lt;/name&gt;  &lt;value&gt;false&lt;/value&gt;  &lt;description&gt;    This flag should be set to true to enable support for SQL2011 reserved keywords.    The default value is true.  &lt;/description&gt;&lt;/property&gt;

4、下载配置mysql-connector-java
wget http://www.java2s.com/Code/JarDownload/mysql/mysql-connector-java-5.1.22-bin.jar.zipunzip mysql-connector-java-5.1.22-bin.jar.zipmv mysql-connector-java-5.1.22-bin.jar /opt/apache-hive-1.2.2-bin/lib

5、修改hive-env.sh文件
cp hive-env.sh.template  hive-env.shvi  hive-env.sh
修改为：
# Set HADOOP_HOME to point to a specific hadoop install directoryHADOOP_HOME=/opt/hadoop-1.2.1

6、启动hadoop,cd /opt/hadoop-1.2.1/bin，start-all.sh。
7、启动metastore，nohup hive --service metastore &gt; metastore.log 2&gt;&amp;1 &amp;
8、启动hive，hive报错：The root scratch dir: /tmp/hive on HDFS should be writable.
mkdir /tmp/hivechmod -R 777 /tmp/hivehadoop fs -chmod -R 777 /tmp/hive

再次启动，报错：Relative path in absolute URI: ${system:java.io.tmpdir%7D/$%7Bsystem:user.name%7D新建tmpdir文件夹
mkdir /tmp/tmpdirchmod -R 777 /tmp/tmpdirhadoop fs -mkdir /tmp/tmpdirhadoop fs -chmod -R 777 /tmp/tmpdir

在hive-site.xml中，查找所有的${system:java.io.tmpdir} 和 ${system:java.io.tmpdir}/${system:user.name}，替换为/tmp/tmpdir
再次启动，成功！
书签hive2.1.1安装部署
Hive安装与配置
Hive集成mysql数据库
Hive安装配置指北（含Hive Metastore详解）
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title>在Ubuntu16.04上安装Hadoop</title>
    <url>/dev-hadoop-on-ubuntu/</url>
    <content><![CDATA[前言专业方向，选择了大数据，那就在这方面深入研究一下。什么是大数据？正如字面意思，大量的数据。举个例子，Mysql的一张表里存了1万条数据，查询没问题；100万条数据，查询也没问题；那么，1亿条数据？100亿条数据？更大的数据？

大数据科学家JohnRauser提到一个简单的定义：大数据就是任何超过了一台计算机处理能力的庞大数据量。

为了处理大量的数据，我们必须找到更好的办法。谷歌经过研究，发表了一些关于大数据解决方案的论文，涉及MapReduce、BigTable、GFS等。但是，谷歌开发的大数据处理平台，并没有开源。一些勤奋的同学根据谷歌发表的论文，搞出了Hadoop平台，后来成为一个主流的大数据处理平台，也就是接下来一段时间郝同学要学习的平台。


大数据分析1、可视化分析大数据分析的使用者有大数据分析专家，同时还有普通用户，但是他们二者对于大数据分析最基本的要求就是可视化分析，因为可视化分析能够直观的呈现大数据特点，同时能够非常容易被读者所接受，就如同看图说话一样简单明了。
2、数据挖掘算法大数据分析的理论核心就是数据挖掘算法，各种数据挖掘的算法基于不同的数据类型和格式才能更加科学的呈现出数据本身具备的特点，也正是因为这些被全世界统计学家所公认的各种统计方法（可以称之为真理）才能深入数据内部，挖掘出公认的价值。另外一个方面也是因为有这些数据挖掘的算法才能更快速的处理大数据，如果一个算法得花上好几年才能得出结论，那大数据的价值也就无从说起了。
3、预测性分析能力大数据分析最终要的应用领域之一就是预测性分析，从大数据中挖掘出特点，通过科学的建立模型，之后便可以通过模型带入新的数据，从而预测未来的数据。
4、数据质量和数据管理大数据分析离不开数据质量和数据管理，高质量的数据和有效的数据管理，无论是在学术研究还是在商业应用领域，都能够保证分析结果的真实和有价值。
好了，废话到此结束，下面开始本文重点。
安装步骤安装JDK直接安装jdk7，会提示E: Invalid operation openjdk-7-jdk。所以，要先更新安装源。
add-apt-repository ppa:openjdk-r/ppa  apt-get update   apt-get install openjdk-7-jdk

安装好之后，javac，测试安装是否成功。
配置JAVA_HOME和JRE_HOME，vim /etc/profile，添加：
export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH
然后使配置文件生效，source /etc/profile。
安装Hadoop慕课教程中选择安装1.2.1，虽然有点老，但是学习足够了，郝同学也安装这一版，方便接下来的学习。
1、下载解压
wget http://mirror.bit.edu.cn/apache/hadoop/common/hadoop-1.2.1/hadoop-1.2.1.tar.gzmv hadoop-1.2.1.tar.gz /opt/cd /opt/tar -zxvf hadoop-1.2.1.tar.gz

2、修改hadoop-env.sh
cd hadoop-1.2.1/conf/vim hadoop-env.sh

主要修改JAVA_HOME如下：
# The java implementation to use.  Required.export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64

3、修改core-site.xml，内容如下：
&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;hadoop.tmp.dir&lt;/name&gt;        &lt;value&gt;/hadoop&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;dfs.name.dir&lt;/name&gt;        &lt;value&gt;/hadoop/name&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;fs.default.name&lt;/name&gt;        &lt;value&gt;hdfs://localhost:9000&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;

4、修改hdfs-site.xml，内容如下：
&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;dfs.data.dir&lt;/name&gt;        &lt;value&gt;/hadoop/data&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;

5、修改mapred-site.xml，内容如下：
&lt;?xml version="1.0"?&gt;&lt;?xml-stylesheet type="text/xsl" href="configuration.xsl"?&gt;&lt;!-- Put site-specific property overrides in this file. --&gt;&lt;configuration&gt;    &lt;property&gt;        &lt;name&gt;mapred.job.tracker&lt;/name&gt;        &lt;value&gt;localhost:9001&lt;/value&gt;    &lt;/property&gt;&lt;/configuration&gt;

6、修改/etc/profile，修改PATH如下：
export HADOOP_HOME=/opt/hadoop-1.2.1export PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$HADOOP_HOME/bin:$PATH

生效，source /etc/profile。
7、测试，hadoop，如果出现COMMAND提示，则表明安装配置成功。
8、在第7步测试时，出现“Warning: $HADOOP_HOME is deprecated.”，这是因为新版的hadoop废弃掉了HADOOP_HOME这个变量。若要除去这个警告，要么换用HADOOP_PREFIX，要么在hadoop-env.sh添加一句：
export HADOOP_HOME_WARN_SUPPRESS=1

9、namenode格式化，hadoop namenode -format。
10、启动hadoop，start-all.sh。
11、检查是否启动成功，jps。如果看到下图的进程，则表明启动成功。
12、查看hadoop下有哪些文件，hadoop fs -ls /。
后记至此，hadoop环境安装配置完成，接下里可以愉快地进行大数据分析了！
书签Hadoop大数据平台架构与实践–基础篇http://www.imooc.com/learn/391
阿里云大数据教程：https://yq.aliyun.com/edu/lessonTagSearch/cid_695-tagid_14065?spm=5176.8142029.388261.235.rtkpxj
云计算从入门到实践：https://yq.aliyun.com/edu/lessonTagSearch/cid_14061-tagid_15114?spm=5176.100242.0.0.fU7F9h
什么是大数据？https://www.zhihu.com/question/23896161
Warning: $HADOOP_HOME is deprecated.的原因以及解决方法。http://blog.csdn.net/jsj568261496/article/details/10175209
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>java</tag>
        <tag>ubuntu</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Hadoop单词计数</title>
    <url>/dev-hadoop-wordcount/</url>
    <content><![CDATA[前言上文中，已经搭建好了hadoop平台。接下来，郝同学利用hadoop来实现单词的计数的功能，视频教程参见慕课网Kit_Ren同学的《Hadoop大数据平台架构与实践——基础篇》。
要求：计算文件中出现每个单词的频数，输入结果按照字母顺序进行排序。输入：
hello world bye worldhello hadoop bye hadoopbye hadoop hello hadoop
输出：
bye     3hello   3hadoop  4world   2



MapReduce过程
编译打包和运行代码从Kit_Ren同学那里下载，没有做修改。
视频教程中，代码是在ubuntu下编译运行的。郝同学打算把编译打包过程放在本地，运行放在ubuntu。
1、首先，使用xftp，把ubuntu中/opt/hadoop-1.2.1文件夹下和/opt/hadoop-1.2.1/lib文件夹下所有的jar包拷贝到本地。
2、引入jar包后，运行代码，失败，“Exception in thread “main” java.lang.ArrayIndexOutOfBoundsException: 0”。这时，到java项目的bin文件夹下寻找WordCount.class、WordCount$WordCountMap.class、WordCount$Reduce.class。
3、打包三个.class文件为一个jar文件，jar -cvf wordcount.jar *.class。
4、拷贝第3步中的wordcount.jar文件到ubuntu的任意文件夹，假设为/home/voidking/hadoop。
5、在/home/voidking/hadoop中新建两个文件，file1和file2，内容分别为：
hello world bye worldhello hadoop bye hadoopbye hadoop hello hadoop

hello world bye worldsystem hello hadoop

6、把file1和file2放到hdfs中，hadoop fs -mkdir wordcount_input，hadoop fs -put file* wordcount_input/。
7、执行jar包，hadoop jar wordcount.jar WordCount wordcount_input wordcount_output。
至此，理论上应该成功，但是报错了。Exception in thread “main” java.lang.UnsupportedClassVersionError: WordCount : Unsupported major.minor version 52.0

也许是因为本机是java1.8，而ubuntu是java1.7。好吧，重来，完全按照视频教程。
1、上传WordCount.java文件到ubuntu的/home/voidking/hadoop文件夹。
2、编译java文件，javac -classpath /opt/hadoop-1.2.1/hadoop-core-1.2.1.jar:/opt/hadoop-1.2.1/lib/commons-cli-1.2.jar WordCount.java
3、打包三个.class文件为一个jar文件，jar -cvf wordcount.jar *.class。
4、在/home/voidking/hadoop中新建两个文件，file1和file2，内容同上。
5、把file1和file2放到hdfs中，hadoop fs -mkdir wordcount_input，hadoop fs -put file* wordcount_input/。
6、执行jar包，hadoop jar wordcount.jar WordCount wordcount_input wordcount_output。
7、查看结果，hadoop fs -ls wordcount_output，hadoop fs -cat wordcount_output/part-r-00000。
源码分享https://github.com/voidking/hadoop-start.git
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>Harbor入门篇</title>
    <url>/dev-harbor-start/</url>
    <content><![CDATA[Harbor简介
Harbor is an open source container image registry that secures images with role-based access control, scans images for vulnerabilities, and signs images as trusted. As a CNCF Incubating project, Harbor delivers compliance, performance, and interoperability to help you consistently and securely manage images across cloud native compute platforms like Kubernetes and Docker.

更多内容参考Harbor官网。


安装Harbor前置条件参考Harbor Installation Prerequisites
1、硬件需求硬件最小需求：2C4G40G。硬件推荐需求：4C8G160G。
2、软件需求Docker engine，Version 17.06.0-ce+ or higherDocker Compose，Version 1.18.0 or higherOpenssl，Latest is preferred
3、网络端口444、4443和80
下载安装Harbor1、访问Harbor releases page，下载需要的harbor版本，这里选择下载 harbor-offline-installer-v1.10.1.tgz
或者使用curl命令下载：
curl -C - -O -L https://github.com/goharbor/harbor/releases/download/v1.10.1/harbor-offline-installer-v1.10.1.tgz

2、解压
tar -xzvf harbor-offline-installer-v1.10.1.tgzcd harbor

3、配置harbor.yml安装前修改harbor.yaml，参考Configure the Harbor YML File，按需要修改如下几个字段：
# The IP address or hostname to access admin UI and registry service.# DO NOT use localhost or 127.0.0.1, because Harbor needs to be accessed by external clients.hostname: harbor.voidking.com# http related confighttp:  # port for http, default is 80. If https enabled, this port will redirect to https port  port: 80# https related config# https:  # https port for harbor, default is 443  #port: 443  # The path of cert and key files for nginx  #certificate: /your/certificate/path  #private_key: /your/private/key/path# The initial password of Harbor admin# It only works in first time to install harbor# Remember Change the admin password from UI after launching Harbor.harbor_admin_password: Harbor12345# The default data volumedata_volume: /data# Harbor DB configurationdatabase:  # The password for the root user of Harbor DB. Change this before any production use.  password: root123  # The maximum number of connections in the idle connection pool. If it &lt;=0, no idle connections are retained.  max_idle_conns: 50  # The maximum number of open connections to the database. If it &lt;= 0, then there is no limit on the number of open connections.  # Note: the default number of connections is 100 for postgres.  max_open_conns: 100# Log configurationslog:  # options are debug, info, warning, error, fatal  level: info  # configs for logs in local storage  local:    # Log files are rotated log_rotate_count times before being removed. If count is 0, old versions are removed rather than rotated.    rotate_count: 50    # Log files are rotated only if they grow bigger than log_rotate_size bytes. If size is followed by k, the size is assumed to be in kilobytes.    # If the M is used, the size is in megabytes, and if G is used, the size is in gigabytes. So size 100, size 100k, size 100M and size 100G    # are all valid.    rotate_size: 200M    # The directory on your host that store log    location: /var/log/harbor

4、执行安装./install.sh如果安装完成发现配置错误，可以修改配置后再次执行脚本。如果报错 ERROR: Failed to Setup IP tables: Unable to enable SKIP DNAT rule ，那么重启docker后再次执行脚本。
至此，harbor安装完成，没有配置https。
验证安装浏览器验证浏览器访问 http://192.168.56.200 ，可以看到harbor登录页面。输入用户名密码，admin和Harbor12345，登录harbor控制台。
命令行验证docker psdocker login 192.168.56.200

输入用户名密码，admin和Harbor12345，登录报错：Error response from daemon: Get https://192.168.56.200/v2/: dial tcp 192.168.56.200:443: connect: connection refused。
这是因为，docker1.3.x之后与registry交互，默认使用https协议。修改/etc/docker/daemon.json，添加insecure-registries参数：
&#123;  "registry-mirrors": [    "https://mirror.ccs.tencentyun.com"  ],  "insecure-registries": [    "http://192.168.56.200",    "http://harbor.voidking.com"  ]&#125;
然后重启docker：
systemctl daemon-reloadsystemctl restart docker
重新登录，成功。
使用启动和停止1、停止docker-compose down -v
2、修改配置修改harbor.yml后，执行./prepare
3、启动docker-compose up -d
上传镜像docker pull busybox:1.31docker tag busybox:1.31 harbor.voidking.com/voidking/busybox:1.31docker tag busybox:1.31 harbor.voidking.com/voidking/subpath/busybox:1.31docker push harbor.voidking.com/voidking/busybox:1.31
报错：The push refers to repository [harbor.voidking.com/voidking/busybox]a6d503001157: Preparingdenied: requested access to the resource is denied
这是因为，需要先创建项目。在web控制台创建项目 voidking，再次上传，成功。带有subpath的镜像，同样可以上传成功。
下载镜像docker pull harbor.voidking.com/voidking/busybox:1.31

高可用如果搭建高可用harbor，比如搭建两个实例的harbor，那么需要XSRFKey保持一致，在 common/config/core/app.conf 中配置。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>HBuilder Android真机调试</title>
    <url>/dev-hbuilder-android-debug/</url>
    <content><![CDATA[关于调试难者不会，会者不难。对于调试，这句话尤其合适。无论是前端调试、Java调试、PHP调试、Python调试，还是我们这次要研究的HBuilder Android真机调试，都是一个道理。欲速则不达，磨刀不误砍柴工。花点时间，磨一磨调试这把刀。


环境准备1、安装好Hbuilder。
2、安装好chrome。
3、电脑安装好360手机助手。
4、Android手机和连接线。
启动调试模式以魅族pro6s和荣耀6为例。
魅族pro6s1、设置，关于手机，在“版本号”的项目栏里，连续点击7次，就会提示开启开发人员选项。
2、回到设置界面，辅助功能，点进去即可看到“开发人员选项”，进入“开发人员选项”就可以打开“USB调试”了。
3、在开发人员选项界面中，下拉到最后，性能优化，高级日志输出，选择全部允许。
至此，魅族pro6s调试模式启动成功。然而，郝同学在调试时，可以启动应用，但是无法使用console.log()。
在拨号页，输入*#*#3646633#*#*，进入工程模式，侧滑到Log and Debugging，Debug Utils，调试等级调成Engineer Mode。然而，并没有什么用处。
备份HBuilder\tools\adbs中的adb.exe、AdbWinApi.dll、AdbWinUsbApi.dll，然后复制HBuilder\tools\adbs\1.0.31中的所有文件，粘贴到HBuilder\tools\adbs目录中。然而，也没有什么用处。
好吧，我的魅族pro6s有个坑，遂弃用。。。
荣耀61、设置，关于手机，在“版本号”的项目栏里，连续点击7次，就会提示进入开发者模式；
2、回到设置界面，下拉即可看到“开发人员选项”。
3、点击开发人员选项界面里，点击开发人员选项后面的滑块，即可开启开发人员模式。
4、开发人员选项界面里，下拉打开“USB调试”。
可选操作：1、在拨号页，输入*#*#2846579#*#*，进入工程菜单。
2、后台设置，Log设置，点击勾选需要的日志。
调试流程1、手机连接到电脑上。
2、启动360手机助手，连接手机，然后启动360演示。
3、启动HBuilder，ctrl+R，在手机上运行应用。
4、启动chrome，在地址栏输入 chrome://inspect ，打开设备检查页面。
file:///storage/emulated/0/Android/data/io.dcloud.HBuilder/.HBuilder/apps/HBuilder/www/pages/center/… 代表的是该文件在Android手机中的位置。
5、点击“inspect”，即可打开该页面的调试。如果启动了一个白屏界面，说明要翻墙才能使用。
6、之后的调试，与前端调试相同。
7、样式调整，打断点，在页面选择元素（在调试器中选择，或者在360演示中选择均可）。。。
至此，就可以愉快地进行Android真机调试了。
书签HBuilder之Chrome调试Android手机Chrome调试Android应用（Debug）
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>hbuilder</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>使用HBuilder开发移动APP</title>
    <url>/dev-hbuilder-app/</url>
    <content><![CDATA[前言HBuilder是DCloud（数字天堂）推出的一款支持HTML5的Web开发IDE。HBuilder的编写用到了Java、C、Web和Ruby。HBuilder本身主体是由Java编写，它基于Eclipse，所以顺其自然地兼容了Eclipse的插件。快，是HBuilder的最大优势，通过完整的语法提示和代码输入法、代码块等，大幅提升HTML、js、css的开发效率。
内置MUI框架，真正彻底的跨平台开发，不是简单的跨iOS和Android。基于mui，一套HTML5工程，通过前端构建工具（如grunt）条件编译，可同时发行到iOS Appstore、安卓各大应用商店、普通手机浏览器、微信App和流应用。并且在每个平台上，都能调用该平台的专有API达到原生体验。


环境准备java参考《全平台安装JDK》。
Android模拟器下载SDK1、访问AndroidDevTools，下载android-sdk。记住，不要去安卓官网下载，不要去安卓官网下载，不要去安卓官网下载。因为安卓官网下载的，解压后只有tools文件夹，没有AVD Manager和SDK Manager。
2、启动SDK Manager，下载如下文件。（1）Tools目录（必须的工具）：

Android SDK Tools（必须，只需下载一个版本，一般选最新版本）：基础工具包，版本号带rc字样的是预览版。
Android SDK Platform-tools（必须，只需下载一个版本，一般选最新版本）：从android2.3开始划出此目录，存放公用开发工具，比如adb、sqlite3等，被划分到了这里。
Android SDK Build-tools（必须，可以安装多个版本）：Android项目构建工具。

（2）Android xxx（API xx）目录（可选的各平台开发工具）：

Documentation for Android Sdk（可选）：安卓开发者官网的一些离线文档，不过下载下来打开也很慢，后面会提供另外一个离线版。
SDK Platform（必须）：对应平台的开发工具，需要在哪个版本的平台下开发就下载哪个。
Samples for SDK（可选，此项在高版本tools中已不提供，需要在IDE里通过Import Sample引入，当然也可以下载离线版）：内置的安卓示例程序，推荐安装。
Sources for Android SDK（可选）：安卓API的源代码，推荐安装。
xxxxxxxx  Image（可选）：各个以Image结尾的东西是支持相应平台的模拟器，一般选择Intel x86 Atom_64 System Image。

（3）Extras目录（可选的扩展）：

Android Support Libraries（需要，高版本tools中已不见了，应该是集成到了别的地方）：在低版本平台实现高版本平台控件效果时提供支持。
Android Support Repository（需要）：主要是方便在gradle中使用Android Support Libraries，因为Google并没有把这些库发布到maven center或者jcenter去，而是使用了Google自己的maven仓库。
Intel x86 Emulator Accelerator(HAXM installer)（可选，但非常需要，需要CPU支持虚拟化技术支持）：windows平台的Intel x86模拟器加速工具，配合Intel x86 atom/atom_64 System Image使用可加快模拟器的运行速度。

创建虚拟机1、启动AVD Manager，创建一个安卓虚拟机。
2、启动创建的虚拟机。
也许会启动失败，报错如下：
Starting emulator for AVD 'android7.0'emulator: ERROR: x86_64 emulation currently requires hardware acceleration!Please ensure Intel HAXM is properly installed and usable.CPU acceleration status: HAXM is not installed on this machine

3、再次打开SDK Manager，发现Intel x86 Emulator Accelerator（HAXM installer）的状态是Not Compatible with Windows。
4、搜索“Hardware_Accelerated_Execution_Manager”，找到Intel官方下载地址，下载haxm-windows_v6_2_0.zip。
5、解压haxm-windows_v6_2_0.zip，放到SDK/extras/intel/目录下，然后双击silent_install.bat。
6、再次启动虚拟机，成功！
HBuilder1、访问Hbuilder官网，下载HBuilder。
2、解压HBuilder，放在一个喜欢的目录。
helloworld1、打开HBuilder，文件，新建，移动App。
2、应用名称填入helloworld，模板选择Hello mui，完成。
3、单击工具栏的三角号，在手机设备上运行/停止移动设备。
4、如果已经启动了安卓虚拟机，理论上会出现虚拟机的选项。但是，如果没有出现的话，直接ctrl+R也可以在虚拟机上启动应用。
书签使用HBuilder开发移动APP：开发环境准备
DCloud文档
Android离线打包
IOS离线打包
如何安装配置手机模拟器
7个最佳的Android模拟器
Android SDK Manager和AVD Manager使用
Android官网
Android Studio &amp;&amp; SDK下载地址
sdkmanager使用说明
在 Android Emulator 上运行应用
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>hbuilder</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title>Helm入门篇</title>
    <url>/dev-helm-start/</url>
    <content><![CDATA[Helm简介
Helm is the best way to find, share, and use software built for Kubernetes.

helm是k8s的包管理工具，就像yum之于centos，apt之于ubuntu。不同的是，yum管理的是软件包，helm管理的是配置好的k8s资源包。这种配置好的k8s资源包，按照chart的包格式进行包装。以下是wordpress的chart包结构：
wordpress/  Chart.yaml          # A YAML file containing information about the chart  LICENSE             # OPTIONAL: A plain text file containing the license for the chart  README.md           # OPTIONAL: A human-readable README file  requirements.yaml   # OPTIONAL: A YAML file listing dependencies for the chart  values.yaml         # The default configuration values for this chart  charts/             # A directory containing any charts upon which this chart depends.  templates/          # A directory of templates that, when combined with values,                      # will generate valid Kubernetes manifest files.  templates/NOTES.txt # OPTIONAL: A plain text file containing short usage notes

Helm2包括两个组件：客户端（Helm Client）和服务端（Tiller）。Helm发送指令给Tiller(gRPC协议)，Tiller主要用于管理各种应用发布的版本，并且与k8s进行交互。不过，在 Helm3 中 Tiller 被移除掉了，Helm直接与k8s进行交互，版本相关的数据存储在k8s中。
更多内容，参考helm/helm、Helm 从入门到实践 | 从 0 开始制作一个 Helm Charts、Helm用户与开发者指南。


体验Helm越来越喜欢用katacoda来学习新技能，Helm也可以在上面通过实践学习。

Helm Package Manager - BY JAVAJON
Helm Package Manager - BY KATACODA

安装Helm参考 Installing Helm，安装helm。
macosbrew install helmhelm version

linux1、查找需要的release版本
2、下载并安装
wget https://get.helm.sh/helm-v3.2.4-linux-amd64.tar.gztar -xzvf helm-v2.16.9-linux-amd64.tar.gzmv linux-amd64/helm /usr/local/bin/helmhelm version

使用Helm使用条件：安装配置k8s集群；配置kubectl，可以访问k8s；安装helm。
查看帮助：
helm -hhelm get -h

1、初始化Chart仓库
# helm repo add stable https://kubernetes-charts.storage.googleapis.com/# helm repo remove stablehelm repo add stable https://kubernetes.oss-cn-hangzhou.aliyuncs.com/chartshelm repo list

2、查看可以安装的chartshelm search repo stable
3、在k8s集群安装mysql
helm repo updatehelm show chart stable/mysqlhelm show all stable/mysqlhelm install stable/mysql --generate-name

4、卸载mysql
helm lshelm uninstall smiling-penguinhelm status smiling-penguin]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>helm</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo加速访问</title>
    <url>/dev-hexo-accelerate/</url>
    <content><![CDATA[前言《Hexo环境搭建2018年5月版》一文中，重新记录了hexo的安装部署方法，比较详细完整。但是，在访问的时候，总感觉访问速度太慢，本文就记录下hexo加速访问的方法。


思路访问速度慢，其实很好理解，毕竟coding提供了千千万万个pages服务，分给你的流量和带宽不会很多。想要加速，最简单的思路，就是更换服务器，换成自己的服务器。没错，有钱就是任性。
而且操作极其简单，git clone一下即可。
操作步骤1、服务器安装nginx和git。
2、创建www目录mkdir /opt/www
3、clone项目cd /opt/www
git clone https://git.coding.net/voidking/voidking.git
4、nginx配置参考《Hexo启用https加密连接》，修改www.voidking.com.conf。
cd /etc/nginx/conf.d/cp www.voidking.com.conf www.voidking.com.conf.bakvim www.voidking.com.conf

www.voidking.com.conf 内容为：
server &#123;    listen 80;    listen 443 ssl;    server_name www.voidking.com;    charset utf-8;    ssl_certificate /etc/nginx/ssl/1_www.voidking.com_bundle.crt;    ssl_certificate_key  /etc/nginx/ssl/2_www.voidking.com.key;    ssl_session_timeout  5m;    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers  HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM;    ssl_prefer_server_ciphers on;    if ($ssl_protocol = "") &#123;        return 301 https://$host$request_uri;    &#125;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;        root /opt/www/voidking/;        index index.html;    &#125;    error_page 404 /404.html;    location = /404.html &#123;        root /opt/www/voidking/;        index 404.html;    &#125;    location ~ /\.git &#123;        return 404;    &#125;&#125;

重启nginx，systemctl restart nginx
更新每次文章有更新时，hexo g，hexo d操作和以前相同。
然后，登录服务器，cd /opt/www/voidking，git pull，即可完成更新。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>hexo</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加百度统计</title>
    <url>/dev-hexo-baidustatistic/</url>
    <content><![CDATA[前言一直不关心网站的访问量，所以也一直没有统计过访问量数据。2019年刚刚开始，突然想到，如果在2019年终的时候，统计一下2019年的访问量，应该会很有意思。
虽然在《hexo生成sitemap》一文中的方法也可以在百度搜索资源平台看到一些站点统计信息，但是并不详细。所以，本文就来研究一下怎样在Hexo中添加百度统计。


账号准备1、访问百度统计，注册账号（好好学习的郝）。
2、注册完成后登录百度统计，管理，新增站点。
3、点击获取代码，即可拿到站点的统计代码。
&lt;script&gt;var _hmt = _hmt || [];(function() &#123;  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt;

使用配置1、在yilia/layout/_partial/post目录下，新建baidustatistic.ejs，内容为：
&lt;!--百度统计的代码--&gt;&lt;script&gt;var _hmt = _hmt || [];(function() &#123;  var hm = document.createElement("script");  hm.src = "https://hm.baidu.com/hm.js?&lt;%=theme.baidustatistic.siteid%&gt;";  var s = document.getElementsByTagName("script")[0];   s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt;

2、编辑yilia/layout/_partial/after-footer.ejs，添加：
&lt;% if (theme.baidustatistic.enable)&#123; %&gt;&lt;%- partial('post/baidustatistic') %&gt;&lt;% &#125; %&gt;

3、编辑yilia/_config.yml，添加：
# 百度统计baidustatistic:  enable: true  siteid: b759ac2a7fa45129e3ef060bf68259f0

至此，百度统计配置完成。
4、查看统计结果hexo s上传新的页面，20分钟后，查看百度统计，即可看到统计信息。

点击查看报告，可以看到更加详细的统计信息。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo环境搭建2018年5月版</title>
    <url>/dev-hexo-build-environment-2018-05/</url>
    <content><![CDATA[前言15年的时候，写了一篇《Hexo环境搭建》，记录了hexo的详细安装部署步骤。三年了，node和hexo都有了很大的变化。而郝同学刚刚换了magicbook，又要再次搭建hexo，那就推出新版的安装记录。


环境准备git1、访问git官网，下载git。
2、双击exe文件安装，一路next即可。
3、安装好git之后，配置用户名和邮箱git config --global user.name &quot;voidking&quot;
git config --global user.email &quot;voidking@qq.com&quot;
nvm1、访问nvm-windows项目，下载nvm-noinstall.zip。
2、解压nvm-noinstall.zip到D:\develop\nvm目录。
3、双击install.cmd，生成settings.txt文件。打开settings.txt文件，添加：
node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/

4、右键此电脑，属性，高级系统设置，环境变量。
5、系统变量中，添加JVM_HOME为D:\develop\nvm；添加JVM_SYMLINK为D:\develop\nvm\nodejs；Path中添加;%NVM_HOME%;%NVM_SYMLINK%;。
6、用户变量中，添加JVM_HOME为D:\develop\nvm；添加JVM_SYMLINK为D:\develop\nvm\nodejs；Path中添加;%NVM_HOME%;%NVM_SYMLINK%;。
node1、查看可获得的node版本nvm list available
2、安装node8.11.1nvm install 8.11.1
2、使用node8.11.1nvm listnvm install 8.11.1
3、测试使用node -v
安装hexo1、切换国内源npm config set registry=&quot;http://registry.cnpmjs.org&quot;
2、安装hexonpm install -g hexo
3、初始化新建hexo目录，并安装依赖包。
hexo init hexocd hexonpm install

4、测试hexo g，hexo s，然后查看 http://localhost:4000
个性化添加RSSnpm install hexo-generator-feed --save，
注意，后面的参数--save绝对不能省，否则该插件信息不会写入package.json。hexo clean，hexo g，查看public文件夹，可以看到atom.xml文件。
添加sitemapnpm install hexo-generator-sitemap --save
npm install hexo-generator-baidu-sitemap --save
hexo clean，hexo g，查看public文件夹，可以看到sitemap.xml和baidusitemap.xml文件。sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。具体参考《hexo生成sitemap》。
主题进入hexo/themes目录，下载自己维护的yilia主题git clone https://github.com/voidking/hexo-theme-yilia.git yilia
该主题的修改，可以参考《hexo主题优化》。
config.ymlhexo目录中的_config.yml修改为：
# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: VoidKingsubtitle: 学而不思则罔，思而不学则殆！description: VoidKingauthor: VoidKinglanguage: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://voidking.comroot: /permalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:  enable: true  line_number: true  auto_detect: true  tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: pageindex_generator:  per_page: 5archive_generator:  per_page: 500  yearly: true    monthly: true tag_generator:  per_page: 100 category_generator:   per_page: 100 # Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: yilia# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy:  type: git  repository: https://git.coding.net/voidking/voidking.git  branch: coding-pages## gitcafe### deploy:###   type: git###   repository: git@gitcafe.com:voidking/voidking.git###   branch: gitcafe-pages## github### deploy:###   type: git###   repository: https://git.coding.net/voidking/voidking.git###   branch: coding-pages

mathjax本来打算参考《Hexo中使用Mathjax的冲突问题》，修改一下修改hexo的渲染代码。但是，郝同学惊奇地发现，在新版的hexo中，并不需要修改任何代码，mathjax就渲染正常，nice。
发布coding1、在coding上注册一个帐号。
2、新建一个项目，和帐号名相同。
3、项目启动Pages服务。
本地操作1、生成本地代码hexo g
2、本地测试hexo s，然后访问 http://localhost:4000
3、发布到codinghexo d
提示ERROR Deployer not found: git，需要先执行：npm install hexo-deployer-git --save
4、线上测试http://voidking.coding.me
域名1、申请域名。
2、域名解析添加CNAME记录指向voidking.coding.me。
3、在coding上绑定域名。
4、测试访问。
后记至此，hexo安装部署完成。有些步骤写的比较简单，不理解的可以自行谷歌百度。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node</tag>
        <tag>nvm</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo环境搭建2021年8月版</title>
    <url>/dev-hexo-build-environment-2021-08/</url>
    <content><![CDATA[前言15年的时候，写了一篇《Hexo环境搭建》，记录了hexo的详细安装部署步骤。18年的时候，写了一篇《Hexo环境搭建2018年5月版》，对安装方法和步骤进行了更新。转眼又过了三年，今天再整理一版hexo环境搭建的流程，与时俱进。


环境准备系统环境：MACOS
安装brew、git、nvm、node，具体安装方法可以参考《MacOS设置》。
其中，node版本选择 v12.22.5
安装hexo1、切换国内源npm config set registry=&quot;https://registry.npm.taobao.org&quot;
2、安装hexo
npm install -g hexowhich hexo

3、初始化新建hexo目录，并安装依赖包。
hexo init hexocd hexonpm install --force

4、测试hexo g，hexo s，然后查看 http://localhost:4000
安装依赖添加RSSnpm install hexo-generator-feed --save，
注意，后面的参数--save绝对不能省，否则该插件信息不会写入package.json。hexo clean，hexo g，查看public文件夹，可以看到atom.xml文件。
添加sitemapnpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save
如果报错：gyp: No Xcode or CLT version detected!可以忽略它，也可以通过重装xcode-select解决
xcode-select --print-pathsudo rm -r -f /Library/Developer/CommandLineToolssudo xcode-select --installxcode-select --install

hexo clean，hexo g，查看public文件夹，可以看到sitemap.xml和baidusitemap.xml文件。sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。具体参考《hexo生成sitemap》。
支持本地搜索npm install hexo-generator-searchdb --save
需要配合_config.yml配置和主题配置，详情参考《Hexo更换主题为Next》。
支持git部署npm install hexo-deployer-git --save

安装主题进入hexo/themes目录，下载自己维护的next主题git clone https://github.com/voidking/hexo-theme-next.git next
该主题的更多个性化设置，可以参考《Hexo更换主题为Next》。
config.yml配置hexo目录中的_config.yml修改为：
# Hexo Configuration## Docs: http://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 好好学习的郝subtitle: 好好学习，天天向上！description: 学而不思则罔，思而不学则殆！author: 好好学习的郝language: zh-CNtimezone:# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://www.voidking.comroot: /permalink: :title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:  - '*.html'# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: truehighlight:  enable: true  line_number: true  auto_detect: true  tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# Pagination## Set per_page to 0 to disable paginationper_page: 5pagination_dir: pageindex_generator:  per_page: 5archive_generator:  per_page: 100  yearly: true    monthly: true tag_generator:  per_page: 100 category_generator:   per_page: 100 # local searchsearch:  path: search.xml  field: post  format: striptags  limit: 10000# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: next# Deployment## Docs: http://hexo.io/docs/deployment.html# github and giteedeploy:- type: git  repo: https://voidking.com/voidking/voidking.github.io.git  branch: master

发布github1、在github上注册一个帐号。
2、新建一个项目，和帐号名相同。
3、项目启动Pages服务。
本地操作1、生成本地代码hexo g
2、本地测试hexo s，然后访问 http://localhost:4000
3、发布到githubhexo d
4、线上测试http://voidking.github.io
域名1、申请域名。
2、域名解析添加CNAME记录指向voidking.github.io。
3、voidking.github.io项目中添加CNAME文件，绑定域名。
4、测试访问。
后记以上，hexo安装部署完成。有些步骤写的比较简单，不理解的可以自行谷歌百度。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo添加categories页面</title>
    <url>/dev-hexo-categories/</url>
    <content><![CDATA[前言随着文章越来越多，在网站中寻找文章越来越麻烦。现在有两个方案可供选择：一个是建立搜索系统；另一个是建立分类检索页面。于是，郝同学选择了更简单的后者，本文就记录一下创建categories检索页面的过程。


目标以郝同学的网站为例，左侧导航栏很小。这就意味着，我们不能像其他其他主题一样，直接把分类显示在导航栏，不然会很丑。
所以，我们需要一个categories页面，在这个页面里进行分类显示。
实践添加categories链接假设主题是yilia，那么打开yilia/_config.yml文件，找到：
# Headermenu:  主页: /  归档: /archives  关于: /about  # 随笔: /tags/随笔

修改为：
# Headermenu:  主页: /  分类: /categories  归档: /archives  关于: /about  # 随笔: /tags/随笔

categories页面1、新建categories页面hexo new page categories该命令在source目录下生成一个categories目录，categories目录下有一个index.md文件。
2、修改categories/index.md为：
---title: 文章分类date: 2018-06-11 10:13:21type: "categories"comments: false---

3、生成htmlhexo g，hexo s
4、测试访问访问 http://localhost:4000/categories/ ，即可看到categories页面，只不过现在的页面只有标题。
参考创建分类页面 和 hexo next 为文章添加分类，发现next主题在生成categories后直接就完成了分类显示。而我们的yilia，明显不行，那就自己动手，风衣足食。
修改yilia主题1、修改categories/index.md为：
---title: 文章分类date: 2018-06-11 10:13:21type: "categories"layout: "categories"comments: false---

指定layout为categories，渲染时就会使用categories.ejs进行渲染。
2、新建yilia/layout/categories.ejs，内容如下：
&lt;article class="article article-type-post show"&gt;  &lt;header class="article-header"&gt;  &lt;h1 class="article-title" itemprop="name"&gt;    &lt;%= page.title %&gt;  &lt;/h1&gt;  &lt;/header&gt;  &lt;% if (site.categories.length)&#123; %&gt;  &lt;div class="category-all-page article-type-post show"&gt;    &lt;h3&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h3&gt;    &lt;ul class="category-list"&gt;    &lt;% site.categories.sort('name').each(function(item)&#123; %&gt;      &lt;% if(item.posts.length)&#123; %&gt;        &lt;li class="category-list-item"&gt;          &lt;a href="&lt;%- config.root %&gt;&lt;%- item.path %&gt;" title="&lt;%= item.name %&gt;"&gt;&lt;%= item.name %&gt;&lt;sup&gt;[&lt;%= item.posts.length %&gt;]&lt;/sup&gt;&lt;/a&gt;        &lt;/li&gt;      &lt;% &#125; %&gt;    &lt;% &#125;); %&gt;    &lt;/ul&gt;  &lt;/div&gt;  &lt;% &#125; %&gt;&lt;/article&gt;

3、新建yilia/source/css/_partial/categories.styl，内容如下：
.category-all-page &#123;  margin: 30px 40px 30px 40px;  position: relative;  min-height: 70vh;  h3&#123;    margin: 20px 0;  &#125;  .category-all-title &#123; text-align: center; &#125;  .category-all &#123; margin-top: 20px; &#125;  .category-list &#123;    margin: 0;    padding: 0;    list-style: none;  &#125;  .category-list-item &#123; margin: 10px 10px; &#125;  .category-list-count &#123;    color: $grey;    &amp;:before &#123;      display: inline;      content: " ("    &#125;    &amp;:after &#123;      display: inline;      content: ") "    &#125;  &#125;  .category-list-child &#123; padding-left: 10px; &#125;&#125;

4、在yilia/source/css/style.styl引入categories.styl：
@import "_extend"@import "_partial/main"@import "_partial/archive"@import "_partial/article"@import "_partial/archive"@import "_partial/highlight"@import "_partial/footer"@import "_partial/share"@import "_partial/page"@import "_partial/instagram"@import "_partial/tagcloud"@import "_partial/scroll"@import "_partial/mobile-slider"@import "_partial/categories"

5、测试访问再次访问 http://localhost:4000/categories/ ，发现已经成功显示分类。
多层分类以上，已经完成了categories分类页面，但是只有一层分类。假设，现在有一篇文章的分类为多层分类，例如：
---title: Linux设置邮件提醒toc: truedate: 2018-05-24 11:00:00tags:- linux- ubuntu- centos- mailcategories: - [专业,测试]---

显示的效果为所有类别平级显示，不是我们想要的效果，如下图：
本节就实现多层分类的显示效果，具体操作如下：
1、修改yilia/layout/categories.ejs为：
&lt;article class="article article-type-post show"&gt;  &lt;header class="article-header" style="border-bottom: 1px solid #ccc"&gt;  &lt;h1 class="article-title" itemprop="name"&gt;    &lt;%= page.title %&gt;  &lt;/h1&gt;  &lt;/header&gt;  &lt;% if (site.categories.length)&#123; %&gt;  &lt;div class="category-all-page"&gt;    &lt;h2&gt;共计&amp;nbsp;&lt;%= site.categories.length %&gt;&amp;nbsp;个分类&lt;/h2&gt;    &lt;%- list_categories(site.categories, &#123;      show_count: true,      class: 'category-list-item',      style: 'list',      depth: 2,      separator: ''    &#125;) %&gt;  &lt;/div&gt;  &lt;% &#125; %&gt;&lt;/article&gt;

2、yilia/source/css/_partial/categories.styl修改为：
.category-all-page &#123;  margin: 30px 40px 30px 40px;  position: relative;  min-height: 70vh;  h2&#123;    margin: 20px 0;  &#125;  .category-all-title &#123; text-align: center; &#125;  .category-all &#123; margin-top: 20px; &#125;  .category-list &#123;    margin: 0;    padding: 0;    list-style: none;  &#125;  .category-list-item-list-item&#123;    margin: 10px 15px;  &#125;  .category-list-item-list-count&#123;    color: $grey;    &amp;:before &#123;      display: inline;      content: " ("    &#125;    &amp;:after &#123;      display: inline;      content: ") "    &#125;  &#125;  .category-list-item &#123; margin: 10px 10px; &#125;  .category-list-count &#123;    color: $grey;    &amp;:before &#123;      display: inline;      content: " ("    &#125;    &amp;:after &#123;      display: inline;      content: ") "    &#125;  &#125;  .category-list-child &#123; padding-left: 10px; &#125;&#125;

3、再次访问categories，达到了预期效果，如下图：
后记多看了几眼next主题，比几年前棒多了，现在也是一个很好的选择，适合小白。不过，它的项目结构也变得更加复杂，不方便个性化修改。
书签Hexo文档
Hexo变量
Hexo之list-categories
hexo-auto-category
Hexo主题实现多级分类显示
Hexo使用攻略：（四）Hexo的分类和标签设置
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo托管到gitcafe</title>
    <url>/dev-hexo-deposit-to-gitcafe/</url>
    <content><![CDATA[前言gitcafe作为国内的代码托管网站，访问速度远快于github，聪明的同学（比如人家我），肯定都会选择gitcafe吧！在《Hexo环境搭建》中，我们已经讲过了SSH key的生成和使用方法。下面还要用到SSH key，没学会小伙伴的自行百度。
注册官网：http://www.gitcafe.com
创建Projecthttps://gitcafe.com/projects/new ，创建和用户名相同的project，比如我的用户名为voidking，那么project名称就为voidking。
添加SSH keyhttps://gitcafe.com/account/public_keys ，Add a new public key，复制id_rsa.pub中的内容，粘贴进去即可。
测试连接ssh git@gitcafe.com
Hi voidking! You've successfully authenticated, but GitCafe does not provide shell access.Connection to gitcafe.com closed.

小结通过连接github和gitcafe，我们可以得出结论：在本地生成密钥的时候，根本不用考虑今后的服务器。github还是gitcafe，或者任何其他使用git的服务器，都没有关系。在需要使用某个服务器时，只需要把密钥添加到该服务器上面，就完成了配置工作。
修改_config.yml编辑E:\hexo下的_config.yml，修改Deployment部分：
deploy:  type: git  repository: git@gitcafe.com:voidking/voidking.git  branch: gitcafe-pages

部署deploy d，不需要输入密码，直接就可以上传到gitcafe。
访问测试访问：http://voidking.gitcafe.io或者：http://voidking.com或者：http://www.voidking.com
参考文档托管博客到gitcafehttp://zipperary.com/hexo-to-gitcafe/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo参考文档</title>
    <url>/dev-hexo-document/</url>
    <content><![CDATA[hexo系列教程：（一）hexo介绍http://zipperary.com/hexo-guide-1/

hexo系列教程：（二）搭建hexo博客http://zipperary.com/hexo-guide-2/

hexo系列教程：（三）hexo博客的配置、使用http://zipperary.com/hexo-guide-3/

hexo系列教程：（四）hexo博客的优化技巧http://zipperary.com/hexo-guide-4/



hexo系列教程：（五）hexo博客的优化技巧续http://zipperary.com/hexo-guide-5/

hexo 主题优化http://zipperary.com/hexo-theme-alteration/

把flickr相册嵌入网页http://zipperary.com/flickr-on-page/

怎样在博文中嵌入图片、音乐、视频？http://zipperary.com/media-on-hexo/

前端之drop-shadow效果http://zipperary.com/box-and-shadow-effect/

为Hexo添加多说评论功能(正文评论和列表评论数)http://blog.csdn.net/jelope/article/details/19678633

Markdown指南http://zipperary.com/introduction-to-markdown/

轻松搞定Markdownhttp://zipperary.com/easy-markdown/

初识node.jshttp://zipperary.com/learn-nodejs/

购买域名、设置DNShttp://zipperary.com/domain-name-and-dns/

如何绑定二级域名http://zipperary.com/secondary-dns/

托管博客到gitcafehttp://zipperary.com/hexo-to-gitcafe/

托管博客到STDYUNhttp://zipperary.com/blog-to-stdyun/

将hexo博客部署到baehttp://zipperary.com/hexo-on-bae/

hexo你的博客http://ibruce.info/hexo-your-blog/?utm_source=tuicoolhttp://www.tuicool.com/articles/AfQnQjy

初识hexo，安装及配置http://md5sum.cc/2014-05-05/first-met-hexo/

使用hexo搭建静态博客http://m.chinaz.com/article/354945.shtml

google字库导致hexo modernist首页加载变慢http://ibruce.info/fonts-googleapis-lead-to-slow/?utm_source=tuicoolhttp://www.tuicool.com/articles/iAVjE3

通过本地加载ga.js文件提高Google Anlytics性能http://www.jb51.net/yunying/70962.html

引用新浪微软谷歌的CDN加载jQueryhttp://www.hicc.cc/quote-sina-microsoft-googles-cdn-load-jquery.html

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用gitalk作为评论插件</title>
    <url>/dev-hexo-gitalk-comment-plugin/</url>
    <content><![CDATA[前言Hexo的评论插件，最开始使用多说，很棒，后来多说没有了。
之后评论插件换成了畅言，很棒；后来畅言开始插入广告，不服，使用CSS技术屏蔽了广告；现在，畅言更换了插入广告的方式，肯定有解决办法，但是不想和畅言玩了。
决定换一个更好用更靠谱的评论插件，或者找个开源项目自己搭建评论插件系统，实在不行自己写一个。
找到了disqus，感觉很靠谱，但是被墙了。通过曲线救国也能使用，但是违背了简单易用的初衷，遂放弃。
最后，找到了gitalk项目，看了演示，nice，搞一搞。


gitalk简介Gitalk 是一个基于 GitHub Issue 和 Preact 开发的评论插件。项目地址：https://github.com/gitalk/gitalk
特点：

使用 GitHub 登录
支持多语言（en, zh-CN, zh-TW, es-ES, fr, ru）
支持个人或组织
无干扰模式（设置 distractionFreeMode 为 true 开启）
快捷键提交评论 （cmd|ctrl + enter）

准备想要gitalk，需要申请GitHub Application。
如上图，以郝同学的申请为例：

Application name填入喜欢的应用名称。
Homepage URL填入域名。
Application description填入应用的描述。
Authorization callback URL 填入域名。

然后，Register application，转到应用页面。在该页面，可以看到Client ID和Client Secret。
使用配置以yilia主题为例。
1、下载gitalk项目git clone https://github.com/gitalk/gitalk.git
2、拷贝gitalk/dist/目录下的gitalk.css和gitalk.min.js到yilia/source/lib/gitalk目录。
3、在yilia/layout/_partial/post目录下，新建gittalk.ejs，内容为：
&lt;div class="gitalk"&gt;    &lt;div id="gitalk-container"&gt;&lt;/div&gt;    &lt;script type="text/javascript"&gt;        const gitalk = new Gitalk(&#123;            clientID: '&lt;%=theme.gitalk.client_id%&gt;',            clientSecret: '&lt;%=theme.gitalk.client_secret%&gt;',            repo: '&lt;%=theme.gitalk.repo%&gt;',            owner: '&lt;%=theme.gitalk.owner%&gt;',            admin: ['&lt;%=theme.gitalk.admin%&gt;'],            id: location.pathname,      // Ensure uniqueness and length less than 50            distractionFreeMode: false  // Facebook-like distraction free mode        &#125;)        gitalk.render('gitalk-container')    &lt;/script&gt;&lt;/div&gt;

4、编辑yilia/layout/_partial/article.ejs，添加：
&lt;% if (!index &amp;&amp; theme.gitalk.enable &amp;&amp; post.comments)&#123; %&gt;&lt;%- partial('post/gitalk', &#123;    key: post.slug,    title: post.title,    url: config.url+url_for(post.path)  &#125;) %&gt;&lt;% &#125; %&gt;

5、编辑yilia/_config.yml，添加：
# 注释所有畅言配置# 配置gitalkgitalk:   enable: true  client_id: 5a238b8c32b1e4dd2156  client_secret: bfb5d518626f6fdc7da0351d1e0cd37ab75c6361  repo: voidking.github.io  owner: voidking  admin: voidking

6、编辑yilia/layout/_partial/head.ejs，添加：
&lt;% if (theme.gitalk.enable)&#123; %&gt;  &lt;link rel="stylesheet" href="/lib/gitalk/gitalk.css"&gt;  &lt;script src="/lib/gitalk/gitalk.min.js"&gt;&lt;/script&gt;&lt;% &#125; %&gt;

至此，配置gitalk评论插件完成。
最终效果如下图：居然，每篇文章都需要初始化！！！尴尬。。。勉强可以接受。
Validation Failed打开一些页面的时候，报错：Error: Validation Failed.在gitalk的issue中发现，如果location.pathname大于50，就会报这个错误。
有同学采用md5编码url的方式来解决这个问题，好想法，参考处理Gitalk中由于文章URL过长导致的Validation Failed(422)，来处理一下。
1、访问blueimp-md5 CDN，下载md5.min.js，放入yilia/source/lib/gitalk目录。
2、编辑yilia/layout/_partial/head.ejs，添加：
&lt;% if (theme.gitalk.enable)&#123; %&gt;  &lt;link rel="stylesheet" href="/lib/gitalk/gitalk.css"&gt;  &lt;script src="/lib/gitalk/gitalk.min.js"&gt;&lt;/script&gt;  &lt;script src="/lib/gitalk/md5.min.js"&gt;&lt;/script&gt;&lt;% &#125; %&gt;

3、gitalk.ejs中id修改为：
id: md5(location.pathname),

至此，问题解决。
为了更加美观，可以适当修改css，比如在yilia/source/css/_partial/main.stly中添加：
.gitalk&#123;  padding: 0 40px;&#125;

书签hexo next 主题配置 gitalk 评论后无法初始化创建 issue
报错出现 Error: Validation Failed.
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移博客从gitcafe到coding</title>
    <url>/dev-hexo-gitcafe-to-coding/</url>
    <content><![CDATA[前言
GitCafe 已加入 CODING 成为 CODING 的一员，共同打造最适合中国开发者使用的 Git 服务平台！GitCafe 将于 2016年5月31日 停止所有服务，届时您在 GitCafe 的账户资料及所有项目都将被永久删除，请尽快将您的资料和项目迁移至 Coding。

啊嘞，郝同学的博客就在gitcafe上，免不了又要折腾一下了，下面我们就研究一下hexo托管到coding的方法。
项目迁移首先，注册一个coding账户；然后，按照提示，关联gitcafe账户，选择项目进行迁移。


Coding Pages 服务Coding Pages 服务，是一个支持 jekyll 静态站的服务，也就是我们搭建静态博客需要的服务。1、进入和用户名相同的项目下（郝同学用户名为voidking，那么就进入voidking项目），点击Pages。
2、开启服务，并且绑定需要的域名。
3、访问http://voidking.coding.me/voidking ，404错误，正常，因为我们还没有coding-pages分支。
4、点击分支，新建分支，输入名称为coding-pages，输入起点。
5、分支创建成功，访问http://voidking.coding.me/voidking ，依然404。
6、点击Pages，重新部署。等待十多秒，就可以正常访问了。
域名解析在上一步中，我们已经在coding上绑定了域名。但是，要想通过域名访问，我们还需要在自己的域名服务器上完成解析。以万网为例，解析如下：然后，访问http://voidking.com ，http://www.voidking.com ，http://blog.voidking.com ，全部正常。
发布博客可以正常访问了，接下来的问题是，它能不能和之前一样，使用hexo d就重新部署呢？试试看。
设置_config.yml原配置如下：
deploy:  type: git  repository: git@gitcafe.com:voidking/voidking.git  branch: gitcafe-pages
修改如下：
deploy:  type: git  repository: https://git.coding.net/voidking/voidking.git  branch: coding-pages

添加SSH key进入项目，设置，部署公钥，新建部署公钥。复制C:\Users\Administrator\.ssh\id_rsa.pub中的内容，粘贴进去即可。关于密钥的生成方法，参见《Hexo环境搭建》。
发布测试hexo g，hexo d，根据提示输入用户名和密码，结果如下：
$ hexo dINFO  Deploying: gitINFO  Clearing .deploy folder...INFO  Copying files from public folder...[master a7d185c] Site updated: 2016-05-13 11:56:08 568 files changed, 8448 insertions(+), 4942 deletions(-) create mode 100644 dev-npm-install/index.html create mode 100644 dev-gitcafe-to-coding/index.html create mode 100644 archives/2016/05/index.html create mode 100644 "categories/\350\256\276\350\256\241\345\274\200\345\217\221/page/2/index.html" rewrite page/40/index.html (74%) create mode 100644 page/59/index.html create mode 100644 tags/bower/index.html create mode 100644 tags/coding/index.html create mode 100644 tags/node/index.html create mode 100644 tags/npm/index.html create mode 100644 "tags/\345\215\232\345\256\242/index.html"Username for 'https://git.coding.net': voidkingPassword for 'https://voidking@git.coding.net':Branch master set up to track remote branch coding-pages from https://git.coding.net/voidking/voidking.git.To https://git.coding.net/voidking/voidking.git   f14ee2d..a7d185c  master -&gt; coding-pagesINFO  Deploy done: git
访问http://www.voidking.com ，刷新下，再刷新下。。。nice，内容已经更新。可见，hexo d命令同样适用于coding。
后记如果过了5月31号，还没有完成迁移，怎么办？参见参考文档的《Coding Pages 介绍》，正常创建项目就可以了。
参考文档Coding Pages 介绍https://coding.net/help/doc/pages/index.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用livere作为评论插件</title>
    <url>/dev-hexo-livere-comment-plugin/</url>
    <content><![CDATA[前言使用gitalk作为评论插件，差强人意，因为每篇文章都需要初始化。而且，加载速度很慢。想了一天，决定再换一个评论插件，换成韩国的评论插件livere。


livere简介livere（来必力）是一个社会化评论插件，优点有：

使用社交网站账户登录，免去注册过程。
提高用户的参与和沟通意愿。
管理/删除我的评论内容。
提供管理页面，管理网站文章及评论内容。

准备1、访问来必力官网，注册账号。
2、登录后点击导航栏“安装”，选择city版。
3、根据提示，申请获取代码。
4、郝同学获取到的一般网站的代码为：
&lt;!-- 来必力City版安装代码 --&gt;&lt;div id="lv-container" data-id="city" data-uid="MTAyMC8zODU3Mi8xNTEwMA=="&gt;    &lt;script type="text/javascript"&gt;   (function(d, s) &#123;       var j, e = d.getElementsByTagName(s)[0];       if (typeof LivereTower === 'function') &#123; return; &#125;       j = d.createElement(s);       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';       j.async = true;       e.parentNode.insertBefore(j, e);   &#125;)(document, 'script');    &lt;/script&gt;&lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;&lt;/div&gt;&lt;!-- City版安装代码已完成 --&gt;

使用配置1、在yilia/layout/_partial/post目录下，新建livere.ejs，内容为：
&lt;div class="livere"&gt;    &lt;!-- 来必力City版安装代码 --&gt;    &lt;div id="lv-container" data-id="city" data-uid="&lt;%=theme.livere.uid%&gt;"&gt;        &lt;script type="text/javascript"&gt;       (function(d, s) &#123;           var j, e = d.getElementsByTagName(s)[0];           if (typeof LivereTower === 'function') &#123; return; &#125;           j = d.createElement(s);           j.src = 'https://cdn-city.livere.com/js/embed.dist.js';           j.async = true;           e.parentNode.insertBefore(j, e);       &#125;)(document, 'script');        &lt;/script&gt;    &lt;noscript&gt; 为正常使用来必力评论功能请激活JavaScript&lt;/noscript&gt;    &lt;/div&gt;    &lt;!-- City版安装代码已完成 --&gt;&lt;/div&gt;

2、编辑yilia/layout/_partial/article.ejs，添加：
&lt;% if (!index &amp;&amp; theme.livere.enable &amp;&amp; post.comments)&#123; %&gt;&lt;%- partial('post/livere', &#123;    key: post.slug,    title: post.title,    url: config.url+url_for(post.path)  &#125;) %&gt;&lt;% &#125; %&gt;

3、编辑yilia/_config.yml，添加：
# 注释所有畅言配置# 注释所有gitalk配置# livere配置livere:   enable: true  uid: MTAyMC8zODU3Mi8xNTEwMA==

4、在yilia/source/css/_partial/main.stly中添加：
.livere&#123;  padding: 0 40px;&#125;

至此，配置livere评论插件完成，效果如下：nice，看起来比gitalk强多了，就你了。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo本地搜索加速</title>
    <url>/dev-hexo-local-search-accelerate/</url>
    <content><![CDATA[前言随着文章数量的增长，search.xml文件越来越大。因此在加载这个文件时，需要的时间很长，而且偶尔会出现加载不出来的情况。
有没有什么办法能够加快加载速度呢？必须是有的，本文就来研究一下。
《Hexo使用Gulp压缩静态资源》一文中，提到search.xml大小为3.5M。今天又看了一下，文件大小变成了4.3M（加载时会压缩传输，大小约为1.3M）。从文中的实验可以得出结论，在文件大小方面，没有什么优化的空间了。
再想优化，就得从网络方面入手：CDN加速。主要参考jsDelivr+Github 使用方法。
更多Hexo相关内容，参考Hexo系列文章。


思路修改 search.xml 的文件链接，改成cdn的地址。
实现1、测试jsdelivr链接，search.xml的cdn地址为https://cdn.jsdelivr.net/gh/voidking/voidking.github.io/search.xml
2、编辑 next/source/js/local-search.js ，如下修改：
// const path = CONFIG.root + searchPath;const jsdelivr = 'https://cdn.jsdelivr.net/gh/'const userRepo = 'voidking/voidking.github.io/'const path = jsdelivr + userRepo + searchPath;

3、本地测试，提交代码，使用修改后的主题进行部署
实测加载速度飞快，4.3M的search.xml能够稳定在2秒内加载完毕，完美。
提高通用性1、cdn的配置放在 _config.yml 文件中
# Local Search# Dependencies: https://github.com/theme-next/hexo-generator-searchdblocal_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false  # Use CDN to accelerate the speed of loading search.xml  cdn:    enable: false    # url: //cdn.jsdelivr.net/gh/&lt;username&gt;/&lt;username&gt;.github.io/search.xml    url:

2、编辑 next/source/js/local-search.js ，如下修改：
let path = CONFIG.root + searchPath;// Use CDN to accelerate the speed of loading search.xmlif ('cdn' in CONFIG.localsearch &amp;&amp; CONFIG.localsearch.cdn.enable === true &amp;&amp; CONFIG.localsearch.cdn.url !== null)&#123;  path = CONFIG.localsearch.cdn.url;&#125;


]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo中使用Mathjax的冲突问题</title>
    <url>/dev-hexo-mathjax/</url>
    <content><![CDATA[问题描述写《信息量&amp;信息熵&amp;信息增益》时，用到了一些数学公式。但是，在使用hexo生成页面后，这些数学公式并没有被正确显示。查找资料发现markdwon本身的特殊符号与latex中的符号会出现冲突:
1、在markdown中，_是斜体，但是在latex中，却有下标的意思。2、在markdown中，\\会被转义为\,这样也会影响影响mathjax对公式中的\\进行渲染。
解决办法有三种，手动添加转义、更换hexo的markdown渲染引擎和修改hexo的渲染代码。郝同学更喜欢第三种，经过尝试，完美解决问题，本文记录下解决问题的过程。


解决问题确认开启mathjax以郝同学使用的yilia主题为例，主题本身已经集成了mathjax，其他主题可以参考添加。
在yilia\layout\_partial\after_footer.ejs 里有如下代码：
&lt;% if (theme.mathjax)&#123; %&gt;&lt;%- partial('mathjax') %&gt;&lt;% &#125; %&gt;
当_config.yml文件中的mathjax参数为true时，页面中便会引入mathjax.ejs。
在yilia\layout\_partial\mathjax.ejs里有如下代码：
&lt;! -- mathjax config similar to math.stackexchange --&gt;&lt;script type="text/x-mathjax-config"&gt;MathJax.Hub.Config(&#123;    tex2jax: &#123;        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],        processEscapes: true,        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']    &#125;&#125;);MathJax.Hub.Queue(function() &#123;    var all = MathJax.Hub.getAllJax(), i;    for(i=0; i &lt; all.length; i += 1) &#123;        all[i].SourceElement().parentNode.className += ' has-jax';                     &#125;       &#125;);&lt;/script&gt;&lt;script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;&lt;/script&gt;
引入了mathjax，以及配置mathjax。
其实更好的做法，是把after_footer.ejs中的代码修改为：
&lt;% if (page.mathjax)&#123; %&gt;&lt;%- partial('mathjax') %&gt;&lt;% &#125; %&gt;
这样，是否在页面中引入mathjax，就交由了页面控制，更加灵活。写文档时，在头部加入mathjax: true，或者mathjax: false。
---title: Hexe中使用Mathjax的冲突问题toc: truemathjax: falsedate: 2017-03-14 16:00:00updated: 2017-03-14 16:00:00tags:- hexo- mathjaxcategories: 点滴发现---


修改渲染代码找到hexo\node_modules\hexo-renderer-marked\node_modules\marked\lib\markd.js，备份后进行修改：
1、去掉\的转义
escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,
修改为
escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,

2、去掉_的斜体含义
em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
修改为
em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,


书签MathJaxhttps://www.mathjax.org/
期刊文章 - TeXIDE, 在线 LaTeX 编辑器https://www.texide.com/templates/journals/?
JaxEdit Websitehttp://jaxedit.com/
Cmd Markdown 编辑阅读器 - 作业部落出品https://www.zybuluo.com/mdeditor
在 Hexo 中完美使用 Mathjax 输出数学公式http://lukang.me/2014/mathjax-for-hexo.html
Hexo下mathjax的转义问题https://segmentfault.com/a/1190000007261752
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo配置多个git仓库</title>
    <url>/dev-hexo-multi-git/</url>
    <content><![CDATA[吐槽在经历过域名被封之后，今天又经历了搬瓦工服务器IP被封，我太难了。。。o(╥﹏╥)o服务器IP被封，带来了三个问题：第一个是不能愉快地科学上网了；第二个是内网穿透不能使用了；第三个是自己的 www.voidking.com 域名无法访问了。
对于问题一，暂时使用免费的公共飞机场。对于问题二，暂时使用百度服务器，但是因为没有备案，所以不能进行域名解析。对于问题三，就是本文要解决的问题之一。


回到github那么，因为服务器IP被封，域名无法访问怎么办？
方法一：再购买一个新的搬瓦工IP，或者再购买一个新的国外服务器。但是因为不想再花钱（就是这么抠），所以这个方法被否定了。方法二：使用免费的git pages服务，比如github pages、gitlab pages、gitee pages等，并且把域名解析到git pages服务器。这里我选择最开始搭建hexo就使用的github pages，它支持免费的自定义域名和https。
参考《Hexo环境搭建》和《Hexo环境搭建2018年5月版》，配置好github pages服务，并且配置域名的CNAME解析到 voidking.github.io ，开启强制https（github会自动申请ssl证书，点个赞）。
百度收录问题除了访问速度慢一点之外，现在我的域名已经正常了，nice。但是，另外的问题出现了：百度搜索不到我的域名了！
使用百度抓取诊断工具诊断，发现抓取异常信息是拒绝访问，403 Forbidden。这是因为github屏蔽了百度蜘蛛，所以百度无法收录解析到github的域名。
浏览了一些文章，找到了解决办法：在DNSPod配置两个www的域名解析，线路类型“默认”解析到 voidking.github.io ，线路类型“百度”解析到一个百度可以抓取的地址，如下图。也就是说，需要维护两个站点，两个站点分别处理来自不同线路的流量。其中一个站点建立在github，另外一个站点建立在哪儿呢？这里我选择ZEIT Now。
理想是美好的，现实是残酷的！因为无论是github还是zeit，都需要验证域名解析，而它们都是境外服务器，所以都需要线路类型“境外”的CNAME解析，否则无法通过验证！尴尬了。。。只能选择其一。
为了百度的收录，看起来只能选择zeit了，不过zeit每个月只有20G的流量。为了在zeit流量用光后方便地切到github，因此还是需要维护两个站点。
hexo配置多个git仓库为了维护两个站点，所以每次更新，需要发布github pages和zeit。github pages的发布很方便，上传代码后直接就发布了；而zeit的发布有多种方式，其中一种方式是通过Deploy Hooks触发。
如果github和zeit都使用 voidking.github.io 这一个git仓库，那么问题很简单。hexo d后，再访问一个url触发 Deploy Hooks就可以了。而zeit，不支持 voidking.github.io 这种项目名称，因此稍微麻烦一点。
1、新建git仓库在github上再创建一个git仓库叫做voidking，import voidking.github.io仓库。
2、配置zeit关联把voidking这个仓库和zeit做关联，并且发布项目，配置生成一个Deploy Hooks。
3、配置域名按照提示绑定 www.voidking.com 这个域名到zeit站点。
4、修改config.yml文件修改hexo的config.yml文件中的deploy部分为：
# githubdeploy:- type: git  repo: https://voidking.com/voidking/voidking.github.io.git  branch: master- type: git  repo: https://voidking.com/voidking/voidking.git  branch: master
以上配置参考Hexo一键发布。
5、发布项目正常执行hexo d，静态资源代码会上传到两个git仓库中。其中，voidking.github.io这个仓库就直接发布了。而voidking这个仓库想要发布到zeit上，还需要手动触发一下（访问Deploy Hooks的url）。
至此，hexo多个git仓库，多个站点配置完成。
后记如果zeit上的流量用完了，可以在DNSPod上修改域名解析到github。虽然有延迟，但是对于个人使用来说足够了。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next主题显示文章更新时间</title>
    <url>/dev-hexo-next-update-time/</url>
    <content><![CDATA[问题《Hexo更换主题为Next》一文中，关闭了文章的更新时间。因为next主题默认是使用markdown文件的修改时间作为更新时间，这个时间是不符合预期的。比如我换了电脑，clone下来markdown文件，写完后发布，那么所有文章的更新时间都会变成当前时间，这个就不符合预期，就不对。
但是，文章更新时间确实是有意义的，读者能够通过更新时间推断出一篇文章的有效性。比如很多工具和技术昨天可以用，文章写的没毛病，但是也许今天就不能用了。
本文就来研究一下，怎样让next主题显示符合预期的、准确的更新时间。


思路首先，我们知道next主题是支持显示更新时间的，只不过显示的更新时间不对。那么，能不能显示对的更新时间呢？看代码。
1、_config.yml，其中关于更新时间的部分：
# Post meta display settingspost_meta:  item_text: true  created_at: true  updated_at:    enable: true    another_day: true  categories: true

2、layout/_macro/post.swig，其中关于更新时间的部分：
&#123;%- if theme.post_meta.updated_at.enable and datetime_diff %&#125;  &#123;%- set display_updated = not theme.post_meta.updated_at.another_day or theme.post_meta.updated_at.another_day and date_diff %&#125;  &#123;%- if display_updated or not theme.post_meta.created_at %&#125;    &lt;span class="post-meta-item"&gt;      &lt;span class="post-meta-item-icon"&gt;        &lt;i class="fa fa-calendar-check-o"&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;span class="post-meta-item-text"&gt;&#123;&#123; __('post.edited') &#125;&#125;&lt;/span&gt;      &lt;time title="&#123;&#123; __('post.modified') + __('symbol.colon') + full_date(post.updated) &#125;&#125;" itemprop="dateModified" datetime="&#123;&#123; moment(post.updated).format() &#125;&#125;"&gt;&#123;&#123; date(post.updated) &#125;&#125;&lt;/time&gt;    &lt;/span&gt;  &#123;%- endif %&#125;&#123;%- endif %&#125;

由上面的代码我们可以得知：

只要在文章头部yaml定义中添加 updated 字段，就可以显示我们自己定义的更新时间，而不是文件的修改时间。
如果开启了 post_meta.updated_at.another_day ，当 date 和 updated 日期相同时，只会显示发布时间。

因此，我们现在有两个思路来实现next主题显示符合预期的更新时间。思路一：开启 post_meta.updated_at.enable，然后给所有的md文件添加 updated 字段。思路二：开启 post_meta.updated_at.enable，修改 post.swig ，令没有 updated 字段的md文件只显示发布时间，有 updated 字段的md文件显示发布时间和更新时间。
这里选择思路一，因为实现的逻辑最简单，而且郝同学的shell脚本用的还不错。
实现开启更新时间显示_config.yml，开启更新时间显示：
# Post meta display settingspost_meta:  item_text: true  created_at: true  updated_at:    enable: true    another_day: true  categories: true

添加updated字段1、准备脚本
#!/bin/bashdir="_posts"for file in `ls $&#123;dir&#125; | grep '.md'`;do    content=$(cat $&#123;dir&#125;/$&#123;file&#125;| head -n 10 | grep 'date: ')    datestr=$(echo "$content" | awk '&#123;print $2" "$3&#125;')    newcontent="updated: "$datestr    sed -i "/$content/a\\$newcontent" $&#123;dir&#125;/$&#123;file&#125;done

2、执行脚本把脚本放到 source 目录下，然后执行脚本 bash modify.sh备注：需要linux环境，mac环境的sed命令和linux环境的sed命令有差异。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo生成sitemap</title>
    <url>/dev-hexo-sitemap/</url>
    <content><![CDATA[前言很久，都不再关心百度谷歌对自己博客的收录，只是把博客当做生活的记录。今天，突然想稍微搞下SEO，然后就有了这篇博文。


过程1、生成站点地图
npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save

提示警告，不过可以忽略。
npm WARN optional Skipping failed optional dependency /chokidar/fsevents:npm WARN notsup Not compatible with your operating system or architecture: fsevents@1.0.15......

在博客目录的_config.yml中添加如下代码(貌似不加也可以，反正我没加)
sitemap:path: sitemap.xmlbaidusitemap:path: baidusitemap.xml

2、验证网站Google验证网站的方式是文件验证；百度验证网站的方式有三种，文件验证、html标签验证、CNAME验证。郝同学采用文件验证方式，下载验证文件，放到hexo/source目录下，hexo g，hexo d，即可发布验证文件到服务器上。
3、添加站点地图分别登录Google Search Console，和百度站长平台，添加站点地图。
问题由上面两个图可以看出，sitemap.xml没有问题，但是baidusitemap.xml解析会出错。访问http://www.voidking.com/baidusitemap.xml，看到详细报错。
xml解析器在遇到字符“&amp;”时，会把“&amp;”当做一个实体引用的开始，而去寻找这个实体引用的结束符号“;”，
在xml文档中，像“&amp;”这样的预定义的实体引用一共有5个，分别是“&amp;”、“&lt;”、“&gt;”、“’”、“””。
解决方法一：把实体引用编码后使用，即
把“&amp;” 编码为 “&amp;amp;” 把“&lt;” 编码为“&amp;lt;” 把“&gt;” 编码为 “&amp;gt;” 把“'” 编码为 “&amp;apos;” 把“"” 编码为 “&amp;quot;”

&lt;loc&gt;url&amp;mb=bt&lt;/loc&gt;
替换为：
&lt;loc&gt;url&amp;amp;mb=bt&lt;/loc&gt;

解决方法二：在标记CDATA中，所有的标记、实体引用都被忽略，而被“xml解析器”一视同仁地当做原始字符数据看待，CDATA的形式如下：针对本文上面的问题，即把原来代码中的：
&lt;loc&gt;url&amp;mb=bt&lt;/loc&gt;
替换为：
&lt;loc&gt;&lt;![CDATA[url&amp;mb=bt]]&gt;&lt;/loc&gt;
使用CDATA需要注意的两点，1、由于CDATA的结束符号是“]]&gt;”，所以CDATA中不能包含“]]&gt;”。2、由于CDATA中的所有标记、实体引用都被忽略，所以CDATA不能嵌套使用。
后记然而，上面的问题并没有找到解决办法，那就留个坑吧。如果看到这篇文章的同学找到解决办法，希望能给我留言，在此谢过。
书签站点信息_站长工具_站点重要数据概览_百度站长平台http://zhanzhang.baidu.com/dashboard/index
Search Console - 首页https://www.google.com/webmasters/tools/home?hl=zh-CN
Hexo生成sitemap站点地图的方法http://blog.kenai.cc/article/hexo/hexo-skills/
hexo干货系列：（六）hexo提交搜索引擎（百度+谷歌）http://www.jianshu.com/p/619dab2d3c08
关于xml特殊符号报错EntityRef: expecting ‘;’http://bbs.phome.net/showthread-13-330736-0.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Travis CI失效</title>
    <url>/dev-hexo-travis-ci-not-work-anymore/</url>
    <content><![CDATA[问题描述2021年8月8日，趁着周末空闲修改了一些文章，然后发了新版。但是，发现网站没有更新。看看邮件，没有收到travis ci的邮件，再仔细想想，貌似好久没有收到travis ci的邮件了。登录Travis CI查看构建记录，好家伙，上次构建还是5月份的！问题大了！
到底是怎么回事？Travis CI有bug不能用了？GitHub封杀了Travis CI？Travis CI规则改了，开源项目也有构建次数限制？…不知道具体什么原因，本文我们就来排查一下。


手动触发1、登录Travis CI
2、点击 voidking/hexo-deploy 项目，点击右上角 More options，点击 Trigger build 进行手动触发构建
3、Branch 保持默认 master ，CUSTOM COMMIT MESSAGE 输入随意内容，CUSTOM CONFIG 不填
4、点击 Trigger custom build，就看到了具体的报错了弹框提示 Oh no! You tried to trigger a build for voidking/hexo-deploy but the request was rejected.Requests Tab页提示 Could not authorize build request for voidking/hexo-deploy.从5月7日至今，一直是这个错误。
猜想和验证Travis CI授权过期了？根据报错信息，很容易联想到授权过期，因为之前还好好的，突然不能用了。
1、进入GitHub Applications settings页面，配置Travis CI。2、检查了一遍，并没有授权过期一说，没有什么问题。3、保险起见，调整了一下 Repository access ，保存。然而问题并没有解决，说明不是授权过期问题。
缺少 .travis.yml ？Travis CI论坛上有人是因为缺少 .travis.yml 文件导致。

In your case, it’s due to a missing .travis.yml.

怀疑自己也是误删了 .travis.yml 文件，但是检查了一遍，并没有误删。
需要换免费版？Travis CI论坛上还有人没有找到原因，最终换了Github Actions。

I kept struggling on this, and finally left travis.com for Github Actions :persevere: Now I can build &amp; deploy again 

如果非换不可的话，我打算换成Travis CI免费版，毕竟更加熟悉。但是工作量很大，很多地方都需要重新配置。我不信需要这么麻烦！
需要加入组织？stackoverflow上有人说需要为组织选择一个plan，莫非现在必须要加入组织才能使用Travis CI？

It’s also worth mentioning that this happens if you do not have a plan selected for your organization. First, you need to select a plan (Travis does not automatically select the free plan for you). Then, you can trigger a build and see if things work.


If that does not work, you’re likely out of builds and will need to upgrade the account.

于是，创建了一个Organizations：begoodcoder。然而创建组织后并没有解决问题。PS：个人感觉组织和个人账号的区别，主要是组织可以创建团队。
Plan! Plan! Plan!stackoverflow上有多个优质回答提到了Plan，这个Plan是个啥？

‘Could not authorize build request …’ usually occurs due to

Has not activated either a free plan or a paid plan.
Expiration of the subscription.
Ran out of free trial build credits available for private repositories.Travis CI is always-free only for public repositories. The free plan also provides 10,000 build credits try out building private repositories. Read updated info on Billing FAQ.


1、Travis CI右上角点击账号，选择Settings
2、点击页面上的Plan
3、选择Free plan
4、再次手动触发配送，成功！
以上，Travis CI失效的问题就定位并解决了，需要选择一个Plan！
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>hexo</category>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo配置Travis CI自动发布</title>
    <url>/dev-hexo-travis-ci/</url>
    <content><![CDATA[CI, CD and CDCI，CONTINUOUS INTEGRATION，持续集成。在持续集成环境中，开发人员将会频繁的提交代码到主干。这些新提交在最终合并到主线之前，都需要通过编译和自动化测试流进行验证。
CD，CONTINUOUS DELIVERY，持续交付。持续交付就是应用发布出去的过程。这个过程可以确保我们尽可能快的实现交付。这就意味着除了自动化测试，我们还需要有自动化的发布流，以及通过一个按键就可以随时随地实现应用的部署上线。为了发挥持续交付的优势，一般需要先进行小批量发布，尽快部署到生产线，以便在出现问题时方便进行故障排除。
CD，CONTINUOUS DEPLOYMENT，持续部署。持续部署是持续集成和持续交付的合并。当开发人员在主分支中合并一个提交时，会触发工作流，包括构建、单元测试、预发布、验收测试、生产发布、冒烟测试等。如果一切顺利，则成功部署到生产环境中。如果某个工作流失败，则不会部署到生产环境。
更多关于CI/CD内容参考详解CI、CD &amp; CD和什么是 CI/CD？，关于发布环境的划分参考Deployment environment。
在gitlab中，无论是CI、CD还是CD，都可以通过配置gitlab-ci.yml来实现。而github，在2019年8月8日也支持内置的CI/CD了。但是本文中，并不是使用github内置的CI/CD，而是使用Travis CI来实现hexo的自动发布。
《Hexo配置多个git仓库》一文中已经学习了hexo配置多个git仓库的方法，发布项目也很简单。为什么还需要hexo的自动发布？因为发布流程还可以更简单。而且，现在的发布方式，如果想要多台电脑同时使用，那么每台电脑都需要配置hexo环境，很麻烦。如果本地只负责写写markdown文件，而构建发布都放到云端，是不是更加美好？本文要做的，就是这样一件事。


安装配置本地hexo参考《Hexo环境搭建2018年5月版》，安装v10.16.3版本的node，创建hexo项目，然后把需要的依赖写入package.json：
npm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --savenpm install hexo-deployer-git --savenpm install hexo-generator-searchdb --save
接下来改造hexo配置，用于Travis CI发布。
1、创建hexo-deploy项目在github创建public项目hexo-deploy，注意一定要是public项目，否则不会触发travis-ci。git clone到本地，然后把hexo项目里的内容剪切到hexo-deploy目录。
2、配置config.yml编辑config.yml，根据自己的需要进行配置。
3、清理文件hexo-deploy目录里只需要保留：
.git.gitignorepackage.json_config.ymlREADME.md

配置travis.yml主要参考使用Travis CI持续部署Hexo博客和將 Hexo 部署到 GitHub Pages。已知 voidking.github.io 和 voidking 是hexo发布后的git仓库（public），hexo-backup是存储markdown文件的git仓库（private）。
1、安装Travis CI插件在github添加Travis CI插件，并且在Applications settings配置Travis CI的权限。
2、生成access token访问github的Personal access tokens页面，Generate new token。Note输入travis，Select scope选择repo，然后点击Generate token。生成了一个token，保存它。
3、添加access token访问Travis CI Pro，找到hexo-deploy项目，Settings，在Environment Variables一栏填入Name为GITHUB_TOKEN，VALUE为github的access token。
3、在hexo-deploy目录下添加.travis.yml文件，内容为：
sudo: falselanguage: node_jsnode_js:  - 10.16.3cache: npmbranches:  only:  - master # build master branch onlyenv:  global:  - GIT_USER: voidking  - HEXO_BACKUP_REPO: github.com/voidking/hexo-backup.git  - HEXO_THEME_REPO: github.com/voidking/hexo-theme-next.git  - GITHUB_PAGES_REPO: github.com/voidking/voidking.github.io.git  - VOIDKING_REPO: github.com/voidking/voidking.gitbefore_install:- export TZ='Asia/Shanghai'- npm install hexo -ginstall:- npm installscript:- git clone https://$&#123;HEXO_THEME_REPO&#125; themes/next- git clone https://$&#123;GIT_USER&#125;:$&#123;GITHUB_TOKEN&#125;@$&#123;HEXO_BACKUP_REPO&#125; hexo-backup- mv hexo-backup/source .- rm -rf source/private- hexo g# 此处有bug，参考下文继续修改after_success:- git config --global user.name "voidking"- git config --global user.email "voidking@qq.com"- cd ./public- git init- git add .- git commit -m "Travis CI Auto Builder"- git push --force --quiet "https://$&#123;GIT_USER&#125;:$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_PAGES_REPO&#125;" master:master- git push --force --quiet "https://$&#123;GIT_USER&#125;:$&#123;GITHUB_TOKEN&#125;@$&#123;VOIDKING_REPO&#125;" master:master

hexo发布在hexo-deploy项目中，修改README.md（建议添加日期信息），然后提交代码，触发发布。
git add .git commit -m "20200202deploy"git push

然后打开Travis CI - hexo-deploy，即可看到构建发布的日志。如果构建发布出错，根据提示修改发布脚本或者markdown文件即可。
至此，Hexo配置Travis CI自动发布完成！
域名404问题发布完成，出现了一个神奇的问题，www.voidking.com 域名404。查看github pages配置，发现自定义域名变回了 voidking.github.io 。神奇了！莫非，是因为force push刷掉了git仓库的commit？那就保留commit试试。修改.travis.yml的aftersuccess部分：
after_success:- git config --global user.name "voidking"- git config --global user.email "voidking@qq.com"- git clone https://$&#123;GIT_USER&#125;:$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_PAGES_REPO&#125; voidking- unalias cp- cp -rf public/. voidking- cd voidking- git add .- git commit -m "Travis CI Auto Builder"- git push --force --quiet "https://$&#123;GIT_USER&#125;:$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_PAGES_REPO&#125;" master:master- cd ../public- git init- git add .- git commit -m "Travis CI Auto Builder"- git push --force --quiet "https://$&#123;GIT_USER&#125;:$&#123;GITHUB_TOKEN&#125;@$&#123;VOIDKING_REPO&#125;" master:master
保留commit之后，自定义域名果然不会再变化，nice。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>hexo</category>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>横向滚动效果</title>
    <url>/dev-horizontal-scrolling/</url>
    <content><![CDATA[html部分：
&lt;div class="tab-body"&gt;    &lt;ul&gt;        &lt;li data-key="0"&gt;全部&lt;/li&gt;        &lt;li data-key="1"&gt;攻略&lt;/li&gt;        &lt;li data-key="2"&gt;案例&lt;/li&gt;        &lt;li data-key="3"&gt;故事会&lt;/li&gt;        &lt;li data-key="4"&gt;特别策划&lt;/li&gt;        &lt;li data-key="5"&gt;喜舍杯&lt;/li&gt;        &lt;li data-key="6"&gt;家居轶事&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;



sass部分：
.tab-body&#123;    background: #fff;    overflow-x: scroll;    ul&#123;        width: 1000%;        li&#123;            display: inline-block;            vertical-align: top;            height: 3.5rem;            line-height: 3.5rem;            font-size: 1.3rem;            color: #666;            padding: 0 .8rem 0 .8rem;            margin-right: 1.8rem;            &amp;.active&#123;                border-bottom: 4px solid #FF5500;                color: #FF5500;            &#125;        &#125;    &#125;&#125;

js部分：
// 初始type是全部$('.tab-body li').first().addClass('active');var type = 0;// 设置导航条宽度var totalWidth = 0;$('.tab-body li').each(function(index, el) &#123;    totalWidth += $(el).width()+parseInt($(el).css('margin-right'));&#125;);$('.tab-body ul').css(&#123;    'width': (totalWidth + 50)+ 'px'&#125;);// 切换type$('.tab-body li').on('click',function()&#123;    $('.tab-body li').removeClass('active');    $(this).addClass('active');    type = $(this).attr('data-key');    var param = &#123;        articleType: type,        pageNo: 1,        pageSize: 4    &#125;    $.ajax(&#123;        url: '/inspiration/home/api',        type: 'POST',        dataType: 'json',        data: param,        success: function(data)&#123;            //把新获得的数据插入到页面        &#125;,        error: function(xhr)&#123;            console.log(xhr)        &#125;    &#125;);         &#125;);

效果图
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>如何学习编程</title>
    <url>/dev-how-to-learn-programming/</url>
    <content><![CDATA[方法在编程这条路上，已经走了四年，而且，还要一直走下去。
个人关于学习编程的方法，三句话以蔽之：1、学而不思则罔，思而不学则殆。2、无论是什么工具，当你开始去使用它，一切都会变得简单！3、学一点，会一点，胜在不止。
求知，思考，实践，总结。知易行难，贵在坚持！


书签十年学会编程http://daiyuwen.freeshell.org/gb/misc/21-days-cn.html
专访周家安：我的十年编程自学之路http://www.csdn.net/article/2013-02-26/2814263
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>如何引入另一个html文件</title>
    <url>/dev-how-to-load-in-another-html-file/</url>
    <content><![CDATA[iframe方式&lt;iframe name="content_frame" width=100% height=30 marginwidth=0 marginheight=0 src="import.htm" mce_src="import.htm" &gt;&lt;/iframe&gt;

你会看到一个外部引入的文件，但会发现有一个类似外框的东西将其包围，可使用
&lt;iframe name="content_frame" marginwidth=0 marginheight=0 width=100% height=30 src="import.htm" mce_src="import.htm" frameborder=0&gt;&lt;/iframe&gt;

但你会发现还会有点问题，就是背景色不同，你只要在引入的文件import.htm中使用相同的背景色也可以如果想引入的文件过长时不出现滚动条的话在import.htm中的body中加入scroll=no
object方式&lt;object style="border:0px" type="text/x-scriptlet" data="import.htm" width=100% height=30&gt;&lt;/object&gt;

behavior的download方式&lt;span id=showImport&gt;&lt;/span&gt;&lt;IE:Download ID="oDownload" STYLE="behavior:url(#default#download)" /&gt;&lt;script&gt;function onDownloadDone(downDate)&#123;	showImport.innerHTML=downDate&#125;oDownload.startDownload(@#import.htm@#,onDownloadDone)&lt;/script&gt;
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样给文件、变量和函数命名？</title>
    <url>/dev-how-to-name-better/</url>
    <content><![CDATA[前言使用user_tool.py还是user_utils.py？使用name还是username？使用user_add还是add_user？使用get_user_by_name还是get_users_by_name？等等等等，在编程活动中，我们经常会产生各种关于命名的纠结。给文件、函数、变量命名是一件很难的事，但是也是有方法的。本文中，我们就来学习一下文件、变量和函数命名的方法。
参考文档：

工程实践：给函数取一个”好”的名字
Google 开源项目风格指南 (中文版)
命名规范

命名方法要领：一看就懂，保持一致。
文件由于Windows, OSX下文件名不区分大小写(linux是区分的)，所以命名建议还是以全部小写为主。连字符可以使用中划线、下划线或者省略，关键是要统一。
目录建议连字符使用中划线，比如: my-project-name。有复数的情况使用复数命名法，比如: scripts, styles, images和data-modules。文件建议连字符使用下划线，比如：user_test.py。
变量变量命名常用的有两种方式:下划线命名法，比如: my_variable驼峰式命名法，比如: myVariale
python语言建议使用下划线命名法。
函数函数命名常用的有两种方式:下划线命名法，比如: get_user_by_name驼峰式命名法，比如: getUserByName
python语言建议使用下划线命名法。不同于变量命名的是，函数名称要使用动词开头，并且尽可能准确。
常用动词表动词选取要精准。通常来说，动词决定了一个函数要采取什么”动作”。动词取的好，一个函数名字已经成功了80%。
常用动词表：



类别
单词



添加/插入/创建/初始化/加载
add、append、insert、create、initialize、load


删除/销毁
delete、remove、destroy、drop


打开/开始/启动
open、start


关闭/停止
close、stop


获取/读取/查找/查询
get、fetch、acquire、read、search、find、query


设置/重置/放入/写入/释放/刷新
set、reset、put、write、release、refresh


发送/推送
send、push


接收/拉取
receive、pull


提交/撤销/取消
submit、cancel


收集/采集/选取/选择
collect、pick、select


提取/解析
sub、extract、parse


编码/解码
encode、decode


填充/打包/压缩
fill、pack、compress


清空/拆包/解压
flush、clear、unpack、decompress


增加/减少
increase、decrease、reduce


分隔/拼接
split、join、concat


过滤/校验/检测
filter、valid、check


常用领域词名词使用领域词汇。举个例子：集合的容量通常用capacity、集合实际元素个数用size、字符串长度用length，这种就遵循大家的使用习惯，不要用size去形如字符串的长度。
再比如，假如使用到建造者模式，那么通常会用build作为函数名字，这个时候就不要另辟蹊径，用create来作为函数名字，使用大家约定俗成的命名习惯更容易让你的代码被别人读懂。
常用名词表：



类别
单词



容量/大小/长度
capacity、size、length


实例/上下文
instance、context


配置
config、settings


头部/前面/前一个/第一个
header、front、previous、first


尾部/后面/后一个/最后一个
tail、back、next、last


区间/区域/某一部分/范围/规模
range、interval、region、area、section、scope、scale


缓存/缓冲/会话
cache、buffer、session


本地/局部/全局
local、global


成员/元素
member、element


菜单/列表
menu、list


源/目标
source、destination、target


常用缩写表1、本缩写表是《编码命名规范》的附录。
2、本缩写表中列出的都是通用性缩写，不提供标准缩写，如：Win9x、COM 等。
3、使用本缩写表里的缩写时，请对其进行必要的注释说明。
4、除少数情况以外，大部分缩写与大小写无关。





缩写
全称



addr
Address


adm
Administrator


app
Application


arg
Argument


asm
assemble


asyn
asynchronization


avg
average


DB
Database


bk
back


bmp
Bitmap


btn
Button


buf
Buffer


calc
Calculate


char
Character


chg
Change


clk
Click


clr
color


cmd
Command


cmp
Compare


col
Column


coord
coordinates


cpy
copy


ctl/ctrl
Control


cur
Current


cyl
Cylinder


dbg
Debug


dbl
Double


dec
Decrease


def
default


del
Delete


dest/dst
Destination


dev
Device


dict
dictionary


diff
different


dir
directory


disp
Display


div
Divide


dlg
Dialog


doc
Document


drv
Driver


dyna
Dynamic


env
Environment


err
error


ex/ext
Extend


exec
execute


flg
flag


frm
Frame


func/fn
Function


grp
group


horz
Horizontal


idx/ndx
Index


img
Image


impl
Implement


inc
Increase


info
Information


init
Initial/Initialize/Initialization


ins
Insert


inst
Instance


INT/intr
Interrupt


len
Length


lib
Library


lnk
Link


log
logical


lst
List


max
maximum


mem
Memory


mgr/man
Manage/Manager


mid
middle


min
minimum


msg
Message


mul
Multiply


num
Number


obj
Object


ofs
Offset


org
Origin


param
Parameter


pic
picture


pkg
package


pnt/pt
Point


pos
Position


pre/prev
previous


prg
program


prn
Print


proc
Process


prop
Properties


psw
Password


ptr
Pointer


pub
Public


rc
rect


ref
Reference


reg
Register


req
request


res
Resource


ret
return


rgn
region


scr
screen


sec
Second


seg
Segment


sel
Select


src
Source


std
Standard


stg
Storage


stm
Stream


str
String


sub
Subtract


sum
summation


svr
Server


sync
Synchronization


sys
System


tbl
Table


temp/tmp
Temporary


tran/trans
translate/transation/transparent


tst
Test


txt
text


unk
Unknown


upd
Update


upg
Upgrade


util
Utility


var
Variable


ver
Version


vert
Vertical


vir
Virus


wnd
Window


]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5和CSS3学习资料</title>
    <url>/dev-html5-and-css3-resources/</url>
    <content><![CDATA[跟KingDZ学HTML5之四 继续探究Canvas之路径http://www.cnblogs.com/hihell/archive/2150413.html
SVG 多边形http://www.runoob.com/svg/svg-polygon.html
理解SVG的图形填充规则http://blog.csdn.net/cuixiping/article/details/7848369
地理定位（navigator.geolocation）http://blog.csdn.net/smok56888/article/details/20628161
HTML5 地理位置定位（HTML5 Geolocation）原理及应用http://www.cnblogs.com/lhb25/archive/html5-geolocation-api-demo.html
HTML5 Web Worker的使用http://www.cnblogs.com/feng_013/archive/2175007.html
HTML 参考手册http://www.w3school.com.cn/tags/index.asp
HTML5 测验http://www.w3school.com.cn/quiz/quiz.asp?quiz=html5
CSS3 border-image详解、应用及jQuery插件
利用css3-animation来制作逐帧动画https://www.qianduan.net/css3-animation/
css3 box-sizing属性http://www.cnblogs.com/zhaoran/archive/3097482.html
Selectors Level 3https://www.w3.org/TR/css3-selectors/
HTML5 Trickshttp://www.html5tricks.com/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>艾佳生活</tag>
      </tags>
  </entry>
  <entry>
    <title>httpload使用说明</title>
    <url>/dev-httpload/</url>
    <content><![CDATA[httpload简介http_load可以并行启动多个http请求，以便测试Web服务器的吞吐量。但是，与大多数测试客户端不同的是，它是单线程运行的，因此不会使客户端计算机产生大量负载。此外，http_load还可以配置支持https请求。更多内容参考http_load - multiprocessing http test client。


安装1、安装openssl，以便支持https
yum install opensslyum install openssl-devel

2、下载httpload并解压
# wget http://acme.com/software/http_load/http_load-12mar2006.tar.gzwget http://www.acme.com/software/http_load/http_load-09Mar2016.tar.gztar -xzvf http_load-09Mar2016.tar.gzcd http_load-09Mar2016/

3、编辑Makefile，取消SSL相关注释
SSL_TREE =     /usr/local/sslSSL_DEFS =     -DUSE_SSLSSL_INC =      -I$(SSL_TREE)/includeSSL_LIBS =     -L$(SSL_TREE)/lib -lssl -lcrypto

4、编译不安装make执行命令后，当前目录下生成可执行文件 http_load
使用1、查看帮助./http_load --help
2、创建文件 url.list
https://www.baidu.com

3、启动测试
./http_load -s 10 -p 1 -r 10 url.list./http_load -s 180 -p 1 -r 10 -timeout 1 url.list./http_load -seconds 180 -parallel 1 -rate 10 -timeout 1 url.list]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>测试</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IDEA合并代码的个人实践</title>
    <url>/dev-idea-git-merge-code/</url>
    <content><![CDATA[前言团队合作开发，肯定会涉及到代码合并的问题。以前在代码合并的时候，喜欢使用beyond compare。同一个项目拷贝两份，一个保持最新代码，一个用于开发，开发完成后使用beyond compare把开发代码合并到最新代码。然后push到远程分支，提一个MR。后来发现，使用IDEA配合Git命令来合并代码，简直完美。本文就来记录一下这种方法，供大家参考。
已知项目名为 voidking，有很多分支，其中 pre 分支用来发布服务到预发环境，master分支用来发布服务到生产环境。代码合并后，创建pre或者prod开头的tag，触发CICD。


开发1、在github或者gitlab新建一个issue，描述清楚问题或者功能。2、针对这个issue，创建一个分支。这个分支会以issue的标题命名，前面加上issue的编号。假设生成的branch为 3-add-new-feat 。3、拉取最新代码后，本地创建自己的分支git checkout -b haojin
4、一顿复制粘贴，功能完成，commit自己的代码。
pre分支代码合并到了代码合并的步骤，表演开始。
1、拉取最新代码
git checkout mastergit pull

2、创建mergepre分支
git checkout -b mergepre origin/pre

3、使用IDEA合并代码点击界面右下角Git Branches，选择 haojin 分支，Show Diff with Working Tree。根据自己的修改，合并代码到当前的mergepre分支，修改完成后commit代码。
4、push代码
git push origin HEAD:haojin --force
需要注意的是，这里我们把mergepre的分支push到了远程的haojin分支，并没有push到 3-add-new-feat 。这是因为，3-add-new-feat这个分支我们留着，代码合并到master分支时使用。
点击出现的链接，或者在gitlab上的haojin分支点击创建MR，进入创建MR的页面。
5、选择要合并到的分支为 pre ，可以看到代码的变更，再次检查。
6、检查没问题的话，提交MR即可。
master分支代码合并以上，假设我们已经合并了自己的代码到 pre 分支。并且在预发环境发版验证通过，没有问题。接下来就可以合并代码到 master 分支了。
1、拉取最新代码
git checkout mastergit pull

2、创建mergeprod分支
git checkout -b mergeprod

3、使用IDEA合并代码点击界面右下角Git Branches，选择 haojin 分支，Show Diff with Working Tree。根据自己的修改，合并代码到当前的mergeprod分支，修改完成后commit代码。
4、push代码
git push origin HEAD:3-add-new-feat
点击出现的链接，或者在gitlab上的haojin分支点击创建MR，进入创建MR的页面。
5、选择要合并到的分支为 master ，可以看到代码的变更，再次检查。
6、检查没问题的话，提交MR即可。
]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>git</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IDEA开发Golang和Python</title>
    <url>/dev-idea-golang-python/</url>
    <content><![CDATA[前言突然发现，自己安装了三款 JetBrains 的产品：IDEA、GoLand和PyCharm。这三款软件大小差不多，长得差不多，用起来也差不多。唯一的差别，就是自己在使用不同的编程语言写代码时，需要在它们之间来回切换。能不能，只保留其中一款呢？一个IDE，所有编程语言通用，或者至少能够保证Java、Golang、Python通用。这个需求是合理的，而且是很简单的配置就可以实现的，本文就来总结一下IDEA配置开发Golang和Python的方法。


JavaIDEA本身就是适用于Java开发的，具体配置方法可以参考《IDEA的常用配置》和《使用IDEA新建Maven JavaWeb项目》。
此外，IDEA还支持Android开发，可以参考《Android开发——Android Studio》进行配置。
Golang1、菜单栏，IntelliJ IDEA，Preferences…。2、Plugins，搜索Go，找到Go插件并安装。This plugin extends IntelliJ platform with Go-specific coding assistance and tool integrations, and has everything you could find in GoLand.3、重启IDEA。菜单栏，IntelliJ IDEA，Preferences…。4、Languages &amp; Frameworks，Go。5、配置好GOROOT和GOPATH。
上面的IDEA配置，和Goland几乎相同，然后就可以像Goland一样开发Go语言程序了。
Go项目Debug的配置方法，参考《beego入门篇——下》中的调试一节。
Python配置方法参考Configure a Python SDK。
1、菜单栏，IntelliJ IDEA，Preferences…。2、Plugins，搜索Python，找到Python插件并安装。The Python plug-in provides smart editing for Python scripts. The feature set of the plugin corresponds to PyCharm IDE Professional Edition.3、重启IDEA。菜单栏，File，Project Structure…。4、Platform Settings，加号，Add Python SDK…。5、Project Settings，Project SDK，选择新添加的Python SDK。
上面的IDEA配置，和PyCharm有所不同。PyCharm中的Python SDK配置，位置在Preferences，Project: project_name。
Python项目Debug的配置方法，参考《PyCharm调试》。不同的是，如果Debug Configurations窗口点击加号，第一眼看不到Python，那么Python在Other层级下。
后记以上，IDEA就成了一个全能IDE，可以开发Java、Golang和Python。如果需要支持其他语言，同样的方法，查找并安装插件即可。Goland和PyCharm可以卸载了，nice。
]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>golang</tag>
        <tag>java</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA常用快捷键和配置</title>
    <url>/dev-idea-shortcut-and-config/</url>
    <content><![CDATA[前言工欲善其事，必先利其器。IDEA作为当今最流行的IDE之一，有很多快捷键和配置可以帮助我们更好地开发。本文记录一下自己常用的一些快捷键和配置，备忘。
快捷键查看快捷键1、菜单栏，IntelliJ IDEA，Preferences…。2、Keymap，Main menu，Refactor，Extract，Introduce Variable…。
自动补全函数返回值windows: ctrl+alt+V，回车macos: option+command+V，回车
函数跳转command+左键，command+]，command+[
代码格式化macos: option+command+L


配置idea配置maven1、打开idea，File，Settings，搜索“maven”。2、Maven home directory选择D:\Server\apache-maven-3.3.9。3、User settings file选择D:\Server\apache-maven-3.3.9\conf\settings.xml。
idea配置tomcat1、打开idea，View，勾选Toolbar，显示工具栏。
2、单击工具栏上的下三角（Select Run/Debug Configuration），Edit Configurations。
3、单击打开窗口的“+”号，Add New Configuration，Tomcat Server，Local。
4、Name修改为Tomcat8.5，JRE选择C:\Program Files\Java\jdk1.8.0_111\jre。
5、勾选Show this page，单击Fix，选择project_name:war exploded，OK。
6、单击工具栏的绿色三角，启动tomcat。
自动导包打开idea，File，Settings，Editor，General，Auto Import，界面上能勾选的全部勾选。
自动换行1、编码时自动换行Preferences &gt; Editor &gt; Code Style，勾选wrap on typing在编码时，如果超出最大行宽，则自动换行。
2、代码格式化时自动换行Preferences &gt; Editor &gt; Code Style &gt; Python，勾选 Ensure right margin is not exceeded在使用快捷键手动格式化代码时，自动换行。
批量替换换行符参考Configuring Line Separators。
为新文件配置换行符：

Press ⌘, to open IDE settings and select Editor | Code Style.
To configure line separators for new projects, go to File | New Projects Setup | Settings/Preferences for New Projects | Editor | Code Style.
The line separator style applied to the current file is indicated in the status bar.

存量文件替换换行符：

Select a file or directory in the Project tool window ⌘1.Note that if a directory is selected, the line ending style applies to all nested files recursively.

From the main menu, choose File | File Properties | Line Separators, and then select a line ending style from the list.


python代码检查pylint 是一个能够检查Python编码质量、编码规范的工具。它分析 Python 代码中的错误，查找不符合代码风格标准（Pylint 默认使用的代码风格是 PEP 8）和有潜在问题的代码。
参考文档： 

Google Python Style Guide
编码风格与自动检查
Python 编码风格与规范

pylint安装配置方法如下：
1、安装pylintpip install pylint
2、常用命令
pylint --versionpylint --help# 查看pylint安装路径which pylint# 生成配置文件pylint --persistent=n --generate-rcfile &gt; .pylintrc# 默认使用当前目录下的.pylintrc配置文件pylint test.py# 指定配置文件pylint --rcfile=.pylintrc test.py

C(convention)：规范，违反了编码风格标准W(warning)：警告，某些python特定问题E(error)：错误，可能是代码中的错误R(refactor)：重构，代码比较糟糕F(fatal error)：致命错误
3、idea配置pylintPreferences… &gt; Tools &gt; External Tools，点击 + 号添加

Name：pylint
Program：/Users/haojin01/Library/Python/2.7/bin/pylint 
Arguments：--rcfile=$ProjectFileDir$/.pylintrc $FilePath$
Working directory：$FileDir$

4、使用Tools &gt; External Tools &gt; pylint
python代码自动规范化black 是一个官方的 Python 代码格式化工具，git地址 psf/black。
black安装配置方法如下：
1、安装blackpip3 install black
2、常用命令
black --helpblack --diff test.pyblack test.pyblack --line-length 120 test.pyblack --config pyproject.toml test.py

3、官方 pyproject.toml 示例
# Example configuration for Black.# NOTE: you have to use single-quoted strings in TOML for regular expressions.# It's the equivalent of r-strings in Python.  Multiline strings are treated as# verbose regular expressions by Black.  Use [ ] to denote a significant space# character.[tool.black]line-length = 88target-version = ['py36', 'py37', 'py38']include = '\.pyi?$'extend-exclude = '''/(  # The following are specific to Black, you probably don't want those.  | blib2to3  | tests/data  | profiling)/'''# Build system information below.# NOTE: You don't need this in your own Black configuration.[build-system]requires = ["setuptools&gt;=41.0", "setuptools-scm", "wheel"]build-backend = "setuptools.build_meta"[tool.pytest.ini_options]# Option below requires `tests/optional.py`optional-tests = [  "no_python2: run when `python2` extra NOT installed",  "no_blackd: run when `d` extra NOT installed",  "no_jupyter: run when `jupyter` extra NOT installed",]

4、自动换行无效问题
black --line-length 120 test.pyblack --config pyproject.toml test.py
以上两个命令，都无效，不能实现自动换行，很奇怪，应该是个bug，先不管它。
5、idea配置blackPreferences… &gt; Tools &gt; External Tools，点击 + 号添加

Name：black
Program：/usr/local/bin/black 
Arguments：--config $ProjectFileDir$/pyproject.toml $FilePath$
Working directory：$FileDir$

6、使用Tools &gt; External Tools &gt; black
设置Python注释模板1、打开注释模板配置Preferences &gt; Editor &gt; Code Style &gt; File and Code Templates &gt;  Python Script
2、填入注释内容
#!/usr/bin/env python3# -*- coding:utf-8 -*-################################################################################## Copyright (c) 2021 Baidu.com, Inc. All Rights Reserved#################################################################################"""Authors: voidkingDate:    $&#123;DATE&#125;"""

3、新建Python文件，文件头部就会自动出现注释了。
新建文件自动git add1、打开注释模板配置Preferences &gt; Version Control &gt; Confirmation ，选择Add silently。
2、新建文件，文件会被自动git add跟踪。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
        <category>java</category>
        <category>工具</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>tomcat</tag>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ansible进行服务器初始化</title>
    <url>/dev-init-servers-by-ansible/</url>
    <content><![CDATA[前言三台CentOS7机器，一台作为ansible管理机，两台作为ansible客户机。使用ansible管理机完成两台客户机的初始化，主要包括java和tomcat的安装配置。ansible管理机IP为：192.168.56.101。ansible客户机IP为：192.168.56.102/103。 


管理机配置1、安装ansibleyum install ansible
2、生成密钥ssh-keygen
3、把公钥拷贝到客户机ssh-copy-id -i .ssh/id_rsa.pub -p 22 root@192.168.56.102
4、客户机IP写入到hostsvim /etc/ansible/hosts
[commonservers]192.168.56.102192.168.56.103

5、测试连接ansible all -m ping
客户机配置客户机不需要额外配置。
java配置1、在oracle官网下载jdk。
2、下载后上传文件到ansible管理机，假设为jdk-8u161-linux-x64.tar.gz。
3、管理机中创建jdk.env，内容为：
export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_161export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH

4、管理机中创建java-install.yml，内容为：
---- hosts: commonservers  tasks:  - name: copy jdk.tar.gz    copy:      src: ./jdk-8u161-linux-x64.tar.gz      dest: ~/jdk.tar.gz  - name: create jvm directory    shell: mkdir -p /usr/lib/jvm  - name: unzip jdk.tar.gz    shell: tar -zxf jdk.tar.gz -C /usr/lib/jvm/  - name: copy env to clients    copy:      src: ./jdk.env      dest: ~/jdk.env  - name: write jdk env to profile    shell: cat jdk.env | tee &gt;&gt; /etc/profile  - name: write jdk env to .bashrc    shell: cat jdk.env | tee &gt;&gt; /root/.bashrc  - name: make the config active    shell: source /root/.bashrc  - name: test jdk    shell: java -version    register: java_out  - name: show java result    debug: var=java_out verbosity=0

5、检查并且执行脚本  
ansible-playbook java-install.yml --syntax-checkansible-playbook java-install.yml

tomcat配置1、在apache官网下载tomcat。
2、下载后上传文件上传到ansible管理机，假设为apache-tomcat-8.0.50.tar.gz。
2、管理机创建tomcat-install.yml，内容为：
---- hosts: commonservers  tasks:  - name: copy tomcat    copy:      src: ./apache-tomcat-8.0.50.tar.gz      dest: ~/tomcat.tar.gz  - name: unzip tomcat.tar.gz    shell: tar -zxf tomcat.tar.gz -C /opt/  - name: start tomcat    shell: nohup /opt/apache-tomcat-8.0.50/bin/startup.sh &amp;  - name: test tomcat    shell: ps aux | grep tomcat    register: tomcat_out  - name: show tomcat result    debug: var=tomcat_out verbosity=0

3、检查并且执行脚本  
ansible-playbook tomcat-install.yml --syntax-checkansible-playbook tomcat-install.yml]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>iNJIT微信公众平台</title>
    <url>/dev-injit-wechat/</url>
    <content><![CDATA[南工程大计院科技立项，纯服务性质微信平台，功能内测中，感谢亲的宝贵意见！
查课表、查学科成绩、查CET成绩、查空教室、查馆藏图书，一个都不能少！
工程外卖、每日挖宝、失物招领、圈里约TA、二手交易，吃喝玩乐样样有！
工程联盟、表白墙、微信小游戏（无需下载）、吐槽灌水，无聊的日子真无聊！
男神女神、我爱抽奖、讲座报名、蹭课、搭讪、大学生活、校内活动、文字控、近期影讯、微招聘……开发进行中！
小伙伴们有什么好的建议，欢迎给我们留言!扫一扫关注iNJIT，公众号搜索injiti，更多好玩功能，等你来发现！


]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>全平台安装JDK</title>
    <url>/dev-install-jdk-on-all-platforms/</url>
    <content><![CDATA[前言经常需要安装JDK，今天在Windows上安装，明天在Ubuntu上安装，后天在CentOS上安装。本文对这三个平台的JDK安装方法和流程进行整理，一文在手，JDK我有。


Windows1、jdk下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html
2、双击安装jdk，按照提示一步一步安装即可，假设安装目录为C:\Program Files\Java\jdk1.8.0_111和C:\Program Files\Java\jre1.8.0_111。
3、添加环境变量JAVA_HOME为C:\Program Files\Java\jdk1.8.0_111。
4、在环境变量Path中添加;%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin;。
5、添加环境变量CLASSPATH为.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar;。
6、在DOS命令行窗口输入javac，输出帮助信息即为配置正确。
Ubuntu1、下载jdk8u161wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u161-b12/2f38c3b165be4555a1fa6e98c45e0808/jdk-8u161-linux-x64.tar.gz
2、解压到jvm目录mkdir -p /usr/lib/jvm
tar -xzvf jdk-8u161-linux-x64.tar.gz -C /usr/lib/jvm/
3、配置JAVA_HOME和JRE_HOME，vi /etc/profile，在最后添加：
export JAVA_HOME=/usr/lib/jvm/jdk1.8.0_161export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH
然后使配置文件生效，source /etc/profile。
4、测试jdk是否配置成功。java，javac
CentOSCentOS中可以使用和Ubuntu中相同的方法来安装JDK。除此之外，还可以使用yum命令来安装JDK，下面是安装配置流程。
1、删除自带jdk
rpm -e --nodeps `rpm -qa | grep java`

2、查看yum库中有哪些jdk版本。yum search java | grep jdk
3、选择java-1.8.0-openjdk-devel.x86_64 : OpenJDK Development Environment版本进行安装。yum install java-1.8.0-openjdk-devel.x86_64
默认安装目录为/usr/lib/jvm/，其中的文件包括：
java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64java -&gt; /etc/alternatives/java_sdkjava-1.8.0 -&gt; /etc/alternatives/java_sdk_1.8.0java-1.8.0-openjdk -&gt; /etc/alternatives/java_sdk_1.8.0_openjdkjava-openjdk -&gt; /etc/alternatives/java_sdk_openjdkjre -&gt; /etc/alternatives/jrejre-1.8.0 -&gt; /etc/alternatives/jre_1.8.0jre-1.8.0-openjdk -&gt; /etc/alternatives/jre_1.8.0_openjdkjre-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64 -&gt; java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/jrejre-openjdk -&gt; /etc/alternatives/jre_openjdk

第一个是真实目录，其他的全部都是软链接，指向/etc/alternatives/目录下的文件。有意思的是，查看/etc/alternatives/目录，里面居然也是软链接，而且指回了/usr/lib/jvm/目录！
/etc/alternatives/java_sdk -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/etc/alternatives/java_sdk_1.8.0 -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/etc/alternatives/java_sdk_1.8.0_openjdk -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/etc/alternatives/java_sdk_openjdk -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/etc/alternatives/jre -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/jre/etc/alternatives/jre_1.8.0 -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/jre/etc/alternatives/jre_1.8.0_openjdk -&gt; /usr/lib/jvm/jre-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/etc/alternatives/jre_openjdk -&gt; /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/jre......

而且，所有的java_sdk，都指向是/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64；所有的jre，都指向/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64/jre。jre_1.8.0_openjdk是个例外，也许是软件的错误。综上，/usr/lib/jvm/目录中的java、java-1.8.0、java-1.8.0-openjdk、java-openjdk、java-1.8.0-openjdk-1.8.0.212.b04-0.el7_6.x86_64是等价的，在配置JAVA_HOME的时候可以任选其一。
4、配置环境变量vim /etc/profile
在最后添加：
#set java environmentJAVA_HOME=/usr/lib/jvm/java-1.8.0JRE_HOME=$JAVA_HOME/jreCLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASS_PATH PATH

5、让修改立即生效source /etc/profile
6、查看安装结果
javajavacjava -version
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>安装部署K8S集群的艰难之路</title>
    <url>/dev-install-k8s-the-hard-way/</url>
    <content><![CDATA[前言《使用kubeadm安装部署K8S集群》一文中，使用kubeadm安装部署了k8s集群。但是，kubeadm的安装方式太简单了，而cka的要求不止这么简单。因此，我们还需要学习从零开始，一个一个组件安装配置k8s集群的方法，所谓k8s the hard way。
本文的目标是在virtualbox中，搭建一个k8s集群，一个master节点，一个node01节点。
主要参考kelseyhightower/kubernetes-the-hard-way和mmumshad/kubernetes-the-hard-way。


准备
创建两台centos7虚拟机，master节点1C2G，node01节点1C1G
配置网络，master节点IP为192.168.56.150，node01节点的IP为192.168.56.151
配置hostname，并且把两个节点的hostname添加到/etc/hosts
安装Docker，参考《Docker入门》

安装流程1、安装kubectl
2、创建CA，给每个组件生成TLS证书TLS证书包括：ETCD Server CertificateKubernetes API Server CertificateController Manager Client CertificateScheduler Client Certificate
Service Account Key PairKube Proxy Client CertificateKubelet Client CertificatesAdmin Client Certificate
3、给每个组件生成k8s配置文件，用于访问apiserver
4、生成数据加密配置和密钥，使集群支持静态加密
5、指定CA和TLS，在master节点启动etcd
6、指定CA和TLS，在master节点启动kube-apiserver、kube-controller-manager、kube-scheduler
7、指定CA和TLS，在node01节点启动kubelet和kube-proxy
8、指定CA和TLS，生成admin用户的配置文件，使用kubectl可以访问集群
9、部署weave，使pod可以获取到IP
10、部署coredns，使svc服务名可以使用
11、Smoke Test和End-to-End Tests
实践篇操作过程太长，具体还是参考前言中的两个 kubernetes-the-hard-way 文档吧。。。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>在Windows上安装mongodb</title>
    <url>/dev-install-mongodb-on-windows/</url>
    <content><![CDATA[下载mongodbmongodb官网 https://www.mongodb.com/download-center#community ，如果下载msi版本，直接按照提示安装即可。
如果下载的是zip版本，则往下接着看。


新建文件和文件夹1、解压安装包到喜欢的位置，郝同学解压到D:\Server目录下，重命名解压出来的文件夹为mongodb。
2、在mongodb文件夹下，新建文件夹data；在data下新建文件夹db和log；在log下新建文件mongodb.log。
3、在mongodb文件夹下，新建文件mongo.config，内容如下：
dbpath=D:\Server\mongodb\data\dblogpath=D:\Server\mongodb\data\log\mongodb.log

安装命令使用管理员打开cmd，输入命令：
sc create mongodb binPath="D:\Server\mongodb\bin\mongod.exe --service --config=D:\Server\mongodb\mongo.config"

至此，安装结束。使用net start mongodb，检查能否正常启动。启动后，使用mongo，检查能否正常连接。
开机自启动右击计算机，管理，服务，右击mongodb，属性，启动类型设置自动。
后记顺便推荐个mongodb可视化管理工具——Robomongo，用起来很顺手。官方地址：https://robomongo.org/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>mongodb</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mongodb</tag>
      </tags>
  </entry>
  <entry>
    <title>在CentOS上搭建Node环境</title>
    <url>/dev-install-node-in-centos/</url>
    <content><![CDATA[前言毕设进入到了最后阶段，基本功能都完成了，接下来就是一些功能的完善和bug的修改。以及，好长好长的论文要写。。。压力有点大哇！
为了方便在答辩的时候装逼，郝同学决定把毕设上线到阿里云服务器。


步骤安装node1、使用xshell登陆到阿里云服务器。2、yum -y install gcc make gcc-c++ openssl-devel wget3、wget http://nodejs.org/dist/v6.1.0/node-v6.1.0.tar.gz4、tar -zvxf node-v6.1.0.tar.gz5、cd node-v6.1.06、./configure7、make &amp;&amp; make install8、node -v
安装node方法二第一种安装node的方法，郝同学失败了，因为编译出错。那么，试试第二种方法。1、yum install epel-release2、yum install nodejs3、yum install npm4、node -v安装成功！但是版本有点低，0.12.0，因为我本地使用的5.6.0，版本不同，估计会出问题哇！
安装mongodb1、wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-3.0.6.tgz2、tar -zxvf mongodb-linux-x86_64-3.0.6.tgz3、mv  mongodb-linux-x86_64-3.0.6/ /usr/local/mongodb4、export PATH=&lt;mongodb-install-directory&gt;/bin:$PATH，其中&lt;mongodb-install-directory&gt;为/usr/local/mongodb。5、mkdir -p /data/db6、cd /usr/local/mongodb/bin，mongod，至此，mongodb已经安装成功并且启动7、使用另一个shell，cd /usr/local/mongodb/bin，mongo，连接成功，可以进行数据库的操作了。
开机自启动mongodbvim /etc/rc.d/rc.local，插入一行如下：
/usr/local/mongodb/bin/mongod


安装gityum install git
下载项目把本地项目上传到githubgit clone https://github.com/voidking/nodeforum.git
安装需要的依赖1、npm install2、npm install bower -g3、bower install有报错，整了半天没整好，后来无缘无故好了，大写的蛋疼。
运行node app.js，报错，主要是connect-mongo版本问题。大哥，出问题才正常好不，毕竟node版本相差太大。还是想办法先把node版本统一了，这才是正途！
安装node方法三1、wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.31.1/install.sh | bash2、source ~/.bash_profile3、nvm list-remote4、nvm install v5.6.05、nvm list6、nvm use v5.6.07、nvm alias default v5.6.0
再次运行node app.js，哈哈，之前的报错没有啦！然后，换了一个新的报错，无法连接到mongodb。使用mongo命令检查一下，原来是服务关掉了。为什么会关掉呢？因为我们之前的mongodb启动方法不对！在shell里启动，肯定不靠谱哇！好吧，暂时先勉强用着，在shell里再次启动mongodb。node app.js，启动成功！打开http://139.129.28.10:3000 ，看到了熟悉的界面，上线成功！
mongodb添加进服务1、mkdir -p /data/db，mkdir -p /data/log，在/data/log下新建文件mongodb.log。2、在/usr/local/mongodb下新建文件mongod.conf，内容如下：
dbpath = /data/db #数据文件存放目录logpath = /data/log/mongodb.log #日志文件存放目录port = 27017  #端口fork = true  #以守护程序的方式启用，即在后台运行
3、在/ect/rc.d/init.d下新建文件mongod，内容如下：
#!/bin/sh## mongodb init file for starting up the MongoDB server## chkconfig: - 20 80# description: Starts and stops the MongDB daemon that handles all \# database requests.# Source function library.. /etc/rc.d/init.d/functionsexec="/usr/local/mongodb/bin/mongod"prog="mongod"logfile="/data/log/mongodb.log"options=" -f /usr/local/mongodb/mongod.conf"[ -e /etc/sysconfig/$prog ] &amp;&amp; . /etc/sysconfig/$proglockfile="/var/lock/subsys/mongod"start() &#123;[ -x $exec ] || exit 5echo -n $"Starting $prog: "daemon --user root "$exec --quiet $options run &gt;&gt; $logfile 2&gt;&amp;1 &amp;"retval=$?echo[ $retval -eq 0 ] &amp;&amp; touch $lockfilereturn $retval&#125;stop() &#123;echo -n $"Stopping $prog: "killproc $progretval=$?echo[ $retval -eq 0 ] &amp;&amp; rm -f $lockfilereturn $retval&#125;restart() &#123;stopstart&#125;reload() &#123;restart&#125;force_reload() &#123;restart&#125;rh_status() &#123;# run checks to determine if the service is running or use generic statusstatus $prog&#125;rh_status_q() &#123;rh_status &gt;/dev/null 2&gt;&amp;1&#125;case "$1" instart)rh_status_q &amp;&amp; exit 0$1;;stop)rh_status_q || exit 0$1;;restart)$1;;reload)rh_status_q || exit 7$1;;force-reload)force_reload;;status)rh_status;;condrestart|try-restart)rh_status_q || exit 0restart;;*)echo $"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload&#125;"exit 2esacexit $?

4、chmod 777 mongod，给mongod文件增加执行权限。5、service mongod start，mongodb服务成功启动。
node守护进程1、安装nohup，yum provides */nohup，yum install coreutils2、启动服务，nohup node app.js &amp;3、关闭服务，bg，fg，Ctrl+C。
后来发现一个问题，nohup node app.js &amp;，断开连接后有时会关闭进程，或者输入命令后两次回车也会关闭进程。查看nohup.out文件，奥，原来是代码出问题了！如果使用命令nohup node app.js &gt; myout.file 2&gt;&amp;1 &amp;，就查看myout.file文件。
还有一点需要注意，退出xshell的时候，不要直接关闭，最好使用exit命令，否则有时也会导致进程关闭。
后记查看CentOS版本命令：cat  /etc/redhat-release查看端口占用命令：netstat -apn | grep 27017查看进程命令：ps -ef | grep mongodb，ps aux | grep mongodb，top结束进程命令：kill -9 [PID]
参考文档Centos 安装 NodeJShttp://www.cnblogs.com/hamy/p/3632574.html
Node Downloadshttps://nodejs.org/en/download/current/
如何在CentOS 7安装Node.jshttp://www.linuxidc.com/Linux/2015-02/113554.htm
Linux平台安装MongoDBhttp://www.runoob.com/mongodb/mongodb-linux-install.html
CentOS6.5源码安装nodejs4.4http://www.centoscn.com/image-text/install/2016/0314/6839.html
在CentOS 7上安装Node.js的4种方法https://www.vmvps.com/4-ways-to-install-node-js-on-centos-7-servers.html
nvm项目https://github.com/creationix/nvm
MongoDB在CentOS6下的安装以及服务启动http://www.swmemo.com/2136.html
Linux 守护进程的启动方法http://www.ruanyifeng.com/blog/2016/02/linux-daemon.html
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>node</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>毕设</tag>
        <tag>node</tag>
        <tag>nvm</tag>
      </tags>
  </entry>
  <entry>
    <title>IoC-DI的Java编程实现</title>
    <url>/dev-ioc-di-experiment/</url>
    <content><![CDATA[实验要求加深对控制反转和依赖注入的理解，使用Spring框架实现一个小的demo。
实验题目IoC-DI的Java编程实现及Spring程序设计与实现
实验原理IoC（控制反转）是一种软件设计模式，遵从了DIP（依赖倒置原则）。DI（依赖注入），是IoC的实现方式。它提供一种机制，将需要依赖（低层模块）对象的引用传递给被依赖（高层模块）对象。IoC容器：依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架）。Spring框架：IoC容器。Spring的IOC容器主要使用DI方式实现的。不需要主动查找，对象的查找、定位和创建全部由容器管理。

设计如下：数据层提供接口IPersonDao，业务逻辑层提供接口IPersonService。IPersonService的实现PersonService中通过Spring容器调用IPersonDao。测试类PersonServiceTest，通过Spring容器调用IPersonService。
目录结构：
实验代码//IPersonDao.javapackage com.voidking.ioc.dao;public interface IPersonDao &#123;		public void save();	&#125;

//PersonDaopackage com.voidking.ioc.dao.impl;import com.voidking.ioc.dao.IPersonDao;public class PersonDao implements IPersonDao &#123;	@Override	public void save() &#123;		System.out.println("------------from PersonDao.save()");	&#125;&#125;

//IPersonService.javapackage com.voidking.ioc.service;public interface IPersonService &#123;		public void processSave();&#125;

//PersonServiceTest.javapackage com.voidking.ioc.service;import org.junit.Before;import org.junit.Test;import org.springframework.beans.factory.BeanFactory;import org.springframework.context.support.ClassPathXmlApplicationContext;public class PersonServiceTest &#123;	private BeanFactory factory = null;		@Before	public void before() &#123;		factory = new ClassPathXmlApplicationContext("applicationContext.xml");	&#125;		@Test	public void testSpring() &#123;		IPersonService personService = (IPersonService) factory.getBean("personService");		personService.processSave();	&#125;&#125;

//PersonService.javapackage com.voidking.ioc.service.impl;import com.voidking.ioc.dao.IPersonDao;import com.voidking.ioc.service.IPersonService;public class PersonService implements IPersonService &#123;	private IPersonDao personDao;		public void setPersonDao(IPersonDao personDao) &#123;		this.personDao = personDao;	&#125;	@Override	public void processSave() &#123;		System.out.println("-------------from PersonService.processSave()");				personDao.save();	&#125;&#125;


applicationContext.xml配置文件内容：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"	xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context"	xsi:schemaLocation="     http://www.springframework.org/schema/beans      http://www.springframework.org/schema/beans/spring-beans-3.0.xsd     http://www.springframework.org/schema/tx      http://www.springframework.org/schema/tx/spring-tx-3.0.xsd     http://www.springframework.org/schema/aop      http://www.springframework.org/schema/aop/spring-aop-3.0.xsd     http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context-3.0.xsd"&gt;	&lt;bean id="personDao" class="com.voidking.ioc.dao.impl.PersonDao"&gt;&lt;/bean&gt;		&lt;bean id="personService" class="com.voidking.ioc.service.impl.PersonService"&gt;		&lt;property name="personDao" ref="personDao"&gt;&lt;/property&gt;	&lt;/bean&gt;	&lt;/beans&gt;

pom.xml配置文件内容：
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.voidking.ioc&lt;/groupId&gt;  &lt;artifactId&gt;ioc&lt;/artifactId&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;  &lt;name&gt;ioc Maven Webapp&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;    &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;4.11&lt;/version&gt;    &lt;/dependency&gt;        &lt;!-- 添加Spring依赖 --&gt;    &lt;dependency&gt;		&lt;groupId&gt;org.springframework&lt;/groupId&gt;		&lt;artifactId&gt;spring-core&lt;/artifactId&gt;		&lt;version&gt;3.1.1.RELEASE&lt;/version&gt;	&lt;/dependency&gt;		&lt;dependency&gt;		&lt;groupId&gt;org.springframework&lt;/groupId&gt;		&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;		&lt;version&gt;3.1.1.RELEASE&lt;/version&gt;	&lt;/dependency&gt;		&lt;dependency&gt;		&lt;groupId&gt;org.springframework&lt;/groupId&gt;		&lt;artifactId&gt;spring-context&lt;/artifactId&gt;		&lt;version&gt;3.1.1.RELEASE&lt;/version&gt;	&lt;/dependency&gt;        &lt;dependency&gt;		&lt;groupId&gt;org.springframework&lt;/groupId&gt;		&lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;		&lt;version&gt;3.1.1.RELEASE&lt;/version&gt;	&lt;/dependency&gt;	  &lt;/dependencies&gt;  &lt;build&gt;    &lt;finalName&gt;ioc&lt;/finalName&gt;  &lt;/build&gt;&lt;/project&gt;

源代码下载https://github.com/voidking/ioc.git
参考文档http://www.cnblogs.com/niuniu1985/archive/1646375.htmlhttp://www.cnblogs.com/liuhaorain/p/3747470.htmlhttp://blog.csdn.net/m13666368773/article/details/8053138
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables实现端口映射</title>
    <url>/dev-iptables-port-map/</url>
    <content><![CDATA[情景模拟有主机A，eth0的IP为内网IP：192.168.56.101，eth1为公网IP：120.77.36.222。有主机B，eth0的IP为内网IP：192.168.56.102。
可以通过外网访问主机A，主机B和主机A在同一个局域网。
想要访问外网访问主机B的Web服务，怎么办？答：使用端口映射。


具体配置开启路由功能sudo echo 1 &gt; /proc/sys/net/ipv4/ip_forward如果报错：-bash: /proc/sys/net/ipv4/ip_forward: Permission denied那就切换到root用户：sudo -iecho 1 &gt; /proc/sys/net/ipv4/ip_forward
要想永久有效，还要把/etc/sysctl.conf文件里边的net.ipv4.ip_forward的值改为1。
端口映射参考linux下用用iptables做端口映射的shell和Ubuntu 14.04 端口映射，具体配置如下：
1、新建portmap.sh，内容如下：
#!/bin/bashpro='tcp'NAT_Host='192.168.56.101'NAT_Port=3480Dst_Host='192.168.56.102'Dst_Port=80iptables -t nat -A PREROUTING -m $pro -p $pro --dport $NAT_Port -j DNAT --to-destination $Dst_Host:$Dst_Portiptables -t nat -A POSTROUTING -m $pro -p $pro --dport $Dst_Port -d $Dst_Host -j SNAT --to-source $NAT_Host

2、添加执行权限sudo chmod a+x portmap.sh
3、执行脚本sudo ./portmap.sh
4、测试访问curl 192.168.56.102，正常。curl 192.168.56.101:3480，报错curl: (7) Failed to connect to 192.168.56.103 port 3480: Connection refused。啊嘞，没有配置成功吗？莫非时因为端口没有打开？测试下3480端口：telnet 192.168.56.101 3480，报错telnet: Unable to connect to remote host: Connection refused。打开端口试试？sudo iptables -A INPUT -m state --state NEW -m tcp -p tcp --dport 3480 -j ACCEPT然而，并没有什么用！
直接用浏览器访问 http://192.168.56.101:3480 ，访问正常。。。心中万马奔腾。。。curl有坑啊！
直接用浏览器访问 http://120.77.36.222:3480 ，访问正常。
5、如果不需要端口映射了，可以删除添加的规则sudo iptables -t nat -vnL PREROUTING --line-number
sudo iptables -t nat -nL --line-number
sudo iptables -t nat -D PREROUTING 1
sudo iptables -t nat -D POSTROUTING 1
6、设置重启后依然有效参考《Linux配置SNAT上网》。
本机端口映射有主机A，eth0的IP为内网IP：192.168.56.101，eth1为公网IP：120.77.36.222。
访问 http://192.168.56.101 正常，访问 http://120.77.36.222 失败。这是因为，电信会封锁80端口和8080端口。为了使外网也可以访问80端口的服务，可以把10180端口映射为80端口。
sudo iptables -t nat -A PREROUTING -p tcp --dport 10180 -j REDIRECT --to-ports 80
然后，就可以通过 http://120.77.36.222:10180 来访问80端口的服务。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>ubuntu</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript书签</title>
    <url>/dev-javascript-bookmark/</url>
    <content><![CDATA[回调函数（callback）是什么？http://www.zhihu.com/question/19801131
读取JAVASCRIPT第一公民-函数http://www.cnblogs.com/YOUCAN/archive/2754968.html
《JAVASCRIPT语言精髓与编程实践》，周爱民http://www.chnxp.com.cn/soft/2013-12/22670.html


无废话JavaScripthttp://blog.csdn.net/aimingoo/article/details/3022379
深入理解javascript原型和闭包http://www.cnblogs.com/wangfupeng1988/p/3977987.html
JS的事件监听机制http://www.cnblogs.com/aji88/archive/2600492.html
js事件监听器用法实例详解http://www.jb51.net/article/67051.htm
HTML 最佳实践http://www.imooc.com/article/3666
Node.JS编码规范指南教程：教你优雅地写JavaScript代码
前端JavaScript规范http://www.imooc.com/article/1402
为JavaScript程序员准备的10本免费书籍http://www.imooc.com/article/1767
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模板引擎</title>
    <url>/dev-javascript-template-engine/</url>
    <content><![CDATA[前言后端渲染和前端渲染，分类依据在于浏览器到底做了什么事情。
后端渲染HTML的情况下，浏览器会直接接收到经过服务器计算之后的呈现给用户的最终的HTML字符串，这里的计算就是服务器经过解析存放在服务器端的模板文件来完成的，在这种情况下，浏览器只进行了HTML的解析，以及通过操作系统提供的操纵显示器显示内容的系统调用在显示器上把HTML所代表的图像显示给用户。
前端渲染就是指浏览器会从后端得到一些信息，这些信息或许是适用于题主所说的angularjs的模板文件，亦或是JSON等各种数据交换格式所包装的数据，甚至是直接的合法的HTML字符串。这些形式都不重要，重要的是，将这些信息组织排列形成最终可读的HTML字符串是由浏览器来完成的，在形成了HTML字符串之后，再进行显示。
根据前后端渲染的不同，模板引擎也分为两种，后端模板引擎和前端模板引擎。而前端模板引擎，就是本文要说的JavaScript模板引擎。


构建自己的JavaScript模板小引擎html部分&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;   &lt;meta charset=utf-8&gt;   &lt;title&gt;Simple Templating&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div class="result"&gt;&lt;/div&gt;&lt;script type="template" id="template"&gt;    &lt;h2&gt;      &lt;a href="&#123;&#123;href&#125;&#125;"&gt;        &#123;&#123;title&#125;&#125;      &lt;/a&gt;    &lt;/h2&gt;    &lt;img src="&#123;&#123;imgSrc&#125;&#125;" alt="&#123;&#123;title&#125;&#125;"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

仿造ajax获取的数据var data = [    &#123;      title: "Knockout应用开发指南",      href: "http://www.cnblogs.com/TomXu/archive/2257154.html",      imgSrc: "http://images.cnblogs.com/cnblogs_com/TomXu/339203/o_knockout2.jpg"    &#125;,    &#123;      title: "微软ASP.NET站点部署指南",      href: "http://www.cnblogs.com/TomXu/archive/2263050.html",      imgSrc: "http://images.cnblogs.com/cnblogs_com/TomXu/339203/o_vs.jpg"    &#125;,    &#123;      title: "HTML5学习笔记简明版",      href: "http://www.cnblogs.com/TomXu/archive/2277499.html",      imgSrc: "http://images.cnblogs.com/cnblogs_com/TomXu/339203/o_LearningHtml5.png"    &#125;];

变量替换方法一template = document.querySelector('#template').innerHTML,result = document.querySelector('.result'),i = 0, len = data.length,fragment = ''; for ( ; i &lt; len; i++ ) &#123;    fragment += template      .replace( /\&#123;\&#123;title\&#125;\&#125;/, data[i].title )      .replace( /\&#123;\&#123;href\&#125;\&#125;/, data[i].href )      .replace( /\&#123;\&#123;imgSrc\&#125;\&#125;/, data[i].imgSrc );&#125; result.innerHTML = fragment;

变量替换方法二template = document.querySelector('#template').innerHTML,result = document.querySelector('.result'),attachTemplateToData; // 将模板和数据作为参数，通过数据里所有的项将值替换到模板的标签上（注意不是遍历模板标签，因为标签可能不在数据里存在）。attachTemplateToData = function(template, data) &#123;    var i = 0,        len = data.length,        fragment = '';     // 遍历数据集合里的每一个项，做相应的替换    function replace(obj) &#123;        var t, key, reg; 　　　　　　　　　　//遍历该数据项下所有的属性，将该属性作为key值来查找标签，然后替换        for (key in obj) &#123;            reg = new RegExp('&#123;&#123;' + key + '&#125;&#125;', 'ig');            t = (t || template).replace(reg, obj[key]);        &#125;         return t;    &#125;     for (; i &lt; len; i++) &#123;        fragment += replace(data[i]);    &#125;     return fragment;&#125;; result.innerHTML = attachTemplateToData(template, data);

参考文档最简单的JavaScript模板引擎http://www.cnblogs.com/dolphinX/p/3489269.html
大叔手记（7）：构建自己的JavaScript模板小引擎http://www.cnblogs.com/TomXu/archive/2284752.html
JavaScript Micro-Templatinghttp://ejohn.org/blog/javascript-micro-templating/
JavaScript模板引擎原理，几行代码的事儿http://www.cnblogs.com/hustskyking/p/principle-of-javascript-template.html
全球最快的JS模板引擎https://cnodejs.org/topic/5490e8ca4823a0234c9e1767
Arttemplate by auihttp://aui.github.io/artTemplate/
laytpl官网http://laytpl.layui.com/
后端渲染html、前端模板渲染html，jquery的html，各有什么区别？http://www.zhihu.com/question/28725977/answer/42077482
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>jira简单使用</title>
    <url>/dev-jira-start/</url>
    <content><![CDATA[新建sprintsprint，全速短跑。新建sprint，也就是新建一轮迭代。1、在顶部导航栏选择项目，打开项目。2、单击左侧导航栏Backlog（积压未办之事，存货），打开Backlog页面。3、单击“create sprint”按钮，创建sprint。4、单击新建的sprint名称，重命名该sprint。


添加issuesissues包括Task、Story、Bug、Epic，常用Task和Bug。
1、在backlog页面，把issues拉入新建的sprint。2、单击任意issue，右侧显示issue详情（此处可以选择把该issue分配给自己）。
更新issue1、单击左侧导航栏Active sprints，打开active sprints页面。2、在active sprints页面，可以看到issues进度，并且可以改变issue进度。
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>jira</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA与Hibernate的关系</title>
    <url>/dev-jpa-and-hibernate/</url>
    <content><![CDATA[名词解释JPA：Java Persistence API，是Java EE 5的标准ORM接口，也是ejb3规范的一部分。JPA通过JDK5.0注解或XML描述对象-关系表的映射关系，并将运行期实体对象持久化到数据库中去。
ORM：Object-Relational Mapping，对象关系映射，即实体对象和数据库表的映射。
Hibernate：是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。
JPA与Hibernate的关系JPA和Hibernate之间的关系，可以简单的理解为JPA是标准接口，Hibernate是实现。

Hibernate主要通过hibernate-annotation、hibernate-core和hibernate-entitymanager三个组件来实现与JPA的关系。
hibernate-annotation是Hibernate支持annotation方式配置的基础，它包括了标准的JPA annotation以及Hibernate自身特殊功能的annotation。
hibernate-core是Hibernate的核心实现，提供了Hibernate所有的核心功能。
hibernate-entitymanager实现了标准的JPA，可以把它看成hibernate-core和JPA之间的适配器，它并不直接提供ORM的功能，而是对hibernate-core进行封装，使得Hibernate符合JPA的规范。
参考文档http://blog.163.com/hero_213/blog/static/398912142010312024809/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jpa</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery书签</title>
    <url>/dev-jquery-bookmark/</url>
    <content><![CDATA[从零开始学习jQuery (一) 开天辟地入门篇http://kb.cnblogs.com/page/46450/
jQuery APIhttp://jquery.cuishifeng.cn/
jQuery API资源专属下载页http://www.cuishifeng.cn/down.html


jQuery基础课程http://www.imooc.com/learn/11
CodePlayerhttp://www.365mini.com/
html中offsetTop、clientTop、scrollTop、offsetTop各属性介绍http://blog.csdn.net/fswan/article/details/17238933
值得 Web 开发人员学习的20个 jQuery 实例教程http://www.cnblogs.com/lhb25/p/20-must-have-jquery-tutorials.html
jQuery Mobilehttp://jquerymobile.com/
HTML5+JS手机web开发之jQuery Mobile初涉
10个优秀的jQuery Mobile主题http://caibaojian.com/10-best-free-jquery-mobile-theme.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery本地无法加载解决办法</title>
    <url>/dev-jquery-cannot-local-load/</url>
    <content><![CDATA[问题描述环境：win7+apache2.2+php5.2
症状：jquery包文件(jquery-1.4.2.min.js)在本地测试的时候加载失败，通过firebug查看，发现文件被加载了两次，但每次都加载不完全。直接引用外部的jquery包就OK，比如http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js


解决办法参考Can’t load jquery on Apache，将httpd.conf中的
#EnableMMAP off#EnableSendfile off
注释去掉，重启apache，在firefox下马上就生效了，在ie下需要删除下缓存。
这两个参数在httpd.conf有作了一些注释
## EnableMMAP and EnableSendfile: On systems that support it, # memory-mapping or the sendfile syscall is used to deliver# files.  This usually improves server performance, but must# be turned off when serving from networked-mounted # filesystems or if support for these functions is otherwise# broken on your system.#

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery学习笔记——概述篇</title>
    <url>/dev-jquery-start/</url>
    <content><![CDATA[jQuery是什么jQuery是一个兼容多浏览器的Javascript库，类似于C语言中的”.h”文件和Java中的”.jar” 文件。
核心理念是write less,do more(写得更少,做得更多)。
jQuery是免费、开源的，使用MIT许可协议。jQuery的语法设计可以使开发者更加便捷，例如操作文档对象、选择DOM元素、制作动画效果、事件处理、使用Ajax以及其他功能。除此以外，jQuery提供API让开发者编写插件。其模块化的使用方式使开发者可以很轻松的开发出功能强大的静态或动态网页。
jQuery能够做什么1、简化编程。jQuery最大的优点，是简化了Javascript编程。本来需要很多行代码才能完成的功能，使用jQuery，时常一两行就够了。
2、跨平台。使用Javascript开发，是一件痛苦的事情，因为你不得不考虑到各种浏览器的兼容问题。而使用jQuery，你编写的程序可以很容易地实现跨浏览器平台。

jQuery简史jQuery在2006年1月由美国人John Resig在纽约的barcamp发布，吸引了来自世界各地的众多JavaScript高手加入，由Dave Methvin率领团队进行开发。
如今，jQuery已经成为最流行的javascript库，在世界前10000个访问最多的网站中，有超过55%在使用jQuery。
在写这篇文章的时候，在谷歌搜索jQuery，返回大约 85,900,000条结果。jQuery每天都有新的官方插件和第三方插件产生，它们不断扩展jQuery的核心功能。
hello voidkingC语言写的第一个程序是helloworld，今天，void自恋一把，第一个程序就和自己打招呼了！
1、官网下载jQuery文件（这里我使用的是jquery-1.10.2.js）。
2、新建index.html文件，内容如下：
&lt;html&gt;&lt;head&gt;		&lt;script type="text/javascript" src="jquery-1.10.2.js"&gt;&lt;/script&gt;	&lt;script type="text/javascript"&gt;		$(function()&#123;			alert("hello voidking");			$("p").css("color","red");		&#125;);	&lt;/script&gt;&lt;/head&gt;&lt;body&gt;	&lt;p&gt;		welcome to jQuery world !	&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

3、打开浏览器，看到弹出的对话框了吧？大功告成！下面的内容，会对此程序作出解释。
$jQuery的一切功能都源自”$”对象，即一个美元符号对象（或美元符号方法），它可以用”jQuery”来代替。
美元符号既是一个对象，也是一个方法。这是因为它具有很多成员属性和方法可以调用，同时可以把它当成一个函数来调用。
延迟加载我们在hellovoidking的代码中，使用$(function(){});进行首尾包裹，那么为什么要包裹这段代码呢？原因是，jQuery库文件是在body元素之前加载的，我们必须等待所有的DOM元素加载后，延迟支持DOM操作，否则就无法获取到。
为了延迟等待加载，JavaScript提供了一个事件为load，方法如下：
window.onload = function()&#123;&#125;;
而jQuery提供的方法如下：
$(document).ready(function()&#123;&#125;);
什么东东？和hello voidking中的代码不一样啊？原来，jQuery的延迟加载方法可以简写为：
$(function()&#123;&#125;);

jQuery选择器jQuery最核心的组成部分就是：选择器引擎。用iPhone式的格言来说，“让选择器完成一切”就是jQuery的座右铭。
在使用jQuery的任何方法时，首先要做的就是选择页面中要操作的那些元素。
jQuery选择器继承了CSS的语法，可以对DOM元素的标签名、属性名、状态等进行快速准确的选择，并且不必担心浏览器的兼容性。jQuery选择器实现了CSS1~CSS3的大部分规则之外，还实现了一些自定义的选择器，用于各种特殊状态的选择。
选择器部分内容很多，我会在下一篇文章中详细研究探讨。
事件处理对于事件的概念，我在《Javascript学习笔记——基础篇》中已经解释过，这里不再赘述。jQuery的事件处理，内容也很多，我会在接下来的文章中探究。
AjaxjQuery的Ajax也是重点，必须的展开。我靠，肿么这么多！别吐槽了帅哥，写教程的void都快哭了，赶着去搞XMPP呢！
调试个人喜欢的工具是：火狐浏览器 + firebug。
结束语jQuery博大精深，还有什么单元测试、插件、特效制作啥的，void就不多说了，感兴趣的小伙伴自己查找资料吧！
参考文档李炎恢的jQuery视频教程《jQuery攻略（作者B.M.Harwani）》《jQuery实战（作者Bear Bibeault、Yehuda Katz）》《jQuery高级编程（作者 Cesar Otero、Rob Larsen）》《jQuery Javascript 与CSS开发入门经典（作者Richard York）》
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>瀑布流特效</title>
    <url>/dev-jquery-waterfall/</url>
    <content><![CDATA[原理假设页面上有三列图片，当我们下拉时，最短（或最长）的一列图片展示完的时候，就要请求加载新的图片，获取到的新的图片放到最短一列图片的下面。
尝试过用原生js或jquery实现瀑布流，源码放在本文最后。下面记录一种使用imageloaded和masonry插件实现的瀑布流，更简便。


imageloaded和masonryejs代码：
&lt;div id="meitulist" class="meitulist"&gt;    &lt;% data.obj.pictureList.forEach(function(picture)&#123; %&gt;        &lt;a href="/inspiration/imagedetail/&lt;%= picture.albumId%&gt;" class="item"&gt;            &lt;img src="&lt;%= picture.url%&gt;" /&gt;        &lt;/a&gt;    &lt;% &#125;)%&gt;&lt;/div&gt;

每次加载图片并插入后，执行resetImage()函数。
function resetImage()&#123;    var width = document.documentElement.clientWidth;    var column = width&gt;320? 3 : 2;    var itemWidth = Math.ceil((width-(column+1)*10)/column);    $('.meitulist .item').css('width',itemWidth);    $('.meitulist .item img').css(&#123;        'width':itemWidth        // 'height': itemWidth    &#125;)    window.imagesLoaded('#meitulist', function() &#123;        var msnry = new Masonry('#meitulist',&#123;            'columnWidth': itemWidth,            'itemSelector': '.item',            'isAnimated':true,            // 'percentPosition':true,            'gutter': 10        &#125;);    &#125;);&#125;

js和jquery源码https://github.com/voidking/front-end-demo/tree/master/%E7%80%91%E5%B8%83%E6%B5%81
参考文档瀑布流特效http://www.cnblogs.com/Leo_wl/p/4306295.html
Masonry官网http://masonry.desandro.com/
mosonry项目地址：https://github.com/desandro/masonry
imagesLoaded官网http://imagesloaded.desandro.com/
imagesloaded项目地址：https://github.com/desandro/imagesloaded
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>插件</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter调试</title>
    <url>/dev-jupyter-debug/</url>
    <content><![CDATA[前言除了PyCharm，另一个常用的编辑器就是Jupyter了。本文研究记录一下Jupyter的调试方法。


使用1、在jupyter中新建文件，运行如下代码：
def func1(a,b):    return a/bdef func2(x):    a=x    b=x-1    return func1(a,b)func2(1)
出现报错：
2、出错后，输入%debug，进入调试模式。调试模式会进入直接出错函数func1，我们可以在调试模式自带的对话框中输入变量名来查看函数中的变量情况，输入“quit”则退出该模式。
同时，在调试模式下，我们也可以通过输入“up”来对外层函数进行调试，查看其中的变量情况。同样的，也可以通过“down”进入内层函数。
3、在notebooke中执行 %pdb on 可以设置为当异常发生时自动进入调试模式，在某些特殊的情况下，这么做可能会更为方便：
def func1(a,b):    return a/bdef func2(x):    a=x    b=x-1    return func1(a,b)%pdb onfunc2(1)


书签Python Jupyter Notebook 中的错误异常与代码调试
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>jupyter</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>使用client-go操作K8S</title>
    <url>/dev-k8s-client-go/</url>
    <content><![CDATA[client-go简介直观上看，用户可以使用kubectl、客户端库或者REST请求来访问K8S API。而实际上，无论是kubectl还是客户端库，都是封装了REST请求的工具。client-go作为一个客户端库，能够调用K8S API，实现对K8S集群中资源对象（包括deployment、service、ingress、replicaSet、pod、namespace、node等）的增删改查等操作。源码地址：kubernetes/client-go接口文档：kubernetes - GoDoc


通过REST访问K8S《K8S入门篇》一文中使用kubectl对minikube进行管理，本节中直接使用REST请求来对minikube进行管理。参考Access Clusters Using the Kubernetes API，来测试一下。
kubectl处理API服务器的定位和身份验证。如果要使用curl或wget等http客户端或浏览器直接访问REST API，可以通过多种方式查找和验证API服务器：（1）在代理模式下运行kubectl（推荐）。建议使用此方法，因为它使用存储的apiserver位置并使用自签名证书验证API服务器的标识。使用此方法无法进行中间人（MITM）攻击。（2）直接向http客户端提供位置和凭据。这适用于被代理混淆的客户端代码。为了防止中间人攻击，需要将根证书导入浏览器。使用Go或Python客户端库可以在代理模式下访问kubectl。
启动minikube，查看集群配置
minikube startkubectl config view

查看kubectl访问了什么url，获得了什么信息。
kubectl get nodes -v=8kubectl get nodes -v=9

kubectl代理模式充当反向代理模式下运行kubectl，它处理定位API服务器和进行身份验证。
kubectl proxy --port=8080 &amp;curl http://localhost:8080/api/
此时使用浏览器进行访问，同样可以拿到数据。
grep/cut方法# Check all possible clusters, as you .KUBECONFIG may have multiple contexts:kubectl config view -o jsonpath='&#123;"Cluster name\tServer\n"&#125;&#123;range .clusters[*]&#125;&#123;.name&#125;&#123;"\t"&#125;&#123;.cluster.server&#125;&#123;"\n"&#125;&#123;end&#125;'# Select name of cluster you want to interact with from above output:# export CLUSTER_NAME="some_server_name"export CLUSTER_NAME="minikube"# Point to the API server refering the cluster nameAPISERVER=$(kubectl config view -o jsonpath="&#123;.clusters[?(@.name==\"$CLUSTER_NAME\")].cluster.server&#125;")# Gets the token valueTOKEN=$(kubectl get secrets -o jsonpath="&#123;.items[?(@.metadata.annotations['kubernetes\.io/service-account\.name']=='default')].data.token&#125;"|base64 -d)# Explore the API with TOKENcurl -X GET $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure


jsonpath方法APISERVER=$(kubectl config view --minify -o jsonpath='&#123;.clusters[0].cluster.server&#125;')TOKEN=$(kubectl get secret $(kubectl get serviceaccount default -o jsonpath='&#123;.secrets[0].name&#125;') -o jsonpath='&#123;.data.token&#125;' | base64 --decode )curl $APISERVER/api --header "Authorization: Bearer $TOKEN" --insecure


client-go操作K8Sclient-go实际上是封装了REST请求的客户端库，能够简化我们的工作。
参考k8s-client-go项目，对k8s进行一些基本操作，包括连接k8s，创建更新deployment，查看deployment状态，查看pod状态等。在使用该项目之前，需要获取k8s集群的配置信息：kubectl config view把配置信息拷贝一下，粘贴到项目中的admin.conf文件中即可。
此外，k8s-client-go项目依赖client-go，因此需要参考《Golang包管理工具》安装好依赖。
后记本文中学习了client-go的安装方法，然后借助k8s-client-go项目学习了client-go的基本用法。接下来，使用client-go实现在K8S集群中发布项目，go！go！go！
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>golang</tag>
        <tag>docker</tag>
        <tag>client-go</tag>
        <tag>kubectl</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S中的网络策略</title>
    <url>/dev-k8s-network-policy/</url>
    <content><![CDATA[怎样限制Pod中的网络流量？已知pod名为 webapp ，label为 name=webapp 。现在想要模拟无法访问数据库，限制它的流量，禁止它访问 10.0.0.0/24 网段的所有3306端口，该怎么实现？
方法一：使用NetworkPolicy限流方法二：开启pod特权模式，在pod内部使用iptables限流方法三：登录pod所在宿主机，在pod所在ns中使用iptables限流


NetworkPolicy网络策略（NetworkPolicy）是一种关于 Pod 间及与其他网络端点间所允许的通信规则的规范。NetworkPolicy 资源使用 标签 选择 Pod，并定义选定 Pod 所允许的通信规则。
网络策略通过网络插件来实现。要使用网络策略，用户必须使用支持 NetworkPolicy 的网络解决方案。创建一个资源对象，而没有控制器来使它生效的话，是没有任何作用的。
默认情况下，Pod 是非隔离的，它们接受任何来源的流量。Pod 可以通过相关的网络策略进行隔离。一旦命名空间中有网络策略选择了特定的 Pod，该 Pod 会拒绝网络策略所不允许的连接。 (命名空间下其他未被网络策略所选择的 Pod 会继续接收所有的流量)网络策略不会冲突，它们是附加的。如果任何一个或多个策略选择了一个 Pod, 则该 Pod 受限于这些策略的 ingress/egress 规则的并集。因此评估的顺序并不会影响策略的结果。
更多内容参考网络策略和NetworkPolicy最佳实践。
基础规则：

如果 Pod 没有被 NetworkPolicy 匹配到，那么它的流量是被允许的 
如果 Pod 被 NetworkPolicy 匹配到，但是没有出口/入口规则被匹配到，那么它的出口/入口流量是被禁止的
只能指定规则来允许流量通行，而不能直接禁止流量通行
NetworkPolicy 中的 Rule 之间的匹配逻辑是 OR
NetworkPolicy 默认的作用域是 Pod 所在的 Namespace

1、创建np.yaml
apiVersion: networking.k8s.io/v1kind: NetworkPolicymetadata:  name: webapp-network-policy  namespace: defaultspec:  podSelector:    matchLabels:      name: webapp  policyTypes:  - Ingress  - Egress  ingress:  - &#123;&#125;  egress:  - to:    - ipBlock:        cidr: 0.0.0.0/0        except:         - 10.0.0.0/24

这种实现方式，其实有一个问题，就是限流时不止限制了3306端口，还限制了 10.0.0.0/24 网段的所有端口。能不能只限制 10.0.0.0/24 网段的 3306 端口呢？理论上可以实现，然而我不会。。。
2、执行限流
kubectl apply -f np.yaml

3、解除限流
kubectl delete -f np.yaml

pod特权模式限流1、在pod定义中添加：
securityContext:  privileged: true  #runAsUser: 0

2、在pod内部执行限流
iptables -A OUTPUT -p tcp --dport 3306 -j DROP

3、解除限流
iptables -t nat -nL --line-numberiptables -D OUTPUT 1

宿主机限流1、登录宿主机
2、查找容器pid
docker ps | grep webappdocker inspect &lt;container_id&gt; | grep pid -i

3、执行限流
nsenter -t &lt;pid&gt; -n iptables -A OUTPUT -p tcp --dport 3306 -j DROP

4、解除限流
nsenter -t &lt;pid&gt; -n iptables -t nat -nL --line-numbernsenter -t 8993 -n iptables -D OUTPUT 1


]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes Operator</title>
    <url>/dev-k8s-operator/</url>
    <content><![CDATA[Kubernetes Operator是啥？
Operators are software extensions to Kubernetes that make use of custom resources to manage applications and their components. Operators follow Kubernetes principles, notably the control loop.

Operator 是 Kubernetes 的扩展软件，通过自定义资源，管理应用及其组件。 Operator 遵循 Kubernetes 的理念，特别是在控制回路方面。
Kubernetes自定义资源包括Custom resources 和 Custom controllers。
Operator 模式旨在捕获（正在管理一个或一组服务的）运维人员的关键目标。负责特定应用和service的运维人员，在系统应该如何运行、如何部署以及出现问题时如何处理等方面有深入的了解。在 Kubernetes 上运行工作负载的人们都喜欢通过自动化来处理重复的任务。Operator 模式会封装我们编写的（Kubernetes 本身提供功能以外的）任务自动化代码。
Operator可以自动化的事情包括：

按需部署应用
获取/还原应用状态的备份
处理应用代码的升级以及相关改动。例如，数据库 schema 或额外的配置设置
发布一个 service，要求不支持 Kubernetes API 的应用也能发现它
模拟整个或部分集群中的故障以测试其稳定性
在没有内部成员选举程序的情况下，为分布式应用选择首领角色

简单来说，Kubernetes实际是期望状态管理器，如果Kubernetes本身提供的功能无法达到期望状态，特别是对于有状态应用，那么就需要手动处理，而Operator可以使这种处理自动化。
更多内容，参考Operator 模式。
本文中，将会学习编写一个Operator，并应用到k8s集群。


工具Operator的yaml文件和go文件，可以纯手写，没毛病。但是使用工具能够提高我们的编写效率。编写Operator的工具有：

KUDO，Kubernetes 通用声明式 Operator)
kubebuilder
Metacontroller，可与 Webhook 结合使用，以实现自己的功能。
Operator Framework

查找和分享Operator：OperatorHub
Operator FrameworkOperator Framework是一个开源工具包，用来管理被称为operators的k8s应用程序，高效、自动化、可扩展。它的两个核心部分是Operator SDK 和 Operator Lifecycle Manager 。
Operator SDK：允许开发人员根据专业知识来构建Operator，而无需了解Kubernetes API的复杂性。Operator Lifecycle Manager：帮助用户安装、更新和总体管理跨集群运行的所有Operators（及其相关服务）的生命周期。
在开发机上安装Operator SDK，在集群中安装Operator Operator Lifecycle Manager。
对于这两个组件，可以在katacoda上试玩，熟悉它们的安装和使用，Building Operators on OpenShift。
第一个Operator参考Kubernetes Operator 快速入门教程，使用Operator Framework开发一个Operator应用，代码仓库cnych/opdemo。
书签Introducing Operators: Putting Operational Knowledge into SoftwareBest practices for building Kubernetes Operators and stateful apps揭秘Kubernetes Operator（一）第一次玩 operator-sdk 就上手
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>源码</tag>
        <tag>golang</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S集群中etcd备份和恢复</title>
    <url>/dev-k8s-etcd-backup-restore/</url>
    <content><![CDATA[前言就像备份数据库一样，很多时候，我们也想对k8s资源配置进行备份。
kubectl get all --all-namespaces -o yaml &gt; all-deploy-services.yaml
上面的方法，可以实现对k8s资源配置的备份。但是更好的办法，是对etcd进行备份。本文就学习一下k8s中etcd的备份和恢复方法。


etcd集群状态HOST_1=10.240.0.17HOST_2=10.240.0.18HOST_3=10.240.0.19ENDPOINTS=$HOST_1:2379,$HOST_2:2379,$HOST_3:2379etcdctl --endpoints=$ENDPOINTS member listetcdctl --write-out=table --endpoints=$ENDPOINTS endpoint statusetcdctl --endpoints=$ENDPOINTS endpoint health

备份1、查看配置
kubectl describe pod etcd-master -n kube-system | grep Command -i -A 20
看到Command字段为：
Command:  etcd  --advertise-client-urls=https://172.17.0.10:2379  --cert-file=/etc/kubernetes/pki/etcd/server.crt  --client-cert-auth=true  --data-dir=/var/lib/etcd  --initial-advertise-peer-urls=https://172.17.0.10:2380  --initial-cluster=master=https://172.17.0.10:2380  --key-file=/etc/kubernetes/pki/etcd/server.key  --listen-client-urls=https://127.0.0.1:2379,https://172.17.0.10:2379  --listen-metrics-urls=http://127.0.0.1:2381  --listen-peer-urls=https://172.17.0.10:2380  --name=master  --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt  --peer-client-cert-auth=true  --peer-key-file=/etc/kubernetes/pki/etcd/peer.key  --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt  --snapshot-count=10000  --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt

或者查看/etc/kubernetes/manifests/etcd.yaml。
2、执行备份
ETCDCTL_API=3 etcdctl \--endpoints=https://[127.0.0.1]:2379 \--cacert=/etc/kubernetes/pki/etcd/ca.crt \--cert=/etc/kubernetes/pki/etcd/server.crt \--key=/etc/kubernetes/pki/etcd/server.key \snapshot save /tmp/snapshot-pre-boot.db

3、查看备份
ETCDCTL_API=3 etcdctl \--endpoints=https://[127.0.0.1]:2379 \--cacert=/etc/kubernetes/pki/etcd/ca.crt \--cert=/etc/kubernetes/pki/etcd/server.crt \--key=/etc/kubernetes/pki/etcd/server.key \snapshot status /tmp/snapshot-pre-boot.db -w table

恢复1、恢复etcd数据
ETCDCTL_API=3 etcdctl \--endpoints=https://[127.0.0.1]:2379 \--cacert=/etc/kubernetes/pki/etcd/ca.crt \--cert=/etc/kubernetes/pki/etcd/server.crt \--key=/etc/kubernetes/pki/etcd/server.key \--initial-cluster=master=https://127.0.0.1:2380 \--initial-cluster-token etcd-cluster-1 \--initial-advertise-peer-urls=https://127.0.0.1:2380 \--name=master \--data-dir /var/lib/etcd-from-backup \snapshot restore /tmp/snapshot-pre-boot.db

2、修改etcd.yamlvim /etc/kubernetes/manifests/etcd.yaml，如下修改：
# Update --data-dir to use new target location--data-dir=/var/lib/etcd-from-backup# Update new initial-cluster-token to specify new cluster--initial-cluster-token=etcd-cluster-1# Update volumes and volume mounts to point to new path    volumeMounts:    - mountPath: /var/lib/etcd-from-backup      name: etcd-data    - mountPath: /etc/kubernetes/pki/etcd      name: etcd-certs  hostNetwork: true  priorityClassName: system-cluster-critical  volumes:  - hostPath:      path: /var/lib/etcd-from-backup      type: DirectoryOrCreate    name: etcd-data  - hostPath:      path: /etc/kubernetes/pki/etcd      type: DirectoryOrCreate    name: etcd-certs]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Kaggle</title>
    <url>/dev-kaggle/</url>
    <content><![CDATA[前言本文转载自优达学城《机器学习工程师》
Kaggle 是一个极受欢迎的数据科学和机器学习挑战平台，有着极为活跃和不断壮大的社区。Kaggle 成员不仅可以争夺积分榜上的排名，公司和研究实验室在此提出的某些挑战题还设有丰厚奖金。
Kaggle 为您提供解决复杂现实问题的机会，您可通过解决这些问题磨练您的机器学习技巧，如果你的 Kaggle 个人页面中有积极参与和表现良好的记录，可以让你在申请工作时更具优势。


开始准备好成为 Kaggle 的一员了吗？
1、前往 Kaggle 网站，并注册账号。看一下 进行中的竞赛，有没有你感兴趣的项目？
2、选择一个项目，根据指导说明获取数据，编写并运行您的算法，最后提交解决方案。
3、如果你觉得这些项目过于复杂，可以查看以下内容：

泰坦尼克号竞赛教程
数字识别
面部特征点检测
Julia 入门教程

Kaggle 脚本使用 Kaggle脚本，你无需设置你的电脑（或下载所有数据），便可轻松开始解决挑战问题。
创建脚本选择一个竞赛或数据集，单击新脚本（New Script）或新记事本（New Notebook），选择你的语言偏好。
一般情况下，程序已为你提供了一些初始代码，教你如何下载所需数据。修改并运行代码，以浏览输出日志。你可直接在脚本中提交挑战的输出文件（格式通常为 .csv），很简单，对吧？
Fork 一个已有脚本Kaggle 成员通常会将自己的解决方案提供给其他参赛者浏览和参考，请在竞赛的控制面板（Dashboard）中寻找脚本。
例如，与数字识别挑战有关的所有脚本都可在这里找到。让我们选择一个来详细了解：在 Python 中实现的简单感知分类器（一个单层神经网络）。点击 Fork 脚本（Fork Script ）或 Fork 记事本（Fork Notebook）按钮来运行或修改脚本。
社群成为 Kaggle 成员不仅意味着你可以乐此不疲地解决多种挑战，并为此付出每一份精力（我相信你的精力是源源不断的），你还会成为数据科学家和机器学习工程师社群的一员，为解决当今社会所面临的诸多实际问题贡献一份力量。
如果你在解决挑战中遇到困难或需要建议，请前往论坛寻找相关信息，论坛中也会有一些他人的问题你能够回答。其他资源可参考此 wiki 网页。
你可以在 Kaggle 的名为 no free hunch 的官方博客中了解到竞赛、新功能和平台变化等方面的最新情况。例如，这篇文章介绍了 Kaggle 的一位顶级成员。
你的 Kaggle 个人主页你可以在你公开的 Kaggle 个人主页上查阅你在不同竞赛中的排名和表现： 

https://www.kaggle.com/&lt;输入你的 Kaggle 用户名&gt;

请在个人主页中填写你的准确信息，提供社交编码平台（如 GitHub）和专业网站（如领英）的链接，并定期更新。我们也欢迎你提供你的优达学城个人主页链接。
工作Kaggle 有一个专门的求职版块，你可能会在这里找到令你心动的职位。在 Kaggle 竞赛中的良好表现能使你脱颖而出。你在纳米学位项目中取得进展的同时，请继续尝试解决各项挑战，构建良好的档案记录。如果你正在寻找工作， 在申请时不要忘了利用这个资源。
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>KISSY入门篇</title>
    <url>/dev-kissy-start/</url>
    <content><![CDATA[WHAT IS KISSY ?KISSY 是一款跨终端、模块化、高性能、使用简单的 JavaScript 框架。除了完备的工具集合如 DOM、Event、Ajax、Anim 等，它还提供了经典的面向对象、动态加载、性能优化解决方案。作为一款全终端支持的 JavaScript 框架，KISSY 为移动终端做了大量适配和优化，让你的程序在全终端均能流畅运行。

引入KISSY1、引入线上kissy。
&lt;script src="http://g.alicdn.com/kissy/k/1.4.7/seed.js"&gt;&lt;/script&gt;

2、引入本地kissy。
&lt;script src="./lib/kissy-1.3.2/build/seed.js"&gt;&lt;/script&gt;

hello world1、启动：Hello World!
KISSY.ready(function(S)&#123;    alert('Hello World!');&#125;);

2、DOM操作：获取一个className叫continue的button，并将它的内容改为”Hello Kissy”。
KISSY.use('node',function(S,Node)&#123;    Node.one('button.continue').html('Hello Kissy!');&#125;);

3、事件处理：点击一个id为click-me的button，显示#banner-msg的内容。
KISSY.use('node',function(S,Node)&#123;    Node.one('#click-me').on('click',function(e)&#123;        Node.one('#banner-msg').show();    &#125;);&#125;);

4、Ajax：请求本地数据/data/ajax-data.json，带入参数zipcode，将结果显示在#weather-con中。
KISSY.use('io,node',function(S,io,Node)&#123;    io(&#123;        url:'./data/ajax-data.json',        data:&#123;            zipcode:10010        &#125;,        success:function(data)&#123;            Node.one('#weather-con').html('&lt;em&gt;' + data.weather + '&lt;/em&gt; 摄氏度');        &#125;    &#125;);&#125;);


源码分享https://github.com/voidking/kissy-start.git
书签KISSY - A Powerful JavaScript Frameworkhttp://docs.kissyui.com/
KISSY项目地址https://github.com/kissyteam/kissy
KISSY 指导手册http://docs.kissyui.com/1.4/docs/html/guideline/get-started.html
jQuery - KISSY Rosetta Stonehttp://cyj.me/jquery-kissy-rosetta/
KISSY 模块定义规范（KMD）http://docs.kissyui.com/1.4/docs/html/guideline/kmd.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Kolla配置实例网络</title>
    <url>/dev-kolla-instance-network/</url>
    <content><![CDATA[前言紧接着《Ubuntu16使用Kolla安装OpenStack》，假设已经使用kolla安装好了openstack，本文我们来研究一下怎样访问实例和怎样配置网络。


访问实例1、在dashboard查看网络拓扑如下：上图中网关的ip为10.0.2.158，ping不通。上图中实例demo1的ip为10.0.0.3，ping不通。这是因为，当前网络和实例的网络属于不同的命名空间。
2、查看命名空间ip netns
3、查看qrouter的网络ip netns exec qrouter-6e5d8c97-3f9c-4ce9-a9b4-580f2f38e0f3 ip add
4、登录实例demo1ip netns exec qrouter-6e5d8c97-3f9c-4ce9-a9b4-580f2f38e0f3 ssh cirros@10.0.0.3
直接访问实例上面的登录方式，比较麻烦，因为要指定命名空间。下面我们来配置一下，使得不指定命名空间也可以访问实例。
1、在/etc/network/interfaces中添加配置：
auto br-exiface br-ex inet staticaddress 10.0.2.1netmask 255.255.255.0

2、启用br-exifup br-ex
3、测试连接此时，可以ping通网关10.0.2.158，ping不通实例10.0.0.3。
4、解决方法一，添加路由
route add -net 10.0.0.0/24 gw 10.0.2.158 dev br-exping 10.0.0.3 -c3

5、解决方法二，给demo1实例分配浮动IP
source /etc/kolla/admin-openrc.shopenstack network listopenstack floating ip create public1openstack server add floating ip demo1 10.0.2.153ping 10.0.2.153 -c3

外网配置在实例中，ping不通8.8.8.8。参考Openstack实践（1）部署使用实例及neutron网络，可以通过修改init-runonce脚本解决，EXT_NET_CIDR、EXT_NET_RANGE和EXT_NET_GATEWAY需要根据物理网络配置。
这里，郝同学使用snat来解决。
1、参考Linux配置SNAT上网，设置snat
iptables -I INPUT -i eth2 -j ACCEPTiptables -I INPUT -i br-ex -j ACCEPTiptables -t nat -A POSTROUTING -s 10.0.2.0/24 -o eth1 -j MASQUERADEiptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth1 -j MASQUERADE
这里的设置，使10.0.2.0/24网段和10.0.0.0/24网段都可以上网了。实际上，只要配置10.0.2.0/24网段可以上网就可以了，因为这个网段用于配置浮动IP。
2、测试网络ssh cirros@10.0.0.3
ping 8.8.8.8 -c3如上图，实例已经可以ping通外网。
书签Openstack 之 kolla部署外部网络配置
Openstack 之 kolla部署外部网络配置
kolla queens on centos7.4
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
        <tag>kolla</tag>
      </tags>
  </entry>
  <entry>
    <title>Kolla安装OpenStack添加新节点</title>
    <url>/dev-kolla-openstack-add-new-node/</url>
    <content><![CDATA[前言《Kolla安装OpenStack多节点》一文中，使用kolla安装了三个节点的openstack。
因为实验需要，现在需要再添加一个计算节点。那么问题来了，怎样在不破坏现有环境的基础上，添加一个新的计算节点呢？本文就来研究一下。



新节点配置网络设置在新添加的计算节点上，执行以下操作：
1、切换到root用户sudo -i
2、vim /etc/network/interfaces，设置网卡为：
# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto eth0iface eth0 inet staticaddress 192.168.56.113netmask 255.255.255.0auto eth1iface eth1 inet dhcpauto eth2iface eth2 inet manualup ifconfig $IFACE 0.0.0.0 upup ifconfig $IFACE promisc

3、启用网卡ifup eth2
4、修改/etc/hosts，添加：
192.168.56.110  controller192.168.56.111  network192.168.56.112  compute192.168.56.113  compute2

python安装pythonapt -y install python-simplejson不安装的话，在使用ansible的时候会报错/bin/sh: 1: /usr/bin/python: not found。
安装docker1、安装dockerapt -y install docker.io
2、为docker和kolla创建配置文件
mkdir -p /etc/systemd/system/docker.service.dvim /etc/systemd/system/docker.service.d/kolla.conf

修改为：
[Service]MountFlags=shared

3、重启docker
systemctl daemon-reloadsystemctl restart docker

4、查看docker信息docker info
密钥登录1、在控制节点将公钥写入新的计算节点
ssh-copy-id -i .ssh/id_rsa.pub -p 22 voidking@192.168.56.11

2、在新的计算节点把voidking用户添加进sudo免密，方便以后的操作sudo vim /etc/sudoers，添加
voidking ALL = NOPASSWD: ALL

控制节点配置1、配置multinode文件vim multinode，如下修改：
# line 3, change[control]#192.168.56.110 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true# line 12, change[network]#192.168.56.111 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true# line 17, change[inner-compute]#192.168.56.112 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true192.168.56.113 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true# line 21, change[external-compute]#192.168.56.112 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true192.168.56.113 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true# line 28, comment[monitoring]#monitoring01# line 36, comment[storage]#storage01

2、测试连通ansible -i multinode -m ping all
3、拷贝kolla.tar到新计算节点scp kolla.tar voidking@192.168.56.113:~
4、在新计算节点导入所有imagesdocker load -i kolla.tar
5、在控制节点执行初始化kolla-ansible -i ./multinode bootstrap-servers报错如图：参考《Ubuntu16使用Kolla安装OpenStack》解决。
6、预检查kolla-ansible -i ./multinode prechecks
7、部署kolla-ansible -i ./multinode deploy报错，创建数据库失败。解决办法：取消multinode文件中control节点的注释，然后重新执行部署。kolla-ansible -i ./multinode deploy --limit @/usr/local/share/kolla-ansible/ansible/site.retry实际上，site.retry文件里面放的是一个单纯的IP地址192.168.56.113。如上图，等待几分钟后，出现部署成功的提示。
测试使用新的问题来了，上面的操作显示新的计算节点部署成功，那么，安装过程中有没有对原系统产生影响？我们来测试查看一下。1、使admin环境生效source /etc/kolla/admin-openrc.sh
2、查看计算服务openstack compute service list如上图，此时已经有了两个计算节点。
3、查看以前的实例openstack server list之前的实例还在，没有受到影响，nice。
后记上面的步骤，完美添加了一个新的计算节点，前提是《Kolla安装OpenStack多节点》一文中的globals.yml等配置文件保持不变。
我很好奇，如果主机清单multinode中的110、111、112三个节点没有添加注释，会不会对它们进行重新安装。于是，我把注释取消，执行了一次kolla-ansible -i ./multinode deploy。实践证明，没啥影响。那么，如果从bootstrap-servers开始执行呢？依次执行bootstrap-servers、prechecks、deploy三条命令会不会重装？于是，先执行bootstrap-servers。然后，卡在了时间同步，卡了一个钟头，遂Ctrl+C放弃。算了算了，不探究了，如无必要勿增实体，还是把精力放在更重要的事情上。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ansible</tag>
        <tag>openstack</tag>
        <tag>kolla</tag>
      </tags>
  </entry>
  <entry>
    <title>kube-controller-manager指标收集</title>
    <url>/dev-kube-controller-manager-metrics/</url>
    <content><![CDATA[前言大家都知道需要监控k8s指标，但是具体需要监控k8s的哪些组件的哪些指标？本文，就来学习梳理kube-controller-mananger组件的监控指标。

有哪些指标？要收集指标，首先要知道有哪些指标可以收集。方法一：使用curl命令
k get pods -n kube-system -o wide | grep kube-controller-managerk get svc -n kube-system -o wide | grep kube-controller-managerssh &lt;clusterhost&gt;curl localhost:&lt;nodeport&gt;/metrics

方法二：在prometheus使用promql
count(&#123;job="kube-controller-manager"&#125;) by (__name__)count(&#123;job="kube-controller-manager",__name__!~"^go_.*"&#125;) by (__name__)

指标含义？找到了指标，接下来需要知道指标的含义。访问 Splunk doc - kube-controller-manager，使用指标名称搜索即可。
比如搜索：rest_client_request_duration_seconds_bucket得到结果：rest_client_request_duration_seconds_bucket (cumulative)Request latency in seconds. Broken down by verb and URL. (bucket)
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>监控</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kubeadm安装部署K8S集群</title>
    <url>/dev-kubeadm-install-k8s/</url>
    <content><![CDATA[kubeadm简介《使用kubeadm升级K8S集群》一文中，了解了k8s集群中常见组件，并且使用kubeadm对k8s集群进行了升级。本文中，会学习使用kubeadm安装部署k8s集群。

Kubeadm is a tool built to provide kubeadm init and kubeadm join as best-practice “fast paths” for creating Kubernetes clusters.

更多内容，参考Overview of kubeadm和Installing kubeadm。


安装流程目标：搭建一个k8s集群，包括master和node01两个节点，节点系统为ubuntu16.04.2。
1、环境准备。
2、在两个节点上安装kubeadm。
3、使用kubeadm初始化节点。
4、安装网络插件。
5、验证安装。
环境准备1、配置主机名
2、配置IP地址
3、参考Letting iptables see bridged traffic，配置iptables
# ensure legacy binaries are installedsudo apt-get install -y iptables arptables ebtables# switch to legacy versionssudo update-alternatives --set iptables /usr/sbin/iptables-legacysudo update-alternatives --set ip6tables /usr/sbin/ip6tables-legacysudo update-alternatives --set arptables /usr/sbin/arptables-legacysudo update-alternatives --set ebtables /usr/sbin/ebtables-legacy# Letting iptables see bridged trafficcat &lt;&lt;EOF &gt; /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsysctl --system

4、参考Docker入门，安装Docker
安装kubeadm参考Installing kubeadm。
1、确认系统版本cat /etc/os-release
2、执行安装kubeadm、kubelet和kubectl（两个节点都要执行）
sudo apt-get update &amp;&amp; sudo apt-get install -y apt-transport-https curlcurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -cat &lt;&lt;EOF | sudo tee /etc/apt/sources.list.d/kubernetes.listdeb https://apt.kubernetes.io/ kubernetes-xenial mainEOFsudo apt-get updatesudo apt-get install -y kubelet kubeadm kubectlsudo apt-mark hold kubelet kubeadm kubectl

3、查看kubelet版本kubelet --version
初始化节点参考Installing kubeadm on your hosts。
master1、测试与gcr.io的连接kubeadm config images pull
2、执行初始化kubeadm init完成后，屏幕输出会提示创建配置文件，以及添加worker node的join命令，记录下来。
3、创建配置文件
mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config

PS：如果忘记了添加worker node的join命令，可以重新生成。
kubeadm token create --helpkubeadm token create --print-join-command
生成新的join命令后，之前的join命令同样可以使用。
node011、使用join命令，添加node01节点到集群
kubeadm join 172.17.0.53:6443 --token b09bi7.ob6evvc11a8jt1ie \    --discovery-token-ca-cert-hash sha256:8abadf8f2eb81301060af3ac6002959714ccf79aaf853546445a2fd6a0265001

2、验证结果在master节点执行：kubectl get nodes可以看到master节点和node01节点，都是NotReady的状态。
安装网络插件参考Installing a Pod network add-on，本文中选择安装weave。（以下命令都是在master节点执行。）
1、安装weave
kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"

2、验证结果kubectl get nodes -w等待一会，可以看到master节点和node01节点，变化为Ready的状态，nice。
以上，k8s集群安装部署完成。
验证安装手动验证kubectl get nodeskubectl get pods --all-namespacesservice kube-apiserver statusservice kube-controller-manager statusservice kube-scheduler statusservice kubelet statusservice kube-proxy status

kubectl run nginxkubectl get podskubectl scale --replicas=3 deploy/nginxkubectl get podskubectl expose deployment nginx --port=80 --type=NodePortkubectl get servicecurl http://node01:31850

test-infra源码地址：kubernetes/test-infra
1、拉取源码go get -u k8s.io/test-infra/kubetest
2、执行kubetest
kubetest --extract=v1.11.3cd kubernetesexport KUBE_MASTER_IP="172.17.0.53:6443"export KUBE_MASTER=kube-masterkubetest --test --provider=skeleton &gt; testout.txtkubetest --test --provider=skeleton --test_args="ginkgo.focus=Secrets" &gt; testout.txtcat testout.txt

Smoke Test按照Smoke Test文档操作一遍。
sonobuoy官网地址：sonobuoy源码地址：vmware-tanzu/sonobuoy
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>使用kubeadm升级K8S集群</title>
    <url>/dev-kubeadm-upgrade/</url>
    <content><![CDATA[K8S组件版本说明k8s集群中的常见组件包括：A类：kube-apiserverB类：controller-manager、kube-schedulerC类：kubelet、kube-proxyD类：etcd cluster、CoreDNSE类：kubectl
组件的版本号一般表示为 major.minor.patch，比如v1.10.3。其中，A类组件是主要组件，以它为版本基准。比如，A类组件版本的minor号为x，那么B类组件版本必须为x或者x-1，C类组件版本必须为x、x-1或者x-2，E类组件版本必须为x、x-1或者x+1。而D类组件，和A类组件不是同一版本体系，版本兼容情况需要查看文档。整理成表格如下：



组件类别
minor版本
组件



A类
x
kube-apiserver


B类
x、x-1
controller-manager、kube-scheduler


C类
x、x-1、x-2
kubelet、kube-proxy


E类
x、x-1、x+1
kubectl


D类
查看文档
etcd cluster、CoreDNS


本文学习使用kubeadm进行k8s集群的升级。


升级顺序推荐的升级方法，是根据minor版本号逐级进行升级。比如v1.10.0想要升级到v1.13.0，不应该直接升级到v1.13.0，而是应该v1.10.0-&gt;v1.11.0-&gt;v1.12.0-&gt;v1.13.0。
升级顺序一般为：1、升级kubeadm2、升级master node3、升级worker node4、升级kubelet
升级操作以v1.11.0升级v1.12.0为例。
master节点1、查看升级帮助kubeadm upgrade plan
2、升级kubeadm
apt-get upgrade -y kubeadm=1.12.0-00# orapt install kubeadm=1.12.0-00

3、升级k8s的AB类组件
kubeadm upgrade apply v1.12.0
此时使用kubectl get nodes，看到的version依然是v1.11.0，因为这里显示的是kubelet的版本，而不是kube-apiserver的版本。
4、升级master节点的kubelet
apt install kubelet=1.12.0-00systemctl restart kubelet

worker节点1、驱逐worker节点的pods，封锁节点
kubectl drain node-1kubectl cordon node-1

2、升级kubeadm和kubectl
apt-get install kubeadm=1.12.0-00apt-get install kubelet=1.12.0-00kubeadm upgrade node config --kubelet-version v1.12.0systemctl restart kubelet

3、解除节点封锁kubectl uncordon node-1
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S中的RBAC鉴权</title>
    <url>/dev-k8s-rbac-auth/</url>
    <content><![CDATA[RBAC Authorization
Role-based access control (RBAC) is a method of regulating access to computer or network resources based on the roles of individual users within your organization.

更多内容，参考Using RBAC Authorization。
《SSL和TLS》文中，通过API签名一节，创建了新用户jane，并且给该用户的证书进行签名。现在我们有了jane.crt和jane.key，本文中会配置jane拥有一些k8s集群的管理权限。


角色和绑定首先，给用户jane配置权限，使其能够创建和查看default空间下的pods。
命令实现1、创建角色
kubectl create role --helpkubectl create role developer --resource=pods --verb=list,create

2、角色绑定
kubectl create rolebinding dev-user-binding --role=developer --user=jane

3、验证权限
kubectl auth can-i list pods --as janekubectl get pods --as jane
至此，用户jane的权限配置完成。
manifest实现---kind: RoleapiVersion: rbac.authorization.k8s.io/v1metadata:  namespace: default  name: developerrules:- apiGroups: [""]  resources: ["pods"]  verbs: ["list", "create"]---kind: RoleBindingapiVersion: rbac.authorization.k8s.io/v1metadata:  name: dev-user-bindingsubjects:- kind: User  name: jane  apiGroup: rbac.authorization.k8s.ioroleRef:  kind: Role  name: developer  apiGroup: rbac.authorization.k8s.iomaster

集群角色和绑定以上，给jane授权，是在namespace范围内的。当我们想给jane授权cluster范围的权限时，就需要clusterroles。
比如，我们想给jane授权node相关的权限，可以如下实现。
命令实现1、创建集群角色
kubectl create clusterrole node-reader --verb=get,list,watch --resource=nodes

2、绑定集群角色
kubectl create clusterrolebinding node-reader-binding --user=jane --clusterrole=node-reader

manifest实现---apiVersion: rbac.authorization.k8s.io/v1kind: ClusterRolemetadata:  creationTimestamp: null  name: node-readerrules:- apiGroups:  - ""  resources:  - nodes  verbs:  - get  - list  - watch---apiVersion: rbac.authorization.k8s.io/v1beta1kind: ClusterRoleBindingmetadata:  creationTimestamp: null  name: node-reader-bindingroleRef:  apiGroup: rbac.authorization.k8s.io  kind: ClusterRole  name: node-readersubjects:- apiGroup: rbac.authorization.k8s.io  kind: User  name: jane

其他如果使用clusterrole指定的资源是pods这种namespace级别的资源，该集群角色绑定给jane后会有什么效果？答：jane对所有namespace中的pods资源拥有clusterrole中定义的操作权限。
配置文件用户jane已经拥有了需要的权限，该怎样访问k8s集群呢？答案是通过kubeconfig文件。
kubeconfig1、查看配置kubectl config view记录当前的server地址。
2、保存ca.crt
cat .kube/config | grep certificate-authority-data | awk '&#123;print $2&#125;' | base64 --decode &gt; ca.crt

jane.kubeconfig1、设置集群参数
kubectl config set-cluster kubernetes \--server="https://172.17.0.69:6443" \--certificate-authority=/root/ca.crt \--embed-certs=true \--kubeconfig=jane.kubeconfig
当前目录生成jane.kubeconfig文件。
2、设置客户端认证参数
kubectl config set-credentials jane \--client-certificate=/root/jane.crt \--client-key=/root/jane.key \--embed-certs=true \--kubeconfig=jane.kubeconfig

3、设置上下文参数
kubectl config set-context jane@kubernetes \--cluster=kubernetes \--user=jane \--namespace=default \--kubeconfig=jane.kubeconfig

4、查看配置
cat jane.kubeconfigkubectl config view --kubeconfig jane.kubeconfig

5、设置默认上下文
export KUBECONFIG=/root/jane.kubeconfigkubectl config use-context jane@kubernetes --kubeconfig=jane.kubeconfig

6、权限测试kubectl get pods如果没有配置权限，会输出：
Error from server (Forbidden): pods is forbidden: User "jane" cannot list resource "pods" in API group "" in the namespace "default"
如果配置好了权限，会输出pod相关信息。
但是，以上权限测试只是在minikube或者katacoda平台生效。如果使用kodekloud或者阿里云k8s集群，会报错：
error: You must be logged in to the server (Unauthorized)
研究了四个多小时，才发现是平台的问题，服气了。。。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>当K8S遇到PM2</title>
    <url>/dev-k8s-pm2/</url>
    <content><![CDATA[问题描述某个前端项目使用PM2进行node进程的管理，把该项目打包放到了docker镜像中，使用docker run命令可以正常启动。但是，把docker镜像放入K8S集群后，启动报错，[PM2][ERROR] Process failed to launch spawn E2BIG。


解决方案查阅资料发现，上面的问题，是因为环境变量过多引起的。K8S启动时会给容器注入环境变量，K8S集群中的项目数越多，环境变量也就越多。而pm2在启动时会导入系统中的环境变量，当环境变量数量过多时，就会报错[PM2][ERROR] Process failed to launch spawn E2BIG。
使用env或者printenv命令查看容器中的变量，果然环境变量特别多。解决方案也就明确了：减少环境变量。
修改pm2源码第一个解决方案是修改pm2源码，过滤掉环境变量。编辑/usr/local/lib/node_modules/pm2/lib/Common.js，修改process.env部分。
function filterDockerEnv(envObj)&#123;	let keys = Object.keys(envObj);	let new_env = &#123;&#125;;	let allowKeys = keys.filter(item =&gt; !item.startsWith("ENV_HOST_"));	allowKeys.forEach(key =&gt; &#123;		new_env[key] = envObj[key];	&#125;);	return new_env;&#125;var newEnv = filterDockerEnv(env);// Change to double check  (dropped , &#123;pm_cwd: cwd&#125;)app.env = [&#123;&#125;, newEnv, app.env || &#123;&#125;].reduce(function(e1, e2)&#123;	return util._extend(e1, e2);&#125;);

清除环境变量第二个方案是在pm2启动前清除系统中的环境变量。正常启动命令前，先执行一段清除系统变量的脚本。
for i in `env | grep -E -i 'SERVICE|HOST|ADDR|PORT' | sed 's/=.*//'` ; do unset $i;done

第二种方案更加灵活，推荐使用这种方式。
书签一次NodeJS测试集群全线瘫痪的解决思路一次环境变量引发的血案[PM2][ERROR] Process failed to launch spawn E2BIG
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
        <tag>node</tag>
        <tag>pm2</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Libvirt进行虚拟机在线迁移</title>
    <url>/dev-libvirt-vm-live-migration/</url>
    <content><![CDATA[前言《虚拟机在线迁移实验》一文中提到，迁移过程中的downtime不合理，但是没有找到原因。
本文，我们来使用Libvirt进行虚拟机在线迁移，如果downtime在毫秒级，那么说明问题出在OpenStack上。参考An analysis of the performance of live migration in Openstack的评论部分，可以发现有人遇到的同样的问题，downtime远大于1s。作者的猜测是libvirt的设置引起的，也可能是由于迁移后网络适应速度较慢造成的。


实验环境使用《使用Libvirt创建虚拟机》一文中搭建的环境，已经有了node0和node1两个节点，IP分别为192.168.56.200和192.168.56.201。
NFS要想进行虚拟机的迁移，首先迁出主机（node0）和迁入主机（node1）存放虚拟机磁盘的目录结构要相同。参考OpenStack中共享存储的虚拟机在线迁移的NFS部分，进行NFS配置。
1、在node0安装nfs服务端apt install nfs-kernel-server
2、编写配置文件vim /etc/exports添加如下内容：
# qemu/opt/qemu *(rw,sync,no_root_squash)

3、重启nfs服务service nfs-kernel-server restart
4、在node1安装nfs客户端apt-get install nfs-common
5、查看共享信息showmount -e 192.168.56.200
6、挂载nfs目录
mkdir /opt/qemumount -t nfs 192.168.56.200:/opt/qemu /opt/qemuchmod -R 777 /opt/qemu

libvirt端口配置1、测试连接virsh -c qemu+tcp://node1/system提示：
error: failed to connect to the hypervisorerror: unable to connect to server at 'node1:16509': Connection refused

2、在node0和node1调整libvirt的配置vim /etc/libvirt/libvirtd.conf，如下修改：
# line 22, uncommentlisten_tls = 0# line 33, uncommentlisten_tcp = 1# line 45, uncommenttcp_port = "16509"# line 55, uncomment and changelisten_addr = "0.0.0.0"# line 163, uncomment and changeauth_tcp = "none"

3、重启libvirtservice libvirtd restart
4、查看libvirt服务netstat -anpt | grep libvirt理论上应该看到监听16509，但是没有。
5、修改libvirt-bin.conf配置（可选）vim /etc/init/libvirt-bin.conf，如下修改：
# line 11, add -lenv libvirtd_opts="-d -l"

6、重启libvirt-bin（可选）service libvirt-bin restart依然没有监听16509端口。
vim /etc/init/libvirt-bin.conf，如下修改：
# line 58, add -lexec /usr/sbin/libvirtd $libvirtd_opts -l
重启libvirt-bin依然无效。
7、还原libvirt-bin.conf，修改libvirt-binvim /etc/default/libvirt-bin，如下修改：
# line 8, uncomment and changelibvirtd_opts="-d -l"
重启libvirt-bin，发现端口监听成功。
8、再次测试连接virsh -c qemu+tcp://node1/system连接成功，nice。
免密登录虚拟机迁移，可以使用普通用户，也可以使用root用户。如果是普通用户进行迁移，那么在输入迁移命令后，需要输入node1中普通用户的密码。如果是root用户进行迁移，那么在输入迁移命令后，同样需要输入node1中root用户的密码。但是，root用户并没有启用密码登录，所以，需要给root用户设置免密登录。
1、在node0上创建密钥对ssh-keygen所有的提示按enter键即可，完成后在home目录执行ll .ssh，即可看到创建好的id_rsa和id_rsa.pub文件。
2、把公钥拷贝到所有客户机中ssh-copy-id -i .ssh/id_rsa.pub -p 22 voidking@node1
3、在node1中使用root用户执行cp -r /home/voidking/.ssh ~
同样的，也给node1添加免密登录node0。
虚拟机迁移参考kvm虚拟机迁移，进行虚拟机动态迁移。
1、在node0查看虚拟机virsh list
2、虚拟机迁移virsh migrate --live --verbose cirros qemu+ssh://node1/system tcp://node1 --unsafe其中node1可以换成root@node1。
后记本来打算在《Libvirt虚拟机网络配置》一文中配置好网络，使得node0可以访问到node1中的实例，node1可以访问到node0中的实例。但是，配置失败了。所以，就无法测试虚拟机迁移的停机时间了。如果之后解决了桥接的问题，就再来更新。
书签KVM 虚拟机在物理主机之间迁移的实现
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>Libvirt虚拟机网络配置</title>
    <url>/dev-libvirt-vm-network/</url>
    <content><![CDATA[前言通过《使用Libvirt创建虚拟机》一文，我们已经学会使用Libvirt创建虚拟机的方法，而且学会了虚拟机的一些基本配置方法。但是，文中创建的虚拟机只能在node0上访问，node1就无法访问，也就是说无法对外网提供服务。
本文，就来研究一下虚拟机网络配置的方法，使得node1也可以访问到node0中的虚拟机。最简单的实现方法，就是VM要有一个对外提供服务的IP，这个IP不依赖于宿主机，而是和宿主机的IP同级。


网络配置1参考KVM 以及桥接网络配置和libvirt kvm 虚拟机上网 – Bridge桥接进行配置。
1、在node0的网络配置中进行修改：
#auto eth0#iface eth0 inet static#address 192.168.56.200#netmask 255.255.255.0auto eth0iface eth0 inet manualup ifconfig $IFACE 0.0.0.0 upup ifconfig $IFACE promiscauto br0iface br0 inet staticaddress 192.168.56.200netmask 255.255.255.0gateway 192.168.56.1bridge_ports eth0bridge_stp offbridge_fd 0bridge_maxwait 0

使用br0替代eth0，eth0做流量转发。
2、重启网络/etc/init.d/networking restart
3、修改路由（可选）
route -nroute del -net 192.168.56.0/24 dev eth0route add -net 192.168.56.0/24 dev br0

同样的，在node1中也配置br0。
下面参考虚拟机在线添加网卡，添加网卡。
4、添加网卡
virsh domiflist cirrosvirsh attach-interface cirros --type bridge --source br0 --configvirsh domiflist cirros
如果在实例开机状态下添加网卡，需要重启实例后才能看到。
5、网卡信息保存到配置文件
virsh dumpxml cirros &gt;/etc/libvirt/qemu/cirros.xml virsh define /etc/libvirt/qemu/cirros.xml

PS：删除网卡
virsh detach-interface cirros --type bridge --mac 52:54:00:09:36:ad

6、登录实例后，配置新网卡的IPsudo vi /etc/network/interfaces，添加eth1的配置：
auto eth1iface eth1 inet staticaddress 192.168.56.202netmask 255.255.255.0

7、重启实例sudo reboot至此，实例桥接网络配置完成。
8、测试网络在node0上ping 192.168.56.202 -c2，正常。在node1上ping 192.168.56.202 -c2，不通。在virtualbox宿主机上ping 192.168.56.202 -c2，不通。
以上，我们的配置失败了，因为除了node0，其他机器无法访问实例。下面我们来分析一下当前网络，如下图：经过测试，node0到switch0是通的，node0到vm0是通的，但是vm0到switch0不通。诡异，理论上应该是通的啊！
网络配置2那么，怎么打通vm0到switch0呢？最容易想到的，是把vm0直接连接到eth0上，而br0单纯作为node0的管理网络。修改后的方案如下图：
1、修改cirros配置virsh edit cirros，找到：
&lt;interface type='bridge'&gt;  &lt;mac address='52:54:00:09:36:ad'/&gt;  &lt;source bridge='br0'/&gt;  &lt;model type='rtl8139'/&gt;  &lt;address type='pci' domain='0x0000' bus='0x00' slot='0x06' function='0x0'/&gt;&lt;/interface&gt;
把source中的br0改为eth0。
2、重启实例
virsh shutdown cirrosvirsh start cirros
报错：
error: Failed to start domain cirroserror: Unable to add bridge eth0 port vnet1: Operation not supported
想法是美好的，但是行不通啊！参考Attaching a Virtual NIC Directly to a Physical Interface进行修改，但是又报出了其他错误：
error: Failed to start domain cirroserror: error creating macvtap interface macvtap0@eth0 (52:54:00:c8:33:b3): Device or resource busy
参考Using KVM with Libvirt and macvtap Interfaces也许可以解决，但是感觉好麻烦，所以决定放弃这个方案。
网络配置3如果，再创建一个网桥，这个网桥不指定IP呢？如下图：
1、创建新网桥br1vim /etc/network/interfaces，添加：
auto br1iface br1 inet dhcpbridge_ports eth0bridge_stp offbridge_fd 0bridge_maxwait 0

2、启动br1ifup br1，报错：
device eth0 is already a member of a bridge; can't enslave it to bridge br1.Internet Systems Consortium DHCP Client 4.3.3......
由上可知，一个物理网卡，只能绑定到一个网桥上。所以，这个想法也是行不通的。
网络配置4那么，把br1绑定到eth2（eth1是上网网卡）上面呢？如下图：
1、修改br1配置vim /etc/network/interfaces，如下修改：
auto eth2iface eth2 inet manualup ifconfig $IFACE 0.0.0.0 upup ifconfig $IFACE promiscauto br1iface br1 inet dhcpbridge_ports eth2bridge_stp offbridge_fd 0bridge_maxwait 0

2、启动br1
ifup eth2ifup br1

3、编辑cirros配置，修改br0为br1，重启cirros。结果，vm0到switch0依然不通。证明这个方案也不行。
网络配置5网络配置2、3、4都不行，看来拍脑门想出来的方法不太靠谱。实际上网络配置1应该是可以的，但是，却无法连通，问题出在哪里呢？莫非，是因为virtualbox？virtualbox有多种网络模式，node1和node2使用的是Host-only Adapter，如果换成Bridged Adapter呢？那就试试吧！结果，依然失败。
后记还能不能愉快地玩耍了？明明很简单的桥接，为啥就不通呢？诡异，实在诡异。郝同学表示已经无能为力，留个坑吧！
书签KVM/Networking
Networking
VirtualNetworking
KVM and OVS on Ubuntu 16.04
ubuntu16.04 配置kvm openvswitch 桥接环境
Open vSwitch + libvirt 搭建vlan网络
How to Put a KVM Guest Domain on a Bridged Network
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的12个问题</title>
    <url>/dev-linux-12-question/</url>
    <content><![CDATA[问题11.下载linux2.6.18的内核2.安装阅读内核的软件soure insight3.编译内核4.写总结讲讲下载编译过程的问题和解决方式。
问题2从内核中寻找各种数据结构的应用，每个找一个例子。从内核中寻找同步机制的应用，每个找一个例子。学习dead  line调度算法（deadline-iosched.c）中红黑树的应用,重点deadline_add_request从dead line调度算法学习双向链表、hash链表的应用。


问题31.从内核中寻找kmalloc的例子并分析2.从内核中寻找wait_event和工作队列的例子并分析
问题4文件系统超级块的创建过程文件系统内创建一个文件的过程
问题5阅读文件打开的过程，重点关注dentry,inode的处理过程。
问题6分析pci总线提供的设备属性如何应用到sys文件系统？（pci_bus_type.pci_dev_attrs）写个小程序，在sysfs文件系统中创建一个目录和文件
问题71.如果文件起点位于硬盘物理扇区10000，那么从文件位置4096+1000字节处读7000个字节，对应的页缓存分别是那几个页面？对应块的物理块号是多少？2.如果一个进程读文件，读的数据是文件内第一个页面的内容，读尚未完成有另一个进程同时准备写第一个页面的内容，  那么内核如何保证前一个进程读到正确的内容？
问题81.简要描述io从中断中返回，经过通用块层返回到用户态进程的函数调用关系。需要包括io的软中断处理，scsi命令的返回函数，bio的返回函数和页面的解锁。2.块设备的队列request-queu提供了一系列的调用函数，简要描述它们各自的作用。
问题91.利用dumpe2fs把linux一个ext2(ext3也可)分区的信息dump出来，解释dump出来的信息。2.结合课程的知识和ext2的目录结构，解析文件打开的过程
问题101.设备dma地址来自哪里？2如何读取pci设备配置空间的信息？3描述pci总线扫描设备的过程，包括桥的处理以及设备信息的获取.
问题111.分析kobj_lookup函数如何找到字符设备的对象cdev?2.分析内核的ext2文件系统打开字符设备文件的整个过程？（假定根目录下有个字符设备文件chdev，文件系统如何读到inode信息，对设备文件赋值的过程，打开字符设备open函数的过程，打开input_handler提供的open函数）
问题12描述物理键盘加入系统的过程分析。分为platform总线的设备和驱动匹配的过程，serio总线设备和驱动匹配的过程，input框架设备和驱动匹配的过程。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下解压命令大全</title>
    <url>/dev-linux-decompress-command-all/</url>
    <content><![CDATA[.tar解包：tar xvf FileName.tar打包：tar cvf FileName.tar DirName（注：tar是打包，不是压缩！）


.gz解压1：gunzip FileName.gz解压2：gzip -d FileName.gz压缩：gzip FileName.tar.gz 和 .tgz解压：tar zxvf FileName.tar.gz压缩：tar zcvf FileName.tar.gz DirName
例：下载了一个eclipse，想把它解压到/usr目录tar -zxvf eclipse-jee-indigo-SR2-linux-gtk-x86_64.tar.gz /usr，提示错误：
tar: /usr: Not found in archivetar: Exiting with failure status due to previous errors
原因是因为压缩文件使用的相对路径 在当前目录下找不到 /usr目录，通过使用-C指定解压目录可解决此问题tar -zxvf eclipse-jee-indigo-SR2-linux-gtk-x86_64.tar.gz -C /usr
.bz2解压1：bzip2 -d FileName.bz2解压2：bunzip2 FileName.bz2压缩： bzip2 -z FileName
.tar.bz2解压：tar jxvf FileName.tar.bz2压缩：tar jcvf FileName.tar.bz2 DirName
.bz解压1：bzip2 -d FileName.bz解压2：bunzip2 FileName.bz压缩：未知
.tar.bz解压：tar jxvf FileName.tar.bz压缩：未知
.Z解压：uncompress FileName.Z压缩：compress FileName
.tar.Z解压：tar Zxvf FileName.tar.Z压缩：tar Zcvf FileName.tar.Z DirName
.zip解压：unzip FileName.zip压缩：zip FileName.zip DirName
.rar解压：rar x FileName.rar压缩：rar a FileName.rar DirName
.lha解压：lha -e FileName.lha压缩：lha -a FileName.lha FileName
.rpm解包：rpm2cpio FileName.rpm | cpio -div
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设置邮件提醒</title>
    <url>/dev-linux-mail/</url>
    <content><![CDATA[前言《Linux设置定时任务》一文中，我们学习了使用crontab设置定时任务的方法，并用它来获取ganglia的运行状态。这样还不够，我们想要在ganglia的运行状态出现问题时通知我们，这样，我们就不用每天自己查看日志了。
本文主要参考Ubuntu mail命令发送邮件 和 如何通过Shell脚本实现发送邮件通知功能？。


mail基础安装1、安装mailutilssudo apt-get install mailutils
2、General type of mail configuration选择Internet Site。
3、System mail name输入mail.voidking.com。
mail命令命令格式：mail [OPTION...] [address...]常用到的选项，一个是s，代表主题；一个是A，代表附件。其他的需要时查看help。
使用普通邮件目标：给邮箱 voidking@qq.com 发送邮件，主题为“Hello VoidKing”，内容为“Welcome to mail world！”
方法一：mail -s &#39;Hello VoidKing&#39; voidking@qq.com提示Cc，这里不需要抄送，就直接回车。然后输入邮件内容“Welcome to mail world！”，回车，ctrl+D，发送邮件。
但是，等待了几分钟，并没有收到邮件，垃圾箱也没有。mail，查看email的发送状态为Undelivered Mail Returned，原来没有投递出去。
查看邮件系统日志：tail -n 50 /var/spool/mail/test，提示host mx3.qq.com[183.57.48.35] said: 550 Mail content denied。看来qq邮箱的垃圾邮件防御机制做的不错，那就换个163邮箱，没想到依然失败。
那就换一台服务器！发送给 voidking@qq.com ，成功！很尴尬。。。
方法二：如果方法一发送邮件失败，可以试一下：
mail -s 'Hello VoidKing' voidking@qq.com &lt;&lt;&lt; 'Welcome to mail world!'echo 'Welcome to mail world！' | mail -s "Hello VoidKing" voidking@qq.com

高级邮件1、从文本读入内容发送邮件mail -s &#39;Error report&#39; voidking@qq.com &lt; /tmp/log/ganglia/error-20180524.log
2、发送附件mail -s &#39;Error report&#39; voidking@qq.com -A /tmp/log/ganglia/ganglia-20180524.log &lt; /tmp/log/ganglia/error-20180524.log
3、指定发件人echo &#39;Welcome to mail world！&#39; | mail -s &quot;Hello VoidKing&quot; voidking@qq.com -aFrom:haojin@qq.com
失败了，收不到邮件，不知道什么原因，留个坑吧。
设置邮件提醒目标：每天获取一次ganglia的状态日志，然后通过checkganglia.sh脚本进行审阅。审阅完毕，发送审阅结果到管理员的邮箱。
修改checkganglia.sh脚本为：
#!/bin/bashDATE=`date +%Y%m%d`filename="ganglia-$&#123;DATE&#125;.log"prefix="ganglia-$&#123;DATE&#125;"hosts=`grep test@ /tmp/log/ganglia/$&#123;filename&#125; | wc -l`pids=`grep gmond.pid /tmp/log/ganglia/$&#123;filename&#125; | wc -l`if [ $&#123;hosts&#125; != 10 ]then    echo "Some hosts are offline!" &gt;&gt; /tmp/log/ganglia/error-$&#123;DATE&#125;.logfiif [ $&#123;hosts&#125; != $&#123;pids&#125; ]then    echo "Some ganglia services have stopped!" &gt;&gt; /tmp/log/ganglia/error-$&#123;DATE&#125;.log    cd /tmp/log/ganglia/    csplit /tmp/log/ganglia/$&#123;filename&#125; /test@/ -n2 -s &#123;*&#125; -f $&#123;prefix&#125; -b ".log.%02d"    rm $&#123;prefix&#125;.log.00    for file in /tmp/log/ganglia/$&#123;prefix&#125;.log.*    do     if [ -f "$&#123;file&#125;" ]    then        #echo "$&#123;file&#125; is file"        if [ `grep gmond.pid $&#123;file&#125; | wc -l` == 0 ]        then            echo `grep test@ $&#123;file&#125;` &gt;&gt; /tmp/log/ganglia/error-$&#123;DATE&#125;.log        fi    fi    donefi# mail infoif [ ! -f "/tmp/log/ganglia/error-$&#123;DATE&#125;.log" ]then    mail -s "HappyDay$&#123;DATE&#125;" voidking@qq.com &lt;&lt;&lt; "All services are running!"else    mail -s "SadDay$&#123;DATE&#125;" voidking@qq.com -A /tmp/log/ganglia/ganglia-$&#123;DATE&#125;.log &lt; /tmp/log/ganglia/error-$&#123;DATE&#125;.logfi

后记至此，大功告成！《Linux设置定时任务》配合《Linux设置邮件提醒》，简直完美！两篇文章完成了一个小系统：定时生成ganglia日志，定时审阅ganglia日志，并且把审阅结果通过邮件发送给管理员。
书签Linux命令大全——LMNOPQ
如何在Ubuntu环境下搭建邮件服务器（一）
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux修改命令提示符信息(PS1)</title>
    <url>/dev-linux-ps1/</url>
    <content><![CDATA[问题如何将 root@izwz94j3dpfuv8pcrn1qitz 修改成 root@voidking-ali？
解决办法1、查看原PS1，echo $PS1，显示结果为：
[\u@\h \W]\$

2、编辑.bashrc，vi ~/.bashrc
3、添加
export PS1='[\u@voidking-ali \W]\$'
或者
export PS1="[\u@voidking-ali \W]\\$"

4、立即生效，source ~/.bashrc


扩展一般情况下，Linux 的命令提示信息类似于以下样子，显示为[当前用户名@短主机名  当前短路径]提示符，例如 [root@voidking-ali ~]#。
不过，有时候我们可能想自定义命令提示符的显示信息，比如显示完整的主机名和完整的路径。
PS1变量中提示符各项含义:
\d ：代表日期，格式为weekday month date，例如："Mon Aug 1"\H ：完整的主机名称。例如：我的机器名称为：voidking.linux，则这个名称就是voidking.linux\h ：仅取主机的第一个名字，如上例，则为voidking，.linux则被省略\t ：显示时间为24小时格式，如：HH：MM：SS\T ：显示时间为12小时格式\A ：显示时间为24小时格式：HH：MM\u ：当前用户的账号名称\v ：BASH的版本信息\w ：完整的工作目录名称。家目录会以 ~代替\W ：利用basename取得工作目录名称，所以只会列出最后一个目录\$ ：提示字符，如果是root时，提示符为：# ，普通用户则为：$


]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux的一些技巧</title>
    <url>/dev-linux-skill/</url>
    <content><![CDATA[软件推荐linux下的图片处理软件，号称linux下的photoshop：gimp
linux下可用的qq：pidgin-lwqq
linux下的翻译软件：stardict
linux下查看chm文件：chmsee
安装windows软件：wine


查看系统位数1、uname -a
2、file /bin/ls
3、getconf LONG_BIT
PS：查询CPU信息cat /proc/cpuinfo
查看系统版本适用所有系统：lsb_release -a
适用centos和redhat：cat /etc/redhat-release
适用ubuntu：cat /etc/issue
修改默认shell1、输入which tcsh，找到tcsh所存放路径。（或which ash 找到ash存放路径）
这里假设tcsh的路径为/bin/tcsh。
2、输入chsh -s /bin/tcsh，即可变更默认shell为tcsh。
3、重启，即可发现默认shell已经更改。
粘贴位要删除一个文件，你不一定要有这个文件的写权限，但你一定要有这个文件的上级目录的写权限。也就是说，你即使没有一个文件的写权限，但你有这个文件的上级目录的写权限，你也可以把这个文件给删除，而如果没有一个目录的写权限，也就不能在这个目录下创建文件。
如何才能使一个目录既可以让任何用户写入文件，又不让用户删除这个目录下他人的文件，sticky就是能起到这个作用。stciky一般只用在目录上，用在文件上起不到什么作用。在一个目录上设了sticky位后，（如/home，权限为1777)所有的用户都可以在这个目录下创建文件，但只能删除自己创建的文件(root除外)，这就对所有用户能写的目录下的用户文件启到了保护的作用。chmod 777 abc + chmod +t abc ，等价于 chmod 1777 abc 。
块大小对于单一文件，若块大小=1024，最大容量为16GB；若块大小=4096，最大容量为2TB。（根据inode的格式来看(12个直接块指针,1个间接块指针,1个二次间接块指针,1个三次间接块指针),假设磁盘块尺寸为n的话,单个文件尺寸应该是:12n + (1/4)n^2 + (1/16)n^3 + (1/64)n^4
任务前后台
CTRL+Z停止进程并放入后台     
jobs显示当前暂停的进程     
bg %N使第N个任务在后台运行(%前有空格)     
fg %N使第N个任务在前台运行     
默认bg,fg不带%N时表示对最后一个进程操作

编码格式执行sh脚本时报错：/bin/sh^M: bad interpreter: No such file or directory
1、添加执行权限chmod a+x filename
2、然后修改文件格式vi filename
3、利用如下命令查看文件格式
:set ff 或 :set fileformat
可以看到 fileformat=dos 或 fileformat=unix。
4、利用如下命令修改文件格式
:set ff=unix 或 :set fileformat=unix
5、保存文件:wq
6、最后再执行文件./filename
ubuntu端口开放1、安装iptablessudo apt-get install iptables
2、创建配置文件sudo iptables-save
3、添加规则sudo iptables -I INPUT -p tcp --dport 22 -j ACCEPT
4、保存规则sudo iptables-save
5、查看规则sudo iptables -L
以上只是暂时保存了开放端口的信息，如果服务器重启，保存的信息就掉了，所以我们需要持久化一下端口信息，这里我们使用 iptables-persistent。
1、安装iptables-persistentsudo apt-get install iptables-persistent
2、持久化信息sudo service iptables-persistent save
硬盘挂载优雅方法1、查看硬盘fdisk -l
2、格式化并创建挂载目录
# mkfs -t ext4 /dev/sdbmkfs.ext4 /dev/sdbmkdir /sdbblkid /dev/sdb

3、添加自动挂载，编辑 /etc/fstab ，添加
# /dev/sdb1 /sdb ext4 defaults 0 0&lt;blkid&gt; /sdb ext4 defaults 0 0

4、执行挂载mount -a
常规方法1、查看硬盘fdisk -l
2、硬盘分区（可选）fdisk /dev/sdb
按照提示，依次输入p，n，回车（Partition number），回车（First sector），回车（Last sector），w。
3、格式化
# mkfs -t ext4 /dev/sdb1mkfs.ext4 /dev/sdb1

4、挂载
mkdir /sdbmount /dev/sdb1 /sdbdf -h

5、自动挂载，编辑 /etc/fstab ，添加
/dev/sdb1 /sdb ext4 defaults 0 0

rm垃圾桶rm命令杀伤力很大，如果误删了系统文件，会很麻烦。所以，给linux系统建立一个垃圾桶，是很有必要的，详情参考Make “rm” Command To Move The Files To “Trash Can”。
1、下载安装saferm.sh
git clone https://github.com/lagerspetz/linux-stuffsudo mv linux-stuff/scripts/saferm.sh /binrm -Rf linux-stuff

2、编辑.bashrc文件，末尾添加
alias rm=saferm.shalias sudo='sudo '

3、使环境生效source .bashrc之后，再使用rm或者sudo rm命令，实际上执行的是mv操作，移动文件到Trash目录。
书签linux核心下载
linux软件包下载
手把手教你如何建立自己的Linux系统
CROSS LFS
Linux From Scratch
LFS linux的安装过程
Linuxsir
Gentoo Linux文档
Unix技术网
IT技术认证考试
自动生成Makefile官方教程
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下使用VirtualBox</title>
    <url>/dev-linux-virtualbox/</url>
    <content><![CDATA[前言一直以来，都是在windows系统上使用虚拟机。今天和树添聊天时发现，在linux系统上，没有图形界面，同样可以使用虚拟机，只不过操作方式变成了命令行。
本文，就研究一下在ubuntu16系统下使用virtualbox的方法。主要参考How to Install Oracle VirtualBox 5.2 on Ubuntu 17.10/16.04, Debian 9/8 和 VirtualBox官网下载页面


virtualbox安装1、添加安装源
sudo add-apt-repository "deb http://download.virtualbox.org/virtualbox/debian `lsb_release -cs` contrib"

2、安装包签名密钥
wget -q https://www.virtualbox.org/download/oracle_vbox_2016.asc -O- | sudo apt-key add -wget -q https://www.virtualbox.org/download/oracle_vbox.asc -O- | sudo apt-key add -

3、执行安装
sudo apt-get updatesudo apt-get install virtualbox-5.2

报错：
virtualbox-5.2 is already the newest version (5.2.12-122591~Ubuntu~xenial).You might want to run 'apt-get -f install' to correct these:The following packages have unmet dependencies: virtualbox-5.2 : Depends: libcurl3 (&gt;= 7.16.2) but it is not going to be installed                  Depends: libgl1-mesa-glx but it is not going to be installed or                           libgl1                  Depends: libx11-xcb1 but it is not going to be installed                  Depends: libxcursor1 (&gt; 1.1.2) but it is not going to be installed                  Depends: libxinerama1 but it is not going to be installed                  Recommends: libsdl-ttf2.0-0 but it is not going to be installed                  Recommends: pdf-viewer                  Recommends: libgl1E: Unmet dependencies. Try 'apt-get -f install' with no packages (or specify a solution).

执行sudo apt-get -f install，修复包依赖问题。
virtualbox使用常用命令参考virtualbox命令行。

vboxmanage -v，查看版本。
vboxmanage showvminfo &quot;Windows XP&quot;，查看某一虚拟机的信息。
vboxmanage startvm &quot;Windows XP&quot;，开启虚拟机（指定name）。
vboxmanage startvm 670e746d-abea-4ba6-ad02-2a3b043810a5，开启虚拟机（指定UUID）。
vboxmanage startvm ubuntu gui，图形化界面启动（这是默认值）。
vboxmanage startvm ubuntu headless，命令行界面启动。
vboxmanage list vms，列出所有的虚拟机。
vboxmanage list runningvms，列出现在正在运行的虚拟机。
vboxmanage list hostinfo，列出宿主机的详细信息（CPU 内存 操作系统版本等）。
vboxmanage list hostonlyifs，列出系统的hostonly网络的信息。
vboxmanage list dhcpservers，DBCP服务器的信息。

创建虚拟机很麻烦，就不实践了。具体用法参考VirtualBox命令行VBoxManage创建与管理虚拟机教程。
图形界面我们发现，使用命令行操作virtualbox有很多不方便的地方，比如创建虚拟机就很麻烦。能不能在远程linux使用VirtualBox的时候，通过图形界面使用呢？答案是可以。
要远程使用桌面，首先需要安装vncserver，参考Ubuntu如何安装vncserver。
1、切换到rootsudo -i
2、安装xfce4apt-get install xfce4 　　xfce4不会安装太多软件，最终看到的界面只有一个灰色背景加上一个shell窗口。
3、安装xrdpapt-get -y install xrdp
4、安装vnc4serverapt-get -y install vnc4server
5、配置默认使用xface作为登录界面
echo "xfce4-session" &gt;~/.xsessionservice xrdp restart

5、启动vncservervncserver，根据提示设置远程密码，默认放在/root/.vnc/passwd中，同时生成/root/.vnc/xstartup。
6、xstartup内容为：
#!/bin/sh# Uncomment the following two lines for normal desktop:# unset SESSION_MANAGER# exec /etc/X11/xinit/xinitrc[ -x /etc/vnc/xstartup ] &amp;&amp; exec /etc/vnc/xstartup[ -r $HOME/.Xresources ] &amp;&amp; xrdb $HOME/.Xresourcesxsetroot -solid greyvncconfig -iconic &amp;x-terminal-emulator -geometry 80x24+10+10 -ls -title "$VNCDESKTOP Desktop" &amp;x-window-manager &amp;

7、启动vncservervncserver
8、本地打开vncviewer client，输入ip:5901进行连接。连接成功后发现，桌面是灰色背景，桌面上只有一个shell。这就是传说中的twm界面。
9、启动virtualbox在shell中，输入virtualbox
至此，就能愉快地使用virtualbox图形界面了。
10、关闭vncserver
vncserver --listvncserver -kill :1

图形界面2以上twm桌面，可以满足我们使用virtualbox的需求，在切换窗口时可以使用Alt+Tab快捷键。但是，这款桌面实在是简单的令人发指。右键鼠标啥也没有，快捷键只能切换窗口，哪怕有个可以打开terminal的快捷键，我也就接受了，然而并没有。所以，还得折腾下，搞个更好用的桌面，参考Ubuntu如何安装vncserver。
1、备份xstartupcp /root/.vnc/xstartup{,.bak}
2、vim /root/.vnc/xstartup，修改如下：
#!/bin/shexport XKL_XMODMAP_DISABLE=1  unset SESSION_MANAGER  unset DBUS_SESSION_BUS_ADDRESS  gnome-panel &amp;  gnome-settings-daemon &amp;  metacity &amp;  nautilus &amp;  gnome-terminal &amp;

3、安装gnomeapt-get install gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal
4、启动vncservervncserver
5、连接vncserver这个桌面，已经比刚才好了很多，但是，看起来还是比较low。
6、安装ubuntu-desktop
vncserver -kill :1apt-get install ubuntu-desktopvncserver

再次连接后，看到的就是正常的桌面了，nice。
7、修改窗口大小vncserver默认的窗口大小为1024x768，使用时如果感觉窗口比较小，可以进行修改。vim /usr/bin/vncserver，如下修改：
# line 44, change$geometry = "1280x1024";
然后kill掉已经启动的vncserver，启动新的即可。
错误解决在某次远程桌面连接时，提示too many security failures，解决办法参考vncserver too many security failures。
1、重置黑名单vncconfig -display :1 -set BlacklistTimeout=0 -set BlacklistThreshold=1000000
2、连接成功后还原黑名单vncconfig -display :1 -set BlacklistTimeout=600000000000 -set BlacklistThreshold=10
书签Manage Virtualbox virtual machines under command line
How to run VirtualBox virtual machines from the command line
XShell+Xmanager实现在XShell中显示远程服务器的图形界面
Ubuntu14.04服务器:远程桌面连接
Linux下VNC配置使用总结：开启+桌面配置+安全访问
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>使用accessToken记录登录状态</title>
    <url>/dev-login-state-accesstoken/</url>
    <content><![CDATA[js设置cookie海哥的插件浏览器端用到了海哥写的Cookie插件：https://github.com/voidking/jquery-cookie ，值得好好学习一下。
cookie.prototype.setCookie('accessToken', accessToken,7);

jquery官方插件如果使用jquery官方给的cookie插件，用法如下：
$.cookie('accessToken', accessToken,&#123; expires: 7&#125;);


原生js如果使用原生的JS来操作cookie，用法如下：
//获取当前时间var date=new Date();var expireDays=7;//将date设置为7天以后的时间date.setTime(date.getTime()+expireDays*24*3600*1000);//或者也可以用date.setDate(date.getDate+expireDays);//将accessToken这个cookie设置为7天后过期document.cookie = 'accessToken='+accessToken+';expires=7';

js删除cookie海哥的插件cookie.prototype.delCookie('accessToken');

jquery官方插件$.removeCookie('accessToken');

原生JS//获取当前时间var date=new Date();//将date设置为过去的时间date.setTime(date.getTime()-10000);//将accessToken这个cookie删除document.cookie='accessToken=v; expire='+date.toGMTString();console.log(document.cookie);

js获取cookie海哥的插件var accessToken = cookie.prototype.getCookie('accessToken');

jquery官方插件var accessToken = $.cookie('accessToken');

原生jsvar accessToken = getCookie('accessToken');function getCookie(objName)&#123;    var arrStr = document.cookie.split("; ");    for(var i = 0;i &lt; arrStr.length;i ++)&#123;            var temp = arrStr[i].split("=");            if(temp[0] == objName)                 return unescape(temp[1]);    &#125;&#125;


Node端获取cookievar Cookies = &#123;&#125;;req.headers.cookie &amp;&amp; req.headers.cookie.split(';').forEach(function( Cookie ) &#123;    var parts = Cookie.split('=');    Cookies[ parts[ 0 ].trim() ] = ( parts[ 1 ] || '' ).trim();&#125;);var accessToken = Cookies['accessToken'] || '';

后记accessToken可以在前端获取后传给Node端，也可以在Node端获取。如果这个accessToken不为空，则表明该用户已经登录，否则表明该用户未登录。
参考文档jQuery Cookiehttp://plugins.jquery.com/cookie/
jQuery Cookie项目地址https://github.com/carhartl/jquery-cookie
关于document.cookie的使用http://www.cnblogs.com/newsouls/archive/2766567.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>cookie</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习——泰坦尼克号生还者分析</title>
    <url>/dev-machine-learning-titanic/</url>
    <content><![CDATA[前言实战项目：泰坦尼克号生还者分析
在这个可选项目中，你要依据乘客的一些特征，例如性别和年龄，来创造一个决策函数，预测1912年泰坦尼克号沉没事件中的生还者。从一个简单的算法开始，逐渐提高它的复杂性，直到你能准确预测给定数据中80%的乘客的生还情况。通过这个案例，我们将向你介绍机器学习纳米学位中会遇到的一些基本概念。


项目概述在这个可选的项目中，您将创建决策函数，并根据1912年泰坦尼克号海难的乘客特征，如：性别、年龄等，对乘客生还结果进行预测。您可以从一个简单的算法入手，然后逐渐增加该算法的复杂度，直至您至少能精确地预测出所提供数据中80%的乘客的生还结果。通过该项目，您可在正式开始学习本纳米学位前，了解机器学习的一些概念。你还可以在论坛找到该题目在 Kaggle 的数据链接。
此外，请确保 Python 装有完成本项目所需的程序包。我们在本项目中将使用到的 Python 库有两个，即 numpy 和 pandas。现在不需担心它们如何运作——我们将在实战项目 1 中接触到它们。本项目还将让您熟悉项目的提交程序，项目提交是您在纳米学位课程中需要完成的内容。
所需软件软件和库本项目采用以下软件和 Python 库：

Python 2.7
NumPy
pandas
matplotlib

你还需要安装和运行 Jupyter Notebook
对jupyter不熟悉的同学可以看一下这两个链接：
Jupyter使用视频教程为什么使用jupyter？如果您还未安装 Python，我们强烈推荐您安装 Python 发行版：Anaconda，其具备包括上述程序包在内的更多程序包。安装时，确保您选择的是 Python 2.7 安装程序，而不是 Python 3.x 安装程序。
如果您的计算机中已装有 Python 2.7，那么您可使用命令行上的 pip 安装 numpy， scikit-learn 和 Jupyter Notebook（之前叫’iPython’）。如果使用 pip 执行安装时出现问题，这个页面对 Windows 用户的某些程序包也是有用的。安装完 pip 之后，你可以执行下列命令安装所需要的包：
sudo pip install numpy pandas matplotlib jupyter scikit-learn
开始项目要开始这个项目，你可以访问我们的GitHub页面，或者点击这里直接下载最新的项目所需文件。
projects/titanic_survival_exploration 文件夹包含三个文件：

Titanic_Survival_Exploration.ipynb: 这是最主要的文件，项目中的主要工作都将在这个文件上完成
titanic_data.csv: 项目数据表。您将需要把这个数据加载到 notebook 里。
titanic_visualizations.py: 这个 Python 脚本包含 helper 函数，可以让数据和存活结果可视化。

为了打开 jupyter notebook，需要完成以下几步。如果你使用 Windows 系统，你需要打开命令终端或 PowerShell；如果你使用 Mac 或者 Linux 系统，直接打开Terminal 终端即可。使用 cd 命令来打开项目文件夹。例如，在 Windows 上你可以使用 cd C:\Users\username\Documents\ （username 用自己的用户名替换）找到项目所在的文件夹；在 Mac 上，你可以使用 cd ~/Documents/ 。在 Windows 上你可以使用 dir 命令，在 Mac 或者 Linux 上用 ls命令列出当前目录中的文件和文件夹。如果发现进错目录，可以使用 cd .. 返回上一级目录。
一旦你进入包含项目文件的文件夹，您可以输入命令
jupyter notebook titanic_survival_exploration.ipynb
打开一个浏览器窗口，或者新建标签页，来使用你的 notebook。依照 notebook 上的指导回答每一个问题完成这个项目。我们还提供了随项目的 READEME 文档，上面也有关于这个项目的信息和指导。
项目提交评估你的项目会由优达学城项目评审师按照 泰坦尼克号探索项目要求进行评审。请确定你仔细阅读了该要求，并在项目提交前自我对检查。要求当中的所有条目都必须合格项目才能通过。
提交文件当你准备好提交项目时，你可以把下列文件压缩成一个 zip 文件上传。或者，你可以提交你在 GitHub 的 Repo 。可以把文件夹命名为 titanic_survival_exploration 便于查找：

带有完整问题答案和代码的 titanic_survival_exploration.ipynb notebook 文件。
notebook 项目导出的 HTML 文件，命名为 report.html。

注意：所提交文件的文件名名，包括zip压缩包内的文件名，都不能含有中文及任何ASCII之外的字符，否则会造成提交失败。
如何导出HTML的说明在 notebook 的最下方。 你也许需要先在命令后通过 pip install mistune 命令安装 mistune 。当你准备好所有这些文件，并且依照项目要求核对过之后，就可以在下面的项目提交页面提交你的项目了。
如果你是第一次在优达学城提交项目，点击提交之后，要等1分钟左右才能打开提交页面。如果长时间打不开，可以刷新。如果依然无法打开项目提交页面，可以联系客服微信或者邮件至 support@youdaxue.com
后记这个项目，是优达学城《机器学习工程师》课程提供的第一个实战项目。摘录了全文，方便查看。郝同学的项目地址：https://github.com/voidking/udaciyty-machine-learning/tree/master/projects/titanic_survival_exploration
书签机器学习工程师（中/英）https://cn.udacity.com/course/machine-learning-engineer-nanodegree--nd009
数据科学入门https://cn.udacity.com/course/intro-to-data-science--ud359
如何把 Project 0 提交到 Kaggle 上http://discussions.youdaxue.com/t/project-0-kaggle/7032
Kaggle: Your Home for Data Sciencehttps://www.kaggle.com/
Titanic: Machine Learning from Disaster | Kagglehttps://www.kaggle.com/c/titanic
A Visual Introduction to Machine Learninghttp://www.r2d3.us/visual-intro-to-machine-learning-part-1/
numpy 1.12.0 : Python Package Indexhttps://pypi.python.org/pypi/numpy
pandas 0.19.2 : Python Package Indexhttps://pypi.python.org/pypi/pandas
window 下python2.7与python3.5两版本共存设置http://blog.csdn.net/u010004460/article/details/53410091
win7下python2.7安装 pip，setuptools的正确方法http://www.jincon.com/archives/213/
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>使用KeePass管理密码</title>
    <url>/dev-manage-pwd-by-keepass/</url>
    <content><![CDATA[前言一直使用Chrome管理密码，简单方便，但是今天突然意识到，Chrome管理密码有一个大坑：只要知道开机密码，就可以明文查看所有密码！而且，还可以一键导出！不能忍，于是寻求更安全的保存密码的方式，同时也要足够方便，至少可以自动填充密码和同步密码。
当前流行的秘密管理工具主要包括KeePass、LastPass、1Password和Enpass，经过简单比较，郝同学决定选择KeePass，其免费、开源、功能强大、多平台使用，密码数据库保存在本地。


KeePass简介我们需要记住许多密码，包括Windows登录密码，电子邮件帐户网站的FTP密码，在线密码（如网站会员帐户）等等。此外，我们应该为每个帐户使用不同的密码。因为如果你在任何地方只使用一个密码并且有人获得这个密码就会出现问题，一个严重的问题。小偷可以访问您的电子邮件帐户，网站等，难以想象。KeePass是一个免费的开源密码管理器，可以帮助您以安全的方式管理密码。您可以将所有密码放在一个数据库中，该数据库使用一个主密钥或密钥文件锁定。因此，您只需记住一个主密码或选择密钥文件即可解锁整个数据库。使用当前已知的最佳和最安全的加密算法（AES和Twofish）对数据库进行加密。
简单使用1、访问KeePass官网，下载对应平台的软件，本文中下载KeePass-2.42.1-Setup.exe，双击安装即可。
2、新建密码数据库File，New，OK，Input DBName，Save，Input Master password，Show expert options，Key file/provid，Use an existing file as key file，OK。这里的key file可选，使用key file会更加安全。
4、导入密码从Chrome中导出密码，File，Import，选择cvs文件导入即可。最后记得删除Chrome中的全部密码。
5、修改数据库后缀修改数据库后缀为常见文件后缀，增加安全性。
自动填充密码参考Keepass用插件实现网页自动填写功能，进行配置。
Keepass插件1、下载KeePassHttp.plgx
2、将 KeePassHttp.plgx 移动到 keepass 安装目录的 Plugins 目录下，在任务栏右键退出 keepass，然后重新打开 keepass。
3、在keepass菜单栏点击Tools，KeePassHTTP Options，Advanced，勾选Always allow access to entries和Always allow updating entries，Save。
Chrome插件1、安装KeePassHttp-Connector
2、点击Chrome右上角的KeePassHttp-Connector图标，选择settings。选择连接数据库Connected Databases页面，点击右下角的Connect。keepass会弹出窗口，我们填入一个key，用来标记这个客户端。
使用打开一个使用过的网站，首次使用自动填写功能，会有弹出框提醒。勾选Remember this decision，然后单击Allow。如果已经勾选Always allow access to entries和Always allow updating entries，则不会出现弹出框。
注册一个新网站，填入用户名密码后，KeePassHttp-Connector图标会变成红色，点击它可以选择保存新密码。
同步密码参考通过 Google drive 备份与同步 Keepass 数据库，使各个设备的密码可以同步。
1、下载安装Google Drive
2、选择云端文件同步到本地。
3、把keepass数据库放入同步文件夹。
4、安卓设备下载安装keepass2android。
5、打开keepass2android，存储类型选择Google Drive，打开keepass数据库即可。
后记使用KeePassHttp-Connector有一个坑，必须保证keepass处于unlock的状态，这就相当于在桌面摆着自己的密码！找到了替代方案，CKP - KeePass integration for Chrome，但是该插件不能添加新密码，也无法更新密码。方便安全难两全，就这么用着吧，也许以后能找到更好的办法。
书签有什么值得推荐的密码管理软件？
怎么使用密码管理器如keepass更安全？
KeeWeb：一个开源且跨平台的密码管理工具
KeeWeb-WebApp
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>使用LastPass管理密码</title>
    <url>/dev-manage-pwd-by-lastpass/</url>
    <content><![CDATA[前言之前整理过一篇《使用KeePass管理密码》，也实际使用了一段时间的KeePass，但是发现这个工具并不能很好地满足自己的需求。因为KeePass适合用来本地存储密码，但是用来自动填充密码，还是不够好用。
本文中，将会学习使用更加方便的LastPass，用来存储管理安全级别为商密和普密的密码。


简单使用1、访问LastPass官网，创建账号，然后在chrome安装LastPass插件。
2、在chrome登录lastpass账号。
3、正常访问网站，登录后会提示保存密码到lastpass，下次登录即可自动填充密码。
导出导入密码keepass导出密码假设之前使用keepass管理密码，需要进行导出。1、使用keepass打开数据库文件
2、File，Export，KeePass XML，Export to，OK。
lastpass导入密码1、点击lastpass图标，Account Options，Advance，Import，Other。
2、Source选择KeePass
3、使用打开xml密码文件，复制，粘贴到Centent。
4、UPLOAD，IMPORT SELECTED或者IMPORT ALL。
lastpass导出密码1、点击lastpass图标，Account Options，Advance，Export，LastPass CSV File。
2、复制页面的文本，保存为csv文件。
后记和keepass相比，lastpass确实更加实用。个人经验是使用lastpass代替chrome的密码管理，保存管理商密和普密；使用keepass或者其他方法保存核密。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>蚁群算法解决TSP问题</title>
    <url>/dev-matlab-aco-tsp/</url>
    <content><![CDATA[TSP问题旅行商问题，即TSP问题（Travelling Salesman Problem）又译为旅行推销员问题、货郎担问题，是数学领域中著名问题之一。假设有一个旅行商人要拜访n个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。


设计思路1、随机生成n个位置（坐标），把坐标点绘制到页面上。
2、设置蚂蚁数量为m，把m只蚂蚁随机放在n个位置上。
3、设置每条路径的初始信息素为 $info_{ij}(0) = C$。
4、计算t时刻蚂蚁k（1到m）由位置i移动到位置j的概率 $probability_{ij}^k$。$$probability_{ij}^k =\begin{cases}\frac{info_{ij}^α(t) reciprocal_{ij}^β}{\sum info_{is}^α(t) reciprocal_{is}^β}, &amp; j \in allowed_k,s \in allowed_k \0, &amp; \text{other}  \\end{cases}$$
（1）$info_{ij}(t)$ 表示t时刻ij上的信息素。$$info_{ij}(t+1) = ρ \cdot info_{ij}(t) + Δinfo_{ij}$$
ρ表示信息素挥发因子，控制信息素保留多少。$Δinfo_{ij}$表示（本次移动）ij路径遗留的信息素。
$$Δinfo_{ij} = \sum_{k=1}^m Δinfo_{ij}^k$$
$$Δinfo_{ij}^k =\begin{cases}\frac{Q}{L_k}, &amp; \text{当第k只蚂蚁经过ij时} \0, &amp; \text{当不经过时}  \\end{cases}$$
$L_k$表示（本次移动）蚂蚁k经过的路径和。
（2）$reciprocal_{ij}$ 表示ij之间距离的倒数，较近的坐标有较大的可能被选中。$$distance_{ij} = \sqrt{(x_i-x_j)^2+(y_i-y_j)^2}$$$$reciprocal_{ij} = \frac{1}{distance_{ij}}$$
（3）α表示信息启发式因子，控制信息素对概率的影响力大小，进而控制蚂蚁选择坐标。
（4）β表示期望值启发式因子，控制距离对概率的影响力的大小，进而控制蚂蚁选择坐标。（5）$allowed_k$表示蚂蚁k下一步允许选择的坐标集合，$travelled_k$表示蚂蚁k已经走过的坐标集合。
5、比较选择每个坐标的概率，依次为每只蚂蚁选择下一个坐标。
6、重复4-5，直到蚂蚁走完所有坐标。
7、使用 $travelled_k$集合，分别计算m只蚂蚁走过的路径和，选择出最小的路径和，作为本次迭代的最优解。
8、把m只蚂蚁随机放在n个位置上。
9、重复4-8，直到达到指定的迭代次数，最后一次迭代的最优解，就是我们找到的最优解。
源码分享https://github.com/voidking/TSP_MATLAB.git
书签Mathjax与LaTex公式简介http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/
]]></content>
      <categories>
        <category>专业</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>知识工程</tag>
        <tag>mathjax</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传算法解决TSP问题</title>
    <url>/dev-matlab-ga-tsp/</url>
    <content><![CDATA[TSP问题旅行商问题，即TSP问题（Travelling Salesman Problem）又译为旅行推销员问题、货郎担问题，是数学领域中著名问题之一。假设有一个旅行商人要拜访n个城市，他必须选择所要走的路径，路径的限制是每个城市只能拜访一次，而且最后要回到原来出发的城市。路径的选择目标是要求得的路径路程为所有路径之中的最小值。


设计思路1、随机生成N的位置（坐标），把坐标点绘制到页面上。2、设置种群规模为M，每个个体生成1到N的随机序列。3、计算每个个体的适应度（路径总长度）。4、寻找出当前迭代的最优解，把最优解路线绘制到页面上。5、交叉，变异，生成新的一代种群。6、重复3-5，直到迭代次数到达指定次数。
对比实验TSP问题的解法，还有回溯法、分支限界法、近似算法、动态规划法、蚁群算法等。对比遗传算法和其他算法求解TSP问题的数据量、数据分布以及实验结果（求解时间等），找出遗传算法的优缺点，适用于数据量多少，数据分布是什么情况。
然而，工作量很大，暂时搁置，完成后也能写篇不错的论文了吧。
源码分享https://github.com/voidking/TSP_MATLAB.githttps://github.com/voidking/GA4TSPProblem.git
]]></content>
      <categories>
        <category>专业</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>知识工程</tag>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse配置Maven</title>
    <url>/dev-maven-eclipse-setting/</url>
    <content><![CDATA[前言Eclipse的自带Maven，在一般情况下就够用了。但是，由于版本要求或者高级功能要求，我们不得不自己安装配置Maven。
下载安装详见《Maven本地安装jar文件》
Eclipse配置Eclipse，Window，Preferences。


1、Maven，Installations，Add，然后选择Maven的安装路径。
2、Maven，User Settings，User Settings选择Maven下的setting.xml。
3、编辑settings.xml，释放&lt;localRepository&gt;&lt;/localRepository&gt;节点，中间加上本地Repository路径。
4、Java，Installed JREs，Edit，在Default VM arguments中设置-Dmaven.multiModuleProjectDirectory=$M2_HOME
后记在使用Eclipse自带Maven的过程中，如果出现了一些无法理解的错误，不妨试试自己配置一个Maven。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven本地安装jar文件</title>
    <url>/dev-maven-local-install-jar/</url>
    <content><![CDATA[下载安装Maven平时使用的，是Eclipse的Eclipse IDE for Java EE Developers 版本，自带Maven。但是，想要使用Maven本地安装jar文件，就需要自己安装Maven。
下载地址： http://maven.apache.org/download.cgi
1、解压到自己喜欢的目录（这里郝同学放到D:\Server路径下）。2、添加环境变量M2_HOME，值为D:\Server\apache-maven-3.3.33、在Path中添加;%M2_HOME%\bin;。
打开命令提示符，输入mvn -v，如果能够看到maven版本号，说明安装成功。
Oracle驱动jar包安装以安装Oracle驱动jar包为例。由于Oracle授权问题，Maven不提供Oracle JDBC Driver，为了在Maven项目中应用Oracle JDBC driver,必须手动添加到本地仓库。
下载jar包JDBC、SQLJ、Oracle JPublisher 和通用连接池 (UCP)JDBC and Universal Connection Pool (UCP)
郝同学使用的是Oracle11g，下载下来的jar包名为ojdbc14.jar。通过解压缩软件看到，jar包中有一个META-INF/MANIFEST.MF文件。打开这个文件，我们看到
Manifest-Version: 1.0Specification-Title:    Oracle JDBC driver classes for use with JDK14Sealed: trueCreated-By: 1.4.2_08 (Sun Microsystems Inc.)Implementation-Title:   ojdbc14.jarSpecification-Vendor:   Oracle CorporationSpecification-Version:  Oracle JDBC Driver version - "10.2.0.3.0"Implementation-Version: Oracle JDBC Driver version - "10.2.0.3.0"Implementation-Vendor:  Oracle CorporationImplementation-Time:    Tue Feb 27 15:23:24 2007Name: oracle/sql/converter/Sealed: falseName: oracle/sql/Sealed: falseName: oracle/sql/converter_xcharset/Sealed: false
等下我们要用到version信息：10.2.0.3.0。

安装命令打开命令提示符，进入到ojdbc.jar所在的文件夹下，执行以下命令：
mvn install:install-file -DgroupId=com.oracle -DartifactId=ojdbc14 -Dversion=10.2.0.3.0 -Dpackaging=jar -Dfile=ojdbc14.jar
看到BUILD SECCESS就说明大功告成了！
也许你会问，Dfile参数可不可以使用绝对路径？答：不可以。我在使用绝对路径的时候失败了，不知道为什么。
其实，上面的DgroupId、DartifactId、Dversion全部可以按照自己喜好来定义，只是，在配置pom.xml的时候会用到。所以，我们还是尽可能规范一些。
本地仓库路径默认为C:\Users\Administrator\.m2\repository，在这个路径下，你可以看到本地已经安装的jar包。
pom.xml中配置&lt;!-- Oracle驱动 --&gt;&lt;dependency&gt;	&lt;groupId&gt;com.oracle&lt;/groupId&gt;	&lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;	&lt;version&gt;10.2.0.3.0&lt;/version&gt;&lt;/dependency&gt;

SQLServer驱动jar包安装类似于Oracle驱动jar包安装，记录命令如下：
mvn install:install-file -DgroupId=com.microsoft.sqlserver -DartifactId=jdbc -Dversion=1.1.1 -Dpackaging=jar -Dfile=sqljdbc4.jar
pom.xml配置如下：
&lt;dependency&gt;	&lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;	&lt;artifactId&gt;sqljdbc4&lt;/artifactId&gt;	&lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;

参考文档在Maven仓库中添加Oracle JDBC驱动
maven3 手动安装本地jar到仓库
MAVEN安装JAR文件到本地仓库
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven项目显示叉号</title>
    <url>/dev-maven-project-fork/</url>
    <content><![CDATA[问题描述明明没有错误的Maven项目，导入到Eclipse之后，项目名的旁边会出现一个叉号。虽然不影响项目的使用，但是，看起来总有一点不爽。
解决办法单击项目，然后alt+F5，Update Maven Project。大部分的项目，都可以通过这个方法去掉叉号。暂时不懂得原理，随着学习的深入，会懂得的。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven概述</title>
    <url>/dev-maven-start/</url>
    <content><![CDATA[Maven是什么Maven这个单词来自于意第绪语，意为知识的积累，最早在Jakata Turbine项目中它开始被用来试图简化构建过程。
Maven是基于项目对象模型(POM，Project Object Model)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具。
Maven能做什么Maven采用了一种被称之为POM的概念来管理项目，所有的项目配置信息都被定义在一个叫做pom.xml的文件中，通过该文件，Maven可以管理项目的整个声明周期，包括编译，构建，测试，发布，报告等等。目前Apache下绝大多数项目都已经采用Maven进行管理。而Maven本身还支持多种插件，可以方便更灵活的控制项目。
郝同学使用Maven，最深切的体会是，不用手动导入jar包，写写配置文件就搞定了，真方便！


jar包依赖使用maven不需要上网单独下载jar包，只需要在配置文件pom.xml中配置jar包的依赖关系，就可以自动的下载jar包到我们的项目中。这样，别人开发或者使用这个工程时，不需要来回的拷贝jar包，只需要复制这个pom.xml就可以自动的下载这些jar包。
而且，我们自己下载jar包，还有可能造成版本的不一致，这样在协同开发的过程中就有可能造成代码运行的不一致。通过使用maven精确的匹配jar包，就不会出现这种问题了。
项目坐标Maven通过特定的标识来定义项目名称，这样既可以唯一的匹配其他的jar包，也可以通过发布，使别人能使用自己的发布产品。这个标识就被叫做坐标，长的其实很普通，就是简单的xml而已：
&lt;groupId&gt;com.voidking.pandawork&lt;/groupId&gt;&lt;artifactId&gt;pandawork-start&lt;/artifactId&gt;&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;packaging&gt;jar&lt;/packaging&gt;&lt;name&gt;pandawork-start&lt;/name&gt;&lt;url&gt;http://maven.apache.org&lt;/url&gt;
groupId：所述的项目名称，由于有的项目并不是一个jar包构成的，而是由很多的jar包组成的。因此这个groupId就是整个项目的名称。
artifactId：包的名称。
version：版本号。
packaging：包的类型，一般都是jar，也可以是war之类的。如果不填，默认就是jar。
name和url，一个是名称，一个是maven的地址。主要就是上面的几个参数。
当想要依赖什么jar的时候就可以通过下面的方式依赖：
&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;junit&lt;/groupId&gt;    &lt;artifactId&gt;junit&lt;/artifactId&gt;    &lt;version&gt;3.8.1&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;

各个属性的内容基本上都是一样的。
这里要注意的是jar包的命名规则：
artifactId-version[-classifier].packaging
比如上面的pom.xml生成的jar包名字就是：pandawork-start-0.0.1-SNAPSHOT.jar。
这里的classifier是可选的，但是有的项目可能还需要导出附属的一些文件，如javadoc，source等等，那么这个地方就需要配置一个字符串。一般都是JDKXXX之类的。
测试驱动Maven是测试驱动的开发思路，因此工程创建初期，就包含两个文件夹，main和test。一个用于放置开发的java文件，一个用于写test单元测试。这样每次开发的时候，提前设计单元测试，就能帮助减少BUG。
Maven生命周期Maven有三套相互独立的生命周期，请注意这里说的是“三套”，而且“相互独立”。这三套生命周期分别是：

Clean Lifecycle 在进行真正的构建之前进行一些清理工作。
Default Lifecycle 构建的核心部分，编译，测试，打包，部署等等。
Site Lifecycle 生成项目报告，站点，发布站点。

再次强调一下它们是相互独立的，你可以仅仅调用clean来清理工作目录，仅仅调用site来生成站点。当然你也可以直接运行 mvn clean install site 运行所有这三套生命周期。
Clean每套生命周期都由一组阶段(Phase)组成，我们平时在命令行输入的命令总会对应于一个特定的阶段。比如，运行mvn clean ，这个的clean是Clean生命周期的一个阶段。Clean生命周期一共包含了三个阶段：

pre-clean  执行一些需要在clean之前完成的工作
clean  移除所有上一次构建生成的文件
post-clean  执行一些需要在clean之后立刻完成的工作

mvn clean中的clean就是上面的clean，在一个生命周期中，运行某个阶段的时候，它之前的所有阶段都会被运行，也就是说，mvn clean 等同于 mvn pre-clean clean ，如果我们运行 mvn post-clean ，那么 pre-clean，clean 都会被运行。这是Maven很重要的一个规则，可以大大简化命令行的输入。
SiteSite生命周期的各个阶段：

pre-site     执行一些需要在生成站点文档之前完成的工作
site    生成项目的站点文档
post-site     执行一些需要在生成站点文档之后完成的工作，并且为部署做准备
site-deploy     将生成的站点文档部署到特定的服务器上这里经常用到的是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，Manager比较喜欢，文档及统计数据自动生成，很好看。

DefaultMaven的最重要的是Default生命周期，绝大部分工作都发生在这个生命周期中，这里，我只解释一些比较重要和常用的阶段：

validate
generate-sources
process-sources
generate-resources
process-resources     复制并处理资源文件，至目标目录，准备打包。
compile     编译项目的源代码。
process-classes
generate-test-sources 
process-test-sources 
generate-test-resources
process-test-resources     复制并处理资源文件，至目标测试目录。
test-compile     编译测试源代码。
process-test-classes
test     使用合适的单元测试框架运行测试。这些测试代码不会被打包或部署。
prepare-package
package     接受编译好的代码，打包成可发布的格式，如 JAR 。
pre-integration-test
integration-test
post-integration-test
verify
install     将包安装至本地仓库，以让其它项目依赖。
deploy     将最终的包复制到远程的仓库，以让其它开发人员与项目共享。

基本上，根据名称我们就能猜出每个阶段的用途，关于其它阶段的解释，请参考 http://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html
记住，运行任何一个阶段的时候，它前面的所有阶段都会被运行，这也就是为什么我们运行mvn install 的时候，代码会被编译，测试，打包。
Maven常用命令
mvn -h不会用时，可寻求帮助。

mvn archetype:create -DgroupId=packageName -DartifactId=projectName创建Maven的普通java项目

mvn archetype:create -DgroupId=packageName -DartifactId=webappName -DarchetypeArtifactId=maven-archetype-webapp创建Maven的Web项目

mvn compile编译源代码

mvn test-compile编译测试代码

mvn test运行测试

mvn install在本地Repository中安装jar

mvn clean install

mvn jetty:run调用 Jetty 插件的 Run 目标在 Jetty Servlet 容器中启动 web 应用 


学习资料Maven官网
将maven源改为国内阿里云镜像
Maven教程
maven pom.xml文件详解
Maven那点事儿（Eclipse版）
Maven生命周期详解
mvn常用命令
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>MediaWiki安装与配置</title>
    <url>/dev-mediawiki-install-and-config/</url>
    <content><![CDATA[MediaWiki简介MediaWiki全球最著名的开源wiki程序，运行于PHP+MySQL环境。MediaWiki从2002年2月25日被作为维基百科全书的系统软件，并有大量其他应用实例。MediaWiki的开发得到维基媒体基金会的支持。
本文，就来研究一下MediaWiki的安装和配置，数据库和Web程序位于不同的主机。主要参考Ubuntu 16.04 安装 MediaWiki和Manual:Running MediaWiki on Debian or Ubuntu。


环境准备数据库数据库使用mysql，下面在主机A（IP为10.0.0.19）中进行安装配置。1、安装sudo apt-get install mysql-server mysql-client安装过程中设置数据库root密码。
2、sudo mysql -u root -p登录mysql，如下配置：
create database wikidb;create user 'wiki'@'%' identified by 'voidking';grant all privileges on wikidb.* to 'wiki'@'%';flush privileges;quit;

3、sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf，修改绑定IP
bind-address            = 0.0.0.0

4、重启mysqlsudo service mysql restart
5、测试登录mysql -u wiki -h 10.0.0.19 -p
Apache和PHP在主机B中安装Apache和PHP
sudo apt-get install -y apache2 php php-mysql libapache2-mod-php php-xml php-mbstring

安装部署在主机B（IP为10.0.0.20）中安装mediawiki，步骤如下。
1、下载mediawiki
cd /tmp/wget https://releases.wikimedia.org/mediawiki/1.32/mediawiki-1.32.1.tar.gz

2、解压重命名
tar -xvzf /tmp/mediawiki-*.tar.gzsudo mkdir /var/lib/mediawikisudo mv mediawiki-*/* /var/lib/mediawiki

3、创建链接
sudo ln -s /var/lib/mediawiki /var/www/html/mediawiki

4、重启apachesudo service apache2 restart
5、端口映射正常情况下，此时mediawiki的访问地址为：
http://10.0.0.20/mediawiki/http://10.0.0.20/mediawiki/mw-config/index.php
但是主机B的IP无法直接访问，所以参考《iptables实现端口映射》进行端口映射，映射后mediawiki的访问地址为：
http://172.16.101.144:2080/mediawiki/http://172.16.101.144:2080/mediawiki/mw-config/index.php

6、测试访问访问映射后的地址，浏览器居然不解析php文件，直接写下载php文件。这是mediawiki的bug吗？测试一下，在/var/www/html中创建index.php，内容为：
&lt;?php    phpinfo();?&gt;
浏览器访问http://172.16.101.144:2080/index.php，正常解析。猜测是mediawiki的锅，换了五个版本的mediawiki，居然存在同样的问题。莫非，是因为设置了端口映射？
参考《Linux下使用VirtualBox》，访问linux图形界面，然后输入firefox启动火狐浏览器，访问地址：
http://10.0.0.20/mediawiki/http://10.0.0.20/mediawiki/mw-config/index.php
正常解析页面，看来是确实是因为端口映射。
7、在浏览器中进行mediawiki的初始化，主要是mysql相关配置，按照主机A中的mysql配置来填写。
8、完成后下载LocalSettings.php，拷贝LocalSettings.php到/var/lib/mediawiki/目录中。
9、测试访问
http://172.16.101.144:2080/mediawiki/index.php/Main_Pagehttp://10.0.0.20/mediawiki/index.php/Main_Page
外部通过端口映射访问，内部通过真实IP访问，都正常。至此，大功告成，nice。
书签TPC-W官网
TPC-W-University of Wisconsin
TPC-W安装与配置（威斯康星大学Java版）
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>linux</tag>
        <tag>mysql</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>决策树迷你项目</title>
    <url>/dev-ml-dt/</url>
    <content><![CDATA[项目背景在本项目中，我们将再次尝试确认邮件作者，但这次使用的是决策树。初始代码可以在 decision_tree/dt_author_id.py 中找到。
你仍需要在你计算机上完成迷你项目，在浏览器中输入答案。你可以在这里找到决策树迷你项目的说明。


运行起来使用 decision_tree/dt_author_id.py 中的初始代码，准备好决策树并将它作为分类器运行起来，设置 min_samples_split=40。可能需要等一段时间才能开始训练。
准确率是多少？
training time: 136.862 s0.978384527873

加速你从 SVM 迷你项目中了解到，参数调整可以显著加快机器学习算法的训练时间。一般情况下，参数可以调整算法的复杂度，越复杂的算法通常运行起来越慢。
控制算法复杂度的另一种方法是通过你在训练/测试时用到的特征数量。算法可用的特征数越多，越有可能发生复杂拟合。我们将在“特征选择”这节课中详细探讨，但你现在可以提前有所了解。
1、从你的数据中找出特征的数量，数据是以 numpy 数组的形式排列的，其中数组的行数代表数据点的数量，列数代表特征的数量；为了提取这个数值，可以写一行这样的代码len(features_train[0])
3785

2、进入 tools/email_preprocess.py，会看到这样的代码：selector = SelectPercentile(f_classif, percentile=10) ，将 percentile 从 10 改为 1。现在的特征数量是多少呢？
379


3、你认为 SelectPercentile 起到什么作用？其他所有的都不变的情况下，赋予percentile的值较大是否得到一棵更加复杂的或者简化的决策树？答：赋予percentile的值较大，得到更复杂的决策树。
4、注意训练时间的不同取决于特征的数量。
5、当 percentile 等于 1 时，准确度是多少？
training time: 9.185 s0.966439135381


源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>安然迷你项目</title>
    <url>/dev-ml-enron/</url>
    <content><![CDATA[项目简介安然欺诈案是一个混乱而又引人入胜的大事件，从中可以发现几乎所有想像得到的企业违法行为。安然的电子邮件和财务数据集还是巨大、混乱的信息宝藏，而且，在你稍微熟悉这些宝藏后，它们会变得更加有用。我们已将这些电子邮件和财务数据合并为一个数据集，而你将在此迷你项目中研究它。
开始：克隆这个 GitHub 库：https://github.com/udacity/ud120-projects运行开始代码：datasets_questions/explore_enron_data.py


数据集大小聚合的安然电子邮件和财务数据集被存储到字典中，字典中的每个键是一个人名，而且值是包含此人所有特征的一个字典。
电子邮件和财务 (E+F) 数据字典被存储在 pickle 文件中，该文件可直接存储和加载 python 对象，非常方便。 使用 datasets_questions/explore_enron_data.py 加载数据集。
数据集中有多少数据点（人）？答：146
数据集特征对于每个人，有多少个特征可用？答：21
查找POI根据我们的定义，“POI”（Person of interest，嫌疑人）特征记录着一个人是否为相关人士的信息。
数据集中有多少 POI？也就是说，计算 data[person_name][“poi”]==1 时，字典中条目的数量。答：18
更换数据源后存在多少 POI？我们编辑了一个包含所有 POI 姓名的列表（在 ../final_project/poi_names.txt 中）并附上了相应的邮箱地址（在 ../final_project/poi_email_addresses.py 中）。
总共有多少 POI？(使用姓名列表，不要用邮箱地址，因为许多雇员不止一个邮箱，而且其中少数人员不是安然的雇员，我们没有他们的邮箱地址。)答：35
不完整数据你可以看到，我们在数据集中有许多POI，但不是所有。这为何会是一个潜在的问题？
我们将在稍后解释POI为何有可能不在安然数据集中，这样你就可以在往下继续之前完全理解这个问题。
查询数据集和任何字典一样，个人特征可以这样被访问：
enron_data[“LASTNAME FIRSTNAME”][“feature_name”]或者enron_data[“LASTNAME FIRSTNAME MIDDLEINITIAL”][“feature_name”]
1、James Prentice 名下的股票总值是多少？答：1095040
2、有多少来自 Wesley Colwell 的发给嫌疑人的电子邮件？答：11
3、Jeffrey K Skilling 行使的股票期权价值是多少？答：19250000
研究安然欺诈案在下面的课程中，我们将介绍为什么大部分情况下，最好的特征都来自我们的直觉。这意味着我们将对安然欺诈案稍作了解。
如果你能腾出一个半小时的时间，可以观看《安然：房间中最聪明的伙计（Enron: The Smartest Guys in the Room）》这部纪录片，它精彩概述了整个事件。另外，还有许多报纸和故事记录着安然的兴衰成败。
下面这些阴谋中，哪一个没有安然的参与？

每月底向空壳公司出售资产，并在次月初购回，以隐瞒会计损失
造成加州电网断电
非法获取政府报告，垄断浓缩橙汁行业
图谋为一名沙特王子加急办理美国公民身份
计划与卖座电影合作在网上传输电影

1、欺诈案发生的多数时间内，安然的 CEO 是谁？答：Jeffrey Skilling
2、安然的董事会主席是谁？答：Kenneth Lay
3、欺诈案发生的多数时间内，安然的 CFO（首席财务官）是谁？答：Andrew Fastow
4、这三个人（Lay、Skilling 和 Fastow）当中，谁拿回家的钱最多（“total_payments”特征的最大值）？答：LAY KENNETH L 103559793
5、对于数据集中的所有人，不是每一个特征都有值。当特征没有明确的值时，我们使用什么来表示它？答：NaN
6、此数据集中有多少雇员有量化的工资？已知的邮箱地址是否可用？答：95，111
字典到数组转换不能将 python 字典直接读入到 sklearn 分类或回归算法中；它其实需要一个 numpy 数组，或者一个由列表组成的列表（此列表本身是一个列表，它的每个元素都是数据点，而较小列表的元素是该点的特征）。
我们编写了一些辅助函数（tools/feature_format.py 中的 featureFormat() 和 targetFeatureSplit()），它们可以获取特征名的列表和数据字典，然后返回 numpy 数组。
如果特征没有某个特定人员的值，此函数还会用 0（零）替换特征值。
缺少POI如你刚才所见，不是每个 POI 在数据集中都有一个条目（比如：Michael Krautz）。那是因为数据集是通过你在 final_project/enron61702insiderpay.pdf 中找到的财务数据所创建的，这些数据中缺少了一些 POI（这些缺失的 POI 被传送至最终的数据集）。另一方面，对于这些“缺少的”POI，我们确实有他们的邮件。
尽管向数据集中添加这些 POI 和他们的信息，并且为财务信息设置“NaN”非常简单，但这会带来一个微妙的问题。你将在此处了解到这一问题。
1、（当前的）数据集中有多少人的薪酬总额被设置了“NaN”？数据集中这些人的比例占多少？答：21，14.3835616438%
2、数据集中有多少 POI 的薪酬总额被设置了“NaN”？这些 POI 占多少比例？答：0，0.0%
3、如果机器学习算法将 total_payments 用作特征，你希望它将“NaN”值关联到 POI 还是非 POI？答：非POI
4、如果你再次添加了全是 POI 的 10 个数据点，并且对这些雇员的薪酬总额设置了“NaN”，你刚才计算的数字会发生变化。数据集中这些人的数量变成了多少？薪酬总额被设置了“NaN”的雇员数变成了多少？答：156，31
5、数据集中的 POI 数量变成了多少？薪酬总额被设置了“NaN”的 POI 数量变成了多少？答：28，10
6、在添加了新的数据点后，你是否认为，监督式分类算法可将 total_payments 为“NaN”理解为某人是 POI 的线索？答：是
混合数据源此例中加入了新的 POI，而我们没有任何人的财务信息，这就带来了一个微妙的问题，即算法可能会注意到我们缺少他们的财务信息，并将这一点作为他们是POI的线索。换个角度来看，为我们的两个类生成数据的方式现在有所不同 - 非POI的人全都来自财务电子表格，之后手动加入了许多POI。这种不同可能会诱使我们以为我们的表现优于实际状况 - 假设你使用 POI 检测器来确定某个未见过的新人是否是 POI，而且该人不在电子表格上。然后，他们的所有财务数据都将包含“NaN”，但该人极有可能不是 POI（世界上非 POI 的人比 POI 多得多，即使在安然也是如此）- 然而你可能会无意中将他们标识为 POI！
这就是说，在生成或增大数据集时，如果数据来自不同类的不同来源，你应格外小心。它很容易会造成我们在此展示的偏差或错误类型。可通过多种方法处理此问题。举例而言，如果仅使用了电子邮件数据，则你无需担心此问题（在这种情况下，财务数据中的差异并不重要，因为并未使用财务特征）。还可以通过更复杂的方法来估计这些偏差可能会对你的最终答案造成多大影响，不过此话题超出了本课程的范围。
目前的结论就是，要非常小心地对待引入来自不同来源（具体取决于类）的特征这个问题！引入此类特征常常会意外地带来偏差和错误。
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>评估迷你项目</title>
    <url>/dev-ml-evaluation/</url>
    <content><![CDATA[项目简介返回至你上节课的代码，你在其中使用决策树和一个特征构建了 POI 识别符的首个简单迭代。 将你构建的 POI 识别符复制到 evaluation/evaluate_poi_identifier.py 内的骨架代码中。 回忆一下在该项目结尾，你（测试集上的）识别符有 0.724 的准确率。不是很差，对吧？让我们更为仔细地探究你的预测值。


测试集对于 POI 识别符的测试集，有多少 POI 被预测到了？答：4(注意我们说的是测试集！我们期望看到的不是整个数据集中 POI 的数量。)
你的测试集中的总人数是多少？答：29
如果测试集中所有人的识别符都被预测为 0（非 POI），其准确率会是多少？0.8620689655172413
True Positive 数量把你的过拟合模型的预测与真实测试标签比较，你得到 true positive 了吗？（在此情况下，我们定义的 true positive 中实际标签和预测标签均为 1）答：Nope
精确率和召回率如你现在可能看到的，类似于安然数据集（非 POI 多于 POI）中的那些不平衡类会带来一些特殊的挑战，即你可以为每个点推测出更为常见的类标签，虽然这不是一个非常有水准的策略，但却仍然能够获得相当不错的准确率！
精确率和召回率可以更好地说明性能。使用 sklearn.metrics 中可用的 precision_score 和 recall_score 来计算这些数量。
精确率是多少？答：0
召回率是多少？答：0
（注意：你可能看到过类似于“用户警告：一些标签的精确率和召回率等于零”的消息。 就像其中所显示的，当精确率和/或召回率为零时，计算其他指标（比如 F1 分数）可能会出现问题，而且在问题发生时，警告消息会显示出来。） 
显然，这并不是一个优化得非常好的机器学习策略（我们没有尝试过决策树以外的任何算法，或调整过任何参数，也没有进行过任何特征选择）， 现在看来，精确率和召回率要比准确率更直观。
混淆矩阵在最终项目中，你将使用在本课程中学习到的众多工具优化 POI 识别符。希望结果是你的精确率和/或召回率会提高，但是你必须能够解读它们。
此处为一些编造的预测值和假设的测试集的真标签；在以下方框中填空，练习识别 true positive、false positive、true negative 和 false negative。 让我们按照惯例，使用“1”表示正结果，“0”表示负结果。
预测值 = [0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1]
真实标签 = [0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0]
有多少 true positive？答：6
此示例中有多少 true negative？答：9
此示例中有多少 false positives？答：3
此示例中有多少 false negatives？答：2
这个分类器的精确率是多少？答：0.666666666667
这个分类器的召回率是多少？答：0.75
理解指标1、填空：
“我的 true positive 率很高，这意味着当测试数据中出现（POI）时，我擅长于标记他或她。”
2、填空：
“我的识别符没有很好的（precision），但是有不错的（recall）。 这意味着，无论我测试集中的 POI 何时被标记，我都可以明确地知道那很有可能是真实的 POI 而非虚警。 另一方面，我为此付出的代价是我有时候会错过真实的 POI，因为我实际上不太情愿触及边界情形。 ”
3、填空：
“我的识别符没有很好的（recall），但是有不错的（precision）。 这意味着，无论我测试集中的 POI 何时被标记，我都可以明确地知道那很有可能是真实的 POI 而非虚警。 另一方面，我为此付出的代价是我有时候会错过真实的 POI，因为我实际上不太情愿触及边界情形”
4、填空：
“我的识别符有非常好的（F1 score）。这是两个世界中最好的识别符，我的 false positive 和 false negative 率均为（low），这意味着我可以可靠、准确地识别 POI。 如果我的识别符发现了 POI，那么此人几乎可以肯定是 POI，而且如果识别符没有标记某人，那么几乎可以肯定他们不是 POI。”
POI 识别符指标我们通常需要在精确率和召回率之间进行取舍——你认为在 POI 识别符中哪个更重要？ 答案没有对错，因为无论怎样都会得到很好的论证，但是你应能解读这两个指标，并且清楚表述你发现哪个最重要以及为什么。
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>特征缩放迷你项目</title>
    <url>/dev-ml-feature-scaling/</url>
    <content><![CDATA[项目简介在上一个项目中，你将安然人物的财务数据作为输入，对这些人物执行了 k-均值聚类。我们将更新那部分工作，以包含被缩放的特征，看看会有怎样的变化。


缩放类型回顾 K-均值聚类迷你项目最后一部分。我们当时没有详细探讨缩放算法而部署了缩放，但是你现在更加了解具体的缩放算法了，并且可以分析出我们使用的是哪类缩放。
哪类缩放被部署了？
计算重缩放特征对你在上一节课中的 k 均值聚类代码的“salary”和“exercised_stock_options”特征（仅这两项特征）运用特征缩放。 原始值为 20 万美元的“salary”特征和原始值为 1 百万美元的“exercised_stock_options”特征的重缩放值会是多少？ （确保呈现浮点型而非整数型数字！）答：0.17962407，0.02902059
何时部署特征缩放有人可能会质疑是否必须重缩放财务数据，也许我们希望 10 万美元的工资和 4 千万美元的股票期权之间存在巨大差异。如果我们想基于“from_messages”（从一个特定的邮箱帐号发出的电子邮件数）和“salary”来进行集群化会怎样？ 在这种情形下，特征缩放是不必要的，还是重要的？答：重要的。
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>特征选择迷你项目</title>
    <url>/dev-ml-feature-selection/</url>
    <content><![CDATA[项目简介Katie 在视频中解释了她在为“作者识别”项目准备 Chris 和 Sara 的邮件时遇到的一个问题， 即一个特征过于强大（就像签名一样，可以说给了算法一个有失公平的优势）。你将在此亲自探究这一发现。


过拟合决策树此漏洞是在 Katie 试图为决策树迷你项目创建过拟合决策树的示例时发现的。 决策树作为传统算法非常容易过拟合，获得过拟合决策树最简单的一种方式就是使用小型训练集和大量特征。
如果决策树被过拟合，你期望测试集的准确率是非常高还是相当低？答：低
如果决策树被过拟合，你期望训练集的准确率是高还是低？答：高
特征数量和过拟合过拟合算法的一种传统方式是使用大量特征和少量训练数据。你可以在 feature_selection/find_signature.py 中找到初始代码。 准备好决策树，开始在训练数据上进行训练，打印出准确率。
根据初始代码，有多少训练点？答：18849
特别说明：根据你何时下载 find_signature.py 代码，你可能需要将第 9 至 10 行的代码更改为
words_file = "../text_learning/your_word_data.pkl" authors_file = "../text_learning/your_email_authors.pkl"
这样一来，通过运行 vectorize_text.py 创建而来的文件就可以得到适当的体现了。
另外，如果你由于内存问题而无法运行代码，而且如果你的 scikit-learn 版本是 0.16.x， 你可以从 features_train 被创建出来的行中删除 .toarray() 函数， 以节省内存——该版本中的决策树分类器可以将稀疏数组而非仅仅是密集数组作为输入。
你刚才创建的决策树的准确率是多少？答：（记住，我们设置决策树用于过拟合——理想情况下，我们希望看到的是相对较低的测试准确率。）
识别最强的特征选择（过拟合）决策树并使用 featureimportances 属性来获得一个列表， 其中列出了所有用到的特征的相对重要性（由于是文本数据，因此列表会很长）。 我们建议迭代此列表并且仅在超过阈值（比如 0.2——记住，所有单词都同等重要，每个单词的重要性都低于 0.01）的情况下将特征重要性打印出来。
最重要特征的重要性是什么？该特征的数字是多少？答：
使用 TfIdf 获得最重要的单词为了确定是什么单词导致了问题的发生，你需要返回至 TfIdf，使用你从迷你项目的上一部分中获得的特征数量来获取关联词。 你可以在 TfIdf 中调用 get_feature_names() 来返回包含所有单词的列表；抽出造成大多数决策树歧视的单词。
这个单词是什么？类似于签名这种与 Chris Germany 或 Sara Shackleton 唯一关联的单词是否讲得通？答：
删除重复从某种意义上说，这一单词看起来像是一个异常值，所以让我们在删除它之后重新拟合。 返回至 text_learning/vectorize_text.py，使用我们删除“sara”、“chris”等的方法，从邮件中删除此单词。 重新运行 vectorize_text.py，完成以后立即重新运行 find_signature.py。
有跳出其他任何的异常值吗？是什么单词？像是一个签名类型的单词？（跟之前一样，将异常值定义为重要性大于 0.2 的特征）。答： 
再次检查重要特征再次更新 vectorize_test.py 后重新运行。然后，再次运行 find_signature.py。
是否出现其他任何的重要特征（重要性大于 0.2）？有多少？它们看起来像“签名文字”，还是更像来自邮件正文的“邮件内容文字”？答：
过拟合树的准确率现在决策树的准确率是多少？答：0.816268486917
我们已经移除了两个“签名词语”，所以要让我们的算法拟合训练集，同时不出现过拟合更为困难。记住，我们这里是想要知道我们是否会让算法过拟合，准确率如何并不是关键！
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>最终项目</title>
    <url>/dev-ml-final-project/</url>
    <content><![CDATA[项目简介在此项目中，你将扮演侦探，运用你的机器学习技能构建一个算法，通过公开的安然财务和邮件数据集，找出有欺诈嫌疑的安然雇员。


为何要进行此项目？此项目将通过机器学习的视角教授你数据调查的端到端流程。
它将教授你如何提取并识别最能代表你的数据的有用特征，当今最常用的机器学习算法，以及如何评估机器学习算法的性能。
我将学到什么？项目结束时，你将能：

处理现实当中不完美的数据集
使用测试数据验证机器学习的结果
使用定量指标评估机器学习的结果
创建、选择和转换特征
比较机器学习算法的性能
为获得最大性能调整机器学习算法
清楚表述你的机器学习算法

为什么这对我的职业发展很重要？机器学习是如今数据分析行业内的金牌敲门砖，能使你获得最令人兴奋的职业机会。
随着配套计算能力的不断发展，数据源数量与日俱增，借助数据快速进行深入探索并做出预测是最直接的方式之一。
机器学习将计算机科学及统计学结合在一起，从而获得强大的预测能力。
我要如何完成此项目？在开始之前，你应该注意，此迷你项目需要大量数据点才能给出直观的结果，并且良好地运行起来。 此项目更为棘手的原因在于，我们使用了真实的数据，这些数据可以是杂乱无章的，而且在进行机器学习时不具有我们所希望的大量数据点。 不要失去信心——作为数据分析师，你只需要习惯不完美的数据！如果你遇到之前没有见过的事物，请退后一步想想聪明的解决之道。要相信自己！
项目概述安然曾是 2000 年美国最大的公司之一。2002 年，由于其存在大量的企业欺诈行为，这个昔日的大集团土崩瓦解。 在随后联邦进行的调查过程中，大量有代表性的保密信息进入了公众的视线，包括成千上万涉及高管的邮件和详细的财务数据。 你将在此项目中扮演侦探，运用你的新技能，根据安然丑闻中公开的财务和邮件数据来构建相关人士识别符。 为了协助你进行侦查工作，我们已将数据与手动整理出来的欺诈案涉案人员列表进行了合并， 这意味着被起诉的人员要么达成和解，要么向政府签署认罪协议，再或者出庭作证以获得免受起诉的豁免权。
需要的资源你的计算机上应有 python 和 sklearn，以及你随“机器学习入门”课程的首个迷你项目一并下载的初始代码（python 脚本和安然数据集）。 你可以从 git 上获取初始代码：
git clone https://github.com/udacity/ud120-projects.git
你可以在下载下来用于迷你项目的代码库 final_project 目录中找到初始代码。相关文件如下所示：
poi_id.py：用于 POI 识别符的初始代码，你将在此处撰写你的分析报告。你也将提交此文件的副本，用于评估人员检验你的算法和结果。
final_project_dataset.pkl：项目数据集，详情如下。
tester.py：在你提交供优达学城评估的分析报告时，你将随附算法、数据集和你使用的特征列表（这些是在 poi_id.py 中自动创建的）。 评估人员将在此后使用这一代码来测试你的结果，以确保性能与你在报告中所述类似。你无需处理这一代码，我们只是将它呈现出来供你参考。
emails_by_address：该目录包含许多文本文件，每个文件又包含特定邮箱的往来邮件。 你可以进行参考，并且可以根据邮件数据集的详细信息创建更多的高级特征。你无需处理电子邮件语料库来完成项目。
迈向成功我们将给予你可读入数据的初始代码，将你选择的特征放入 numpy 数组中，该数组是大多数 sklearn 函数假定的输入表单。 你要做的就是设计特征，选择并调整算法，用以测试和评估识别符。 我们在设计数个迷你项目之初就想到了这个最终的项目，因此请记得借助你已完成的工作成果。
在预处理此项目时，我们已将安然邮件和财务数据与字典结合在一起，字典中的每对键值对应一个人。 字典键是人名，值是另一个字典（包含此人的所有特征名和对应的值）。 数据中的特征分为三大类，即财务特征、邮件特征和 POI 标签。
财务特征: [‘salary’, ‘deferral_payments’, ‘total_payments’, ‘loan_advances’, ‘bonus’, ‘restricted_stock_deferred’, ‘deferred_income’, ‘total_stock_value’, ‘expenses’, ‘exercised_stock_options’, ‘other’, ‘long_term_incentive’, ‘restricted_stock’, ‘director_fees’] (单位均是美元）
邮件特征: [‘to_messages’, ‘email_address’, ‘from_poi_to_this_person’, ‘from_messages’, ‘from_this_person_to_poi’, ‘shared_receipt_with_poi’] (单位通常是电子邮件的数量，明显的例外是 ‘email_address’，这是一个字符串）
POI 标签: [‘poi’] (boolean，整数)
我们鼓励你在启动器功能中制作，转换或重新调整新功能。如果这样做，你应该把新功能存储到my_dataset，如果你想在最终算法中使用新功能，你还应该将功能名称添加到 my_feature_list，以便于你的评估者可以在测试期间访问它。关于如何在数据集中添加具体的新要素的例子，可以参考“特征选择”这一课。
此外，我们还建议你可以在完成项目过程中做一些记号。你可以写出系列问题的答案（在下一页），将这个作为提交的项目的一部分，以便于评估者了解到你对于不同方面分析的方法。你的思维过程在很大程度上比你的最终项目更重要，我们将通过你在这些问题的解答中了解你的思维过程。
Project EvaluationFinal Project Evaulation InstructionsWhen you’re finished, your project will have 2 parts: the code/classifier you create and some written documentation of your work. Share your project with others and self-evaluate your project according to the rubric here.
Before you start working on the project: Review the final project rubric carefully. Think about the following questions - How will you incorporate each of the rubric criterion into your project? Why are these aspects important? What is your strategy to ensure that your project “meets specifications” in the given criteria? Once you are convinced that you understand each part of the rubric, please start working on your project. Remember to refer to the rubric often to ensure that you are on the right track.
Items to include when sharing your work with others for feedback:
Code/ClassifierWhen making your classifier, you will create three pickle files (my_dataset.pkl, my_classifier.pkl, my_feature_list.pkl). The project evaluator will test these using the tester.py script. You are encouraged to use this script before checking to gauge if your performance is good enough. You should also include your modified poi_id.py file in case of any issues with running your code or to verify what is reported in your question responses (see next paragraph).
Documentation of Your WorkDocument the work you’ve done by answering (in about a paragraph each) the questions found here. You can write your answers in a PDF, Word document, text file, or similar format.
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>K-均值聚类迷你项目</title>
    <url>/dev-ml-k-means/</url>
    <content><![CDATA[项目简介在此项目中，我们会将 k-均值聚类应用于安然财务数据。当然，我们最终的目标是识别相关人员；既然我们有了已标记数据，调用 k-均值聚类这种非监督式方法就不成问题。
尽管如此，在此项目中，你仍然会获得 k-均值的一些实际操作经验并尝试特征缩放，这会让你预先了解下一课的材料。可在此处找到安然数据集。


聚类特征可以在 k_means/k_means_cluster.py 中找到初始代码，该代码会读入电子邮件 + 财务 (E+F) 数据集，让我们为聚类做好准备。首先你将基于两个财务特征开始执行 K-means，请查看代码并确定代码使用哪些特征进行聚类。
运行代码，这将创建数据的散点图。仔细思考如果创建两个聚类，你预期会产生哪两个聚类。答：salary，exercised_stock_options
部署聚类在 financial_features 数据上部署 k-均值聚类，并将 2 个聚类指定为参数。将聚类预测存储到名为 pred 的列表，以便脚本底部的 Draw() 命令正常工作。在弹出的散点图中，聚类是否是你预期的？
使用 3 个特征聚类向特征列表（features_list）中添加第三个特征：“total_payments”。现在使用 3 个，而不是 2 个输入特征重新运行聚类（很明显，我们仍然可以只显示原来的 2 个维度）。将聚类绘图与使用 2 个输入特征获取的绘图进行比较。是否有任何点切换群集？多少个点？这种使用 3 个牲的新聚类无法通过肉眼加以猜测——必须通过 k-均值算法才能识别它。
（你需要更改创建散点图的代码，以便容纳 3 个特征而不是 2 个，有关操作说明，请参阅初始代码中的注释。）
股票期权范围在下一课中，我们将讨论特征缩放。它是一种特征预处理，应在执行某些分类和回归任务之前执行。这里只是快速预览，概述特征缩放的功能。
本例中使用的“exercised_stock_options”特征取的最大值和最小值是什么？
（注意：如果查看 finance_features，会发现有些“NaN”值已被清理并被零值取代——因此尽管那些值可能看起来像是最小值，但却具有欺骗性，因此它们更像是你不具有其相关信息而必须填入一个数字的点。对于此问题，请返回 data_dict 并查找显示的最大值和最小值，忽略所有“NaN”条目。）
薪酬范围“salary”取的最大值和最小值是什么？
（注意：与上一个测试题中的注意事项相同。如果查看 finance_features，会发现有些“NaN”值已被清理并被零值取代——因此尽管那些值可能看起来像是最小值，但却具有欺骗性，因此它们更像是你不具有其相关信息而必须填入一个数字的点。对于此问题，请返回 data_dict 并查找显示的最大值和最小值，忽略所有“NaN”条目。）
聚类更改下一张幻灯片上的绘图会显示你刚刚编写的聚类代码，但在本例中，我们在执行聚类之前应用了特征缩放。
我们希望你将（下一张幻灯片上）使用缩放的聚类与在聚类算法中使用*两个特征时生成的第一个聚类可视化效果进行比较。
请注意，特征范围现在已更改为 [0.0, 1.0]。这是我们所做的唯一更改。
在下一课中，你将详细了解特征缩放的含义，但现在，只需查看对聚类产生的影响–哪个/哪些点会切换它们关联的聚类？ 
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>朴素贝叶斯迷你项目</title>
    <url>/dev-ml-naive-bayes/</url>
    <content><![CDATA[项目背景几年前，J.K. 罗琳（凭借《哈利波特》出名）试着做了件有趣的事。她以 Robert Galbraith 的化名写了本名叫《The Cuckoo’s Calling》的书。尽管该书得到一些不错的评论，但是大家都不太重视它，直到 Twitter 上一个匿名的知情人士说那是 J.K. Rowling 写的。《伦敦周日泰晤士报》找来两名专家对《杜鹃在呼唤》和 Rowling 的《偶发空缺》以及其他几名作者的书进行了比较。分析结果强有力地指出罗琳就是作者，《泰晤士报》直接询问出版商情况是否属实，而出版商也证实了这一说法，该书在此后一夜成名。


我们也将在此项目中做类似的事。我们有一组邮件，分别由同一家公司的两个人撰写其中半数的邮件。我们的目标是仅根据邮件正文区分每个人写的邮件。在这个迷你项目一开始，我们将使用朴素贝叶斯，并在之后的项目中扩展至其他算法。
我们会先给你一个字符串列表。每个字符串代表一封经过预处理的邮件的正文；然后，我们会提供代码，用来将数据集分解为训练集和测试集（在下节课中，你将学习如何进行预处理和分解，但是现在请使用我们提供的代码）。
朴素贝叶斯特殊的一点在于，这种算法非常适合文本分类。在处理文本时，常见的做法是将每个单词看作一个特征，这样就会有大量的特征。此算法的相对简单性和朴素贝叶斯独立特征的这一假设，使其能够出色完成文本的分类。在这个迷你项目中，你将在计算机中下载并安装 sklearn，然后使用朴素贝叶斯根据作者对邮件进行分类。
环境准备1、检查你是否装有可用的 python，版本最好是 2.6 或 2.7（这是我们使用的版本 - 其他版本应该也可以，但我们不敢保证）。2、我们会使用 pip 来安装一些包。首先，从此处获取并安装 pip。3、使用 pip 安装一系列 Python 包：

转到终端行界面（请勿打开 Python，只打开命令提示符）
安装 sklearn: pip install scikit-learn
此处包含 sklearn 安装说明，可供参考

4、安装自然语言工具包：pip install nltk5、获取机器学习简介源代码。你将需要 git 来复制资源库：git clone https://github.com/udacity/ud120-projects.git
你只需操作一次，基础代码包含所有迷你项目的初始代码。进入 tools/ 目录，运行 startup.py。该程序首先检查 python 模块，然后下载并解压缩我们在后期将大量使用的大型数据集。下载和解压缩需要一些时间，但是你无需等到全部完成再开始第一部分。
运行代码在 naive_bayes/nb_author_id.py 中创建和训练朴素贝叶斯分类器，用其为测试集进行预测。准确率是多少？
training time: 1.517 s0.973265073948

在训练期间，你可能会看到以下错误：“用户警告：分数重复。结果可能取决于特征排序，或者你对回归任务使用了分类分数。” 警告（“分数重复。结果可能取决于特征排序。”）
邮件中两个以上的单词恰巧具有相同的使用模式时，会出现这一警告—对算法而言，这表示两个特征是相同的。当重复特征出现时，一些算法实际上会中断（数学上无法运行），或给出多个不同的答案（取决于特征排序），然后 sklearn 发出警告。这种信息能起到帮助作用，所以我们无需担心。
练习: 作者身份准确率在此问题中，一些学员在执行代码时会遇到内存问题。为了降低运行代码时看到内存错误的提示，我们建议你使用 RAM 至少为 2GB 的计算机。如果你发现代码造成内存错误，你也可以尝试在 email_preprocess.py 文件中设置 test_size = 0.5。
对分类器计时我们之前未明确提及的一个重要主题是何时训练和测试算法。在你分类器所在行的上方和下方插入两行代码，就像这样：
t0 = time()&lt; 你的 clf.fit() 代码行 &gt;print 'training time:', round(time()-t0, 3), 's'

在你的 clf.predict() 代码行前后也加上这段代码，这样你可以比较训练分类器的所需时间，并作出预测。训练和预测哪一个更快？
我们会把朴素贝叶斯的用时与其他几种算法比较，所以请记下你得到的时间和准确率，在下一个迷你项目中，我们还会用到。
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>选择自己的算法</title>
    <url>/dev-ml-new-algorithm/</url>
    <content><![CDATA[为何要学习新算法？任何数据分析师具备的一项关键技能就是不断从机器学习中得到新的认识，这也是本节课的学习目标。这节课的内容是一个迷你项目。目标是用你选择的算法来做地形分类，并由你自己进行研究和部署。


可选的算法如下：
1、k nearest neighbors（k 最近邻 或 KNN）2、random forest（随机森林）3、adaboost（有时也叫“被提升的决策树”）
我们无法检查你的结果，因为你有太多的算法和参数组合可以尝试了，但是你看到过我们上一个算法（朴素贝叶斯、SVM、决策树）所得出的准确率，因此你可以自行评估新的算法是否更好。
你将在 choose_your_own/your_algorithm.py 文件中寻找初始代码来准备你的数据。以下视频还给出了更多你应该遵循的算法和过程的细节，不过你需要自行去发现。祝你好运！
学习算法的步骤1、搜索相关资料，大致了解这个算法，能够向朋友解释这个算法。2、查找sklearn中关于这个算法的文档，运行文档给的demo。3、使用算法对实际问题进行预测。4、对算法进行评估，准确率和速度。
挑战我们使用任一这些算法（朴素贝叶斯、SVM、决策树、AdaBoost、随机森林、KNN）能够获得的最高准确率是 93.6%。这是一个有趣的挑战：你可以打败我们吗？如果可以，请在方框中写下你的方法（算法和参数）。
答：knn算法，准确率94%。
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>异常值迷你项目</title>
    <url>/dev-ml-outliers/</url>
    <content><![CDATA[项目简介此项目有两部分。在第一部分中将运行回归，然后识别并删除具有最大残差的 10% 的点。然后，根据 Sebastian 在课程视频中所建议的，从数据集中删除那些异常值并重新拟合回归。
在第二部分中，你将熟悉安然财务数据中的一些异常值，并且了解是否/如何删除它们。


带有异常值Sebastian 向我们描述了改善回归的一个算法，你将在此项目中实现该算法。你将在接下来的几个测试题中运用这一算法。总的来说，你将在所有训练点上拟合回归。舍弃在实际 y 值和回归预测 y 值之间有最大误差的 10% 的点。
先开始运行初始代码 (outliers/outlier_removal_regression.py) 和可视化点。一些异常值应该会跳出来。部署一个线性回归，其中的净值是目标，而用来进行预测的特征是人的年龄（记得在训练数据上进行训练！）。
数据点主体的正确斜率是 6.25（我们之所以知道，是因为我们使用该值来生成数据）；你的回归的斜率是多少？答：5.07793064
当使用回归在测试数据上进行预测时，你获得的分数是多少？答：0.878262470366
清理异常值后你将在 outliers/outlier_cleaner.py 中找到 outlierCleaner() 函数的骨架并向其填充清理算法。用到的三个参数是：predictions 是一个列表，包含回归的预测目标；ages 也是一个列表，包含训练集内的年龄；net_worths 是训练集内净值的实际值。每个列表中应有 90 个元素（因为训练集内有 90 个点）。你的工作是返回一个名叫cleaned_data 的列表，该列表中只有 81 个元素，也即预测值和实际值 (net_worths) 具有最小误差的 81 个训练点 (90 * 0.9 = 81)。cleaned_data 的格式应为一个元组列表，其中每个元组的形式均为 (age, net_worth, error)。
一旦此清理函数运行起来，你应该能看到回归结果发生了变化。新斜率是多少？是否更为接近 6.25 这个“正确”结果？答：6.36859481
当使用回归在测试集上进行预测时，新的分数是多少？答：0.983189455396
安然异常值在本节回归课程的迷你项目中，你使用回归来预测安然雇员的奖金。如你所见，单一的异常值都可以对回归结果造成很大的差异。但是，我们之前没有跟你说过的是，你在项目中使用的数据集已经被清理过明显的异常值了。第一次看到数据集时，识别并清除异常值是你一直应该思考的问题，而你现在已经通过安然数据有了一定的实践经验。
你可以在 outliers/enron_outliers.py 中找到初始代码，该代码读入数据（以字典形式）并将之转换为适合 sklearn 的 numpy 数组。由于从字典中提取出了两个特征（“工资”和“奖金”），得出的 numpy 数组维度将是 N x 2，其中 N 是数据点数，2是特征数。对散点图而言，这是非常完美的输入；我们将使用 matplotlib.pyplot 模块来绘制图形。（在本课程中，我们对所有可视化均使用 pyplot。）将这些行添加至脚本底部，用以绘制散点图：
for point in data:    salary = point[0]    bonus = point[1]    matplotlib.pyplot.scatter( salary, bonus )matplotlib.pyplot.xlabel("salary")matplotlib.pyplot.ylabel("bonus")matplotlib.pyplot.show()

如你所见，可视化是查找异常值最强大的工具之一！
识别最大的安然异常值有一个异常值应该会立即跳出来。现在的问题是识别来源。我们发现原始数据源对于识别工作非常有帮助；你可以在 final_project/enron61702insiderpay.pdf 中找到该 PDF。
该数据点的字典键名称是什么？（例如：如果是 Ken Lay，那么答案就是“LAY KENNETH L”）。最大 Enron 异常值的字典 key 值是什么？
移除安然异常值在此数据集上运行机器学习时，该异常值是否像我们应该包含的数据点？是否应该删除它？答：应该移除
从字典中快速删除键值对的一种方法如以下行所示：
dictionary.pop( key, 0 )

写下这样的一行代码（你必须修改字典和键名）并在调用 featureFormat() 之前删除异常值。然后重新运行代码，你的散点图就不会再有这个异常值了。
所有异常值都没了吗？
我们认为还有 4 个异常值需要调查；让我们举例来看。两人获得了至少 5 百万美元的奖金，以及超过 1 百万美元的工资；换句话说，他们就像是强盗。
和这些点相关的名字是什么？
你是否会猜到这些就是我们应该删除的错误或者奇怪的电子表格行，你是否知道这些点之所以不同的重要原因？（换句话说，在我们试图构建 POI 识别符之前，是否应该删除它们？）答：否
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>主成分分析迷你项目</title>
    <url>/dev-ml-pca/</url>
    <content><![CDATA[项目简介我们在讨论 PCA 时花费了大量时间来探讨理论问题，因此，在此迷你项目中，我们将要求你写一些 sklearn 代码。特征脸方法代码很有趣，而且内容丰富，足以胜任这一整个迷你项目的试验平台。
可在 pca/eigenfaces.py 中找到初始代码。此代码主要取自此处 sklearn 文档中的示例。
请注意，在运行代码时，对于在 pca/eigenfaces.py 的第 94 行调用的 SVC 函数，有一个参数有改变。对于“class_weight”参数，参数字符串“auto”对于 sklearn 版本 0.16 和更早版本是有效值，但将被 0.19 舍弃。如果运行 sklearn 版本 0.17 或更高版本，预期的参数字符串应为“balanced”。如果在运行 pca/eigenfaces.py 时收到错误或警告，请确保第 98 行包含与你安装的 sklearn 版本匹配的正确参数。
如果直接运行下载的代码，会先下载233MB的数据文件。你可以点击这里先下载数据集，再根据指示运行代码。


主成分的可释方差我们提到 PCA 会对主成分进行排序，第一个主成分具有最大方差，第二个主成分 具有第二大方差，依此类推。第一个主成分可以解释多少方差？第二个呢？
我们发现，有时 Pillow 模块（本例中使用的）可能会造成麻烦。如果你收到与 fetch_lfw_people() 命令相关的错误，请尝试以下命令：pip install --upgrade PILLOW
如果运行时遇到错误，请注意对于在“pca/eigenfaces.py ”的第 94 行调用的“SVC”函数，有一个参数有改变。对于“class_weight”参数，参数字符串“auto”对于 sklearn 版本 0.16 和更早版本是有效值，但将被 0.19 版本舍弃。如果运行 sklearn 版本 0.17 或更高版本，预期的参数字符串应为“balanced”。如果在运行“pca/eigenfaces.py”时收到错误或警告，请确保第 98 行包含与你安装的 sklearn 版本匹配的正确参数。
要使用多少个主成分？现在你将尝试保留不同数量的主成分。在类似这样的多类分类问题中（要应用两个以上标签），准确性这个指标不像在两个类的情形中那么直观。相反，更常用的指标是 F1 分数。
我们将在评估指标课程中学习 F1 分数，但你自己要弄清楚好的分类器的特点是具有高 F1 分数还是低 F1 分数。你将通过改变主成分数量并观察 F1 分数如何相应地变化来确定。
随着你添加越来越多的主成分作为训练分类器的特征，你认为它的性能会更好还是更差？答：更好
F1 分数与使用的主成分数将 n_components 更改为以下值：[10, 15, 25, 50, 100, 250]。对于每个主成分，请注意 Ariel Sharon 的 F1 分数。（对于 10 个主成分，代码中的绘制功能将会失效，但你应该能够看到 F1 分数。）
如果看到较高的 F1 分数，这意味着分类器的表现是更好还是更差？答：更好
维度降低与过拟合在使用大量主成分时，是否看到过拟合的证据？答：是的，当使用大量主成分时，性能开始下降。
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习相关原则与方法</title>
    <url>/dev-ml-principle-and-method/</url>
    <content><![CDATA[前言越学习，越发现自己的无知。——笛卡尔笛卡尔的这句话，用在郝同学学习机器学习的进展，刚好合适。从开始搞机器学习到现在，一年多了，学习了很多课程，查阅了很多文档，阅读了很多书籍，编写了很多代码，然而，并没有什么实质性的进展。没有任何可以拿得出手的成绩，可以让面试官眼前一亮。寒假了，继续“搞机”，参加kaggle和天池，边比赛边学习，学以致用，为自己书写一份优秀的简历。
接下来一段时间，郝同学会参考七月在线的《Kaggle案例实战班》教程，选择一些项目进行实战。


问题解决流程1、了解场景和目标2、了解评估准则3、认识数据4、数据预处理（清洗，调权）5、特征工程6、模型选择7、模型调参（选择最佳超参数：交叉验证）8、模型状态分析9、模型融合
了解场景和目标1、这是一个什么样的问题？2、可以采集到哪些数据？3、需要完成什么样的目标？
了解评估标准https://www.kaggle.com/wiki/Metrics
认识数据编程显示出前几行、前几列，观察特点。
1、数据有哪些维度？2、数据是不是分布平衡？3、数据是不是有缺省值？
数据预处理1、数据清洗

不可信的样本丢掉
缺省值极多的字段考虑不用

2、数据采样

上/下采样
保证样本均衡（加权）
bagging，vote

3、工具

hive sql/spark sql
pandas

特征工程
1、特征处理

数值型
类别型
时间类（离散型，间隔型，组合型）
文本类（n-gram，bag of words，tf-idf，word2vec）
统计型
组合特征

2、特征抽取
http://scikit-learn.org/stable/modules/preprocessing.html
http://scikit-learn.org/stable/modules/classes.html#module-sklearn.feature_extraction
3、特征选择http://scikit-learn.org/stable/modules/feature_selection.html
过滤型：sklearn.feature_selection.SelectKBest包裹型：sklearn.feature_selection.RFE嵌入型：feature_selection.SelectFromModel，Linear model，L1正则化 
模型选择

sklearn cheat-sheet提供的候选 
课程案例经验 
交叉验证（cross validation）：K折交叉验证（K-fold cross validation）、Cross-validation: evaluating estimator performance

模型参数选择交叉验证：

Tuning the hyper-parameters of an estimator
sklearn.model_selection.GridSearchCV

模型状态评估1、模型状态过拟合还是欠拟合
2、学习曲线（learning curve）
3、绘制学习曲线（plot learning curve）
模型融合1、群众的力量是伟大的，集体智慧是惊人的（1）Bagging（2）随机森林/Random forest 
2、站在巨人的肩膀上，能看得更远（1）模型stacking 
3、一万小时定律（1）Adaboost（2）逐步增强树/Gradient Boosting Tree
Bagging1、模型很多时候效果不好的原因是什么？（1）过拟合啦！！！
2、如何缓解？（1）少给点题，别让它死记硬背这么多东西（2）多找几个同学来做题，综合一下他们的答案
3、sklearn.ensemble.BaggingClassifier
（1）用一个算法不用全部的数据集，每次取一个子集训练一个模型分类：用这些模型的结果做vote回归：对这些模型的结果取平均
（2）用不同的算法用这些模型的结果做vote 或 求平均
Stacking用多种predictor结果作为特征训练
Boosting考得不好的原因是什么？（1）还不够努力，练习题要多次学习解决办法：重复迭代和训练（2）时间分配要合理，要多练习之前做错的题解决办法：每次分配给分错的样本更高的权重（3）我不聪明，但是脚踏实地，用最简单的知识不断积累，成为专家解决办法：最简单的分类器的叠加
Ensemble Methods
原则和技巧1、画出数据2、简单实现3、画出图表4、根据图表优化

数据的重要性超过模型。

注意点与核心思路1、拿到数据后怎么了解数据（可视化）2、选择最贴切的机器学习算法3、定位模型状态（过/欠拟合）以及解决方法4、大量级的数据的特征分析与可视化5、各种损失函数（loss function）的优缺点及如何选择
书签机器学习系列(4)_机器学习算法一览，应用建议与解决思路
机器学习系列(19)_通用机器学习流程与问题解决架构模板
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>kaggle</tag>
      </tags>
  </entry>
  <entry>
    <title>回归迷你项目</title>
    <url>/dev-ml-regression/</url>
    <content><![CDATA[项目简介在此项目中，你将使用回归来预测安然雇员和合伙人的财务数据。一旦你知道某位雇员的财务数据，比如工资，你是否会预测他们奖金的数额？


目标和特征运行在 regression/finance_regression.py 中找到的初始代码。这将绘制出一个散点图，其中有所有的数据点。你尝试预测什么目标？用来预测目标的输入特征是什么？
在脑海中描绘出你大致预测的回归线（如果打印散点图并用纸笔来描绘，效果会更好）。
可视化回归数据就像在分类中一样，你需要在回归中训练和测试数据。这在初始代码中已被设定。将 test_color 的值从“b”改为“r”（针对“red”），然后重新运行。
注意：对于将 Python 2 代码转换至 Python 3 的学员，请参见以下关于兼容性的重要备注。
你将仅使用蓝色（训练）点来拟合回归。（你可能已经注意到，我们放入测试集的是 50% 的数据而非标准的 10%—因为在第 5 部分中，我们将改变训练和测试数据集，并且平均分割数据使这种做法更加简单。）从 Python 3.3 版本开始，字典的键值顺序有所改变，在每次代码运行时，字典的键值皆为随机排序。这会让我们在 Python 2.7 环境下工作的评分者遭遇一些兼容性的问题。为了避免这个问题，请在 finance_regression.py 文件的第26行 featureFormat 调用时添加一个参数
sort_keys = ‘../tools/python2_lesson06_keys.pkl’
它会打开 tools 文件夹中带有 Python 2 键值顺序的数据文件。
提取斜率和截距从 sklearn 导入 LinearRegression 并创建/拟合回归。将其命名为 reg，这样绘图代码就能将回归覆盖在散点图上呈现出来。回归是否大致落在了你期望的地方？
提取斜率（存储在 reg.coef_ 属性中）和截距。
斜率和截距是多少？答：斜率为5.44814029，截距为-102360.543294
训练数据假设你是一名悟性不太高的机器学习者，你没有在测试集上进行测试，而是在你用来训练的相同数据上进行了测试，并且用到的方法是将回归预测值与训练数据中的目标值（比如：奖金）做对比。
你找到的分数是多少？你可能对“良好”分数还没有概念；此分数不是非常好（但却非常糟糕）。答：0.0455091926995
测试数据现在，在测试数据上计算回归的分数。
测试数据的分数是多少？如果只是错误地在训练数据上进行评估，你是否会高估或低估回归的性能？答：-1.48499241737
根据 LTI 回归奖金我们有许多可用的财务特征，就预测个人奖金而言，其中一些特征可能比余下的特征更为强大。例如，假设你对数据做出了思考，并且推测出“long_term_incentive”特征（为公司长期的健康发展做出贡献的雇员应该得到这份奖励）可能与奖金而非工资的关系更密切。
证明你的假设是正确的一种方式是根据长期激励回归奖金，然后看看回归是否显著高于根据工资回归奖金。根据长期奖励回归奖金—测试数据的分数是多少？答：-0.59271289995
工资与 LTI如果你必须预测某人的奖金并且你只有一小段相关信息，你想要知道他们的工资还是长期奖励？答：长期奖励
异常值破坏回归这是下节课的内容简介，关于异常值的识别和删除。返回至之前的一个设置，你在其中使用工资预测奖金，并且重新运行代码来回顾数据。你可能注意到，少量数据点落在了主趋势之外，即某人拿到高工资（超过 1 百万美元！）却拿到相对较少的奖金。此为异常值的一个示例，我们将在下节课中重点讲述它们。
类似的这种点可以对回归造成很大的影响：如果它落在训练集内，它可能显著影响斜率/截距。如果它落在测试集内，它可能比落在测试集外要使分数低得多。就目前情况来看，此点落在测试集内（而且最终很可能降低分数）。让我们做一些处理，看看它落在训练集内会发生什么。在 finance_regression.py 底部附近并且在 plt.xlabel(features_list[1]) 之前添加这两行代码：
reg.fit(feature_test, target_test)plt.plot(feature_train, reg.predict(feature_train), color=”b”)
现在，我们将绘制两条回归线，一条在测试数据上拟合（有异常值），一条在训练数据上拟合（无异常值）。来看看现在的图形，有很大差别，对吧？单一的异常值会引起很大的差异。
新的回归线斜率是多少？答：2.27410114
（你会发现差异很大，多数情况下由异常值引起。下一节课将详细介绍异常值，这样你就有工具来检测和处理它们了。）
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>SVM迷你项目</title>
    <url>/dev-ml-svm/</url>
    <content><![CDATA[项目背景在此迷你项目中，我们将解决与朴素贝叶斯迷你项目相同的电子邮件作者 ID 问题，不同的是我们将运用 SVM。我们的研究结果将阐明两种算法之间的一些实际差异。此项目还向我们提供比朴素贝叶斯更多的机会来使用参数，因此我们也将这样做。


运行代码转到 svm 目录，查找初始代码 (svm/svm_author_id.py)。
使用 sklearn SVC 分类器进行导入、创建、训练和预测。在创建分类器时使用线性内核（如果你忘记此步骤，你会发现分类器要花很长的时间来训练）。
分类器的准确率是多少？
时间跟你在朴素贝叶斯迷你项目中所做的一样，将计时代码用于拟合和预测函数。与朴素贝叶斯相比，训练和预测如何计时？
朴素贝叶斯结果：
training time: 1.517 s0.973265073948

SVM结果：
training time: 207.594 s0.984072810011

减小训练集加快算法速度的一种方式是在一个较小的训练数据集上训练它。这样做换来的是准确率几乎肯定会下降。让我们更具体地探讨这个问题：在训练分类器之前，立即加入以下两行。 
features_train = features_train[:len(features_train)/100] labels_train = labels_train[:len(labels_train)/100]

这两行有效地将训练数据集切割至原始大小的 1%，丢弃掉 99% 的训练数据。你可以使其他所有代码保持不变。
现在的准确率是多少？修改后SVM结果：
training time: 0.124 s0.884527872582

速度与准确率如果速度是一个主要考虑因素（对于许多实时机器学习应用而言确实如此），并且如果牺牲一些准确率可加快你的训练/预测速度，则你可能会想这样做。
在以下哪些应用中，你可以想象非常快速地运行的算法尤其重要？
1、预测电子邮件作者2、标记信用卡欺诈，在欺诈发生之前阻止交易3、Siri 之类的语音识别
答案是2和3。
部署RBF内核保留上一个测试题中的训练集代码段，以便仍在 1% 的完整训练集上进行训练。将 SVM 的内核更改为“rbf”。
这个更复杂的内核给出的准确率是多少？
training time: 0.139 s0.616040955631

优化C参数保持训练集大小不变，并且保留上一个测试题中的 rbf 内核，但是尝试多个 C 值（比如：10.0、100.、1000. 和 10000.）。
哪个给出的准确率最高？结果依次为：
training time: 0.142 s0.616040955631training time: 0.139 s0.616040955631training time: 0.132 s0.821387940842training time: 0.127 s0.892491467577

优化C后的准确率在你为 RBF 内核优化了 C 值后，你会获得怎样的准确率？该 C 值是否对应更简单或者更复杂的决策边界？
（如果你不确定复杂度，请回顾本节课有关“SVM C 参数”的视频。你在该处发现的结果同样适用于此处，不过，在简单的散点图中画出决策边界现在变得更加困难甚至不可能。）
优化C后使用完整训练集你已经为 RBF 内核优化了 C，现在恢复为使用完整的训练集。较大的训练集往往能提高算法的性能，所以（通过在大数据集上调整 C 和进行训练）我们应得到相当优化的结果。
经过优化的 SVM 的准确率是多少？
training time: 142.459 s0.990898748578

从SVM提取预测你的 SVM（0 或 1，分别对应 Sara 和 Chris）将测试集中的元素10、元素26和元素50分别预测为哪一类？
（使用 RBF 内核、C=10000 和 1% 的训练集。通常，使用完整的训练集能获得最好的结果，但是我们发现使用 1% 的完整训练集不仅大幅加快计算过程，而且不会改变我们的结果，因此你在这里可以随意使用该快捷算法。）
而且需要说明的是，我们这里给出的数据点数字 (10, 26, 50) 假设使用的是零索引列表。因此，使用类似于 answer=predictions[100] 的表达式可找到元素 # 100 的正确答案。
预测Chris的邮件数量There are over 1700 test events–how many are predicted to be in the “Chris” (1) class? (Use the RBF kernel, C=10000., and the full training set.) 
测试事件的数量超过 1700——其中多少预测在“Chris” (1) 类中？（使用 RBF 内核、C=10000. 以及完整的训练集。）
training time: 137.599 s877

部署SVM最后提醒希望 Sebastian 在说朴素贝叶斯非常适合文本时，更清楚地表达了他的意思。对于这一具体问题，朴素贝叶斯不仅更快，而且通常比 SVM 更出色。当然，SVM 更适合许多其他问题。你在第一次求解问题时就知道该尝试哪个算法，这是机器学习艺术和科学性的一个体现。除了选择算法外，视你尝试的算法而定，你还需要考虑相应的参数调整以及过拟合的可能性（特别是在你没有大量训练数据的情况下）。
我们通常建议你尝试一些不同的算法来求解每个问题。调整参数的工作量很大，但你现在只需要听完这堂课，我们将向你介绍 GridCV，一种几乎能自动查找最优参数调整的优秀 sklearn 工具。
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>文本学习迷你项目</title>
    <url>/dev-ml-text-learning/</url>
    <content><![CDATA[项目简介本节课开始，你使用大量监督式分类算法，根据作者来识别邮件。 在这些项目中，我们为你做了预处理，将输入邮件转换到 TfIdf 中，这样你就能向算法提供这些邮件了。 现在，你将自行完成预处理工作，以便你能从原始数据直接得到经过处理的特征。
你将得到两个文本文件：一个包含来自 Sara 的所有邮件，一个包含 Chris 的邮件。 你还将访问 parseOutText() 函数，该函数接受作为参数的已读邮件，并且返回包含邮件中所有（被词干化的）单词的字符串。


项目准备# 下载语料库import nltknltk.download()# 停止词from nltk.corpus import stopwordssw = stopwords.words('english')print len(sw)# 词干化from nltk.stem.snowball import SnowballStemmerstemmer = SnowballStemmer('english')stemmer.stem('responsiveness')stemmer.stem('responsivity')stemmer.stem('unresponsive')

parseOutText()你将从热身习题开始了解 parseOutText()。 前往工具目录并运行 parse_out_email_text.py，该程序包含 parseOutText() 和一封测试邮件，用以运行此函数。
parseOutText() 获得被打开的邮件，然后仅返回文字部分，除去了可能出现在邮件开头的元数据，接下来就是邮件正文了。 我们现在已经设置好了这一脚本，这样它就能将邮件正文打印到屏幕上，你运行 parseOutText() 时会得到怎样的正文？答：Hi Everyone  If you can read this message youre properly using parseOutText  Please proceed to the next part of the project
在 parseOutText() 中，添加以下注释： 
# words = text_string

增强 parseOutText() ，这样返回的字符串就有了所有因使用 SnowballStemmer（使用 nltk 包，可在 http://www.nltk.org/howto/stem.html 找到我发现有用的一些示例）而获得的词干化单词。
重新运行 parse_out_email_text.py，该程序将使用你更新的 parseOutText() 函数。你现在的输出是什么？答：hi everyon if you can read this messag your proper use parseouttext pleas proceed to the next part of the project
提示：你需要将字符串分解成单个单词，词干化每个单词，然后再将所有单词重新组合成一个字符串。
清除“签名文字”在 text_learning/vectorize_text.py 中，你将迭代所有来自 Chris 和 Sara 的邮件。 将每封已读邮件提供给 parseOutText() 并返回词干化的文本字符串。然后做以下两件事：

删除签名文字（“sara”、“shackleton”、“chris”、“germani”——如果你知道为什么是“germani”而不是“germany”，你将获得加分）
向 word_data 添加更新的文本字符串——如果邮件来自 Sara，向 from_data 添加 0（零），如果是 Chris 写的邮件，则添加 1。

完成此步骤后，你应该有两个列表：一个包含了每封邮件被词干化的正文，第二个应该包含用来编码（通过 0 或 1）谁是邮件作者的标签。
对所有邮件运行程序需要花一些时间（5 分钟或更长时间），所以我们添加了一个 temp_counter，将第 200 封之后的邮件切割掉。 当然，一切就绪后，你会希望对整个数据集运行程序。
在以下方框中，放入你得到的 word_data[152] 字符串。答：tjonesnsf stephani and sam need nymex calendar
进行 TfIdf使用 sklearn TfIdf 转换将 word_data 转换为 tf-idf 矩阵。删除英文停止词。
你可以使用 get_feature_names() 访问单词和特征数字之间的映射，该函数返回一个包含词汇表所有单词的列表。有多少不同的单词？答：
你 TfId 中的单词编号 34597 是什么？答：stephen
需要说明的是，如果问题是“单词编号 100 是什么”，我们肯定会查找对应 vocab_list[100] 的单词。有时候，零索引数组谈论起来非常不好理解。
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>验证迷你项目</title>
    <url>/dev-ml-validation/</url>
    <content><![CDATA[项目简介在此迷你项目中，你将从分割训练数据和测试数据开始。这是你通往“构建 POI 识别符”这个最终项目的第一步。


第一个（过拟合）POI 识别符你将先开始构建想象得到的最简单（未经过验证的）POI 识别符。 本节课的初始代码 (validation/validate_poi.py) 相当直白——它的作用就是读入数据，并将数据格式化为标签和特征的列表。 创建决策树分类器（仅使用默认参数），在所有数据（你将在下一部分中修复这个问题！）上训练它，并打印出准确率。 这是一颗过拟合树，不要相信这个数字！尽管如此，准确率是多少？答：
从 Python 3.3 开始，字典键被处理的顺序发生了变化，顺序在每次代码运行时都会得到随机化处理。 这会造成与评分工具和项目代码（均在 Python 2.7 下运行）的一些兼容性问题。 要更正这个问题，向 validate_poi.py 第 25 行调用的 featureFormat 添加以下参数：
sort_keys = '../tools/python2_lesson13_keys.pkl'
这将以 Python 2 的键顺序打开 tools 文件夹中的文件。
注意：如果你没有获得评分工具期望的结果，你可能会想查看 tools/feature_format.py 文件。 由于最终项目发生的变化，一些文件更改影响了此处所写任务的数量输出。 检查你是否从资源库获得了最新版本的文件，以便 featureFormat 具有 sort_keys = False 的默认参数，并且 keys = dictionary.keys() 能够产生结果。
部署训练/测试机制现在，你将添加训练和测试，以便获得一个可靠的准确率数字。 使用 sklearn.cross_validation 中的 train_test_split 验证； 将 30% 的数据用于测试，并设置 random_state 参数为 42（random_state 控制哪些点进入训练集，哪些点用于测试；将其设置为 42 意味着我们确切地知道哪些事件在哪个集中； 并且可以检查你得到的结果）。更新后的准确率是多少？答：0.724137931034
源码分享https://github.com/voidking/ud120-projects
书签机器学习入门https://cn.udacity.com/course/intro-to-machine-learning--ud120
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>修改 MP3 的 ID3Tags</title>
    <url>/dev-modify-mp3-id3tags/</url>
    <content><![CDATA[ID3Tags是啥？ID3Tags，简称 ID3 ，表示MP3文件曲目标签。ID3位于一个mp3文件的开头或末尾的若干字节内，附加了关于该mp3的歌手，标题，专辑名称，年代，风格等信息，该信息就被称为ID3信息，ID3信息分为两个版本，v1和v2版。其中v1版的ID3在mp3文件的末尾128字节，以TAG三个字符开头，后面跟上歌曲信息。v2版一般位于mp3的开头，可以存储歌词，该专辑的图片等大容量的信息。
ID3全称是啥？没有找到，懂得的小伙伴感谢留言告知。


思路使用python第三方库，查看mp3当前id3tags，修改id3tags并保存。找到了两个不错的python第三方库：

eyeD3 document
Mutagen document

这里选择eyeD3，因为使用更简单。使用到的参数和方法，参考eyed3.id3。
实现安装eyeD3python3 -m pip install eyed3 -i https://pypi.tuna.tsinghua.edu.cn/simple/

命令行查看id3eyeD3 -heyeD3 song.mp3

脚本查看id3使用python脚本查看所有mp3的id3信息
#!/usr/bin/env python3# coding: utf-8import osimport eyed3def get_audio_paths(dir_path):    audio_paths = []    for dirs, dirnames, files in os.walk(dir_path):        for file in files:            if file.endswith('.mp3'):                audio_paths.append(dirs+'/'+file)    return audio_pathsdef show_id3(audio_path):    # load 和 save 时会打印出 Invalid date: ???????:36903863 ，可忽略    audio = eyed3.load(audio_path)    audio_name = audio_path.split('/')[-1]    if not audio.tag:        print('------ ' + audio_name + ' ------')        print('不存在id3')        print('------ ' + '------' + ' ------')    else:        print('------ ' + audio_name + ' ------')        if audio.tag.title:            print('title: ' + audio.tag.title)        if audio.tag.artist:            print('artist: ' + audio.tag.artist)        print('------ ' + '------' + ' ------')if __name__ == '__main__':    audio_paths = get_audio_paths('./mp3')    # 显示id3信息    for audio_path in audio_paths:        show_id3(audio_path)

脚本修改id3需求：已有200个mp3文件，id3信息都是广告。现在想要批量清除mp3文件现有的id3，然后根据文件名修改title，根据真实作者修改artist，根据真实封面修改封面。
def modify_id3(audio_path, title, artist ,img_path):    audio = eyed3.load(audio_path)    if not audio.tag:        audio.initTag()    else:        audio.tag.clear()    audio.tag.title = title    audio.tag.artist = artist    audio.tag.images.set(3, open(img_path,'rb').read(), 'image/jpeg')    audio.tag.save()    if __name__ == '__main__':    audio_paths = get_audio_paths('./mp3')    # 修改id3信息    for audio_path in audio_paths:        title = audio_path.split('/')[-1]        artist = '钱文忠'        img_path = './img.png' # 200x200        modify_id3(audio_path, title, artist ,img_path)


]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>爱好</category>
        <category>python</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么MVC不是一种设计模式？</title>
    <url>/dev-mvc-design-pattern/</url>
    <content><![CDATA[GoF (Gang of Four，四人组，《Design Patterns: Elements of Reusable Object-Oriented Software》/《设计模式》一书的作者：Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides)并没有把MVC提及为一种设计模式，而是把它当做“一组用于构建用户界面的类集合”。
在他们看来，它其实是其它三个经典的设计模式的演变：观察者模式(Observer)(Pub/Sub),策略模式(Strategy)和组合模式(Composite)。
根据MVC在框架中的实现不同可能还会用到工厂模式(Factory)和装饰器(Decorator)模式。
models表示应用的数据，而views处理屏幕上展现给用户的内容。为此，MVC在核心通讯上基于推送/订阅模型(惊讶的是在很多关于MVC的文章中并没有提及到)。当一个model变化时它对应用其它模块发出更新通知(“publishes”)，订阅者(subscriber)——通常是一个Controller，然后更新对应的view。观察者——这种自然的观察关系促进了多个view关联到同一个 model。
对于感兴趣的开发人员想更多的了解解耦性的MVC(根据不同的实现)，这种模式的目标之一就是在一个主题和它的观察者之间建立一对多的关系。当这个主题改变的时候，它的观察者也会得到更新。Views和controllers的关系稍微有点不同。Controllers帮助views对不同用户的输 入做不同的响应，是一个非常好的策略模式列子。
摘自文档：http://damoqiongqiu.iteye.com/blog/1949256
]]></content>
      <categories>
        <category>专业</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL常用命令</title>
    <url>/dev-mysql-command/</url>
    <content><![CDATA[前言mysql是郝同学使用最多的数据库，但是每次要手敲命令，还是得谷歌百度。好记性不如烂笔头，本文对常用mysql命令进行一些整理，方便再次拾起。


权限相关参考《MySQL重置密码》。
数据库相关1、常用命令
# 创建数据库create database vkphp default character set utf8 collate utf8_general_ci;# 删除数据库drop database vkphp;# 导出数据库数据mysqldump -uroot -ppassword vkphp &gt; /root/vkphp.sql# 导入数据库数据mysql -uroot -ppassword vkphp &lt; /root/vkphp.sqlsource /root/vkphp.sql;

数据表相关# 创建数据表CREATE TABLE IF NOT EXISTS `user` (  `id` int(8) NOT NULL AUTO_INCREMENT,  `name` varchar(32) NOT NULL,  `password` varchar(32) NOT NULL DEFAULT '',  PRIMARY KEY (id)) ENGINE=InnoDB DEFAULT CHARSET=utf8;# 删除数据表drop table `user`;# 删除所有数据表SELECT CONCAT('drop table ',table_name,';') FROM information_schema.`TABLES` WHERE table_schema='vkphp';# 添加columnalter table `user` add column `deleted1` bool not null default false;# 修改columnalter table `user` change `deleted1` `deleted` bool not null default false;alter table `user` modify `deleted` int(1) not null default 0;alter table `user` modify column `deleted` int(1) not null default 0;# 设置uniquealter table `user` modify `name` varchar(32) not null unique;alter table `user` modify column `name` varchar(32) not null unique;# 删除columnalter table `user` drop `deleted`;alter table `user` drop column `deleted`;# 插入数据insert into `user` (`name`,`password`) values('haojin','voidking');# 查询数据select * from `user` where name='haojin' and password='voidking';select * from `user` where name='haojin' or password='haojin';select * from `user` where name&lt;&gt;'haojin0';select * from `user` where name like '%ao%';select * from `user` order by id asc;select * from `user` order by id desc;select * from `user` order by id desc limit 2;# 修改数据update `user` set password='haojin' where name='haojin';# 删除数据delete from `user` where name='haojin';

高级命令联合查询left join（左联接）：返回左表中的所有记录以及和右表中的联接字段相等的记录。right join（右联接）：返回右表中的所有记录以及和左表中的联接字段相等的记录。inner join（等值联接）：只返回两个表中联接字段相等的记录。
例子：查询用户表（user）中的用户名（name）和用户详细表（user_detail）中的用户手机号码（telephone）。
select user.name, user_detail.telephonefrom user inner join user_detailon user.id=user_detail.user_idwhere user.id=1;# 或者select U1.name, U2.telephonefrom user as U1 inner join user_detail as U2on U1.id=U2.user_idwhere U1.id=1;

联合查询3张表例子：查询用户表（user）中的用户名（name）、用户角色表（role）中的角色名（name）、用户详细表（user_detail）中的用户手机号码（telephone）。
select user.name, user_detail.telephone, role.namefrom user left join roleon user.role_id=role.idleft join user_detailon user.id=user_detail.user_idwhere user.id=1;

替换字符串需求：用户表（user）的个性签名字段（info）是字符串，字符串中都包含“my name is haojin”，现在需要把“my name is haojin”都替换成“my name is voidking”。
update user set info=replace(info,"my name is haojin","my name is voidking") where info like "%my name is haojin%";

拼接命令例子：根据手机号17625160000查询用户，给该用户添加另外一个手机号17625160001，手机号用逗号分隔。
select name,mobiles from user where mobiles like "%17625160000%";# 查询出name="haojin",mobiles="17625160000"update user set mobiles="17625160000,17625160001" where name="haojin";

更简单的方法是使用concat拼接：
select CONCAT('update user set mobiles="',mobiles,',17625161201" where name="',name,'";') from user where mobiles like "%17625160000%";

假设有很多用户需要另外添加手机号，使用拼接的方式也很麻烦，此时需要借助shell脚本。已有文本mobiles.txt，内容为：
17625160000 1762516000117625160002 17625160003

编写shell脚本为：
#!/bin/bash grep -v "^$" mobiles.txt | while read linedo  old=`echo $line | awk '&#123;print $1&#125;'`  new=`echo $line | awk '&#123;print $2&#125;'`  echo "select CONCAT('update user set mobiles=\"',mobiles,',$&#123;new&#125;\" where name=\"',name,'\";') from user where mobiles like \"%$&#123;old&#125;%\";"done

定时备份需求：每天自动备份数据库。1、测试命令
/usr/bin/mysqldump -h 127.0.0.1 -uroot -pvoidking vkphp &gt; /root/vkphp-`date +%Y%m%d-%H%M%S`.sql

2、测试定时任务crontab -e，写入每分钟执行一次的定时任务：
# backup vkphpdb* * * * * /usr/bin/mysqldump -h 127.0.0.1 -uroot -pvoidking vkphp &gt; /root/vkphp-`date +\%Y\%m\%d-\%H\%M\%S`.sql

查看执行结果是否正常，如果不正常，通过crontab日志排查：tail -f /var/log/cron
3、确认定时任务
# backup vkphpdb0 0 * * * /usr/bin/mysqldump -h 127.0.0.1 -uroot -pvoidking vkphp &gt; /root/vkphp-`date +\%Y\%m\%d-\%H\%M\%S`.sql

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL中的游标</title>
    <url>/dev-mysql-cursor/</url>
    <content><![CDATA[需求已知app表有两个字段：id和name，build_history表有四个字段：id、app_id、image_path和create_time。app构建后会生成镜像，镜像地址存在于build_history表中的image_path字段。
现在想要查找出每个app的最新的五个镜像，该怎样实现？


思路思路一：使用select拿到所有的app id，然后使用shell脚本生成很多条sql语句，每条sql语句的查询结果插入到一个结果表中。具体参考《Shell实用脚本》循环读取多列文本部分。
思路二：使用mysql cursor，拿到所有的app id，然后循环读取build_image中的内容，插入到结果表中。本文中采用mysql cursor的方法，实现我们的需求。
代码实现-- create tabledrop table if exists latest_image;CREATE TABLE test.latest_image (    id INT auto_increment NOT null primary key,	app_id INT NULL,	app_name varchar(128) NULL,	app_image varchar(512) NULL)ENGINE=InnoDBDEFAULT CHARSET=utf8COLLATE=utf8_general_ci;-- create proceduredrop procedure if exists get_latest;CREATE PROCEDURE get_latest (num int(2))BEGINdeclare appid int default 0;declare appname varchar(128) default '';declare appimage varchar(512) default '';declare finished int default 0;	-- declare cursor for appdeclare appcursor CURSOR FOR SELECT id,name FROM app;	-- declare NOT FOUND handlerdeclare CONTINUE HANDLER FOR NOT FOUND SET finished = 1;OPEN appcursor;get_item: LOOP	FETCH appcursor INTO appid,appname;	IF finished = 1 THEN 		LEAVE get_item;	END IF;	-- select appid,appname;	-- select id,app_id,image_path from build_history where app_id=appid order by create_time desc limit 5;	-- insert into latest_image(`app_id`,'app_name','app_image') values(appid,appname,appimage);	insert into latest_image(`app_id`,`app_image`)	select app_id as app_id,image_path as app_image 	from build_history 	where app_id=appid order by create_time desc limit num;END LOOP get_item;CLOSE appcursor;END-- call procedurecall get_latest(5);
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>连接MySQL报错ERROR 2002 (HY000)</title>
    <url>/dev-mysql-error-2002/</url>
    <content><![CDATA[问题描述mysql -u root -p，然后输入密码，登录mysql，报错如下：
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)



解决办法1、查看mysql.sock文件位置find / -name mysql.sock，结果为：
/data/db/3306/mysql.sock
和/tmp/mysql.sock不一致。
在/tmp下没有mysql.sock文件，依次执行touch mysql.sock，chmod 666 mysql.sock。
重启mysql，service mysqld restart，再次登录mysql，报错如下：
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (111)

2、找到mysql配置文件ps aux | grep mysql，在结果中找到：
--defaults-file=/opt/mysql/my.cnf

3、查看mysql.sock配置more /opt/mysql/my.cnf | grep sock，结果如下：
socket=/data/db/3306/mysql.socksocket = /data/db/3306/mysql.sock

4、修改my.cnfvim /opt/mysql/my.cnf，修改两个socket如下：
socket = /tmp/mysql.socksocket = /tmp/mysql.sock

重启mysql，再次登录，成功！
书签MySQL错误ERROR 2002 (HY000)http://www.jb51.net/article/56952.htm
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL重置密码</title>
    <url>/dev-mysql-reset-password/</url>
    <content><![CDATA[设置mysql初始密码常规设置密码一般mysql的root默认密码为空，如果之前没有设置过root密码，我们可以使用空密码登录后设置密码。1、启动mysql，centos中service start mysql，windows中net start mysql
2、mysql -u root，进入mysql控制台
3、执行修改密码命令
mysql&gt; use mysql;mysql&gt; update mysql.user set password=password('voidking') where user='root';mysql&gt; exit;

4、重启mysql服务service mysqld restart
5、测试登录mysql -u root -p
mysqladmin也可以使用mysqladmin命令来修改root密码。1、启动mysql
2、重置密码mysqladmin -u root -p password voidking
mysql8设置密码alter user 'root'@'localhost' identified with mysql_native_password by 'voidking';flush privileges;



mysql忘记密码1、kill掉系统里的mysql进程
2、以不检查权限的方式启动mysql：mysqld_safe --skip-grant-tables &amp;
3、用空密码登录mysqlmysql -u root
4、修改root用户的密码
mysql&gt; update mysql.user set password=password('voidking') where user='root';mysql&gt; flush privileges;mysql&gt; quit;

5、重新启动mysql
ps -e | grep mysqlkill -KILL [PID of mysqld_safe]kill -KILL [PID of mysqld]service mysqld start

6、测试登录mysqlmysql -u root -p，回车后输入新设置的密码“voidking”即可。
空密码无法登录问题描述登录mysql，mysql -u root -p，两次回车，结果提示，“ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password:NO)”。
解决办法1、停止mysql服务，service mysqld stop。2、进入/usr/local/mysql/bin文件夹，启用安全模式，./mysqld_safe --skip-grant-tables &amp;。3、使用root用户登录mysql，mysql -u root。4、修改root用户密码：
mysql&gt; use mysql;mysql&gt; select * from  user;mysql&gt; truncate table user;mysql&gt; flush privileges;mysql&gt; grant all privileges on *.* to root@localhost identified by 'voidking' with grant option;

如果想设置密码为空，那么：
mysql&gt; grant all privileges on *.* to root@localhost identified by '' with grant option;mysql&gt; flush privileges;

确认结果：
mysql&gt; select host, user from user;+-----------+------+| host      | user |+-----------+------+| localhost | root |+-----------+------+1 row in set (0.00 sec)mysql&gt; quit;

5、启动mysql服务：
ps -e | grep mysqlkill -KILL [PID of mysqld_safe]kill -KILL [PID of mysqld]service mysqld start

6、登录mysql，mysql -u root -p，回车后输入新设置的密码“voidking”即可。
允许远程访问1、关闭防火墙systemctl stop firewalld.service
或者开放端口：firewall-cmd --zone=public --add-port=3306/tcp --permanent，firewall-cmd --reload
2、登录mysql控制台，然后依次输入：mysql&gt; use mysql;mysql&gt; grant all privileges on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;voidking&#39; with grant option;
书签Mysql数据库中设置root密码的命令及方法
Access denied for user ‘root@localhost’ (using password:NO)
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>mysql</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Navicat对比和同步Mysql</title>
    <url>/dev-navicat-mysqldiff/</url>
    <content><![CDATA[问题线上一份数据库，测试环境一份数据库。怎样知道两个数据库之间的表结构和数据差异？
1、表结构对比：对比开发库和正式库之间的表结构，哪个表结构有字段的增加减少，或者字段类型的改变，并生成sql进行结构的同步。
2、数据对比：对比两个数据库中的某个表的数据差异，生成sql脚本进行两个库的同步。


解决办法很简单，使用 navicat 。
很多开发者使用navicat创建数据库、创建表、增删查改、导出sql文件、导入sql文件等。但是，只有少数人知道，navicat还有强大的对比同步功能。
情景描述东北高师就业联盟网，线上（阿里云）有一份数据库db_new_dsjyw，本地有一份数据库也叫db_new_dsjyw。因为在本地进行开发，所以本地的数据库表结构是最新的，而线上的数据库数据是最新的。开发完成要把本地数据库表结构同步到线上，该怎么做？
表结构同步1、在navicat中，首先确认本地数据库连接和线上数据库连接都正常。
2、工具，结构同步。
3、结构同步窗口，常规选项卡中，源连接选择本地，源数据库选择db_new_dsjyw；目标连接选择阿里云，目标数据库选择db_new_dsjyw。
4、对比选项全部勾选，除了对比自动递增值，运行选项全部勾选。
5、单击“对比”，即可跳转到对比选项卡。
6、对比完成，右键查询修改小窗口，即可看到“运行查询”前的选项。
7、单击“全部勾选”，然后单击“已勾选脚本的详细信息”，可以看到脚本详细信息。
8、全选，复制，保存为sql脚本，用于修改线上的数据库表结构。
9、单击“运行查询”，即可修改线上数据库表结构。或者直接在线上数据库中执行第8步中得到的sql文件，也可以修改线上数据库表结构。
表数据同步在本情景中，不需要同步表数据。如果非要同步的话，那么我们要先把线上的数据同步到本地，然后再把本地数据同步到线上。当然，更好的做法是线上新建数据库db_new_dsjyw2，然后切换到db_new_dsjyw2，万一同步除了问题，我们还可以切换回db_new_dsjyw。
下面我们尝试下线上数据同步到本地。
1、在navicat中，首先确认本地数据库连接和线上数据库连接都正常。
2、工具，数据同步。
3、数据同步窗口，常规选项卡中，源连接选择阿里云，源数据库选择db_new_dsjyw；目标连接选择本机，目标数据库选择db_new_dsjyw。
4、单击“全选”，源表出现在目标表中。
5、单击“开始”，开始数据同步。
后记有同学推荐mysqldiff，mysqldiff工具是官方mysql-utilities工具集的一个脚本，可以用来对比不同数据库之间的表结构，或者同个数据库间的表结构。如果在windows下，直接下载安装mysql-utilities就可以了。
然而，上手体验不愉快，遂放弃，感兴趣的小伙伴自行百度。
书签10秒钟完成MySQL数据库结构对比
MySQL 对比数据库表结构
mysqldiff — Identify Differences Among Database Objects
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx入门篇</title>
    <url>/dev-nginx-start/</url>
    <content><![CDATA[Nginx是个啥Nginx (engine x) 是一个高性能的HTTP静态页面服务器，更是一个常用的反向代理服务器，同时还可以作为IMAP/POP3/SMTP代理服务器。
经常使用Nginx服务器，进行一些简单配置，但只是从网上照抄，知其然不知其所以然。本文，我们主要学习一下nginx的目录结构和基础规则，补一补nginx基础。


目录结构因为nginx目录是可以指定的，所以真实使用的目录结构请以命令查看。ps aux | grep nginx
配置目录可能的默认配置目录：
/etc/nginx//etc/nginx/conf

nginx.conf一般放在这两个目录中，nginx.conf中会写清楚子配置目录，比如：
http &#123;    include /etc/nginx/conf.d/*.conf;&#125;
那么，子配置文件就放在 /etc/nginx/conf.d/ 目录中，并且子配置文件必须以 .conf 结尾。一般情况下，我们比较少修改 nginx.conf，大部分时候都是修改子配置文件。
根目录可能的默认根目录：
/usr/share/nginx/html
根目录下一般会有nginx自带的index.html和50x.html。
curl ${nginx_server}时看到内容，就是index.html文件中的内容。
我们自己的静态页面项目，最好不要放到默认根目录下，因为默认根目录可以通过ip和路径访问到，这往往是不符合预期的。推荐的静态页面项目目录为：/usr/share/nginx/work
日志目录可能的默认日志目录：
/var/log/nginx
日志文件中一般有两个日志文件，error.log和access.log。
常见配置静态页面服务器配置server &#123;    listen 80;    server_name www.voidking.com;    charset utf-8;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;        root /usr/share/nginx/html/;        index index.html;    &#125;&#125;
这个配置，是一个标准的静态页面服务器配置。使用以上配置，如果已经配置好了域名解析，那么访问 www.voidking.com 时，就会看到nginx首页，也就是 index.html。
反向代理到其他域名server &#123;    listen 80;    server_name www.voidking.com;    charset utf-8;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_pass http://voidking.coding.me;    &#125;&#125;
使用以上配置，访问 www.voidking.com 时，实际上看到的是 voidking.coding.me 这个域名返回的内容。
反向代理到一个服务server &#123;    listen 80;    server_name www.voidking.com;    charset utf-8;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_pass http://192.168.56.101:8080;    &#125;&#125;
使用以上配置，访问 www.voidking.com 时，实际上看到的是 192.168.56.101:8080 这个服务返回的内容。
反向代理到upstreamupstream www_voidking_com&#123;    server 192.168.56.101:8080 weight=5;    server 192.168.56.102:8081 weight=2;    server 192.168.56.103:8000;&#125;server &#123;    listen 80;    server_name www.voidking.com;    charset utf-8;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_pass http://www_voidking_com;    &#125;&#125;
使用以上配置，访问 www.voidking.com 时，实际上看到的是upstream里的服务返回的内容。但是问题来了，upstream里有三个服务，到底是哪个服务返回的内容呢？答：不一定，这就要用到传说中的加权轮询算法了。三个服务的权值分别为 5、2、1（默认），从权值来看，最大可能打到第一个服务。有没有想到什么知识点？没错，负载均衡，使用了加权轮询算法的负载均衡。
基础规则location规则在常见配置中，我们看到了一个叫 location 的关键字。location规则为：
location [ = | ~ | ~* | ^~ ] uri &#123; ... &#125;location @name &#123; ... &#125;

紧跟在location后面的，是可选的修饰符，uri是要匹配的字符串。常见修饰符：

= 普通匹配。只有请求的url路径与后面的字符串完全相等时，才会命中。
空 普通匹配。
/ 普通匹配。
^~ 普通匹配。匹配到了uri，则不再进行正则匹配。
~ 正则匹配。区分大小写。
~* 正则匹配。不区分大小写。

匹配规则匹配过程：1、先普通匹配，再正则匹配。2、普通匹配：按最大前缀匹配。若=或^~匹配到了，则不再进行后续正则匹配。3、正则匹配：按配置顺序进行匹配，若匹配到了，则不再进行后续正则匹配。4、普通匹配和正则匹配都有结果，优先使用正则匹配结果。
proxy_pass规则如果nginx作为反向代理使用，那么必须要搞明白的就是proxy_pass的规则，这关系到请求能否打到正确的接口。proxy_pass规则：

如果proxy_pass后面没有路径，那么转发时带上uri
如果proxy_pass后面有路径，那么转发时使用该路径替换匹配到的uri

保留urilocation  /test &#123;    proxy_set_header Host   $host;    proxy_set_header X-Real-IP      $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_pass http://192.168.56.101:8080;&#125;
访问 www.voidking.com/test/index 会被代理到 http://192.168.56.101:8080/test/index 这个url，/test/index 被保留转发给了后端服务。
去掉urilocation  /test &#123;    proxy_set_header Host   $host;    proxy_set_header X-Real-IP      $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_pass http://192.168.56.101:8080/;&#125;
访问 www.voidking.com/test/index 会被代理到 http://192.168.56.101:8080/index 这个url，/test 被去掉了。
替换urilocation  /test &#123;    proxy_set_header Host   $host;    proxy_set_header X-Real-IP      $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_pass http://192.168.56.101:8080/qa/;&#125;
访问 www.voidking.com/test/index 会被代理到 http://192.168.56.101:8080/qa/index 这个url，/test/index 被替换成了 /qa/index，然后转发给了后端服务。
location  /test &#123;    proxy_set_header Host   $host;    proxy_set_header X-Real-IP      $remote_addr;    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    proxy_pass http://192.168.56.101:8080/qa;&#125;

访问 www.voidking.com/test/index 会被代理到 http://192.168.56.101:8080/qaindex 这个url，/test/index 被替换成了 /qaindex，然后转发给了后端服务。
状态码
1xx:信息响应类，表示接收到请求并且继续处理
2xx:处理成功响应类，表示动作被成功接收、理解和接受
3xx:重定向响应类，为了完成指定的动作，必须接受进一步处理
4xx:客户端错误，客户请求包含语法错误或者是不能正确执行
5xx:服务端错误，服务器不能正确执行一个正确的请求

详情参考HTTP 状态码详解与选用
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx URL大小写转换</title>
    <url>/dev-nginx-url-to-lowercase/</url>
    <content><![CDATA[url大小写问题将Windows下的项目（如：php）迁移到Linux下，由于Windows操作系统中，文件名是不区分大小写的；而Linux系统是大小写敏感，会导致有些网页出现404情况。那么，怎样Nginx实现url请求不区分大小写呢？运维笔记提供了四种解决方案，郝同学采用安装lua模块的方式。lua-nginx-module来自大牛agentzh的开源项目，在Nginx中嵌入Lua语言，使之可以支持强大Lua语法。


安装lua1、下载luawget http://luajit.org/download/LuaJIT-2.0.2.tar.gz
2、安装luatar -xvzf LuaJIT-2.0.2.tar.gz
cd LuaJIT-2.0.2
make &amp;&amp; make install
3、配置lua在当前用户的home目录下，编辑.bashrc，添加：
export LUAJIT_LIB="/usr/local/lib"export LUAJIT_INC="/usr/local/include/luajit-2.0"

使配置立即生效，source .bashrc
下载nginx1、查看nginx编译安装时安装了哪些模块/usr/local/nginx/sbin/nginx -V
结果为：
nginx version: nginx/1.10.0built by gcc 4.4.7 20120313 (Red Hat 4.4.7-17) (GCC) built with OpenSSL 1.0.1e-fips 11 Feb 2013TLS SNI support enabledconfigure arguments: --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module --with-ipv6 --with-http_sub_module

2、下载对应版本的nginxwget http://nginx.org/download/nginx-1.10.0.tar.gz
3、解压tar -xvzf nginx-1.10.0.tar.gz
下载nginx-lua1、在opt目录下，下载nginx-lua模块wget https://github.com/simpl/ngx_devel_kit/archive/v0.2.19.tar.gz
wget https://github.com/chaoslawful/lua-nginx-module/archive/v0.10.2.tar.gz
2、解压模块tar -xvzf ngx_devel_kit-0.2.19.tar.gz
tar -xvzf lua-nginx-module-0.10.2.tar.gz
编译安装nginx-lua1、进入nginx源码目录cd cd nginx-1.10.0
2、参考nginx -V中的参数，添加add-module编译参数：./configure --user=www --group=www --prefix=/usr/local/nginx --with-http_stub_status_module --with-http_ssl_module --with-http_v2_module --with-http_gzip_static_module --with-ipv6 --with-http_sub_module --add-module=/opt/ngx_devel_kit-0.2.19 --add-module=/opt/lua-nginx-module-0.10.2
3、编译make
注意，一定不要make install
4、替换nginx二进制文件
cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak
service nginx stop
cp ./objs/nginx /usr/local/nginx/sbin/
5、重新读取库文件ldconfig
6、启动nginx/usr/local/nginx/sbin/nginx -t
service nginx start
nginx-lua使用修改test.voidking.com.conf文件：
location / &#123;      if ($uri ~ [A-Z])&#123;          rewrite_by_lua 'return ngx.redirect(string.lower(ngx.var.uri),ngx.HTTP_MOVED_PERMANENTLY)';      &#125;  &#125;

书签Nginx实现url请求不区分大小写
已安装nginx动态添加模块
 error while loading shared libraries: libluajit-5.1.so.2
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>node中exports和module.exports的区别和联系</title>
    <url>/dev-node-exports-and-module-exports/</url>
    <content><![CDATA[前言
exports只是module.exports的辅助方法。你的模块最终返回module.exports给调用者，而不是exports。exports所做的事情是收集属性，如果module.exports当前没有任何属性的话，exports会把这些属性赋予module.exports。如果module.exports已经存在一些属性的话，那么exports中所用的东西都会被忽略。


最初时，exports是module.exports的一个引用。(exports=global.exports)=(self.exports=module.exports)



exports正常导出// caculate.jsexports.add = function (a, b) &#123;    return a+b;&#125;

// main.jsvar caculate = require('./caculate');exports.runAdd = function(req, res)&#123;    var num = caculate.add(5,4);    console.log(num);&#125;
在main模块中，可以正常调用caculate模块中的add函数。因为exports是module.exports的一个引用，所以exports.add=function(){}这个操作，把add函数加到了module.exports指向的对象（函数也是对象）中。而main模块中获取到的，就是caculate的module.exports指向的对象，自然也获取到了add函数。
exports错误导出// caculate.jsexports = function (a, b) &#123;    return a+b;&#125;

// main.jsvar caculate = require('./caculate');exports.runAdd = function(req, res)&#123;    console.log(caculate);    //var num = caculate(5, 4);    //console.log(num);&#125;
如上的导出方法是错误的，我们可以看到打印出的caculate是一个空对象{}。因为exports原本是module.exports的一个引用，后来指向了一个函数。而module.exports的指向的对象，初始值就是空对象{}，自始至终都没有这个空对象添加属性或函数。所以，当main模块中获取到caculate的module.exports指向的对象时，依然是一个空对象{}。
module.exports导出// caculate.jsexports.add = function (a, b) &#123;    return a+b;&#125;var caculate = &#123;    delete: function(a, b)&#123;        return a-b;    &#125;,    multiple: function(a, b)&#123;        return a*b;    &#125;&#125;;module.exports = caculate;

// main.jsvar caculate = require('./caculate');exports.runDelete = function(req, res)&#123;    //var num = caculate.add(5, 4);    var num = caculate.delete(5, 4);    console.log(num);&#125;
如上导出方法，在caculate的module.exports指向的对象中，不会包含add函数。虽然exports.add=function(){}向module.exports指向的空对象{}中添加了一个add函数，但是紧接着，module.exports指向的对象改变了！变成了caculate对象。
seajs中module.exports和returnseajs中的exports和module.exports的关系，和Node中相同。
在进行插件CMD模块化时，发现module.exports和return基本相同。下面写个小例子：
// plugin.jsdefine(function(require, exports, module)&#123;    module.exports = function(jQuery)&#123;        // require('another-plugin')(jQuery);        // 依赖jQuery的插件代码    &#125;&#125;)

// plugin.jsdefine(function(require, exports, module)&#123;    return function(jQuery)&#123;        // require('another-plugin')(jQuery);        // 依赖jQuery的插件代码    &#125;&#125;)

seajs.use(['jquery','plugin'],function($,plugin)&#123;    plugin($);//初始化&#125;);

书签Modules Node.js v6.3.0 Manual &amp; Documentationhttps://nodejs.org/api/modules.html#modules_the_module_object
module.exports 还是 exports？http://zihua.li/2012/03/use-module-exports-or-exports-in-node/
nodejs中export与module.export的区别
SeaJS 中的 exports 和模块加载http://www.tuicool.com/articles/Y3qmAj
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>exports</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Node读写文件</title>
    <url>/dev-node-read-and-write-file/</url>
    <content><![CDATA[前言七夕将近，公司要整一个活动：七夕礼物测试。大致需求是，用户选择自己的性别、生日和情感状态，点击“惊喜一下”，出现礼物详情。根据性别、生日和情感状态的不同，给出不同的礼物详情，一共有37种不同的礼物。同时，添加统计，统计有多少人参加过测试。


设计这次活动，不打算让后端参与，所以要Node端自己负责数据的存取。
读取文件有三个方案：1、数据存在代码中（运行时直接加载到内存）。2、利用request模块读取。3、利用fs模块读取。
写入文件有一个方案：利用fs模块写入。
在之前的文章中，已经讨论过使用request模块读取本地文件的方法，本文主要探讨一下使用fs模块读写文件的方法。
代码数据文件在/public/data文件下，新建文件count.json。内容如下：
&#123;"count":100&#125;

fs读取文件var fs = require('fs');var path = require('path');fs.readFile(path.join(__dirname,'../public/data/count.json'),&#123;encoding:'utf-8'&#125;,function(error, data)&#123;    console.log(data);    var countData = JSON.parse(data);    console.log(count.countData.count);&#125;);
需要解释一下的，是dirname，在任何模块文件内部，可以使用dirname变量获取当前模块文件所在目录的完整绝对路径。
path.join([path1],[path2],[…])函数，将多个参数组合成一个path。
fs写入文件var fs = require('fs');var path = require('path');fs.readFile(path.join(__dirname,'../public/data/count.json'),&#123;encoding:'utf-8'&#125;,function(error, data)&#123;    //console.log(data);    var count = parseInt(JSON.parse(data).count);    count++;    var countData = &#123;        count: count    &#125;;    fs.writeFile(path.join(__dirname,'../public/data/count.json'),JSON.stringify(countData),function(error)&#123;        console.log('success');    &#125;);&#125;);

完整代码https://github.com/voidking/nodebase/blob/master/controllers/weixin.js
书签简单的nodejs 文件系统（fs）读写例子http://www.2cto.com/kf/201411/351586.html
Node.js读取文件内容http://blog.csdn.net/zk437092645/article/details/9231787
node 的文件操作http://blog.chinaunix.net/uid-26672038-id-4139323.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>利用Node的request模块访问本地数据</title>
    <url>/dev-node-request-local-data/</url>
    <content><![CDATA[前言最近公司系统架构调整，数据还没有迁移完毕，很多接口出现了问题，联调成了一件困难的事。开发还要继续，牛逼的前端自力更生！


获取地址以获取用户的地址信息为例，对代码进行改造。
原代码// 获取用户地址信息var queryAddressUrl = config.apihost + '/address/selAddress';var param = &#123;  accessToken: accessToken&#125;;request.post(&#123;url: queryAddressUrl, form:JSON.stringify(param)&#125;,function(error, response, body)&#123;  console.log(response.body);  if(!error &amp;&amp; response.statusCode == 200)&#123;    ep.emit('address',response.body);  &#125;&#125;);

改造后代码// 获取用户地址信息// var queryAddressUrl = config.apihost + '/address/selAddress';var queryAddressUrl = config.host + '/data/address.json';var param = &#123;  accessToken: accessToken&#125;;// post改为getrequest.get(&#123;url: queryAddressUrl, form:JSON.stringify(param)&#125;,function(error, response, body)&#123;  console.log(response.body);  if(!error &amp;&amp; response.statusCode == 200)&#123;    ep.emit('address',response.body);  &#125;&#125;);
两段代码对比，可以发现，请求的url由远程接口地址改为了本地文件地址，请求的type由post改为了get。
address.json因为public文件夹的虚拟路径为网站根目录，且为静态文件目录，所以在/public/data文件夹下，新建文件address.json，内容如下：
&#123;    "code": 1,    "ext": &#123;        "msg": "成功"    &#125;,    "obj": &#123;        "pcdAddress": "江苏省 南京市 雨花台区",        "purchaserName": "郝锦",        "purchaserTel": "15195892217",        "street": "华博智慧园",        "areaId": 0,        "defaultAddress": false    &#125;&#125;
至此，改造成功，可以愉快地获取数据了！
后记有些需要计算的数据并不能模拟，比如支付宝的签名字符串。
利用ajax也可以获取本地数据，对于前端开发者来说同样很实用。用法很简单，一看就会，详情自行百度。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>request</tag>
      </tags>
  </entry>
  <entry>
    <title>Node基础开发框架</title>
    <url>/dev-nodebase-framework/</url>
    <content><![CDATA[前言测试新功能，开发新项目，按照本人的懒惰程度推算，八成会在原有项目的基础上开发。既然如此，抽出来一个node基础框架，似乎是一个很好的想法。本框架保留了毕设的主体代码，删除了一些无关代码，并且会继续增减代码，逐渐完善。


nodebasea node framework designed for myselfversion: v1.0.0url: https://github.com/voidking/nodebase.git  
作者相关author: haojin(voidking)e-mail: voidking@qq.comsite: http://www.voidking.com   
开发环境说明1、安装5.6.0以上Node2、安装mongodb，不要配置密码3、安装sass4、全局安装bower5、全局安装supervisor6、全局安装node-inspector7、全局安装puer8、运行前执行命令
npm installbower install


node实时调试命令node-inspector --web-port=8888node --debug app.js

运行命令node app.js，访问http://localhost
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js学习笔记（一）</title>
    <url>/dev-nodejs-note-1/</url>
    <content><![CDATA[整理自：慕课网
helloworld工程的搭建技术及工具
node.js + mongodb(工具mongoose) + express + jade + moment.js + npm + jquery + bootstrap + grunt

我靠，那么多！淡定，暂时，咱们这个工程只要 node.js + express + jade 。
准备工作下载安装node.js。
工程结构helloworld/  -node_modules/  -bower_components/  -views/    -index.jade  -app.js
上两张图，直观感受下：![工程结构][1]![工程结构][2]

具体操作新建helloworld文件夹在F盘下新建个文件夹叫做“ helloworld ”，然后打开命令提示符，cd命令进入F盘下的helloworld文件夹。
执行以下命令：npm install expressnpm install jadenpm install mongodbnpm install bower -gbower install bootstrap
查看文件夹看看helloworld文件夹，诶？结构和你给的不一样啊！那就对了，咱接着搞！
新建文件在helloworld文件夹下，新建文件app.js，输入内容如下：
var express = require('express');var port = process.env.PORT || 3000 ;var app = express();app.set('views','./views');app.set('view engine','jade');app.listen(port);console.log('helloworld started on port ' + port);app.get('/', function(req, res)&#123;  res.render('index',&#123;title:'helloworld'&#125;);&#125;);
至于这段代码的意思，请自行观看视频哈！在views文件夹下，新建文件index.jade（这个文件就相当于html文件），输入内容如下：
doctypehtml	head		meta(charset="utf-8")		title #&#123;title&#125;	body		h1 #&#123;title&#125;
至此，大功告成！
查看效果在helloworld文件夹下执行命令：
node app.js
在浏览器中打开：http://localhost:3000有没有看到“helloworld”这个出现在了浏览器上？没看到？请留言！PS：你也可以新建admin.jade，也输入和index.jade相同的代码。然后在app.js添加如下代码：
app.get('/admin/', function(req, res)&#123;  res.render('admin',&#123;title:'admin'&#125;);&#125;);
访问地址：http://localhost:3000/admin/这时你会看到“admin”出现在了浏览器上！
结束好了，今天的笔记就写到这里！有任何问题欢迎留言。  [1]: http://ihelloworld.qiniudn.com/@/imgs/nodejs%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpg  [2]: http://ihelloworld.qiniudn.com/@/imgs/nodejs%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E5%88%86%E6%94%AF.jpg
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>node依赖包的管理</title>
    <url>/dev-npm-install/</url>
    <content><![CDATA[前言在使用node进行开发时，我们会用到很多包（模块、中间件），而这些包，并不是需要我们维护的，所以，只要记住包名和版本号就够了。而这些包名和版本号等信息，就放在package.json文件里，该文件就类似于Maven中的pom.xml。
package.json文件，可以手动编写，也可以利用npm init命令生成。


npm常用命令1、npm install module-name -g，全局安装。2、npm install module-name --save，自动把模块和版本号添加到dependencies部分。3、spm install module-name --save-dev 自动把模块和版本号添加到devDependencies部分。那么，2和3有什么区别呢？根据官方的解释，就是说在dependencies部分用到的模块，是一些必须的模块；而devDependencies用到的模块，是我们在生产过程中做测试用到的模块。如果你把自己的代码提交到了git服务器，别人下载了你的代码，然后npm install，下载所有依赖的模块，这时，dependencies里的模块会下载，devDependencies里的模块不会下载。
忘记使用–save补救npm init，根据提示可以创建一个package.json文件，这个过程会自动把已经安装的模块写入package.json的dependencies部分。
假设，在之后，我们又安装了很多模块，但是，在安装时，使用的命令是npm install，而不是npm install --save。这时，有没有什么办法，可以一次性把我们安装的所有模块名和版本号写入package.json呢？
郝同学摸索出来一个可行的办法：1、把原先的package.json（文件1）拷贝出来。2、npm init，不停回车至新的package.json（文件2）创建完成。3、把文件2的dependencies部分拷贝覆盖到文件1的dependencies部分。4、使用文件1覆盖文件2。5、npm ls，如果有报错，说明还有个别依赖模块没有写进package.json。6、根据5的提示，手动修改package.json；或者，npm install module-name --save，把没有写进package.json的模块重新安装一次。
git忽略上传在主目录下新建.gitignore文件，内容格式如下：1、最常用
/node_modules/*/bower_components/*

2、在已忽略文件夹中不忽略指定文件夹
/node_modules/*!/node_modules/layer/

3、在已忽略文件夹中不忽略指定文件
/node_modules/*!/node_modules/layer/layer.js
【注意项】注意写法 要忽略的文件夹一定要结尾 /* ，否则不忽略规则将无法生效
4、其他规则写法 (附)

以斜杠“/”开头表示目录；

以星号“*”通配多个字符；

以问号“?”通配单个字符

以方括号“[]”包含单个字符的匹配列表；

以叹号“!”表示不忽略(跟踪)匹配到的文件或目录；


后记bower的用法和npm非常相似，两者可以对比着学习和记忆。
参考文档npm Documentationhttps://docs.npmjs.com/install
package.jsonhttps://docs.npmjs.com/files/package.json
git添加 .ignore 忽略http://www.thinksaas.cn/topics/0/487/487787.html  
.gitignore 规则写法http://my.oschina.net/longyuan/blog/521098
用package.json来管理NPM里面的依赖包
淘宝npm镜像http://npm.taobao.org/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>使用OpenCV实现实时视频目标检测</title>
    <url>/dev-object-detection/</url>
    <content><![CDATA[前言老板与时俱进，开始带领大家搞机器学习。nice，刚好小生就想往这方面发展。这不，老板派发下了任务：利用深度学习+python+opencv，实现实时视频目标检测。看教程，很简单的样子，那就搞一下。


环境准备python1、参考《Anaconda》，安装Anaconda。
Anaconda常用命令：

查看环境，conda env list
进入环境，activate my_env
退出环境，deactivate
查看python版本，python --version
添加环境，conda create -n py3.6 python=3.6
删除环境，conda env remove -n py3.6
查看环境中的包，conda list
更新当前环境下的所有包，conda upgrade --all
安装包，conda install package_name

2、安装python3.6环境，以便使用对应版本的opencv。
conda create -n py3.6 python=3.6activate py3.6conda upgrade --all


PS：以下命令都是在python3.6环境中执行。
3、安装numpy、imutils
pip install numpypip install imutils

opencv1、访问Python Extension Packages for Windows，下载python对应版本的opencv。
比如郝同学下载的是opencv_python-3.3.0+contrib-cp36-cp36m-win_amd64.whl，cp36表示Python是3.6版本，win_amd64是表示安装的python是64bit的，+contrib表示包括contrib包。
2、下载好后，把它放到C盘中，执行安装命令：pip install C:\opencv_python-3.3.0+contrib-cp36-cp36m-win_amd64.whl
运行代码修改Adrian Rosebrock同学的原版代码适用于直接调用摄像头来获取视频流，尴尬的是，小生的电脑摄像头坏了，无法使用。于是，不得不修改代码，主要是把视频流的获取方式改为从本地获取。
# vs = VideoStream(src=0).start()# vs =cv2.VideoCapture('C:\\Users\\voidking\\Desktop\\real-time-object-detection\\test_video.flv')vs =cv2.VideoCapture('./test_video.flv')

# grab the frame from the threaded video stream and resize it# to have a maximum width of 400 pixels# frame = vs.read()# frame = imutils.resize(frame, width=400)# grab the frame from the threaded video file stream(grabbed,frame) = vs.read()# if the frame was not grabbed, then we have reached the end# of the streamif not grabbed:    breakframe = imutils.resize(frame, width=800)


运行推荐使用命令：
python real_time_object_detection.py -p ./MobileNetSSD_deploy.prototxt.txt -m ./MobileNetSSD_deploy.caffemodel

或者，指定绝对路径，假设项目目录为C:\Users\voidking\Desktop\real-time-object-detection\，那么命令如下：
python real_time_object_detection.py -p "C:\Users\voidking\Desktop\real-time-object-detection\MobileNetSSD_deploy.prototxt.txt" -m "C:\Users\voidking\Desktop\real-time-object-detection\MobileNetSSD_deploy.caffemodel"

进阶修改我们看到，prototxt和model都是指定的，那我们的视频文件也用这种方式指定，就更加友好一点。
# construct the argument parse and parse the argumentsap = argparse.ArgumentParser()ap.add_argument("-p", "--prototxt", required=True,    help="path to Caffe 'deploy' prototxt file")ap.add_argument("-m", "--model", required=True,    help="path to Caffe pre-trained model")ap.add_argument("-c", "--confidence", type=float, default=0.2,    help="minimum probability to filter weak detections")args = vars(ap.parse_args())

我们插入一行：
ap.add_argument("-v", "--video", required=True,    help="path to Caffe video file")

然后在初始化视频流时，修改为：
vs =cv2.VideoCapture(args["video"])

运行命令修改为：
python real_time_object_detection.py -p ./MobileNetSSD_deploy.prototxt.txt -m ./MobileNetSSD_deploy.caffemodel -v ./test_video.flv

运行效果
源码分享https://github.com/voidking/object-detection.git
书签《深度学习 + OpenCV，Python实现实时视频目标检测》
Real-time object detection with deep learning and OpenCV
Faster video file FPS with cv2.VideoCapture and OpenCV
用 Python 和 OpenCV 检测和跟踪运动对象
用树莓派 + Python + OpenCV 实现家庭监控和移动目标探测（下）
Python 3.x 安装opencv+opencv_contrib
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>opencv</tag>
        <tag>深度学习</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>开源镜像站</title>
    <url>/dev-open-source-mirror-site/</url>
    <content><![CDATA[前言开源镜像站是一个放置开源系统镜像文件的站点，免费提供镜像文件下载。


Linux镜像kernel 镜像站： http://mirrors.kernel.org/CentOS 官方镜像站：http://mirror-status.centos.org/Fedora 官方镜像站：http://mirrors.fedoraproject.org/publiclistDebian 全球镜像站：http://www.debian.org/mirror/listUbuntu 官方镜像站：http://releases.ubuntu.com/releases/http://cdimage.ubuntu.com/suse官方镜像站：http://download.opensuse.org/RedHat镜像站：http://ftp.corbina.net/pub/Linux/redhat/Linux运维派开源镜像站：http://mirrors.skyshe.cn/


企业机构开源镜像站阿里云开源镜像站：http://mirrors.aliyun.com/网易开源镜像站：http://mirrors.163.com/搜狐开源镜像站：http://mirrors.sohu.com/天翼云：http://mirrors.ctyun.cn/首都在线科技股份有限公司：http://mirrors.yun-idc.com/开源中国：http://mirrors.oschina.net/阿里云开源镜像：http://mirrors.aliyun.com/常州贝特康姆软件技术有限公司(原cn99）：http://centos.bitcomm.cn/开源世界：http://mirror.lupaworld.com/
国内大学开源镜像站香港中文大学 ：http://ftp.cuhk.edu.hk/pub/Linux/台湾淡江大学：http://ftp.tku.edu.tw/Linux/电子科技大学: http://ubuntu.uestc.edu.cn/厦门大学：http://mirrors.xmu.edu.cn/浙江大学：http://mirrors.zju.edu.cn/东软信息学院：http://mirrors.neusoft.edu.cn/中山大学镜像：http://mirror.sysu.edu.cn/华中科技大学： http://mirrors.hustunique.com/大连理工大学：http://mirror.dlut.edu.cn/兰州大学：http://mirror.lzu.edu.cn/重庆大学：http://mirrors.cqu.edu.cn/北京理工大学：http://mirror.bit.edu.cn (IPv4 only)http://mirror.bit6.edu.cn (IPv6 only)北京交通大学：http://mirror.bjtu.edu.cn (IPv4 only)http://mirror6.bjtu.edu.cn (IPv6 only)http://debian.bjtu.edu.cn (IPv4+IPv6)上海交通大学：http://ftp.sjtu.edu.cn/ (IPv4 only)http://ftp6.sjtu.edu.cn (IPv6 only)清华大学：http://mirrors.tuna.tsinghua.edu.cn/ (IPv4+IPv6)http://mirrors.6.tuna.tsinghua.edu.cn/ (IPv6 only)http://mirrors.4.tuna.tsinghua.edu.cn/ (IPv4 only)中国科学技术大学：http://mirrors.ustc.edu.cn/ (IPv4+IPv6)http://mirrors4.ustc.edu.cn/http://mirrors6.ustc.edu.cn/东北大学：http://mirror.neu.edu.cn/ (IPv4 only)http://mirror.neu6.edu.cn/ (IPv6 only)华中科技大学：http://mirrors.hust.edu.cn/http://mirrors.hustunique.com/
国外大学开源镜像站北陆先端科学技术大学院大学JAIST: http://ftp.jaist.ac.jp/pub/卡内基梅隆大学CMU: http://www.club.cc.cmu.edu/pub麻省理工学院MIT: http://mirrors.mit.edu/哥伦比亚大学: http://mirror.cc.columbia.edu/俄勒冈州立大学: http://ftp.osuosl.org/pub伊利诺伊大学厄巴纳-香槟分校: http://cosmos.cites.illinois.edu/杜克大学: http://archive.linux.duke.edu/约翰·霍普金斯大学: http://mirrors.acm.jhu.edu/俄罗斯镜像服务器：http://ftp.kddilabs.jp/http://ftp.jaist.ac.jp/pub/http://ftp.kaist.ac.kr/http://mirror.karneval.cz/pub/http://ftp.gwdg.de/pub/http://ftp.estpak.ee/pub/
分类镜像服务器PyPi豆瓣：http://pypi.douban.com/中山大学：http://mirror.sysu.edu.cn/pypi/
RubyGems淘宝：http://ruby.taobao.org/中山大学：http://mirror.sysu.edu.cn/rubygems/
npmcnpmjs：http://cnpmjs.org/
书签国内外开源镜像服务器站点汇总http://www.douban.com/note/375227086/
国内开源镜像站点汇总http://segmentfault.com/a/1190000000375848
中国Linux开源镜像站大全http://www.centoscn.com/yunwei/news/2012/1227/131.html
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenShift使用说明</title>
    <url>/dev-openshift-illustration/</url>
    <content><![CDATA[前言郝同学的第一个网站，使用WordPress，搭建在OpenShift上面。OpenShift出身名门，无论从其稳定性还是功能性来说，都没有给RedHat丢人。
官网：https://www.openshift.com


常用命令云服务器总是出问题，可以来这里试试openshift的命令来检查测试
gem install rhc安装rhc
gem update rhc更新rhc版本
rhc-chk检测本地环境配置
rhc-user-info显示用户信息
rhc-create-domain：创建个人域
rhc-create-app创建应用
rhc-snapshot应用备份
rhc-tail-files查看应用日志
openshift: rhc setup登录
rhc app create -a  app_name -t php-5.3创建php应用
rhc app create -a wordpress -t php-5.3创建wordpress
wordpress添加mysql支持：rhc app cartridge add -a wordpress -c mysql-5.1创建一个自定义应用：rhc-create-app -a  app_name -t diy-0.1创建命名空间：rhc domain create -n mydomain -l rhlogin创建phpmyadmin：rhc app cartridge add -a  app_name -c phpmyadmin-3.4绑定域名:rhc alias add appname domian删除绑定域名: rhc alias removeappname domian如果你是创建一个wordpress，需要MongoDB支持，可以输入如下命令：rhc app cartridge add -a wordpress -c mongodb-2.2
启动应用程序：ctl_app start停止应用程序：ctl_app stop重启应用程序：ctl_app restart查看应用程序：ctl_app status
启动应用程序：ctl_all start停止应用程序：ctl_all stop重启应用程序：ctl_all restart查看应用程序：ctl_all status
书签Red Hat老用户的OpenShift初体验
OpenShift红帽免费云空间申请、WordPress安装(图文教程)
RedHat Openshift 搭建个人博客(wordpress)指南
OpenShift Redhat免费空间SSH登录管理和使用:下载文件安装程序和应用
OpenShift redhat推出PaaS云计算应用平台支持PHP、Java、MySQL
openshift免费空间绑定顶级域名
友好面对开发者 OpenShift加入更多新元素
OpenShift免费空间安装PhpMyadmin及SQL数据库管理（图文教程）
OpenShift推出收费业务和解决OpenShift空间打不开和SSH无法连接
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack添加镜像</title>
    <url>/dev-openstack-add-mirror/</url>
    <content><![CDATA[前言本文实验最终失败，失败，失败！重要的事情说三遍。
想要用openstack创建两台ubuntu16的虚拟机，于是上传了ubuntu-16.04.4-server-amd64.iso镜像，然后用它创建了实例，分配了浮动IP。理论上，应该可以访问了。但是，ping该IP会提示Destination Host Unreachable。
找到了制作 OpenStack Linux 镜像 - 每天5分钟玩转 OpenStack（151）一文，发现作者使用的是cloud镜像。十有八九是镜像的原因了，那就尝试一下。


下载cloud镜像最简单的方法是使用标准镜像。主流的Linux发行版都提供可以在OpenStack中直接使用的cloud镜像，下面有几个下载地址：

CentOS6：http://cloud.centos.org/centos/6/images/
CentOS7：http://cloud.centos.org/centos/7/images/
Ubuntu14.04：http://cloud-images.ubuntu.com/trusty/current/
Ubuntu16.04：http://cloud-images.ubuntu.com/xenial/current/

这里我们访问 http://cloud-images.ubuntu.com/xenial/current/ ，然后下载xenial-server-cloudimg-amd64-disk1.img。
导入镜像1、在horizon控制台，项目，计算，镜像，创建镜像。
2、镜像上传完成，即可看到新添加的镜像。
3、使用ubuntu16的镜像创建实例u16-n0。
4、测试登录。给实例分配浮动IP为172.24.4.10，在ccrfox105上可以ping通。然后，查看日志，想要找到用户名和密码。但是，不同于cirros，在ubuntu16日志中并没有找到。
参考openstack入门二十六：创建实例，发现大多数 cloud images支持公钥授权而不是传统的用户名密码授权。
使用密钥dashboard方法1、项目，计算，密钥对，创建密钥对。
2、输入密钥名ccrfox105-key，创建密钥对，然后公钥就会上传到openstack，显示在控制台。同时会自动下载私钥到本地，名为ccrfox105-key.pem。
3、重新创建实例u16-n0（这次不要忘记选择密钥对），然后分配浮动IP为172.24.4.10。
4、通过scp把ccrfox105-key.pem上传到ccrfox105scp ccrfox105-key.pem test@ccrfox105:~
5、等待实例启动完全（5分钟左右），在ccrfox105测试登录ssh ubuntu@172.24.4.10 -i ccrfox105-key.pem
报错：修改了密钥权限为600，依然无法登录。
换成root用户，ssh root@172.24.4.10 -i ccrfox105-key.pem，依然无法登录。
尴尬，这是什么鬼？
命令行方法1、切换到stack用户sudo su - stack
2、生成密钥对ssh-keygen，三次回车。
3、添加公钥到openstack环境nova keypair-add --pub-key ~/.ssh/id_rsa.pub ccrfox105-stack-key
报错：
ERROR (CommandError): You must provide a username or user ID via --os-username, --os-user-id, env[OS_USERNAME] or env[OS_USER_ID]

参考[完整部署CentOS7.2+OpenStack+kvm 云平台环境（5）–问题解决]，需要source admin-openrc.sh，然而我的系统中并没有admin-openrc.sh这个文件。
（1）新建admin-openrc.sh，内容如下：
export OS_TENANT_NAME=adminexport OS_USERNAME=adminexport OS_PASSWORD=secretexport OS_AUTH_URL=http://172.16.0.105:35357/v2.

（2）执行source admin-openrc.sh
（3）再次执行nova keypair-add --pub-key ~/.ssh/id_rsa.pub ccrfox105-stack-key进行测试，错误变了
No handlers could be found for logger "keystoneauth.identity.generic.base"ERROR (DiscoveryFailure): Could not determine a suitable URL for the plugin

（4）sudo netstat -antupo | egrep &#39;(5000|35357)&#39;，发现35357端口服务没有启动。
（5）ps -ef | grep keystone，查看keystone服务，已经启动。
（6）vim /etc/keystone/keystone.conf，打开几处注释：
admin_bind_host = 0.0.0.0admin_port = 35357public_bind_host = 0.0.0.0public_port = 5000

（6）重启keystone，sudo /etc/init.d/apache2 restart
然后，没有用。
dashboard与命令行结合1、切换到stack用户sudo su - stack
2、生成密钥对ssh-keygen，三次回车。
3、拷贝公钥到本地
4、在openstack的dashboard导入公钥。
5、创建实例，选择新导入的公钥。
6、再次测试登录。ssh ubuntu@172.24.4.10 -i ~./ssh/id_rsassh root@172.24.4.10 -i ~./ssh/id_rsa
和dashboad方法报同样的错误：Permission denied (publickey).
至此，三种方法全部失败，猜测openstack的keystone服务没有安装好，留个坑吧。
不使用密钥参考如何在OpenStack上安装Ubuntu系统、Openstack使用官方ubuntu和Centos镜像和openstack中镜像的密码修改，配置过程如下：
创建实例，创建过程中不添加密钥对，而是配置脚本：
#!/bin/sh  sed -i 's/PermitRootLogin without-password/PermitRootLogin yes/g' /etc/ssh/sshd_config  sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/g' /etc/ssh/sshd_config  cp -f /home/ubuntu/.ssh/authorized_keys /root/.ssh/  service ssh restart  passwd ubuntu&lt;&lt;EOF  123456123456EOF

如下图：
然后，ssh ubuntu@172.24.4.10，Permission denied (publickey).
如果是CentOS，那么输入：
#!/bin/sh  sed -i 's/PermitRootLogin without-password/PermitRootLogin yes/g' /etc/ssh/sshd_config  sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/g' /etc/ssh/sshd_config  cp -f /home/centos/.ssh/authorized_keys /root/.ssh/  service sshd restart  passwd centos&lt;&lt;EOF  123456123456EOF


后记本次实验过程中，各种报错不断，大部分都没有找到解决方案。
最坑的是，除了cirros，其他镜像在实例创建成功后都无法登录，尝试了各种办法也没有解决，只能无奈放弃。
控制台也无法访问，参考OpenStack 控制台不能访问的问题进行配置，依然无法访问。
怀疑是因为openstack没有安装完整，毕竟安装完是有报错的，看来有必要重新安装一下openstack了。然后再写一篇《OpenStack添加镜像2.0》版本。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack入门</title>
    <url>/dev-openstack-start/</url>
    <content><![CDATA[云计算“云”是两个比喻：第一个比喻是互联网，计算资源不在本地，在互联网的另一端（云端）。第二个比喻是群组，天上的云是雨滴的汇聚成群组，云计算中的云是计算资源的群组。
云计算有一个愿景，就是希望把计算像水电一样提供给用户使用。然而用户并不是直接使用电，而是使用电灯电视等；同样，用户并不会直接使用计算资源，而是使用在计算资源上层开发的一些应用。 
“云”是分层的：

IaaS：Infrastructure-as-a-Service，基础设施即服务。
PaaS：Platform-as-a-Service，平台即服务。
SaaS：Software-as-a-Service，软件即服务。



What is OpenStack?
OpenStack is a cloud operating system that controls large pools of compute, storage, and networking resources throughout a datacenter, all managed through a dashboard that gives administrators control while empowering their users to provision resources through a web interface.

OpenStack是一个云操作系统，控制整个数据中心的计算、存储和网络资源。管理员通过面板管理OpenStack，普通用户通过一个Web界面获取资源。
OpenStack将硬件资源虚拟化出计算资源池，向上开放了一系列API，用于支持上层应用的开发，满足用户对计算资源的各种需求。
OpenStack与Docker的集成有两个方面：1、利用Docker进行OpenStack部署。2、在OpenStack中集成Docker，提供PaaS服务。
书签写在最前面 - 每天5分钟玩转 OpenStack（1）
5分钟学会OpenStack 基础知识
为何现在流行OpenStack和Docker结合？
深度解析Docker和OpenStack系统集成
Docker学习笔记 — Docker与OpenStack集成
How To Get Started With OpenStack
云服务的三层概念
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack中虚拟机的在线迁移</title>
    <url>/dev-openstack-vm-block-live-migration/</url>
    <content><![CDATA[前言虚拟机迁移主要有三种方式：P2V、V2V和V2P。P2V指迁移物理服务器上的操作系统及其上的应用软件和数据到VMM（Virtual Machine Monitor）管理的虚拟服务器中。V2V迁移是在虚拟机之间移动操作系统和数据。V2P 指把一个操作系统、应用程序和数据从一个虚拟机中迁移到物理机的主硬盘上，是 P2V 的逆操作。
V2V迁移又分为离线迁移和在线迁移。离线迁移也叫做常规迁移、静态迁移，在迁移之前需要将虚拟机关闭。在线迁移又称为实时迁移，是指保持虚拟机正常运行的同时进行迁移。本文要研究的，就是虚拟机的在线迁移。更多详细内容，请参考虚拟机迁移技术漫谈，第 1 部分。


迁移相关命令本文研究的是OpenStack集群中的虚拟机迁移，那么先研究一下OpenStack的虚拟机迁移命令。主要参考Live-migrate instances、Block Live Migration in OpenStack environment。
1、查看实例IDopenstack server list
PS：openstack server可以换成nova。
2、查看实例详情openstack server show 180617ec-1348-4144-a496-8751d12e84bf
PS：实例ID可以换成demo1。
3、查看可以迁移的节点openstack compute service list
4、查看其它节点资源使用情况openstack host list
openstack host show compute2
5、迁移nova live-migration 180617ec-1348-4144-a496-8751d12e84bf compute2啊嘞，没有反应是闹哪样？查看实例详情，依然位于compute节点。
6、调试迁移nova live-migration 180617ec-1348-4144-a496-8751d12e84bf compute2 --debug信息很多，找不到重点。在openstack热迁移和冷迁移一文中发现，在线迁移又可以分为两种：live migration和block migration。live migration需要实例保存在NFS共享存储中，这种迁移主要是实例的内存状态的迁移，速度应该会很快。block migration除了实例内存状态要迁移外，还得迁移磁盘文件，速度会慢些，但是它不要求实例存储在共享文件系统中。
而我们的这个集群，没有共享存储，所以应该用block migration？
7、再次迁移nova live-migration --block-migrate 180617ec-1348-4144-a496-8751d12e84bf compute2修改后的命令，在shell中同样没有更多提示，但是查看horizon，发现了惊喜，正在迁移。等到迁移完成，查看实例详情，却发现，实例所在主机依然没有发生变化！是因为nova没有配置好吗？很有可能，那么修改一下nova的配置试试。
nova配置因为是使用kolla部署的OpenStack，所以修改配置重启服务的方法，和传统方法有所不同。参考kolla(Ocata)部署nova组件关键配置和volume映射和Openstack 之 调整nova相关参数。可以知道，主机中的/etc/kolla/nova-compute/nova.conf，对应容器中的/etc/nova/nova.conf。修改后重启容器，nova-compute服务配置就会发生改变。
1、在两个计算节点，修改nova.confvim /etc/kolla/nova-compute/nova.conf，添加:
live_migration_flag=VIR_MIGRATE_UNDEFINE_SOURCE,VIR_MIGRATE_PEER2PEER,VIR_MIGRATE_LIVE

2、重启nova-compute
docker stop nova_computedocker start nova_compute

3、进入容器docker exec -it nova_compute /bin/bash
4、查看配置是否生效vi /etc/nova/nova.conf
再次迁移1、在控制节点执行迁移命令nova live-migration --block-migrate 180617ec-1348-4144-a496-8751d12e84bf compute2满怀期望，但是依然失败。
2、在计算节点查看日志tail -n 20 /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log日志报错部分如下：
2018-11-13 19:12:04.614 6 ERROR nova.virt.libvirt.driver [req-e6654355-fcec-4b93-a662-c758a03766fa b2edc935f89d4d2684ec4039c02a21cc ab7e3eb8c00d4299afd8572e1ec437bf - default default] [instance: 180617ec-1348-4144-a496-8751d12e84bf] Live Migration failure: operation failed: Failed to connect to remote libvirt URI qemu+tcp://compute2/system: Unable to resolve address 'compute2' service '16509': Name or service not known: libvirtError: operation failed: Failed to connect to remote libvirt URI qemu+tcp://compute2/system: Unable to resolve address 'compute2' service '16509': Name or service not known
由日志可以看出，问题出现在libvirt上，那么修改一下libvirt的配置。
libvirt配置参考OpenStack虚拟机冷迁移与热迁移、虚拟机在 OpenStack 里没有共享存储条件下的在线迁移、虚拟化之KVM virsh常用命令篇，对libvirt的配置进行修改。
1、查看libvirtd.confvim /etc/kolla/nova-libvirt/libvirtd.conf修改配置如下：
listen_tcp = 1listen_tls = 0auth_tcp = "none"ca_file = ""log_level = 3log_outputs = "3:file:/var/log/kolla/libvirt/libvirtd.log"listen_addr = "0.0.0.0"

2、重启libvirt服务
docker stop nova_libvirtdocker start nova_libvirt

3、查看libvirt服务netstat -anpt | grep libvirt看到libvirtd监听在0.0.0.0:16509端口即为正常。
PS：可以在其他节点使用virsh命令测试连通性virsh -c qemu+tcp://compute2/system
第三次迁移1、在控制节点执行迁移命令nova live-migration --block-migrate 180617ec-1348-4144-a496-8751d12e84bf compute2
2、查看实例详情openstack server show demo1迁移成功了，nice。
其他命令1、查看迁移任务nova server-migration-list 180617ec-1348-4144-a496-8751d12e84bf该命令查看到迁移任务的ID，然后根据这个ID就可以看到更详细的迁移过程。
2、查看迁移过程nova server-migration-show 180617ec-1348-4144-a496-8751d12e84bf 2
3、查看警告或者出错日志grep WARNING.*180617ec-1348-4144-a496-8751d12e84bf /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log
4、取消迁移nova live-migration-abort 180617ec-1348-4144-a496-8751d12e84bf 2
后记以上，实现了OpenStack虚拟机的block live migration。后续实验，不妨再研究下共享存储的live migration。
书签OpenStack命令行操作之虚机管理实现
虚拟机迁移之热迁移(live_migrate)源码解读
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机在线迁移过程中的故障注入</title>
    <url>/dev-openstack-vm-live-migration-fault-injection/</url>
    <content><![CDATA[前言《虚拟机在线迁移的性能统计》一文中，已经找到了虚拟机迁移过程中性能统计的方法，可以统计出迁移时间、停机时间、迁移数据量等指标。
而实际生产环境是复杂的，所以我们想模拟一些环境，看看这些环境（故障）对于虚拟机迁移性能的影响。本文就来研究一下CPU故障、内存故障、磁盘故障、网络故障等的模拟方法。


故障注入本次故障注入主要有CPU故障、内存故障、磁盘故障、网络故障。请教了卢澄志同学，对于CPU故障、内存故障、磁盘故障的模拟，使用stress或者stress-ng，参考Linux 压力测试软件 Stress 使用指南和stress-ng：模拟特定的cpu百分比；对于网络故障的模拟，使用netem，参考使用 tc netem 模拟网络异常和netem wiki。
故障注入有两个大的思路：一个是注入到被迁移的虚拟机，另一个是注入到宿主机。
stress1、安装stress-ngapt-get install stress-ng
2、产生3个CPU进程1分钟后关闭stress-ng --cpu 3 --verbose --timeout 1m
3、产生2个10MB的内存进程1分钟后关闭stress-ng --vm 2 --vm-bytes 10M --vm-keep --timeout 1m
4、产生3个IO进程1分钟后关闭stress-ng --io 3 --timeout 1m
netem在Ubuntu16中，tc netem不需要安装，系统自带。
1、模拟延迟传输tc qdisc add dev eth0 root netem delay 100ms报文延迟 100ms 发送。
tc qdisc replace dev eth0 root netem delay 100ms 20ms报文延迟的时间在 100ms ± 20ms 之间，具体值随机选择。
2、模拟丢包率tc qdisc change dev eth0 root netem loss 0.3% 25%丢包率是 0.3%，并且当前报文丢弃的可能性和前一个报文 25% 相关。
3、模拟包重复tc qdisc change dev eth0 root netem duplicate 50%随机产生 50% 重复的包。
4、模拟包损坏tc qdisc add dev eth0 root netem corrupt 2%随机产生 2% 损坏的报文（在报文的随机位置造成一个比特的错误）。
5、模拟包乱序tc qdisc change dev eth0 root netem reorder 50% gap 3 delay 100ms固定的每隔一定数量的报文就乱序一次：每5个报文会正常发送，其他的报文延迟 100ms。
要想看到 ping 报文的乱序，我们要保证发送报文的间隔小于报文的延迟时间 100ms，这里用 -i 0.05 把发送间隔设置为 50ms。
tc qdisc change dev eth0 root netem reorder 50% 15% delay 300ms使用概率来选择乱序的报文：50% 的报文会正常发送，其他报文（1-50%）延迟 300ms 发送。
6、取消模拟tc qdisc del dev eth0 root
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>测试</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack中共享存储的虚拟机在线迁移</title>
    <url>/dev-openstack-vm-live-migration/</url>
    <content><![CDATA[前言《OpenStack中虚拟机的在线迁移》一文中，虚拟机迁移时，把block一起进行了迁移。生产环境中，这些虚拟机往往是共享存储设备，不需要对block进行迁移。所以，本文就来重新配置一下环境，实现共享存储的虚拟机在线迁移。


原理常规安装的OpenStack中，实例存放在 /var/lib/nova/instances/ 目录；使用kolla安装的OpenStack中，实例存放在 /var/lib/docker/volumes/nova_compute/_data/instances/ 目录。
共享存储，需要两个步骤：1、有一台NFS（Network File System）服务器，共享某个目录，比如/nfs/share/instances。2、所有计算节点的instances目录，都挂载上NFS服务器的/nfs/share/instances目录。
主机准备使用virtualbox创建一个新的ubuntu16虚拟机，或者clone其他节点并且通过快照恢复初始状态，作为nfs存储节点。这里通过clone的方法得到一个新的主机，设置IP为192.168.56.130。参考《VirtualBox中Ubuntu扩容》，对虚拟机进行扩容。
NFSNFS服务器首先，我们要搭建一个NFS服务器，参考Ubuntu 16.04系统上NFS的安装与使用和使用NFS实现Ubuntu的文件共享。
1、安装nfs软件包apt install nfs-kernel-server
2、编写配置文件vim /etc/exports添加如下内容：
# openstack instances/nfs/share/instances *(rw,sync,no_root_squash)

3、创建共享目录并修改权限
mkdir -p /nfs/share/instanceschmod o+x /nfs/share/instances

4、重启nfs服务service nfs-kernel-server restart
5、查看共享信息exportfs
控制节点在控制节点删除demo1实例，或者在horizon控制台删除demo1的实例。
计算节点1、安装nfs客户端apt-get install nfs-common
2、查看共享信息showmount -e 192.168.56.130
3、挂载nfs目录
mount -t nfs 192.168.56.130:/nfs/share/instances /var/lib/docker/volumes/nova_compute/_data/instances/

instances目录中还有文件和文件夹，直接挂载覆盖确定没有影响吗？没有。
两个计算节点都执行同样的操作，此时它们的instances目录是同一个目录。
4、修改instances目录权限chmod -R 777 /var/lib/docker/volumes/nova_compute/_data/instances/一定要修改，否则创建实例时会报错。
5、自动挂载vim /etc/fstab，添加：
192.168.56.130:/nfs/share/instances /var/lib/docker/volumes/nova_compute/_data/instances nfs default 0 0
自动挂载有可能会失败，所以在计算节点重启后，最好先检查一下有没有挂载成功。没有挂载成功的话，就手动进行挂载。
6、重启compute服务和libvirt服务
docker stop nova_computedocker start nova_computedocker stop nova_libvirtdocker start nova_libvirt

如果不重启，那么创建的实例会存放在计算节点本地磁盘上，卸载instances目录后可以看到。
迁移创建实例参考《Kolla安装OpenStack多节点》的初始化配置部分，使用cirros镜像创建demo2实例。
1、使管理员环境生效source /etc/kolla/admin-openrc.sh
2、创建实例
openstack server create \    --image cirros \    --flavor m1.tiny \    --key-name mykey \    --nic net-id=25e6c0ef-6a0a-481c-a08a-46f7ef67ad3e \    demo2

3、分配浮动IP
openstack network listopenstack floating listopenstack floating ip create public1openstack server add floating ip demo2 10.0.2.156

3、查看实例计算节点上，在/var/lib/docker/volumes/nova_compute/_data/instances目录中，可以看到新创建的实例。
迁移实验1、查看实例列表nova list
2、查看实例信息nova show demo2可以看到demo2位于compute节点。
3、实例迁移nova live-migration demo2 compute2
4、再次查看实例信息nova show demo2可以看到demo2迁移到了compute2节点，迁移成功，nice。
书签DAS、NAS、SAN三种存储架构比较及应用分析
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>ORA-01033</title>
    <url>/dev-ora-01033/</url>
    <content><![CDATA[转载自百度百科
1、进入CMD，执行set ORACLE_SID=ORCL，确保连接到正确的SID；2、命令窗口运行sqlplus “/as sysdba” 启动窗口之后显示如下信息
SQL*Plus: Release 11.1.0.7.0 - Production on 星期三 3月 6 17:17:53 2013Copyright (c) 1982, 2008, Oracle. All rights reserved.
连接到:Oracle Database 11g Enterprise Edition Release 11.1.0.7.0 - ProductionWith the Partitioning, OLAP, Data Mining and Real Application Testing optionsSQL&gt;3、停止服务 shutdown immediateSQL&gt; shutdown immediateORA-01109: 数据库未打开

已经卸载数据库。ORACLE 例程已经关闭。4、 启动服务 startup 观察启动时有无数据文件加载报错，并记住出错数据文件标号SQL&gt; startupORACLE 例程已经启动。Total System Global Area 535662592 bytesFixed Size 1348508 bytesVariable Size 272632932 bytesDatabase Buffers 255852544 bytesRedo Buffers 5828608 bytes数据库装载完毕。ORA-16038: 日志 2 sequence# 59 无法归档ORA-19809: 超出了恢复文件数的限制ORA-00312: 联机日志 2 线程 1: ‘D:\APP\EN\ORADATA\ORCL\REDO02.LOG’
5、检查出错日志所在的组SQL&gt; select group#,sequence#,archived,status from v$log;GROUP# SEQUENCE# ARC STATUS

1 61 NO CURRENT3 60 NO INACTIVE2 59 NO INACTIVE6、修复出错的组日志信息SQL&gt; alter database clear unarchived logfile group 2;数据库已更改。7、打开数据库SQL&gt; alter database open;数据库已更改。SQL&gt;
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——基本命令</title>
    <url>/dev-oracle-experiment-base-command/</url>
    <content><![CDATA[1、显示员工信息表emp的内容select * from emp;
2、将sql命令存入emp.sql文件save d:\emp.sql
3、清空缓存区del
4、调入emp.sql文件get d:\emp.sql
5、再次执行同样的sql命令@ d:\emp.sql或者start d:\emp.sql


6、利用替换变量接受雇员的姓名select * from emp where ename=&amp;cont_name;
7、利用替换变量接受雇员的雇佣日期（格式：03-12月-81）select * from emp where hiredate=&#39;&amp;d&#39;;
8、定义替换变量，在sql语句里使用该替换变量，使用完后将该变量删除define salary=1800;select * from emp where sal&gt;&amp;salary;undefine salary
9、将查询结果假脱机输出到文件d:\spool_temp.txt中spool d:\spool_temp.txtselect * from emp;select * from dept;spool off
10、为列deptno设置标题为“部门代码”column deptno heading &#39;部门代码&#39;select * from emp;
11、为sal列定制格式。要求在每个值前加$符号作为前缀，并保留一个小数位column sal format $99,999.0select * from emp;
12、用“/”替换所有空值column comm null &#39;/&#39;select * from emp;
13、显示所有列的当前设置column
14、清除所有列的设置clear column
15、限制重复行select * from emp;select * from emp order by deptno;
可能有许多雇员属于同一个部门，因此在DepartmentID列将有重复值出现break on deptno;select * from emp order by deptno;
显示break的设置break
清除break的设置clear break
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——创建和管理表空间</title>
    <url>/dev-oracle-experiment-create-and-manage-table-space/</url>
    <content><![CDATA[创建临时表空间create temporary tablespace user_temp  tempfile 'D:\oracle\oradata\user_temp.dbf' size 10m  autoextend on  next 5m maxsize 50m  extent management local;

PS：临时表空间主要用于存储用户在执行order by等语句进行排序或汇总时产生的临时数据，它是所有用户公有的。默认情况下，所有用户都使用temp作为临时表空间。但是也允许使用其他表空间作为临时表空间，这需要在创建用户时进行指定。


创建数据表空间创建数据表空间 user_data
create tablespace user_data  datafile 'D:\oracle\oradata\user_data.dbf' logging size 10m  autoextend on  next 5m maxsize 50m  extent management local;

创建用户并指定表空间创建用户 voidking，密码为 voidking，指定表空间为user_data 
create user voidking identified by voidkingdefault tablespace user_data  temporary tablespace user_temp; ``` ### 修改用户的默认表空间修改用户 voidking 的默认表空间为 user_data`alter user voidking default tablespace user_data;`### 给用户授予权限给 voidking 用户授权`grant connect,resource,dba to voidking;`### 重命名表空间重命名表空间 user_data 为 new_user_data`alter tablespace user_data rename to new_user_data;`### 增加新的数据文件在 user_data 表空间下新增数据文件
alter tablespace user_dataadd datafile ‘D:\oracle\oradata\user_data2.dbf’size 2mautoextend onnext 1mmaxsize unlimited;
### 删除表空间的数据文件删除 user_data 表空间下的数据文件`alter tablespace user_data drop datafile 'D:\oracle\oradata\user_data2.dbf';`### 设置数据文件的状态数据文件主要有三种状态：online、offline、offline drop。`alter database datafile 'D:\oracle\oradata\user_data.dbf' online;`### 删除表空间
//删除表空间drop tablespace user_data including contents and datafiles;//无法删除，表空间被占用drop tablespace user_temp including contents and datafiles;//查看user_temp是不是某些用户的默认临时表空间select username,temporary_tablespace from dba_users;alter user voidking temporary tablespace user_temp2;alter database default temporary tablespace user_temp2;//成功删除drop tablespace user_temp including contents and datafiles;
### 设置默认表空间
//设置默认临时表空间alter database default temporary tablespace user_temp;
//设置默认永久表空间alter database default tablespace user_data;
### 查看表空间1、查看表空间的名称和大小
SELECT t.tablespace_name, round(SUM(bytes / (1024 * 1024)), 0) ts_sizeFROM dba_tablespaces t, dba_data_files dWHERE t.tablespace_name = d.tablespace_nameGROUP BY t.tablespace_name; 
// or
select tablespace_name ,sum(bytes) / 1024 / 1024 as MB　from dba_data_filesgroup by tablespace_name;
2、查看表空间物理文件的名称及大小
SELECT tablespace_name,file_id,file_name,round(bytes / (1024 * 1024), 0) total_spaceFROM dba_data_filesORDER BY tablespace_name; 
3、查看所有表空间对应的文件
select tablespace_name,file_name from dba_data_files;
4、查看回滚段名称和大小
SELECT segment_name,tablespace_name,r.status,(initial_extent / 1024) initialextent,(next_extent / 1024) nextextent,max_extents,v.curext curextentFROM dba_rollback_segs r, v$rollstat vWHERE r.segment_id = v.usn(+)ORDER BY segment_name; 
5、查看控制文件
SELECT NAME FROM v$controlfile; 
6、查看日志文件
SELECT MEMBER FROM v$logfile; 
7、查看表空间的使用情况
SELECT SUM(bytes) / (1024 * 1024) AS free_space, tablespace_nameFROM dba_free_spaceGROUP BY tablespace_name;SELECT a.tablespace_name,a.bytes total,b.bytes used,c.bytes free,(b.bytes * 100) / a.bytes “% USED “,(c.bytes * 100) / a.bytes “% FREE “FROM sys.sm$ts_avail a, sys.sm$ts_used b, sys.sm$ts_free cWHERE a.tablespace_name = b.tablespace_nameAND a.tablespace_name = c.tablespace_name; 
8、查看数据库库对象
SELECT owner, object_type, status, COUNT(*) count#FROM all_objectsGROUP BY owner, object_type, status; 
9、查看数据库的版本
SELECT versionFROM product_component_versionWHERE substr(product, 1, 6) = ‘Oracle’; 
10、查看数据库的创建日期和归档方式
SELECT created, log_mode, log_mode FROM v$database; 

### 修改数据文件大小
修改数据文件大小为 20M
`alter database datafile &apos;D:\oracle\oradata\user_data.dbf&apos;  resize 20m;`

### 使用OEM管理表空间
开始，所有程序，Oracle-OraDb11g_home1，Database Control-orcl。使用sys登陆，连接身份sysdba。服务器，存储，表空间。]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——数据的导入和导出</title>
    <url>/dev-oracle-experiment-data-in-and-out/</url>
    <content><![CDATA[以下命令，都是在操作系统命令行中使用。
EXP数据导出1、full方式：导出整个数据库exp system/Admin123 file=d:/test_1.dmp full=y
2、owner方式：导出指定的用户模式exp scott/tiger file=d:/test_2.dmp owner=scott
3、tables方式：导出指定的表exp scott/tiger file=d:/test_3.dmp tables=(emp,dept)

IMP数据导入1、full方式：导入整个数据库imp system/Admin123 file=d:/test_1.dmp full=y
2、owner方式：导入指定的用户模式imp scott/tiger file=d:/test_2.dmp owner=scott
3、tables方式：导入指定的表imp scott/tiger file=d:/test_3.dmp tables=emp,dept
EXPDP数据泵导出数据泵工具导出的步骤1、启动sql plus，以system/manager 登陆conn system/manager as sysdba
2、创建目录对象（Tips：手动在D盘下创建一个temp文件夹）create directory mypump as &#39;D:\temp&#39;;
3、授权grant read,write on directory mypump to scott;
4、在操作系统命令行中，执行导出expdp scott/tiger schemas=scott directory=mypump dumpfile=expdp_test1.dmp;
数据泵导出的各种模式1、tables：指定表模式导出expdp scott/tiger tables=emp,dept directory=mypump dumpfile=expdp_test2.dmp
2、按条件查询导出expdp scott/tiger tables=emp directory=mypump dumpfile=exopdp_test3.dmp query=&#39;&quot;where sal &lt; 2000&quot;&#39;
3、tablespaces：指定要导出表空间列表expdp system/Admin123 directory=mypump dumpfile=expdp_tablespace.dmp tablespaces=users
4、schemas：指定用户模式导出expdp scott/tiger schemas=scott directory=mypump dumpfile=expdp_test1.dmp
5、full：指定整个数据库模式导出expdp system/Admin123 directory=mypump dumpfile=full.dmp full=y
6、使用exclude，include导出数据使用include选项，导出用户中包括指定类型的指定对象导出scott用户下以B开头的所有表expdp scott/tiger directory=mypump dumpfile=include_1.dmp include=table:\&quot;like\&#39;B%\&#39;\&quot;
导出scott用户下的所有存储过程expdp scott/tiger directory=mypump dumpfile=include_2.dmp schemas=scott include=procedure
exclude导出用户中排除指定类型的指定对象导出scott用户下除view类型以外的所有对象expdp scott/tiger directory=mypump dumpfile=exclude_1.dmp schemas=scott exclude=view
IMPDP数据泵导入1、tables：指定表模式导入impdp scott/tiger tables=emp,dept directory=mypump dumpfile=expdp_test2.dmp
2、schemas：指定用户模式导入impdp scott/tiger schemas=scott directory=mypump dumpfile=expdp_test1.dmp
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——数据查询和函数的使用</title>
    <url>/dev-oracle-experiment-data-query-and-function/</url>
    <content><![CDATA[我们使用scott用户的几张表来演示。
查看表结构desc emp;
查询所有列select * from dept;
查询指定列select ename, sal, job, deptno from emp;

取消重复行select distinct deptno, job from emp;
统计行数select count(*) from emp;
条件查询1、查询SMITH所在部门，工作，薪水select deptno,job,sal from emp where ename = &#39;SMITH&#39;;2、查询薪水大于3000的员工信息select * from emp where sal &gt; 3000;
显示每个雇员的年工资select sal*13+nvl(comm, 0)*13 &quot;年薪&quot; , ename, comm from emp;
显示列别名select ename &quot;姓名&quot;, sal*12 as &quot;年收入&quot; from emp;
||select ename || &#39; is a &#39; || job from emp;
like%表示0到多个字符，_表示任意单个字符。1、显示首字符为S的员工姓名和工资？select ename,sal from emp where ename like &#39;S%&#39;;
2、显示第三个字符为大写O的所有员工的姓名和工资select ename,sal from emp where ename like &#39;__O%&#39;;
inselect * from emp where empno in (7844, 7839,123,456);
is nullselect * from emp where mgr is null;
逻辑操作符查询工资高于500或者是岗位为 MANAGER 的雇员，同时还要满足他们的姓名首字母为大写的J。select * from emp where (sal &gt;500 or job = &#39;MANAGER&#39;) and ename like &#39;J%&#39;;
order by1、按照工资的从低到高的顺序显示雇员的信息select * from emp order by sal;2、按照部门号升序而雇员的工资降序排列select * from emp order by deptno,sal desc;3、按年薪排序select ename, (sal+nvl(comm,0))*12 &quot;年薪&quot; from emp order by &quot;年薪&quot; asc;
分组函数1、显示所有员工中的最高工资和最低工资select max(sal),min(sal) from emp;
2、最高工资那个人select ename,sal from emp where sal=(select max(sal) from emp);
3、显示所有员工的平均工资和工资总和select avg(sal),sum(sal) from emp;
4、计算总共有多少员工select count(*) from emp;
group by1、显示每个部门的平均工资和最高工资select avg(sal),max(sal),deptno from emp group by deptno;
2、显示每个部门的每种岗位的平均工资和最低工资select min(sal), avg(sal), deptno, job from emp group by deptno, job;
having显示平均工资低于 2000的部门号和它的平均工资select avg(sal), max(sal), deptno from emp group by deptno having avg(sal) &lt; 2000;
多表查询1、显示雇员名，雇员工资及所在部门的名字select e.ename, e.sal, d.dname from emp e, dept d where e.deptno = d.deptno;
2、显示部门号为 10 的部门名、员工名和工资select d.dname, e.ename, e.sal from emp e, dept d where e.deptno = d.deptno and e.deptno = 10;
3、显示各个员工的姓名，工资及工资的级别select e.ename, e.sal, s.grade from emp e, salgrade s where e.sal between s.losal and s.hisal;
4、显示雇员名，雇员工资及所在部门的名字，并按部门排序select e.ename, e.sal, d.dname from emp e, dept d where e.deptno = d.deptno order by e.deptno;
自连接显示某个员工的上级领导的姓名select worker.ename, boss.ename from emp worker,emp boss where worker.mgr = boss.empno and worker.ename = &#39;FORD&#39;;
单行子查询1、查询出SMITH的部门号select deptno from emp where ename = &#39;SMITH&#39;;
2、显示与SMITH同部门的所有员工select * from emp where deptno = (select deptno from emp where ename = &#39;SMITH&#39;);
多行子查询查询和部门10的工作相同的雇员的名字、岗位、工资、部门号select distinct job from emp where deptno = 10;select * from emp where job in (select distinct job from emp where deptno = 10);
all显示工资比部门 30的所有员工的工资高的员工的姓名、工资和部门号select ename, sal, deptno from emp where sal &gt; all (select sal from emp where deptno = 30);select ename, sal, deptno from emp where sal &gt; (select max(sal) from emp where deptno = 30);
any显示工资比部门30的任意一个员工的工资高的员工姓名、工资和部门号select ename, sal, deptno from emp where sal &gt; any (select sal from emp where deptno = 30);select ename, sal, deptno from emp where sal &gt; (select min(sal) from emp where deptno = 30);
多列子查询查询与 SMITH 的部门和岗位完全相同的所有雇员select deptno, job from emp where ename = &#39;SMITH&#39;;select * from emp where (deptno, job) = (select deptno, job from emp where ename = &#39;SMITH&#39;);
from子句中使用子查询显示高于自己部门平均工资的员工的信息select deptno, avg(sal) mysal from emp group by deptno;
select e.ename, e.deptno, e.sal, ds.mysal from emp e, (select deptno, avg(sal) mysal from emp group by deptno) ds where e.deptno = ds.deptno and e.sal &gt; ds.mysal;
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——数据库的安全性</title>
    <url>/dev-oracle-experiment-database-safety/</url>
    <content><![CDATA[创建数据库表空间（永久表空间）create tablespace test datafile 'D:\oracle\oradata\test.dbf'size 100mautoextend on next 100mmaxsize unlimited;

创建临时表空间create temporary tablespace test_temp tempfile 'D:\oracle\oradata\test_temp.dbf'size 100mautoextend on next 32mmaxsize 1024m;


创建用户create user user1 identified by user1default tablespace test quota 10m  on users account lock;
PS:创建用户时，如果没有指定默认表空间和临时表空间，则该用户将使用系统自带的users表空间作为默认表空间，自带的temp表空间作为临时表空间。
解锁用户alter user user1 account unlock;
授予系统权限grant create session to user1;grant create table to user1;grant unlimited tablespace to user1;
授予对象权限conn scott/tiger;grant select on emp to user1;grant update(ename) on emp to user1;
创建角色Oracle三个标准角色：1、Connect：拥有CONNECT角色的用户，可以与服务器建立连接会话，不可以创建表。2、Resource：RESOURCE角色允许用户创建表、过程、触发器、序列等权限。3、DBA：DBA角色拥有所有的系统权限——包括无限制的空间限额和给其他用户授予各种权限的能力。PS：如果新创建的用户需要登录到OEM，则必须给用户授予select_catalog_role角色后才可以登录，否则只有管理员身份的用户才可以登录到OEM。
conn system/voidkingcreate role myrole;grant create session to myrole;grant create table to myrole;grant myrole to user1;
PS：有些系统权限比较特殊，是不能放到角色中的，如：unlimited tablaspace；这些权限很高、很特殊，必须直接赋予给用户。
回收用户的权限revoke create table from user1;
删除用户drop user user1;drop user user1 cascade;//用户如果有其他对象，加上cascade连同该用户的所有对象一并删除。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——模式对象</title>
    <url>/dev-oracle-experiment-pattern-object/</url>
    <content><![CDATA[表表示数据库中最常用的模式对象，用户的数据在数据库中是以表的形式存储的。表通常由一个或多个列组成，每个列表示一个属性，而表中的一行则表示一条记录。
在创建表时可以为表指定存储空间，如果不指定，Oracle会将该表存储到默认表空间中。根据需要可以将表从一个表空间移动到另一个表空间。create table userbase(username varchar2(16),passwd varchar2(16));alter table userbase move tablespace user_data;
重命名表alter table userbase rename to newuserbase;或者rename userbase to newuserbase;


索引索引是数据库中用于存放表的每一条记录的位置的一种对象，其主要目的是为了加快数据的读取速度和完整性检查。不过，创建索引需要占用许多存储空间，而且在向表中添加和删除记录时，数据库需要花费额外的开销来更新索引。创建索引：create index index_username on userbase(username) tablespace user_data;删除索引：drop index index_username;创建唯一索引：create unique index unique_index_username on userbase(username) tablespace user_data;创建组合索引：create index complex_index_username on userbase(username,passwd) tablespace user_data;创建反向键索引：create index reverse_index_username on userbase(username) reverse tablespace user_data;
视图视图是一个虚拟表，它并不存储真实的数据，它的行和列的数据来自于定义视图的子查询语句中所引用的表，这些表通常也称为视图的基表。视图可以建立在一个或多个表（或其他视图）上，它不占用实际的存储空间，只是在数据字典中保存它的定义信息。
create table userdetail(username varchar2(16),realname varchar2(16));创建视图语法如下：
create or replace view view_user(v_username,v_passwd,v_realname) as select b.username,b.passwd,d.realnamefrom userbase b,userdetail dwhere b.username=d.username;
以上命令如果提示没有创建视图权限，请使用system登陆，执行grant create view to scott;
序列在Oracle中，可以使用序列自动生成一个整数序列，主要用来自动为表中的数据类型的主键列提供有序的唯一值，这样就可以避免在向表中添加数据时，手工指定主键值。序列和表没有关系。
而且使用手工指定主键值这种方式时，由于主键值不允许重复，因此它要求操作人员在指定主键值时自己判断新添加的值是否已经存在，这显然是不可取的。
创建序列语法如下：
create sequence userbase_sequenceminvalue 1maxvalue 1024start with 1increment by 1cache 10;
删除序列：drop sequence userbase_sequence;
添加id列：alter table add id int;
插入数据：insert into userbase values(&#39;voidking&#39;,&#39;voidking&#39;,userbase_sequence.nextval);
同义词Oracle支持为表、索引或视图等模式对象定义别名，也就是为这些对象创建同义词。Oracle中的同义词主要分为如下两类。1、公有同义词：在数据库中所有用户都可以使用。2、私有同义词：由创建它的用户私人拥有。不过，用户可以控制其他用户是否有权使用自己的同义词。
创建同义词语法：create public synonym synonym_userbase for userbase;
权限不够，使用system用户登录，执行grant create synonym to scott;
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——PL/SQL程序设计</title>
    <url>/dev-oracle-experiment-plsql-design/</url>
    <content><![CDATA[PL/SQL块创建一个PL/SQL块，利用替换变量输入职工号，查询该职工的工资，如果工资小于300元，那么把工资更改为加200元。如果没有该员工，则显示“没有该员工！”
select empno from emp;
记住一些empno，方便接下来的输入。
undefine 员工号;declare  v_sal emp.sal%type;begin  select sal into v_sal from emp where empno = &amp;&amp;员工号;  if v_sal &lt; 3000 then  update emp set sal = sal + 200 where empno = &amp;&amp;员工号;  end if;  dbms_output.put_line('工资为：'||v_sal);  exception when no_data_found then    dbms_output.put_line('没有该员工！');end;
运行上述代码，输入一个empno，比如7369，就可以在DBMS输出中看到结果，注意，需要先启用DBMS输出。

使用游标为了处理select语句返回的多行数据，开发人员可以使用显式游标。使用显式游标表哭定义游标、打开游标、提取游标和关闭游标。
1、游标的使用
declare  cursor emp_cursor is select ename,sal from emp where deptno=10;  v_ename emp.ename%type;  v_sal emp.sal%type;begin  open emp_cursor;  loop    fetch emp_cursor into v_ename,v_sal;    exit when emp_cursor%notfound;    dbms_output.put_line('姓名：'||v_ename||'，工资：'||v_sal);  end loop;  close emp_cursor;end;

2、在游标中，使用fetch…bulk collect into语句提取所有数据
declare  cursor emp_cursor is    select ename from emp where deptno=10;  type ename_table_type is table of emp.ename%type;  ename_table ename_table_type;begin  open emp_cursor;  fetch emp_cursor bulk collect into ename_table;  for i in 1..ename_table.count loop    dbms_output.put_line(ename_table(i));  end loop;  close emp_cursor;end;

3、使用游标属性
declare   cursor emp_cursor is    select ename from emp where deptno=10;  type ename_table_type is table of emp.ename%type;  ename_table ename_table_type;begin  if not emp_cursor%isopen then    open emp_cursor;  end if;  fetch emp_cursor bulk collect into ename_table;  dbms_output.put_line('提取的总行数：'||emp_cursor%rowcount);  close emp_cursor;end;
4、基于游标定义记录变量5、带参数的游标6、使用游标更新数据7、使用游标删除数据8、使用游标for循环9、若类型REF游标10、强类型REF游标
小结PL/SQL程序设计有什么用处？不知道。只是感觉很复杂，也没有学习的欲望，等到确实有需求了再来学习吧！
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——利用SQL命令创建表</title>
    <url>/dev-oracle-experiment-sql-commond-create-table/</url>
    <content><![CDATA[创建表create table userbase(username varchar2(8),passwd varchar2(16));
插入一行insert into userbase values(&#39;voidking&#39;,&#39;voidking&#39;);
查看数据select * from userbase;


修改表1、追加新的列alter table userbase add(realname varchar2(8));
2、修改现有的列、为新追加的列定义默认值alter table userbase modify(realname varchar2(8) default &#39;haojin&#39;);insert into userbase(username, passwd) values(&#39;voidking&#39;,&#39;voidking&#39;);select * from userbase;
3、删除一个列alter table userbase drop column realname;
4、禁用列alter table userbase set unused column passwd;
5、重命名列alter table userbase rename column username to name;
清空表truncate table userbase;
删除表drop table userbase;
添加注释comment on table userbase is &#39;这张表用来测试&#39;;
定义和管理数据完整性约束1、非空约束create table userbase(username varchar2(8) not null,passwd varchar2(16));
2、主键约束create table userbase(username varchar2(8) primary key,passwd varchar2(16));alter table userbase add constraint primary_key primary key(username);
3、唯一性约束create table userbase(username varchar2(8) primary key not null ,passwd varchar2(16) unique);alter table userbase add constraint unique_value unique(passwd);
4、外键约束create table userdetail(username varchar2(8) primary key not null ,realname varchar2(8));alter table userbase add constraint fk_username foreign key(username) references userdetail(username);
insert into userdetail values(&#39;voidking&#39;,&#39;haojin&#39;);insert into userbase values(&#39;voidking&#39;,&#39;voidking&#39;);
delete from userbase where username=&#39;voidking&#39;;//不会删除userdetail的内容delete from userdetail where username=&#39;voidking&#39;;//约束限制，无法删除
alter table userbase add constraint fk_username foreign key(username) references userdetail(username) on delete cascade;delete from userbase where username=&#39;voidking&#39;;//不会删除userdetail的内容delete from userdetail where username=&#39;voidking&#39;;//userdetail和userbase里的内容都被删除了
5、检查约束alter table userdetail add(sex varchar(4) default &#39;男&#39; check(sex=&#39;男&#39; or sex=&#39;女&#39;));alter table userdetail add(sex varchar(4));alter table userdetail modify(sex check(sex=&#39;男&#39; or sex=&#39;女&#39;));
6、禁用和激活约束insert into userbase values(&#39;test&#39;,&#39;voidking&#39;);//执行失败alter table userbase disable constraint fk_username;insert into userbase values(&#39;test&#39;,&#39;voidking&#39;);//执行成功alter table userbase enable constraint fk_username;
7、删除约束alter table userdetail drop primary key;//删除失败alter table userdetail drop primary key cascade;//删除成功，同时删除了fk_usernamealter table userbase disable constraint fk_username;
8、查看约束信息select constraint_name,constraint_type,status,validated from user_constraints where table_name=&#39;USERBASE&#39;;select * from user_cons_columns where table_name=&#39;USERBASE&#39;;
在sqldeveloper中创建表开始，所有程序，Oracle-OraDb11g_home1，应用程序开发，SQL Developer。
在OEM中创建表开始，所有程序，Oracle-OraDb11g_home1，Database Control-orcl。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——存储过程和函数</title>
    <url>/dev-oracle-experiment-store-procedure-and-function/</url>
    <content><![CDATA[创建、编译并运行PL/SQL存储过程在SQL Developer中，创建、编译并运行PL/SQL存储过程1、右击过程，创建过程2、输入过程名“emp_list”3、添加参数



Name
Type
Mode
Default Value



v_empno
VARCHAR2
IN



v_ename
VARCHAR2
OUT



4、显示指定参数的过程的框架
CREATE OR REPLACEPROCEDURE EMP_LIST( v_empno IN VARCHAR2, v_ename OUT VARCHAR2) ASBEGIN  NULL;END EMP_LIST;
5、替换NULL为：
select ename into v_ename from emp where empno = v_empno;
单击工具栏的save按钮，编译PL/SQL子程序。
6、运行PL/SQL过程单击编译图标，过程成功编译。右击emp_list，选择运行。该操作将调用“运行PL/SQL”对话框。运行PL/SQL对话框允许选择要运行的目标过程或函数（对程序包有用），并显示所选目标的参数列表。PL/SQL块文本区域中包含的SQL Developer用来调用所选程序的生成代码。使用该区域填充要传送到程序单元的参数及处理复杂的返回类型。将 “V_EMPNO:=NULL;”更改为“V_EMPNO:=7369;”，然后单击确定。可以看到运行日志：
连接到数据库 scott。V_ENAME = SMITH进程已退出。从数据库 scott 断开连接。

无参数的存储过程创建一个存储过程，使用游标实现，每输出dept表的一条记录（deptno、dname、loc）后，诉后输出该部门的员工记录（empno、ename、sal）。
create or replace procedure query_dept_emp is  type sp_emp_cursor is ref cursor;  test_cursor1 sp_emp_cursor;  test_cursor2 sp_emp_cursor;  v_deptno dept.Deptno%type;  v_dname dept.dname%type;  v_loc dept.loc%type;  v_empno emp.empno%type;  v_ename emp.ename%type;  v_sal emp.sal%type;begin  open test_cursor1 for select deptno,dname,loc from dept;  loop    fetch test_cursor1 into v_deptno, v_dname, v_loc;    exit when test_cursor1%notfound;    dbms_output.put_line('部门编号：'||v_deptno||'部门名称：'||v_dname||'部门位置：'|| v_loc);    dbms_output.put_line('-----------------------------------------------');    open test_cursor2 for select empno,ename,sal from emp where deptno = v_deptno;    loop      fetch test_cursor2 into v_empno, v_ename, v_sal;      exit when test_cursor2%notfound;      dbms_output.put_line(v_empno||'          '|| v_ename||'         '|| v_sal);    end loop;  end loop;  close test_cursor1;  close test_cursor2;end;exec query_dept_emp;

带in参数的存储过程创建一个PL/SQL块，根据输入的部门编号，用游标实现逐条输出emp表中该部门每位员工的编号（empno）、姓名（ename）和工资（sal）信息。
create or replace procedure query_by_deptno(v_deptno in emp.Deptno%type) is  type sp_emp_cursor is ref cursor;  test_cursor sp_emp_cursor;  v_empno emp.empno%type;  v_ename emp.ename%type;  v_sal emp.sal%type;begin  open test_cursor for select empno,ename,sal from emp where deptno = v_deptno;  dbms_output.put_line('员工编号    姓名    工资');  loop    fetch test_cursor into v_empno, v_ename, v_sal;    exit when test_cursor%notfound;    dbms_output.put_line(v_empno||'    '|| v_ename||'    '|| v_sal);  end loop;  close test_cursor;end;exec query_by_deptno(10);
带输入in、输出out参数的存储过程查询emp中给定职工号的姓名、工资和佣金。
create or replaceprocedure query_emp  (v_emp_no in emp.empno%type,   v_emp_name out emp.ename%type,  v_emp_sal out emp.sal%type,  v_emp_comm out emp.comm%type  )is  begin    select ename,sal,comm    into v_emp_name, v_emp_sal, v_emp_comm    from emp     where empno = v_emp_no;end query_emp;variable emp_name varchar2(15);variable emp_sal number;variable emp_comm number;execute query_emp(7369,:emp_name,:emp_sal,:emp_comm);print emp_name;
使用隐式游标SQL%NOTFOUND的存储过程解雇给定职工号的职工。如果职工号7654的职工不存在则出错。为了避免出错可使用隐式游标SQL%NOTFOUND语句。
create or replace procedure fire_emp(v_emp_no in emp.empno%type)isbegin  delete from emp where empno = v_emp_no;  if sql%notfound then    dbms_output.put_line('雇员号为：'||v_emp_no||'的员工不存在！');  else     dbms_output.put_line('已删除雇员号为：'|| v_emp_no || '的员工。');  end if;end fire_emp;execute fire_emp(7654);

自定义函数用Function查询出EMP中给定职工号的工资。
create or replace function get_sal  (v_emp_no in emp.empno%type)  return number is   v_emp_sal emp.sal%type:=0;begin  select sal into v_emp_sal  from emp where empno = v_emp_no;  return (v_emp_sal);end get_sal;variable emp_sal number;execute:emp_sal:=get_sal('7900');print emp_sal;
小结这个实验肯定是和PL/SQL程序设计一伙的！感觉在专业中基本用不到。本篇是Oracle实验记录的的最后一篇，书上还有一些内容，什么分区表的创建和使用、使用RMAN工具、闪回技术等等，需要时再去学习。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle实验记录——登陆解锁</title>
    <url>/dev-oralce-experiment-login-unlock/</url>
    <content><![CDATA[1、使用SYSTEM登陆SQL Plus
2、通过数据字典dba_users，查看Oracle账户的锁定状态select username,account_status from dba_users;
3、为scott账户解锁alter user scott account unlock;
4、为scott账户设置口令alter user scott identified by tiger;
5、查看现在scott的状态select username,account_status from dba_users where username=&#39;SCOTT&#39;;
6、在SQL Plus中使用scott账户连接数据库conn scott/tiger;
7、显示当前用户show user;
8、查看表信息select empno,ename,job,sal from emp where sal&lt;2500;
9、列出缓冲区内容list或者l
10、编辑当前行change /epno/empno

11、运行当前命令run或者/
12、增加一行inputorder by sal
13、在一行上增加内容append  desc注意，两个单词之间有两个空格
14、删除一行del
15、用系统编辑器编辑命令edit
16、保存命令（sql文件）save d:\hello.sql
17、运行命令（sql文件）start d:\hello.sql或者@ d:\hello.sql
18、清空缓冲区clear buffer
19、列出表结构desc emp
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>开源中国团队协作开发平台</title>
    <url>/dev-oschina-teamwork/</url>
    <content><![CDATA[前言在公司时，使用wiki来写文档，使用jira来记录工作进度和bug，非常方便。马上要进行项目管理，本来打算自己搭建wiki和jira系统，后来想到开源中国有一个团队协作开发平台。试用了一下，基本满足要求，nice。


写文档本平台内置markdown编辑器，建议学习一下markdown写法。
普通文档1、点击左侧导航栏的“文档”，然后点击“新文档”。
2、输入文档信息。
3、之后点击文档名，进入编辑页面。
4、编辑完成，可以进行预览。
接口文档接口文档，在普通文档的基础上，规定结构如下：
下面是一个示例：http://doc.oschina.net/interfacedemo
PS：接口文档后端负责编写。后端在开发前，先写好接口文档，然后把文档地址发到讨论组里，前端就可以自己模拟数据独立进行开发。后端在开发好接口之后，自己使用HttpRequester测试一下，确保接口没有问题，然后在讨论组里声明哪些接口已经可以使用。
渲染文档thinkphp框架的前后端分离做的不彻底，默认架构为后端路由+后端渲染+后端接口，适合全栈开发者使用。理想的前后端分离框架，应该是由前端来负责路由控制和前端渲染，后端专注于接口，也就是前端路由+前端渲染+后端接口。
因为thinkphp框架中的路由控制由后端来控制，页面渲染也属于后端渲染，所以页面渲染的工作理论上应该归属于后端开发者。但是，后端开发者负责页面渲染的话，前后端就混到了一起，加大了开发的复杂度。
相较而言，让前端开发者负责页面渲染的更好一些。那么，前端开发者就需要拿到页面地址，以及用来页面渲染的数据。页面地址和页面渲染数据需要后端提供，因此需要一个文档来说明。
更多关于前后端渲染的内容，请参考《JavaScript模板引擎》。
规定渲染文档结构如下：
下面是一个示例：http://doc.oschina.net/interfacedemo2
PS：渲染文档同样由后端负责编写。后端渲染虽然不便于前后端分离，但是也有好处。因为后端渲染的话，页面加载的速度会更快些。如果变更架构为前端渲染+后端路由+后端接口，也很简单，只要在前端加一个模板引擎即可。
记录工作进度新建任务1、每次开发前，点击左侧导航栏的“任务”，然后点击“新建任务”。
2、选择项目，标题输入当天的任务（或一段时间的任务），任务标签选择功能（feature），指派成员选自己，选择开始时间和结束时间，其他可选。
3、点击确认创建。
关闭任务当任务完成后，变更任务状态为已完成或验收通过。
生成周报每周日，点击左侧导航栏的“周报”，然后点击“提交周报”，自动生成周报。
记录bug和记录工作进度类似，只不过任务标签选择缺陷（bug），指派成员选择模块的开发者。并且，在任务描述中添加一些bug的描述信息。
代码托管获取项目git clone https://git.oschina.net/voidking/volunteer.git

上传项目git pullgit add .git commit -m "message"git push

后记有任何问题，或者好的建议，都可以提出来，希望大家在这个团体中共同进步，成为更加牛逼的自己。
书签卓音工作室—Team@OSC团队协作开发平台https://team.oschina.net/pandazhuoyin
码云平台帮助文档_V1.2http://git.mydoc.io/?t=84110
码云 - 开源中国http://git.oschina.net/
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>jira</tag>
        <tag>wiki</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>外包平台</title>
    <url>/dev-outsourcing-platform/</url>
    <content><![CDATA[前言计划10号离职，12号前往吉林长春。无论是出于自尊心，还是出于一个男人的责任，都不打算再向家里要钱。没有了收入来源，那就开源！想来想去，外包也许是最好的选择。从知乎上摘录了一些外包平台，备忘。


平台1、程序员客栈程序员客栈-程序员的经纪人|网站建设APP开发制作远程技术中心https://www.proginn.com/
2、快码众包快码众包-让互联网产品开发更快速！认准域名Kuai.mahttp://www.kuai.ma/
3、Coding码市Coding 码市 - 云端众包，可靠交付，远程工作，全程担保！https://mart.coding.net/
4、猿团猿团-YuanTuan.Com_成为创业者的专业技术合伙人http://www.yuantuan.com/
5、英选英选 | 从0到1，打造你的第一版产品https://www.linktion.cn/
6、开源中国众包平台开源中国众包平台 - 专业IT软件众包平台，快速交付，安全可靠-开源中国众包平台https://zb.oschina.net/
7、码易码易-高质量软件交付服务平台http://www.mayigeek.com/
8、小圆桌首页 - 创业与人才的社区|小圆桌http://www.xyuanzhuo.com/
9、项目软件交易网软件项目交易网－中国最早的软件外包服务平台，专注实现中国程序员价值http://www.sxsoft.com/
10、人人开发人人开发 - 集可视化开发，应用市场，威客众包，PaaS云于一体的企业级应用服务平台http://rrkf.com/
11、极客邦极客邦 专注提供技术服务的在线平台http://www.looip.cn/
12、开发邦开发邦-专业互联网软件开发与咨询服务http://www.kaifabang.com/
书签国内有类似Freelancer的网站？https://www.zhihu.com/question/26478092
]]></content>
      <categories>
        <category>专业</category>
      </categories>
  </entry>
  <entry>
    <title>网页标签添加图标</title>
    <url>/dev-page-label-add-icon/</url>
    <content><![CDATA[前言这个标题是啥意思？如下图，每个网站都有自己的标签图标：

制作图标图标，值得你花费时间用心选择、设计。每当你看到那个蓝色的脚印，都会想起百度！我们难以超越百度，但是，我们也能拥有自己的“品牌”，哪怕没人知道，也很爽，不是吗？
在线生成百度在线favicon生成，你会找到很多在线制作favicon图标的网站。上传一张图片，就可以自动生成你想要的favicon.ico图标，下载即可。
软件生成制作favicon的软件有很多，这里推荐一款魔法ICO v2.00。
使用方法假设我们已经得到了favicon图标，这时，应该怎样使用它呢？
把favicon.ico上传到服务器放在网站根目录下，然后在首页文件中段插入：
&lt;link rel="shortcut icon" href="favicon.ico"&gt;&lt;link rel="Bookmark" href="favicon.ico"&gt;

第一句用来正常显示图标，第二句用来添加书签时显示图标。

如果你希望出现动画效果的favicon图标，那就上传animated_favicon1.gif（动画图标）并且添加如下的HTML标签：
&lt;link rel="shortcut icon" href="favicon.ico" &gt;&lt;link rel="icon" href="animated_favicon1.gif" type="image/gif" &gt;
小结整个过程还是很简单，记录一下，希望对不熟悉的小伙伴有点帮助。
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP接收ajax的json数组</title>
    <url>/dev-php-ajax-json-array/</url>
    <content><![CDATA[前言前端和PHP端（服务器）通过ajax进行数据交互时，数据格式一般为字符串、数组、json、json数组。下面，我们针对这四种数据格式，进行前端和PHP端模拟交互，寻找一些规律和结论。


前端var data = &#123;    product_name: '毛巾',    product_arr: ['毛巾','肥皂'],    product_json: &#123;        product_name: '毛巾',        product_num: '5',        product_unit: '条'    &#125;,    product_json_arr: [&#123;        product_name: '毛巾',        product_num: '5',        product_unit: '条'    &#125;,&#123;        product_name: '肥皂',        product_num: '10',        product_unit: '块'    &#125;]&#125;console.log(data);$.ajax(&#123;    url: '/',    type: 'POST',    dataType: 'json',    data: data,    success: function(data)&#123;        console.log(data);    &#125;,    error: function(xhr)&#123;        console.log(xhr);    &#125;&#125;);

PHP端接收字符串$product_name = $_POST['product_name'];echo json_encode($product_name,JSON_UNESCAPED_UNICODE);
由结果看出，PHP端获取到了product_name。
接收数组$product_arr = $_POST['product_arr'];echo json_encode($product_arr,JSON_UNESCAPED_UNICODE);
由结果看出，PHP端获取到了product_arr。
$product_arr = $_POST['product_arr'];echo json_encode($product_arr[0],JSON_UNESCAPED_UNICODE);
由结果看出，PHP端拿到的确实是数组。
接收json$product_json = $_POST['product_json'];echo json_encode($product_json,JSON_UNESCAPED_UNICODE);
由结果看出，PHP获取到了product_json。
$product_json = $_POST['product_json'];echo json_encode($product_json-&gt;product_name,JSON_UNESCAPED_UNICODE);
根据返回结果，猜测PHP端拿到的json数据是字符串。
$product_json = json_decode($_POST['product_json']);echo json_encode($product_json-&gt;product_name,JSON_UNESCAPED_UNICODE);
根据返回结果，证明PHP端拿到的json数据不是字符串。因为json字符串通过json_decode函数是可以转换成json格式数据的，而此处的json数据转换失败。
后端已经没有办法再变化，我们调整前端数据格式，把json数据先转化成字符串再传输。
var data = &#123;    product_json: JSON.stringify(&#123;        product_name: '毛巾',        product_num: '5',        product_unit: '条'    &#125;)&#125;
根据返回结果，证明前端json数据必须先转换成字符串，然后PHP端可以获取json字符串，接着正常处理即可。
json数组$product_json_arr = $_POST['product_json_arr'];  echo json_encode($product_json_arr,JSON_UNESCAPED_UNICODE);
由结果看出，PHP端拿到了product_json_arr。
$product_json_arr = $_POST['product_json_arr'];  echo json_encode($product_json_arr[0],JSON_UNESCAPED_UNICODE);
由结果看出，PHP端拿到的确实是数组。
$product_json_arr = $_POST['product_json_arr']; echo json_encode($product_json_arr[0]-&gt;product_name,JSON_UNESCAPED_UNICODE);
由结果看出，PHP端拿到的是数组，但是数组里的并不是json数据。
$product_json_arr = json_decode($_POST['product_json_arr'],true);echo json_encode($product_json_arr[0]-&gt;product_name,JSON_UNESCAPED_UNICODE);
由结果看出，数组里的json数据不是字符串，猜测这里也需要前端先转json字符串。
调整前端数据格式，把json数组数据先转化成字符串再传输。
var data = &#123;    product_json_arr: JSON.stringify([&#123;        product_name: '毛巾',        product_num: '5',        product_unit: '条'    &#125;,&#123;        product_name: '肥皂',        product_num: '10',        product_unit: '块'    &#125;])&#125;

由结果看出，依然不行。
再次修改后端代码：
$product_json_arr = json_decode($_POST['product_json_arr']);echo json_encode($product_json_arr[0]-&gt;product_name,JSON_UNESCAPED_UNICODE);
输出成功，也就是说，问题出在json_decode上面。json_decode($str, true) 可以得到数组，第二参数不加默认为false，得到对象。而json数组出现时，要选择生成对象。
小结通过上面的实验，我们可以得出结论：涉及到json格式的数据，需要在前端先使用JSON.stringify()函数转换为字符串；然后，在PHP端通过json_decode()函数转换为对象。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP调试之Xdebug+PhpStorm</title>
    <url>/dev-php-debug-xdebug/</url>
    <content><![CDATA[前言该怎么强调调试的重要性呢？我们生病的时候，要去看医生，医生会通过各种仪器对我们进行检查，定位病因，然后给我们治疗。程序也会生病，生病的时候，作为医生（开发者）的我们，就要通过各种办法定位bug，然后修改代码。定位bug并且修改代码的过程，就是调试。
最简单直接的调试办法是摘出需要调试的部分，放入 main.php 中，然后运行脚本：php main.php前提是调试环境要安装好php，检查方法：php -v
但是，这种方法并不适合项目的调试，因为项目中涉及到很多上下文，模拟起来会比较麻烦。这时候就需要调试工具出场了。
PHP的调试工具有很多，本文记录一下Xdebug的使用方法。配合使用的集成环境为laragon-1.0，IDE为PhpStorm-2016.2.1。


启用Xdebug1、启动laragon后，任务栏右键laragon图标，定位到PHP，然后单击php.ini。（或者直接到laragon安装目录寻找php.ini，然后打开它）
2、找到[XDebug]，然后修改如下：
[XDebug]zend_extension=php_xdebug.dllxdebug.profiler_append=onxdebug.profiler_enable=onxdebug.profiler_enable_trigger=onxdebug.profiler_output_dir="C:/laragon/tmp/xdebug"xdebug.profiler_output_name="cachegrind.out.%t-%s"xdebug.remote_enable=onxdebug.remote_handler="dbgp"xdebug.remote_host="127.0.0.1"xdebug.remote_port=9000xdebug.trace_output_dir="C:/laragon/tmp/xdebug"xdebug.idekey=PHPSTORM

3、访问http://localhost，查看phpinfo。
4、在网页中Ctrl+F，搜索“xdebug”，如果找到了xdebug的配置信息，则证明xdebug启用成功。
PhpStorm配置1、打开phpstorm，File，Settings。
2、搜索“debug”，可以看到PHP下面的Debug，单击Debug。
3、在xdebug栏，Debug port默认端口为9000，一般不需要修改。同时，三个选项全部打钩。
4、展开Debug，单击DBGp Proxy，填入IDE key为PHPSTORM，Host为localhost，Port为80。单击OK，退出设置。
Debug配置1、View，Toolbar，显示工具栏。
2、View，Tool Windows，Project，显示项目结构。
3、单击工具栏向下的小三角，Edit Configurations。
4、在新打开的Run/Debug Configurations窗口中，单击左上角加号，选择PHP Web Application。
5、右侧Server配置为本地Web服务器。
开始调试1、在PhpStorm中，单击代码左侧插入断点。
2、单击导航栏的电话，然后单击导航栏中的虫子，即可打开默认浏览器进入调试。
3、网页卡住，PhpStorm自动定位到断点处。
4、此时，我们就可以根据PhpStorm提供的按钮进行需要的调试。
XDEBUG_SESSION_START在调试时，郝同学发现一个神奇的问题：假设默认浏览器是chrome，那么在chrome中访问接口，PhpStorm会自动定位到断点处。但是，如果这时使用firefox或postman访问同样的接口，则无法定位到断点处。
解决办法：郝同学注意到，在PhpStorm打开默认浏览器时，url中带有参数，例如：http://www.dsjyw.net/?XDEBUG_SESSION_START=10218
在firefox和postman中的接口地址后也加上XDEBUG_SESSION_START=10218，成功跳转到断点，问题解决。
书签有哪些 PHP 调试技巧？
如何调试PHP程序
Xdebug文档
Xdebug下载地址
php使用Xdebug进行调试
用 Xdebug 修正 PHP 应用程序中的错误
Xdebug 配置
phpstorm+Xdebug断点调试PHP
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>调试</tag>
        <tag>xdebug</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP使用Memcache</title>
    <url>/dev-php-memcache/</url>
    <content><![CDATA[memcache简介Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。Memcached基于一个存储键/值对的hashmap。
memcache有memcache和memcached两种名称，其实memcache是这个项目的名称，而memcached是它服务器端的主程序文件名。
memcached是一种服务器，是内存缓存服务器，就像apache服务器一样。只不过apache是用来提供web服务，而memcached是用来进行内存缓存。那么memcache客户端呢？我们可能用php开发网站，也可能用java或者python，这些相对与服务器来说是客户，都在使用服务器的服务。在php的扩展中加入memcache，就可以调用服务器的服务了，就是可以调用memcached来进行内存缓存了。


下载安装memcached服务端1、下载memcahed，wget http://www.memcached.org/files/memcached-1.5.1.tar.gz
2、解压源码，tar -xvf memcached-1.5.1.tar.gz
3、编译安装，cd memcached-1.5.1，./configure，make &amp;&amp; make install
启动memcached服务端1、memcached的默认目录为/usr/local/bin/memcached
2、启动memcache，memcached -u root -d

-d 选项是启动一个守护进程。
-m 是分配给Memcache使用的内存数量，单位是MB，默认64MB。
-u 是运行Memcache的用户，如果当前为root 的话，需要使用此参数指定用户
-p [num]是设置Memcache的TCP监听的端口，最好是1024以上的端口。
-c 选项是最大运行的并发连接数，默认是1024。
-P [file] 是设置保存Memcache的pid文件。

或者，service memcached start
3、验证安装结果，memcached -h
4、设置开机启动，chkconfig memcached on
5、查看监听端口，yum install lsof，lsof -i tcp:11211
php安装memcache安装libmemcached1、下载wget https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gz
2、解压tar -xvf libmemcached-1.0.18.tar.gz
3、编译安装到/usr/local/libmemcachedcd libmemcached-1.0.18
./configure --prefix=/usr/local/libmemcached
make &amp;&amp; make install
安装memcached的PHP扩展1、下载wget https://pecl.php.net/get/memcached-2.2.0.tgz
2、解压tar -xvf memcached-2.2.0.tgz
3、生成配置文件cd memcached-2.2.0
/usr/local/php/bin/phpize
4、编译安装./configure --enable-memcached --with-php-config=/usr/local/php/bin/php-config --with-libmemcached-dir=/usr/local/libmemcached --disable-memcached-sasl
make &amp;&amp; make install
5、修改php.ini，添加 extension = &quot;memcached.so&quot;
6、验证安装结果，/usr/local/php/bin/php -m | grep memcache，如果出现memcached，则证明安装成功。
7、重启php-fpm，service php-fpm restart
8、访问 http://host_ip/p.php，ctrl+f，查找memcache，如果能找到memcache，则证明成功启动。
测试1、在web目录下，新建mem.php，内容如下：
&lt;?php    $mem = new Memcached;    $mem-&gt;addServer("127.0.0.1", 11211);    $mem-&gt;set('key', 'hello memcache!');    $val = $mem-&gt;get('key');    echo $val;?&gt;

2、访问 http://host_ip/mem.php，即可看到“hello memcached!”。至此，memcache安装配置成功！
书签教你CentOS 7下安装操作Memcached
centos yum安装memcached及php memcache扩展
Nginx中文官方文档 Memcached
ngx_http_memcached_module
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>memcache</tag>
      </tags>
  </entry>
  <entry>
    <title>python pip更换国内源</title>
    <url>/dev-pip-source/</url>
    <content><![CDATA[前言国内使用python下载包，经常会遇到下载不了的情况，这时可以替换pip源。
目前国内靠谱的 pip 镜像源有：清华：https://pypi.tuna.tsinghua.edu.cn/simple/阿里：https://mirrors.aliyun.com/pypi/simple/豆瓣：https://pypi.douban.com/simple/
参考文档：pypi 镜像使用帮助。


临时使用比如更新tensorflow，可以使用
pip install tensorflow --upgrade -i https://pypi.tuna.tsinghua.edu.cn/simplepip install tensorflow --upgrade --trusted-host -i https://pypi.tuna.tsinghua.edu.cn/simple
两者的差别，在于使用的协议是http还是https。在最新的pip版本(&gt;=7)中，使用镜像源时，会提示源地址不受信任或不安全。
windows配置pip源1、创建目录和文件
%appdata%\pip\pip.ini# c:\user\username\pip\pip.ini

2、pip.ini内容为：
[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn/simple/

linux配置pip源1、创建目录和文件vi ~/.pip/pip.conf
2、pip.conf内容为：
[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/[install]trusted-host = https://pypi.tuna.tsinghua.edu.cn/simple/

anaconda配置pip源conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yes

虽然修改了软件源，但是pip search命令还是不能使用的，因为搜索软件使用的协议与安装软件不同。pip search基于xmlrpclib实现，pip install基于urllib2实现。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pip</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL入门篇</title>
    <url>/dev-postgresql-start/</url>
    <content><![CDATA[PostgreSQL简介
PostgreSQL is a powerful, open source object-relational database system with over 30 years of active development that has earned it a strong reputation for reliability, feature robustness, and performance.

更多内容参考PostgreSQL官网和PostgreSQL Documentation。
Harbor中使用的数据库就是PostgreSQL，因此本文对PostgreSQL（pg）进行一个简单的学习，主要参考PostgreSQL 菜鸟教程。


Harbor中的pg1、进入pg容器docker exec -it harbor-db /bin/bash
2、登录pgpsql -U postgres -h postgresql -p 5432默认密码为 root123 ，实际密码查看harbor.yml中的配置。
3、查看帮助
\help\help select

4、查看数据库，切换数据库，查看表
\l\c registry;\d\dt

5、查看表结构
\d registry;\d replication_policy;

6、查看表数据
select * from registry;select * from replication_policy;
可以看到，查看表数据的方法和mysql完全相同。实际上，pg支持标准的sql语法，因此增删查改的语法参考《MySQL常用命令》即可。
安装pg如果单独使用pg，该怎样安装？下面学习使用docker安装pg的方法。
1、登录dockerhub查看需要的pg版本。
2、下载pg镜像（以pg12.2为例）docker pull postgres:12.2
3、启动pg服务
docker run --name vk-pg -d \-p 5432:5432 \-e POSTGRES_PASSWORD=voidking \-e PGDATA=/var/lib/postgresql/data/pgdata \-v /opt/postgresql/data:/var/lib/postgresql/data \postgres:12.2

以上命令：

命名容器为vk-pg，后台运行
映射宿主机5432端口到容器5432端口
设置pg数据库密码和数据存放目录
映射宿主机/opt/postgresql/data目录（不需要提前创建目录）到容器/var/lib/postgresql/data目录

更高级的启动命令参考How to use this image。
4、验证安装docker psgp启动正常的话就可以看到vk-pg容器。如果启动失败，可以使用docker logs vk-pg查看失败原因并进行解决。
使用nc命令验证：
yum install ncnc -v localhost 5432

5、登录pg
docker exec -it vk-pg /bin/bashpsql -U postgrespsql -U postgres -h localhost -p 5432
啊嘞，直接登录进去了，不需要密码？这是因为，pg镜像在本地设置了信任身份验证，因此从容器内连接时不需要密码。
但是，如果从其他主机/容器进行连接，则需要输入密码。比如在宿主机（系统为centos7）上登录pg：
yum list | grep postgresqlyum install postgresql.x86_64psql -U postgres -h localhost -p 5432
这次必须输入正确的密码才能登录。
以上，pg安装配置完成。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>数据库</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus Blackbox exporter</title>
    <url>/dev-prometheus-blackbox-exporter/</url>
    <content><![CDATA[白盒监控和黑盒监控我们监控主机的资源用量、容器的运行状态、数据库中间件的运行数据。这些都是支持业务和服务的基础设施，通过白盒能够了解其内部的实际运行状态，通过对监控指标的观察能够预判可能出现的问题，从而对潜在的不确定因素进行优化。而从完整的监控逻辑的角度，除了大量的应用白盒监控以外，还应该添加适当的黑盒监控。黑盒监控即以用户的身份测试服务的外部可见性，常见的黑盒监控包括HTTP探针、TCP探针等用于检测站点或者服务的可访问性，以及访问效率等。
黑盒监控相较于白盒监控最大的不同在于黑盒监控是以故障为导向当故障发生时，黑盒监控能快速发现故障，而白盒监控则侧重于主动发现或者预测潜在的问题。一个完善的监控目标是要能够从白盒的角度发现潜在问题，能够在黑盒的角度快速发现已经发生的问题。
Prometheus Blackbox exporter允许通过HTTP，HTTPS，DNS，TCP和ICMP对端点进行黑盒探测。
更多内容，参考网络探测：Blackbox Exporter 和 prometheus/blackbox_exporter。
本文中，我们会安装blackbox exporter，并且使用http探针对一些接口进行探活。


安装使用blackbox exporterblackbox exporter的常规安装使用方法有三种：直接使用二进制文件、使用docker image、编译安装。这里我们选择使用docker image的方式来进行安装，默认已经安装了docker。
1、创建配置文件blackbox.yml
modules:  http_2xx:    prober: http    http:      method: GET      preferred_ip_protocol: "ip4"  http_post_2xx:    prober: http    http:      method: POST      preferred_ip_protocol: "ip4"  tcp:    prober: tcp  ping:    prober: icmp    timeout: 3s    icmp:      preferred_ip_protocol: "ip4"  dns_baidu:    prober: dns    timeout: 5s    dns:      query_name: "baidu.com"      query_type: "A"      preferred_ip_protocol: "ip4"
探测时默认使用ipv6，探测不支持ipv6的站点都会显示失败，因此在配置时改成了ipv4，更多内容参考UNDERSTANDING AND USING THE MULTI-TARGET EXPORTER PATTERN。
2、启动blackbox exporter
docker run --name blackbox-exporter -d \-p 9115:9115  \-v `pwd`:/config \prom/blackbox-exporter:v0.16.0 --config.file=/config/blackbox.yml

3、测试
curl "http://127.0.0.1:9115/probe?module=http_2xx&amp;target=baidu.com"curl "http://127.0.0.1:9115/probe?module=http_post_2xx&amp;target=baidu.com"curl "http://127.0.0.1:9115/probe?module=tcp&amp;target=baidu.com:80"curl "http://127.0.0.1:9115/probe?module=ping&amp;target=baidu.com"curl "http://127.0.0.1:9115/probe?module=dns_baidu&amp;target=180.76.76.76"
从返回的样本中，可以获取站点的DNS解析耗时、站点响应时间、HTTP响应状态码等等和站点访问质量相关的监控指标，从而帮助管理员主动的发现故障和问题。
与prometheus集成紧接着《使用Docker安装配置Prometheus》，当前prometheus.yml配置内容为：
global:  scrape_interval: 15s #默认采集监控数据时间间隔  external_labels:    monitor: 'my-monitor'scrape_configs:  #监控对象设置  - job_name: prometheus #任务名称    scrape_interval: 5s #每隔5s获取一次监控数据    static_configs: #监控对象地址      - targets: ['127.0.0.1:9090']  # 将自己加入到监控对象中      - targets: ['192.168.56.102:9100']        labels:          group: 'client-node-exporter'      - targets: ['192.168.56.102:9091']        labels:          group: 'pushgateway'rule_files:  - /etc/prometheus/rules.yml   #告警规则文件路径alerting:   #告警管理器设置  alertmanagers:    - static_configs:      - targets: ['192.168.56.102:9093'] #告警信息会发送给alertmanager进一步处理

简单配置修改prometheus.yml，添加blackbox exporter相关字段。
- job_name: baidu_http2xx_probe  params:    module:    - http_2xx    target:    - baidu.com  metrics_path: /probe  static_configs:  - targets:    - 127.0.0.1:9115- job_name: prometheus_http2xx_probe  params:    module:    - http_2xx    target:    - prometheus.io  metrics_path: /probe  static_configs:  - targets:    - 127.0.0.1:9115
这里分别配置了名为baidu_http2x_probe和prometheus_http2xx_probe的采集任务，并且通过params指定使用的探针（module）以及探测目标（target）。
高级配置以上配置会有一个问题，假如我们有N个目标站点且都需要M种探测方式，那么Prometheus中将包含N * M 个采集任务，从配置管理的角度来说显然是不可接受的。这里我们利用Prometheus的Relabeling方式对这些配置进行简化，配置方式如下：
scrape_configs:  #监控对象设置  - job_name: prometheus #任务名称    scrape_interval: 5s #每隔5s获取一次监控数据    static_configs: #监控对象地址      - targets: ['127.0.0.1:9090']  # 将自己加入到监控对象中      - targets: ['192.168.56.102:9100']        labels:          group: 'client-node-exporter'      - targets: ['192.168.56.102:9091']        labels:          group: 'pushgateway'      - targets: ['192.168.56.102:9115']  - job_name: 'blackbox'    metrics_path: /probe    params:      module: [http_2xx]    static_configs:      - targets:        - http://prometheus.io    # Target to probe with http.        - https://prometheus.io   # Target to probe with https.        - http://example.com:8080 # Target to probe with http on port 8080.    relabel_configs:      - source_labels: [__address__]        target_label: __param_target      - source_labels: [__param_target]        target_label: instance      - target_label: __address__        replacement: 192.168.56.102:9115 # The blackbox exporter's real hostname:port.

这里针对每一个探针服务（如http_2xx）定义一个采集任务，并且直接将任务的采集目标定义为我们需要探测的站点。在采集样本数据之前通过relabel_configs对采集任务进行动态设置。
上面的配置，实际上相当于：
curl "http://192.168.56.102:9115/probe?module=http_2xx&amp;target=http://prometheus.io"curl "http://192.168.56.102:9115/probe?module=http_2xx&amp;target=https://prometheus.io"curl "http://192.168.56.102:9115/probe?module=http_2xx&amp;target=http://example.com:8080"

这个配置实际上是很奇怪的，因为第一个job中 static_configs.targets 代表的是用来exporter对外暴露的接口，第二个job中 static_configs.targets 却代表blackbox要探测的站点。而且第二个job的 relabel_configs.replacement 居然用来指定blackbox的url，我也是服气了，说好的用来替换标签值的呢？
重启prometheus，然后进行验证：（1）访问blackbox-exporter页面，可以看到探测记录的日志。（2）访问prometheus的target页面，即可看到blackbox-exporter。（3）访问prometheus的graph页面，可以查看blackbox-exporter指标。 &#123;job=~"blackbox",__name__!~"^go.*"&#125;
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus查询语言：PromQL</title>
    <url>/dev-prometheus-query-language-promql/</url>
    <content><![CDATA[PromQL简介
Prometheus提供了一种称为PromQL（Prometheus查询语言）的功能查询语言，使用户可以实时选择和汇总时间序列数据。表达式的结果既可以显示为图形，也可以在Prometheus的表达式浏览器中显示为表格数据，也可以由外部系统通过HTTP API使用。

更多内容参考QUERYING PROMETHEUS 和 探索PromQL。


时间序列# HELP node_cpu Seconds the cpus spent in each mode.# TYPE node_cpu counternode_cpu&#123;cpu="cpu0",mode="idle"&#125; 362812.7890625# HELP node_load1 1m load average.# TYPE node_load1 gaugenode_load1 3.0703125
其中非#开头的每一行表示当前Node Exporter采集到的一个监控指标（监控样本）：node_cpu和node_load1表明了当前指标的名称（大括号中的标签则反映了该指标的一些特征和维度），浮点数是该指标的具体值。指标格式为：
metric_name [ &#123;label_name="label_value"&#125; ] value [ timestamp ]

其中metric_name和label_name必须遵循PromQL的格式规范要求。value是一个float格式的数据，timestamp的类型为int64（从1970-01-01 00:00:00以来的毫秒数），timestamp为可选默认为当前时间。具有相同metric_name的样本必须按照一个组的形式排列，并且每一行必须是唯一的指标名称和标签键值对组合。
Prometheus会将所有采集到的指标数据以时间序列（time-series）的方式保存在内存数据库中，并且定时保存到硬盘上。时间序列是按照时间戳和指标的序列顺序存放的，我们称之为向量(vector)。
可以将time-series理解为一个数字矩阵，X轴是时间戳，Y轴是指标。
数据类型在Prometheus的表达语言中，一个表达式或子表达式可以分以下四种类型之一：

瞬时向量：一组时间序列，这组时间序列具有相同的时间戳
范围向量：一段时间范围的时间序列
标量：一个简单的数字浮点值
String：一个简单的字符串值；目前未使用

根据用例（例如在绘制图形或显示表达式的输出时），由于用户指定的表达式的结果，其中只有某些类型是合法的。例如，返回瞬时向量的表达式是唯一可以直接绘制图形的类型。
常量字符串常量字符串可以用单引号，双引号或反引号指定为常量。PromQL遵循与Go相同的转义规则。在单引号或双引号中，反斜杠开始一个转义序列。可以使用八进制或十六进制提供特定字符。反引号内不会处理任何转义。与Go不同，Prometheus不会在反引号内丢弃换行符。
"this is a string"'these are unescaped: \n \\ \t'`these are not unescaped: \n ' " \t`

浮点常量浮点常量可以写做数字形式：[-](digits)[.(digits)] ，例如 -2.43
时间序列选择器瞬时向量选择器瞬时向量选择器允许在给定的时间戳（瞬时）下选择一组时间序列和每个样本的单个样本值：以最简单的形式，仅指定度量名称。这将导致一个瞬时向量，其中包含具有该度量名称的所有时间序列的元素。通过在花括号 {} 中附加逗号分隔的标签匹配器列表，可以进一步过滤这些时间序列。也可以否定标签值，或将标签值与正则表达式匹配。存在以下标签匹配运算符：

=：选择与字符串完全相等的标签。
!=：选择不等于字符串的标签。
=〜：选择与字符串进行正则表达式匹配的标签。
!〜：选择与字符串正则表达式不匹配的标签。

匹配空标签值的标签匹配器还会选择所有根本没有设置特定标签的时间序列。正则表达式匹配完全锚定。同一标签名称可能有多个匹配器。向量选择器必须指定一个名称或至少一个与空字符串不匹配的标签匹配器。通过与内部 __name__ 标签进行匹配，标签匹配器也可以应用于度量标准名称。Prometheus中的所有正则表达式都使用RE2语法。
&#123;job=~".*"&#125; # Bad!&#123;job=~".+"&#125;              # Good!&#123;job=~".*",method="get"&#125; # Good!&#123;__name__=~"job:.*"&#125; # selects all metrics that have a name starting with job:on&#123;&#125; # Bad!&#123;__name__="on"&#125; # Good!

范围向量选择器范围向量的工作方式与瞬时向量相同，不同的是范围向量从瞬时向量中选择了一定范围的样本。语法上，将范围持续时间附加在向量选择器末尾的方括号 [] 中，以指定提取时间值的范围。持续时间以数字指定，后面紧跟以下单位之一：s - seconds，m - minutes，h - hours，d - days，w - weeks，y - years
偏移量偏移量允许更改查询中各个瞬时向量和范围向量的时间偏移。
http_requests_total offset 5msum(http_requests_total&#123;method="GET"&#125; offset 5m) // GOOD.sum(http_requests_total&#123;method="GET"&#125;) offset 5m // INVALID.rate(http_requests_total[5m] offset 1w)

子查询子查询对给定的范围进行即时查询。子查询的结果是范围向量。语法：
&lt;instant_query&gt; '[' &lt;range&gt; ':' [&lt;resolution&gt;] ']' [ offset &lt;duration&gt; ]

resolution是可选的。默认值为全局评估间隔。
运算符Prometheus支持许多二进制和聚合运算符，更多内容参考表达式语言运算符。
函数Prometheus支持多种对数据进行操作的函数，更多内容参考表达式语言函数。
注释PromQL支持以＃开头的行注释。
例子详细内容参见QUERY EXAMPLE
简单时间序列查询http_requests_total&#123;__name__="http_requests_total"&#125;http_requests_total&#123;job="apiserver", handler="/api/comments"&#125;http_requests_total&#123;job="apiserver", handler="/api/comments"&#125;[5m]http_requests_total&#123;job=~".*server"&#125;http_requests_total&#123;status!~"4.."&#125;

子查询rate(http_requests_total[5m])[30m:1m]max_over_time(deriv(rate(distance_covered_total[5s])[30s:5s])[10m:])

函数运算等rate(http_requests_total[5m])sum by (job) (  rate(http_requests_total[5m]))(instance_memory_limit_bytes - instance_memory_usage_bytes) / 1024 / 1024sum by (app, proc) (  instance_memory_limit_bytes - instance_memory_usage_bytes) / 1024 / 1024topk(3, sum by (app, proc) (rate(instance_cpu_time_ns[5m])))count by (app) (instance_cpu_time_ns)]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus入门篇</title>
    <url>/dev-prometheus-start/</url>
    <content><![CDATA[Prometheus简介
Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud. Since its inception in 2012, many companies and organizations have adopted Prometheus, and the project has a very active developer and user community. It is now a standalone open source project and maintained independently of any company. To emphasize this, and to clarify the project’s governance structure, Prometheus joined the Cloud Native Computing Foundation in 2016 as the second hosted project, after Kubernetes.

特性、组件和架构等更多信息，参考Prometheus官方文档。


安装Prometheus server本节在CentOS7虚拟机上安装Prometheus server，虚拟机IP为192.168.56.130，安装流程主要参考Prometheus - GETTING STARTED。
1、下载Prometheus server访问Prometheus官网下载页，这里选择下载prometheus-2.15.2.linux-amd64.tar.gz
cd /optwget https://github.com/prometheus/prometheus/releases/download/v2.15.2/prometheus-2.15.2.linux-amd64.tar.gz

2、解压并进行配置
tar -xzvf prometheus-2.15.2.linux-amd64.tar.gzmv prometheus-2.15.2.linux-amd64 prometheuscd prometheusvim prometheus.yml

修改targets为0.0.0.0:9090，修改后的prometheus.yml如下：
# my global configglobal:  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.  # scrape_timeout is set to the global default (10s).# Alertmanager configurationalerting:  alertmanagers:  - static_configs:    - targets:      # - alertmanager:9093# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.rule_files:  # - "first_rules.yml"  # - "second_rules.yml"# A scrape configuration containing exactly one endpoint to scrape:# Here it's Prometheus itself.scrape_configs:  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.  - job_name: 'prometheus'    # metrics_path defaults to '/metrics'    # scheme defaults to 'http'.    static_configs:    - targets: ['0.0.0.0:9090']

3、启动prometheus./prometheus --config.file=prometheus.yml
除了上面的安装方法，还可以下载Prometheus的Docker images，使用Docker安装。
简单使用1、访问metrics浏览器访问 http://192.168.56.130:9090/metrics可以看到prometheus的一些信息：
# HELP go_gc_duration_seconds A summary of the GC invocation durations.# TYPE go_gc_duration_seconds summarygo_gc_duration_seconds&#123;quantile="0"&#125; 6.078e-06go_gc_duration_seconds&#123;quantile="0.25"&#125; 9.877e-06go_gc_duration_seconds&#123;quantile="0.5"&#125; 9.9e-06go_gc_duration_seconds&#123;quantile="0.75"&#125; 1.1475e-05go_gc_duration_seconds&#123;quantile="1"&#125; 1.2132e-05go_gc_duration_seconds_sum 4.9462e-05go_gc_duration_seconds_count 5# HELP go_goroutines Number of goroutines that currently exist.# TYPE go_goroutines gaugego_goroutines 35

2、查看图表浏览器访问 http://192.168.56.130:9090/graph在Expression输入框中输入：prometheus_target_interval_length_seconds，然后点击Execute，再点击下面Tab中的Graph。可以看到一个图表，图表的含义是，emm，不知道。
3、收集其他metrics想要收集metrics，首先要安装配置好exporter。比如想要收集jmx metrics，那么需要安装prometheus/jmx_exporter。
后记Prometheus也有不少问题，比如数据量大的时候需要拆分集群，聚合数据很难数据去重，可用性较低等。因此出现了Thanos，能够解决Prometheus的很多问题，详情参考分布式 Promethues 之 Thanos。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>监控</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>PyCharm调试</title>
    <url>/dev-pycharm-debug/</url>
    <content><![CDATA[PyCharmPyCharm是一种Python IDE，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具，比如调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制。此外，该IDE提供了一些高级功能，以用于支持Django框架下的专业Web开发。
本文要记录的，是PyCharm的调试功能。


使用一般调试一般调试，不需要对PyCharm做什么设置，直接使用就可以了。
1、打开PyCharm，新建文件test.py
def my_abs(x):    if x &gt;= 0:        return x    else:        return -xprint(my_abs(-100))

2、双击代码左侧行号旁的空白处，添加断点。
3、在菜单栏点击Run，Debug…，选择test。再次调试的时候，只需要在菜单栏点击Run，Debug ‘test’即可。
4、在PyCharm底部的Debugger窗口中，就可以看到Step Over、Step Into、Step Into My Code、Step Out、Run to Cursor等按钮。同时在Variables窗口里，会出现变量的信息。
django调试django的调试，需要对PyCharm进行设置，这里以调试djsite项目为例。
1、在PyCharm中打开djsite项目，点击djsite的目录，然后点击菜单栏的Run，Edit Configurations…。弹出一个Run/Debug Configurations窗口。
2、点击配置窗口左上角的加号，再点击Python，出现配置项目的页面。主要修改Name为djsite，Script为D:\github\djsite\manage.py，Script parameters为runserver。然后点击OK即可。
3、在菜单栏点击Run，Debug…，选择djsite。在Console中，就会显示出运行情况。（注意，Console可以缩小到最右边，记得把它展开）
4、双击代码左侧行号旁的空白处，添加断点。在浏览器访问该方法，就会跳转到断点处。
书签PyCharm下载地址
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
        <category>工具</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>debug</tag>
        <tag>pycharm</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript学习笔记——实践篇</title>
    <url>/dev-jquery-practice/</url>
    <content><![CDATA[注释本文中的文件名，写在了代码注释中。既然用到了三种文件，就把这三种文件的注释方法先说明一下。
HTML注释语法&lt;!--注释的内容--&gt;,示例如下：
&lt;!--欢迎来到VoidKing的主页--&gt;

CSS注释语法/*注释的内容*/，示例如下：
/*这是注释*//*这也是注释可以分段*/

Javascript注释和C语言相同，语法//注释的内容或者/*注释的内容*/，示例如下：
//这是注释/*这也是注释*/
使用Javascript在html页面中使用Javascript，有三种方法：
body中body中的Javascript代码，相当于C语言中位于main函数内代码，格式如下：
&lt;!--index.html--&gt;&lt;html&gt;	&lt;head&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;script type="text/javascript"&gt;		document.write("voidking.com");		alert("voidking.com");		&lt;/script&gt;	&lt;/body&gt;&lt;/html&gt;
head中head中的Javascript代码，相当于C语言中位于main函数外的代码，一般是封装好的函数。格式如下：
&lt;!--index.html--&gt;&lt;html&gt;	&lt;head&gt;		&lt;meta http-equiv="Content-Type" content="charset=utf-8" /&gt;		&lt;script type="text/javascript"&gt;		function hello()&#123;			var str=prompt("VoidKing的网址是什么？","请在这里输入");			if(str!=null &amp;&amp; str!="")			&#123;				alert("你输入的是："+str);			&#125;			else			&#123;				alert("你什么也没有输入！");			&#125;		&#125;		&lt;/script&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;script type="text/javascript"&gt;			hello();		&lt;/script&gt;	&lt;/body&gt;&lt;/html&gt;
外部head中的Javascript代码不易维护，所以多数情况下我们会使用外部引用来代替。格式如下：
&lt;!--index.html--&gt;&lt;html&gt;	&lt;head&gt;		&lt;meta http-equiv="Content-Type" content="charset=utf-8" /&gt;		&lt;script type="text/javascript" src="javascript.js"&gt;&lt;/script&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;script type="text/javascript"&gt;			hello();		&lt;/script&gt;	&lt;/body&gt;&lt;/html&gt;
//javascript.jsfunction hello()&#123;			var str=prompt("VoidKing的网址是什么？","请在这里输入");			if(str!=null &amp;&amp; str!="")			&#123;				alert("你输入的是："+str);			&#125;			else			&#123;				alert("你什么也没有输入！");			&#125;		&#125;
使用CSS上面我们已经说完了使用Javascript的三种方式，爱思考的小伙伴肯定想到了CSS的使用方法，在这里，我也总结一下。
内联样式当特殊的样式需要应用到个别元素时，就可以使用内联样式。格式如下：
&lt;!--index.html--&gt;&lt;html&gt;	&lt;head&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;p style="color:red;margin-left:20px"&gt;		This is a paragraph.		&lt;/p&gt;	&lt;/body&gt;&lt;/html&gt;

内部样式当单个文件需要特别样式的时候，就可以使用内部样式表。格式如下:
&lt;!--index.html--&gt;&lt;html&gt;	&lt;head&gt;		&lt;style type="text/css"&gt;		body&#123;background-color:red&#125;		p&#123;margin-left:20px&#125;		&lt;/style&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;p&gt;		This is a paragraph.		&lt;/p&gt;	&lt;/body&gt;&lt;/html&gt;
外部样式当样式需要被应用到很多页面的时候，外部样式表最适合。格式如下：
&lt;!--index.html--&gt;&lt;html&gt;	&lt;head&gt;		&lt;link rel="stylesheet" type="text/css" href="style.css"/&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;p&gt;		This is a paragraph.		&lt;/p&gt;	&lt;/body&gt;&lt;/html&gt;
/*style.css*/body&#123;background-color:red&#125;p&#123;margin-left:20px&#125;

借花献佛本来想自己整理出一批好的例子，但是，无意中发现了一个网站，已经做得非常好了。所以，void在这里就偷懒一下。例子精品，还附有教程讲解，分享给大家——梦之都！
结束语这篇文章比预期的用时要短上很多，主要因为，我把痛苦的工作全部交给梦之都了，好机智地说！还想写个提高篇来着，但是能力有限，不能误人子弟啊！所以，Javascript笔记至此结束，接下来，该是jQuery了！
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>仿淘宝图片放大器</title>
    <url>/dev-jquery-image-zoom/</url>
    <content><![CDATA[原理两个盒子，盒子1放小图片，盒子2放对应的大图片。盒子1里的图片正常显示，盒子2里的图片隐藏。在盒子1的图片标签中，加入大图的数据链接。当鼠标在盒子1上移动时，通过鼠标在盒子1的位置计算出盒子2中应该显示的大图的部分。


以下代码中，利用到了jquery.jqzoom.js插件。
代码&lt;div id="preview" class="spec-preview"&gt;     &lt;span class="jqzoom"&gt;        &lt;img jqimg="images/b1.jpg" src="images/s1.jpg" /&gt;    &lt;/span&gt; &lt;/div&gt;

$(function()&#123;    $(".jqzoom").jqueryzoom(&#123;xzoom:380,yzoom:380&#125;);&#125;);


参考文档jquery.jqzoom.js图片放大镜http://www.cnblogs.com/sydeveloper/p/3796330.html
ImageZoom 图片放大效果http://www.cnblogs.com/cloudgamer/archive/ImageZoom.html
jQuery-实现图片的放大镜显示效果
jquery插件 放大镜http://www.jq-school.com/Article.aspx?kid=41
jQzoom简介http://www.oschina.net/p/jqzoom?fromerr=tUayHgqO
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>插件</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python操作Excel表格</title>
    <url>/dev-python-excel/</url>
    <content><![CDATA[前言最近疫情又变得严重，多地都推迟了开学，改为上网课。这样一来，老师们就需要每次上完课后统计学生的出勤情况，包括未上课的同学和上课时间不足40分钟的同学。
为了方便我们家谭老师的统计工作，决定趁周末写一个脚本，把人工统计变成自动统计。


思路1、选择excel读写模块，经过简单比较决定选择 xlrd 和 xlwt 。2、已知学生没有重名，因此全体学生姓名作为集合A，上课学生作为集合B，上课满40分钟学生作为集合C。未上课学生为A-B，上课时间不足40分钟的学生为A-C-(A-B)。3、因为两个班级需要分开统计，因此使用学生姓名作为dict的key，班级作为dict的value。
实现1、安装依赖
pip3 install xlrd==1.2.0pip3 install xlwt
之所以指定xlrd的版本，是因为更高的版本不支持读取xlsx格式的表格。
2、代码实现统计缺勤学生
3、代码执行./main.py xxx.xlsx
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>加快Android离线文档的访问速度</title>
    <url>/dev-quickly-open-android-offline-document/</url>
    <content><![CDATA[前言学习编程三年，已经确信，学习一门技术最好的资料就是官方文档。如今，拖沓了很久的Android学习计划，终于启动。学习资料：Android官方文档；学习方法：写demo写博客（总结）。
阅读途径官网http://developer.android.com/index.html不幸的是，这个网站的国内访问速度，慢到令人发指。很多时候，根本打不开。当然，如果你喜欢翻墙玩，就另当别论。
国内镜像站不得不说，咱们国家有很多雷锋。国外的网站不好访问，那就在国内搭建一个镜像站，方便大家访问。这里郝同学推荐几个国内镜像站供大家使用：1、踏得网http://wear.techbrood.com/training/index.html
2、Android中文APIhttp://www.android-doc.comhttp://www.android-doc.com/reference/packages.htmlhttp://www.android-doc.com/guide/components/activities.html
3、Android官方培训课程中文版(v0.9.2)http://hukai.me/android-training-course-in-chinese/index.html


离线文档打开adt中的SDK Manager，安装Documentation for Android SDK。安装好之后，在adt/sdk/docs目录下，就是官方文档了。当然，我们也可以直接下载别人下载打包好的官方文档，速度会快很多。
这时候问题来了，docs里的很多文件，会加载谷歌的字体和js。这样，严重拖慢了打开速度。
解决办法修改index.html打开index.html，然后注释掉stylesheet和js两个地方：
&lt;!--&lt;link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Roboto:regular,medium,thin,italic,mediumitalic,bold" title="roboto"&gt;--&gt;&lt;!--&lt;script src="http://www.google.com/jsapi" type="text/javascript"&gt;&lt;/script&gt;--&gt;
修改本机hosts文件C:\Windows\System32\drivers\etc\hosts增加如下部分：
127.0.0.1 fonts.googleapis.com127.0.0.1 www.google.com
Java实现批量注释/* * 去掉Android文档中需要联网的javascript代码 */import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.File;import java.io.FileNotFoundException;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FormatDoc &#123;    public static int j=1;    /**     * @param args     */    public static void main(String[] args) &#123;                File file = new File("D:/android/android-sdk-windows/docs/");        searchDirectory(file, 0);        System.out.println("OVER");    &#125;    public static void searchDirectory(File f, int depth) &#123;        if (!f.isDirectory()) &#123;            String fileName = f.getName();            if (fileName.matches(".*.&#123;1&#125;html")) &#123;                String src= "&lt;(link rel)[=]\"(stylesheet)\"\n(href)[=]\"(http)://(fonts.googleapis.com/css)[?](family)[=](Roboto)[:](regular,medium,thin,italic,mediumitalic,bold)\"( title)[=]\"roboto\"&gt;";                String src1 = "&lt;script src=\"http://www.google.com/jsapi\" type=\"text/javascript\"&gt;&lt;/script&gt;";                String dst = "";                //如果是html文件则注释掉其中的特定javascript代码                annotation(f, src, dst);                annotation(f, src1, dst);            &#125;        &#125; else &#123;            File[] fs = f.listFiles();            depth++;            for (int i = 0; i &lt; fs.length; ++i) &#123;                File file = fs[i];                searchDirectory(file, depth);            &#125;        &#125;    &#125;    /*     * f 将要修改其中特定内容的文件      * src 将被替换的内容      * dst 将被替换层的内容     */    public static void annotation(File f, String src, String dst) &#123;        String content = FormatDoc.read(f);        content = content.replaceFirst(src, dst);        int ll=content.lastIndexOf(src);        System.out.println(ll);        FormatDoc.write(content, f);        System.out.println(j++);        return;    &#125;    public static String read(File src) &#123;        StringBuffer res = new StringBuffer();        String line = null;        try &#123;            BufferedReader reader = new BufferedReader(new FileReader(src));            int i=0;            while ((line = reader.readLine()) != null) &#123;                if (i!=0) &#123;                    res.append('\n');                &#125;                res.append(line);                i++;            &#125;            reader.close();        &#125; catch (FileNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;        return res.toString();    &#125;    public static boolean write(String cont, File dist) &#123;        try &#123;            BufferedWriter writer = new BufferedWriter(new FileWriter(dist));            writer.write(cont);            writer.flush();            writer.close();            return true;        &#125; catch (IOException e) &#123;            e.printStackTrace();            return false;        &#125;    &#125;&#125;

C++实现批量注释详见参考文档：优化Android离线文档的访问速度。velable兄很牛逼，感谢他分享给我们的代码和文档！郝同学存入了网盘一份，方便大家下载。源代码：http://yunpan.cn/cj7VgRg9tUS6e  访问密码 edb4文档：http://yunpan.cn/cj7Vsaavmey62  访问密码 4e38
参考文档Android帮助文档本地打开慢的解决方案http://blog.csdn.net/wc0077/article/details/39669885

优化Android离线文档的访问速度http://git.oschina.net/velable/OptAndroidDocs

Android离线文档，急速访问+搜索功能正常。http://git.oschina.net/velable/Android_Offline_Docs

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>ReactNative、Ionic和NativeScript</title>
    <url>/dev-reactnative-ionic-nativescript/</url>
    <content><![CDATA[前言最近几年，利用HTML5技术开发跨平台app，越来越流行。各种框架层出不穷，郝同学选择了其中三个，来对比研究一下究竟什么样的框架才更好。


ReactNativeReact Native 使你能够使用基于 JavaScript 和 React 一致的开发体验在本地平台上构建世界一流的应用程序体验。React Native 把重点放在所有开发人员关心的平台的开发效率上——开发者只需学习一种语言就能轻易为任何平台高效地编写代码。Facebook 在多个应用程序产品中使用了 React Native，并将继续为 React Native 投资。
优势：1、虽然不能做到一处编码到处运行，但是基本上即使是两套代码，也是相同的jsx语法，使用js进行开发。用户体验，高于html，开发效率较高。2、flexbox 布局，据说比native的自适应布局更加简单高效。3、可实现在线更新，AppStore审核政策调整：允许运行于JavascriptCore的动态加载代码。4、更贴近原生开发。
劣势：1、（引）对开发人员要求较高，不是懂点web技术就行的，当官方封装的控件、api无法满足需求时 就必然需要懂一些native的东西去扩展，扩展性仍然远远不如web，也远远不如直接写Native code。2、（引）官方说得很隐晦：learn once, write anywhere。人家可没说run anywhere。事实上，从官方的api来看SliderIOS，SwitchIOS..等等这些控件，之后势必会出现SliderAndroid，SwitchAndroid…，也就是很可能针对不同的平台会需要写多套代码。3、发展还不成熟，目前很多ui组件只有ios的实现，android的需要自己实现。4、（引）从Native到Web，要做很多概念转换，势必造成双方都要妥协。比如web要用一套CSS的阉割版，Native通过css-layout拿到最终样式再转换成native原生的表达方式（比如iOS的Constraint\origin\Center等属性），再比如动画。另外，若Android和iOS都要做相同的封装，概念转换就更复杂。5、文档还不够完整，学习起来困难。
IonicIONIC是目前最有潜力的一款 HTML5 手机应用开发框架。通过 SASS 构建应用程序，它提供了很多 UI 组件来帮助开发者开发强大的应用。 它使用 JavaScript MVVM 框架和 AngularJS 来增强应用。提供数据的双向绑定，使用它成为 Web 和移动开发者的共同选择。Ionic是一个专注于用WEB开发技术，基于HTML5创建类似于手机平台原生应用的一个开发框架。Ionic框架的目的是从web的角度开发手机应用，基于PhoneGap的编译平台，可以实现编译成各个平台的应用程序。
优势：1、ios 和 android 基本上可以共用代码，纯web思维，开发速度快，简单方便，一次编码，到处运行，如果熟悉web开发，则开发难度较低。2、文档很全，系统级支持封装较好，所有UI组件都是有html模拟，可以统一使用。3、可实现在线更新 允许加载动态加载web js。4、文档多，开发者多，视频教程多。容易学习，遇到问题容易解决，技术成熟。
劣势：1、占用内存高一些（不过手机内存都大了不影响），不适合做游戏类型app，web技术无法解决一切问题，对于比较耗性能的地方无法利用native的思维实现优势互补，如高体验的交互，动画等。
NativeScript和 ReactNative 相比，NativeScript 最大的特点是可以获得100%的原生 API 。也就是说，开发者可以通过 JavaScript 获取和原生开发语言同样多的原生接口。
优势：1、使用 JavaScript 直接访问所有原生 API。2、系统新功能0延时支持。3、第三方原生库全部支持。
劣势：1、NativeScript和React不同，无法与原生项目融合，即你只能纯写个NativeScript的应用，不可能把它抽离出来作为某原生应用的一部分来出现。虽然说它和React的出发点一致都是”用Web APP的开发速度打造Native App的体验”，但是实际上，它算是鸡肋吧，拿它来写个展示App或者简单的应用还是不错的。2、NativeScript中虽然已经支持了很多组件，比如说tabview、srcollview、button，但是提供的组件方法、属性过少，整个框架还不是很丰满。
后记利用HTML5技术开发跨平台app，最重要的是两点：第一点，一套代码，所有平台都可以运行；第二点，利用HTML5技术实现，尽量少的用到其他技术。至于性能，肯定是不如原生应用的，只能期待框架以后的优化。ReactNative，很多时候都要写两套代码，不满足第一点；开发时要用到很多原生的android和ios技术，不满足第二点。Ionic，两点皆满足，但是更适合开发web类app，不适合开发游戏。NativeScript，两点皆满足。
综上，个人认为，Ionic和NativeScript更值得学习。如果非要二选一，我选择NativeScript。理由很简单，ReactNative的研发人数更少，参考文档、书籍和视频更少，要做，就做先行者。
书签ReactNative整理了一份React-Native学习指南http://www.tuicool.com/articles/zaInUbA
RativeScript的工作原理：用JavaScript调用原生API实现跨平台 – OurJShttp://top.css88.com/archives/656
React Native中文社区http://bbs.reactnative.cn/
React 入门实例教程http://www.ruanyifeng.com/blog/2015/03/react.html
WebViewJavascriptBridge详细使用http://www.tuicool.com/articles/Q3AVnq2
WebViewJavascriptBridge 原理分析http://www.2cto.com/kf/201503/384998.html
教你怎么屏蔽掉在移动端的宽带运营商的流量劫持，屏蔽无耻的广告https://my.oschina.net/zxcholmes/blog/596192
ReactJS 傻瓜教程https://zhuanlan.zhihu.com/p/19896745?columnSlug=FrontendMagazine
React | A JAVASCRIPT LIBRARY FOR BUILDING USER INTERFACEShttps://facebook.github.io/react/index.html
IonicIonic: Advanced HTML5 Hybrid Mobile App Frameworkhttp://ionicframework.com/
Ionic中文文档教程http://www.ionic.wang/js_doc-index.html
ionic react-native native 优劣势对比http://www.ionic.wang/article-index-id-69.html
NativeScript使用NativeScript和Angular2构建跨平台APPhttps://zhuanlan.zhihu.com/p/21458458
Cross-Platform Native Development with Javascripthttps://www.nativescript.org/
NativeScript源码https://github.com/NativeScript
NativeScript中文手册 - GitBookhttps://www.gitbook.com/book/flowforever/nativescript-cn-book/details
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>SASS使用说明</title>
    <url>/dev-sass-guide/</url>
    <content><![CDATA[前言
Sass，Syntactically Awesome StyleSheets。Sass 是对 CSS 的扩展，让 CSS 语言更强大、优雅。 它允许你使用变量、嵌套规则、 mixins、导入等众多功能， 并且完全兼容 CSS 语法。 Sass 有助于保持大型样式表结构良好， 同时也让你能够快速开始小型项目， 特别是在搭配 Compass 样式库一同使用时。



安装1、下载安装ruby2、安装好ruby后，再ruby命令行中输入gem install sass
语法变量sass中可以定义变量，方便统一修改和维护。
$fontStack:    Helvetica, sans-serif;$primaryColor: #333;body &#123;  font-family: $fontStack;  color: $primaryColor;&#125;

嵌套sass可以进行选择器的嵌套，表示层级关系，看起来很优雅整齐。
nav &#123;  ul &#123;    margin: 0;    padding: 0;    list-style: none;  &#125;  li &#123; display: inline-block; &#125;  a &#123;    display: block;    padding: 6px 12px;    text-decoration: none`;  &#125;&#125;`。

导入sass中如导入其他sass文件，最后编译为一个css文件，优于纯css的@import。
// reset.scsshtml,body,ul,ol &#123;  margin: 0;  padding: 0;&#125;

@import 'reset';body &#123;  font-size: 100% Helvetica, sans-serif;  background-color: #efefef;&#125;

mixinsass中可用mixin定义一些代码片段，且可传参数，方便日后根据需求调用。从此处理css3的前缀兼容轻松便捷。
@mixin box-sizing ($sizing) &#123;    -webkit-box-sizing:$sizing;            -moz-box-sizing:$sizing;            box-sizing:$sizing;&#125;.box-border&#123;    border:1px solid #ccc;    @include box-sizing(border-box);&#125;

扩展/继承sass可通过@extend来实现代码组合声明，使代码更加优越简洁。
.message &#123;  border: 1px solid #ccc;  padding: 10px;  color: #333;&#125;.success &#123;  @extend .message;  border-color: green;&#125;.error &#123;  @extend .message;  border-color: red;&#125;.warning &#123;  @extend .message;  border-color: yellow;&#125;

运算sass可进行简单的加减乘除运算等
.container &#123; width: 100%; &#125;article[role="main"] &#123;  float: left;  width: 600px / 960px * 100%;&#125;aside[role="complimentary"] &#123;  float: right;  width: 300px / 960px * 100%;&#125;

颜色sass中集成了大量的颜色函数，让变换颜色更加简单。
$linkColor: #08c;a &#123;    text-decoration:none;    color:$linkColor;    &amp;:hover&#123;      color:darken($linkColor,10%);    &#125;&#125;

&amp;表示当前元素伪类和伪元素在CSS中是常用的一种方式，比如最常见的是链接的伪类或者说伪元素:after和:before的使用。大家常看到的就是清除浮动的clearfix:
.clearfix:before,.clearfix:after &#123;    content:"";    display:table;&#125;.clearfix:after &#123;    clear:both;    overflow:hidden;&#125;.clearfix &#123;    *zoom: 1;&#125;

那么在Sass中，使用&amp;会变得更简单，更方便：
$lte-ie: true !default;.clearfix &#123;    @if $lte-ie &#123;        *zoom: 1;    &#125;    &amp;:before,    &amp;:after &#123;        content: "";        display: table;    &#125;    &amp;:after &#123;        clear: both;        overflow: hidden;    &#125;&#125;

&amp;不止用于和伪类的结合，还可以用于多类选择器、后代选择器、相邻兄弟选择器、媒体查询中的嵌套等。
2016.07.30补Sass编码错误ruby环境sass编译中文出现Syntax error: Invalid GBK character。解决办法如下：打开ruby中sass的安装目录，在其中找到engine.rb。在engine.rb中所有的require XXX之后，添加
Encoding.default_external = Encoding.find('utf-8')

PS:郝同学的engine.rb的路径为D:\Program Files\Ruby23-x64\lib\ruby\gems\2.3.0\gems\sass-3.4.22\lib\sass\engine.rb
scss自动编译为css如果希望某一个scss文件或者相应的文件夹下面文件修改后，自动进行编译，那么可以使用侦听命令。1、侦听文件
sass --watch --style compressed style.scss:style.css

2、侦听文件夹
sass --watch --style compressed scss:css

3、封装为脚本为了避免每次运行都敲命令，我们把上述命令分装为脚本scss.bat。
sass --watch --style compressed scss:css

海哥哥封装了不一样的scss-wap.bat，其中的参数至今没有看懂，可以实现同样的效果。
@echo offsass -C -t compressed --watch scss:cssrem  sass -C -t compact --watch scss:csspause

该命令的含义为：
书签sass安装http://www.w3cplus.com/sassguide/install.html
SASS用法指南http://www.ruanyifeng.com/blog/2012/06/sass.html
sass入门http://www.w3cplus.com/sassguide/
SASS 初学者入门http://www.oschina.net/translate/the-absolute-beginners-guide-to-sass
Sass参考手册http://sass.bootcss.com/docs/sass-reference/
SassMeister在线调试http://www.sassmeister.com/
Sass中连体符（&amp;）的运用
ruby环境sass编译中文出现Syntax error: Invalid GBK character错误解决方法http://www.tuicool.com/articles/f2YVRvhttp://www.cnblogs.com/zhidong123/p/3902270.html
SASS的安装和转换为CSS的方法http://www.cnblogs.com/52css/archive/sass-how-to-install-and-use.html
前端之Sass/Scss实战笔记http://www.tuicool.com/articles/iERVJbBhttp://segmentfault.com/a/1190000003742313
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>前端</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title>校内网服务器IP问题</title>
    <url>/dev-school-network-host-ip/</url>
    <content><![CDATA[帮助叶老师做精品课程网站的时候，使用过两个服务器，IP先后分别是202.119.160.48和202.119.160.253。
令我不解的是，我们学校，撑死了能分配到一个公网IP就不错了。但是，学校里却又很多服务器，每个都有不同的IP，而且都可以通过公网访问！这其中使用了什么技术？百度无果，暂时放在这里，留待以后解决。
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>批量替换文件脚本</title>
    <url>/dev-scripts-for-batch-replace-files/</url>
    <content><![CDATA[任务要求步骤一：【替换文件】log4j.properties文件拷贝覆盖到：/opt/flume/conf/log4j.properties步骤二：【替换文件】run.sh文件拷贝覆盖到：/opt/flume/bin/run.sh步骤三：【删除文件】进入/opt/plugins.d/vipkid/lib目录，如果存在就删除flume-ext-1.0-SNAPSHOT.jar步骤四：【替换文件】flume-ext-1.1-SNAPSHOT.jar文件拷贝覆盖到：/opt/flume/plugins.d/vipkid/lib/flume-ext-1.1-SNAPSHOT.jar其他：替换的文件所属用户为flume用户


ansible实现ansible脚本的思路是先备份，然后执行替换删除操作。
---- hosts: commonservers  tasks:  - name: get the time stamp    shell: date +%Y%m%d%H%M%S.%N    register: now_time  - name: backup log4j.properties    shell: cp /opt/flume/conf/log4j.properties&#123;,.&#123;&#123;now_time.stdout&#125;&#125;&#125;   - name: backup run.sh    shell: cp /opt/flume/bin/run.sh&#123;,.&#123;&#123;now_time.stdout&#125;&#125;&#125;  - name: backup flume-ext-1.0-SNAPSHOT.jar    shell: cp /opt/flume/plugins.d/vipkid/lib/flume-ext-1.0-SNAPSHOT.jar&#123;,.&#123;&#123;now_time.stdout&#125;&#125;&#125;  - name: backup flume-ext-1.1-SNAPSHOT.jar    shell: cp /opt/flume/plugins.d/vipkid/lib/flume-ext-1.1-SNAPSHOT.jar&#123;,.&#123;&#123;now_time.stdout&#125;&#125;&#125;  - name: replace log4j.properties    copy:      src: log4j.properties      dest: /opt/flume/conf/log4j.properties      owner: flume      force: yes  - name: replace run.sh    copy:      src: run.sh      dest: /opt/flume/bin/run.sh      owner: flume      force: yes  - name: remove flume-ext-1.0-SNAPSHOT.jar    shell: rm -f /opt/flume/plugins.d/vipkid/lib/flume-ext-1.0-SNAPSHOT.jar  - name: replace flume-ext-1.1-SNAPSHOT.jar    copy:      src: flume-ext-1.1-SNAPSHOT.jar      dest: /opt/flume/plugins.d/vipkid/lib/flume-ext-1.1-SNAPSHOT.jar      owner: flume      force: yes

shell脚本实现shell脚本的思路是在A机器上执行batch-main.sh批量处理脚本，读取主机列表，把新文件和replace.sh脚本拷贝到所有B机器上。然后batch-main.sh调用执行所有B机器上的replace.sh脚本，replace.sh脚本负责备份和执行替换删除操作。
batch-main.sh内容为：
#!/bin/bash# zipmkdir newfilecp /opt/flume/conf/log4j.properties newfile/cp /opt/flume/bin/run.sh newfile/cp /opt/flume/plugins.d/vipkid/lib/flume-ext-1.1-SNAPSHOT.jar newfile/tar -czvf newfile.tar newfile &amp;&amp;# scparray_str=`cat hosts`IPS=' 'array=($array_str)user=`whoami`echo 'scp start'for data in $&#123;array[@]&#125;do    echo 'host: '$data    scp newfile.tar $user@$data:~/    scp replace.sh $user@$data:~/    ssh $user@$data '/bin/tar -xvf ~/newfile.tar'done &amp;&amp;echo 'scp finished'# replaceecho 'replace start'for data in $&#123;array[@]&#125;do    echo 'host: '$data    ssh $user@$data 'sudo /bin/chown flume -R ~/newfile'    ssh $user@$data '/bin/bash ~/replace.sh'doneecho 'repalce finished'

replace.sh内容为：
#!/bin/bash# backupnow_time=`date +%Y%m%d%H%M%S.%N`sudo cp /opt/flume/conf/log4j.properties&#123;,.$now_time&#125;sudo cp /opt/flume/bin/run.sh&#123;,.$now_time&#125;if [ ! -f "/opt/flume/plugins.d/vipkid/lib/flume-ext-1.0-SNAPSHOT.jar" ];then  echo "flume-ext-1.0-SNAPSHOT.jar不存在"else  sudo cp /opt/flume/plugins.d/vipkid/lib/flume-ext-1.0-SNAPSHOT.jar&#123;,.$now_time&#125;fisudo cp /opt/flume/plugins.d/vipkid/lib/flume-ext-1.1-SNAPSHOT.jar&#123;,.$now_time&#125;# operationsudo cp -f ~/newfile/log4j.properties /opt/flume/conf/log4j.propertiessudo cp -r ~/newfile/run.sh /opt/flume/bin/run.shsudo rm -f /opt/plugins.d/vipkid/lib/flume-ext-1.0-SNAPSHOT.jarsudo cp -f ~/newfile/flume-ext-1.1-SNAPSHOT.jar /opt/flume/plugins.d/vipkid/lib/flume-ext-1.1-SNAPSHOT.jar

hosts内容为：
l-newman-server1.ops.beta.ali.dml-newman-server2.ops.beta.ali.dml-newman-server3.ops.beta.ali.dml-newman-server4.ops.beta.ali.dm

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>shell</tag>
        <tag>ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本之参数提示和校验</title>
    <url>/dev-shell-args-prompt-and-check/</url>
    <content><![CDATA[需求：有一个脚本，需要appname、ip、hostname、domain四个参数，并且都不能为空。
main.sh 脚本内容为：
#!/bin/bashfunction usage()&#123;    echo -e "-a -i -H -d are requierd    -a: appName    -i: ip    -h: hostname    -d: domain    "&#125;checkOpts () &#123;    local key=$1    local value=$2    [[ -z "$&#123;value&#125;" ]] \    &amp;&amp; echo -e "\033[31mFATAL: $&#123;key&#125; should not be empty! \033[0m" \    &amp;&amp; usage \    &amp;&amp; return 1    return 0&#125;function main()&#123;    while getopts "a:i:H:d:" opt;do        case $opt in            a) appname=$&#123;OPTARG&#125; &amp;&amp; echo "appname=$&#123;appname&#125;" ;;            i) ip=$&#123;OPTARG&#125; &amp;&amp; echo "ip=$&#123;ip&#125;" ;;            H) hostname=$&#123;OPTARG&#125; &amp;&amp; echo "hostname=$&#123;hostname&#125;" ;;            d) domain=$&#123;OPTARG&#125; &amp;&amp; echo "domain=$&#123;domain&#125;" ;;            *) usage &amp;&amp; exit 0 ;;        esac    done    read -p "确认参数无误，继续执行脚本？[Y/N]" input    if [[ $input = "y" || $input = "Y" ]];then        echo -e "\n------ continue... ------\n"    else        echo -e "\n------ exit ------\n"        exit 1    fi    ! checkOpts "appname" $&#123;appname&#125; &amp;&amp; exit 1    ! checkOpts "ip" $&#123;ip&#125; &amp;&amp; exit 1    ! checkOpts "hostname" $&#123;hostname&#125; &amp;&amp; exit 1    ! checkOpts "domain" $&#123;domain&#125; &amp;&amp; exit 1        # logic code&#125;main "$@"

问题来了，如果想要添加参数怎么办？最简单的思路就是修改getopts部分，添加新的参数。这里提供另外一个思路：提前留出一个other变量，用来接收多出的参数，这个other变量可以拆分成多个子变量，这样就具备了更好的通用性。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本之模拟面试</title>
    <url>/dev-shell-interview-mock/</url>
    <content><![CDATA[需求已知 quiz.txt 内容为：
介绍 Java 垃圾回收器的基本原理。介绍 HashMap 的实现原理。讲讲 Web 应用程序中的 Cookie 和 Session 是什么关系？你在生产实践中使用过哪些设计模式，是什么场景下使用的？为什么使用？Java 11 的 “本地变量类型推断” 听说过么？讲讲看。解释一下事务隔离级别。什么是一致性hash？看你做的项目不少，请介绍一个你认为最能表现你能力的项目吧。讲讲你最近开发的一个项目的业务背景和架构（或技术）。项目开发用的是瀑布模型还是敏捷模型，团队角色在什么时候、用什么工具和资源、做什么动作，以及是如何协作的。

需求：从 quiz.txt 文本中，随机选出5道题（不能重复），作为面试题目。面试结束后，发送面试题目到指定邮箱，方便回顾思考。


脚本#!/bin/bashcat /dev/null &gt; interview.txtecho "面试开始！"echo "面试开始！" &gt;&gt; interview.txtquiz=$(cat quiz.txt | grep -v -e '^[[:space:]]*$')sum=$(echo "$&#123;quiz&#125;" | wc -l)#echo $&#123;sum&#125;for i in `seq 1 5`;do  #echo "第$&#123;i&#125;题"  line=$(($&#123;RANDOM&#125;%$&#123;sum&#125;+1))  content=$(echo "$&#123;quiz&#125;" | sed -n $&#123;line&#125;p)  echo "$&#123;i&#125;、$&#123;content&#125;"  echo "$&#123;i&#125;、$&#123;content&#125;" &gt;&gt; interview.txt  quiz=$(echo "$&#123;quiz&#125;" | sed $&#123;line&#125;d)  sum=$((sum-1))  #echo $&#123;sum&#125;  read -p "是否继续下一题？[Y/N]" input  if [[ $input = "n" || $input = "N" ]];then    break  fidonecat interview.txt | mail -s "面试-`date +\%Y\%m\%d-\%H\%M\%S`" admin@voidking.com


]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本之循环读取文本</title>
    <url>/dev-shell-loop-read-file/</url>
    <content><![CDATA[需求已知mobile.txt为：
haojin 17625160000voidking 17625160001

需求：根据 mobile.txt 中的内容拼接成SQL，修改不同用户的手机号。例如：
update user set mobile="17625160000" where name="haojin";



简单实现脚本：
#!/bin/bashgrep -v "^$" mobile.txt | while read linedo  name=`echo $line | awk '&#123;print $1&#125;'`  mobile=`echo $line | awk '&#123;print $2&#125;'`  echo "update user set mobile=\"$&#123;mobile&#125;\" where name=\"$&#123;name&#125;\";"done

PS：不能使用for line in cat &#39;mobile.txt&#39;，因为这种方法会按照空格或换行切分文本。
更好的实现以上循环读取的方法，对于上面的需求是没有问题的。但是通用性不好，我们再来看另外一个需求。
已知service.txt内容为：
127.0.0.1 80127.0.0.1 8080192.168.56.101 8080

需求：探测service.txt中每个服务的连通性，并记录结果。
我们用同样的思路实现脚本：
#!/bin/bash#cat /dev/null &gt; detectresult.txt: &gt; detectresult.txtcat service.txt | while read linedo  ip=$(echo $line | awk '&#123;print $1&#125;')  port=$(echo $line | awk '&#123;print $2&#125;')  res=$(nc -w 2 -v $ip $port)  echo "$res" &gt;&gt; detectresult.txtdone

执行脚本后，我们发现结果文件中只有一条结果！这就不符合预期了。这是因为while使用重定向机制，while read line一次性将文件信息读入输入缓存，并按行赋值给变量line，直到输入缓存数据为空。而刚好nc、telnet、ssh等命令，会读取输入缓存中的所有数据，这就导致输入缓存被清空了，while循环结束。
解决办法：
res=$(nc -w 2 -v $ip $port &lt; /dev/null)

此外，因为管道符左右的命令都是在子shell中执行的，所以容易引起变量赋值不会在父shell中生效的问题。
因此，更好的脚本应该改成：
#!/bin/bashcat /dev/null &gt; detectresult.txtwhile read linedo  ip=$(echo $line | awk '&#123;print $1&#125;')  port=$(echo $line | awk '&#123;print $2&#125;')  res=$(nc -w 2 -v $ip $port &lt; /dev/null)  echo "$res" &gt;&gt; detectresult.txtdone &lt; service.txt

while read line进阶使用while read line的循环读取文本的方案，通用性已经很不错，可以应对大多数场景。但是，如果循环读取时，还需要和用户进行交互，那么就不适用了，下面看一个例子。
已知applist.txt内容为：
app1 running hbaapp2 stop hbeapp3 running hna

需求：对applist.txt中的app进行修改，修改每个app前都需要进行确认。
按照while的思路，编写 main.sh 内容为：
#!/bin/bashwhile read line;do  app_id=$(echo $line | awk '&#123;print $1&#125;')  idc=$(echo $app_id | awk -F'.' '&#123;print $NF&#125;')  #echo $&#123;app_id&#125;" "$&#123;idc&#125;  bash modify.sh $&#123;idc&#125; $&#123;app_id&#125;done &lt; applist.txt

modify.sh内容为：
#!/bin/bashidc=$1app_id=$2echo -e "idc: $&#123;idc&#125;"echo -e "app_id: $&#123;app_id&#125;"read -p "确认进行修改？[Y/N]" inputif [[ $input = "y" || $input = "Y" ]];then    echo -e "continue..."else    echo -e "exit"    exit 1fi# logic code

但是问题来了，最终执行效果不符合预期，modify.sh中的确认交互效果会失效！这是因为read会读取缓存中的内容，而不是等待交互。
那么，怎么解决这个问题？非要使用while read line的话，确实没有好的解决办法。但是，我们可以把while read line替换掉！新的 main.sh 如下：
#!/bin/bashfilename="applist.txt"lines=$(cat $&#123;filename&#125; | sed '/^$/d')linenum=$(echo "$&#123;lines&#125;" | wc -l)#echo -e "$&#123;lines&#125;"#echo -e "$&#123;linenum&#125;"index=1while [[ $&#123;index&#125; -le $&#123;linenum&#125; ]];do  #echo $&#123;index&#125;  line=$(echo "$&#123;lines&#125;" | sed -n "$&#123;index&#125;p")  app_id=$(echo $line | awk '&#123;print $1&#125;')  idc=$(echo $app_id | awk -F'.' '&#123;print $NF&#125;')  bash modify.sh $&#123;idc&#125; $&#123;app_id&#125;  index=$(($&#123;index&#125;+1))done

或者使用for循环：
#!/bin/bashfilename="applist.txt"lines=$(cat $&#123;filename&#125; | sed '/^$/d')linenum=$(echo "$&#123;lines&#125;" | wc -l)#echo -e "$&#123;lines&#125;"#echo -e "$&#123;linenum&#125;"for index in `seq 1 $&#123;lines&#125;`;do  #echo $&#123;index&#125;  line=$(echo "$&#123;lines&#125;" | sed -n "$&#123;index&#125;p")  app_id=$(echo $line | awk '&#123;print $1&#125;')  idc=$(echo $app_id | awk -F'.' '&#123;print $NF&#125;')  bash modify.sh $&#123;idc&#125; $&#123;app_id&#125;done


]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本之模块化</title>
    <url>/dev-shell-modules/</url>
    <content><![CDATA[脚本模块化脚本调用脚本的方法有两种，第一种是bash调用，在子shell里执行子脚本；第二种是引用调用，在当前脚本里执行子脚本。
脚本的模块化，两种调用方法都能实现，这里推荐第二种方法：引用调用。
引用调用时，父脚本和子脚本里的变量是共用的。


模块化设计1、创建modules目录，后续模块放入这个目录里
2、创建文件 modules/check.sh
read -p "确认进行检查？[Y/N]" inputif [[ $input = "y" || $input = "Y" ]];then    echo -e "\n------ continue... ------\n"    # check something    echo -e "\n------ finished ------\n"else    echo -e "\n------ 不检查 ------\n"fi

3、创建文件 modules/modify.sh
read -p "确认进行修改？[Y/N]" inputif [[ $input = "y" || $input = "Y" ]];then    echo -e "\n------ continue... ------\n"    # modify something    echo -e "\n------ finished ------\n"else    echo -e "\n------ 不修改 ------\n"fi

4、创建文件 main.sh 
#!/bin/bashfunction main()&#123;    # 参数提示和校验，代码省略    read -p "确认参数正确，继续执行脚本？[Y/N]" input    if [[ $input = "y" || $input = "Y" ]];then        echo -e "\n------ continue... ------\n"    else        echo -e "\n------ exit ------\n"        exit 1    fi    # 调用各个模块    source modules/check.sh    source modules/modify.sh&#125;main "$@"

其中，参数提示和校验部分代码参考 《Shell脚本之参数提示和校验》
交互部分模块化交互部分模块化，可以选择是否开启交互。
1、改写main.sh，抽象出函数
#!/bin/bashINTERACTIVE=trueCHECK_ENABLE=trueMODIFY_ENABLE=truefunction run() &#123;    func=$1    info=$2    if [[ $&#123;INTERACTIVE&#125; = false ]];then        $&#123;func&#125;        return 0    fi    read -p "$&#123;info&#125; [Y/N]" input    if [[ $input = "y" || $input = "Y" ]];then        $&#123;func&#125;    else        echo "放弃操作"        return 1    fi    return 0&#125;function nothing()&#123;    :&#125;function main()&#123;    # 参数提示和校验，代码省略    run nothing "确认参数正确，继续执行？"    [[ $? -ne 0 ]] &amp;&amp; exit 1        # 调用各个模块    [[ $&#123;CHECK_ENABLE&#125; = true ]] &amp;&amp; source modules/check.sh    [[ $&#123;MODIFY_ENABLE&#125; = true ]] &amp;&amp; source modules/modify.sh&#125;main "$@"

2、改写 modules/check.sh
echo -e "appname=$&#123;appname&#125;"function check()&#123;    # check something&#125;run check "确认进行检查？"

2、改写 modules/modify.sh
echo -e "appname=$&#123;appname&#125;"function modify()&#123;    # modify something&#125;run modify "确认进行修改？"

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell和Python互相调用</title>
    <url>/dev-shell-python/</url>
    <content><![CDATA[前言在linux上，最常用的编程语言是shell，其次是python。而这两种语言，很多时候需要配合使用。本文就研究一下这两种语言互相调用的方法。
参考文档：

《Shell脚本编程》
《Python基础》



shell调用python调用python脚本shell调用python脚本，直接调用即可，例如：
python main.py

调用python模块举个简单的例子，我们想要对curl获取的结果进行json格式化。假设安装了jq，可以使用jq命令：
curl -s "http://rap2api.taobao.org/app/mock/241888/example/1578301745121" | jq

假设没有安装jq，那我们可以使用python的 json.tool 模块：
curl -s "http://rap2api.taobao.org/app/mock/241888/example/1578301745121" | python -m json.tool

调用python函数1、test.py 内容为：
#!/usr/bin/env python#-*- coding:utf-8 -*-#scriptname:test.pydef helloworld():	return "helloworld"def echo():	print helloworld()def get_user():	return "haojin",100,"beijing"

2、shell中调用 test.py 中的方法
python -c 'import test;print test.helloworld()'python -c 'import test;test.echo()'res=$(python -c 'import test;print test.get_user()')name=$(echo $res | cut -d' ' -f1 | sed 's/,$//' | sed 's/^(//' | sed "s/\'//g")score=$(echo $res | cut -d' ' -f2 | sed 's/,$//')loc=$(echo $res | cut -d' ' -f3 | sed 's/)$//' | sed "s/\'//g")

python调用shell调用shell命令main.py内容为
import osval = os.system('ls -al')print val
其中，val的值是exit code。
执行main.py，python main.py
调用shell脚本1、main.sh 内容为
#!/bin/bashecho "hello"

2、python 调用 main.sh
import osval = os.system('sh main.sh')print val

获取shell指令的结果例子：获取echo命令结果。
import osres = os.popen('echo "hello"')print res.read()res.close()

高级例子：获取curl命令的返回结果，转化成dict。1、main.sh 内容为
#!/bin/bashcurl -s "http://rap2api.taobao.org/app/mock/241888/example/1578301745121"

2、python 调用 main.sh
import osimport jsonres = os.popen('sh main.sh')data = json.loads(res.read())res.close()print data['number']print data['string']print data['array'][0]['foo']
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>python</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本之安全删除</title>
    <url>/dev-shell-saferm/</url>
    <content><![CDATA[前言很多时候，我们会误删文件，那么一个回收站就很有必要了。看了一些回收站的实现，都比较复杂，干脆自己写一个。
思路：使用mv替换rm，把想要删除的文件暂时移动到回收站。


安全删除脚本1、编写安全删除脚本，saferm.sh
#!/bin/bashTRASHDIR="$&#123;HOME&#125;/.saferm/trash"[[ ! -d $&#123;TRASHDIR&#125; ]] &amp;&amp; mkdir -p $&#123;TRASHDIR&#125;function usage()&#123;    echo -e "    Brief: move directory and files to ~/.local/trash    Usage: alias rm=/path/to/saferm.sh            rm &lt;dir&gt;            rm &lt;file&gt;            rm &lt;file1&gt; &lt;file2&gt;    "&#125;function main()&#123;    local now=$(date "+%Y%m%d%H%M%S")    local destdir="$&#123;TRASHDIR&#125;/$&#123;now&#125;"    mkdir $&#123;destdir&#125;    local opt    while getopts "h" opt    do      case $opt in        h)          usage &amp;&amp; exit 0 ;;        \?)          usage &amp;&amp; exit 0 ;;      esac    done    local files="$*"    local successfiles=""    for file in $&#123;files&#125;;do        mv $&#123;file&#125; $&#123;destdir&#125; &amp;&amp; successfiles=$&#123;successfiles&#125;" "$&#123;file&#125;    done    if [[ -z "$&#123;successfiles&#125;" ]];then        echo -e "\033[31mNothing to do! Check the source filenames please!\033[0m"    else        echo -e "$&#123;successfiles&#125; have been moved to \033[31m$&#123;destdir&#125;\033[0m"    fi&#125;main "$@"

2、使用方法编辑 .bash_profile ，添加内容
# safermalias rm="/path/to/saferm.sh"
添加内容完成， source .bash_profile ，rm命令就被替换为saferm脚本了。
以上，安全删除的功能就完成了，自己偶尔手动清理下 TRASHDIR 中的文件。以下内容可选，是对该saferm脚本的补充。
清理回收站脚本1、清理回收站脚本，cleartrash.sh
#!/bin/bash# Clear files in trash that been removed 3 days ago.TRASHDIR="$&#123;HOME&#125;/.saferm/trash"CLEARLOG="$&#123;TRASHDIR&#125;/clear.log"[[ -d $&#123;TRASHDIR&#125; ]] \&amp;&amp; find $&#123;TRASHDIR&#125; -mindepth 1 -type d -mtime +2 \| xargs rm -rfv | tee -a $&#123;CLEARLOG&#125;

2、使用方法编辑 .bash_profile ，添加内容
# safermalias rm="/path/to/saferm.sh"alias cleartrash="/path/to/cleartrash.sh"
添加内容完成， source .bash_profile ，然后就可以使用 cleartrash 命令清理回收站了。
3、定时任务参考《Linux设置定时任务》，添加定时任务。
crontab -e，添加定时任务，每天晚上执行一次：
5 0 * * * /bin/bash /path/to/cleartrash.sh

进阶saferm.sh 脚本存在一个严重bug：无法删除文件名带空格的文件，甚至会误删文件。因为Shell默认以空格、Tab、回车作为值与值之间的分隔符，而不是做为文件名的一部分。如果文件名中带空格，就会被认为是多个文件。
修改 saferm.sh 如下：
#!/bin/bashTRASHDIR="$&#123;HOME&#125;/.saferm/trash"[[ ! -d $&#123;TRASHDIR&#125; ]] &amp;&amp; mkdir -p $&#123;TRASHDIR&#125;function usage()&#123;    echo -e "    Brief: Move directories or files to ~/.local/trash           You can move 1-3 files with wildcard. More is unsupported.            If file name contains space, use quotation mark please.    Usage: alias rm=/path/to/saferm.sh            rm &lt;dir&gt;            rm &lt;file&gt;            rm *.&lt;filetype&gt;            rm &lt;file1&gt; &lt;file2&gt; &lt;file3&gt;    "&#125;function main()&#123;    local now=$(date "+%Y%m%d%H%M%S")    local destdir="$&#123;TRASHDIR&#125;/$&#123;now&#125;"    mkdir $&#123;destdir&#125;    local opt    while getopts "h" opt    do      case $opt in        h)          usage &amp;&amp; exit 0 ;;        \?)          usage &amp;&amp; exit 0 ;;      esac    done    local file1="$1"    local file2="$2"    local file3="$3"    local file4="$4"    local successfiles=""    [[ -n "$&#123;file1&#125;" ]] &amp;&amp; mv "$&#123;file1&#125;" $&#123;destdir&#125; &amp;&amp; successfiles=$&#123;successfiles&#125;" "$&#123;file1&#125;    [[ -n "$&#123;file2&#125;" ]] &amp;&amp; mv "$&#123;file2&#125;" $&#123;destdir&#125; &amp;&amp; successfiles=$&#123;successfiles&#125;" "$&#123;file2&#125;    [[ -n "$&#123;file3&#125;" ]] &amp;&amp; mv "$&#123;file3&#125;" $&#123;destdir&#125; &amp;&amp; successfiles=$&#123;successfiles&#125;" "$&#123;file3&#125;    [[ -n "$&#123;file4&#125;" ]] &amp;&amp; echo -e "\033[31mYou can move 1-3 files with wildcard. More is unsupported.\033[0m"    if [[ -z "$&#123;successfiles&#125;" ]];then        echo -e "\033[31mNothing to do! Check the source filenames please!\033[0m"    else        echo -e "$&#123;successfiles&#125; have been moved to \033[31m$&#123;destdir&#125;\033[0m"    fi&#125;main "$@"

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本编程——上</title>
    <url>/dev-shell-script-program-0/</url>
    <content><![CDATA[Shell简介Shell 是什么？Shell 这个单词的原意是“外壳”，跟 kernel（内核）相对应，比喻内核外面的一层，即用户跟内核交互的对话界面。
具体来说，Shell 这个词有多种含义。
首先，Shell 是一个程序，提供一个与用户对话的环境。这个环境只有一个命令提示符，让用户从键盘输入命令，所以又称为命令行环境（command line interface，简写为 CLI）。Shell 接收到用户输入的命令，将命令送入操作系统执行，并将结果返回给用户。  
其次，Shell 是一个命令解释器，解释用户输入的命令。它支持变量、条件判断、循环操作等语法，所以用户可以用 Shell 命令写出各种小程序，又称为脚本（script）。这些脚本都通过 Shell 的解释执行，而不通过编译。  
最后，Shell 是一个工具箱，提供了各种小工具，供用户方便地使用操作系统的功能。  
对于用户来说，Shell是最重要的实用程序，深入了解和熟练掌握Shell的特性极其使用方法，是用好Unix/Linux系统的关键。可以说，Shell使用的熟练程度反映了用户对Unix/Linux使用的熟练程度。
Shell 有两种执行命令的方式：交互式（Interactive）：解释执行用户的命令，用户输入一条命令，Shell就解释执行一条。批处理（Batch）：用户事先写一个Shell脚本，其中有很多条命令，让Shell一次把这些命令执行完。
Shell脚本是解释型语言，不需要编译。Shell程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到Shell提示符下执行。
Unix/Linux 上常见的 Shell 脚本解释器有 bash、sh、csh、ksh 等，习惯上把它们称作一种Shell。我们常说有多少种 Shell，其实说的是 Shell 脚本解释器。
Bash 是大多数 Linux 标准默认的 Shell，因此是我们学习的重点。
更多内容，请参考阮一峰前辈的《Bash 脚本教程》。


starthelloworld1、新建helloworld.sh，vim helloworld.sh内容为：
#!/bin/bashecho "Hello World !"

#! 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种Shell。echo命令用于向窗口输出文本。
2、添加执行权限chmod +x helloworld.sh
3、执行脚本./helloworld.sh
PS：输入gg跳到首行，.,$d，表示从当前行到末行全部删除掉。或者，1,$d，表示从首行到末行全部删除掉。
echoecho是Shell的一个内部指令，用于在屏幕上打印出指定的字符串。
#!/bin/bash# 显示转义字符echo "\"It is a test\""# 显示变量name="VoidKing"echo "Welcome, $name"# 变量与其它字符相连时需要使用大括号month=8echo "$&#123;month&#125;-1-2009"# 显示换行echo -e "OK!\n"echo "It is a test"# 显示不换行echo -e "OK!\c"echo "It is a test"# 显示结果重定向至文件echo "It is a test" &gt; myfile# 原样输出字符串echo '$name\"'# 显示命令执行结果echo `date`

printfprintf 命令用于格式化输出， 是echo命令的增强版。它是C语言printf()库函数的一个有限的变形，并且在语法上有些不同。
注意：printf 由 POSIX 标准所定义，移植性要比 echo 好。
#!/bin/bash# format-string为双引号printf "%d %s\n" 1 "abc"# 单引号与双引号效果一样 printf '%d %s\n' 1 "abc" # 没有引号也可以输出printf %s abcdef# 一个格式多个参数printf %s abc defprintf "%s\n" abc defprintf "%s %s %s\n" a b c d e f g h i j# %s默认为空，%d默认为0printf "%s and %d \n" # 如果以%d的格式来显示字符串，那么会有警告，并且默认置为 0printf "always prints %s,%d\n" Hello Shell

交互使用 read 命令从 stdin 获取输入并赋值给 PERSON 变量，最后在 stdout 上输出。
#!/bin/bashecho "What is your name?"read PERSONecho "Hello, $PERSON"

重定向#!/bin/bash# stdout重定向到filels -l &gt; filels -l &gt;&gt; file# stdout和stderr合并后重定向到myfilels -l &gt; myfile 2&gt;&amp;1ls -l &gt;&gt; myfile 2&gt;&amp;1# 屏蔽 stdout 和 stderrls -l &gt; /dev/null 2&gt;&amp;1

#!/bin/bashcat &lt;&lt; EOFMy name is VoidKing.I'm good at programming.EOF

包含脚本url="http://www.voidking.com"

#!/bin/bash. ./helloworld.shsource ./helloworld.sh. ./url.shecho $url

变量基本变量#!/bin/bash# 定义变量your_name="voidking"your_age=25# 显示变量echo -e "your name is $&#123;your_name&#125; \n welcome to shell world"echo "your age is $&#123;your_age&#125;"your_email="voidking@qq.com"# 设置your_email为只读变量readonly your_emailecho "your email is $your_email"your_address="中国吉林长春"# 删除变量unset your_address

注意，变量名和等号之间不能有空格，这可能和我们熟悉的所有编程语言都不一样。shell里没有多行注释，只能每一行加一个#号。
上面的脚本中，我们使用了一些中文。在CentOS7.2中，如果出现乱码，那么，我们需要添加CentOS7.2的中文支持。locale，显示LANG=C。
vim /etc/locale.conf，修改locale.conf如下：
LANG="zh_CN.UTF-8"LANGUAGE="zh_CN.UTF-8:zh_CN.UTF-8:zh_CN"SUPPORTED="zh_CN.UTF-8:zh_CN:zh:en_US.UTF-8:en_US:en"SYSFONT="lat0-sun16"

locale，显示：
LANG=zh_CN.UTF-8LC_CTYPE="zh_CN.UTF-8"LC_NUMERIC="zh_CN.UTF-8"LC_TIME="zh_CN.UTF-8"LC_COLLATE="zh_CN.UTF-8"LC_MONETARY="zh_CN.UTF-8"LC_MESSAGES="zh_CN.UTF-8"LC_PAPER="zh_CN.UTF-8"LC_NAME="zh_CN.UTF-8"LC_ADDRESS="zh_CN.UTF-8"LC_TELEPHONE="zh_CN.UTF-8"LC_MEASUREMENT="zh_CN.UTF-8"LC_IDENTIFICATION="zh_CN.UTF-8"LC_ALL=

特殊变量#!/bin/bashecho "Process ID: $$"echo "File Name: $0"echo "First Parameter: $1"echo "Second Parameter: $2"echo "Quoted Values: $@"echo "Quoted Values: $*"echo "Total Number of Parameters: $#"


变量替换#!/bin/bashecho $&#123;var:-"Variable is not set"&#125;echo "1 - Value of var is $&#123;var&#125;"echo $&#123;var:="Variable is not set"&#125;echo "2 - Value of var is $&#123;var&#125;"unset varecho $&#123;var:+"This is default value"&#125;echo "3 - Value of var is $var"var="Prefix"echo $&#123;var:+"This is default value"&#125;echo "4 - Value of var is $var"echo $&#123;var:?"Print this message"&#125;echo "5 - Value of var is $&#123;var&#125;"

命令替换#!/bin/bashDATE=`date`echo "Date is $DATE"USERS=`who | awk '&#123;print $1&#125;'`echo "Logged in user are $USERS"UP=`date ; uptime`echo "Uptime is $UP"

字符串#!/bin/bash# 单引号字符串中的变量无效，任何字符都会原样输出# 单引号字串中不能出现单引号（对单引号使用转义符后也不行）str='this is a string'# 双引号里可以有变量，可以出现转义符str="Hello, I know your are \"$your_name\"! \n"# 拼接字符串your_name="voidking"greeting="hello, "$your_name" !"greeting_1="hello, $&#123;your_name&#125; !"echo $greeting $greeting_1# 获取字符串长度string="abcd"echo $&#123;#string&#125;# 提取子字符串string="alibaba is a great company"echo $&#123;string:1:4&#125; # 查找子字符串string="alibaba is a great company"echo `expr index "$string" is`

数组#!/bin/shname[0]="VoidKing0"name[1]="VoidKing1"name[2]="VoidKing2"echo "Index0: $&#123;name[0]&#125;"echo "Index1: $&#123;name[1]&#125;"echo "All names: $&#123;name[*]&#125;"echo "All names: $&#123;name[@]&#125;"age=(24 25 26)age[2]=25# 取得数组元素的个数name_length=$&#123;#name[@]&#125;age_length=$&#123;#age[*]&#125;echo "name_length: $name_length,age_length: $age_length"# 取得数组单个元素的长度lengthn=$&#123;#name[0]&#125;echo "Index0 length: $lengthn"

源码分享https://github.com/voidking/shell.git
书签Linux Shell脚本教程：30分钟玩转Shell脚本编程http://c.biancheng.net/cpp/shell/
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell脚本编程——下</title>
    <url>/dev-shell-script-program-1/</url>
    <content><![CDATA[运算符算术运算符#!/bin/sha=10b=20echo "a=$a, b=$b"val=`expr $a + $b`echo "a + b : $val"val=`expr $a - $b`echo "a - b : $val"val=`expr $a \* $b`echo "a * b : $val"val=`expr $b / $a`echo "b / a : $val"val=`expr $b % $a`echo "b % a : $val"if [ $a == $b ]then   echo "a is equal to b"fiif [ $a != $b ]then   echo "a is not equal to b"fi



关系运算符#!/bin/sha=10b=20echo "a=$a, b=$b"if [ $a -eq $b ]then   echo "$a -eq $b : a is equal to b"else   echo "$a -eq $b: a is not equal to b"fiif [ $a -ne $b ]then   echo "$a -ne $b: a is not equal to b"else   echo "$a -ne $b : a is equal to b"fiif [ $a -gt $b ]then   echo "$a -gt $b: a is greater than b"else   echo "$a -gt $b: a is not greater than b"fiif [ $a -lt $b ]then   echo "$a -lt $b: a is less than b"else   echo "$a -lt $b: a is not less than b"fiif [ $a -ge $b ]then   echo "$a -ge $b: a is greater or  equal to b"else   echo "$a -ge $b: a is not greater or equal to b"fiif [ $a -le $b ]then   echo "$a -le $b: a is less or  equal to b"else   echo "$a -le $b: a is not less or equal to b"fi


布尔运算符#!/bin/sha=10b=20echo "a=$a, b=$b"if [ $a != $b ]then   echo "$a != $b : a is not equal to b"else   echo "$a != $b: a is equal to b"fiif [ $a -lt 100 -a $b -gt 15 ]then   echo "$a -lt 100 -a $b -gt 15 : returns true"else   echo "$a -lt 100 -a $b -gt 15 : returns false"fiif [ $a -lt 100 -o $b -gt 100 ]then   echo "$a -lt 100 -o $b -gt 100 : returns true"else   echo "$a -lt 100 -o $b -gt 100 : returns false"fiif [ $a -lt 5 -o $b -gt 100 ]then   echo "$a -lt 100 -o $b -gt 100 : returns true"else   echo "$a -lt 100 -o $b -gt 100 : returns false"fi

字符串运算符#!/bin/sha="abc"b="efg"echo "a=$a, b=$b"if [ $a = $b ]then   echo "$a = $b : a is equal to b"else   echo "$a = $b: a is not equal to b"fiif [ $a != $b ]then   echo "$a != $b : a is not equal to b"else   echo "$a != $b: a is equal to b"fiif [ -z $a ]then   echo "-z $a : string length is zero"else   echo "-z $a : string length is not zero"fiif [ -n $a ]then   echo "-n $a : string length is not zero"else   echo "-n $a : string length is zero"fiif [ $a ]then   echo "$a : string is not empty"else   echo "$a : string is empty"fi

文件测试运算符#!/bin/shfile="../start/helloworld.sh"if [ -r $file ]then   echo "File has read access"else   echo "File does not have read access"fiif [ -w $file ]then   echo "File has write permission"else   echo "File does not have write permission"fiif [ -x $file ]then   echo "File has execute permission"else   echo "File does not have execute permission"fiif [ -f $file ]then   echo "File is an ordinary file"else   echo "This is sepcial file"fiif [ -d $file ]then   echo "File is a directory"else   echo "This is not a directory"fiif [ -s $file ]then   echo "File size is not zero"else   echo "File size is zero"fiif [ -e $file ]then   echo "File exists"else   echo "File does not exist"fi


条件if…fi#!/bin/sha=10b=20echo "a=$a, b=$b"if [ $a == $b ]then   echo "a is equal to b"fiif [ $a != $b ]then   echo "a is not equal to b"fi

if…else…fi#!/bin/sha=10b=20echo "a=$a, b=$b"if [ $a == $b ]then   echo "a is equal to b"else   echo "a is not equal to b"fi

if…elif…fi#!/bin/sha=10b=20echo "a=$a, b=$b"if [ $a == $b ]then   echo "a is equal to b"elif [ $a -gt $b ]then   echo "a is greater than b"elif [ $a -lt $b ]then   echo "a is less than b"else   echo "None of the condition met"fi

testtest 命令用于检查某个条件是否成立，与方括号[]类似。
#!/bin/shnum1=$[2*3]num2=$[1+5]if test $[num1] -eq $[num2]then    echo 'The two numbers are equal!'else    echo 'The two numbers are not equal!'fi


casecase … esac 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构。
#!/bin/shecho -e "Input a number between 1 to 4: \c"read aNumcase $aNum in    1)  echo 'You select 1'    ;;    2)  echo 'You select 2'    ;;    3)  echo 'You select 3'    ;;    4)  echo 'You select 4'    ;;    *)  echo 'You do not select a number between 1 to 4'    ;;esac

#!/bin/bashoption="$&#123;1&#125;"case $&#123;option&#125; in    -f) FILE="$&#123;2&#125;"        echo "File name is $FILE"    ;;    -d) DIR="$&#123;2&#125;"        echo "Dir name is $DIR"    ;;    *)         echo "`basename $&#123;0&#125;`:usage: [-f file] | [-d directory]"        exit 1 # Command to come out of the program with status 1    ;;esac

循环for#!/bin/bashfor loop in 1 2 3 4 5do    echo "The value is: $loop"donefor str in 'This is a string'do    echo $strdonefor FILE in $HOME/.bash*do   echo $FILEdone

while#!/bin/bashCOUNTER=0while ( $COUNTER &lt;= 5 )do    COUNTER=`expr $COUNTER + 1`    echo $COUNTERdonewhile [ $COUNTER -lt 10 ]do    COUNTER=`expr $COUNTER + 1`    echo $COUNTERdoneecho 'type &lt;CTRL-D&gt; to terminate'echo -n 'enter your most liked film: 'while read FILMdo    echo "Yeah! great film the $FILM"done

until#!/bin/basha=0until [ ! $a -lt 10 ]do    echo $a    a=`expr $a + 1`done

for_break#!/bin/bashfor var1 in 1 2 3do    for var2 in 0 5    do        if [ $var1 -eq 2 -a $var2 -eq 0 ]        then            break 2        else            echo "$var1 $var2"        fi    donedone

while_break#!/bin/bashwhile :do    echo -n "Input a number between 1 to 5: "    read aNum    case $aNum in        1|2|3|4|5) echo "Your number is $aNum!"        ;;        *) echo "You do not select a number between 1 to 5, game is over!"            break        ;;    esacdone

for_continue#!/bin/bashNUMS="1 2 3 4 5 6 7"for NUM in $NUMSdo    Q=`expr $NUM % 2`    if [ $Q -eq 0 ]    then        echo "Number is an even number!!"        continue    fi    echo "Found odd number"done

while_continue#!/bin/bashwhile :do    echo -n "Input a number between 1 to 5: "    read aNum    case $aNum in        1|2|3|4|5) echo "Your number is $aNum!"        ;;        *) echo "You do not select a number between 1 to 5!"            continue            echo "Game is over!"        ;;    esacdone

函数hello#!/bin/bash# Define your function hereHello () &#123;   echo "http://www.voidking.com"&#125;# Invoke your functionHello

return#!/bin/bashfunWithReturn()&#123;    echo "The function is to get the sum of two numbers..."    echo -n "Input first number: "    read aNum    echo -n "Input another number: "    read anotherNum    echo "The two numbers are $aNum and $anotherNum !"    return $(($aNum+$anotherNum))&#125;funWithReturn# Capture value returnd by last commandret=$?echo "The sum of two numbers is $ret !"

two_function#!/bin/bash# Calling one function from anothernumber_one () &#123;    echo "Url_1 is http://www.voidking.com"    number_two&#125;number_two () &#123;    echo "Url_2 is http://www.baidu.com"&#125;number_onenumber_three () &#123;    echo "Url_3 is http://www.baidu.com"&#125;unset -f number_three

参数#!/bin/bashfunWithParam()&#123;    echo "The value of the first parameter is $1 !"    echo "The value of the second parameter is $2 !"    echo "The value of the tenth parameter is $4 !"    # 参数个数    echo "The amount of the parameters is $# !"    # 传递给函数的所有参数      echo "The string of the parameters is $* !"  &#125;funWithParam 1 2 3 4

源码分享https://github.com/voidking/shell.git
书签Linux Shell脚本教程：30分钟玩转Shell脚本编程http://c.biancheng.net/cpp/shell/
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>用div模拟input和textarea</title>
    <url>/dev-simulate-input-by-div/</url>
    <content><![CDATA[前言先看需求：在输入评论的时候，当评论长度超过一行时，自动换行，同时评论框变高，效果如下。
然而，input并没有自动换行属性，也就无法实现这个效果；使用textarea，写js控制row？想想就不够优雅！
经评估，使用div模拟输入框，是最佳方案。


html&lt;div class="input-body"&gt;    &lt;div class="left"&gt;        &lt;div class="input"&gt;            &lt;p id="input-comment" contenteditable="true"&gt;&lt;/p&gt;            &lt;p id="input-placeholder"&gt;请输入评论内容&lt;/p&gt;        &lt;/div&gt;                  &lt;/div&gt;    &lt;div class="right"&gt;        &lt;span id="send"&gt;发送&lt;/span&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;div class="input-body-back"&gt;&lt;/div&gt;

scss.input-body&#123;    position: fixed;    border-top: 1px solid #e5e5e5;    border-bottom: 1px solid #e5e5e5;    width: 100%;    bottom: 0;    background: #f7f7f7;    font-size: 1.2rem;    .left&#123;        display: inline-block;        vertical-align: bottom;        width: 80%;        text-align: center;        padding: .5rem;        .input&#123;            position: relative;            #input-comment&#123;                display: inline-block;                width: 92%;                min-height: 2rem;                line-height: 2rem;                text-align: left;                padding: .2rem .5rem;                background: #fff;                border: 1px solid #e5e5e5;                border-radius: 3px;                outline: 0;            &#125;               #input-placeholder&#123;                position: absolute;                top: .5rem;                left: .8rem;                color: #8E8E93;            &#125;        &#125;           &#125;    .right&#123;        display: inline-block;        vertical-align: bottom;        width: 15%;        height: 2.5rem;        text-align: center;        font-weight: bold;        #send&#123;            margin-right: 1rem;            color: #8E8E93;            &amp;.active&#123;                color: #146AF3;            &#125;;        &#125;    &#125;&#125;.input-body-back&#123;    height: 4rem;&#125;

js$('#input-comment').on('input propertychange',function()&#123;    var str = $(this).html();    if(str == '')&#123;        $('#send').removeClass('active');        $('#input-placeholder').show();    &#125;else&#123;        $('#send').addClass('active');        $('#input-placeholder').hide();    &#125;&#125;);$('#send').on('click',function()&#123;    if(!$(this).hasClass('active'))&#123;        return;    &#125;    var comment = $('#input-comment').html();    if(comment.length &gt; 500)&#123;        alert('字数过多，请删减');        return;    &#125;    // ajax请求&#125;);


书签div模拟textarea文本域轻松实现高度自适应http://www.zhangxinxu.com/wordpress/2010/12/div-textarea-height-auto/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>用div模拟select</title>
    <url>/dev-simulate-select-by-div/</url>
    <content><![CDATA[前言四不四傻？有select不用，干嘛要用div来模拟select呢？下面来看一个问题：
请问不使用chosen等插件，也不使用div模拟select，通过html和css，有没有办法限制select下拉框的高度。默认显示20条option，我想改成5条该怎么处理？
答案是，无解！使用插件？找了十几款selectbox插件，都不满意！要么封装起来麻烦，要么根本不提供限制下拉框长度的功能。
评估了一下，还是自己模拟一个select选择框更靠谱。


select日期选择html&lt;div class="birthday"&gt;    &lt;label&gt;生日：&lt;/label&gt;    &lt;select name="month" id="month"&gt;        &lt;option value="1"&gt;1&lt;/option&gt;        &lt;option value="2"&gt;2&lt;/option&gt;        &lt;option value="3"&gt;3&lt;/option&gt;        &lt;option value="4"&gt;4&lt;/option&gt;        &lt;option value="5"&gt;5&lt;/option&gt;        &lt;option value="6"&gt;6&lt;/option&gt;        &lt;option value="7"&gt;7&lt;/option&gt;        &lt;option value="8"&gt;8&lt;/option&gt;        &lt;option value="9"&gt;9&lt;/option&gt;        &lt;option value="10"&gt;10&lt;/option&gt;        &lt;option value="11"&gt;11&lt;/option&gt;        &lt;option value="12"&gt;12&lt;/option&gt;    &lt;/select&gt;月    &lt;select name="day" id="day"&gt;    &lt;/select&gt;日&lt;/div&gt;

js$('#month').change(function()&#123;    changeDay();&#125;);function changeDay()&#123;    var $day = $('#day');    var month = $('#month').val();    var data = [];              if(month==2)&#123;        for (var i = 1; i &lt;= 29; i++) &#123;            data.push(i);        &#125;    &#125;else if(month==1 || month==3 || month==5 || month==7 || month==8 || month==10 || month==12)&#123;        for (var i = 1; i &lt;= 31; i++) &#123;            data.push(i);        &#125;    &#125;else if(month==4 || month==6 || month==9 || month==11)&#123;        for (var i = 1; i &lt;= 30; i++) &#123;            data.push(i);        &#125;    &#125;    var html = '';    data.forEach( function(element, index) &#123;        html += '&lt;option value='+element+'&gt;'+element+'&lt;/option&gt;';    &#125;);    $day.html(html);    $day.find('option').first().checked;&#125;

div日期选择html&lt;div class="birthday2"&gt;    &lt;label&gt;生日：&lt;/label&gt;    &lt;div class="simulate-select" id="month-box"&gt;        &lt;input class="input" name="month2" type="hidden" value="1"&gt;        &lt;div class="check"&gt;1&lt;/div&gt;月        &lt;ul class="items"&gt;            &lt;li&gt;1&lt;/li&gt;            &lt;li&gt;2&lt;/li&gt;            &lt;li&gt;3&lt;/li&gt;            &lt;li&gt;4&lt;/li&gt;            &lt;li&gt;5&lt;/li&gt;            &lt;li&gt;6&lt;/li&gt;            &lt;li&gt;7&lt;/li&gt;            &lt;li&gt;8&lt;/li&gt;            &lt;li&gt;9&lt;/li&gt;            &lt;li&gt;10&lt;/li&gt;            &lt;li&gt;11&lt;/li&gt;            &lt;li&gt;12&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;div class="simulate-select" id="day-box"&gt;        &lt;input class="input" name="day2" type="hidden" value="1"&gt;        &lt;div class="check"&gt;1&lt;/div&gt;日        &lt;ul class="items"&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;/div&gt;

scss.simulate-select&#123;    position: relative;    display: inline-block;    .check&#123;        display: inline-block;        width: 40px;        text-align: center;        border: 1px solid #333;    &#125;    .items&#123;        display: none;        list-style: none;        position: absolute;        top: 100%;        left: 0;        height: 100px;        overflow-y: auto;        margin: -1px 0 0 0;        padding: 0;        width: 40px;        text-align: center;        border: 1px solid #333;        background: #fff;        li&#123;            &amp;.active&#123;                background: #eee;                color: #fff;            &#125;        &#125;        &amp;.active&#123;            display: block;        &#125;    &#125;&#125;

jsselectMonth2();changeDay2();selectDay2();function selectMonth2()&#123;    var self = this;    var $month = $('#month-box');    $('#month-box').on('click','.check',function(event)&#123;        $('#day-box').find('.items').removeClass('active');        if($month.find('.items').hasClass('active'))&#123;            $month.find('.items').removeClass('active');        &#125;else&#123;            $month.find('.items').addClass('active');        &#125;        event.stopPropagation();    &#125;);    $('#month-box').on('click','li',function()&#123;        var month = $(this).html();        $month.find('.input').val(month);        $month.find('.check').html(month);        $month.find('.items').removeClass('active');        changeDay2();    &#125;);    $(document).click(function()&#123;        $month.find('.items').removeClass('active');    &#125;);&#125;function changeDay2()&#123;    var $month = $('#month-box');    var $day = $('#day-box');    var month = $month.find('.input').val();    var data = [];          if(month==2)&#123;        for (var i = 1; i &lt;= 29; i++) &#123;            data.push(i);        &#125;    &#125;else if(month==1 || month==3 || month==5 || month==7 || month==8 || month==10 || month==12)&#123;        for (var i = 1; i &lt;= 31; i++) &#123;            data.push(i);        &#125;    &#125;else if(month==4 || month==6 || month==9 || month==11)&#123;        for (var i = 1; i &lt;= 30; i++) &#123;            data.push(i);        &#125;    &#125;    var html = '';    data.forEach( function(element, index) &#123;        html += '&lt;li&gt;'+element+'&lt;/li&gt;';    &#125;);    $day.find('.items').html(html);    $day.find('.check').html('1');&#125;function selectDay2()&#123;    var $day = $('#day-box');    $('#day-box').on('click','.check',function(event)&#123;        $('#month-box').find('.items').removeClass('active');        if($day.find('.items').hasClass('active'))&#123;            $day.find('.items').removeClass('active');        &#125;else&#123;            $day.find('.items').addClass('active');        &#125;        event.stopPropagation();    &#125;);    $('#day-box').on('click','li',function()&#123;        var day = $(this).html();        $day.find('.input').val(day);        $day.find('.check').html(day);        $day.find('.items').removeClass('active');    &#125;);    $(document).click(function()&#123;        $day.find('.items').removeClass('active');    &#125;);&#125;

效果图
源码https://github.com/voidking/nodebase/blob/master/views/weixin/love.htmlhttps://github.com/voidking/nodebase/blob/master/public/scss/weixin/love.scsshttps://github.com/voidking/nodebase/blob/master/public/js/weixin/love.js
后记我相信，一定有更简单的方法实现限制select下拉框的高度。如果在调试时，可以捕捉到下拉框，就可以设置该下拉框的高度了。但是，尝试了各种办法都没有捕捉到，奇怪。不管了，暂时这样，以后发现了更好的解决办法再补上。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>css</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>软件版本号命名规则</title>
    <url>/dev-software-version-name/</url>
    <content><![CDATA[前言有了版本控制工具，版本命名，势必是要学习一下的。
以下内容转载自百度经验，地址：http://jingyan.baidu.com/article/8cdccae9659f5c315413cde6.html
版本命名规范软件版本号有四部分组成，第一部分为主版本号，第二部分为次版本号，第三部分为修订版本号，第四部分为日期版本号加希腊字母版本号，希腊字母版本号共有五种，分别为base、alpha、beta 、RC 、 release。



上一级有变动时，下级要归零。

软件版本阶段说明
Base：此版本表示该软件仅仅是一个假页面链接，通常包括所有的功能和页面布局，但是页面中的功能都没有做完整的实现，只是做为整体网站的一个基础架构。

Alpha：软件的初级版本，表示该软件在此阶段以实现软件功能为主，通常只在软件开发者内部交流，一般而言，该版本软件的Bug较多，需要继续修改，是测试版本。测试人员提交Bug经开发人员修改确认之后，发布到测试网址让测试人员测试，此时可将软件版本标注为alpha版。

Beta：该版本相对于Alpha版已经有了很大的进步，消除了严重错误，但还需要经过多次测试来进一步消除，此版本主要的修改对象是软件的UI。修改的Bug经测试人员测试确认后可发布到外网上，此时可将软件版本标注为 beta版。

RC：该版本已经相当成熟了，基本上不存在导致错误的Bug，与即将发行的正式版本相差无几。

Release：该版本意味“最终版本”，在前面版本的一系列测试版之后，终归会有一个正式的版本，是最终交付用户使用的一个版本。该版本有时也称标准版。


版本号修改规则
主版本号：当功能模块有较大的变动，比如增加模块或是整体架构发生变化。此版本号由项目决定是否修改。

次版本号：相对于主版本号而言，次版本号的升级对应的只是局部的变动，但该局部的变动造成程序和以前版本不能兼容，或者对该程序以前的协作关系产生了破坏，或者是功能上有大的改进或增强。此版本号由项目决定是否修改。

修订版本号：一般是Bug的修复或是一些小的变动或是一些功能的扩充，要经常发布修订版，修复一个严重 Bug 即可发布一个修订版。此版本号由项目经理决定是否修改。

日期版本号：用于记录修改项目的当前日期，每天对项目的修改都需要更改日期版本号。此版本号由开发人员决定是否修改。

希腊字母版本号：此版本号用于标注当前版本的软件处于哪个开发阶段，当软件进入到另一个阶段时需要修改此版本号。此版本号由项目决定是否修改。


后记本文作者的描述非常详细，受教了。以后郝同学上传项目，会添加一个tag，用来标记版本。
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring事务支持</title>
    <url>/dev-spring-affair/</url>
    <content><![CDATA[概述Spring的事务管理不需要与任何特定的事务API耦合。Spring同时支持编程式事务策略和声明式事务策略，大部分时候都采用声明式事务策略。声明式事务管理的优势非常明显：代码中无需关注事务逻辑，让Spring声明式事务管理负责事务逻辑，声明式事务管理无需与具体的事务逻辑耦合，可以方便地在不同事务逻辑之间切换。
声明式事务逻辑的配置方式，通常有以下4中：1、使用TransactionProxyFactoryBean为目标Bean生成事务代理的配置。此方式是最传统、配置文件最臃肿、最难以阅读的方式。2、采用Bean继承的事务代理配置方式，比较简洁，但仍然是增量式配置。3、采用BeanNameAutoProxyCreator，根据Bean Name自动生成事务代理的方式。这是直接利用Spring的AOP框架配置事务代理的方式，需要对Spring的AOP框架有所理解。但这种方式避免了增量式方式，效果非常不错。4、采用DefaultAdvisorAutoProxyCreator，直接利用Spring的AOP框架配置事务代理的方式，效果非常不错，只是这种配置方式的可读性不如第3种方式。

参考文档《Java EE基础实用教程》，郑阿奇主编
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP</title>
    <url>/dev-spring-aop/</url>
    <content><![CDATA[从代理机制初探AOPpackage com.voidking.aop;import java.util.logging.*;public class HelloSpeaker &#123;	private Logger logger = Logger.getLogger(this.getClass().getName());	public void hello(String name)	&#123;		logger.log(Level.INFO, "hello method starts...");		System.out.println("hello,"+name);		logger.log(Level.INFO, "hello method ends...");	&#125;&#125;
在HelloSpeaker类中，当执行hello()方法时，程序员希望该方法执行开始与执行完毕时都留下日志。最简单的做法是上面的程序设计，在方法执行前后加上日志动作。
然而对于HelloSpeaker类来说，日志的这种动作并不属于HelloSpeaker的逻辑，这使得HelloSpeaker增加了额外的职责。

如果程序中这种日志动作到处都有，以上的写法势必造成程序员必须到处撰写这些日志动作的代码。这将使得维护日志代码的困难加大。如果需要的服务不只是日志动作，有一些非类本身职责的相关动作也混入到类中，如权限检查、事务管理等，会使得类的负担加重，甚至混淆类本身的职责。
另一方面，使用以上的写法，如果有一天不再需要日志（或权限检查、交易管理等）服务，将需要修改所有留下日志动作的程序，无法简单地将这些相关服务从现有的程序中移除。
可以使用代理（Proxy）机制来解决这个问题，有两种代理方式：静态代理（static proxy）和动态代理（dynamic proxy）。
在静态代理的实现中，代理类与被代理的类必须实现同一个接口。在代理类中可以实现记录等相关服务，并在需要的时候再呼叫被代理类。这样被代理类就可以仅仅保留业务相关的职责了。
举个简单的例子，首先定义一个IHello接口：
package com.voidking.aop;public interface IHello &#123;	public void hello(String name);&#125;

然后让实现业务逻辑的HelloSpeaker2类实现IHello接口：
package com.voidking.aop;public class HelloSpeaker2 implements IHello &#123;		@Override	public void hello(String name) &#123;		// TODO Auto-generated method stub		System.out.println("hello,"+name);	&#125;&#125;

代理类HelloProxy同样要实现IHello接口：
package com.voidking.aop;import java.util.logging.Level;import java.util.logging.Logger;public class HelloProxy implements IHello &#123;	private Logger logger = Logger.getLogger(this.getClass().getName());	private IHello helloObject;	public  HelloProxy(IHello helloObject) &#123;		// TODO Auto-generated constructor stub		this.helloObject = helloObject;	&#125;			@Override	public void hello(String name) &#123;		// TODO Auto-generated method stub		log("hello method starts...");		helloObject.hello(name);		log("hello method ends...");	&#125;		private void log(String msg)	&#123;		logger.log(Level.INFO, msg);	&#125;&#125;
写一个测试程序来看看效果：
package com.voidking.aop;public class ProxyDemo &#123;	public static void main(String[] args) &#123;		IHello proxy = new HelloProxy(new HelloSpeaker2());		proxy.hello("Justin");	&#125;&#125;

这是静态代理的基本示例，但是可以看到，代理类的一个接口只能服务于一种类型的类，而且如果要代理的方法很多，势必要为每个方法进行代理。静态代理在程序规模稍大时必定无法胜任。
动态代理JDK1.3之后加入了可协助开发动态代理功能的API等相关类别，不需要为特定类和方法编写特定代理类，使用动态代理。使用动态代理可以使一个处理者（Handler）为各个类服务。
IHello.java、HelloSpeaker.java、LogHandler.java、ProxyDemo.java代码分别如下：
package com.voidking.aop2;public interface IHello &#123;	public void hello(String name);&#125;

package com.voidking.aop2;public class HelloSpeaker implements IHello &#123;	@Override	public void hello(String name) &#123;		// TODO Auto-generated method stub		System.out.println("Hello,"+name);	&#125;&#125;

package com.voidking.aop2;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;public class LogHandler implements InvocationHandler &#123;	private Object sub;	public LogHandler() &#123;		// TODO Auto-generated constructor stub	&#125;	public LogHandler(Object obj)&#123;		sub=obj;	&#125;	@Override	public Object invoke(Object proxy, Method method, Object[] args)			throws Throwable &#123;		// TODO Auto-generated method stub		System.out.println("before you do thing");		method.invoke(sub, args);		System.out.println("after you do thing");		return null;	&#125;&#125;

package com.voidking.aop2;import java.lang.reflect.Proxy;public class ProxyDemo &#123;	public static void main(String[] args) &#123;		// TODO Auto-generated method stub		HelloSpeaker helloSpeaker = new HelloSpeaker();		LogHandler logHandler = new LogHandler(helloSpeaker);		Class cls = helloSpeaker.getClass();		IHello iHello = (IHello)Proxy.newProxyInstance(cls.getClassLoader(), cls.getInterfaces(), logHandler);		iHello.hello("Justin");	&#125;&#125;
HelloSpeaker本身的职责是显示文字，却必须插入日志动作，这是的HelloSpeaker的职责加重。日志的程序代码横切（cross-cutting）到HelloSpeaker的程序执行流程中，日志这样的动作在AOP术语中被称为横切关注点（cross-cutting concerns）。
使用代理类将记录与业务逻辑无关的动作提取出来，设计为一个服务类，如同前面的范例HelloProxy或者LogHandler，这样的类称为切面（Aspect）。
将日志等动作（cross-cutting concerns）设计为通用，不介入特定业务类的一个职责清楚的Aspect类，这就是所谓的Aspect-Oriented Programming，AOP。
通知AdviceSpring提供了5种通知（Advice）类型：

Interception Around Advice：在目标对象的方法执行前后被调用。
Before Advice：在目标对象的方法执行前被调用。
After Returning Advice：在目标对象的方法执行后被调用。
Throw Advice：在目标对象的方法抛出异常时被调用。
Introduction Advice：一种特殊类型的拦截通知，只有在目标对象的方法调用完毕后执行。

切入点PointcutPointcut定义了Advice应用的时机。在Spring中，使用PointcutAdvisor把Pointcut与Advice结合为一个对象。Spring中大部分内建的Pointcut都有对应的PointAdvisor。静态切入点只限于给定的方法和目标类，而不考虑方法的参数。动态切入点与静态切入点的区别是，动态切入点不仅限定于给定的方法和类，还可以指定方法的参数。大多数切入点，可以使用静态切入点，很少有机会创建动态切入点。
源代码分享https://github.com/voidking/aop.git
小结Advice和Pointcut到底干嘛用的？书上根本没有讲清楚哇！不去查资料了，需要的时候再去深入学习。
参考文档《Java EE基础实用教程》，郑阿奇主编
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring与Hibernate整合应用</title>
    <url>/dev-spring-hibernate-integration/</url>
    <content><![CDATA[创建数据库和表其实我们在之前的例子中已经创建过了，数据库名xscj，表为dlb。详情请见《Hibernate与Struts2整合应用》。
创建项目创建Dynamic Web Project，命名为hibernate_spring。
加载Spring框架右击项目名，Properties，Java Build Path，Libraries，Add Library…，User Library，Next，User Libraries…，New…，输入“spring”，OK，Add External JARs…，选中需要的jar文件，打开，OK。
加载Hibernate框架右击项目名，Properties，Java Build Path，Libraries，Add Library…，User Library，Next，User Libraries…，New…，输入“hibernate”，OK，Add External JARs…，选中需要的jar文件，打开，OK。

生成POJO类和*.hbm.xmlWindow，Open Perspective，Hibernate。
Add Configuration…，选中Project（hibernate_spring），选择Database connection，Setup… Propery file，Setup… Configuration file（需要进行一些配置）。
这时，会提示缺少MySQL驱动，在Classpath选项卡中配置一下就好了。
File，New，Hibernate Reverse Engineering File（reveng.xml），选中hibernate_spring，Next，选择Console configuration，Refresh，
在工具栏中，有三个三角号（绿色圆底），其中一个三角号的右下角有Hibernate的小标志。点击它的下拉菜单，Hibernate Code Generation Configurations…。
New，在Main选项卡中选择Console configuration，选择Output directory，勾选Reverse engineer from JDBC Connection。
在Exporters选项卡中勾选Domain code（.java）和Hibernate XML Mappings（.hbm.xml）。Run。
编写DlDao接口package com.voidking.hibernate_spring.dao;import com.voidking.hibernate_spring.model.Dlb;public interface DlDao &#123;	public void save(Dlb dl);&#125;

编写DlDaoImp实现类package com.voidking.hibernate_spring.dao.imp;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.classic.Session;import com.voidking.hibernate_spring.dao.DlDao;import com.voidking.hibernate_spring.model.Dlb;public class DlDaoImp implements DlDao &#123;	// 依赖注入SessionFactory对象，set方法注入	private SessionFactory sessionFactory;	public void setSessionFactory(SessionFactory sessionFactory) &#123;		this.sessionFactory = sessionFactory;	&#125;	@Override	public void save(Dlb dl) &#123;		try &#123;			Session session = sessionFactory.openSession();			Transaction ts = session.beginTransaction();			session.save(dl);			ts.commit();		&#125; catch (Exception e) &#123;			// TODO: handle exception			e.printStackTrace();		&#125;			&#125;&#125;

applicationContext.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--  - Middle tier application context definition for the image database.  --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"		xmlns:context="http://www.springframework.org/schema/context"		xmlns:tx="http://www.springframework.org/schema/tx"		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;	&lt;!-- 用Bean定义数据源 --&gt;	&lt;bean id="datasource" class="org.apache.commons.dbcp.BasicDataSource"&gt;		&lt;property name="driverClassName" value="com.mysql.jdbc.Driver"&gt;&lt;/property&gt;		&lt;property name="url" value="jdbc:mysql://localhost:3306/xscj"&gt;&lt;/property&gt;		&lt;property name="username" value="scott"&gt;&lt;/property&gt;		&lt;property name="password" value="tiger"&gt;&lt;/property&gt;	&lt;/bean&gt;		&lt;!-- 定义Hibernate的SessionFactory --&gt;	&lt;bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"&gt;		&lt;!-- 定义SessionFactory必须注入DataSource --&gt;		&lt;property name="dataSource"&gt;			&lt;ref bean="datasource"/&gt;		&lt;/property&gt;				&lt;!-- 定义Hibernate的SessionFactory属性 --&gt;		&lt;property name="hibernateProperties"&gt;			&lt;props&gt;				&lt;prop key="hibernate.dialect"&gt;					org.hibernate.dialect.MySQLDialect				&lt;/prop&gt;			&lt;/props&gt;		&lt;/property&gt;				&lt;!-- 定义POJO的映射文件 --&gt;		&lt;property name="mappingResources"&gt;			&lt;list&gt;				&lt;value&gt;/com/voidking/hibernate_spring/model/Dlb.hbm.xml&lt;/value&gt;			&lt;/list&gt;		&lt;/property&gt;	&lt;/bean&gt;		&lt;!-- 注入dlDao --&gt;	&lt;bean id="dlDao" class="com.voidking.hibernate_spring.dao.imp.DlDaoImp"&gt;		&lt;property name="sessionFactory"&gt;			&lt;ref bean="sessionFactory"/&gt;		&lt;/property&gt;	&lt;/bean&gt;&lt;/beans&gt;
Spring的Bean很好地管理了以前在hibernate.cfg.xml文件中创建的SessionFactory，使文件更易阅读。
编写测试类package com.voidking.hibernate_spring.test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;import com.voidking.hibernate_spring.dao.DlDao;import com.voidking.hibernate_spring.model.Dlb;public class Test &#123;	public static void main(String[] args) &#123;		Dlb dlb = new Dlb();		dlb.setXh("081109");		dlb.setKl("123456");		ApplicationContext context = new FileSystemXmlApplicationContext("src/applicationContext.xml");		DlDao dlDao = (DlDao)context.getBean("dlDao");		dlDao.save(dlb);			&#125;&#125;

运行报错Cannot find class [org.apache.commons.dbcp.BasicDataSource]
缺少commons-dbcp.jar、commons-pool.jar这两个包，在spring-framework-*/lib/jakarta-commons目录下可以找到，添加进路径即可。
上述问题解决之后，运行成功，数据插入成功。但是，并不能运行第二次，因为Duplicate entry &#39;0&#39; for key &#39;PRIMARY&#39;，且不去管它。
源代码分享https://github.com/voidking/hibernate_spring.git
小结这个工程中，并不需要hibernate.cfg.xml、hibernate.properties，因为它们完成的工作，applicationContext帮它们完成了。
参考文档《Java EE基础实用教程》，郑阿奇主编

Cannot find class [org.apache.commons.dbcp.BasicDataSource]http://blog.csdn.net/a105421548/article/details/43016953

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>spring</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring与Struts2整合应用</title>
    <url>/dev-spring-struts2-integration/</url>
    <content><![CDATA[新建项目新建Dynamic Web Project，命名为struts2_spring。
添加struts2框架添加struts2五个核心jar包到lib文件夹。
web.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app id="WebApp_9" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;	&lt;welcome-file-list&gt;		&lt;welcome-file&gt;/login.jsp&lt;/welcome-file&gt;	&lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;


login.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/struts-tags" prefix="s" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;登录界面&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;s:form action="login.action" method="post"&gt;		&lt;s:textfield name="xh" label="学号"&gt;&lt;/s:textfield&gt;		&lt;s:password name="kl" label="口令"&gt;&lt;/s:password&gt;	&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt;

LoginAction.javapackage com.voidking.struts2_spring.action;import com.opensymphony.xwork2.ActionSupport;public class LoginAction extends ActionSupport&#123;	private String xh;	private String kl;	public String getXh() &#123;		return xh;	&#125;	public void setXh(String xh) &#123;		this.xh = xh;	&#125;	public String getKl() &#123;		return kl;	&#125;	public void setKl(String kl) &#123;		this.kl = kl;	&#125;		public String execute() throws Exception&#123;		return SUCCESS;	&#125;&#125;

struts.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;	&lt;include file="struts-default.xml"&gt;&lt;/include&gt;	&lt;package name="default" extends="struts-default"&gt;		&lt;action name="login" class="com.voidking.struts2_spring.action.LoginAction"&gt;			&lt;result name="success"&gt;/login_success.jsp&lt;/result&gt;		&lt;/action&gt;	&lt;/package&gt;&lt;/struts&gt;

login_success.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/struts-tags" prefix="s" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;登录成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;h2&gt;您好！&lt;s:property value="xh"/&gt; 欢迎您登录成功&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt;

部署运行在登录框和密码框输入任意输入，单击登录按钮，转向登录成功界面，并输出登录名。
添加Spring框架拷贝Spring的核心jar包到lib文件夹。
添加Spring支持包拷贝struts2-spring-plugin.jar到lib文件夹，该包位于Struts2的lib目录下。
修改web.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app id="WebApp_9" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;	&lt;welcome-file-list&gt;		&lt;welcome-file&gt;/login.jsp&lt;/welcome-file&gt;	&lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;	&lt;listener&gt;		&lt;listener-class&gt;			org.springframework.web.context.ContextLoaderListener		&lt;/listener-class&gt;	&lt;/listener&gt;	&lt;context-param&gt;		&lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;		&lt;param-value&gt;			/WEB-INF/classes/applicationContext.xml		&lt;/param-value&gt;	&lt;/context-param&gt;&lt;/web-app&gt;

struts.propertiesstruts.objectFactory=spring
该文件位于src文件夹下，运行过程中会被Struts2框架加载，是的Struts2的类对象的生成交给Spring完成。
applicationContext.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--  - Middle tier application context definition for the image database.  --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"		xmlns:context="http://www.springframework.org/schema/context"		xmlns:tx="http://www.springframework.org/schema/tx"		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;	&lt;bean id="loginAction" class="com.voidking.struts2_spring.action.LoginAction"&gt;&lt;/bean&gt;&lt;/beans&gt;

修改struts.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;	&lt;include file="struts-default.xml"&gt;&lt;/include&gt;	&lt;package name="default" extends="struts-default"&gt;		&lt;!-- 使用Spring生成的类对象 --&gt;		&lt;action name="login" class="loginAction"&gt;			&lt;result name="success"&gt;/login_success.jsp&lt;/result&gt;		&lt;/action&gt;	&lt;/package&gt;&lt;/struts&gt;

再次部署运行我们可以得到和第一次部署运行同样的结果。
源代码分享https://github.com/voidking/struts2_spring.git
参考文档《Java EE基础实用教程》，郑阿奇主编
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>spring</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL Server迁移到Oracle问题</title>
    <url>/dev-sqlserver-to-oracle/</url>
    <content><![CDATA[前言Oracle最后一次实验，郝同学打算移植SQL Server上的一个项目到Oracle。因为使用了Maven+JPA+Spring+Struts2+AngularJs，所以，虽然复杂了一点，但是可移植性非常好。修改一个database-conn.properties配置文件，在pom.xml中添加Oracle驱动即可。
database-conn.properties原文件：
database.driver=com.microsoft.sqlserver.jdbc.SQLServerDriverdatabase.uri=jdbc:sqlserver://localhost:1433;databaseName=design;integratedSecurity=falsedatabase.username=sadatabase.password=123#hibernatehibernate.dialect=org.hibernate.dialect.SQLServer2008Dialecthibernate.show_sql=true



database-conn.properties修改后文件：
database.name=Oracledatabase.driver=oracle.jdbc.OracleDriverdatabase.uri=jdbc:oracle:thin:@localhost:1521:orcldatabase.username=scottdatabase.password=tiger #hibernatehibernate.dialect=org.hibernate.dialect.OracleDialecthibernate.show_sql=true

使用Maven把ojdbc14.jar安装到本地仓库，pom.xml添加：
&lt;!-- Oracle驱动 --&gt;&lt;dependency&gt;	&lt;groupId&gt;com.oracle&lt;/groupId&gt;	&lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;	&lt;version&gt;10.2.0.3.0&lt;/version&gt;&lt;/dependency&gt;
大功告成，clean install，jetty:run。
问题描述及解答在Oracle的adminbase中插入一条数据：
insert into adminbase values(1,'voidking','voidking');select * from adminbase;
两条命令都正常。然后在网页上使用账号密码登录，结果提示，用户名或密码错误。啊勒，怎么回事？莫非是因为Oracle的编码方式不对？修改完字符编码方式，问题没有解决。但是，我仍然倔强的认为，应该是编码方式的问题，因为以前在这方面吃的亏太多了。
上面的命令都是在sqldeveloper中执行的，换到sql plus试试。
select * from adminbase;
我靠，问题来了！结果显示未选定行！这是肿么回事？我好像知道为什么无法登录了，因为根本找不到数据哇！
经过查找资料，终于明白，在pl/sql developer插入数据后，需要commit（提交）。在SQL Plus中才能看到这种改变，因为二者处于两个不同的会话中。
在sqldeveloper中执行commit，再次登录，果然成功！
PS：字符编码查看命令：
select userenv('language') from dual;select * from nls_database_parameters;

新的问题不报错，但是不可以插入数据。比如添加书籍种类，输入信息后，点击“添加”，之后便没有反应了。理想的效果是，界面出现添加成功的信息。控制台并没有报错信息，只是提示：
Hibernate: select hibernate_sequence.nextval from dualHibernate: insert into readerkind (enddate, name, notice, quantity, validity, id) values (?, ?, ?, ?, ?, ?)
不知道哪里出现了问题，也许，从SQLServer移植到Oracle，没有想象的那么简单。。。问题待解决。。。
参考文档Oracle 字符集的查看和修改http://www.cnblogs.com/rootq/articles/2049324.htmlhttp://blog.chinaunix.net/uid-25492475-id-3140218.html

使用pl/sqldeveloper和使用sql*plus得到的结果不同http://www.educity.cn/wenda/410219.html

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>oracle</tag>
        <tag>sqlserver</tag>
      </tags>
  </entry>
  <entry>
    <title>SSH概述</title>
    <url>/dev-ssh-start/</url>
    <content><![CDATA[名词解释SSH：SSH不是一个框架，而是多个框架（Struts+Spring+Hibernate）的集成，是目前较流行的一种Web应用程序开源集成框架，用于构建灵活、易于扩展的多层Web应用程序。
Struts：它通过采用 Java Servlet/JSP 技术，实现了基于JavaEE Web应用的MVC设计模式的应用框架，是MVC经典设计模式中的一个经典产品。
Struts2：它是Struts的下一代产品，是在Struts和WebWork的技术基础上进行了合并的全新的Struts2框架。其全新的Struts2的体系结构与Struts的体系结构差别巨大。Struts2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts2可以理解为WebWork的更新产品。
Spring：简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。

Hibernate：它是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。
层次划分JavaEE的体系结构有三层：表示层、业务逻辑层和数据持久层。开发一个SSH项目，要遵循这三层模式。用Hibernate来完成数据的持久层应用，用Spring的Bean来管理组件（主要是DAO、业务逻辑和Struts的Action），而用Struts来完成页面的控制跳转。
开发一个项目，一般要先完成持久层数据连接，然后实现DAO，接着是业务逻辑，最后实现页面及逻辑控制。
demo设计开发环境Eclipse IDE for Java EE Developers + Mysql + Tomcat
数据库设计创建一个Web项目，命名为“ssh”。该项目要实现学生、课程及成绩的增加、删除、修改、查找功能，需要三个表，即XSB表、KCB表、CJB表。其中XSB表中含有该学生所属专业的ID，且作为外键，故还应该有一个ZYB表。在登陆学生成绩管理系统时，如果没有登陆成功，就回到登陆界面，登陆成功后方可进行各种操作，所以还要有个DLB表。数据库名为XSCJ。
XSB1、学生信息表结构



项目名
列名
数据类型
可空
默认值
说明



学号
XH
定长字符串型（char6）
×
无
主键


姓名
XM
不定长字符串型（varchar8）
×
无



性别
XB
位型（bit）
×
无
值约束：1/0。1表示男，0表示女


出生时间
CSSJ
日期时间型（datetime）
√
无



专业Id
ZY_ID
整数型（int）
×
无



总学分
ZXF
整数型（int）
√
0
0&lt;=总学分&lt;160


备注
BZ
不定长字符串型（varchar500）
√
无



照片
ZP
longblob
√
无



2、学生信息表样本数据



学号
姓名
性别
出生时间
专业
总学分
备注



081101
王林
男
1990-2-10
1
50



081102
程明
男
1991-2-01
1
50



081201
王敏
男
1989-6-10
2
42



081202
孙艳
女
1989-12-29
2
40
有一门功课不及格，待补考


081241
罗琳琳
女
1990-1-30
2
50
转专业学习


KCB1、课程信息表结构



项目名
列名
数据类型
可空
默认值
说明



课程号
KCH
定长字符型（char3）
×
无
主键


课程名
KCM
不定长字符串型（varchar12）
√
无



开学学期
KXXQ
整数型（smallint）
√
无
只能为1~8


学时
XS
整数型（int）
√
0



学分
XF
整数型（int）
√
0



2、课程信息表样本数据



课程号
课程名
开学学期
学时
学分



101
计算机基础
1
80
5


102
程序设计语言
2
68
4


206
离散数学
4
68
4


208
数据结构
5
68
4


CJB1、学生成绩表结构



项目名
列名
数据类型
可空
默认值
说明



学号
XH
定长字符型（char6）
×
无
主键


课程号
KCH
定长字符型（char3）
×
无
主键


成绩
CJ
整数型（int）
√
0



学分
XF
整数型（int）
√




2、学生成绩表样本数据



学号
课程号
成绩



081101
101
80


081101
102
78


081101
206
76


ZYB1、专业信息表结构



项目名
列名
数据类型
可空
默认值
说明



Id
ID
整数型（int）
×
增1
主键


专业名
ZYM
定长字符型（char12）
×




人数
RS
整数型（int）
√
0



辅导员
FDY
定长字符型（char8）
×




2、专业信息表样本数据



专业
人数
辅导员



计算机
150
黄日生


通信工程
131
赵红


DLB1、登陆表结构



项目名
列名
数据类型
可空
默认值
说明



标志
ID
整数型（int）
×

主键，是标志


登陆号
XH
定长字符型（char6）
×
无
与XSB表学号关联


口令
KL
定长字符型（char20）
√
无
可以加密，长度为8~20


2、登录表样本数据



标志
登陆号
口令



1
081101
voidking


2
081102
voidking


XS_KCB1、连接表结构



项目名
列名
数据类型
可空
默认值
说明



学号
XH
定长字符型（char6）
×

主键


课程号
KCH
定长字符型（char3）
×

主键


2、连接表样本数据



学号
课程号



081101
101


081101
102


081101
206


包设计com.voidking.ssh.action：放置对应的用户自定义的Action类。由Action类调用业务逻辑来处理用户请求，然后控制跳转。
com.voidking.ssh.dao：放置DAO（数据访问对象）的接口，接口中的方法用来和数据库进行交互，这些方法由它们的类来实现。
com.voidking.ssh.dao.imp：放置实现DAO接口的类。
com.voidking.ssh.model：放置表对应的POJO类及映射文件*.hbm.xml。
com.voidking.ssh.service：放置业务逻辑接口。接口中的方法用来处理用户请求，这些方法由实现接口的类来实现。
com.voidking.ssh.service.imp：放置实现业务逻辑接口的类。
com.voidking.ssh.tool：放置公用的工具类，如分页类。
struts.properties：实现Struts2和Spring整合。
struts.xml：配置Action。
添加Spring开发实现Hibernate持久层实现DAO实现业务逻辑层实现Web层源代码分享改进设计使用SSH自动生成表，或者通过表自动生成POJO类。
参考文档《Java EE基础实用教程》，郑阿奇主编SSH框架总结：http://blog.csdn.net/shan9liang/article/details/8803989Struts1和Struts2：http://blog.csdn.net/bjyfb/article/details/8679523手把手教你搭建SSH：http://www.tuicool.com/articles/f2u6VrAhttp://blog.csdn.net/zhaolijing2012/article/details/39700187eclipse搭建SSH框架详解：http://blog.csdn.net/aaaaaaaa0705/article/details/6288431
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>ssh</tag>
        <tag>spring</tag>
        <tag>hibernate</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>通过浏览器打开应用程序</title>
    <url>/dev-start-app-from-browser/</url>
    <content><![CDATA[原理通过浏览器打开应用程序，利用的是在浏览器地址栏中输入一个协议，如果有本地程序（应用）能够解析这个协议，那么这个应用将被调起。


前端代码如果安装过app调起app，否则页面跳转到app下载页面，这个逻辑分支实现原理如下：
当在浏览器地址栏输入app定义的协议调起app时，如果已经安装过，系统中断浏览器进程，继而响应app进程，因而在切换到app的时候浏览器中js代码将不再执行，当再次切换回来时系统进程又切回浏览器，js代码从中断处继续执行。所做的逻辑分支就是利用这个关键点。可设置延时来做分支，当app可以被调起时，切换到app，js不再执行，这期中有个app调起时间（与系统有关），如果设置的延时时间过短，则js会继续执行。当切换回来，记录切换回来的时间点，与切换之前比较大于设定时间说明已经切换成功，将不再执行下载，否则下载。
PS：app的协议是与app开发同学约定，由app开发同学通过activity scheme设置的。
var appInfo = &#123;    iosUrl: "",    //打开IOS客户端链接    androidUrl: "",  //打开ANdroid客户端的链接    downloadUrl: ""  //下载客户端或者去App Store的链接&#125;;var t1 = new Date().getTime();iframe2open();jump2download();//利用iframe打开客户端function iframe2open()&#123;    var src = $.os.ios ? appInfo.iosUrl : appInfo.androidUrl,        iframe = document.createElement("iframe");    iframe.src = src;    iframe.style.display = "none";    document.body.appendChild(iframe); &#125; //跳转下载页面function jump2download()&#123;    var _timer = null;    clearTimeout(_timer);    _timer = setTimeout(function()&#123;        var t2 = new Date().getTime();        if (t2 - t1 &lt;= 800) &#123;            window.location = appInfo.downloadUrl;        &#125;    &#125;,400);&#125;

书签通过浏览器直接打开iOS/Android App 应用程序http://itindex.net/blog/1415353560000.html
Make a link in the Android browser start up my app?
Launch custom android application from android browser
非微信内置浏览器中的网页调起微信支付的方案研究http://blog.csdn.net/ahence/article/details/51317814
浏览器调起app应用方法http://blog.csdn.net/u012193330/article/details/52190143
android自定义协议和html加载时自动尝试调用本地APPhttp://www.oschina.net/code/snippet_256033_35330/
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts2综合应用实例</title>
    <url>/dev-struts2-comprehensive-example/</url>
    <content><![CDATA[前言本实例实现了一个简单的功能：添加学生信息。我们仍然在Struts2概述中struts2项目的基础上进行。
建立数据库使用MySQL，scott用户，建立数据库，名为XSCJ，其中有一张表XSB，结构如下：



项目名
列名
数据类型
可空
默认值
说明



学号
XH
定长字符串型（char6）
×
无
主键


姓名
XM
不定长字符串型（varchar8）
×
无



性别
XB
位型（bit）
×
无
值约束：1/0。1表示男，0表示女


出生时间
CSSJ
日期时间型（datetime）
√
无



专业Id
ZY_ID
整数型（int）
×
无



总学分
ZXF
整数型（int）
√
0
0&lt;=总学分&lt;160


备注
BZ
不定长字符串型（varchar500）
√
无



照片
ZP
longblob
√
无



create database xscj;use xscj;create table xsb(xh char(6) not null primary key,xm varchar(8) not null,xb bit not null check(xb=0 or xb=1),cssj datetime ,zy_id int,zxf int default 0 check(0&lt;=zxf&lt;160),bz varchar(500),zp longblob);

建立stu.jsp&lt;%@ page language="java" pageEncoding="utf-8"%&gt;&lt;%@ taglib uri="/struts-tags" prefix="s"%&gt;&lt;%@ taglib uri="/struts-dojo-tags" prefix="sx" %&gt;&lt;html&gt;&lt;head&gt;	&lt;s:head /&gt;	&lt;sx:head/&gt;&lt;/head&gt;&lt;body&gt;	&lt;h3&gt;添加学生信息&lt;/h3&gt;	&lt;s:form action="save" namespace="/" method="post" theme="simple"&gt;		&lt;table&gt;			&lt;tr&gt;				&lt;td&gt;学号（六位数）：&lt;/td&gt;				&lt;td&gt;&lt;s:textfield name="xs.xh"&gt;&lt;/s:textfield&gt;&lt;/td&gt;			&lt;/tr&gt;			&lt;tr&gt;				&lt;td&gt;姓名：&lt;/td&gt;				&lt;td&gt;&lt;s:textfield name="xs.xm" &gt;&lt;/s:textfield&gt;&lt;/td&gt;			&lt;/tr&gt;			&lt;tr&gt;				&lt;td&gt;性别：&lt;/td&gt;				&lt;td&gt;&lt;s:radio name="xs.xb" list="#&#123;true:'男',false:'女'&#125;" value="true"&gt;&lt;/s:radio&gt;&lt;/td&gt;			&lt;/tr&gt;			&lt;tr&gt;				&lt;td width="70"&gt;出生时间:&lt;/td&gt;				&lt;td&gt;&lt;sx:datetimepicker name="xs.cssj" id="cssj"	displayFormat="yyyy-MM-dd"&gt;&lt;/sx:datetimepicker&gt;&lt;/td&gt;			&lt;/tr&gt;			&lt;tr&gt;				&lt;td&gt;专业ID：&lt;/td&gt;				&lt;td&gt;&lt;s:textfield name="xs.zy_id" label="专业"&gt;&lt;/s:textfield&gt;&lt;/td&gt;			&lt;/tr&gt;			&lt;tr&gt;				&lt;td&gt;备注：&lt;/td&gt;				&lt;td&gt;&lt;s:textarea name="xs.bz" label="备注"&gt;&lt;/s:textarea&gt;&lt;/td&gt;			&lt;/tr&gt;			&lt;tr&gt;				&lt;td&gt;&lt;s:submit value="添加"&gt;&lt;/s:submit&gt;&lt;/td&gt;				&lt;td&gt;&lt;s:reset value="重置"&gt;&lt;/s:reset&gt;&lt;/td&gt;			&lt;/tr&gt;		&lt;/table&gt;	&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt;
注意，上面的代码使用了/struts-dojo-tags标签，需要导入包struts2-dojo-plugin-*.jar。Struts2的标签具有自动排版的功能，如果想要自己排版，可以在form标签中加入theme=”simple”，但加入该元素后，标签中的label属性就没用了。
建立addsuccess.jsp&lt;%@ page language="java" pageEncoding="utf-8"%&gt;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;    	恭喜你，添加成功！&lt;/body&gt;&lt;/html&gt;

建立JavaBeanpackage com.voidking.struts2.model;import java.sql.Date;public class Xsb &#123;   	private String xh;	private String xm;	private boolean xb;	private Date cssj;	private int zy_id;	private int zxf;	private String bz;	private byte[] zp;	public String getXh() &#123;		return xh;	&#125;	public void setXh(String xh) &#123;		this.xh = xh;	&#125;	public String getXm() &#123;		return xm;	&#125;	public void setXm(String xm) &#123;		this.xm = xm;	&#125;		public boolean isXb() &#123;		return xb;	&#125;	public void setXb(boolean xb) &#123;		this.xb = xb;	&#125;	public Date getCssj() &#123;		return cssj;	&#125;	public void setCssj(Date cssj) &#123;		this.cssj = cssj;	&#125;	public int getZy_id() &#123;		return zy_id;	&#125;	public void setZy_id(int zy_id) &#123;		this.zy_id = zy_id;	&#125;	public int getZxf() &#123;		return zxf;	&#125;	public void setZxf(int zxf) &#123;		this.zxf = zxf;	&#125;	public String getBz() &#123;		return bz;	&#125;	public void setBz(String bz) &#123;		this.bz = bz;	&#125;	public byte[] getZp() &#123;		return zp;	&#125;	public void setZp(byte[] zp) &#123;		this.zp = zp;	&#125;		&#125;

建立DBConnpackage com.voidking.struts2.db;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import com.voidking.struts2.model.Xsb;public class DBConn &#123;	Connection conn;	PreparedStatement pstmt;	public DBConn()&#123;		try&#123;			Class.forName("com.mysql.jdbc.Driver");			conn=DriverManager.getConnection("jdbc:mysql://localhost/xscj","scott","tiger");		&#125;catch(Exception e)&#123;			e.printStackTrace();		&#125;	&#125;	// 添加学生	public boolean save(Xsb xs)&#123;		try&#123;			pstmt=conn.prepareStatement("insert into XSB(xh,xm,xb,cssj,zy_id,bz) values(?,?,?,?,?,?)");			pstmt.setString(1, xs.getXh());			pstmt.setString(2, xs.getXm());			pstmt.setBoolean(3, xs.isXb());			pstmt.setDate(4, xs.getCssj());			pstmt.setInt(5, xs.getZy_id());			pstmt.setString(6, xs.getBz());			pstmt.executeUpdate();			return true;		&#125;catch(Exception e)&#123;			e.printStackTrace();			return false;		&#125;	&#125;&#125;
注意，别忘记导入包mysql-connector-java-*-bin.jar。
建立SaveActionpackage com.voidking.struts2.action;import com.opensymphony.xwork2.ActionSupport;import com.voidking.struts2.db.DBConn;import com.voidking.struts2.model.Xsb;public class SaveAction extends ActionSupport&#123;	private Xsb xs;	public Xsb getXs() &#123;		return xs;	&#125;	public void setXs(Xsb xs) &#123;		this.xs=xs;	&#125;	public String execute() throws Exception &#123;		DBConn db=new DBConn();		Xsb stu=new Xsb();		stu.setXh(xs.getXh());		stu.setXm(xs.getXm());		stu.setXb(xs.isXb());		stu.setZy_id(xs.getZy_id());		stu.setCssj(xs.getCssj());		stu.setBz(xs.getBz());		if(db.save(stu))&#123;			return SUCCESS;		&#125;else			return ERROR;	&#125;&#125;

struts.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;	&lt;constant name="struts.multipart.saveDir" value="/tmp"/&gt;    &lt;package name="default"  extends="struts-default"&gt;        	&lt;interceptors&gt;    		&lt;interceptor name="myInterceptor" class="com.voidking.struts2.tool.MyInterceptor"&gt;&lt;/interceptor&gt;    	&lt;/interceptors&gt;    	&lt;default-interceptor-ref name=""&gt;&lt;/default-interceptor-ref&gt;    	        &lt;default-action-ref name="index" /&gt;        &lt;action name="struts" class="com.voidking.struts2.action.StrutsAction"&gt;            &lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;            &lt;result name="error"&gt;/hello.jsp&lt;/result&gt;            &lt;result name="input"&gt;/hello.jsp&lt;/result&gt;                        &lt;!-- 拦截配置在result后面 --&gt;            &lt;!-- 使用系统默认拦截器栈 --&gt;            &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;            &lt;!-- 配置拦截器 --&gt;            &lt;interceptor-ref name="myInterceptor"&gt;&lt;/interceptor-ref&gt;                    &lt;/action&gt;                &lt;action name="upload" class="com.voidking.struts2.action.UploadAction"&gt;        	&lt;result name="success"&gt;/uploadsuccess.jsp&lt;/result&gt;        	&lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;        &lt;/action&gt;                &lt;action name="upload2" class="com.voidking.struts2.action.Upload2Action"&gt;        	&lt;result name="success"&gt;/uploadsuccess.jsp&lt;/result&gt;        	&lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;        &lt;/action&gt;                &lt;action name="save" class="com.voidking.struts2.action.SaveAction"&gt;        	&lt;result name="success"&gt;/addsuccess.jsp&lt;/result&gt;        	&lt;result name="error"&gt;/stu.jsp&lt;/result&gt;        	&lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;
源代码分享https://github.com/voidking/struts2.git包括Struts2概述、Struts2国际化应用、Struts2文件上传、Struts2综合应用实例。
小结性别保存为bit类型数据，搞起来感觉有点麻烦，换成char(2)类型，限定值为“男”或“女”，也许更方便一些。
参考文档《Java EE基础实用教程》，郑阿奇主编
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts2国际化应用</title>
    <url>/dev-struts2-international/</url>
    <content><![CDATA[前言有的时候，一个项目不仅要求只支持一种语言。如用中文开发的项目，只有懂中文的用户能用，而别的国家由于不使用中文将难以使用。若再重新开发一套功能相同但只是语言不同的项目，显然是不可取的。所以对于一个项目，国际化的应用是必要的。
建立资源文件在Struts2概述中的实例的基础上，在src文件夹下新建一个文件struts.properties，内容如下：
struts.custom.resources=messageResource
或者直接在struts.xml中添加：
&lt;constant name="struts.custom.i18n.resources" value="messageResource"&gt;&lt;/constant&gt;

在src文件夹下新建两个文件，messageResource_en_US.properties和messageResource_zh_CN.properties，内容分别如下：
username=DLMpassword=KLlogin=login


username=登录名password=口令login=登录
PS：在输入中文时，eclipse会帮助我们自动转成ASCII字符，所以，输入完成后，我们看到的结果如下：
username=\u767B\u5F55\u540Dpassword=\u53E3\u4EE4login=\u767B\u5F55

建立login.jsp文件为了让程序可以显示国际化信息，则需要在JSP页面输出key，而不是直接输出字符常量。Struts2访问国际化消息主要有以下三种方式：1、在JSP页面输出国际化消息，可以使用Struts2的&lt;s:text…/&gt;标签，该标签可以指定name属性，该属性指定国际化资源文件中的key。2、在Action中访问国际化消息，可以使用ActionSupport类的getText()方法，该方法可以接收一个参数，该参数指定了国际化资源文件中key。3、在表单元素的label属性里输出国际化信息，可以为该表单标签指定一个key属性，该属性指定了国际化资源文件中的key。
下面是login.jsp文件代码：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/struts-tags" prefix="s" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;登录&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;s:i18n name="messageResource"&gt;		&lt;s:form action="login.action" method="post"&gt;			&lt;s:textfield name="XH" key="username" size="20"&gt;&lt;/s:textfield&gt;			&lt;s:textfield name="KL" key="password" size="21"&gt;&lt;/s:textfield&gt;			&lt;s:submit value="%&#123;getText('login')&#125;"&gt;&lt;/s:submit&gt;		&lt;/s:form&gt;	&lt;/s:i18n&gt;&lt;/body&gt;&lt;/html&gt;

部署运行部署项目，启动Tomcat，使用IE访问：http://localhost:8080/struts2/login.jsp ，可以看到中文界面。工具，Internet选项，常规，语言，添加，英语（美国）[en-US]，上移。刷新页面，就可以看到英文界面了。
eclipse下显示classes文件夹eclipse，Window，Show View，Navigator。
参考文档《Java EE基础实用教程》，郑阿奇主编
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>团队博客项目（一）——基础框架的搭建</title>
    <url>/dev-team-blog-project-1-basic-frame/</url>
    <content><![CDATA[开发环境下载安装node.js。安装完成后，进入命令提示符界面，输入node --version，如果能出现node的版本号，则说明安装成功。
开发工具的选用java程序开发，我喜欢eclipse；node.js程序开发，我选择的工具是webstorm。至于软件下载破解啥的，都是基本功，在此不赘述。
生成基本目录和文件1、打开webstorm，file -&gt; new project
2、输入project name，选择location，project type选择node.js express app
3、node.js interpreter和npm excutable的位置默认就好（自动读取），version of express-generator选择最新版4.9.0，template engine选择ejs，css engine选择plain css。
4、ok，this window，如果接下来弹出configure node.js v0.10.31 core modules sources，直接点cancel就好，用不到。
5、好了，项目基础框架搭建好了，看下效果：
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>团队博客项目（二）</title>
    <url>/dev-team-blog-project-2-hello/</url>
    <content><![CDATA[hello voidking查看效果1、单击webstorm右上角的绿色三角形（或者shift+f10），运行项目。
2、打开浏览器，输入localhost:3000，有没有看到welcome to express ？
修改文字下面我们把welcome to express修改为hello voidking！1、打开views文件夹下的index.ejs，诶？这不是html代码吗？发现有个&lt;%= title%&gt;，这是个啥玩意？这时，我们就要解释一下模板引擎了。专业一点说，模板引擎是一个可以根据模板生成html代码的工具。通俗一点讲，模板引擎就像是一个函数，不同的x值对应不同的y值。比如y=x+1，当x=1时y=2。这里的x就相当于&lt;%= title%&gt;，y就相当于html页面。懂了？不懂拉倒，自己慢慢想，这不是重点。2、知道了原理，修改就简单了，不就是给x赋值嘛！打开routes文件夹下的index.js文件，看到这段代码：
router.get('/', function(req, res) &#123;  res.render('index', &#123; title: 'Express' &#125;);&#125;);
修改如下：
router.get('/', function(req, res) &#123;  res.render('index', &#123; title: 'voidking' &#125;);&#125;);
看懂了吧，把“voidking”赋值给了title，仅此而已。

3、运行，看到效果没？“welcome to voidking”，怎么改成“hello voidking”？当然是修改index.ejs文件了！“welcome to” 就相当于y=x+1中的1，是固定的。
一点解释也许你已经运行成功了，但是你还是不理解这些代码。下面我简单解释下，不懂没关系，我会在接下来的教程中详细解释。1、bin文件夹，不用管。
2、node_modules文件夹，存放包。包又是啥玩意？类比吧，node.js中的包（文件夹） = java中的包（jar文件）。
3、public文件夹，存放图片等资源文件。
4、routes文件夹，存放路由文件，也就是业务层处理的文件。
5、views文件夹，存放交互层文件，这次项目中，也就是ejs模板文件。
6、app.js文件，程序入口。不要费心去找“main”函数了，它就是！
7、package.json文件，包的配置文件，相当于java的maven工程中的pom.xml文件。也许咱们这个项目用了很多第三方的包，那么，别人要运行这个项目，必须也安装了这些包。所以，package.json文件的主要目的，就是记录依赖的第三方包。这样，代码是不是很容易迁移？没错！具体写法这里不展开了，下次专门说一下。
8、细心的朋友可能发现了，业务层和交互层都有了，那么数据层在哪？别着急，马上我们会新建一个models文件夹，存放数据层文件。
表达的不好，请见谅。推荐一本好书——《node.js开发指南》，byvoid写的，这次项目我主要参考的就是这本书。不懂的地方，看书吧！
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>团队博客项目总结</title>
    <url>/dev-team-blog-project-summary/</url>
    <content><![CDATA[20天这次项目的任务是：开发一个适用于团队的博客。从9月27接手任务，到10月17项目上线，20天左右。加班加点，一路走过，收获颇丰。现在，项目验收完毕，是时候吹吹牛了！
node.js + express + ejs + mongodb + bootstrap起初，有组员提出使用Java EE，因为我们之前用它开发了复合人才网，比较熟悉。这个提议被我否定了，理由是杀鸡用牛刀。最终，我们决定使用从来都没有接触过的node.js，边学边做，这也符合我们做开发的最终目的——学习。

什么都不懂，根本无从下手，那就学习吧！找了很多资料来看，接触到了很多有趣的东西。大概一周后，我才对node.js有了比较清晰的认识。
学一点，用一点，经过艰辛的探索、测试，我们才选出了最终的框架——node.js + express + ejs + mongodb + bootstrap。
例会三天一次，交流经验，分配任务，交流经验，分配任务……互相借鉴彼此实现的功能模块，两条线，基本上都已经完成。
收获最大的收获，在于扩宽了眼界，对于编程工具的选用，有了更多的思路。
其他我在考虑，是否要把做项目的步骤写下来，毕竟这是一笔宝贵的经验。但是郝同学实在是懒到不行，不能确定是否可以坚持下来，写教程太累了。（10分钟后……）决定了，写！！！权当复习了，也为后来者提供一点点帮助。慢慢写，不着急，欧耶！

最后，附上几张效果图吧！
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorboard基础</title>
    <url>/dev-tensorboard/</url>
    <content><![CDATA[前言《tenserflow入门》中，我们学习了tensorflow的基本概念和搭建神经网络的方法。接下来，我们学习一下tensorboard的使用。


Tensorboard为了更方便 TensorFlow 程序的理解、调试与优化，Google发布了一套叫做 TensorBoard 的可视化工具。你可以用 TensorBoard 来展现你的 TensorFlow 图像，绘制图像生成的定量指标图以及附加数据。
可视化构建过程《tenserflow入门》中，我们建立了一个神经网络。这里，我们进行一下修改，使之用Tensorboard显示出结构。
import tensorflow as tfimport numpy as nptf.set_random_seed(1)np.random.seed(1)# fake datax = np.linspace(-1, 1, 100)[:, np.newaxis]          # shape (100, 1)noise = np.random.normal(0, 0.1, size=x.shape)y = np.power(x, 2) + noise                          # shape (100, 1) + some noisewith tf.variable_scope('Inputs'):    tf_x = tf.placeholder(tf.float32, x.shape, name='x')    tf_y = tf.placeholder(tf.float32, y.shape, name='y')with tf.variable_scope('Net'):    l1 = tf.layers.dense(tf_x, 10, tf.nn.relu, name='hidden_layer')    output = tf.layers.dense(l1, 1, name='output_layer')    # add to histogram summary    tf.summary.histogram('h_out', l1)    tf.summary.histogram('pred', output)loss = tf.losses.mean_squared_error(tf_y, output, scope='loss')train_op = tf.train.GradientDescentOptimizer(learning_rate=0.5).minimize(loss)tf.summary.scalar('loss', loss)     # add loss to scalar summarysess = tf.Session()sess.run(tf.global_variables_initializer())writer = tf.summary.FileWriter('./log', sess.graph)     # write to filemerge_op = tf.summary.merge_all()                       # operation to merge all summaryfor step in range(100):    # train and net output    _, result = sess.run([train_op, merge_op], &#123;tf_x: x, tf_y: y&#125;)    writer.add_summary(result, step)

1、首先运行程序，python 305_tensorboard.py，这时，会在当前文件夹下生成log目录和 event.out.tfevent.* log文件。
2、执行tensorboard --logdir ./log，此时，会启动tensorboard web服务，默认端口为6006。访问 http://localhost:6006 ，看到tensorboard页面。
3、因为我们只定义了graph，所以点击导航栏的GRAPHS，即可看到我们定义的graph。
可视化训练过程from __future__ import print_functionimport tensorflow as tfimport numpy as npdef add_layer(inputs, in_size, out_size, n_layer, activation_function=None):    # add one more layer and return the output of this layer    layer_name = 'layer%s' % n_layer    with tf.name_scope(layer_name):        with tf.name_scope('weights'):            Weights = tf.Variable(tf.random_normal([in_size, out_size]), name='W')            tf.summary.histogram(layer_name + '/weights', Weights)        with tf.name_scope('biases'):            biases = tf.Variable(tf.zeros([1, out_size]) + 0.1, name='b')            tf.summary.histogram(layer_name + '/biases', biases)        with tf.name_scope('Wx_plus_b'):            Wx_plus_b = tf.add(tf.matmul(inputs, Weights), biases)        if activation_function is None:            outputs = Wx_plus_b        else:            outputs = activation_function(Wx_plus_b, )        tf.summary.histogram(layer_name + '/outputs', outputs)    return outputs# Make up some real datax_data = np.linspace(-1, 1, 300)[:, np.newaxis]noise = np.random.normal(0, 0.05, x_data.shape)y_data = np.square(x_data) - 0.5 + noise# define placeholder for inputs to networkwith tf.name_scope('inputs'):    xs = tf.placeholder(tf.float32, [None, 1], name='x_input')    ys = tf.placeholder(tf.float32, [None, 1], name='y_input')# add hidden layerl1 = add_layer(xs, 1, 10, n_layer=1, activation_function=tf.nn.relu)# add output layerprediction = add_layer(l1, 10, 1, n_layer=2, activation_function=None)# the error between prediciton and real datawith tf.name_scope('loss'):    loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - prediction),                                        reduction_indices=[1]))    tf.summary.scalar('loss', loss)with tf.name_scope('train'):    train_step = tf.train.GradientDescentOptimizer(0.1).minimize(loss)sess = tf.Session()merged = tf.summary.merge_all()writer = tf.summary.FileWriter("log/", sess.graph)init = tf.global_variables_initializer()sess.run(init)for i in range(1000):    sess.run(train_step, feed_dict=&#123;xs: x_data, ys: y_data&#125;)    if i % 50 == 0:        result = sess.run(merged,                          feed_dict=&#123;xs: x_data, ys: y_data&#125;)        writer.add_summary(result, i)

打开tensorboard，点击导航栏SCALARS，即可看到loss的变化过程。点击导航栏DISTRIBUTIONS，即可看到weights、biases和putputs的变化过程。
源码分享https://github.com/voidking/Tensorflow-Tutorial.git
书签TensorFlow官网
Tensorflow游乐场
莫烦Tensorflow教程系列
TensorFlow 官方文档中文版
TensorFlow中文社区
youtube CS 20SI: Tensorflow for Deep Learning Research
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
        <tag>tensorboard</tag>
      </tags>
  </entry>
  <entry>
    <title>Android终端Termux</title>
    <url>/dev-termux/</url>
    <content><![CDATA[termux简介termux是个非常强大的终端模拟器，能够在android上模拟linux终端。接下来，郝同学就在自己的Honor9上尝试一下termux。


安装termux1、安装google play2、google play中搜索“termux”3、下载安装termux
安装ssh运维从访问远程服务器开始，这怎么离得开ssh命令。Termux不自带ssh命令，需先安装才能使用。
1、安装opensshapt install openssh
安装的openssh包括客户端ssh和服务端sshd，也就是说我们既可以使用ssh访问远程设备，也可以在本机上开启ssh服务以方便其他设备远程访问本机。默认情况下，安装openssh不开启服务端。
2、开启sshd服务端正常启动：sshd调试模式启动：sshd -d
3、关闭sshd服务端pkill sshd或者killall sshd
4、使用sshtermux终端中使用ssh访问远程服务器，与linux终端中使用ssh别无二致。但要使用ssh访问android设备就不同了，termux终端中sshd服务不支持密码验证，也就是说用户不能期望通过ssh user@server然后输入用户密码的方式从别的终端访问android设备。Termux终端中sshd只支持密钥验证。
5、保持sshd运行下拉手机顶部状态栏，看到termux，点击“ACQUIRE WAKELOCK”，即可看到1 session(wake lock help)。此时，termux就可以保持后台运行，sshd也不会关闭。
配置远程连接假设我们有一台linux服务器，ip是192.168.1.25；termux终端的ip地址为192.168.1.58。
1、在termux中生成ssh-keyssh-keygen
命令完成后，在~/.ssh目录中就生成了id_rsa.pub和id_rsa两个文件。
2、创建authorized_keystouch ~/.ssh/authorized_keys
cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys
3、更改权限chmod 700 ~/.ssh，切记，是700而不是777。
chmod 600 ~/.ssh/authorized_keys
4、termux测试连接ssh localhost -p 8022，或者 ssh localhost -p 8022 -i ~/.ssh/id_rsa
郝同学在这里出现错误提示：
Permission denied (publickey,keyboard-interactive).

5、termux拷贝密钥到linux，命名为id_rsa_honorscp ~/.ssh/id_rsa root@192.168.1.25:~/.ssh/id_rsa_honor
6、linux端测试连接ssh 192.168.1.58 -p 8022 -i ~/.ssh/id_rsa_honor
同样出现错误提示：
Permission denied (publickey,keyboard-interactive).

如果第4步和第6步出现错误，那么，关闭ssh服务端后，以调试模式启动。
killall sshdsshd -d
然后，在linux端输入ssh 192.168.1.58 -p 8022 -i ~/.ssh/id_rsa_honor。
这时就能在termux控制台看到错误的提示信息。郝同学的错误在于给了.ssh文件夹777权限，修改成700，问题解决。
windows端远程连接使用xftp登录linux，拷贝id_rsa_honor到windows的~/.ssh文件夹中，比如C:\Users\voidking\.ssh。
连接方式一：右键打开git命令窗口，ssh 192.168.1.58 -p 8022 -i ~/.ssh/id_rsa_honor，连接成功。
连接方式二：使用xshell，新建连接，主机填入192.168.1.58，端口填入8022。用户身份验证中，方法选择Public Key，用户密钥浏览导入id_rsa_honor，其他不填。
点击连接后，提示输入登录的用户名，不用填写，直接确定，连接成功。
书签神器Termux的使用日常
debian ssh 连接android 通过termux
Termux命令行神器初体验
Termux 設定 SSH Server
Run an SSH server on your Android with Termux
The Termux Wiki
Touch Keyboard
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>termux</tag>
      </tags>
  </entry>
  <entry>
    <title>ThinkPHP开发环境搭建</title>
    <url>/dev-thinkphp-environment/</url>
    <content><![CDATA[前言8月12号，抵达东北师范，开启了闭关修炼模式。入手的第一个项目，小太阳，有意思的名字。这是一个物业管理系统，分为业主端、物业端、CMS端，计划使用ThinkPHP框架来开发。PHP，好久不见，倍感亲切。


PHP运行环境PHP运行，需要两个条件，一个是Apache容器，另一个是PHP程序。很多情况下，还需要Mysql数据库。本次环境搭建中，我们使用集成环境WAMPServer，本环境包含了以上三个软件。省却了很多配置，很方便。其中，W代表Windows，A代表Apache，M代表Mysql，P代表PHP。
下载WAMPServerWAMPSever官网：http://www.wampserver.com/不翻墙的话，可能下载不下来，这里提供一个360网盘的下载链接：https://yunpan.cn/c6CkFLeumMZVv  访问密码 38f7
MSVCR110运行WAMPServer，报错：
如果是64位系统，下载安装vcredist_x64.exe，即可解决该错误，32位同理下载vcredist_x86.exe。微软官网下载：http://www.microsoft.com/zh-CN/download/details.aspx?id=30679
360网盘的下载链接：https://yunpan.cn/c6C2FxHGXTabm  访问密码 f641
查看运行效果成功运行WAMPSever后，我们发现桌面右下角多了一个WAMPSever的logo。这时在浏览器地址栏中输入http://localhost，即可看到WAMP的一些信息。
phpmyadmin在浏览器地址栏中输入http://localhost/phpmyadmin/，可以看到phpmyadmin的登录界面。默认用户名为root，密码为空。
下载安装ThinkPHP下载ThinkPHP官网：http://www.thinkphp.cn/360网盘的下载链接：https://yunpan.cn/c6CvrUtM6C6X4  访问密码 ebd1
安装1、解压到thinkphp_3.2.3_full。2、重命名thinkphp_3.2.3_full文件夹为thinkphp。3、剪切thinkphp文件夹到WAMP安装目录下的www文件夹中。比如我的WAMP安装目录为D:\Server\wamp64，那么就把thinkphp放到D:\Server\wamp64\www中。
查看运行结果在浏览器地址栏中输入http://localhost/thinkphp，即可看到thinkphp的一些信息。
后记至此，ThinkPHP的开发环境搭建成功，接下来可以愉快地开发了！
附上另外几款常见的PHP集成环境：1、AppServ2、WAMPP3、ServKit（原名PHPnow）4、UPUPW
书签PHP入门篇http://www.imooc.com/learn/54
ThinkPHP3.2完全开发手册http://document.thinkphp.cn/manual_3_2.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>ThinkPHP登录状态记录</title>
    <url>/dev-thinkphp-login-state/</url>
    <content><![CDATA[前言登录状态的记录，两种思路：一种是在前端cookie中存一个token，每次请求都把token传给后端，用于验证用户身份；另一种是建立session，在session中保存用户信息。
本次开发中，我们采用第二种思路，下面实现一个简单的逻辑：1、在地址栏输入后台首页地址，如果管理员未登录，则显示后台首页（登录页面）；如果管理员已登录，则跳转到内容管理页面。2、在地址栏输入内容管理页面地址，如果管理员未登录，则跳转到后台首页；如果管理员已登录，则显示内容管理页面。


php代码// 后台首页public function index()&#123;    if(isset($_SESSION['admin']))&#123;        $url = 'http://localhost/volunteer/index.php/Admin/manage';        header("location: $url");    &#125;else&#123;        $this-&gt;display();    &#125;&#125;// 登录函数public function login($name, $password)&#123;    // $name = $_POST['name'];    // $password = $_POST['password'];    $admin = M('admin');    $data = $admin-&gt;where("name='$name' AND password='$password'")-&gt;find();    if($data)&#123;        $_SESSION['admin']=$name;        $result = array(            'code' =&gt; '0',            'ext' =&gt; '登录成功',            'adminName' =&gt; $_SESSION['admin']        );        echo json_encode($result);    &#125;else&#123;        $result = array(            'code' =&gt; '1',            'ext' =&gt; '用户名或密码错误'        );        echo json_encode($result);    &#125;&#125;// 管理页面public function manage()&#123;    if(!isset($_SESSION['admin']) || !$_SESSION['admin'])&#123;        $url = 'http://localhost/volunteer/index.php/Admin/Index';        header("location: $url");    &#125;else&#123;        $this-&gt;display();    &#125;&#125;

js代码$(function()&#123;    $('#confirm').click(function(e)&#123;        e.preventDefault();        var name = $('#name').val();        var password = $('#password').val();        $.ajax(&#123;            url: '/volunteer/index.php/Admin/Index/login',            type: 'POST',            dataType: 'json',            data: &#123;                name: name,                password: password            &#125;,            success: function(data)&#123;                console.log(data);                if(data.code == 0)&#123;                    window.location = '/volunteer/index.php/Admin/Index/manage';                &#125;            &#125;,            error: function(xhr)&#123;                console.log(xhr);            &#125;        &#125;);    &#125;); &#125;);

书签起步 · Bootstrap v3 中文文档http://v3.bootcss.com/getting-started/#examples
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp部署到nginx服务器</title>
    <url>/dev-thinkphp-nginx/</url>
    <content><![CDATA[前言nginx默认情况下不支持pathinfo模式，从而不能支持ThinkPHP。能访问的，只有首页，其他函数的路径，都无法访问。


nginx配置支持pathinfo首先，查看nginx配置文件的位置，ps aux | grep nginx。然后，进入配置文件所在文件夹，备份配置文件cp nginx.conf nginx.conf_mybak。
原nginx.conf内容如下：
error_log  logs/error.log  error ;pid logs/nginx.pid;user  www;worker_processes  auto;worker_rlimit_nofile 51200;events &#123;    use epoll;    worker_connections  51200;&#125;http &#123;    client_body_buffer_size 32k;    client_header_buffer_size 2k;    client_max_body_size 2m;    default_type application/octet-stream;    log_not_found off;    server_tokens off;    include       mime.types;    gzip on;    gzip_min_length  1k;    gzip_buffers     4 16k;    gzip_http_version 1.0;    gzip_comp_level 2;    gzip_types       text/plain text/css text/xml text/javascript application/x-javascript application/xml application/rss+xml application/xhtml+xml application/atom_xml;    gzip_vary on;    #error_page   500 502 503 504  /50x.html;     log_format  access  '$remote_addr - $remote_user [$time_local] "$request" '              '$status $body_bytes_sent "$http_referer" '              '"$http_user_agent" $http_x_forwarded_for';    server &#123;        listen 80 default_server;        server_name localhost;        root /home/wwwroot/;        index index.php index.html index.htm;        location ~ \.php$ &#123;            fastcgi_pass   127.0.0.1:9000;            fastcgi_index  index.php;            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;            fastcgi_param  PHP_VALUE        open_basedir=$document_root:/tmp/:/proc/;            include        fastcgi_params;        &#125;    &#125;    include vhost/*.conf;    &#125;

修改nginx.conf的server部分如下：
server &#123;    listen 80 default_server;    server_name localhost;    root /home/wwwroot/;    index index.html index.htm index.php;    error_page 404 /404.html;    location = /404.html &#123;        return 404 'Sorry, File not Found!';    &#125;    error_page 500 502 503 504 /50x.html;    location = /50x.html &#123;        root /usr/local/nginx/html; # windows用户替换这个目录    &#125;    location / &#123;        try_files $uri @rewrite;    &#125;    location @rewrite &#123;        set $static 0;        if  ($uri ~ \.(css|js|jpg|jpeg|png|gif|ico|woff|eot|svg|css\.map|min\.map)$) &#123;            set $static 1;        &#125;        if ($static = 0) &#123;            rewrite ^/(.*)$ /index.php?s=/$1;        &#125;    &#125;    location ~ /Uploads/.*\.php$ &#123;        deny all;    &#125;    location ~ \.php/ &#123;       if ($request_uri ~ ^(.+\.php)(/.+?)($|\?)) &#123; &#125;       fastcgi_pass 127.0.0.1:9000;       include fastcgi_params;       fastcgi_param SCRIPT_NAME     $1;       fastcgi_param PATH_INFO       $2;       fastcgi_param SCRIPT_FILENAME $document_root$1;    &#125;    location ~ \.php$ &#123;        fastcgi_pass 127.0.0.1:9000;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    &#125;    location ~ /\.ht &#123;        deny  all;    &#125;&#125;

最后，重启nginx。cd /usr/local/nginx/sbin，./nginx -s reload。
访问http://192.168.56.101，提示No input file specified.。出错了？不过没有太大影响。
输入函数完整路径，http://192.168.56.101/thinkphp/index.php/Home/Index/getInfo，获取信息成功！至此，nginx配置支持pathinfo成功！
nginx配置支持跨域紧接着上面的nginx.conf配置文件修改，添加一行即可：
add_header Access-Control-Allow-Origin *;location / &#123;    try_files $uri @rewrite;&#125;


No input file specified紧接着上面的nginx.conf配置文件修改，添加一行即可：
http &#123;    # 其他配置省略    fastcgi_intercept_errors on;    include vhost/*.conf;&#125;

后记至此，在虚拟机CentOS7上配置的nginx，已经支持pathinfo模式、支持跨域、404报错正常。
阿里云同样的配置，放在阿里云的CentOS6.5上居然报错！无奈，寻找另外一种配置nginx支持pathinfo模式的方法。只需要在nginx.conf初始配置的基础上，修改四个地方即可：
location ~ \.php &#123; #去掉$    root /home/wwwroot/; #增加这一句    fastcgi_pass   127.0.0.1:9000;    fastcgi_index  index.php;    fastcgi_split_path_info ^(.+\.php)(.*)$; #增加这一句    fastcgi_param PATH_INFO $fastcgi_path_info; #增加这一句    fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;    fastcgi_param  PHP_VALUE        open_basedir=$document_root:/tmp/:/proc/;    include        fastcgi_params;&#125;

添加跨域支持：
add_header Access-Control-Allow-Origin *;

域名绑定：
server_name localhost api.voidking.com;
然后，在万网添加域名解析A记录到阿里云主机ip地址。
书签最完美ThinkPHP nginx 配置文件https://my.oschina.net/zhuyajie/blog/523268
Nginx跨域配置，支持DELETE,PUT请求http://to-u.xyz/nginx-cors/
Nginx执行php显示no input file specified的处理方法http://www.ahlinux.com/nginx/3984.html
nginx指定404 No input file specifiedhttp://coolnull.com/238.html
简单配置nginx使之支持pathinfohttp://www.thinkphp.cn/topic/3228.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>nginx</tag>
        <tag>thinkphp</tag>
        <tag>pathinfo</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Travis CI部署项目到服务器</title>
    <url>/dev-travis-ci-deploy-to-server/</url>
    <content><![CDATA[前言《Hexo配置Travis CI自动发布》一文中，我们学习了使用travis-ci构建发布hexo项目的方法。
因为项目的特殊性，所以发布时只是把代码push到了git仓库，并没有把代码发布到我们自己的服务。本文，我们就来学习一下怎样通过travis-ci，把项目发布到我们自己的服务器。
需求：已知hexo项目部署在github，百度抓取不到github的内容，因此我们想要在自己的服务器也部署一份代码，国内的流量打到自己的服务器。实现国内流量 -&gt; 阿里云服务器，国外流量 -&gt; github pages。配置 hexo-deploy ，在发布时会同时发布静态页面到 voidking.github.io 和 voidking。阿里云服务器上有项目 /opt/nginx/work/voidking ，项目仓库为 voidking。现在想要实现的是，当使用 hexo-deploy 之后，阿里云服务器上的代码能够自动更新。


思路给 voidking.github.io 项目配置travis-ci，当静态页面更新完成后，在阿里云服务器上执行 git pull。中间需要解决的主要问题是： travis-ci 访问阿里云服务器的权限问题。
另外，因为 voidking.github.io 项目是线上项目，所以我们创建一个在github上和travis-ci上分别创建一个 travis-test 项目，用来测试travis-ci的配置。
配置travis-ci服务器密钥配置1、创建一个用户专门用来更新代码
useradd -m voidking -s /bin/bashpasswd voidkingchown voidking -R /opt/nginx/work/

2、生成密钥
su voidkingcd ~ssh-keygen
执行完之后，.ssh目录下生成了 id_rsa 和 id_rsa.pub。
3、使密钥生效
ALI_IP="8.136.13.58"ssh-copy-id -i .ssh/id_rsa.pub voidking@$&#123;ALI_IP&#125;ssh voidking@$&#123;ALI_IP&#125;

安装travis client直接安装travis破坏服务器环境，因此最好使用Docker安装travis。1、运行travis容器
docker pull ruby:slimdocker run --name travis -it -d ruby:slim /bin/bashdocker exec -it travis /bin/bash

2、容器内安装travis client
# gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/gem install travistravis -h

travis-ci密钥配置1、拷贝密钥到容器
docker cp /home/voidking/.ssh/id_rsa travis:/tmpdocker exec -it travis /bin/bash

2、登录travis-ci
cd /tmptravis login --com --github-token xxxxxx

3、对id_rsa加密，生成id_rsa.enc；同时生成服务端解密命令
touch .travis.ymltravis encrypt-file id_rsa --add --com --repo=voidking/travis-test
详情参考Encrypting Files。
执行完命令，会生成加密文件 id_rsa.enc，.travis.yml 中会被写入解密命令：
before_install:- openssl aes-256-cbc -K $encrypted_f217180e22ee_key -iv $encrypted_f217180e22ee_iv -in id_rsa.enc -out id_rsa -d
并且，变量 encrypted_f217180e22ee_key 和 encrypted_f217180e22ee_iv 会填入travis-ci上travis-test项目中的环境变量配置中。
travis.yml配置1、访问Travis CI Pro，找到 travis-test 项目，Settings，在Environment Variables一栏填入Name为GITEE_TOKEN，VALUE为gitee的access token。
2、在github上 travis-test 项目中放入 id_rsa.enc
3、在github上 travis-test 项目中创建 .travis.yml，内容为
sudo: falselanguage: pythonpython:- 3.6branches:  only:  - main # build main branch onlyenv:  global:  - ALI_IP: 8.136.13.58  - GIT_USER: voidking  - GITEE_PAGES_REPO: gitee.com/voidking/voidking.gitaddons:  ssh_known_hosts:   - 8.136.13.58before_install:- openssl aes-256-cbc -K $encrypted_f217180e22ee_key -iv $encrypted_f217180e22ee_iv -in id_rsa.enc -out ~/.ssh/id_rsa -d- chmod 600 ~/.ssh/id_rsascript:- ssh voidking@$&#123;ALI_IP&#125; "cd /opt/nginx/work/voidking/ &amp;&amp; git pull --force --quiet \"https://$&#123;GIT_USER&#125;:$&#123;GITEE_TOKEN&#125;@$&#123;GITEE_PAGES_REPO&#125;\" master:master"after_success:- echo "deploy success"

4、提交代码
git add .git commmit -m "添加travis.yml"git push

5、验证打开travis voidking/travis-test ，可以看到脚本已经成功执行。
登录阿里云服务器，git log查看代码版本，确实也已经更新到了最新版。nice！
最后，同样的步骤配置到 voidking.github.io 项目上即可。
配置travis-ci简化版上面的流程，安全性较高，但是整个流程很麻烦，有没有更简单的办法？必须是有的。方法一：安装sshpass，直接使用密码登录服务器执行命令。方法二：把私钥作为参数配置到travis-ci，使用时写入到文件中。
本节中我们研究一下方法二的配置方法。
服务器密钥配置1、创建一个用户专门用来更新代码
useradd -m voidking -s /bin/bashpasswd voidkingchown voidking -R /opt/nginx/work/

2、生成密钥
su voidkingcd ~ssh-keygen
执行完之后，.ssh目录下生成了 id_rsa 和 id_rsa.pub。
3、使密钥生效
ALI_IP="8.136.13.58"ssh-copy-id -i .ssh/id_rsa.pub voidking@$&#123;ALI_IP&#125;ssh voidking@$&#123;ALI_IP&#125;

travis-ci密钥配置1、加密私钥cat .ssh/id_rsa | base64 | tr -d &#39;\n&#39;
2、访问Travis CI Pro，找到 travis-test 项目，Settings，Environment Variables。创建两组环境变量：

Name为GITEE_TOKEN，VALUE为gitee的access token。
Name为ID_RSA，VALUE为加密后的私钥。

travis.yml配置1、在github上 travis-test 项目中创建 .travis.yml，内容为
sudo: falselanguage: pythonpython:- 3.6branches:  only:  - main # build main branch onlyenv:  global:  - ALI_IP: 8.136.13.58  - GIT_USER: voidking  - GITEE_PAGES_REPO: gitee.com/voidking/voidking.gitaddons:  ssh_known_hosts:   - 8.136.13.58before_install:- echo $&#123;ID_RSA&#125; | base64 -d &gt; ~/.ssh/id_rsa- chmod 600 ~/.ssh/id_rsascript:- ssh voidking@$&#123;ALI_IP&#125; "cd /opt/nginx/work/voidking/ &amp;&amp; git pull --force --quiet \"https://$&#123;GIT_USER&#125;:$&#123;GITEE_TOKEN&#125;@$&#123;GITEE_PAGES_REPO&#125;\" master:master"after_success:- echo "deploy success"

2、提交代码
git add .git commmit -m "简化travis.yml"git push

3、验证打开travis voidking/travis-test ，查看脚本执行日志。登录阿里云服务器，git log查看代码版本。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>hexo</category>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>cicd</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 14.04.5 Server物理机安装</title>
    <url>/dev-ubuntu-14.04.5-server-install/</url>
    <content><![CDATA[前言机房里有十几台服务器需要安装系统，这里选择Ubuntu 14.04.5 Server版。本文，就图文记录一下Ubuntu 14.04.5 Server (64-bit)的物理机的安装过程。


思路我们知道，使用虚拟机安装ubuntu很简单，选好配置，设置好镜像，启动虚拟机一步步安装就可以了。但是，在物理机上安装却没有那么简单，尤其是server版，过程中有很多坑。假设使用U盘安装，一般安装思路如下：
1、下载Ubuntu 14.04.5 Server (64-bit)的镜像。2、使用usb-installer、Win32DiskImager、UltraISO等把镜像写入U盘。3、插入U盘到服务器，设置BIOS把U盘作为第一启动项。4、一步步安装配置，解决各种坑。
第一次尝试下载镜像访问Ubuntu官网，下载Ubuntu 14.04.5 Server (64-bit)。
镜像写入1、访问Universal USB Installer – Easy as 1 2 3，下载usb-installer。
2、双击启动usb-installer，按照下图选择，然后Create。
3、把镜像拷贝进U盘。
BIOS设置开机时，提示可能有：

Press Esc to enter SETUP
Press F2 go to Setup Utility
Press DEL to enter EFI BIOS SETUP
Press Del run Setup
Press F1 run Setup
Press F2 to Setup

等等，按照提示狂点几下提示的按键就可以进入BIOS界面。选择选择U盘作为第一启动项，保存退出。
安装配置安装过程如下图：
不知道大家注意到了没有，到了最后一张图，实际上和倒第四张图相同，也就是说，开始循环了。而此时的主机还没有网络，无法从网络下载镜像。
U盘安装Ubuntu-14.04.2-server一文给出了解决办法：挂载iso文件到/cdrom目录。然而，我的操作却失败了。
继续查找安装失败的原因，找到了14.04server LTS安装为啥跳不过choose mirror 这一步骤和14.04.1 server install without internet access，和我的问题一毛一样。怀疑是usb-installer的问题，决定换成Win32DiskImager。
备注：之前在同一台机器上，用usb-installer安装ubuntu desktop版，一路畅通无阻安装成功。。。
第二次尝试第二次尝试，主要是重新制作镜像。
镜像写入1、访问Win32DiskImager和Win32DiskImager makes an Ubuntu family USB boot drive in Windows，下载Win32DiskImager。
2、双击启动Win32DiskImager，按照下图选择，然后点击“写入”。
此时，出现一个坑，U盘空间变小了，变成了2.18MB。而且U盘里只有一个文件夹：efi。空间太小，也就无法把镜像再拷贝进U盘里。
使用这样一个2.18MB的U盘，能安装成功？我保持怀疑。
安装配置一直到上图，都和第一次尝试相同。接下来却发生了变化：注意，到上图的步骤时，点击空格选择安装OpenSSH server。
然后，就安装成功了吗？并没有！卡在了最后一步Installing GRUB boot loader！等了20分钟，没有丝毫动静。重启看看，果然无法启动系统！
离成功如此接近，最后却失败了，蓝瘦！莫非，是因为某个步骤没有配置好？于是，重装，在Partition disks一步，选择yes后继续，依然卡在最后一步。
再来一次，在Partition disks一步，选择Guided-reuse partition…，然后，居然安装成功！
但是，高兴的太早了，选择Ubuntu，并没有进入到登录页面，而且键盘失效了，插哪个USB接口都没有任何反应。折腾继续。。。
再次重装，配置选择和之前没有什么不同，没想到一路顺利，安装成功！对于这种莫名其妙的成功，我也是很无奈啊。。。
后记以前在物理机上安装过很多次Linux，只不过没有记录。因为安装系统的过程无法截图，只能挨个拍照，很麻烦。这次下了很大的决心，完成了本文，给自己点个赞，真是个勤劳的郝同学啊！
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu更换源列表</title>
    <url>/dev-ubuntu-change-sources/</url>
    <content><![CDATA[前言Ubuntu默认的安装源是http://archive.ubuntu.com/ubuntu/，在国内访问速度比较慢。最好是换成国内的安装源，能够节省很多时间。本文中，我们假设系统为Ubuntu14.04.5，打算换成Ubuntu官方中国的安装源（阿里、网易、搜狐等的更换方法类似）。Ubuntu14的源地址可以在模板:14.04source中找到，其他版本Ubuntu的源地址可以在源列表中找到。


配置步骤配置步骤参考如何修改Ubuntu的源列表(source list)，操作如下：
1、备份源列表文件sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
2、编辑源列表文件sudo vim /etc/apt/sources.list
修改为：
deb http://cn.archive.ubuntu.com/ubuntu/ trusty main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu/ trusty-security main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiverse##測試版源deb http://cn.archive.ubuntu.com/ubuntu/ trusty-proposed main restricted universe multiverse# 源碼deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty main restricted universe multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiverse##測試版源deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-proposed main restricted universe multiverse# Canonical 合作夥伴和附加# deb http://archive.canonical.com/ubuntu/ trusty partner# deb http://extras.ubuntu.com/ubuntu/ trusty main

3、更新资源包sudo apt-get update
如果报错Error connecting: Could not connect: Connection refused ，那么可以参考“Unable to connect” error with apt-get?和apt-get update Error connecting Could not connect Connection refused。
4、更新软件sudo apt-get upgrade
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu14.04配置DNS Server</title>
    <url>/dev-ubuntu-dns-server/</url>
    <content><![CDATA[前言《Ubuntu系统批量自动安装》一文中，也许会用到DNS Server，那么就来研究配置一下。
配置目标：在Ubuntu14.04上，搭建一个DNS服务器，服务器地址为10.0.0.100。使用这个DNS，可以把dns.voidking.com域名解析到10.0.0.100这个地址。


实践安装安装命令：sudo apt-get update
sudo apt-get install bind9
安装完成后，会创建/etc/bind目录，里面有很多配置文件。
DNS正反解区域1、添加DNS正反解区域，需要修改named.conf.default-zones
sudo vim /etc/bind/named.conf.default-zones，在最后添加：
zone "voidking.com" &#123;        type master;        file "/etc/bind/db.voidking.com";&#125;;zone "0.0.10.in-addr.arpa" &#123;        type master;        file "/etc/bind/db.10.0.0";&#125;;
添加正解区域“voidking.com”，以及反解区域“10.0.0.0”
2、创建db.voidking.com并编辑cd /etc/bindsudo cp db.local db.voidking.comsudo vim db.voidking.com
添加一个A记录到10.0.0.100：
;; BIND data file for local loopback interface;$TTL    604800@       IN      SOA     localhost. root.localhost. (                              2         ; Serial                         604800         ; Refresh                          86400         ; Retry                        2419200         ; Expire                         604800 )       ; Negative Cache TTL;@       IN      NS      localhost.@       IN      A       127.0.0.1@       IN      AAAA    ::1dns     IN      A       10.0.0.100

3、创建db.10.0.0并编辑sudo cp db.127 db.10.0.0sudo vim db.10.0.0
添加100的反向解析到dns.voidking.com：
;; BIND reverse data file for local loopback interface;$TTL    604800@       IN      SOA     localhost. root.localhost. (                              1         ; Serial                         604800         ; Refresh                          86400         ; Retry                        2419200         ; Expire                         604800 )       ; Negative Cache TTL;@       IN      NS      voidking.com.100     IN      PTR     dns.voidking.com.

测试1、测试访问ping dns.voidking.com这次访问会提示 connection timed out: no servers could be reached，或者提示 ping: unknown host dns.voidking.com
2、重启dns服务sudo /etc/init.d/bind9 restart
3、测试访问ping dns.voidking.com这次访问，就可以正常ping到服务器100的ip地址。
host 10.0.0.100，可以看到10.0.0.100绑定到了dns.voidking.com。
至此，DNS服务器已经配置成功。但是，我们本地的这个DNS服务器上存的域名太少了，比如ping www.baidu.com，就会ping不通。这时，我们需要配置转发服务器。
配置转发服务器1、编辑named.conf.optionssudo vim named.conf.options
forwarders设置转发DNS为180.76.76.76，allow-query设置为0.0.0.0/0：
options &#123;        directory "/var/cache/bind";        // If there is a firewall between you and nameservers you want        // to talk to, you may need to fix the firewall to allow multiple        // ports to talk.  See http://www.kb.cert.org/vuls/id/800113        // If your ISP provided one or more IP addresses for stable        // nameservers, you probably want to use them as forwarders.        // Uncomment the following block, and insert the addresses replacing        // the all-0's placeholder.        forwarders &#123;                180.76.76.76;        &#125;;        allow-query &#123;                0.0.0.0/0;        &#125;;        //========================================================================        // If BIND logs error messages about the root key being expired,        // you will need to update your keys.  See https://www.isc.org/bind-keys        //========================================================================        dnssec-validation auto;        auth-nxdomain no;    # conform to RFC1035        listen-on-v6 &#123; any; &#125;;&#125;;

2、重启DNS服务sudo /etc/init.d/bind9 restart
3、测试访问ping www.baidu.com
4、其他机器测试访问同局域网主机在/etc/resolv.conf中添加：
nameserver 10.0.0.100

然后ping dns.voidking.com，ping www.baidu.com
后记至此，DNS Server安装配置成功，更高级的用法需要时再去学习。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>dns</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装配置zabbix</title>
    <url>/dev-ubuntu-install-zabbix/</url>
    <content><![CDATA[前言对于服务器集群的监控，有很多可选的开源技术方案，比如zabbix，nagios，Cacti，Munin，icinga，ganglia ，collectd + graphite，influxed + grafana，prometheus等。以前简单研究过ganglia，本文中，来研究学习一下zabbix。


zabbix简介参考zabbix监控的基础概念、工作原理及架构，我们了解到zabbix是一个分布式系统监控和网络监视工具。zabbix支持主机的性能监控、网络设备性能监控、数据库性能监控、多种告警方式、详细的报表图表绘制。zabbix的基本工作原理为：zabbix agent需要安装到被监控的主机上，它负责定期收集各项数据，并发送到zabbix server端，zabbix server将数据存储到数据库中，zabbix web根据数据在前端进行展现和绘图。这里agent收集数据分为主动和被动两种模式。
环境准备在VirtualBox中创建两台Ubuntu16虚拟机，zabbix0和zabbix1。硬件配置都是1核2GB内存，IP分别为192.168.56.200和192.168.56.201。
zabbix0上安装zabbix-server和zabbix-agent，zabbix1上zabbix-agent。
sudo -i切换到root用户，方便安装配置。
zabbix0zabbix服务端的安装配置，主要参考在Ubuntu16.04 Server上安装Zabbix。
软件安装1、安装zabbix需要的PHP模块apt-get install php7.0-bcmath php7.0-xml php7.0-mbstring
2、下载导入zabbix-server安装源
wget http://repo.zabbix.com/zabbix/3.2/ubuntu/pool/main/z/zabbix-release/zabbix-release_3.2-1+xenial_all.debdpkg -i zabbix-release_3.2-1+xenial_all.debapt-get update
Ubuntu仓库中提供的zabbix是过时的，因此使用官方的安装包。
3、安装zabbix-server（支持mysql的版本）和zabbix-webapt-get install zabbix-server-mysql zabbix-frontend-php
4、安装zabbix-client（可选）apt-get install zabbix-agent
mysql配置1、登录mysqlmysql -uroot -p默认密码为空。
2、创建zabbix数据库和zabbix用户
create database zabbix character set utf8 collate utf8_bin;grant all privileges on zabbix.* to zabbix@localhost identified by 'zabbix_password';exit;

3、导入初始表和数据
zcat /usr/share/doc/zabbix-server-mysql/create.sql.gz | mysql -uzabbix -p zabbix

zabbix-server配置1、vim /etc/zabbix/zabbix_server.conf，如下修改：
# line 81, uncommentDBHost=localhost# line 91, changeDBName=zabbix# line 107, changeDBUser=zabbix# line 115, uncomment and changeDBPassword=zabbix_password

2、vim /etc/zabbix/apache.conf，如下修改：
# line 19, uncomment and changephp_value date.timezone Asia/Shanghai# line 28, uncomment and changephp_value date.timezone Asia/Shanghai

3、重启apache，启动zabbix-server并设置开机启动
systemctl restart apache2systemctl start zabbix-serversystemctl enable zabbix-serversystemctl status zabbix-server

zabbix-web配置1、浏览器访问 http://192.168.56.200/zabbix
2、点击“Next step”，按照提示进行安装配置。中间只要填写一次数据库密码，其他的默认即可。安装完成后的配置文件为/usr/share/zabbix/conf/zabbix.conf.php。
3、浏览器访问 http://192.168.56.200/zabbix/index.php使用默认的用户Admin和密码zabbix登录，即可进入管理界面。此时，我们看到Number of hosts enabled为0。
zabbix-agent配置1、vim /etc/zabbix/zabbix_agentd.conf，如下修改：
# line 95, changeServer=127.0.0.1# line 136, changeServerActive=127.0.0.1# line 147, changeHostname=zabbix0
其中Server和ServerActive指的是Zabbix Server，Hostname指的是client server name。
2、启用zabbix-agent并设置开机启动
systemctl start zabbix-agentsystemctl enable zabbix-agent
此时，在zabbix web管理页面依然看不到主机的信息。
3、在zabbix web管理页面添加zabbix0主机，参考How to Add Host in Zabbix Server to Monitor。
（1）在zabbix web管理页面，Configuration，Hosts，Create host。（2）在Host标签页，填入如下信息。

Hostname: Enter hostname of Remote system
Visible name: Name to be display in zabbix
Group: Select the desired group for you host
Agent interface: Fill the info of Zabbix agent running on host
Enabled: Check for active

（3）在Templates标签页，点击Select选择要监控的指标，点击Add链接确认。（4）点击Add按钮确认添加host。
此时，就可以在zabbix web管理页面看到host的信息了，选择host的Graphs，即可查看host状态相关的绘图。
zabbix11、下载导入zabbix-server安装源
wget http://repo.zabbix.com/zabbix/3.2/ubuntu/pool/main/z/zabbix-release/zabbix-release_3.2-1+xenial_all.debdpkg -i zabbix-release_3.2-1+xenial_all.debapt-get update

2、安装zabbix-clientapt-get install zabbix-agent
3、vim /etc/zabbix/zabbix_agentd.conf，如下修改：
# line 95, changeServer=192.168.56.200# line 136, changeServerActive=192.168.56.200# line 147, changeHostname=zabbix1

4、启用zabbix-agent并设置开机启动
systemctl start zabbix-agentsystemctl enable zabbix-agent

5、在zabbix web管理页面添加zabbix1主机，再添加一台不存在的zabbix2主机。添加完成后即可看到三台主机都是Enabled，等待两分钟后界面显示其中一台不可用。
后记至此，zabbix就安装配置完成了，更高级的用法，用到了再去研究学习。
书签Zabbix Documentation 3.2
How to Install Zabbix Server 3.4 on Ubuntu 18.04 &amp; 16.04 LTS
How To Install Zabbix Agent on Ubuntu 18.04 &amp; 16.04 LTS
ubuntu 16.04.1 LTS zabbix-agent安装
Update-rc.d 命令用法详解
zabbix常见指标项梳理
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>监控</tag>
        <tag>zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu Kylin编译内核和添加系统调用</title>
    <url>/dev-ubuntu-kylin-compile-kernel-and-add-systemcall/</url>
    <content><![CDATA[下载内核查看当前内核版本uname -a可以看到，当前内核版本为3.16.0。


获取当前版本内核源码sudo apt-get install linux-source内核源码默认下载到/usr/src文件夹下，这里，我们就使用这套源码。
官方下载地址https://www.kernel.org/这个网站，你可以找到最新的内核版本，如果要想要给内核升级，可以来这里下载。
解压内核cd /usr/src/tar -jvf linux-source-3.16.0.tar.bz2解压失败：
tar: You must specify one of the '-Acdtrux', '--delete' or '--test-label' optionsTry 'tar --help' or 'tar --usage' for more information.

添加一个参数x：tar -xjvf linux-source-3.16.0.tar.bz2再次失败，各种Permission denied。
sutar -xjvf linux-source-3.16.0.tar.bz2虽然速度很慢（3分钟左右），但是好歹解压成功了。
添加系统调用修改sys.ccd linux-source-3.16.0/kernel/gedit sys.c添加如下代码：
/* *new systemcall added by voidking */asmlinkage int sys_callvoidking(void)&#123;	printk("You are handsome,VoidKing!");	return 0;&#125;

修改syscall_32.tblcd /usr/src/linux-source-3.16.0/arch/x86/syscallsgedit syscall_32.tbl在最后一行插入
355	i386	callvoidking		sys_callvoidking

修改syscalls.hcd /usr/src/linux-source-3.16.0/include/linux/gedit syscalls.h在#endif前添加：
asmlinkage int sys_callvoidking(void);

编译准备libncurses5-dev安装nucurses库，为了make menuconfig调用。apt-get install libncurses5-dev
配置文件把原先系统的配置文件拷贝到当前源码目录。cp /boot/config-\uname -r` .config`
加载配置文件make menuconfig，打开编译配置界面，load，ok，save，exit。
编译命令编译内核make -j8或者make bzImage，前者更快一点。
有些同学要两个小时才能编译完成，郝同学使用VirtualBox，只用了20分钟，电脑配置之牛逼可见一斑！哇哈哈哈！
编译模块make modules，编译模块时，郝同学自己添加的系统调用出现了警告，不过不影响接下来的编译。一个小时之后。。。噗！要吐血了，之前分给虚拟机8G存储空间，没想到编译过程中，空间不足了，没法继续编译。。。
扩展Ubuntu空间1、首先关闭虚拟机，在设置中给Ubuntu再添加一块虚拟硬盘。2、打开虚拟机，cd /dev3、fdisk sdb4、命令p：查看当前新盘状态。5、命令n：创建一个新的分区。6、两个选项e（扩展分区）和p（主分区），选择p。7、连续两次回车，使用默认的起始和结束sector。8、创建了一个sdb1，大小为整块虚拟硬盘。9、命令w：保存退出。10、mkfs -t ext4 sdb1，格式化。11、cd /mnt，mkdir sdb1，mount /dev/sdb1 sdb112、cd sdb1，cp -rv /usr/src/linux-source-3.16.0 .13、umount sdb1，mount /dev/sdb1 /usr/src
重新编译模块cd /usr/src/linux-source-3.16.0，make modules等。。。再等。。。继续等。。。四个小时之后，提示空间不足。。。我靠，你丫到底需要多大空间？8G的空间不够你编译程序用的！！！哭了。。。
加速编译寻找加速编译内核的办法，发现，似乎make -j8等于make bzImage加make modules。去掉编译模块这个步骤试试：make mrproper，make clean，make -j8，然后make modules_install。报错：
  INSTALL arch/x86/crypto/aes-x86_64.kocp: cannot stat ‘arch/x86/crypto/aes-x86_64.ko’: No such file or directoryCan't read private keyscripts/Makefile.modinst:30: recipe for target 'arch/x86/crypto/aes-x86_64.ko' failedmake[1]: *** [arch/x86/crypto/aes-x86_64.ko] Error 2Makefile:1089: recipe for target '_modinst_' failedmake: *** [_modinst_] Error 2
猜测是配置文件.config文件有问题，换成/usr/src/linux-headers-3.16.0-23-generic目录下的.config文件。重新编译，安装，还是报同样错误。那就再加上编译模块这个步骤吧！
第三次编译模块make -j8 modules，大概四个小时之后，终于编译完成。安装模块报错，和make -j8编译后直接安装模块报错相同。给跪了，能不能愉快地玩耍了！
找到错误后来，仔细检查了前面的步骤。发现修改syscalls.h的时候，声明类型写错了，本该是int，却写成了long类型。修改成int，一路顺利。实践证明，make -j8等于make bzImage加make modules。
安装模块make modules_install
建立映像文件建立要载入ramdisk的映像文件mkinitramfs -o /boot/initrd-mylinux.imgcd /boot，ll
安装内核make install
更新grub引导update-grub
测试选择新内核开机时，选择新内核引导系统。
voidking.c新建文件voidking.c，内容如下：
#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#define callvoidking 355int main()&#123;	syscall(callvoidking);	return 0;&#125;
编译执行gcc -o voidking voidking.c./voidking最终什么都没有显示出来，不知道错在哪里。。。也许是sys.c中的函数没有写好，不重做了，整个流程耗时太久，领会精神就够了。
小结为Linux添加新的系统调用，主要包括有4个步骤：编写系统调用服务例程；添加系统调用号；修改系统调用表；重新编译内核并测试新添加的系统调用。
虽然这次实验最终失败了，但是，我掌握了添加系统调用和编译内核的流程，培养了耐心以及分析解决问题的能力。也算是收获颇丰，吼吼！
参考文档Ubuntu 14.04 TLS 内核升级和添加系统调用http://yunpan.cn/cQtsTfkbeTPvG  访问密码 adce

如何实现一个新的系统调用http://book.51cto.com/art/201007/213651.htm

ubuntu下重新编译内核http://m.blog.csdn.net/blog/chen_jianjian/42168449

Ubuntu Linux内核编译步骤http://www.linuxidc.com/Linux/2012-03/57303.htm

Add a system call to the linux kernel in Ubuntuhttp://www.franksthinktank.com/howto/addsyscall/

Ubuntu添加系统调用http://gnodsy.blog.163.com/blog/static/17754713320112135352447/

Ubuntu内核的重新编译安装http://www.linuxidc.com/Linux/2009-12/23721.htm
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Ubuntu时的一些问题</title>
    <url>/dev-ubuntu-questions/</url>
    <content><![CDATA[安装特别慢ubuntu安装过程“retrieving file 43 of 105”就停住了。问题及解决办法：文件系统不对，重新分区，再次安装。


激活root账号在安装系统时，root账户并没有被激活来供你使用，即root帐号被隐藏了，而是通过初始用户与sudo的结合使用来完成一些需要root权限的任务。这样做的好处是防止你不得不使用root来进行一些系统的初级管理，同时完全允许另一个账户来充当超级用户，也保护了你系统的安全方面的缺陷。如果你需要使用root用户来完成一些工作的话，使用以下命令激活root用户：
法一：在终端中输入：sudo passwd root之后要求你输入两次root用户的密码，重启后就可以登陆root用户了。退出root权限方法：exit若想禁用 root 帐号： sudo passwd -l root
法二：1、重启电脑，选择recovery模式2、找到最下边的root选项3、在recovery模式的root用户下创建一个root用户，输入：passwd root4、两次输入新密码即可
root初始密码设置sudo passwd系统提示输入密码，即安装时的用户密码，然后，系统提示输入两次新密码。
su提示输入密码，输入密码后就切换到了root。
vim更新ubuntu下使用Vi时方向键变乱码 退格键不能使用的解决方法:sudo apt-get remove vim-commonsudo apt-get install vim如果安装失败，提示：
Package vim is not available, but is referred to by another package.
请先执行：sudo apt-get update
root用户登录图形界面Ubuntu12.10设置root用户登录图形界面。
1、先设定一个root的密码sudo passwd root
2、root 登陆su root
3、备份一下lightgdmcp -p /etc/lightdm/lightdm.conf /etc/lightdm/lightdm.conf.bak
4、编辑lightdm.confsudo gedit /etc/lightdm/lightdm.conf
5、加：
greeter-show-manual-login=true
修改后为：
[SeatDefaults]greeter-session=unity-greeteruser-session=ubuntugreeter-show-manual-login=true

重启登陆即可。已经可以输入root了。
注意：如果root登陆后没声音，又查了查，如下方法:Ubuntu root登录没有声音这个问题的根本原因是使用root登录后pulseaudio没有启动。将root加到pulse-access组：sudo usermod -a -G pulse-access root然后修改配置文件/etc/default/pulseaudio，将PULSEAUDIO_SYSTEM_START设为1。
NTFS文件系统权限问题修改 ubuntu NTFS 文件系统下没有执行权限的问题。由于NTFS本身的特殊性，不能对其分区的文件权限进行修改，无论是suodo还是root都没有用。
安装以下两个插件解决问题：sudo apt-get install ntfs-3g，这个12.04已经有了。sudo apt-get install ntfs-config，这个是个图形界面的NTFS权限配置程序。


打开ntfs-config后，我把权限全开了。
再看NTFS目录下的所有文件，权限都有了。不过还是不能用chmod命令来修改。
同时，ntfs-config可以帮助用户自动挂载所有硬盘分区：
sudo ntfs-config，自动挂载所有分区。
实际就是在/etc/fstab中添加相应的挂载信息，如不需要，可以直接删掉，重启后就不再自动挂载了。
附：查看硬盘分区UUID的命令：sudo blkid
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——glance篇</title>
    <url>/dev-ubuntu16-manual-openstack-glance/</url>
    <content><![CDATA[目标紧接着《Ubuntu16手动安装OpenStack——keystone篇》，本文我们来安装glance，主要参考Glance Installation Tutorial for Ubuntu。


glance简介Image服务（glance）使用户能够发现、注册和检索虚拟机映像。它提供了一个REST API，使用户可以查询虚拟机镜像元数据并检索实际镜像。用户可以通过Image服务，把虚拟机映像存储在各种位置，从简单的文件系统到OpenStack Object Storage等对象存储系统。
为简单起见，官方教程中介绍如何配置Image服务以使用文件后端，该文件后端上载并存储在托管Image服务的控制器节点上的目录中。默认情况下，此目录为/var/lib/glance/ images/。在继续之前，请确保控制器节点在此目录中至少有几千兆字节的可用空间。请记住，由于文件后端通常是控制器节点的本地，因此通常不适合多节点glance部署。
OpenStack Image服务是Infrastructure-as-a-Service（IaaS）的核心。它接受来自磁盘或服务器映像的API请求，以及来自终端用户或OpenStack Compute组件的元数据定义。它还支持在各种存储库类型（包括OpenStack Object Storage）上存储磁盘或服务器映像。许多定期进程在OpenStack Image服务上运行以支持缓存。Replication服务可确保群集的一致性和可用性，其他定期进程包括auditors，updaters和reapers。
OpenStack Image服务包括以下组件：
glance-api接受Image API调用以进行镜像发现，检索和存储。
官方建议将Glance作为独立服务器以传统方式运行。
glance-registry存储，处理和检索有关镜像的元数据。元数据包括大小和类型等选项。
注册表是一个私有的内部服务，供OpenStack Image服务使用，不要将此服务公开给用户。
Glance注册服务及其API已在queens版本中弃用，并且在“S”开发周期开始后，可根据OpenStack标准弃用政策进行删除。
Database存储镜像元数据，您可以根据自己的喜好选择数据库，大多数部署使用MySQL或SQLite。
Storage repository for image files支持各种存储库类型，包括常规文件系统（或安装在glance-api控制器节点上的任何文件系统），Object Storage，RADOS块设备，VMware数据存储和HTTP。
请注意，某些存储库仅支持只读用法。
Metadata definition service供应商、管理员、服务和用户的通用API，用于定义自己的元数据。此元数据可用于不同类型的资源，如 images、artifacts、volumes、flavors和aggregates。定义包括新属性的关键字、描述、约束和它可以关联的资源类型。
安装和配置本节介绍如何在控制器节点上安装和配置镜像服务（glance）。为简单起见，此配置将镜像存储在本地文件系统上。
root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
数据库1、登录数据库mysql -uroot -p，密码为openstack。
2、创建glance数据库CREATE DATABASE glance;
3、授权GRANT ALL PRIVILEGES ON glance.* TO &#39;glance&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;openstack&#39;;
GRANT ALL PRIVILEGES ON glance.* TO &#39;glance&#39;@&#39;%&#39; IDENTIFIED BY &#39;openstack&#39;;
4、退出数据库exit;
服务证书和端点1、使admin环境生效. admin-openrc
2、创建glance用户openstack user create --domain default --password-prompt glance
根据提示设置密码为openstack。
3、将admin角色添加到glance用户和service项目上openstack role add --project service --user glance admin
4、创建glance服务实体openstack service create --name glance --description &quot;OpenStack Image&quot; image
5、创建镜像服务API endpoints
openstack endpoint create --region RegionOne image public http://controller:9292openstack endpoint create --region RegionOne image internal http://controller:9292openstack endpoint create --region RegionOne image admin http://controller:9292

安装和配置组件1、安装glanceapt -y install glance
2、备份glance-api.confmv /etc/glance/glance-api.conf /etc/glance/glance-api.conf.bak
3、vim /etc/glance/glance-api.conf，新建glance-api.conf文件内容为：
[DEFAULT]bind_host = 0.0.0.0[glance_store]default_store = filefilesystem_store_datadir = /var/lib/glance/images/[database]# MariaDB connection infoconnection = mysql+pymysql://glance:openstack@controller/glance# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = glancepassword = openstack[paste_deploy]flavor = keystone

4、备份glance-registry.confmv /etc/glance/glance-registry.conf /etc/glance/glance-registry.conf.bak
5、vim /etc/glance/glance-registry.conf，新建glance-registry.conf内容为：
[DEFAULT]bind_host = 0.0.0.0[database]# MariaDB connection infoconnection = mysql+pymysql://glance:openstack@controller/glance# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = glancepassword = openstack[paste_deploy]flavor = keystone

6、更改权限
chmod 644 /etc/glance/glance-api.conf /etc/glance/glance-registry.confchown glance. /etc/glance/glance-api.conf /etc/glance/glance-registry.conf

7、生成glance数据库结构su -s /bin/bash glance -c &quot;glance-manage db_sync&quot;
完成后登录mysql查看数据。
查看日志命令：tail /var/log/glance/glance-api.log
tail /var/log/glance/glance-registry.log
8、重启镜像服务systemctl restart glance-api glance-registry
验证操作1、使admin环境生效. admin-openrc
2、下载corris镜像wget http://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img
3、上传corris镜像到glance，存储为QCOW2格式，并且设置为所有人可见
openstack image create "cirros" \  --file cirros-0.4.0-x86_64-disk.img \  --disk-format qcow2 --container-format bare \  --public


有关OpenStack映像创建参数的信息，请参阅OpenStack用户指南中的创建或更新映像（glance）。
有关映像的磁盘和容器格式的信息，请参阅OpenStack虚拟机映像指南中的映像的磁盘和容器格式。
4、查看镜像openstack image list
看到镜像ID、Name和Status。
cd /var/lib/glance/images，可以看到名为镜像ID的文件。

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——horizon篇</title>
    <url>/dev-ubuntu16-manual-openstack-horizon/</url>
    <content><![CDATA[目标完成了《Ubuntu16手动安装OpenStack——创建实例》，验证了之前的安装没有大的问题。
本文，我们来研究一下horizon的安装配置，主要参考Horizon: Install and configure for Ubuntu 和 OpenStack Queens : Configure Horizon。


说明由于电脑配置有限，已经没有多余的资源分配给虚拟机，所以接下来的安装配置转移到实体上。实体机系统为ubuntu-16.04.4-server-amd64，配置为32核64GB内存8TB存储。有四张网卡分别为eno1、eno2、eno3和eno4，其中eno1的IP为172.16.0.105，eno2的ip为172.16.101.105，eno3配置为neutron使用的网卡。
172.16.0.105需要通过跳板机访问，172.16.101.105可以本地直连。
实体机同样安装好了keystone、glance、nova和neutron服务，也测试创建了实例。除了配置更高，其他等同于之前的控制节点。
horizon简介horizon（dashboard）一般安装在控制器节点上，所需的唯一核心服务是身份认证服务。我们可以将horizon与其他服务结合使用，例如镜像服务，计算和网络。也可以在具有独立服务（如对象存储）的环境中使用horizon。
queens版本的horizon需要以下依赖：
（1）Python 2.7（2）Django 1.11。Django 1.8到1.10也受支持，不过他们的支持将在Rocky版本中被删除。（3）可访问的keystone端点。（4）所有其他服务都是可选的。如果配置了服务的keystone端点，则horizo​​n会检测它并自动启用其支持。queens发布时，Horizo​​n支持以下服务：

cinder: Block Storage
glance: Image Management
neutron: Networking
nova: Compute
swift: Object Storage
Horizon also supports many other OpenStack services via plugins. 

安装配置1、安装horizonapt-get -y install openstack-dashboard
2、编辑horizon配置文件vi /etc/openstack-dashboard/local_settings.py
如下修改：
# line 39 uncomment and add own hostnameALLOWED_HOSTS = ['controller', 'localhost']# line 65: uncomment like followsOPENSTACK_API_VERSIONS = &#123;#    "data-processing": 1.1,    "identity": 3,    "image": 2,    "volume": 2,    "compute": 2,&#125;# line 76: uncomment and changeOPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True# line 98: uncommentOPENSTACK_KEYSTONE_DEFAULT_DOMAIN = 'Default'# line 163: change to your own Memcache serverCACHES = &#123;    'default': &#123;        'BACKEND': 'django.core.cache.backends.memcached.MemcachedCache',        'LOCATION': '172.16.0.105:11211',    &#125;,&#125;# line 190: change to your own HostOPENSTACK_HOST = "172.16.0.105"OPENSTACK_KEYSTONE_URL = "http://%s:5000/v3" % OPENSTACK_HOSTOPENSTACK_KEYSTONE_DEFAULT_ROLE = "_member_"

3、重启apache2和memcachedsystemctl restart apache2 memcached
简单使用1、测试访问访问地址：http://172.16.101.105/horizon/auth/login/
2、Domain输入default，用户名输入admin，密码输入openstack。登录horizon。
3、查看项目和用户。点击左侧导航栏身份认证，项目或者用户。
4、查看cirros0实例。身份认证，项目，siat，查看使用量。
5、退出登录
简单使用21、测试访问访问地址：http://172.16.101.105/horizon/auth/login/
2、Domain输入default，用户名输入voidking，密码输入openstack。登录horizon。
3、同样可以看到cirros0实例，并且进行管理。
访问实例参考OpenStack添加镜像，添加ubuntu16的官方镜像，创建实例，分配的IP为10.0.0.208。
1、在控制节点通过密钥访问ssh ubuntu@10.0.0.208 -i id_rsa
2、在本地通过网页访问点击实例名称，控制台，即可拿到vnc地址，比如 http://controller:6080/vnc_auto.html?token=a92733f2-e6c5-45e8-8521-5ace9b747957&amp;title=k8s01
把controller替换为172.16.101.105，得到 http://172.16.101.105:6080/vnc_auto.html?token=a92733f2-e6c5-45e8-8521-5ace9b747957&amp;title=k8s01
访问该地址，即可看到网页控制台。
3、在本地通过密钥访问（1）在控制节点新建portmap.sh脚本，内容为：
#!/bin/bashpro='tcp'NAT_Host='172.16.0.105'NAT_Port=20822Dst_Host='10.0.0.208'Dst_Port=22iptables -t nat -A PREROUTING -m $pro -p $pro --dport $NAT_Port -j DNAT --to-destination $Dst_Host:$Dst_Portiptables -t nat -A POSTROUTING -m $pro -p $pro --dport $Dst_Port -d $Dst_Host -j SNAT --to-source $NAT_Host

（2）执行脚本chmod a+x portmap.sh
sudo ./portmap.sh
（3）新建xshell连接名称填入10.0.0.208，主机填入172.16.101.105，端口号填入20822。
用户身份验证，方法选择Public Key，浏览，导入实例对应的id_rsa私钥。
（4）配置完成，连接即可。
实例访问外网在实例中ping百度，是不通的，下面我们进行配置，使实例能够访问外网。参考Linux配置SNAT上网。
控制节点在控制节点切换到root进行操作。
1、接收数据包iptables -P INPUT ACCEPT
2、开启路由功能echo 1 &gt; /proc/sys/net/ipv4/ip_forward
3、伪装数据包iptables -t nat -A POSTROUTING -j MASQUERADE
实例1、在实例中测试访问ping 120.77.36.182，是可以ping通的。ping www.baidu.com，ping不通。
2、在实例中配置resolv.confsudo vim /etc/resolv.conf，添加nameserver的配置
nameserver 180.76.76.76nameserver 223.6.6.6

sudo vim /etc/resolvconf/resolv.conf.d/base，添加：
nameserver 180.76.76.76nameserver 223.6.6.6

注意：执行sudo的时候，反应非常慢，请耐心等待，大概半分钟才能打开文件。要解决这个问题，需要修改hosts文件，加入主机名的解析：
127.0.0.1  k8s01

3、测试ping www.baidu.com
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——实例访问外网</title>
    <url>/dev-ubuntu16-manual-openstack-internet/</url>
    <content><![CDATA[问题《Ubuntu16手动安装OpenStack——vxlan网络》一文中，已经配置好了vxlan网络，并且成功创建了cirros1实例。
但是，进入实例后，发现一个问题：实例无法连通外网。这个问题我们在《Ubuntu16手动安装OpenStack——horizon篇》一文中就遇到过，也找到了解决办法。如今更换了网络模式，我们再来研究一下实例访问外网的问题。


解决办法traceroute1、登录cirros1ssh cirros@10.0.0.201
2、路由跟踪traceroute 8.8.8.8从上图可以看出，从虚拟机发出的包，依次经过了192.168.100.1和10.0.0.1，然后就出不去了。这说明，问题出在网桥（10.0.0.1）和外网的连接。
snat参照《Linux配置SNAT上网》和《Ubuntu16手动安装OpenStack——horizon篇》，对控制节点网络进行设置。
1、接受虚拟机数据包iptables -I INPUT -i eth2 -j ACCEPT
2、开启路由功能echo 1 &gt; /proc/sys/net/ipv4/ip_forward
3、伪装数据包iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth1 -j SNAT --to 172.16.0.105
测试1、登录cirros1ssh cirros@10.0.0.201
2、测试访问ping 8.8.8.8 -c3
3、修改resolv.confsudo vi /etc/resolv.conf添加：
nameserver 180.76.76.76

4、测试访问ping www.baidu.com -c3
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——修改镜像</title>
    <url>/dev-ubuntu16-manual-openstack-modify-mirror/</url>
    <content><![CDATA[问题描述《Ubuntu16手动安装OpenStack——horizon篇》一文中，已经安装了horizon，并且在dashboard中使用官方镜像创建了ubuntu16实例。看上去，很成功。
但是，再次使用官方镜像创建实例，这次居然无法通过ssh密钥访问！！！Permission denied (publickey). 神奇了。。。
重建实例，依然无法通过密钥访问。本文，就来研究一下解决办法。


尝试解决1、查看启动日志，发现：
ci-info: no authorized ssh keys fingerprints found for user ubuntu.
看这个提示，应该是密钥没有注入到实例中。
2、再往上看，发现：
DataSourceEc2.py[CRITICAL]: Giving up on md from ['http://169.254.169.254/2009-04-04/meta-data/instance-id'] after 120 secondsurl_helper.py[WARNING]: Calling 'http://10.0.0.200/latest/meta-data/instance-id' failed [0/120s]: bad status code [404]......DataSourceCloudStack.py[CRITICAL]: Giving up on waiting for the metadata from ['http://10.0.0.200/latest/meta-data/instance-id'] after 120 seconds

完整日志查看：start.log
3、参考OpenStack METADATA不工作的分析方法，重启metadata服务：systemctl restart neutron-metadata-agent.service
然后重新创建实例，没有用。
4、查看metadata日志tail /var/log/neutron/neutron-metadata-agent.log
2018-07-10 11:40:45.079 22459 INFO eventlet.wsgi.server [-] 10.0.0.1,&lt;local&gt; "GET /latest/meta-data/instance-id HTTP/1.1" status: 404  len: 297 time: 0.0431259

使用日志关键词搜索，并没有找到相关解决办法。
5、参考Openstack 通过 Metadata 服务请求流程 和 在OpenStack里如何确保虚机正常访问MetaData IP 169.254.169.254，也没有解决问题。
6、重建实例，配置脚本设置ssh允许密码登录。但是，无论是密钥还是密码，都无法登录，和《OpenStack添加镜像》一文中遇到的问题简直一模一样。
修改镜像配置失败，决定从镜像入手，修改镜像，使之支持ssh密码登录。主要参考openstack中镜像的密码修改和使用 guestfish 工具修改OpenStack官方Ubuntu 镜像
以下操作在控制节点切换到root执行。
1、下载镜像wget http://cloud-images.ubuntu.com/xenial/current/xenial-server-cloudimg-amd64-disk1.img
2、安装guestfish工具apt-get install libguestfs-tools -y
3、打开镜像guestfish --rw -a xenial-server-cloudimg-amd64-disk1.img
4、执行修改
&gt;&lt;fs&gt; run&gt;&lt;fs&gt; list-filesystems&gt;&lt;fs&gt; mount /dev/sda1 /&gt;&lt;fs&gt; vi /etc/cloud/cloud.cfg&gt;&lt;fs&gt; quit

在编辑cloud.cfg的时候，做如下修改：
# line 12, change and adddisable_root: falsessh_pwauth: true# line 93, change and addlock_passwd: falseplain_text_passwd: "ubuntu"

以上，允许了root登录，增加了ssh密码登录，设置ubuntu用户的默认密码为ubuntu。
5、使admin环境生效. admin-openrc
6、添加镜像
openstack image create "ubuntu16-server-modified" \  --file xenial-server-cloudimg-amd64-disk1.img \  --disk-format qcow2 --container-format bare \  --public

7、之后，创建实例ubuntu1，就可以在vnc使用密码登录了。可以使用sudo -i切换到root，等待时间很长，大概半分钟才能切换成功。
但是此时，依然不能使用ssh登录，无论是使用密钥，还是不使用密钥，都会提示：Permission denied (publickey).。
打算在vnc给实例添加公钥，然后把私钥scp给控制节点，但是，无法向authorized_keys写入公钥。神奇了！
而且，在vnc也无法ssh登录本机！同样提示Permission denied (publickey).
8、解决办法
sudo -iapt remove openssh-serverrm /etc/ssh/*apt install openssh-server

继续修改镜像定位问题以上，已经实现了实例通过ssh密码登录，但是这个过程比较麻烦。理论上，继续修改镜像，应该就能够实现这个目标。
1、创建一个实例ubuntu2，然后对比ubuntu1和ubuntu2中的/etc/ssh/sshd_config。发现它们最大的不同在于PasswordAuthentication。
ubuntu1中：
# Change to no to disable tunnelled clear text passwords#PasswordAuthentication yes

ubuntu2中：
# Change to no to disable tunnelled clear text passwordsPasswordAuthentication no

啊哈，这就是无法使用ssh登录的罪魁祸首了。
2、在ubuntu2中，修改PasswordAuthentication：
# Change to no to disable tunnelled clear text passwords#PasswordAuthentication no

3、重启sshdservice sshd restart
然后，就可以使用ssh密码登录了。
修改镜像那么，该怎么在镜像中修改PasswordAuthentication呢？很简单。
1、打开镜像guestfish --rw -a xenial-server-cloudimg-amd64-disk1.img
2、修改sshd_config
&gt;&lt;fs&gt; run&gt;&lt;fs&gt; list-filesystems&gt;&lt;fs&gt; mount /dev/sda1 /&gt;&lt;fs&gt; vi /etc/ssh/sshd_config&gt;&lt;fs&gt; quit

在编辑sshd_config的时候，做如下修改：
# Change to no to disable tunnelled clear text passwords#PasswordAuthentication no

3、（可选）为了方便联网，不妨编辑resolv.conf.d/base
&gt;&lt;fs&gt; vi /etc/resolvconf/resolv.conf.d/base

在base中添加：
nameserver 180.76.76.76nameserver 223.6.6.6

4、使admin环境生效. admin-openrc
5、删除镜像，重新添加
openstack image delete "ubuntu16-server-modified"openstack image create "ubuntu16-server-modified" \  --file xenial-server-cloudimg-amd64-disk1.img \  --disk-format qcow2 --container-format bare \  --public

至此，大功告成。
后记在创建实例时无法注入公钥和脚本的问题，最终没有解决，好在找到了其他解决方案。至于这个注入问题，会在后续的学习中继续尝试解决。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>把UEditor整合进ThinkPHP</title>
    <url>/dev-ueditor-in-thinkphp/</url>
    <content><![CDATA[前言
UEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码…



巾帼志愿者项目，需要发布一些带图片的文章，使用UEditor很合适。同时，UEditor还可以当做图片上传插件使用。下面，我们把UEditor整合进ThinkPHP框架中。
准备1、登录UEditor官网，下载PHP版本（UTF-8版）的代码。2、解压文件，重命名文件夹utf8-php为ueditor。3、拷贝ueditor到项目中的Public/libs文件夹下。4、修改ueditor/php/config.json里的路径。
编辑器新建表在数据库中新建表volun_culture，content字段的类型选择longtext。
Controller在Application/Admin/Controller/TestController.class.php中，添加函数ueditor、cultureAdd和ueditorshow。
public function ueditor()&#123;    $this-&gt;display();&#125;public function cultureAdd($title, $content)&#123;    $data['title'] = $title;    $data['content'] = $content;    $culture = D('culture');    if($culture-&gt;create($data))&#123;        $id = $culture-&gt;add();        if($id)&#123;            $data = array(                'code'=&gt;'0',                'id'=&gt;$id            );            echo json_encode($data);        &#125;    &#125;&#125;public function ueditorshow()&#123;    $culture = D('culture');    $cultureArr = $culture-&gt;select();    $this-&gt;assign('cultureArr',$cultureArr);    $this-&gt;display();&#125;


页面在Application/Admin/View/Test文件夹中，新建文件ueditor.html和ueditorshow.html。
&lt;!--ueditor.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;UEditor&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!-- 加载编辑器的容器 --&gt;    &lt;script id="container" name="content" type="text/plain"&gt;        这里写你的初始化内容    &lt;/script&gt;    &lt;button id="getContent"&gt;获取内容&lt;/button&gt;    &lt;button id="saveContent"&gt;保存&lt;/button&gt;    &lt;script src="/volunteer/Public/libs/jquery/jquery.min.js"&gt;&lt;/script&gt;    &lt;!-- 配置文件 --&gt;    &lt;script type="text/javascript" src="/volunteer/Public/libs/ueditor/ueditor.config.js"&gt;&lt;/script&gt;    &lt;!-- 编辑器源码文件 --&gt;    &lt;script type="text/javascript" src="/volunteer/Public/libs/ueditor/ueditor.all.js"&gt;&lt;/script&gt;    &lt;!-- 实例化编辑器 --&gt;    &lt;script type="text/javascript"&gt;        $(function()&#123;            var ue = UE.getEditor('container');            $('#getContent').click(function()&#123;                var html = ue.getContent();                alert(html);            &#125;);            $('#saveContent').click(function()&#123;                var html = ue.getContent();                var param = &#123;                    title: '测试',                    content: html                &#125;;                $.ajax(&#123;                    url: '/volunteer/index.php/Admin/Test/cultureAdd',                    type: 'POST',                    dataType: 'json',                    data: param,                    success: function(data)&#123;                        console.log(data);                    &#125;,                    error: function(xhr)&#123;                        console.log(xhr);                    &#125;                &#125;);                            &#125;);        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;
显示效果如下：点击“获取内容”：我们可以看到，上传的图片路径为/volunteer/Public/libs/ueditor/php/upload/image/*，这个路径是我们在准备工作的第四步中配置的。查看一下该路径，果然可以找到上传的图片。点击“保存”：
&lt;!--ueditorshow.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;文章展示&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;volist name="cultureArr" id="item"&gt;        &lt;div class="article"&gt;            &lt;h2&gt;&#123;$item.title&#125;&lt;/h2&gt;            &#123;$item.content&#125;        &lt;/div&gt;        &lt;hr/&gt;    &lt;/volist&gt;&lt;/body&gt;&lt;/html&gt;

显示效果如下：
图片上传插件Controller在Application/Admin/Controller/TestController.class.php中，添加函数imgupload。
public function imgupload()&#123;    $this-&gt;display();&#125;

页面在Application/Admin/View/Test文件夹中，新建文件imgupload.html。
&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;图片上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;tr&gt;        &lt;th&gt;上传图片&lt;/th&gt;        &lt;td&gt;            &lt;input type="text" id="path" /&gt;            &lt;input type="button" id="addPic" value="上传图片"/&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;div id="myeditor" style="display: none;"&gt;&lt;/div&gt;&lt;js file="__ROOT__/Public/libs/ueditor/ueditor.config.js"/&gt;&lt;js file="__ROOT__/Public/libs/ueditor/ueditor.all.js"/&gt;&lt;js file="__ROOT__/Public/libs/jquery/jquery.min.js"/&gt;&lt;script&gt;    $(function()&#123;        var editor = UE.getEditor('myeditor');        editor.ready(function () &#123;            //editor.setDisabled();            editor.hide();            editor.addListener('beforeInsertImage', function (t, arg) &#123;                $("#path").val(arg[0].src);                //$("#preview").attr("src", arg[0].src);                console.log(arg);            &#125;);        &#125;);        $('#addPic').click(function()&#123;            var myImage = editor.getDialog("insertimage");            myImage.open();        &#125;);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

UEditor优化上传图片弹框延迟问题描述：在最新版Chrome浏览器中，点击上传图片时，等待非常久，大概10秒左右，才弹出选择图片的对话框。
解决方案：打开ueditor.all.js，找到：
accept="image/*"
修改为：
accept="image/jpg,image/jpeg,image/png,image/gif"

点击选择图片弹框延迟问题描述：和上传图片弹框延迟基本相同，但是，点击的按钮有所差别。
解决方案：打开dialogs/images/images.js，找到：
accept: &#123;    title: 'Images',    extensions: acceptExtensions,    mimeTypes: 'image/*'&#125;
修改为：
accept: &#123;    title: 'Images',    extensions: acceptExtensions,    mimeTypes: 'image/jpg,image/jpeg,image/png,image/gif'&#125;

后记为什么我会知道修改哪个js文件？两个原因：
第一，查找资料，资料指明了修改ueditor.all.js（ueditor.all.min.js）和webuploader.js（webuploader.min.js）。
第二，按照资料给的方法，并没有解决我的问题。仔细研读资料，关键在于accept参数的修改。问题没有解决，极大的可能是accept参数没有修改正确。检查后，确信accept参数已经修改正确。清掉缓存，确保修改后的代码生效。然而，问题依然没有解决。那么，只剩下一种可能，版本问题，accept参数也许移动到其他js中了。
右键“单击选择图片”按钮，检查，选择Event Listener，便可以定位到相关的js。
书签UEditor - 首页http://ueditor.baidu.com/website/
UEditor Docshttp://fex-team.github.io/ueditor/#start-config
Web Uploaderhttp://fex.baidu.com/webuploader/
WebUploader UEditor chrome 点击上传文件选择框会延迟几秒才会显示 反应很慢http://www.cnblogs.com/liangjiang/p/5799984.html
FAQ · fex-team/ueditor Wiki · GitHubhttps://github.com/fex-team/ueditor/wiki/FAQ
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd下错误之:500 OOPS</title>
    <url>/dev-vftpd-error-500-oops/</url>
    <content><![CDATA[前言vsftpd下错误之：500 OOPS。vsftpd是在Linux发行版中最推崇的一种FTP服务器程序，vsftpd的特点：小巧轻快、安全易用等。 这里主要讲的是如何解决vsftpd下错误之：500 OOPS　
详细问题：我在用ftp IP 地址登录FTP服务器时，系统提示我输入用户名和密码，可是仍然提示：500 OOPS: child died.Connection closed by remote host.
解决办法：1、 查看 SELinux 的状态： sestatus -b | grep ftp2、 在出现的结果中可以看到ftp_home_dir offtftpd_disable_trans off之类。我们现在只要把其中之一设置为on就可以了。3、 setsebool -P ftpd_disable_trans on 或者 setsebool -P ftp_home_dir on4、 重启vsftpd： service vsftpd restart
再次登录登录成功了。试着上传一些文件来进行测试，看看是否有日志记录默认的日志在/var/log/目录下面。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox中Ubuntu扩容</title>
    <url>/dev-virtualbox-ubuntu-extend-storage/</url>
    <content><![CDATA[前言VirtualBox中，安装了Ubuntu16，磁盘40G。现在，因为某些原因，要对磁盘进行扩容。有两个思路，一个是添加磁盘，另一个是对原磁盘进行扩容。
本文就来研究一下这两种思路的具体做法。


添加磁盘VirtualBox配置1、Settings，Storage，Controller: SATA，Adds hard disk。
2、Create new disk，VDI，Dynamically allocated，命名为sdb，大小选择512GB，Create。
分区挂载参考《Linux的一些技巧》的硬盘挂载部分。
1、查看磁盘
df -hfdisk -l

2、硬盘分区fdisk /dev/sdb
按照提示，依次输入p，n，回车（Partition number），回车（First sector），回车（Last sector），w。
3、格式化mkfs -t ext4 /dev/sdb1或者：mkfs.ext4 /dev/sdb1
4、挂载
mkdir /sdbmount /dev/sdb1 /sdbdf -h

5、自动挂载vi /etc/fstab添加：
/dev/sdb1 /sdb ext4 defaults 0 0

扩展卷组在硬盘分区、格式化之后，不要进行挂载。参考VirtualBox下Linux虚机扩容，进行如下操作：
1、创建物理卷pvcreate /dev/sdb1
2、查看物理卷pvdisplay
3、查看卷组vgdisplay可以看到一个卷组ubuntu-vg。
4、扩展卷组vgextend ubuntu-vg /dev/sdb1
5、查看逻辑卷lvdisplay可以看到root卷的LV Path为/dev/ubuntu-vg/root。
6、扩展逻辑卷
lvextend -L +512G -n /dev/ubuntu-vg/rootlvdisplay

7、调整root逻辑卷大小
resize2fs /dev/ubuntu-vg/rootdf -h

原磁盘扩容VirtualBox配置1、切换到root用户sudo -i
2、查看磁盘列表vboxmanage list hdds
3、找到需要扩容的磁盘，记下UUID
4、扩容到512Gvboxmanage modifyhd --resize 512000 ba3e897a-742e-45dc-a99a-3302c07be984
分区挂载1、查看磁盘
df -hfdisk -l

2、增加分区fdisk /dev/sda输入n，报错：No free sectors available.没有找到好的解决办法，只能搁置。
扩展卷组无法分区，同样无法扩展卷组。
后记以上两种方案，殊途同归。增加容量后，都要经过分区，格式化，然后分区挂载或者扩展卷组。鉴于第二种方案中分区会出错，所以使用第一个方案更好些。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox中安装OpenStack</title>
    <url>/dev-virtualbox-ubuntu-openstack/</url>
    <content><![CDATA[前言OpenStack的安装是一个难点，非常难。哪怕已经安装过OpenStack，再次安装，也不敢说一定成功。安装过程中某处细微变化，也许就会出现各种奇葩错误。
总的来说，OpenStack大致分为4种安装方式：1、基于虚拟机的快速体验安装。这是最简单的方法，把搭建好环境的虚拟机运行起来即可。但是，遗憾的是，在网上没有找到OpenStack的虚拟机镜像。
2、基于DevStack快速脚本安装。这是OpenStack官方推荐的方式，安装速度较快，基于Folsom版本。但是，安装过程中一言不合就报错，困难重重。
3、使用自动化安装工具。RDO、Fuel、Puppet、Chef、Salt等，都是OpenStack的自动化安装工具。说是自动化安装工具，实际上安装配置时，也是非常繁琐。
4、手动安装。这种方式最困难，但是实际生产环境下，基本都需要手动安装。
本文，就探讨一下在VirtualBox中使用DevStack安装OpenStack的步骤。也就是说，我们要自己创建一个OpenStack的虚拟机镜像。


系统准备1、VirtualBox中安装好Ubuntu16，至少需要内存4G，硬盘20G。
2、配置好Ubuntu16的网络地址为192.169.56.102。
3、安装好ssh服务，方便远程操作。
步骤2和3可以参考《VirtualBox下CentOS7和Ubuntu16.04网络配置》。
环境准备1、安装gitapt-get install git
2、安装pythonapt-get install python
3、添加stack用户useradd -s /bin/bash -d /opt/stack -m stack
4、给stack用户添加sudo权限echo &quot;stack ALL=(ALL) NOPASSWD: ALL&quot; | sudo tee /etc/sudoers.d/stack
5、切换到stack用户su - stack
6、下载devstackgit clone https://git.openstack.org/openstack-dev/devstack或者git clone https://github.com/openstack-dev/devstack
推荐从github下载。速度缓慢，请耐心等待。
7、切换到stable/newton分支cd devstack
git checkout stable/newton
配置devstack创建local.conf在devstack目录下创建local.conf文件，内容如下：
[[local|localrc]]ADMIN_PASSWORD=voidkingDATABASE_PASSWORD=$ADMIN_PASSWORDRABBIT_PASSWORD=$ADMIN_PASSWORDSERVICE_PASSWORD=$ADMIN_PASSWORD# BranchesKEYSTONE_BRANCH=stable/newtonNOVA_BRANCH=stable/newtonNEUTRON_BRANCH=stable/newtonSWIFT_BRANCH=stable/newtonGLANCE_BRANCH=stable/newtonCINDER_BRANCH=stable/newton# Use mirrorGIT_BASE=http://git.trystack.cnNOVNC_REPO=http://git.trystack.cn/kanaka/noVNC.gitSPICE_REPO=http://git.trystack.cn/git/spice/spice-html5.git# Enable heat servicesenable_service h-eng h-api h-api-cfn h-api-cw# Enable heat pluginenable_plugin heat http://git.trystack.cn/openstack/heat.git stable/newtonIMAGE_URL_SITE="http://download.fedoraproject.org"IMAGE_URL_PATH="/pub/fedora/linux/releases/25/CloudImages/x86_64/images/"IMAGE_URL_FILE="Fedora-Cloud-Base-25-1.3.x86_64.qcow2"IMAGE_URLS+=","$IMAGE_URL_SITE$IMAGE_URL_PATH$IMAGE_URL_FILE# Service/Dashboard IPFLOATING_RANGE=192.168.1.224/27HOST_IP=192.168.56.102FLAT_INTERFACE=enp0s3

local.conf说明1、密码配置
ADMIN_PASSWORD=voidkingDATABASE_PASSWORD=$ADMIN_PASSWORDRABBIT_PASSWORD=$ADMIN_PASSWORDSERVICE_PASSWORD=$ADMIN_PASSWORD

2、git仓库devstack默认会从 https://git.openstack.org 上下载openstack组件，那是相当的慢。故在local.conf必须要把仓库替换成其他源，国内推荐git.trystack.cn。注意，trystack用的是http，不是https。
GIT_BASE=http://git.trystack.cn
或者
GIT_BASE=https://github.com

3、branch保证与devstack的branch一致，避免不可预知的问题。
NOVA_BRANCH=stable/newton

4、Service/Dashboard IP与虚拟机IP保持一致。
HOST_IP=192.168.56.102

更换pypi源（可选）devstack默认python源为 https://pypi.python.org ，国内访问非常慢。可以从 https://www.pypi-mirrors.org/ 选一个国内的镜像，把镜像地址写到pip.conf文件，并放到/root/.pip/pip.conf以及/home/stack/.pip/pip.conf。
[global]index-url = https://pypi.doubanio.com/simple

安装devstack1、切换stack用户，在devstack目录下。./stack.sh
安装过程中，会三次提示输入密码，这些密码需要和local.conf中保持一致。
如果下载报错了。。。，请重新执行：./stack.sh
这一步非常久，郝同学用了六个多小时，请耐心等待。
3、安装成功，提示：
=========================Total runtime         2982run_process           104test_with_retry         6apt-get-update         22pip_install           462restart_apache_server  15wait_for_service       26apt-get                12=========================This is your host IP address: 192.168.56.102This is your host IPv6 address: ::1Horizon is now available at http://192.168.56.102/dashboardKeystone is serving at http://192.168.56.102/identity/The default users are: admin and demoThe password: voidking2017-06-15 01:01:59.770 | WARNING: 2017-06-15 01:01:59.771 | Using lib/neutron-legacy is deprecated, and it will be removed in the future2017-06-15 01:01:59.771 | stack.sh completed in 2982 seconds.


4、大功告成，这时就可以通过浏览器访问openstack服务了！访问地址：http://192.168.56.102/dashboard

PS：如果这一步无法访问，提示“Internal Server Error”，那么需要手动把ip地址加到local_settings.py里的ALLOWED_HOSTS字段。vim /opt/stack/horizon/openstack_dashboard/local/local_settings.py
# If horizon is running in production (DEBUG is False), set this# with the list of host/domain names that the application can serve.# For more information see:# https://docs.djangoproject.com/en/dev/ref/settings/#allowed-hostsALLOWED_HOSTS = ['*']

然后重启apache2服务，service apache2 restart
5、输入用户名admin，密码voidking，进入管理面板。
书签VirtualBox + DevStack
DevStack
10分钟安装OpenStack
Fuel 30 分钟快速安装OpenStack
个人电脑上搭建OpenStack的实验室
All-In-One Single Machine
Huawei Icehouse All in One Operation Guide
penStack项目系列介绍（3） Devstack
DevStack环境搭建
Ubuntu14.04下载地址1
Ubuntu14.04下载地址2
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>ssh</tag>
        <tag>openstack</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox Ubuntu共享文件夹</title>
    <url>/dev-virtualbox-ubuntu-share/</url>
    <content><![CDATA[设置步骤1、设置，共享文件夹，添加，选择共享文件夹路径（假设为E:\VirtualBoxShare，对应共享文件夹名称为VirtualBoxShare），注意此时不要勾选自动挂载。2、启动Ubuntu，打开Terminal。3、cd /mnt/4、sudo mkdir shared5、sudo mount -t vboxsf VirtualBoxShare /mnt/shared/6、cd shared，ll


卸载如果想卸载，可运行命令：sudo umount -f /mnt/shared
参考文档virtualbox+ubuntu设置共享文件夹
virtualbox中ubuntu和windows共享文件夹设置
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始打造自己的PHP框架——第0章</title>
    <url>/dev-vkphp-0/</url>
    <content><![CDATA[前言使用过thinkphp和yii，涉猎过shopnc。市场上已经有了这么多好的框架，为什么还要开发自己的框架？答：假装大神。为了在装神的道路上走的更远，郝同学决定开发一个自己的php框架，命名为vkphp。


框架运行流程1、入口文件
2、定义常量
3、引入函数库
4、自动加载类
5、启动框架
6、路由解析
7、加载控制器
8、返回结果
helloworld集成环境集成开发环境使用laragon，在www目录下新建vkphp项目目录。
项目结构vkphp│  index.php│  README.md│├─app└─core    │  vk.php    │    └─common            function.php

index.php&lt;?php/*入口文件1、定义常量2、加载函数库3、启动框架*/define('VKPHP',realpath('./')); //获取项目所在根目录define('CORE',VKPHP.'/core'); //核心文件所在目录define('APP',VKPHP.'/app'); //应用文件所在目录define('DEBUG',true); //是否开启调试if(DEBUG)&#123;    ini_set('display_errors', 'On');&#125;else&#123;    ini_set('display_errors', 'Off');&#125;include CORE.'/common/function.php';//p(VKPHP);include CORE.'/vk.php';\core\vk::run();

function.php&lt;?phpfunction p($var)&#123;    if(is_null($var))&#123;        var_dump(NULL);    &#125;else if(is_bool($var))&#123;        var_dump($var);    &#125;else&#123;        echo '&lt;p&gt;'. print_r($var, true) .'&lt;/p&gt;';    &#125;&#125;

vk.php&lt;?phpnamespace core;class vk&#123;    public function run()&#123;        p('helloworld');    &#125;&#125;

测试访问启动laragon，在浏览器中访问 http://vkphp.dev 或者 http://vkphp.dev/index.php ，即可看到“helloworld”。
源码分享https://github.com/voidking/vkphp/releases/tag/v1.0.0
书签从零开始打造自己的PHP框架
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始打造自己的PHP框架――第2章</title>
    <url>/dev-vkphp-2/</url>
    <content><![CDATA[目标本篇，我们来实现加载控制器、数据查询和页面渲染。


加载控制器控制器在app目录下，新建ctrl目录，ctrl目录下新建indexCtrl.php文件，内容如下：
&lt;?phpnamespace app\ctrl;class indexCtrl&#123;    public function index()&#123;        echo 'index ctrl';    &#125;&#125;

调用控制器在根目录下的index.php文件中，继续添加：
include CORE.'/autoload.php';spl_autoload_register('\core\autoload::load');$route = new \core\route();$ctrl = $route-&gt;ctrl;$action = $route-&gt;action;$params = $route-&gt;params;$ctrl_file = APP.'/ctrl/'.$ctrl.'Ctrl.php';$ctrl_class = '\\app\\ctrl\\'.$ctrl.'Ctrl';if(is_file($ctrl_file))&#123;    include $ctrl_file;    $ctrl_obj = new $ctrl_class;    $ctrl_obj-&gt;$action();&#125;else &#123;    throw new \Exception('找不到控制器'.$ctrl_file);&#125;

访问地址 http://vkphp.dev ，即可看到“index ctrl”。
数据查询1、在mysql中，新建数据库vkphp。
2、在vkphp数据库中，新建表vk_user，字段包括id、username和password。
3、在common文件夹下，新建db.php，内容如下：
&lt;?phpnamespace core\common;class db extends \PDO&#123;    public function __construct()&#123;        $dsn = 'mysql:host=localhost;dbname=vkphp';        $username = 'root';        $passwd = '';        try&#123;            parent::__construct($dsn,$username,$passwd);            // echo 'database connect success';        &#125;catch (\Exception $e)&#123;            echo $e-&gt;getMessage();        &#125;    &#125;&#125;

4、在indexCtrl.php中，添加：
public function data()&#123;    $db = new \core\common\db();    $sql = 'select * from vk_user';    $result = $db-&gt;query($sql);    p($result);    p($result-&gt;fetchAll());&#125;

访问地址 http://vkphp.dev/index/data ，即可看到从数据库中查询出的数据。
页面渲染页面渲染，主要有两部分工作：赋值和显示。我们需要实现两个函数：assign和display。
1、在app目录下新建view目录，view目录下新建index目录，index目录中新建render.html，内容如下：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Render&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;第一个视图&lt;/p&gt;    &lt;p&gt;用户名：&lt;?php echo $username; ?&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

2、在core目录中，添加render.php，内容如下：
&lt;?phpnamespace core;class render&#123;    public $params = array();    public function assign($name,$value)&#123;        $this-&gt;params[$name] = $value;    &#125;    public function display($file)&#123;        $file = APP.'/view/'.$file;        if(is_file($file))&#123;            extract($this-&gt;params); //把数组变成变量            include $file;        &#125;    &#125;&#125;

3、修改indexCtrl.php如下：
&lt;?phpnamespace app\ctrl;class indexCtrl extends \core\render&#123;    // 其他    public function render()&#123;        $this-&gt;assign('username','voidking');        $this-&gt;display('index/render.html');    &#125;&#125;

访问地址 http://vkphp.dev/index/render ，即可看到渲染出的页面。
页面渲染进阶直接在页面echo，难以体现水平，我们来安装一个模板引擎――smarty。
命名空间接下来smarty的使用，牵涉到命名空间这个知识点，在此学习一下。
首先声明：命名空间和文件路径没有关系，没有关系，没有关系！虽然，在使用命名空间时经常参考文件路径，但是，它们没有必然关系。
命名空间的作用：解决重名问题。不同的命名空间中，可以存在相同类名和函数名。我们在使用一个类和函数时，必须明确指出使用的是哪一个命名空间中的类和函数。
上文我们说到，在文件系统中访问一个文件有三种方式，PHP命名空间中的元素使用同样的原理。例如，类名可以通过三种方式引用：
1、非限定名称，或不包含前缀的类名称，例如 $a=new foo(); 或 foo::staticmethod(); 。如果当前命名空间是 currentnamespace，foo 将被解析为 \currentnamespace\foo ；如果当前没有指定命名空间，则foo会被解析为 \foo。2、限定名称，或包含前缀的名称，例如 $a = new subnamespace\foo(); 或 subnamespace\foo::staticmethod(); 。如果当前的命名空间是 currentnamespace，则 foo 会被解析为 \currentnamespace\subnamespace\foo ；如果当前没有指定命名空间，foo 会被解析为\subnamespace\foo。3、完全限定名称，或包含了全局前缀操作符的名称，例如，$a = new \currentnamespace\foo(); 或 \currentnamespace\foo::staticmethod();。在这种情况下，foo 总是被解析为代码中的文字名(literal name) \currentnamespace\foo。
下面举个栗子：
&lt;?phpnamespace A\B\C;class Exception extends \Exception &#123;&#125;$a = new Exception('hi'); // $a 是类 A\B\C\Exception 的一个对象$b = new \Exception('hi'); // $b 是类 Exception 的一个对象$c = new ArrayObject; // 致命错误, 找不到 A\B\C\ArrayObject 类?&gt;

下载安装smarty1、访问smarty官方下载 ，下载smarty，郝同学下载的是3.1.30版本。
2、在根目录下新建lib，解压smarty到lib目录下，重命名文件夹为smarty。
使用smarty1、在app目录下新建smarty目录，smarty目录下新建templates、template_c、configs、cache四个目录。
2、在templates目录下新建index目录，index目录中新建render2.html，内容如下：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Smarty&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;第一个Smarty页面&lt;/p&gt;    &lt;p&gt;用户名：&#123;&#123;$username&#125;&#125;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

3、修改core目录下的render.php如下：
&lt;?phpnamespace core;class render&#123;       public $smarty;    public function __construct()&#123;        require_once(LIB.'/smarty/libs/Smarty.class.php');        $this-&gt;smarty = new \Smarty();        $this-&gt;smarty-&gt;setTemplateDir(APP.'/smarty/templates/');        $this-&gt;smarty-&gt;setCompileDir(APP.'/smarty/templates_c/');        $this-&gt;smarty-&gt;setConfigDir(APP.'/smarty/configs/');        $this-&gt;smarty-&gt;setCacheDir(APP.'/smarty/cache/');    &#125;    public $params = array();    public function assign($name,$value)&#123;        $this-&gt;params[$name] = $value;    &#125;    public function display($file)&#123;        $file = APP.'/view/'.$file;        if(is_file($file))&#123;            extract($this-&gt;params); //把数组变成变量            include $file;        &#125;    &#125;&#125;

4、修改indexCtrl.php如下：
&lt;?phpnamespace app\ctrl;include CORE.'/render.php';class indexCtrl extends \render&#123;    // 其他    public function render2()&#123;        $this-&gt;smarty-&gt;assign('username','voidking');        $this-&gt;smarty-&gt;display('index/render2.html');    &#125;&#125;

访问地址 http://vkphp.dev/index/render2 ，即可看到渲染出的页面。
源码分享https://github.com/voidking/vkphp/releases/tag/v1.2.0
书签从零开始打造自己的PHP框架
使用命名空间：基础
使用命名空间：后备全局函数/常量
smarty基础安装
smarty进阶安装
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始打造自己的PHP框架——第3章</title>
    <url>/dev-vkphp-3/</url>
    <content><![CDATA[目标本篇，我们的目标有三个：

调整项目结构
加载配置类
添加日志类



调整项目结构vkphp├─app│  ├─ctrl│  ├─model│  ├─smarty│  └─view├─config├─core├─lib├─log└─public


app内包含控制器、数据库model、smarty模板、普通渲染模板。
config内包含全局配置文件。
core内包含框架的核心文件。
lib内包含第三方库。
log内存放日志文件。
public包含静态资源文件。

加载配置类我们之前的路由配置、数据库配置都是写在程序中的，修改起来不方便，下面我们把这些配置都放在配置文件中。
conf.php在core目录中，新建conf.php，内容如下：
&lt;?phpnamespace core;class conf&#123;    public function get($name,$file)&#123;        /**         * 1、判断文件是否存在         * 2、判断配置是否存在         */        $file_path = CONFIG.'/'.$file.'.php';        if(is_file($file_path))&#123;            $conf = include $file_path;            if(isset($conf[$name]))&#123;                    return $conf[$name];            &#125;else&#123;                throw new \Exception('没有配置项'.$name);            &#125;        &#125;else&#123;            throw new \Exception('找不到配置文件'.$file);        &#125;    &#125;    public function all($file)&#123;        $file_path = CONFIG.'/'.$file.'.php';        if(is_file($file_path))&#123;            $conf = include $file_path;            return $conf;        &#125;else&#123;            throw new \Exception('找不到配置文件'.$file);        &#125;    &#125;&#125;

配置类在config目录中，新建配置文件route_config.php和db_config.php。
&lt;?phpreturn array(    'CTRL'=&gt;'index',    'ACTION'=&gt;'index');

&lt;?phpreturn array(    'DSN'=&gt;'mysql:host=localhost;dbname=vkphp',    'USER'=&gt;'root',    'PASSWD'=&gt;'');

使用修改core目录中的route.php和db.php。
&lt;?php/** * 路由控制 */namespace core;class route&#123;    public $ctrl='index';    public $action='index';    public $params=array();    public function __construct()&#123;        //echo 'route is ready!';        /**         * 1、隐藏index.php         * 2、获取URL中的控制器和方法         * 3、获取URL中的参数         */        $this-&gt;ctrl = \core\conf::get('CTRL','route_config');        $this-&gt;action = \core\conf::get('ACTION','route_config');        // 其他不变&#125;

&lt;?phpnamespace core;class db extends \PDO&#123;    public function __construct()&#123;        $conf = \core\conf::all('db_config');        $dsn = $conf['DSN'];        $user = $conf['USER'];        $passwd = $conf['PASSWD'];        try&#123;            parent::__construct($dsn,$user,$passwd);            // echo 'database connect success';        &#125;catch (\Exception $e)&#123;            echo $e-&gt;getMessage();        &#125;    &#125;&#125;

添加日志类log.php在core目录，添加log.php文件，内容如下：
&lt;?phpnamespace core;class log&#123;    public function log($message,$file_name)&#123;        $log_path = LOG.'/'.$file_name.'-'.date('YmdHis').'.log';        $message = date('Y-m-d H:i:s').' '.$message;        file_put_contents($log_path,json_encode($message));    &#125;&#125;

使用在indexCtrl.php中，添加：
public function log()&#123;    $log = new \core\log();    $log-&gt;log('this is log','log_test');    echo '成功写入日志';&#125;

访问 http://vkphp.dev/index/log ，即可在log目录下生成日志文件。如果时间不正确，就在php.ini中搜索 date.timezone ，然后修改时区为：
data.timezone="Asia/Shanghai"

或者，直接在程序代码中使用函数ini_set(&#39;date.timezone&#39;,&#39;Asia/Shanghai&#39;); ，或者date_default_timezone_set(‘Asia/Shanghai&#39;); 。
源码分享https://github.com/voidking/vkphp/releases/tag/v1.3.0
书签从零开始打造自己的PHP框架
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始打造自己的PHP框架——第4章</title>
    <url>/dev-vkphp-4/</url>
    <content><![CDATA[ComposerComposer 是 PHP5.3以上 的一个依赖管理工具。它允许你申明项目所依赖的代码库，它会在你的项目中为你安装他们。Composer 不是一个包管理器。是的，它涉及 “packages” 和 “libraries”，但它在每个项目的基础上进行管理，在你项目的某个目录中（例如 vendor）进行安装。默认情况下它不会在全局安装任何东西。因此，这仅仅是一个依赖管理。
本篇，我们就在自己的项目中使用composer来进行依赖管理。


安装Composer1、访问Composer下载地址，下载安装对应平台的composer，安装方法参照官方文档。
2、打开命令行，输入composer -V，测试是否安装成功。
使用Composer初次使用1、在项目根目录下新建composer.json，内容如下：
&#123;    "name": "VKPHP",    "description": "A PHP Framework for php developer",    "type": "Framework",    "keywords": [        "PHP","PHP Framework","VKPHP"    ],    "homepage": "http://www.voidking.com",    "time": "2017-09-14",    "license": "MIT",    "authors": [&#123;        "name": "VoidKing",        "email": "voidking@qq.com",        "homepage": "http://www.voidking.com",        "role": "Student"    &#125;],    "require": &#123;        "PHP": "&gt;=5.3.0",        "smarty/smarty": "~3.1"    &#125;&#125;

需要解释的，是require字段，要求PHP大于等于5.3，smarty大于等于3.1且小于等于4.0。
版本号选择参照下表：
2、安装依赖在根目录打开命令行，输入composer，如果composer.json文件有错误会出现提示，没有错误则提示可选参数和功能。输入composer install，即可安装依赖到vendor目录中，并且自动生成composer.lock和vendor/autoload.php。
更新依赖1、在composer.json中添加依赖，whoops任意版本，var-dumper任意版本。
"filp/whoops": "*","symfony/var-dumper": "*"


2、安装依赖composer install，提示
Loading composer repositories with package informationInstalling dependencies (including require-dev) from lock fileNothing to install or updateGenerating autoload files

从提示可以看出，composer install读取的是composer.lock中的依赖，而不是最新的composer.json。
所以，我们要使用命令composer update，这样就可以下载新写入的依赖，并且更新composer.lock。
更换Composer源如果在composer install或composer update时非常慢，那么我们可以更换Composer源。
访问Composer中国镜像站，参照文档，在composer.json所在目录中执行：composer config repo.packagist composer https://packagist.phpcomposer.com
或者，直接在composer.json中添加：
"repositories": &#123;    "packagist": &#123;        "type": "composer",        "url": "https://packagist.phpcomposer.com"    &#125;&#125;

使用依赖smarty1、当前，lib目录和vendor目录中都包含了smarty，使用verdor中的smarty会更有格调，遂弃用lib目录，改用vendor作为第三方库目录。
2、根目录下index.php修改为：
// define('LIB',VKPHP.'/lib'); //第三方库所在目录define('LIB',VKPHP.'/vendor'); //第三方库所在目录include LIB.'/autoload.php'; //自动加载第三方库

3、core目录下render.php修改为：
// require_once(LIB.'/smarty/libs/Smarty.class.php');
因为index.php中自动加载了所有第三方库，所以我们不再需要自己引入。
访问 http://vkphp.dev/index/render2 ，smarty正常工作。
whoops根目录index.php修改为：
if(DEBUG)&#123;    ini_set('display_errors', 'On');    $whoops = new \Whoops\Run;    $whoops-&gt;pushHandler(new \Whoops\Handler\PrettyPageHandler);    $whoops-&gt;register();&#125;else&#123;    ini_set('display_errors', 'Off');&#125;

访问 http://vkphp.dev/index/render3 ，即可看到炫酷的报错页面，没错，whoops就是一个错误显示插件。
var-dumper修改app/ctrl/indexCtrl.php中的data函数为：
public function data()&#123;    $db = new \core\db();    $sql = 'select * from vk_user';    $result = $db-&gt;query($sql);    dump($result);    dump($result-&gt;fetchAll());&#125;

访问 http://vkphp.dev/index/data ，即可看到炫酷的变量输出页面，没错，var-dumper是一个变量显示插件。
源码分享https://github.com/voidking/vkphp/releases/tag/v1.4.0
书签从零开始打造自己的PHP框架
Composer中文网
Composer中文文档
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>框架</tag>
        <tag>composer</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始打造自己的PHP框架——第5章</title>
    <url>/dev-vkphp-5/</url>
    <content><![CDATA[目标使用medoo插件来连接和操作数据库。


medoo基础安装medoo1、在composer中添加依赖：
"catfan/medoo": "*"

2、更新依赖composer update
使用medoo1、config目录添加medoo_config.php为：
&lt;?phpreturn array(    'database_type' =&gt; 'mysql',    'database_name' =&gt; 'vkphp',    'server' =&gt; 'localhost',    'username' =&gt; 'root',    'password' =&gt; '',    'charset' =&gt; 'utf8',    'port' =&gt; 3306,// 可选参数    'prefix' =&gt; 'vk_',// 可选，定义表的前缀);

2、core目录添加medoo.php为：
&lt;?phpnamespace core;class medoo extends \Medoo\Medoo&#123;    public function __construct()&#123;        $conf = \core\conf::all('medoo_config');        parent::__construct($conf);    &#125;&#125;

3、app/ctrl/indexCtrl.php中添加函数：
public function medoo()&#123;    $medoo = new \core\medoo();    dump($medoo);&#125;

访问 http://vkphp.dev/index/medoo ，即可看到medoo的相关信息。
增删查改查找$ret = $medoo-&gt;select('user','*',['username'=&gt;'voidking']);dump($ret);

插入$data = array(    'username'=&gt;'voidking1',    'password'=&gt;'voidking1');$ret = $medoo-&gt;insert('user',$data);dump($ret);
因为medoo的版本问题（1.4.5），此时并没有打印出这条记录的id，而是PDOStatement object。此时，要想获取记录id，有两个方案：
方案一：从medoo中获取
dump($medoo-&gt;id());

方案二：找到vender/catfan/medoo/src/Medoo.php的第1173行，修改为
$this-&gt;exec('INSERT INTO ' . $this-&gt;tableQuote($table) . ' (' . implode(', ', $fields) . ') VALUES ' . implode(', ', $stack), $map);return $this-&gt;pdo-&gt;lastInsertId();

删除$ret = $medoo-&gt;delete('user',['username'=&gt;'voidking2']);dump($ret-&gt;rowCount()); // 受影响的行数

修改$ret = $medoo-&gt;update('user',['username'=&gt;'voidking2'],['username'=&gt;'voidking1']);dump($ret-&gt;rowCount());

medoo进阶回顾yii框架，对于每个表，我们都要创建一个model类，继承ActiveRecord类。比如：
&lt;?phpnamespace app\models;use yii\db\ActiveRecord;// Project.phpclass Project extends ActiveRecord&#123;    public static function model($className=__CLASS__)    &#123;        return parent::model($className);    &#125;    public function getTenProject()&#123;        // 具体实现    &#125;&#125;

在使用的时候，新建一个model对象，调用其中的方法即可：
$project = new Project();

thinkphp框架，对于每个表，我们不用创建model类。在使用的时候，直接新建一个默认model对象，传入表名，调用其中的方法即可：
$project = M('project');

当然，thinkphp也可以自定义model类，继承Model类。比如：
&lt;?php// ProjectModel.class.phpclass ProjectModel extends Model&#123;    public function getTenProject()&#123;        // 具体实现    &#125;&#125;

使用D方法新建自定义model对象，找不到定义类的情况下会调用M方法：
$project = D('project');

yii和thinkphp的两种实现方案，异曲同工，同样都包含了默认model类和自定义model类。yii中，默认model类为ActiveRecord，如果要自定义model类，继承它即可。thinkphp中，默认model类为Model，如果要自定义model类，继承它即可。
model.php鉴于yii的实现方式，我们也来新建一个model基类，其他的model类都继承它。
1、core目录下，新建model.php，内容如下：
&lt;?phpnamespace core;class model extends \core\medoo&#123;    public $table_name = '';    public function __construct($table_name)&#123;        $name_arr = explode('\\',$table_name);        $this-&gt;table_name = strtolower(end($name_arr));        parent::__construct();        //dump($this-&gt;table_name);    &#125;    public function list_all()&#123;        $ret = $this-&gt;select($this-&gt;table_name,'*');        return $ret;    &#125;    public function find_by_id($id)&#123;        $ret = $this-&gt;select($this-&gt;table_name,'*',['id'=&gt;$id]);        return $ret;    &#125;    public function find_by_condition($condition)&#123;        $ret = $this-&gt;select($this-&gt;table_name,'*',$condition);        return $ret;    &#125;    public function add($data)&#123;        $ret = $this-&gt;insert($this-&gt;table_name,$data);        return $this-&gt;id();    &#125;    public function del($condition)&#123;        $ret = $this-&gt;delete($this-&gt;table_name,$condition);        return $ret-&gt;rowCount(); // 受影响的行数    &#125;    public function edit($data,$condition)&#123;        $ret = $this-&gt;update($this-&gt;table_name,$data,$condition);        return $ret-&gt;rowCount();    &#125;&#125;

2、在app/model目录中新建user.php，内容如下：
&lt;?phpnamespace app\model;class user extends \core\model&#123;    public function __construct()&#123;        parent::__construct(__CLASS__);    &#125;&#125;

3、在app/ctrl/indexCtrl.php中添加函数：
$user = new \app\model\user();dump($user-&gt;list_all());dump($user-&gt;find_by_id(1));dump($user-&gt;find_by_condition(['username'=&gt;'voidking']));dump($user-&gt;add(['username'=&gt;'voidking1','password'=&gt;'voidking1']));dump($user-&gt;edit(['username'=&gt;'voidking2'],['username'=&gt;'voidking1']));dump($user-&gt;del(['username'=&gt;'voidking2']));

访问 http://vkphp.dev/index/model ，可以看到操作结果：
操作完成后，也许会感觉数据库表比较乱。这时可以清空表，并且重新从1开始自增id。truncate vk_user;
小结至此，整个框架已经基本完成。接下来，我们会开发一个迷你项目，在开发的过程中，测试并改进我们的框架。
源码分享https://github.com/voidking/vkphp/releases/tag/v1.5.0
书签从零开始打造自己的PHP框架
Medoo官方文档
Medoo中文文档
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>框架</tag>
        <tag>medoo</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始打造自己的PHP框架——第6章</title>
    <url>/dev-vkphp-6/</url>
    <content><![CDATA[前言第0到5章，我们完成了一个属于自己的php框架，麻雀虽小五脏俱全。接下来，我们使用vkphp框架开发一个迷你项目——书签收藏。在开发过程中，也许会遇到很多问题，这时候我们就可以对框架进行调整，使之更加完善。
系统描述：用户登录系统，能够看到自己收藏的书签，并且可以对书签进行增删改查。
系统功能：1、注册登录。2、书签展示。3、增删查改。


项目结构vkphp├─app│  ├─ctrl│  │  └─bookmark│  ├─model│  └─smarty│     ├─templates│     │  └─bookmark│     └─templates_c ├─assets├─config├─core├─log└─vendor


app内包含控制器、model、smarty模板。
config内包含全局配置文件。
core内包含框架的核心文件。
log内存放日志文件。
assets包含静态资源文件。
vendor内包含第三方库。

我们编写业务代码的位置，主要在app、assets两个目录。
注册登录表结构修改vk_user表结构为：
DROP TABLE IF EXISTS `vk_user`;CREATE TABLE `vk_user` (  `id` int(10) NOT NULL AUTO_INCREMENT,  `username` varchar(20) NOT NULL,  `password` varchar(32) NOT NULL COMMENT 'md5加密',  `salt` varchar(16) NOT NULL,  `screen_name` varchar(20) DEFAULT '低调的用户',  `email` tinytext,  PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;

modelapp/model目录下，已经有了user.php这个model类。
&lt;?phpnamespace app\model;class user extends \core\model&#123;    public function __construct()&#123;        parent::__construct(__CLASS__);    &#125;&#125;

控制器app/ctrl/bookmark目录下，新建user_ctrl.php。
&lt;?phpnamespace app\ctrl\bookmark;class user_ctrl extends \core\render&#123;    public function index()&#123;        echo 'user ctrl';    &#125;    public function captcha()&#123;        $captcha = new \core\util\captcha();        $captcha-&gt;create(300,80,40);    &#125;    public function check()&#123;        if(!(isset($_REQUEST['code']) &amp;&amp; $_REQUEST['code'] !== ''))&#123;            $result = array(                'code'=&gt;'-4',                'ext'=&gt;'验证码不能为空'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);            return;        &#125;        $code = $_REQUEST['code'];        $captcha = new \core\util\captcha();        $ret = $captcha-&gt;check($code);        if($ret == 0)&#123;            $result = array(                'code'=&gt;'0',                'ext'=&gt;'验证成功'            );        &#125;else if($ret == -1)&#123;            $result = array(                'code'=&gt;'-1',                'ext'=&gt;'请先获取验证码'            );        &#125;else if($ret == -2)&#123;            $result = array(                'code'=&gt;'-2',                'ext'=&gt;'验证码超时'            );        &#125;else if($ret == -3)&#123;            $result = array(                'code'=&gt;'-3',                'ext'=&gt;'验证码错误'            );        &#125;        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;    public function reg()&#123;        if(!(isset($_POST['username'])             &amp;&amp; isset($_POST['password'])             &amp;&amp; isset($_POST['password2'])            &amp;&amp; $_POST['username'] !== ''            &amp;&amp; $_POST['password'] !== ''            &amp;&amp; $_POST['password2'] !== '')        )&#123;            $result = array(                'code'=&gt;'-1',                'ext'=&gt;'参数不能为空'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);            return;        &#125;        $username = $_POST['username'];        $password = $_POST['password'];        $password2 = $_POST['password2'];        if($password !== $password2)&#123;            $result = array(                'code'=&gt;'-2',                'ext'=&gt;'两次密码不同'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);            return;        &#125;        $salt = \core\util\random::get_random_string(16);        $password = md5($password.$salt);        $data = array(            'username'=&gt;$username,            'password'=&gt;$password,            'salt'=&gt;$salt        );        $user = new \app\model\user();        $ret = $user-&gt;find_by_condition(['username'=&gt;$username]);        if($ret)&#123;            $result = array(                'code'=&gt;'-2',                'ext'=&gt;'用户名已存在'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);            return;        &#125;        $user_id = $user-&gt;add($data);        if($ret &gt;= 1)&#123;            $result = array(                'code'=&gt;'0',                'user_id'=&gt;$user_id,                'ext'=&gt;'注册成功'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);        &#125;    &#125;    public function login()&#123;        if(!(isset($_POST['username'])             &amp;&amp; isset($_POST['password'])            &amp;&amp; $_POST['username'] !== ''            &amp;&amp; $_POST['password'] !== '')        )&#123;            $result = array(                'code'=&gt;'-1',                'ext'=&gt;'参数不能为空'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);            return;        &#125;        $username = $_POST['username'];        $password = $_POST['password'];        $user = new \app\model\user();        $ret = $user-&gt;find_by_condition(['username'=&gt;$username]);        if($ret)&#123;            $salt = $ret['salt'];            $req_password = md5($password.$salt);            $real_password = $ret['password'];            if($req_password == $real_password)&#123;                session_start();                $_SESSION['user_id'] = $ret['id'];                $result = array(                    'code'=&gt;'0',                    'ext'=&gt;'登录成功'                );                echo json_encode($result,JSON_UNESCAPED_UNICODE);            &#125;        &#125;else&#123;            $result = array(                'code'=&gt;'-2',                'ext'=&gt;'用户不存在'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);        &#125;    &#125;    public function logout()&#123;        session_start();        if(isset($_SESSION['user_id']))&#123;            unset($_SESSION['user_id']);            $result = array(                'code'=&gt;'0',                'ext'=&gt;'下线成功'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);        &#125;                &#125;    public function to_login()&#123;        $this-&gt;smarty-&gt;assign('basepath',$this-&gt;basepath);        $this-&gt;smarty-&gt;assign('assets',$this-&gt;assets);        $this-&gt;smarty-&gt;display('bookmark/user/login.html');    &#125;&#125;

前端如果需要详细代码，请到源码中查看，下面只描述思路。1、实现静态页面的最终效果，包括html、css和js。2、把静态页面改写为smarty页面。3、使用postman测试写好的注册登录接口。4、打通前后端。
访问地址： http://vkphp.dev/bookmark/user/to_login ，即可看到注册登录页面。
源码分享https://github.com/voidking/vkphp/releases/tag/v1.6.0
书签从零开始打造自己的PHP框架
session与PHP之session_start()
PHP session详解
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始打造自己的PHP框架——第7章</title>
    <url>/dev-vkphp-7/</url>
    <content><![CDATA[前言《thinkphp部署到nginx服务器》一文中，小生提到过，nginx默认情况下不支持pathinfo模式，从而不能支持ThinkPHP。能访问的，只有首页，其他函数的路径，都无法访问。
这是因为，PHP中的全局变量$_SERVER[&#39;PATH_INFO&#39;]，常常被用来优化url路径格式，比如thinkphp，而nginx是不支持pathinfo的。
同样的，小生开发的vkphp，虽然没有使用$_SERVER[&#39;PATH_INFO&#39;]，但是也使用到了$_SERVER，所以，也需要配置nginx支持pathinfo。


完整demo1、首先，查看nginx配置文件的位置，ps aux | grep nginx
2、进入conf/vhost目录，添加enroll.voidking.com.conf文件。
server &#123;    listen 80;    server_name enroll.voidking.com;    root /home/wwwroot/enroll;    index index.html index.htm index.php;    error_page 404 /404.html;    location = /404.html &#123;        return 404 'Sorry, File not Found!';    &#125;    error_page 500 502 503 504 /50x.html;    location = /50x.html &#123;        root /usr/local/nginx/html; # windows用户替换这个目录    &#125;    location / &#123;        try_files $uri @rewrite;    &#125;    location @rewrite &#123;        set $static 0;        if  ($uri ~ \.(css|js|jpg|jpeg|png|gif|ico|woff|eot|svg|css\.map|min\.map)$) &#123;            set $static 1;        &#125;        if ($static = 0) &#123;            rewrite ^/(.*)$ /index.php?s=/$1;        &#125;    &#125;    location ~ /Uploads/.*\.php$ &#123;        deny all;    &#125;    location ~ \.php/ &#123;       if ($request_uri ~ ^(.+\.php)(/.+?)($|\?)) &#123; &#125;       fastcgi_pass 127.0.0.1:9000;       include fastcgi_params;       fastcgi_param SCRIPT_NAME     $1;       fastcgi_param PATH_INFO       $2;       fastcgi_param SCRIPT_FILENAME $document_root$1;    &#125;    location ~ \.php$ &#123;        fastcgi_pass 127.0.0.1:9000;        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;        include fastcgi_params;    &#125;    location ~ /\.ht &#123;        deny  all;    &#125;&#125;

3、最后，重启nginx，./nginx -s reload
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>nginx</tag>
        <tag>pathinfo</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机在线迁移实验结果绘图</title>
    <url>/dev-vm-live-migration-gnuplot/</url>
    <content><![CDATA[前言《虚拟机在线迁移实验》一文中，模拟了CPU压力、内存压力、磁盘压力还有各种网络故障，得到了这些条件下虚拟机在线迁移的性能数据。《ApacheBenchmark和gnuplot》一文中，找到了测试Web应用性能的方法，学习了gnuplot的基本用法。
本文，就利用gnuplot给迁移过程中得到的性能数据进行绘图，绘图结果用于写论文。


数据处理gnuplot的数据是纯文本的，不带单位的，按列分布的。那么首先就要处理下数据，使之符合gnuplot的要求，以CPU数据为例，处理后的数据如下：
#CPU占用率  迁移时间    停机时间    迁出数据量   迁入数据量0%  18  6.28    283 24810% 20  6.53    353 34120% 19  4.52    323 30030% 20  4.58    354 33840% 21  4.62    336 34750% 20  5.41    355 32360% 19  4.54    303 30970% 21  5.24    356 35580% 19  4.41    351 33890% 17  7.31    328 36299% 19  5.77    351 348

绘图设计绘图，最基本的，要知道绘图的目的，想要显示出哪些信息？然后考虑绘制什么图？柱状图还是折线图？x轴是什么？y轴是什么？要不要第二坐标轴？另外，就要考虑在一张图里面放入哪些信息，不能太少，显得空旷；不能太多，显得杂乱。对于迁移过程中的四个指标，我们来分析一下。对于迁移时间和停机时间，可以放到一张图（图1）里面，这里的迁移时间和停机时间都是秒级，所以可以使用同一个坐标轴。对于迁移数据量，也可以放进图1，建立第二坐标轴即可。而对于应用程序性能，这个就麻烦了，等会再讨论。
CPU与迁移性能1、按照以上设计，新建cpu.plt，内容如下：
# graph titleset title "CPU usage, downtime and migration time"set key below box 1# x-axisset xlabel "CPU usage"set format x "%g%%"# y-axisset ylabel "seconds"set yrange[0:25]set ytics 5 nomirror# y2-axisset y2label "MB"set y2range[0:500]set y2tics 100set gridplot "cpu.dat" using 1:2 with linespoints title "migration time",\    "cpu.dat" using 1:3 with linespoints title "downtime",\    "cpu.dat" using 1:4 axis x1y2 with linespoints title "transfered data"#pause 5pause mouse

2、gnuplot cpu.plt，执行脚本绘制图片看上去，挺不错的。但是，实际上的downtime应该是毫秒级，不能和migration time共用y轴，否则看不出downtime的变化。所以，最好把迁移数据量拿出来单独绘图，downtime和migration time绘制在同一个图中，使用不同的坐标系。
3、新建cpu1.plt，绘制迁移时间和停机时间
# graph titleset title "CPU usage, downtime and migration time"set key below box 1# x-axisset xlabel "CPU usage (%)"# y-axisset ylabel "Time (s)"set yrange[0:25]set ytics 5 nomirror# y2-axisset y2label "Time (ms)"set y2range[0:10]set y2tics 2set gridplot "cpu.dat" using 1:2 with linespoints title "migration time (s)",\    "cpu.dat" using 1:3 axis x1y2 with linespoints title "downtime (ms)",#pause 5pause mouse

4、新建cpu2.plt，绘制迁移数据量
# graph titleset title "CPU usage and transfered data"set key below box 1# x-axisset xlabel "CPU usage (%)"# y-axisset ylabel "Transfered Data (MB)"set yrange[0:500]set ytics 50plot "cpu.dat" using 1:4 with linespoints title "Source Machine",\    "cpu.dat" using 1:5 with linespoints title "Target Machine"#pause 5pause mouse

CPU与吞吐量1、性能测试
ab -g cpu0.dat -t 120 -n 10000000 http://10.0.2.154/ab -g cpu80.dat -t 120 -n 10000000 http://10.0.2.154/
生成cpu0.dat和cpu80.dat两个文件。
2、处理ab数据，计算吞吐量
#!/bin/bashfor var in &#123;0,80&#125;do    start_time=`awk '&#123;print $6&#125;' cpu$&#123;var&#125;.dat | grep -v 'wait' | sort | uniq -c|head -1|awk '&#123;print $2&#125;'`    awk '&#123;print $6&#125;' cpu$&#123;var&#125;.dat | grep -v 'wait' | sort | uniq -c|awk -v t=$&#123;start_time&#125; '&#123;print $2-t,$1&#125;' &gt; cpu$&#123;var&#125;-t.datdone
生成cpu0-t.dat和cpu80-t.dat两个文件。
3、填充空缺数据为0
#!/bin/bashfor var in &#123;0,80&#125;do    array_str=`cat cpu$&#123;var&#125;-t.dat | awk '&#123;print $1&#125;'`    array_str2=`cat cpu$&#123;var&#125;-t.dat | awk '&#123;print $2&#125;'`    IPS=' '    array=($array_str)    array2=($array_str2)    index=0    count=0    max=121    echo "#cpu$&#123;var&#125;" &gt; cpu$&#123;var&#125;-tf.dat    while ( [ $index -lt $max ] &amp;&amp; [ $count -lt $max ] )    do        if [[ $&#123;array[index]&#125; == $count ]]        then            echo "$count $&#123;array2[index]&#125;" &gt;&gt; cpu$&#123;var&#125;-tf.dat            index=`expr $index + 1`            count=`expr $count + 1`        else            echo "$count 0"  &gt;&gt; cpu$&#123;var&#125;-tf.dat            count=`expr $count + 1`        fi    donedone

4、新建cpu3.plt，绘制吞吐量
# output as png image#set terminal png  size 1000,560#set output "cpu3.png"# graph titleset title "CPU usage and throughput"set key below box 1# x-axis labelset xlabel "Time (s)"# y-axis labelset ylabel "Responses per second"plot "cpu0_tf.dat" using 1:2 with linespoints title "CPU usage 0%",\    "cpu80_tf.dat" using 1:2 with linespoints title "CPU usage 80%"pause mouse

后记内存压力、磁盘压力、网络故障等条件下的实验结果绘图，和CPU压力类似，详情参考live-migration-plot。
对于吞吐量的绘图，还有很多需要完善。比如说取样，绘制所有CPU占用率下的吞吐量会太乱，取样少了又没有对比，所以2-4条是比较合适的。再比如说时间间隔问题，输入ab测试命令后，输入迁移命令，这中间存在时间间隔。而且通过观察吞吐量曲线，也无法看出从何时开始进行迁移，只能看出停机时间。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>VM9下ubuntu安装vmtools</title>
    <url>/dev-vm9-ubuntu-vmtools/</url>
    <content><![CDATA[1.右击“ubuntu”，选择安装Vmware tools
2.设备（CD-ROM）中会出现Vmware tools
3.选中里面的压缩文件，复制到“主文件夹”（为了下面的操作方便），解压
4.ctrl+ait+t，打开终端
5.输入“cd”，回车（为了确保进入了自己的家目录）

6.输入“su”，回车，输入root用户密码，回车（这步是为了切换到root用户）
7.输入“ls -l”，回车，会看到文件列表中出现了vmware-tools-distrib这个文件夹 
8.输入“cd vmware-tools-distrib”，回车
9.输入“ls -l”，回车，会看到vmware-install.pl这个文件
10.输入“./vmware-install.pl”，回车
11.接下来一路回车
12.等到再也没有提示“yes”或“no”时，关闭窗口即可。
13.再次右击“ubuntu”，你会发现“安装vmware tools”的提示变成了“重新安装vmware tools”，至此，大功告成！
14.检验一下：重启虚拟机，从主机复制一个文件然后粘贴到虚拟机
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全学习（二）</title>
    <url>/dev-web-safety-learning-02/</url>
    <content><![CDATA[信息探测在进行安全测试之前，最重要的一步就是信息探测。信息探测时应该搜集哪些资料呢？其实最主要的就是与服务器的配置信息和网站的信息，包括网站注册人、目标网站系统、目标服务器系统、目标网站相关子域名、目标服务器开放的端口和服务器存放网站等。


NmapNmap是一个开源的网络连接端扫描软件，用来扫描计算机开放的网络连接端，确定哪些服务运行在哪些连接端，并且推断计算机运行哪个操作系统。另外，它也用于评估网络系统安全。
常用命令1、扫描主机列表nmap -sL 192.168.199.1/24
2、扫描特定主机上的特定端口nmap -p 80,21,23 192.168.199.1
3、探测主机操作系统nmap -O 192.168.199.1
4、全面的系统探测nmap -v -A 192.168.199.1
5、穿透防火墙的进行扫描nmap -Pn -A 192.168.199.1
6、使用文件。如果你有一个ip地址列表，将这个保存为一个txt文件，和命令行执行路径相同，扫描这个txt内的所有主机。nmap -iL target.txt
PS：target.txt内容
127.0.0.1www.baidu.com

7、保存扫描结果nmap -O 127.0.0.1 -oN result.txt
8、windows扫描本机nmap -sT 127.0.0.1
脚本引擎在Nmap安装目录下存在Script文件夹，在Script文件夹中存在许多以“.nse”后缀结尾的文本文件，即Nmap自带的脚本引擎。
1、扫描Web敏感目录nmap -p 80 --script=http-enum.nse 192.168.199.1
2、扫描SqlInjectionnmap -p 80 --script=sql-injection.nse 192.168.199.1
3、使用通配符扫描nmap --script=&quot;http-*&quot; 192.168.199.1
4、使用所有的脚本进行扫描nmap --script all 192.168.199.1
DirBuster在渗透测试中，探测Web目录结构和隐藏的敏感文件是必不可少的一部分。通过探测可以了解网站的结构，获取管理员的一些敏感信息，比如网站的后台管理页面、文件上传界面，有事甚至可能扫描出网站的源代码。而DirBuster就是完成这些功能的一款优秀的资源探测工具。
图形化界面，熟悉下即可。
指纹识别此处的指纹识别并非一些门禁指纹识别、财务指纹识别、汽车指纹识别等，而是针对计算机或计算机系统的某些服务的指纹识别。
Namp的nmap -O命令，御剑的指纹识别，AppPrint等。
书签Nmap: the Network Mapper - Free Security Scannerhttps://nmap.org/
DirBuster download | SourceForge.nethttps://sourceforge.net/projects/dirbuster/
Nmap scan produces all “unknown”http://security.stackexchange.com/questions/21544/nmap-scan-produces-all-unknown
Zenmap prits all states as unknownhttp://stackoverflow.com/questions/30289512/zenmap-prits-all-states-as-unknown
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>黑客</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全学习（三）</title>
    <url>/dev-web-safety-learning-03/</url>
    <content><![CDATA[漏洞扫描漏洞扫描器可以快速帮助我们发现漏洞，例如，SQL注入漏洞（SQL injection）、跨站脚本攻击（cross site scripting）、缓冲区溢出（buffer overflow）。一个好的漏洞扫描器在渗透测试中是至关重要的，可以说是渗透成功或者失败的关键点。


一款优秀的漏洞扫描器会使渗透测试变得轻松，但对于一些漏洞，自动化软件是无法识别的，例如，逻辑性漏洞，及其隐蔽的XSS漏洞或者SQL注入漏洞。所以，在进行漏扫时，必须要与人工渗透相结合。
漏洞扫描也属于信息探测的一种，扫描器可以帮助我们发现非常多的问题。
本章主要介绍了几款工具的使用，郝同学更加喜欢在应用中学习，因此，不再摘抄书中内容，仅记录一下三款优秀的工具，具体用法自行百度。1、Burp Suite在sectools.org Web扫描模块位居第一名。
2、AWVSAWVS（Acunetix Web Volunerability Scanner）是一个自动化的Web应用程序安全测试工具，它可以扫描任何可通过Web浏览器访问的和遵循HTTP/HTTPS规则的Web站点和Web应用程序。
也有很多人喜欢把AWVS改为WVS称呼，两者是同一款工具。
WVS可以快速扫描跨站脚本攻击（XXS）、SQL注入攻击、代码执行、代码执行、目录遍历攻击、文件入侵、脚本源代码泄漏、CRLF注入、PHP代码注入、XPath注入、LDAP注入、Cookie操纵、URL重定向、应用程序错误消息等。
官网：http://www.acunetix.com/
3、AppScanAppScan是IBM公司出品的一个领先的Web应用安全测试工具，曾以Watchfire AppScan的名称享誉业界。AppScan可自动化Web应用的安全漏洞评估工作，能扫描和检测所有常见的Web应用安全漏洞，例如，SQL注入、跨站点脚本攻击、缓冲区溢出及最新的Flash/Flex应用和Web2.0应用暴露等方面的安全漏洞扫描。
其他国外工具：HP Webinspect、Owasp Zap、Nikto、Owasp WebScarab、w3af、Netsparker。
其他国内工具：JSKY、Safe3 Web Vul Scanner、安恒信息明鉴Web应用弱点扫描器、极光远程安全评估系统。
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>安全</tag>
        <tag>黑客</tag>
      </tags>
  </entry>
  <entry>
    <title>微信获取用户信息</title>
    <url>/dev-weixin-get-user-info/</url>
    <content><![CDATA[前言在微信公众平台开发中，经常会需要获取用户信息。获取用户信息的方法很简单，传入ACCESS_TOKEN和OPENID，直接请求微信给出的接口就可以了。


本文中，参照方倍工作室的分类方法，把access_token分为两种。一种是使用AppID和AppSecret获取的access_token，一种是OAuth2.0授权中产生的access_token，方倍工作室分别称为全局access_token和授权access_token。
全局access_token获取全局access_token传入APPID和APPSECRET，请求微信给出的接口，就可以获取到全局access_token。
https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET

返回结果：
&#123;    "access_token": "NU7Kr6v9L9TQaqm5NE3OTPctTZx797Wxw4Snd2WL2HHBqLCiXlDVOw2l-Se0I-WmOLLniAYLAwzhbYhXNjbLc_KAA092cxkmpj5FpuqNO0IL7bB0Exz5s5qC9Umypy-rz2y441W9qgfnmNtIZWSjSQ",    "expires_in": 7200&#125;

获取openid用户关注以及回复消息的时候，均可以获得用户的OpenID。
&lt;xml&gt;    &lt;ToUserName&gt;&lt;![CDATA[gh_b629c48b653e]]&gt;&lt;/ToUserName&gt;    &lt;FromUserName&gt;&lt;![CDATA[ollB4jv7LA3tydjviJp5V9qTU_kA]]&gt;&lt;/FromUserName&gt;    &lt;CreateTime&gt;1372307736&lt;/CreateTime&gt;    &lt;MsgType&gt;&lt;![CDATA[event]]&gt;&lt;/MsgType&gt;    &lt;Event&gt;&lt;![CDATA[subscribe]]&gt;&lt;/Event&gt;    &lt;EventKey&gt;&lt;![CDATA[]]&gt;&lt;/EventKey&gt;&lt;/xml&gt;
其中的FromUserName就是OpenID。
获取用户信息有了access_token和openid，请求如下接口：
https://api.weixin.qq.com/cgi-bin/user/info?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN

获取到的用户信息数据格式如下：
&#123;    "subscribe": 1,     "openid": "o6_bmjrPTlm6_2sgVt7hMZOPfL2M",     "nickname": "Band",     "sex": 1,     "language": "zh_CN",     "city": "广州",     "province": "广东",     "country": "中国",     "headimgurl": "http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/0",     "subscribe_time": 1382694957,    "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"    "remark": "",    "groupid": 0&#125;

授权access_token微信配置假设M站的网址为http://wx.voidking.com，那么在微信公众平台上，JS接口安全域名修改为wx.voidking.com，网页授权获取用户基本信息修改为wx.voidking.com。
获取code在确保微信公众账号拥有授权作用域（scope参数）的权限的前提下（服务号获得高级接口后，默认拥有scope参数中的snsapi_base和snsapi_userinfo），引导关注者打开如下页面：
https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect
若提示“该链接无法访问”，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。
获取授权access_token和openid获取code后，请求接口：
https://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code

返回数据如下：
&#123;   "access_token":"ACCESS_TOKEN",   "expires_in":7200,   "refresh_token":"REFRESH_TOKEN",   "openid":"OPENID",   "scope":"SCOPE",   "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"&#125;

获取用户信息获取code时，如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。请求接口如下：
https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN

返回数据如下：
&#123;    "openid":"OPENID",    "nickname":"NICKNAME",    "sex":"1",    "province":"PROVINCE"    "city":"CITY",    "country":"COUNTRY",    "headimgurl":"http://wx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46",     "privilege":[        "PRIVILEGE1",        "PRIVILEGE2"    ],    "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"&#125;

Node端源码https://github.com/voidking/nodebase/blob/master/controllers/weixin.js
两种方法的对比接口全局access_token获取用户信息接口为https://api.weixin.qq.com/cgi-bin/user/info。授权access_token获取用户信息接口为https://api.weixin.qq.com/sns/userinfo。
返回数据全局access_token获取用户信息返回数据为：
授权access_token获取用户信息返回数据为：
小结通过授权access_token无法得知用户是否关注了公众号，必须通过全局access_token。
后记有问题，看文档。经历了四年发展的微信公众平台，文档已经越来越完善。
书签微信公众平台开发(76) 获取用户基本信息http://www.cnblogs.com/txw1958/p/weixin76-user-info.html
微信公众平台开发者文档——获取用户基本信息http://mp.weixin.qq.com/wiki/14/bb5031008f1494a59c6f71fa0f319c66.html
微信公众平台开发者文档——网页授权获取用户基本信息http://mp.weixin.qq.com/wiki/17/c0f37d5704f0b64713d5d2c37b468d75.html
微信公共平台Node库 APIhttp://doxmate.cool/node-webot/wechat-api/api.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>微信本地调试</title>
    <url>/dev-weixin-localhost-debug/</url>
    <content><![CDATA[前言在微信开发的时候，需要填写与微信服务器相连接的url，这个url必须是公网域名。也就是说我们需要在这个公网域名对应的公网服务器上做开发，而没办法本地开发调试。
理想的解决办法，是把公网域名绑定到本地服务器，那就可以本地开发调试了。而本地主机是没有公网IP的，怎么办？动态域名解析。


ngrok
I want to expose a local server behind a NAT or firewall to the internet.我想发布一个能够被公网访问的本地服务。

ngrok官网上的这句话，也正是我们的需求。
按照官方教程，郝同学测试了一下。ngrok会分配给我们一个动态域名，也可以通过公网访问这个域名（也就访问到了本地服务器），nice。但是，如果想要使用固定域名，必须付费。基础版5dollar一个月，约合人民币33.4元，值得。
natapp
开启您的内网穿透之旅。

natapp，实际上是中国的ngrok。收费更便宜，基础版5元一个月，真心实惠，强烈推荐。
值得一提的是，natapp的服务人员态度很好。由于官方文档还不是特别完善，郝同学遇到了一个解决不了的问题：付费后依然无法使用固定域名。给服务人员发邮件，很快就回复，还帮忙远程。最后确定是win8.1系统的问题，无法使用配置文件，必须手输参数。
win8.1下natapp启动步骤：在natapp.exe所在的文件夹，鼠标右键+shift，在此处打开命令窗口，输入以下命令即可。
natapp -authtoken=xxxxxx

花生壳花生壳的业务有点多，其中一个是提供动态域名解析。郝同学花了5元在花生壳买了个固定域名，不过没有继续测试，感兴趣的小伙伴自行百度。
后记最终，郝同学决定长期使用natapp。natapp官网分配的固定域名为voidking.vip.natapp.cn，郝同学绑定了自己的域名wx.voidking.com。
在微信公众平台测试号上，JS接口安全域名修改为wx.voidking.com，网页授权获取用户基本信息修改为wx.voidking.com。
完成了以上步骤，就可以进行微信公众号网站的本地开发了。如果要做微信公众号后台，接口配置信息也需要修改。
书签微信开发如何做本地调试https://www.zhihu.com/question/25456655
ngrok - secure introspectable tunnels to localhosthttps://ngrok.com/
NATAPP 基于ngrok高速内网穿透服务https://natapp.cn/
花生壳官网http://www.oray.com/
微信公众平台开发者文档http://mp.weixin.qq.com/wiki/home/index.html
微信公众平台接口调试工具http://mp.weixin.qq.com/debug/
微信web开发者工具http://mp.weixin.qq.com/wiki/10/e5f772f4521da17fa0d7304f68b97d7e.html
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>微信</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>wiki简单使用</title>
    <url>/dev-wiki-start/</url>
    <content><![CDATA[创建空间1、导航栏点击空间，创建空间，选择团队空间。2、填入空间信息，创建。


新建页面1、进入空间后，导航栏点击创建，然后新建一个页面。2、进入一个页面，导航栏点击创建，然后新建一个页面。
切换主题1、导航栏选择空间，空间目录。2、点击空间名称后面的小圆圈（Space Details），进入空间管理页面。或者在进入空间后点击右上角工具，以层级方式查看。3、点击外观，主题，然后选择Documentation Theme，确认。
页面树1、进入空间后，点击右上角编辑。2、删除不需要的模块，保留需要的模块。3、插入，其他宏，导航，页面树。4、配置页面树，插入。
重建索引有时候，进入空间目录，却看不到我们新建的空间，这是因为索引没有更新。1、导航栏单击管理（右上角齿轮），一般配置。2、下拉在左边导航栏找到管理，内容索引。3、单击重新创建，等待片刻即可。
wiki转邮件有时候，编辑好了wiki页面，然后想作为邮件发送。但是，如果直接复制粘贴到outlook，会发现格式全部都乱了。比较好的做法是导出为word，打开word，复制粘贴到outlook。
]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>wiki</category>
      </categories>
      <tags>
        <tag>wiki</tag>
      </tags>
  </entry>
  <entry>
    <title>Win8+UbuntuKylin注意事项</title>
    <url>/dev-win8-ubuntukylin-notice/</url>
    <content><![CDATA[前言接近一年半没有换过操作系统（Win7），各种大型软件，各种系统后台服务，怎一个牛逼了得！近期安装的Oracle，成功地再次拖慢了系统速度，终于达到了郝同学的忍耐极限！做完了所有实验，果断换个系统！
忙碌了一天，安装了Win8+Ubuntu Kylin，并且对它们进行了基本配置和简单优化。在此简单记录下过程中遇到的问题，以及解决办法，分享给大家。


安装方法详细方法请见《安装系统》系列，这里简单叙述一下。1、准备两个U盘，一个使用U大师做成启动盘（U盘1），另一个利用Universal-USB-Installer-*.exe做成Ubuntu安装盘（U盘2）。2、使用U盘1启动，进入WinPe。3、分区，分成四个，然后删除最后一个分区（等会儿安装Ubuntu）。4、安装Win8。5、使用U盘2启动，进入Ubuntu的安装界面。6、在空白分区上分区，swap分区4096MB（Logical），/分区占用剩下的全部空间（Primary）。7、安装Ubuntu。
Win8不见了安装完成，郝同学发现，开机不会出现启动选项，直接进入Ubuntu。应该是因为安装Ubuntu时重写了引导扇区，没关系，我们只要在Ubuntu系统下执行sudo update-grub。该命令会自动检测启动项，重新生成/boot/grub/grub.cfg文件。重新启动，已经多出了Win8的启动选项。
很多小伙伴认为，必须要GPT分区，必须要EFI分区。其实没必要，郝同学就是传统的MBR分区，毫无问题。
Win8初始软件卸载完自带的软件，接下来就要个性化定制了。先美化一下桌面，设置一下头像密码等，需要的软件有：

搜狗输入法
Notepad++
JDK
Eclipse
WPS
FastStone Capture
Photoshop
360安全卫士
360极速浏览器（IE不好用，Firefox笨重且历史记录太丑，Chrome插件受限，UC连主页都可以设置）
360云盘
百度云盘
QQ
QQ飞车
ADSafe
其他。。。

Ubuntu初始软件
搜狗输入法
JDK
Eclipse
WPS
vim。vim输入法需要更新，否则上下左右键不可用，更新命令：sudo apt-get remove vim-common，sudo apt-get install vim。

Ubuntu中文文件夹转英文想到以前使用Ubuntu的痛苦经历，郝同学决定直接安装英文版。安装好之后，在Language设置中选择中文，重启。启动后，系统会询问是否把Home文件夹中的文件夹转换为中文，选择否。如此，便可以保持中文界面，同时在使用命令的时候，不用中英文输入法来回切换。
Win8比Ubuntu慢8小时设置好Ubuntu，重启切换到Win8，发现Win8时间要比Ubuntu的时间慢8个小时！
原因：Windows把系统硬件时间当作本地时间（local time），即操作系统中显示的时间跟BIOS中显示的时间是一样的。Linux/Unix/Mac把硬件时间当作UTC，操作系统中显示的时间是硬件时间经过换算得来的，比如说北京时间是GMT+8，则系统中显示时间是硬件时间+8。
解决办法：修改ubuntu时间如下：sudo gedit /etc/default/rcS找到这一行： UTC=yes把 yes 改为 no 。
设置Win8为默认启动项1、在Ubuntu下，进入/etc/grub.d2、sudo mv 30_os-prober 06_os_prober3、sudo update-grub
参考文档win8和ubuntu13.10 双系统时间错误http://blog.csdn.net/flywindmouse/article/details/13025017

将Ubuntu主文件夹里的中文文件夹名称改成英文http://blog.csdn.net/l0605020112/article/details/20285239

Windows与Ubuntu双系统启动菜单管理和配置（补充win8）http://blog.chinaunix.net/uid-23586172-id-3075207.html
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>ubuntu</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows安装配置Gym</title>
    <url>/dev-windows-gym/</url>
    <content><![CDATA[前言最近在研究强化学习，各种概念公式，让人心烦意乱。打算搞点有意思的东西，提高下学习的热情。
听说用强化学习玩游戏很有意思，不妨搞一下。第一步，安装OpenAI Gym，本文做下记录。


安装篇环境准备win10系统，python3.6.3。
更换pip源参考python pip更换国内源，打开%appdata%目录，新建pip目录，pip目录下新建pip.ini文件，内容为：
[global]index-url = https://mirrors.aliyun.com/pypi/simple/[install]trusted-host = https://mirrors.aliyun.com/pypi/simple/

下载安装参考gym官方文档，使用一条命令安装即可：pip install gym
测试篇1、新建python脚本demo.py：
import gymenv = gym.make('CartPole-v0')env.reset()for _ in range(1000):    env.render()    env.step(env.action_space.sample()) # take a random action

2、运行脚本python demo.py

后记gym安装配置很简单，接下来，就可以愉快地进行游戏训练了。
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>强化学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>gym</tag>
        <tag>rflearning</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Word2010发布WordPress博客文章</title>
    <url>/dev-word2010-deploy-wordpress-article/</url>
    <content><![CDATA[用word2010编辑发布wordpress博客文章1、打开word，选择新建博客文章

2、如果之前没有用word发布过文章，会提示你注册博客账户
3、选择立即注册，然后选择博客提供商，在此我们选择wordpress
4、把下面这张表格填写完整，就像我给出的例子那样
5、点击确定，等几秒钟会提示“账户注册成功”。
6、然后我们就可以用word来编辑文章，编辑好之后，然后点击左上角的“发布”，就会出现提示：“此文章已于某时间发布到某网站上了”。
7、查看自己的网站，会发现果然发布成功，一切如此简单！发布后的文章属于Uncategorized分类，我们可以自己在网站上修改分类，这样就大功告成了！
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress使用说明</title>
    <url>/dev-wordpress-illustration/</url>
    <content><![CDATA[WordPress使用说明前言WordPress是一个免费的开源项目，在GNU通用公共许可证下授权发布。是一个注重美学、易用性和网络标准的个人信息发布平台。简体中文官网：http://cn.wordpress.org
当年，刚开始接触建站，和WordPress留下了一段难忘的时光。
本地环境由于WordPresss是使用PHP语言和MySQL数据库开发的。所以，本地搭建测试环境，需要PHP和MySQL。

这里推荐两个套件：1、XAMPPhttps://www.apachefriends.org/index.html
2、ServKit（曾经叫做PHPnow）http://servkit.org/
本地问题解决1、Attempting to start Tomcat service…双击tomcat7.exe，提示不是有效的32位程序。但是在命令行敲startup可以正常启动。自我感觉最好的解决办法是把可以正常使用的tomcat文件夹替换掉xampp的tomcat文件夹。
2、安装xampp后apache不能启动解决方法http://blog.csdn.net/kunlong0909/article/details/7716715
3、MySQL Service detected with wrong path首先需要修改一下环境变量。应该是在安装xampp之前电脑上装过mysql，然后默认启动的是以前的mysql。修改注册表[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\MySQL]的ImagePath修改成新的xampp中位置\mysql\bin\mysqld MySQL重启explorer.exe进程，使注册表生效再次点击 mysql 后边的start，OK！mysql服务正常启动！ 
4、安装wordpress过程中，访问wp-admin/install.php出错：数据库连接错误。您在wp-config.php文件中提供的数据库用户名和密码可能不正确crifan的博客
优化1、在wordpress功能版块有登入\登出，管理，Feed以外，还有一个wordpress，如何删除它们呢，看起来使博客的所有链接实际有用！找到网站wordpress安装目录，在wp_includes文件夹下面有一个default-widgets.php的文件，在此文件里搜索查找标签里带有rss2_url，comments_rss2_url，wordpress.org的三段代码全部删除掉。
2、WordPress文章置顶1、写好文章并发布。2、点击博客后台文章菜单下的“编辑”选项，进入文章列表。3、把鼠标移到需要置顶的文章上，点击“快速编辑”选项。4、在快速编辑下“保持这篇文章置顶”前面的小框打勾，然后点击更新文章。5、更新文章后，打开博客首页就会发现文章的置顶状态了。Tips：除了使用这个方法，也可以使用WordPree的一些文章置顶插件，相对来说可能会方便许多，在这里不做推荐。
3、WordPress评论框下方“您可以使用这些 HTML 标签和属性”文字去除找到wp-includes/comment-template.php查找：echo $args[‘comment_notes_after’];注释掉它（也可以直接删除）。
参考文档PHP 手册http://php.net/manual/zh/

WordPress中文文档 | WordPress啦http://www.wordpress.la/codex.html

WordPress官方中文文档http://codex.wordpress.org/zh-cn:Main_Page

WordPress连接微博:个人博客开放化策略微博QQ百度账号登录http://www.freehao123.com/wordpress-weibo-qq/

怎样在wordpress网站添加小工具http://www.zhidao91.com/wordpress-add-widget-area/

如何轻松的在你的wordpress网站添加附加小工具或者导航区域http://www.ylsay029.com/how-to-add-widget-or-navigation-areas-wordpress-website.htmlhttp://www.douban.com/note/285551052/

新版京东云擎JAE云空间申请使用和安装运行WordPress博客http://www.freehao123.com/jae-wordpress/

增强Wordpress编辑器功能最简便的方法http://jingyan.baidu.com/article/7c6fb42841891b80652c906b.html

两步搞定WordPress多区域widgethttp://www.wordpress.la/widgetize-wordpress-theme.htmlhttp://www.veryhuo.com/a/view/15116.html

WordPress 博客添加个性标志favicon.icohttp://www.chinaz.com/web/2010/0928/135480.shtml

中文版标签云插件：wp-cumulushttp://plugins.wopus.org/content/tagplugin/146.html

29个实用的WordPress主题函数使用技巧.pdf、WordPress主题教程.pdf、WordPress_主题模板制作及修改教程.pdfhttp://yunpan.cn/cVbAQzcvut7FS  访问密码 dd25

wordpress代码调用大全更新到_3.0版.pdf、WordPress高级教程.pdf、如何用WORDPRESS改成CMS来开发企业站.pdfhttp://yunpan.cn/cVbAqs5Bd32pS  访问密码 82bc

]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>mysql</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>WordPress首页播放音乐</title>
    <url>/dev-wordpress-music/</url>
    <content><![CDATA[Wordpress首页自动播放音乐最简单方法1、登陆flash网页mp3播放器代码生成器网站，比如http://www.51119.com/play/

2、选择一种播放器格式
3、寻找MP3外链，可以到这个网站http://www.111ttt.com/up/去寻找，找到的外链像这种http://sc.111ttt.com/up/mp3/5060/973D42EA0271C8E4A1E9421D9AD2890E.mp34、粘贴到“MP3地址”那一栏中，简单设置后提交，结果如下
5、复制html代码，接着，到WordPress控制台下，在“外观（Appearance）”选项里找到“小工具（Widgets）”，点击进入，然后拖放一个“文本（Text）”小工具放到边栏（Sidebar）里，在文本框输入区域粘贴代码即可。
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title>yii框架整合smarty使用自定义验证码</title>
    <url>/dev-yii-smarty-captcha/</url>
    <content><![CDATA[前言把模板引擎换成smarty后，yii框架自带的captcha，非常不友好，使用起来不方便。干脆自己封装一个php图片验证码模块，想要移植到其他框架，简单修改即可。


设计思路PHP生成验证码的原理：使用PHP的GD库，生成一张带验证码的图片，并将验证码保存在Session中。PHP生成验证码的大致流程有：
1、产生一张png的图片；
2、为图片设置背景色；
3、设置字体颜色和样式；
4、产生N位数的随机的验证码；
5、把产生的每个字符调整旋转角度和位置画到png图片上；
6、加入噪点和干扰线防止注册机器分析原图片来恶意破解验证码；
7、输出图片；
8、释放图片所占内存。
项目结构1、《yii框架实战》的基础上，在controllers目录中新建util目录，util目录中新建CaptchaController.php，用来实现验证码模块。
2、在web中新建font目录，font目录中放入微软雅黑字体msyh.ttf，用来显示验证码上的字体。

代码实现&lt;?phpnamespace app\controllers\util;use Yii;use yii\filters\AccessControl;use yii\web\Controller;use yii\filters\VerbFilter;class CaptchaController extends Controller&#123;    public function actionIndex()    &#123;        echo 'captcha index function';    &#125;    public function actionGetcode()&#123;        session_start();        $response = Yii::$app-&gt;getResponse();        $response-&gt;format = $response::FORMAT_RAW;        $this-&gt;createCode(300,80,30);    &#125;    public function createCode($width,$height,$fontsize)&#123;        //设置验证码图片大小的函数        $image = imagecreate($width, $height);            //设置验证码颜色 imagecolorallocate(int im, int red, int green, int blue);        $bgcolor = imagecolorallocate($image,255,255,255); //#fff        //区域填充 int imagefill(int im, int x, int y, int col) (x,y) 所在的区域着色,col 表示欲涂上的颜色        imagefill($image, 0, 0, $bgcolor);                //设置变量        $captcha_code = "";        //生成随机的字母和数字        for($i=0;$i&lt;4;$i++)&#123;                          //设置字体颜色，随机颜色，0-120深颜色            $fontcolor = imagecolorallocate($image, rand(0,120),rand(0,120), rand(0,120));                 //$fontcolor = imagecolorallocate($image, 0, 0, 0);            //设置需要随机取的值，去掉容易出错的值如0和o、1和l、2和z            $data ='abcdefghigkmnpqrstuvwxy3456789';            //取出值，字符串截取方法  strlen获取字符串长度            $fontcontent = substr($data, rand(0,strlen($data)-1),1);            //连续定义变量            $captcha_code .= $fontcontent;                            //imagestring设置字体大小，最大值为5            //$fontsize = 5;             //设置坐标            $x = ($i*$width/4)+rand(5,10);            $y = rand(($height+$fontsize)/2-5,($height+$fontsize)/2+5);            //imagestring($image,$fontsize,$x,$y,$fontcontent,$fontcolor);            imagettftext($image,$fontsize,rand(-10,10),$x,$y,$fontcolor,'font/msyh.ttf',$fontcontent);        &#125;        //存到session        $_SESSION['captcha_code'] = $captcha_code;        //增加干扰元素，设置雪花点        for($i=0;$i&lt;200;$i++)&#123;            //设置点的颜色，50-200颜色比数字浅，不干扰阅读            $pointcolor = imagecolorallocate($image,rand(50,200), rand(50,200), rand(50,200));                //imagesetpixel — 画一个单一像素            imagesetpixel($image, rand(1,$width-1), rand(1,$height-1), $pointcolor);        &#125;        //增加干扰元素，设置横线        for($i=0;$i&lt;2;$i++)&#123;            //设置线的颜色            $linecolor = imagecolorallocate($image,rand(80,220), rand(80,220),rand(80,220));            //设置线，两点一线            imageline($image,rand(1,$width-1), rand(1,$height-1),rand(1,$width-1), rand(1,$height-1),$linecolor);        &#125;                 //设置头部，image/png        header('Content-Type: image/png');        //imagepng() 建立png图形函数        imagepng($image);        //imagedestroy() 结束图形函数 销毁$image        imagedestroy($image);    &#125;    public function actionCheck($code)&#123;        session_start();        if(isset($_SESSION['captcha_code']))&#123;            if($_SESSION['captcha_code'] == $code)&#123;                unset($_SESSION['captcha_code']);                $result = array(                    'code'=&gt; '0',                    'ext'=&gt; '验证成功'                );            &#125;else&#123;                $result = array(                    'code'=&gt; '1',                    'ext'=&gt; '验证码错误'                );            &#125;        &#125;else&#123;            $result = array(                'code'=&gt; '2',                'ext'=&gt; '请先刷新验证码'            );        &#125;        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125; &#125;

使用接口获取验证码接口：http://localhost/basic/web/util/captcha/getcode
验证验证码接口：http://localhost/basic/web/util/captcha/check?code=f7nh
显示在smarty渲染的页面中，直接使用验证码接口即可显示图片。
&lt;p&gt;&lt;img id="captcha" src="http://localhost/basic/web/util/captcha/getcode" alt=""&gt;&lt;/p&gt;&lt;p&gt;请输入验证码：&lt;input id="code" type="text"&gt;&lt;/p&gt;&lt;p&gt;&lt;input id="check" type="button" value="确定"&gt;&lt;/p&gt;

刷新如果要刷新验证码，在js中重置src地址即可。
$('#captcha').click(function()&#123;    var $new_src = 'http://localhost/basic/web/util/captcha/getcode?'+Math.random();    $(this).attr('src',$new_src);&#125;);

验证$('#check').click(function()&#123;    var data = &#123;        code: $('#code').val()    &#125;;    $.ajax(&#123;        url: 'http://localhost/basic/web/util/captcha/check',        type: 'GET',        dataType: 'json',        data: data,        success: function(data)&#123;            alert(data.ext);        &#125;,        error: function(xhr)&#123;            console.log(xhr);        &#125;    &#125;);&#125;);

效果演示
源码分享1、下载安装：git clone https://github.com/voidking/yii-basic.git basic
2、利用navicat等工具连接到本地mysql数据库，创建数据库basic，在数据库中创建表bas_project(int id, varchar title, varchar content)。注意，编码格式选择utf8。
3、验证码测试页url：http://localhost/basic/web/util/captcha/index
书签PHP生成各种验证码和Ajax验证
PHP如何实现验证码
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>yii</tag>
        <tag>验证码</tag>
      </tags>
  </entry>
  <entry>
    <title>yum命令</title>
    <url>/dev-yum-command/</url>
    <content><![CDATA[通过yum安装和删除RPM包安装rpm包,如dhcpyum install dhcp
删除rpm包,包括与该包有依赖性的包yum remove licq注意:同时会提示删除licq-gnome,licq-qt,licq-text
通过yum工具更新软件包检查可更新的rpm包：yum check-update
更新所有的rpm包：yum update

更新指定的rpm包,如更新kernel和kernel source：yum update kernel kernel-source
大规模的版本升级,与yum update不同的是,陈旧的淘汰的包也会升级：yum upgrade
通过yum查询RPM包信息列出资源库中所有可以安装或更新的rpm包的信息：yum info
列出资源库中所有可以更新的rpm包的信息：yum info updates
列出已经安装的所有的rpm包的信息：yum info installed
列出已经安装的但是不包含在资源库中的rpm包的信息：yum info extras注：也就是通过其它网站下载安装的rpm包的信息。
列出资源库中所有可以安装或更新的rpm包的信息：yum list
列出资源库中特定的可以安装或更新以及已经安装的rpm包的信息：yum list sendmailyum list gcc*注意：可以在rpm包名中使用匹配符， 如上面例子是列出所有以gcc开头的rpm包的信息。
搜索匹配特定字符的rpm包的详细信息：yum search wget注意：可以通过“search”在rpm包名，包描述中进行搜索。
搜索包含特定文件名的rpm包：yum provides realplay
通过yum操作暂存信息（/var/cache/yum）清除暂存的rpm包文件：yum clean packages
清除暂存的rpm头文件：yum clean  headers
 清除暂存中旧的rpm头文件和包文件：yum clean  all
Redhat Linux下用yum升级系统yum也可以升级Redhat Linux系统，在Redhat Linux系统安装盘中默认没有yum的安装包，由于Redhat Linux与Centos Linux基本一致，因此可以用同版本同内核的Centos Linux的yum包在Redhat Linux上进行安装。安装过程在上面章节已经讲述，这里不在多说。由于使用的是Centos Linux的yum包在Redhat Linux下进行的安装，因此在Redhat Linux下需要增加资源库，定义yum的非官方库文件，让一些必需的软件包通过yum也能够安装。首先建立dag.repo，定义非官方库：vi /etc/yum.repos.d/dag.repo
[dag]name=Dag RPM Repository for RHEL4baseurl=http://ftp.riken.jp/Linux/dag/redhat/el4/en/$basearch/dag/enabled=1gpgcheck=1
接着导入非官方库的GPG：rpm --import  http://ftp.riken.jp/Linux/caos/centos/RPM-GPG-KEY-centos4注意：此步骤很重要，如果没有导入授权的RPM-GPG-KEY，在使用yum升级安装软件时就会提示软件不合法，结合上下文可以看出，在Centos下进行yum配置的时候，并没有涉及到导入RPM-GPG-KEY，那是因为连接的资源库为Centos官方的库，而升级的系统也是Centos，当然无需授 权，而这里我们升级的系统是Redhat Linux，而用的资源文件是Centos的，所以必须导入Centos的RPM-GPG-KEY，系统才认为升级的包是合法的。 
最后，就可以使用非官方定义的rpm包升级系统：yum update
实践yum install vimyum install gccyum install gcc-c++]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>13-14寒假学习计划</title>
    <url>/essay-13-14-the-winter-vacation-learning-plan/</url>
    <content><![CDATA[一、Java1、线程√2、集合√3、泛型√4、反射机制√5、网络编程√6、枚举√7、持久化Hibernate√
1、jsp serverlet Tomcat√2、java webservice————————————3、javaAPIrestful4、服务器 jboss jetty glassfish5、框架 Struts JPA spring framework6、23种设计模式√

二、前端1、html2、css3、javascript————————1、jquery2、extjs3、angularjs
三、Android
四、数据库1、基本操作 mysql oracle db2 sqlite √2、优化3、事务
五、帮助1、stackoverflow2、谷歌开发者3、插件4、5431156375、oracle官网
java基础看完。23种设计模式junit或者testng单元测试hudson集成测试subversion版本控制和管理maven依赖管理尽可能对软件研发有一个总体的了解
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>写在25岁之前</title>
    <url>/essay-before-25-years-old/</url>
    <content><![CDATA[前言今天是鸡年春节，以阴历生日划分年龄的话，还有一个月就到25岁了。
25岁，研一。上学晚，加一年复读，最终导致，同级的小伙伴，普遍年龄在22到23岁。想到这，心里难免有些落差。仍然没有踏入职场，仍然依赖父母过活，仍然没有出类拔萃。


家人今年回家，印象格外深刻。还有几天就要过年，零下四五度，离天亮还早，当我还在没有醒来的时候，妈妈和奶奶已经在集市卖菜，爸爸已经在地里忙活。十二点半以后回来，刚吃完午饭，来不及休息，就去地里收菜。夜幕降临才回家，晚饭后，已经累得不行的他们，早早入睡。
日未出而作，日已落未休。然而，就是这样忙碌的一天，三个人，总共就能赚到一百块钱左右，这还是因为过年生意好。而整个地里的菜卖完，也就能卖到三四千。
多想对家人说：“别种地了，那么累还赚不到什么钱！”但是，我又有什么资格？家里花钱最多的就是我了。已经奔三，还在依仗父母。犹记得去长春之前，信誓旦旦，自己赚取生活费。再想想，只能自嘲一笑，非全职，哪有那么容易。要上课，要备考，要处理实验室的事情，要陪女朋友，要自学一些东西。
呆在家里的空调房，静静想着，理由很充分，但是负罪感还是涌上心头。那么，我该怎么做？至少，研究生不能只是混个学历，而是学到本科生不会的东西！真正牛逼的东西！
会有那么一天，自信地对家人说：“别种地了，我养你们！”
恋人东北读研，最大的幸运，就是遇到了小七。命运丈量了两人的轨迹，安排好，让我们相遇相知相爱。
从陌生到熟悉，从熟悉到真实，从真实到包容。一路走来，不长，但是已经走进了彼此的生活。我知道你的小脾气，给你包容；你知道我的小秘密，给我理解。有过争执，有过烦恼，但更多的是欢乐，是两个人在一起的满足。
一起规划未来，有很多困难要克服，但是，我们都不会放弃。一段感情，最大的困难不是来自外部，而是来自两人之间。彼此理解，包容，信任，全心付出，有什么困难是不能克服的呢？
只愿与子偕老，共赴一生情长。
亲人亲情观念越来越淡，但是，那些看着自己长大，对自己各种宠爱的亲人，始终在心里占据非常重要的位置。
“将来有出息了，一定好好报答他们。”打算孝敬外公的钱还没有，打算感谢姑妈姨妈的礼物还没有，打算给表弟买的电脑还没有……
兄弟没有拜把子，却有兄弟。兄弟在一起，损损这个，骂骂那个，吹吹牛逼，无话不谈，无需顾忌，无需伪装，都是最真实的自己。聚也好，不聚也好，再见面都能一个熊抱：“二货（傻逼），好久不见！”
一年又一年，兄弟们一个比一个混的好。工作的，早九晚五，生活滋润，准备着结婚；学习的，泡实验室，成绩优异，各种奖学金。
看到积极向上的大家，心中不免升起一种不服输的豪情！小样，哥哥不会落后给你们的！
后记乱七八糟扯了很多，总而言之，男人，你必须得有所成就了，你必须得更加努力。
三十而立，还有五年。你必须在某一方面出类拔萃，成为佼佼者，行业顶尖，拥有安身立命的本钱。读书这么多年，必须有一个对得起自己，对得起家人的交代！
你还有心爱的人儿要娶，你还有亲爱的长辈要孝敬，你还有可爱的兄弟们要去攀比，怎么敢停下脚步？
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>考研还是工作</title>
    <url>/essay-choice-kaoyan-or-work/</url>
    <content><![CDATA[班主任说：“你们大四肯定没课！”如果这是真的，那么，今天结束的编译原理课设，就是大学里的最后一门课设。还有两场考试，大学的课程就全部结束了。然后呢？
学院说：“下学期安排你们实习，16周！”几乎一整个学期。我关心的是，是否可以自己找实习单位？是否可以在学校规定的实习期满后继续实习，或者留在单位工作？
如果两个问题的答案都为“是”，那么，我完全可以出去工作了，和应届毕业生相比，也就差了一张毕业证书！有同学补充说，还有一张学位证书，不要在意这些细节。。。
但是，学院至今没有给出明确的答复，说是等通知。男人，要有魄力！那就默认学校同意了，哪怕不同意，也会有斡旋的办法。
好了，真正的选择来了，考研还是工作？

考研，研究生毕业，几乎不会再遇到学历限制，起点更高，起薪更高，提升空间更大。但是，考研的准备时间很长，上课两年，还要写各种报告。
工作，早点进入职场，早点学会企业实用的技术，早点获取经验值，早点赚钱，早点娶媳妇。但是，学历这个东西，也许会限制自己的发展。经验值早一点晚一点，都可以得到。而学历，错过了这个提升时间，也许这辈子就错过了。2+6+3+4+4，19年学校生活，每个人都拿到了不同等级的毕业证。不考研，便放弃了这次，也许是最后一次，获取高级毕业证的机会。
如今，我处在一个隐藏副本当中，每个玩家一生只可以进入一次。传说，打败这个副本中的BOSS，就可以获得神级装备，全属性增值50%。获得这件神级装备的玩家，被称为同级至尊，甚至可以越级刷图打怪。玩家在该副本中消灭小怪，积累经验、等级、装备，在12月26和12月27去挑战BOSS，BOSS死后掉落紫色神级装备。但是，想要打败这个BOSS，非常困难。有些玩家努力了几年，都不能如愿。而有些放弃了这个副本的同期玩家，已经在主线任务中牛逼哄哄！这个副本，刷还是不刷？
短期看，工作更好，有趣有挑战性！长期看，考研更好，有机会修改四分之一人生的分数！而且，研究生毕业当年，能够拿到的年薪，并不会比工作两年后的年薪低！再往后看两年、五年，研究生学历的优势会更加明显！
经过以上种种分析，我得出了答案：男人，全力准备考研吧！！！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>感冒后为什么咳嗽不止</title>
    <url>/essay-cold-cough/</url>
    <content><![CDATA[一般感冒只持续3～5天，长的也就7～10天。有些患者感冒的其他症状都消失了，只有咳嗽还持续不断，甚至1个多月才好，这叫做感冒后慢性咳嗽。这种咳嗽的特点是一声声或一阵阵，为刺激性干咳。夜间重，遇到寒冷、灰尘环境、刺激性气体、运动、烟雾或再次感冒，都可诱发加重。随着时间推移，不治也能痊愈。为什么多数人得了感冒很快就好了，而有些人感冒之后咳嗽不断呢?


从病原体来说，感冒多由病毒引起，如鼻病毒、冠状病毒、流感病毒、副流感病毒、合胞病毒等，也有少数是由支原体、衣原体及百日咳杆菌引起。这些病原体侵犯了呼吸道上皮，引起损伤，上皮坏死裸露，常达基底膜。有一小部分人因为过敏体质，上述损害通过迷走神经反射引起气道收缩，加重咳嗽，上呼吸道感染引起的支气管高反应（过敏反应），可持续5～7周。从本质来说，病毒感染引起的呼吸道感染，可诱导免疫细胞分泌一些介质，如激肽、白三烯、组胺、白介素1、6、8、巨噬细胞、T细胞等，这些免疫细胞促使局部气道过敏。从病理学上符合炎症表现（病理学上凡具有渗出、变性坏死及增生形成的就叫炎症），对气道进一步形成损害。这种气道炎症对激素治疗最敏感。
因为感冒后慢性咳嗽是一种自限性疾病，不治自己也能好，所以医生治疗起来多半不太积极，不乱用药。具体治疗方法：1．先给予止咳药右美沙芬，其止咳作用与可待因相当，但无成瘾性，对呼吸中枢也无抑制，口服每次15～30毫克，每天3～4次；或用喷妥维林，作用相当于可待因的1／3，口服每次25毫克，每日3次。2．若上法无效可吸入丙酸倍氯美松（必可酮），经鼻吸入，每次2喷，每天3次，共用3～7天，也可口服泼尼松（强的松），每次10～20毫克，每日1次，共用3～7天。3．不愿意用激素者也可吸入溴化异丙托品，每天吸人320毫克，共用3～7天，本药对吸烟者疗效差。4．通常不用抗生素，如疑为支原体、衣原体或百日咳杆菌引起者，可应用大环内酯类抗生素，如罗红霉素，每次100毫克，口服，每天2次，共用3～7天。（邵　荣）
本文转载自：http://blog.sina.com.cn/s/blog_4d25c4f40100gyg3.html
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>大众点评极客大赛</title>
    <url>/essay-dianping-geek/</url>
    <content><![CDATA[前言前段时间，参加了大众点评的极客大赛初赛。线上编程排位赛，最初排名第六，第二次排名掉到第十，第三次排名明天出结果。没有关系了，今天收到大众点评的决赛通知，看来排名应该进了前六十。


准备8月8日到8月10日，上海大众点评总部。
决赛第一名iPhone6 plus，第二名iPad Air，还有大众点评的录用意向书，很有吸引力，好好准备！
24小时的编程比赛，组队做一个Demo。以前的项目经验，估计可以派上用场，但是基本上都忘记了。这几天，Android暂时放下，复习一下以前的项目，搞一搞！
主要有三个项目值得重做：

图书管理系统
团队博客
微信公众平台iNJIT

后记估计，可以遇到很多牛逼的小伙伴，真是令人期待！
点评链接大众点评校园招聘http://campus.dianping.com/#!/index
点评极客挑战赛http://evt.dianping.com/event/campus15/pc.html
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>极客大赛回顾</title>
    <url>/essay-geek-review/</url>
    <content><![CDATA[大众点评极客大赛，一段难忘的经历。接下来的一段时间，有了吹牛逼的材料。差一点拿到一等奖，虽有遗憾，但是二等奖的ipad air，依然令人惊喜。
比赛之后，郝同学坚定了考研的信念。学历，原来可以如此重要。


本次大赛，实际上是大众点评的一次招聘会。通过一天一夜的编程马拉松，挑选出他们看中的人才。网上海选的参赛者共有近两千，然后选出60个人在上海大众点评总部参加决赛，报销来回路费，还包吃住。全季酒店，提供自助早餐，真心好吃。
到了酒店，我才知道，来参赛的几乎全部是985、211的研究生。一阵无语，就当长长见识吧，看看人家有多强！
第一天上午，公司简介，就是说说大众点评的牛逼之处，吸引大家加入。第一天下午，组队，由队长上前演讲，招揽队友。一共12队，每队5个人。差点成为队长，最终耍赖赖掉了，好险。。。我们组最终成员为：张琪学长、许榕学长、熊环宇学长、李乾科和我，张琪学长为队长。第一天晚上，我们队在酒店热烈讨论了需求以及设计方案，每个人都很有激情。
第二天早上到第三天早上，24小时，编程比赛！大致分工是许榕学长和李乾科负责后端，熊环宇学长和我负责前端，张琪学长负责支援。预期是美好的，但实际进度总要慢很多，好在大家都很乐观，嘻嘻哈哈就过来了。晚上，有点评的开发人员来帮我们解决问题，真正见识到了一些大牛！
第三天上午，休息。第三天下午，作品展示。我们抽中了最后一组，lucky，于是，趁着其他组展示的时间修改代码，最终作品上升了一个档次！印象深刻的是，张琪学长女朋友的助攻，很强悍！张琪学长的演讲水平，也是杠杠的！第一，近在眼前！第三天晚上，颁奖。关于第一名和第二名的争论，评委团几乎吵了起来。最终，我们组拿到了第二，一个令人遗憾和惊喜并存的成绩。组内没有队员收到offer，因为三位学长还没有入职意向，因为我和乾科是本科生（应该是仅有的两个本科生）。
期间的细节不作展开，留一份朦胧的美好记忆。
最后，附上一些照片。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>大三下第13周周五</title>
    <url>/essay-grade-3-later-week-13-friday/</url>
    <content><![CDATA[马上就到考试周了，压力倍增。。。
一直在自学其他东西，结果，学校教授的课程都要预习；还有十几天考六级，但是没有复习，很难考过；下周四就到我讲Linux了，还没有准备好PPT；下周四考体育，健美操，想想就要醉了，完全不会；临近期末，好多报告要写，而且，本人写报告特别慢；说好的专心准备考研，结果一天推一天，事情层出不穷；身体欠安，咳嗽很给力，确诊为支气管炎，期待早点康复；感情问题没处理好，一直感到愧疚；第15周考三门课，时间貌似有些紧迫；好多技术要学，好多文章要写，成神之路不好走。。。。。。
男人，这就是生活，喜怒哀乐悲恐惊，一切都会过去，没什么大不了，用心感受这一切。男人，剧情不一定按照你的猜想发展，但正是因为不确定性，生命才更显精彩！男人，做好当下的事情就够了！做完一件，再做下一件。不骄不躁，一点一滴，积跬步以至千里。男人，不要悲观，不要抱怨，相信一切都会是最好的安排！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>健康</title>
    <url>/essay-health/</url>
    <content><![CDATA[
我每天祈祷，愿上帝让我早晨起来像婴儿一般地看这个世界。——柯罗

上课，读书，考研，学车，扯淡，打游戏，写博客，看视频，敲代码。。。满满的生活，总有事情做，沾沾自喜——这就是充实？
直到昨天，发现，扩胸的时候胸口会疼。最近没做啥缺德事啊？（好事倒是做了很多。）咋又遭报应了？且不去管它，观察两天再说。突如其来的疼痛，让我难过的同时，也促发了我对健康的思考。
虽然挑食，但是郝同学的体质还是不错的。正常情况下，每年秋季感冒一次，一两周之后痊愈，然后健康一整年。
2015，情况有变。首先是蛀牙，这是对于一个吃货最好的惩罚。很多东西不能吃，比如说麦丽素；很多东西不便吃，比如说各种肉类；很多东西不敢吃，比如说砖头（话说以前也不敢吃）。。。那段日子里，经常怀念大口吃肉大碗喝酒的日子！健康真好！
其次是发烧，某天发烧到38度3。校诊所的妹纸开了退烧药给我，并郑重告诫：要等到38度5再吃。等啊等，等啊等，啊勒，一直只有38度3！呵呵，你在逗我吗，一气之下就直接碎觉了。那时候，啥也不想做，只想躺着休息，休息也不爽，浑身疼。无眠中，感叹健康真好！

如今，再次生病，虽然不知道是什么病，但是我不喜欢它。试问苍天，健康何以换？
总是等到生病以后，才感觉到健康的可贵。暗下决心，病好了之后要每天刷牙三次，作息规律，饮食健康，留心身边的美女（不对，风景），每天俯卧撑、举腿、引体向上、深蹲、桥、倒立。。。病终于好了，那些决心也随之而散。直到下次生病，才继而开始新一轮的检讨和决心！这也是人性的弱点吗？失去了才懂得珍惜。

陈继儒《小窗幽记》中说：人常想病时，则尘心便减；人常想死时，则道念自生。

健康的平常时候，偶尔想想生病的痛苦，心底难免升起几分感恩。再看这个世界，是不是更美好了一点？
把每一次生病，当成一种恩赐，那是上帝在提醒：小伙子，放慢脚步，好好欣赏啊。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次面试</title>
    <url>/essay-interview-01/</url>
    <content><![CDATA[面试，也是学习的一部分。第一次面试结束，不管结果怎样，收获很多。
首先，手写代码！技术细节的东西，多少是要问到的，尤其是那些最基础的东西。所以，平时写写代码，保证记忆准确，是有必要的。


其次，深入思考！明白框架的原理，比使用框架更重要。面试中，不是看你用过什么框架，而是问你这些框架的原理。学习技术，多问几个为什么，肯定没错！
然后，时常复习！很多东西，学习过，总结过，但是忘记了，这和没学过又有什么差别呢？面试时，我只恨没有看一遍自己写的博客。博客，与其说是分享，不如说是写给自己的复习笔记。
最后，坚持学习！面试不通过，肯定还是自己的问题。不要气馁，不要放弃。面试不过，就去学习；再次不过，再去学习；还是不过，还去学习。。。我相信这是一个前进上升的过程！离毕业还有很长时间，还有机会！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>艾佳生活</title>
    <url>/essay-interview-05/</url>
    <content><![CDATA[第一次面试，认识到了自己的很多不足，尤其是前端基础，非常薄弱。一周多的时间，浸泡在慕课网，看视频敲代码。
明天就要回家，今天，再一次来到艾佳生活。面试通过，留下来工作；面试不过，回家继续学习，来年再来面试。


两轮技术面，大神前辈很nice，给了通过。HR姐姐看到我时，很惊奇的问我之前是不是来过，我点点头，第二次来。艾佳生活，无论是地理位置、工作环境，还是开发氛围、薪资待遇，都是我非常喜欢的。
艾佳生活，职业生涯的起点，努力成为海哥一样的大牛！吼吼！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>男人，新的开始</title>
    <url>/essay-kaoyan-end/</url>
    <content><![CDATA[2月14到12月27，10个多月的时间，在笔尖沙沙划过。最后一科结束，走出考场，天空灰暗，一如当时的心情，我没有哭，但是眼泪却流了下来。尘埃落定，彻底跪了。失落是难免的，但是，男人，生活还得继续，奋斗还得继续。找个工作，回家相亲，也是极好的。
每天8到12个小时的学习时间，却取得这样的结果，虽然不甘，但也没有什么好后悔的。一如初中所说，但求问心无愧。命运这么安排，只是想告诉某些人，你们不适合考研，你们的长处在其他地方。新的目标已经定下，成为一个偏前端的全栈工程师，男人，努力！
四个月前就打算写的文章，只来得及写好题目，为了全力考研，一直搁置，是时候补上了。大学四年，自学了很多技术，忘得七七八八。最近几天，拾起一二，准备面试，争取回家之前签好三方。


原以为，这一天，会有很多话想说，会有很多事想吐槽。可是，当考研真正结束，实际感觉是，还有很多事情要做，生活依旧充实。一条路不通，就去领略另一条路上的风景。16年，如期而至，男人，新的开始！
好好工作，好好健身，好好练琴，好好孝敬爸妈。。。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>原来这才是结局</title>
    <url>/essay-kaoyan-final-result/</url>
    <content><![CDATA[
生活就像盒子里的巧克力糖，你永远不知道下一颗会是什么味道。——阿甘

15年02月13日，决定考研，寻找资料，制定计划。
15年12月27日，考研失利，自知无望，找工作。
16年01月18日，入职艾佳，满意的工作，可爱的伙伴。
16年03月11日，兄弟告知，超过国家线16分，抓紧调剂。
16年03月18日，最终决定，参与调剂，填下了调剂志愿，写了封自荐信。


16年03月19日，收到通知，内大复试，爸妈反对，否。
16年03月25日，收到通知，东北师大复试，决心前往。
16年03月30日，飞往长春，陌生的天空，熟悉亲切的东北味，依稀记起某一年赵本山的小品。灰色的主色调，仿佛再次回到冬天。没有下雪，也很温暖，但是脑海忍不住浮现一句话：南国花开，北国雪飘。误打误撞，走了最实惠最舒适的路线，连高德都不知道，lucky！
16年03月31日，专业笔试，发挥一般，很久没碰C++，忘记太多。
16年04月01日，英语面试，专业面试，只记得当时很紧张，英语自我介绍停顿一次，翻译完跪，三个专业问题答出来两个。浑浑噩噩回到宾馆，不停回想面试的细节，最终甩甩脑袋，多想无用，静待结果吧。。。一个小时后，收到待录取通知，点击“接受”的瞬间，对世界充满感激。
16年04月04日，回想考研，一路波折，写点什么吧，仅此纪念一年多的考研历程。
三年研究生，比预想多一年。三年，成长为理想中的自己！
最后，感谢江淮，一个比我自己还关心我的调剂的好兄弟！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>考研资料</title>
    <url>/essay-kaoyan-material/</url>
    <content><![CDATA[前言考研资料浩如烟海，找到适合自己的资料，学习起来必定事半功倍。为了搜集信息、寻找资料，郝同学昨晚居然失眠了，凌晨四点左右还没有入睡。看到各位前辈的考研经验，心中升起了万丈豪情——哥也可以！！！

考试科目①101 思想政治理论②204 英语二③302 数学二④842 数据结构、软件工程、操作系统和计算机网络
复试科目:3203 复试：笔试：数据库、上机：Java程序设计上机；面试：专业综合、英语口语

参考书目初试参考书目：《数据结构与算法分析：Java语言描述》（英文版），第2版，机械工业出版社；《软件工程与计算：软件开发的技术基础》，骆斌主编、丁二玉、刘钦编著，机械工业出版社；《操作系统教程》（第五版），费翔林、骆斌编著，高等教育出版社；《思科网络技术学院教程CCNA（1、2，3学期）》，人民邮电出版社。
复试参考书目：《数据库：原理编程与性能》（影印版）（第2版）奥尼尔著，高等教育出版社；《软件工程与计算：软件开发的编程基础》，骆斌主编、邵栋、任桐炜编著，机械工业出版社。


政治教科书：无
辅导书：《全国硕士研究生入学统一考试:思想政治理论考试大纲解析》《肖秀荣考研政治命题人讲真题》，北京航空航天大学出版社.《肖秀荣考研政治1000题》，北京航空航天大学出版社.《肖秀荣考研政治知识点精讲精练》，北京航空航天大学出版社.《肖秀荣考研政治命题人冲刺8套卷》，北京航空航天大学出版社.《肖秀荣考研政治命题人终极预测4套卷》，北京航空航天大学出版社.《风中劲草核心考点考题》

英语二教科书：无.
辅导书：《考研英语词汇 乱序版》，俞敏洪，北京语言大学出版社.《新编考研英语阅读理解150篇》，张健，世纪高教编辑部,世界图书出版社.《历年考研英语真题解析及复习思路》，张健，世纪高教编辑部,世界图书出版社.

数学二教科书：《高等数学 第六版》上下，同济大学数学系，高等教育出版社.《工程数学 线性代数 第五版》，同济大学数学系，高等教育出版社.《概率论与数理统计 第四版》，浙江大学，高等教育出版社.
辅导书：《李永乐考研数学复习全书》，国家行政学院出版社.《李永乐数学基础过关660题》，国家行政学院出版社.《李永乐数学历年真题权威解析》，国家行政学院出版社.《张宇高等数学18讲》，北京理工大学出版社.《张宇线性代数9讲》，北京理工大学出版社.《张宇概率论与数理统计9讲》，北京理工大学出版社.《张宇考研数学题源探析经典1000题》，北京理工大学出版社.《张宇考研数学命题人终极预测8套卷》，北京理工大学出版社.《张宇考研数学命题人最后4套卷》，北京理工大学出版社.

专业课教科书：《数据结构与算法分析：Java语言描述》（英文版），第2版，机械工业出版社；《软件工程与计算：软件开发的技术基础》，骆斌主编、丁二玉、刘钦编著，机械工业出版社；《操作系统教程》（第五版），费翔林、骆斌编著，高等教育出版社；《思科网络技术学院教程CCNA（1、2，3学期）》，人民邮电出版社。
辅导书：《王道操作系统》《王道论坛真题精析》
历年真题试题范围：南大所有专业近4-11年的考研（博）原版真题试卷（已有11年博士和硕士试卷），相关笔记，讲义和教材
购买地点：南大鼓楼校区逸夫管理科学楼十楼图书馆复印室
南大考研（博）试卷资料复印时间（除下面规定时间外其它时间不提供）：每周一至周六（周三除外）下午2：30—3：30；周日全天上午8：30—下午4：00（节假日不休），其他时间需要试卷可以电话联系，外地办理邮购服务。
联系电话： 13813989681（建议短信联系）  南大陈老师

小结以上的考研资料不限于数学二、英语二，其他科目同样可以参考。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>考研计划表</title>
    <url>/essay-kaoyan-plan-1/</url>
    <content><![CDATA[前言2016年考研时间为：12月26日和12月27日，距离今天还有312天。
312天，分成了几个阶段。每个阶段，以周为单位轮回。每周，周一到周六，学习日；周日，休息日。学习日，早上7点起床，整天学习一门课，直到晚上8点；休息日，学习与否随意。每天晚上，8点开始背单词，半小时到一小时；之后学习与否随意；10点半到11点关机上床。

2月17~3月1


政
英
数
专



0
6
0
0





周日
周一
周二
周三
周四
周五
周六



休
英
英
英
英
英
英











——








### 3月2~6月20








政
英
数
专





:—-:
:—-:
:—-:
:—-:





0
3
2
1








周日
周一
周二
周三
周四
周五
周六



休
英
数
英
数
英
专



6月21~8月30


政
英
数
专



1
1
2
2





周日
周一
周二
周三
周四
周五
周六



休
政
英
数
专
数
专



8月31~10月30


政
英
数
专



2
1
1
2





周日
周一
周二
周三
周四
周五
周六



休
政
专
政
专
英
数



11月1~12月20


政
英
数
专
弱



1
1
1
1
2





周日
周一
周二
周三
周四
周五
周六



休
政
英
数
专
弱
弱



12月21~12月26考前调整，自由复习。

后记备考过程中，2016年6月20日，六级考试，顺路考过！计划不是限制，执行过程中根据情况调整，效率至上。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>考研计划表（第二版）</title>
    <url>/essay-kaoyan-plan-2/</url>
    <content><![CDATA[前言寒假里，没怎么学习，计划形同于无；开学之后，一直到4月中旬，大部分时间都在学车；之后，休息娱乐，作业实验，生病挂水，转眼到了5月。是时候全力准备考研了，根据现在的生活学习状态，更新一下考研计划表。
2016年考研时间为：12月26日和12月27日，距离今天还有237天。
237天，分成了几个阶段。每个阶段，以周为单位轮回。每周，周日到周五，学习日；周六，休息日。学习日，7:00起床，整天学习一门课，直到18:00；18:00到20:30，写日记和学习专业课；20:30开始健身，一小时左右；之后是自由时间；22:30到23:00关机上床。休息日，自由时间。


规定休息时间：无论什么时候，睡觉都是头等大事，可以抢占其他计划的时间。
学习时间：周日到周五的7:00到21:30。使用手机只可以背单词，使用平板只可以阅读专业书籍，使用电脑只可以写代码写博客。（PS：学习时间包括上课时间）
上课时间：背单词、阅读专业书籍、写代码写博客、听课、复习考研，视心情而定。
自由时间：周日到周五的21:30到22:30，周六全天。洗漱、洗澡、洗衣服、打电话、阅读纸质书籍、听歌、飞车、睡觉，视心情而定。

5月3~6月20


政
英
数



0
3
3





周日
周一
周二
周三
周四
周五
周六



数
英
数
英
数
英
休



6月21~8月30


政
英
数



1
2
3





周日
周一
周二
周三
周四
周五
周六



数
英
数
英
数
政
休



8月31~10月30


政
英
数



2
2
2





周日
周一
周二
周三
周四
周五
周六



数
英
数
英
政
政
休



11月1~12月20


政
英
数
弱



1
1
1
3





周日
周一
周二
周三
周四
周五
周六



数
英
政
弱
弱
弱
休



12月21~12月26考前调整，自由复习。

后记备考过程中，2016年6月20日，六级考试，顺路考过！计划不是限制，执行过程中根据情况调整，效率至上。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>考研计划表（第三版）</title>
    <url>/essay-kaoyan-plan-3/</url>
    <content><![CDATA[暑假开始了，再没有任何借口不去专心备考。
小伙伴们的进度都好快，某某考研单词背了三遍，阅读做了50篇；某某同济高数习题过了两遍，真题做完六套；某某感觉英语、数学、专业课都差不多了，正在背政治考点。。。谁都比不过，哥哥还是按照自己的节奏来吧！
离考研还有170天，这次的计划表，适用于暑假。



以周为单位轮回。


一、三、五、七，数学；二、四、六，英语。


7点半，早饭；11点半，午饭；17点半，健身；23点，休息。


一天的学习时间，8个小时左右，空闲时间自由安排。

数学：1、同济高数概念例题过一遍。2、真题真题做一遍，同时复习同济高数知识点，弱项挑几个课后习题做做。
英语：1、真题阅读理解研读30遍，同时背下阅读理解中的单词。2、背完20篇大小作文模板。
经测试，本计划可行，贵在坚持！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>考研</title>
    <url>/essay-kaoyan/</url>
    <content><![CDATA[引子从开始上大学，到昨天，一直不想考研。也许动过考研的念头，然后一瞬间就消失。然而，昨天小伙伴们查成绩，加上今天的思考，考研这个想法，在郝同学的心里生根发芽了。
不想考研理由一：郝同学觉得，自己的年龄比同届小伙伴高两三岁，太老了。理由二：对郝同学而言，考研，不过收获一个学历，获得了一个进大企业的机会。但是，郝同学崇尚自由，不愿意看老板脸色。不管是进大企业还是小企业，郝同学都不会一直待下去，只是在那里学习。那么，获得一个进大企业的机会，也就不是那么重要。理由三：除了计算机，郝同学还可能从事餐饮业、住宿业、娱乐业、零售业等等。如果互联网公司搞不起来，那么就开很多店，“随便吃”，“随便喝”，“随便穿”，“随便拿”，“随便住”。。。想想都激动。。。
想考研理由一：一个关系特别好的小伙伴，目测毕业年薪50万，羡慕嫉妒恨！更多的同学，高薪的高薪，名校的名校，出国的出国，咱也不能落后！理由二：读研的同时，也可以创业。理由三：高考丢人了，要找回场子！而且，考上的把握非常大！理由四：万一失败，还省了学费。

分析一天，收集各种考研信息，分析整理。郝同学得出了一个结论：我能考上！对，就是这个学校，就是这个专业！努力备考一年，我有百分之九十的把握可以考上！
决定优柔寡断与我无缘，此刻，已经做出了决定——考研！2015年3月2日开始备考！南京大学软件学院085212软件工程，南大MSE！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>劳尘如兔</title>
    <url>/essay-laochenrutu/</url>
    <content><![CDATA[不要百度，请回答：“劳尘如兔”这个成语是褒义还是贬义？具体是什么意思？
不好意思，实际上不存在劳尘如兔这个成语，这是郝同学在梦里梦到的。依稀记得，我用“劳尘如兔”来形容一位同学，结果这位同学非说这个词是个贬义词。当时我就不乐意了，居然敢欺负我没有文化。于是，我们展开了百度。。。之后，之后我就醒了！发现没有这个词。。。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>LOL</title>
    <url>/essay-lol/</url>
    <content><![CDATA[前言英雄联盟，原版名称League of Legends，又称LOL、撸啊撸。由Riot Games开发，腾讯游戏发行。国服发行时间：2011年9月22日美服发行时间：2009年4月10日
LOL火了一直对游戏的关心不够，意识到LOL火了的时候，是在大一下（2013年上半年）。火了又怎样？以前的CF、dota不也很火！没想到的是，两年后的今天，LOL更火了！甚至，“火”这个词，都无法形容它的范围之广，影响之大！它俨然成了一个全民游戏，不会LOL，和小伙伴们简直就没有了共同语言！当他们满嘴专业名词，上单、白银、钻石、EZ、S3、红BUFF、ADC、SOLO等等，侃的唾液横飞的的时候，不等他们问：“你听得懂吗？”郝同学就会提前告知：“我丫外星人！”因为我知道，如果我回答：“听不懂！”他们接下来肯定问：“你丫外星人吧？”
都在玩小学同学、初中同学、高中同学、大学同学，当中的男生，80%都在玩LOL！当中的女生，10%在玩LOL！甚至，现在的小学生，也在玩！醉了醉了，这个世界太疯狂。
新年新技能羊年第一天，和小伙伴们去网吧开黑，入门了一个新技能——LOL。主要是为了和小伙伴们同步，这也算是盲目跟风了吧！
此前也尝试过玩LOL，但是没有玩下去。果然，这个游戏还是群体玩好玩。

队友第一天玩，打出了0死6杀4助攻的好成绩，也打出了14死0杀0助攻的坏成绩。至于队友，实力强劲的有，刚刚入门的有，语言文明的有，满口脏话的有。。。林子大了什么鸟都有，看来这也是一个考验心态的游戏！
结束语从今往后，哥也是会打LOL的人了！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>游戏</tag>
      </tags>
  </entry>
  <entry>
    <title>禅定的境界</title>
    <url>/essay-meditation-realm/</url>
    <content><![CDATA[禅定的境界可分为六种，即空定、气定、火定、光定、法身定和大涅槃定。
(1) 空定禅定的最初境界为空定，没有空定进入不了气定、火定的境界，更不能进入光定、法身定和大涅槃定的高深境界。空定既是基础，也是进入一切禅定境界之门，为不同禅定境界所依。
空定也可以说是一种清静定，感到很宁静。 通过调息的练习，慢慢从五彩缤纷的杂念中解脱，而进入一的境界，然后再把一也慢慢松开，使其消失而入空定的境界。
(2) 气定气定也可称为融融乐乐定。气定与单纯的空定不一样，它在空定的基础上修练内气，当内气充足时，气会沿着经脉走，并充满全身上下，身体有微胀的感觉，有轻松的感觉，有暖流流动的感觉，有如痴如醉的感觉等。
在气定中，你的感觉是身体与大自然合一，内气也像与大气化为一体，融融乐乐，舒舒服服，生气勃勃，神气相抱，人们喜欢把此感觉称为天人合一。 而单纯的空定就只有感到寂静，感觉有如死灰枯木，缺少了一点生气。

(3) 火定
火定可以称为大乐定。 其大乐的感觉不是气定可比的，火定可以烧尽烦恼，火至顶轮有如长夜消去，烦恼尽除，生命重生。
火定是继气定之后之定，没有充足的内气，就不可能有火产生。 火从丹田产生，引其火沿中脉直上至顶轮，然后折回至海底轮，然后又上升至顶轮，如此来回三数次，必能印证四喜四空之大乐境界，烦恼尽除。 进一步，在此境界中，观空中脉，然后入于甚深之三摩地火定中，定中会现不可思议境界，但切莫执着。 此即为拙火定，也称为拙火瑜伽，属密教无上瑜伽部的一个极其重要的大法。
火的另一个行走的路线是沿督脉而行，至顶轮而把千叶莲花激活，一样的烦恼尽除，大乐境界虽不及行走中脉者，但它却是成就实相法身至为关健的修链路线。
(4) 光定
光定可以说是坚固定，是继火定之后的一个定。 火产生大乐，而光却产生坚固感。 入于光定，除了有极轻微的电麻的感觉外，全身的感觉有如盘石般坚固，法乐与火定不一样，是更深一层的修链。
火定主要是拙火，即元阳的运作。 而光则必须靠拙火与菩提心月液，也即元阳与元阴的充分交媾才能产生。金丹的修链过程，就是由光的产生向著成就实相法身转化的过程。 在链光过程中，实相法身未成，而又随机入于禅定者，即为光定。
(5) 法身定
实相法身修成后，于禅定中，法身即现于虚空中，成真空妙有，法身不断放光惠泽三界众生，无为而为，如大日之光辉。
『法身定』与『光定』的最大不同处在于法身本身像太阳一样会源源不绝地产生光明，其法身之光会无碍地穿越一切有情及无情之物，超越一切时空，遍及三界六道，三千大千世界，及遍虚空界，所谓百千万亿化身也只是一个比喻，而实际上它是遍一切处，无处不在，而太阳光辉之德虽然伟大，但也只能及于事物的表面，与法身之德不能相提并论。所以，法身定也称作无为而为定，普渡众生，展现无为大爱，一切无为却有所作为。
(6) 大涅槃定
大涅槃定也称为空空定，无无定，为第一义空之定。 中道实相亦化空，实相法身隐去，即入此定。
入于此定，六大皆化空，而入于虚空未生前的最原始之源头，一切无为也无所作为。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>QQ飞车</title>
    <url>/essay-qqspeed/</url>
    <content><![CDATA[前言QQ飞车，琳琅天上开发，腾讯游戏在2008年1月23号发行。
悲剧的开场还记得那是初三的一个周末，一群小伙伴聚集在江淮家，玩飞车！当时，飞车刚推出没多久，大家都是从初级驾照开场！一台电脑，大家轮流考一遍初级驾照，这时悲剧出现了。。。七八个人，大都是一遍考过，比较笨的家伙，需要考两次。轮到哥了，具体多少次记不清了，肯定不到30次。。。下巴惊掉了一地。。。见过笨的，没见过这么笨的。。。
飞车生日2008年6月24日，飞车生日，当时，初三。成为飞车党，一晃近七年。期间出现了各种游戏，也试玩过很多游戏，但是，飞车一直无可替代。


七年开始的时候，玩的小伙伴比较多。三年后，还剩了三个，我、大孝和PP。其他的小伙伴，专注魔兽、dota、星际、CF等等。
PP真是个人才，进入大学后，技术怎一个牛逼了得。常州市比赛，实力能进前三，最后得了第八，耿耿于怀。个别的图，能跑进全国前十，吊炸天简直！至于我，普普通通，偶尔玩玩。
又过了一年，哥终于也进了大学。这时候，玩飞车的小伙伴还剩两个，我和大孝。
大学的三年，有时会放纵，玩什么游戏？飞车！因为，感觉其他游戏都没有飞车好玩！也钻研过飞车的技术，但是到达一定水平后，再也没有提升。有时虐虐菜，有时被高手虐，水平普通，游戏低调。
现在大学之前，很少有玩游戏的时间，也就没有什么好的装备。大学之后，经过一段时间的努力，什么都有了。假期里，经常挂号。得经验值，升级；得点券，买装备；得赠送绝版，拉风。。。现在，126级的雷霆骑士，一身装备，称不上奢侈，也算得上豪华吧！
现在，飞车仍然是我生活的一部分。腐败的时候，跑两局；忙碌的日子，几个月不碰。游戏，放松身心的工具，就和小说、动漫、电影、电视剧一样。
2016.08.06更新
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>三年，剩下了什么</title>
    <url>/essay-three-years/</url>
    <content><![CDATA[前言2012年9月进入南工程，一晃三年。当初用了很多时间学完的教程，当初用了很多时间读完的书籍，当初用了很多时间写出的代码。。。学过了，实践了，但是忘记了，剩下了什么？
C大一上，学习C，廖雷老师主讲。上课听讲，课后看小甲鱼的视频，写demo。为什么没有多学点东西？因为那时的郝同学穿梭于学生会和各种社团。
汇编为了更好的理解计算机，辅助C语言的学习，同时为破解打基础。大一寒假，学习汇编。学完了王爽的《汇编语言》，一边看书，一边看小甲鱼的视频。同时，读完了《编程高手箴言》、《疯狂的程序员》。安装试用了各种系统，winXP、win7、win8、Mac OS X 10.8、各种Linux。
C++大一下，学习C++，廖雷老师主讲。上课听讲，课后本打算看完孙鑫的C++视频，不曾想艰涩难懂，遂放弃。写demo，同时强化C，做完了C语言经典例题100。学习PS，入门级。

黑客还没上大学，就对黑客心存向往。在互联网的世界里，叱咤风云，打遍天下无敌手。大学三年里，偶尔会看看关于黑客攻防方面的书籍，但是，一直没能登堂入室。
Oracle大一暑假，留校，准备服务外包大赛。从韩顺平的视频入门，敲命令，写demo，学完了Oracle。大三下，开设了Oracle，程初老师主讲，刚好可以复习一下。
服务器大一暑假，开始接触服务器，最先学会使用的是tomcat。在公司做项目时，学会了使用jetty、SVN、Maven；再后来，学会了使用Node.js；再后来，学会了使用Openfire；再后来。。。虽然它们的类型不同，但是都叫服务器，这里郝同学就不去划分了。
JavaSE同样是大一暑假，从韩顺平的视频入门，跟着敲代码，写demo，学完JavaSE。大二上，开设Java课程，叶核亚老师主讲，再次学习一遍。Java博大精深，至今仍感觉懂得的只是冰山一角。
安卓从大一暑假，就萌生了学习安卓的年头，结果，两年过去了，一直没有付诸行动。拖拖学学拖拖，至今也就会搭建个环境，写个“Hello World！”。2015年，一定要成为安卓高手！
Linux大二上，Java课上，以及课后的大部分时间，都在学习Linux。看完了韩顺平的Linux教程，读完了《鸟哥的Linux私房菜》、《自己动手写操作系统》、《手把手教你构建自己的Linux操作系统》等，在虚拟机、实体机中实践。试玩了各种Linux，比如Ubuntu、CentOS、RedHat、Fedora、StarOS、红旗、Geetoo等等，个人喜欢Ubuntu、CentOS和Fedora。遇到过各种奇葩问题，连百度都不知道。有些经过思考创新，最终大功告成；有些各种尝试无果，至今悬而未决。大三下，开设了Linux，丁宋涛老师主讲，非常幽默。
数据结构大二上，学习数据结构，C++语言描述，徐金宝老师主讲，真心不错。
个人网站2013年11月3日，注册了第一个域名，在OpenShift上使用WordPress完成第一个个人网站。之后一发而不可收。
PHP大二上，为了改写WordPress模板，简单学习了PHP。大二暑假，为了开发微信公众平台，系统学习了PHP。不够牛13，但是用来装13足够了。
Mysql大二上，为了本地测试WordPress，开始接触Mysql。后来，写demo，帮助叶核亚老师完善精品课程网站，开发复合人才网，使用云擎建立应用，完成课表查询功能，搭建微擎等等，都用到了Mysql。
jsp大二下，学习jsp，夏官梦老师主讲。做实验，写demo，不够出色。
asp大二下，帮助学校的水电中心完善了网站。这个网站，是用asp写的，没看懂多少，不过最终还是帮他们改好了。
JavaEE大二上，加入了南京天诚逍逸网络科技有限公司，认识了大牛郭小成。开始学习Java的高级技术，集合、泛型、反射、持久化、单元测试等等。大二寒假，继续深造Java。大二下，和队友们合作，不求甚解，使用Maven、SVN、SSH、JPA、Mysql、AngularJs等完成了复合人才网。
设计模式大二寒假和大二下，系统学习了23种设计模式，读完了《大话设计模式》、《易学设计模式》，画了很多UML图。
数据库大二下，开设数据库，使用SqlServer，程初老师主讲。
微信公众平台大二暑假，开始学习微信公众平台的开发。少眠少休，废寝忘食，两周左右的时间，做出了一个比较牛逼的公众平台——iNJIT。为了其中一个技术，花费200元向别人请教，执着如此，我也是服了我了。维护了几个月，感觉麻烦，就放弃了更新。
CloudStack大二暑假，郭小成出了另一本书《Hadoop大数据挖掘最佳实践》（第一本是《HTML5+CSS3技术应用完美解析》）。我们在办公室里的两台机器上，努力搭出一个CloudStack环境。最终失败了，但是增长了见识。
Node.js大三上，公司给出任务——做一个团队博客系统。当时，身为组长的郝同学，选择使用Node.js，而不是JavaEE。这样，做项目的过程中，可以学到更多的新东西。不到一个月，读完了BYVoid的《node.js开发指南》，完成了团队博客系统。顺路学习了一下Mongodb，增删查改。也学会了Bootstrap的使用，非常喜欢。
XMPP大三上，公司给的任务，学习XMPP，使用XMPP开发即时通讯软件。浅尝辄止，不过收获很多。
HTML等学习jsp、asp、PHP、JavaEE的时候，顺便学习了一些前端的知识。大三上，系统学习HTML+CSS+JavaScript+JQuery，主要为了更好地学习XMPP。因为《XMPP高级编程》中的例子，是用JavaScript写的。
.net大三上，开设C++.net，杜青老师主讲。学艺不精，用到的时候再补课。
网络为了学习黑客技术，曾经钻研过计算机网络，略有小成。大三上，开设计算机网络，汪峥老师主讲。
嵌入式系统大三下，开设嵌入式系统，韩磊老师主讲。
软件测试大三下，开设软件测试，陈科燕老师主讲。
编译原理大三下，开设编译原理，肖旻老师主讲。
后记学而不精，习而复忘。但当涉猎，见大势耳。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>成为一个有思想的人</title>
    <url>/essay-to-be-a-man-with-thought/</url>
    <content><![CDATA[前言
不把信息当作知识，不把收藏当作学习，不把阅读当作思考，不把储存当作掌握。不提炼总结、不应用学习、不深入思考、不实践反馈，就不会变成自己的能力。

什么是有思想的人？对一件事，有自己的观点，有自己的见解，有理有据，令人信服。
近朱者赤近墨者黑，和这样的人在一起，能够感受到TA的气场，能够感受到TA的能量，能够感受到收获和成长。


如何做那么，怎样成为一个有思想的人？
1、提问为什么？为什么不？有什么用？怎样去做？作者想表达什么样的观点？这个新闻想让我们相信什么？这个微博传达了朋友什么样的情绪？
2、批判知道自己的观点，理解文字（信息）中的观点。支持或反对，有理有据。相信或不信，找出原因。
3、想象想象和别人聊天，想象演讲，想象辩论。
后记会思考的人不会无聊！保持好奇心，多问多想多读书。也许终其一生也无法成为有思想的人，但至少，要比昨天的自己更好一些。
书签四种思维方式http://www.xuexila.com/naoli/siwei/50198.html
牛人和普通人的区别在于思维方式！http://www.zreading.cn/archives/4724.html
如何成为有想法的人？如何培养独立思考的能力？http://www.zhihu.com/question/20114502
新闻联播该如何看？
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>成为一个优秀的人</title>
    <url>/essay-to-be-an-excellent-man/</url>
    <content><![CDATA[
只有自己变优秀了，其他事情才会跟着好起来。

看到这句话，想到了五年前，高三的时候。一位哈佛博士后，来到沛县中学演讲，他说：只有到了那个层次，才会有相应的圈子，而不是反过来；只有成为梧桐，凤凰才会来栖，否则凤凰早晚会离开。人们总是喜欢围绕着优秀的人，因为优秀的人充满正能量，能够给他人带来知识、温暖、快乐。


随着阅历的增长，我们会遇到更多优秀的人。他们是各自行业的精英，是我们只能仰视的人物。但是，再优秀的人，也是一点一点成长起来的。没有人能随随便便成功，但是，成功又是一种自然而然的事情。当一件事做到极致，当能力发生质变，自然能够获得相应的身份、地位、金钱。
工作生活中，每个人都会成长，但是成长的方向和速度是不同的。想清楚，自己想要成为什么样的人，自己想要过怎样的生活，是最重要的事。明确了这些，也就知道了该把生命的焦点放在哪里。
有了目标，想想该去做哪些事，该培养哪些能力，该戒掉哪些习惯。。。Just do it ！如今，已不是少年。男人，不要退缩；男人，不要拖拉；男人，不要借口。30岁的时候，回头看看现在的自己，充满感激。
无所畏惧，一点一滴，成长为满意的自己。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>VoidKing</title>
    <url>/essay-voidking/</url>
    <content><![CDATA[十年初一开始上网，不觉间，已经在网络世界游荡了十年，一如最初的默默无闻。账号、网名、昵称、签名、头像、邮箱、密码……换了又换。就连用来拉风的域名，也经历了四次变革。
imsnail.com取义：世界上只有两种动物可以登上金字塔，一种是雄鹰，一种是蜗牛。没有雄鹰的天赋，我愿做那只努力的蜗牛。
imdust.com取义：我本微尘，却也心向天空！
ihelloworld.net取义：每只猴子都是从“helloworld”起家的，“i”代表个性、我的，我的编程世界。（没有注册到.com域名还挺遗憾）
voidking.com取义：有个牛逼的前辈，叫做BYVoid（郭家宝），写的《node.js开发指南》非常精彩。“Void”是我最喜欢词汇之一，“King”是我的英文名（译为：金，京）。
网络名片论坛、博客、游戏等等，都要昵称，但是，经常遇到，“该昵称已被注册”！就连“路过天空”这种奇葩网名，居然都有很多人用！为了够拉风，最好构思一个响亮的名字，于是，“Void”+“King”应运而生！
是时候，去写一张名片了！“VoidKing”，我的名片！以BYVoid为偶像，努力！把这个百度不知道的名字，做到百度知道！
VoidKing博客地址从今以后就定为voidking.com，网名、昵称、代号都是VoidKing！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>男人，再努力一点！</title>
    <url>/essay-work-harder/</url>
    <content><![CDATA[最近两周的表现，让人不满意！说好每天至少8个小时的考研复习，实际只有4个小时左右；说好的每天健身，隔三差五还要偷懒一次；说好的学习Android，确实很用心，但也不能把重心放到这上面哇！
男人，再努力一点！凭现在的状态，能考进南大吗？放弃了实习、工作、恋爱，为了什么？不是为了看电影，不是为了看小说，不是为了睡懒觉。。。而是为了考研，为了南大，为了四年前的梦想！！！


考研计划表要再次修正了，第三版的改进版如下：

以周为单位轮回。


一、三、五、七，数学；二、四、六，英语。


7点半，早饭；11点半，午饭；17点半，健身；21点半，回宿舍；23点，休息。


每天考研复习时间，10个小时左右，空闲时间自由安排。

男人，你是一个努力的人，你是一个认真的人，你是一个自律的人，你是一个优秀的人！这样的你，才有资格拥有南大的入学通知书！没有人能随随便便成功，有些苦必须要吃，有些路必须要走！
吾将心无旁骛，日积跬步，严于律己，十分努力，以求二分运气八分才气！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>考研</tag>
      </tags>
  </entry>
  <entry>
    <title>关于写论文的思考</title>
    <url>/essay-write-paper/</url>
    <content><![CDATA[前言原来，专硕是不需要发论文的。但是，如果发一篇SCI，就可以拿到国家奖学金，很有吸引力！毕竟，研究生期间，没啥收入，两万块是个很大的数目。
老师们讲了很多关于写论文的内容，做下记录，也许能用到。


思路1、问题2、原因3、解决方案4、抽象5、应用
海尔迈耶系列问题你要做什么？不要用术语，清晰的表达你的目标。这件事现在是怎么做的？现在的做法有什么局限？谁在关心？你的方法有哪些创新？你为什么觉得你的方法能够成功？如果你的方法能够成功，它能带来怎样的变化？你的方法需要花多少钱？需要花费多少资源？要怎样在过程中和结束进行评估？
自查问题我要做什么？解决什么问题？别人是怎样解决的？我的方法好在哪里？
为什么没人做？在哪个方面有用？用在哪里？已有方法可以达到什么效果？我的方法可以有哪些提升？
值不值得做？能不能做？市场预期是怎样的？依据的标准、理论、方法、政策是什么？
产生这个问题原因是什么？别人为什么没有解决？我为什么能解决？我的方法局限性在哪里？后续怎样改进？
标题明确标题中应该包含：技术点，研究点/核心（算法），结果（可行性分析报告，研究报告，系统）
综述性论文为什么需要软件体系结构？软件体系结构是什么？软件体系结构要研究什么？当前的问题有哪些？总结和展望。
Tips不一定非要做出来，发挥想象。评述参考文献。内容不要太多，突出自己研究的内容。不是具体工作，要抽取出做的东西。重要的是解决问题的 过程、 思路。有困难，不清晰，别人解决不了，所以才立项。从学习知识到创造知识。从会议、沙龙等寻找切入点。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>般若波罗蜜多心经</title>
    <url>/essay-xj/</url>
    <content><![CDATA[观自在菩萨，行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。
舍利子，色不异空，空不异色，色即是空，空即是色，受想行识，亦复如是。
舍利子，是诸法空相，不生不灭，不垢不净，不增不减。是故空中无色，无受想行识，无眼耳鼻舌身意，无色声香味触法，无眼界，乃至无意识界。无无明，亦无无明尽，乃至无老死，亦无老死尽。无苦集灭道，无智亦无得。
以无所得故，菩提萨埵，依般若波罗蜜多故，心无挂碍，无挂碍故，无有恐怖，远离颠倒梦想，究竟涅槃。
三世诸佛，依般若波罗蜜多故，得阿耨多罗三藐三菩提。
故知般若波罗蜜多，是大神咒，是大明咒，是无上咒，是无等等咒，能除一切苦，真实不虚。故说般若波罗蜜多咒，即说咒曰：揭谛揭谛，波罗揭谛，波罗僧揭谛，菩提萨婆诃。
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>大学生十八条受益一生的定律</title>
    <url>/hobby-18-law/</url>
    <content><![CDATA[　　1、一定要有独立的人格、独立的思想。一个经过独立思考而坚持错误观点的人比一个不假思索而接受正确观点的人更值得肯定。不要成为灌输教育的牺牲品。　　2、仕途，商界，学术。大致说来，每个人都注定要走上三条道路中的某一条。在进行职业生涯规划的时候，不妨以此作为思考的出发点。根据不同的职业生涯规划来塑造各自的核心竞争力。只有知道自己以后要做什么，才能知道自己应该学什么。　　3、专业无冷热，学校无高低。没有哪个用人单位会认为你代表了你的学校或者你的专业。千万不要因为你是名牌大学或者热门专业而沾沾自喜，也大可不必因为你的学校不好或者专业冷门而自卑。
　

4、千招会，不如一招熟。十个百分之十并不是百分之百，而是零。如果你有十项工作每项都会做百分之十，那么，在用人单位眼中，你什么都不会。所以，你必须要让自己具备核心竞争力。“通才”只有在“专才”的基础上才有意义。　　5、不逃课的学生不是好学生。什么课都不逃，跟什么课都逃掉没什么两样。一定要掌握学习的主动性，不要像读中学一样被老师牵着鼻子走。逃课没有错，但是不要逃错课。同时，既要逃课，又要让老师给高分。　　6、一定要学会理财。对于贫困生来说，首先要做的不是挣钱，而是省钱。很多大学生读书的时候一掷千金，可是，毕业以后一个月的工资还不够交半个月的房租。　　7、掌握必要的计算机操作能力。大部分女生将电脑当成了影碟机，大部分男生将电脑当成了游戏机。大学生要掌握必要的计算机操作能力，但是，很多时候电脑会成为浪费时间的堂而皇之的借口。有电脑的大学生非常多，可是，这中间很多人可能大学毕业的时候还不会Excel，不会做一个像样的PPT。　　8、做事不如做人，人脉决定成败。一个人有多少钱并不是指他拥有多少钱的所有权，而是指他拥有多少钱的使用权。一个人具备多少能力，不只是说他一个人的时候能做什么，还包括他能通过别人做什么。一个人赚的钱，12、5%是靠自身的知识，87、5%则来自人脉关系。三十岁以前靠专业赚钱，三十岁以后拿人脉赚钱。所以，请好好珍惜大学期间建立起来的人脉关系。这几年你认识的朋友可能会是你毕业以后最可宝贵的财富。　　9、互联网固然威力无穷，但是，如果你沉迷于网络聊天，或者沉迷于网络游戏，浪费的金钱倒是可以弥补，荒废的青春就无可追寻了。轻舞飞扬已经红颜薄命了，而痞子蔡却继续跟别的女孩发生着一次又一次的亲密接触。对于很多大学生而言，网吧就是一个血淋淋的黑洞。　　10、爱情是不期而至的，可以期待，但不可以制造。花开堪折方须折，莫让鲜花败残枝。一个有一万块钱的人为你花掉一百元，你只占了他的百分之一；而一个只有十块钱的人为你花掉十块，你就成了他的全部。　　11、不要以为考研究生就是积极进取的表现。研究生扩招的速度是30%，也就意味着硕士学历贬值的速度是30%。对于很多人而言，考研不过是一种消极逃避的方式罢了。对于绝大多数人而言，读研究生纯粹是浪费时间浪费金钱，立志从事科研、学术的人及其他少数人除外。　　12、不要一门心思想着出国，更加不要迷信外国的月亮比中国圆。削尖脑袋记GRE词汇很可能是一件非常愚蠢也非常可悲的事情。既然全世界的公司都想到中国的市场上来瓜分蛋糕，为什么中国人还要一门心思到国外去留学然后给外国人打工？　　13、人才市场就是一个地雷阵。通过多种方式求职固然没有错，但是千万不要饥不择食。只要用人单位一说要你交钱，你掉头就走便是了。　　14、求职简历必须突出自己的核心竞争力。　　15、垃圾是放错位置的人才。所以，在找工作的时候一定要把自己放到那个让你成为人才而不是垃圾的职位上。当然，前提是你要知道自己究竟想做什么、究竟适合做什么。世界上最大的悲剧莫过于有太多的年轻人从来没有发现自己真正想做什么。骑驴找马固然没错，可是，并非随便找一头驴就能找到千里马。所以，一定要重视第一份工作。　　16、大公司是做人，小公司是做事。进入公司工作以后，必须尽快融入写字楼政治。职员能否得到提升，很大程度不在于是否努力，而在于老板对你的赏识程度。在写字楼的政治斗争中，一定要学会自我保护。　　17、瘦死的骆驼比马大。撑死胆大的，饿死胆小的。一定要有创业的勇气和魄力。如果你一直满足于给别人打工，那么，不管你工资多高，永远都只能是一个可怜的穷光蛋。就算月薪2万，在深圳上海那种地方，一年的存款还买不来一个小小的洗手间。　　18、大学期间一定要多去图书馆多去自习室。很多书你现在不读，一辈子就再也没有机会去读了。虽然不是每本书看了都一定有用，但是，因为你不知道究竟哪本书以后会有用，所以只好多看书，并且抛弃那些过于功利的想法。尽管每次网到鱼的不过是一个网眼，但要想捕到鱼，就必须要编织一张网。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>7个源码搜索网站</title>
    <url>/hobby-7-source-code-search-engine-website/</url>
    <content><![CDATA[不管你是初学一门计算机语言或技术，还是想学习别人的经验和创意。做为一个开发人员，都会经常需要到搜索一些代码，下面是7个地方可以帮助你快速寻找到你需要的代码。原文7 Places to Find the Code You Need。


GitHub Code Search热门的开源代码库和和版本控制服务。 GitHub 在最近启动了 Code Search.即使它才启动不久，但凭借GitHub 的受欢迎度和成千上万的代码库，GitHub的这项代码搜索服务已经非常受欢迎。
KrugleKrugle是一个为开发人员量身定做的代码搜索引擎，他们宣称可搜索超过25亿行的开放源代码，是互联网最大的源代码搜索引擎之一。
和传统搜索引擎不同，Krugle专门用来搜索代码，不管是压缩包文件，还是展示在blog、网页上的代码，只要是在网络开放的空间内，Krugle都能找到，并且Krugle还可以自动生成某个特定代码的API报告 ( 尚处实验阶段 ) 。
Krugle 能提供和代码相关问题的解答。 
允许开发人员对搜索结果进行评论，并通过创建tag的方式来帮助其他人更好的找到所需的代码，实现共享。
Krugle具有较快的搜索速度，能对和代码相关的例如各种技术主题、 API 、示例、文档进行快速搜索。
KodersKoders是一个专为开放代码的搜索引擎。目前可以搜索到424,227,372套程序代码，并提供了全站更新订阅。你还可以在你的网站上共享它的代码搜索服务。每天有30000多开发者在Koders上搜索766000000行的代码，包括高达30种编程语言和28种软件license。
CodaseHuihong Luo 等人在硅谷创办一家名为 Codase.com 的程序源码搜索引擎，用户可以通过项目、类、方法及字段等来搜索程序源代码；最初只针对 Linux 平台的 C/C++ 开源项目源码搜索，目前已包含了 Windows 平台及 Java 语言相关的源码搜索，计划不久将提供对 C#、Visual Basic、Perl、PHP、Python、Ruby 等程序设计语言的支持；据 Codase 称现在已可搜索超过 250,000,000 行的源代码，并致力成为最为专业的源码搜索引擎。
SnipplrSnipplr是一个开放的源代码技巧分享社区，号称Code2.0。和一般的源码分享网站不同，它针对的并不是大型网站源码，而是一些编程的代码技巧。比如针对IE的CSS代码Hack，javascript的隐藏和显示效果代码，CSS圆角效果代码等等。具有分类和Tag支持，以及搜索，评论和收藏等等功能。
DZone Snippets拥有超过13,000 用户提供的 5,000多代码摘录, DZone Snippets 是一个寻找代码示例的好地方.
Google Code Search这个就不用多做介绍了。
其他https://searchcode.com/
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
  </entry>
  <entry>
    <title>带刺的长椅</title>
    <url>/hobby-a-bench-with-thorn/</url>
    <content><![CDATA[作者：睿雪

德国柏林有个公园很特别，里面有十几条吸引人眼球的长椅，其表面布满了4厘米长的锥形钢刺。

许多游客说，这样的椅子中看不中坐。唯有当地的居民知道，这十几条长椅是最人性化的设计。
长椅的设计者是公园管理员法比安·布伦森。布伦森年轻时是名设计师，退休后来公园做管理员。
他经常能看到这样的场景：一条长椅上坐着两个人，左边的人看着手机傻笑，右边的人则盯着手机狂喊“加油”。他们顶多相距50厘米，可内心世界像隔了十万八千里，你聊你的天，我看我的球赛，互不干扰。


这让布伦森意识到，人和人之间最遥远的距离不是生与死，而是两个人紧挨着，却各自关注着不同的世界。
经过一番思考，最终，布伦森向当地政府申请，将公园的长椅改成“锥刺股”的款式。得到允许后，他先设计出一个投币盒和一个连接着十几根钢刺的线路板。然后，在每条长椅表面均匀地钻上十几个孔洞，孔洞里安装的正是那十几根钢刺。平时，这些钢刺都是冒出孔洞的状态。当人们往投币盒投入50欧分后，钢刺就会缩回到椅子中，人们就可以坐下来休息。
钢刺缩回的时间是10分钟，时间一到，椅子就会发出尖锐的警告声，十几秒后，钢刺又会重新冒出来。对于步行疲惫的人们来说，10分钟的休息已经足够；而对于玩手机的人来说，10分钟一晃就过，这样能有效起到“扫兴”的作用。
每条长椅上都有一条相同的标语：请别让每天在此走路的距离小于手指滑动屏幕的距离。
带刺的长椅使用一段时间后，居民们这样评价：长椅虽有些“邪恶”，但让我们醒悟——试着放下手机，多和家人、朋友甚至陌生人面对面地交流。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>关于扑克，你知道多少？</title>
    <url>/hobby-about-poker/</url>
    <content><![CDATA[一付扑克牌共有54张，13种数字，每种数字有4张，也有4种花色，分别是黑桃、红桃、梅花和方块。代表一年中的春、夏、秋、冬四季。黑桃、梅花为黑色，即代表黑夜，红桃、方块为红色，即代表白天。
扑克牌中的字母也有特别的含义，比如说“A”在扑克牌中指“至尊”，意为扭转乾坤之王牌。“K”指“国王”，“Q”指“王后。“J”指的是“宫内的仆人杰克”。
扑克牌中的J、Q、K共12张，代表一年有12个月。除大、小王外，共52张，说明一年有52个星期。而扑克牌中每种花色共13张，说明每个季节正好13个星期。如果把扑克牌的点数相加，J作11点，Q作12点，K作13点，大、小王各作半点，正好365点，表示一年有365天。如果是闰年，把大、小王各作一点，刚好366点


（一）四种花色代表的意义扑克牌的四种花色代表的意义–扑克牌有四种花色，每一个花色代表一个季节，也就是一年有四个季节代表春、夏、秋、冬。而一个季度呢有91天，所以1+2+3+4+5+6+7+8+9+10+j+o+k=91。就是从1加到k等于91是一个季度的天数。再用91乘以一年4个季度正好等于364，差一天是一年的天数。可是每个花色有各代表哪个季节呢？黑桃代表什么？方片代表什么？草花代表什么？红桃代表什么？春季——黑桃（春天是第一季，黑桃在4样花色中也最大）／夏季——方片（夏天，天太热，）／秋天——草花（草花状像树-秋天是收获的季节）／冬天——红桃（红桃像火热的心）
（二）扑克数字代表的意义。在占卜中，数字所代表的意义不仅与种牌有关，还依数字之差异而变化。A代表太阳。胸怀大志，进攻性，具有创造、积极性的男性性格特征。2代表月亮。包容力，想象力，审美力，协调力大女性性格特征。3代表木星。正义感，义务感，权威感、团结力和领导者的能力。4代表天王星。因观点，意见不同而产生不满而表示出叛逆，并且义务理想主义导致不服和分歧。5代表水星。表示寻求，探险的性情，具有坚强的意志。6代表金星。魅力四射，交际广泛，人际关系良好。7代表海王星。善于思考，喜欢旅游，并有获取知识、研究的雄心。8代表土星。孤独，容易走极端，对自身的成功与幸福热切关注，利己主义的性格。9代表火星。如火的激情，超凡的勇气与强大的攻击力，属于可怕型性格。
（三）扑克牌所代表的意义扑克牌若去除鬼牌，则剩下五十二张，这五十二张正代表了一年有五十二周，而那鬼牌即代表了闰年。 接着，我们来看看扑克牌中所蕴含的其他意思。扑克牌有红心、方块、梅花、黑桃四种图案，分别代表了一年有春、夏、秋、冬四个季节；一季有十三周，所以从A到K共有十三张；一年有十二个月，所以图神有十二张：一年有三百六十五天，所以扑克牌上的数字全部加起来是三百六十五；另外，一年中有一半是白天、一半是黑夜，所以扑克牌也是一半红的，一半黑的。扑克牌是历法的缩影：54张牌中，2张是副牌，分别代表太阳与月亮，其它52张牌表示一年有52个星期。一年四季春、夏、秋、冬分别用桃、心、梅、方块来表示，其中黑桃、梅花代表黑夜、红心、方块代表白昼。每个季度有13个星期，扑克牌每个花色正好为13张牌。每个季度平均为91天，13张牌的点数加起来正好是91点。扑克牌中的J、Q、K共有12张，表示一年有12个月。4种花色点数之和是364，再加大王的一点为365，是一年的天数，若再加小王一点为366，正好是闰年的天数。另外，扑克牌中的四个花色还有不同寓意：黑桃表示橄榄叶，象征和平；红桃是心形，表示智慧；梅花傲霜雪，表现坚强；方块表示钻石，意味着财富。四种花色是人们在一年中的美好愿望。扑克牌分为四种花色：黑桃、方块、梅花和红桃。各国人民都以本国民族文化对四种花色给予不同的文化阐述。法国人将四种花色理解为矛、方形、丁香叶和红心；德国人把四种花色理解为树叶、铃铛、橡树果和红心；意大利人将四种花色理解为宝剑、硬币、拐杖和酒杯；瑞士人将四种花色理解为橡树果、铃铛、花朵和盾牌；英国人则将四种花色理解为铲子、钻石、三叶草和红心。比较集中的说法有以下两种：一说是这四种花色代表当时社会的四种主要行业，其中黑桃代表长矛，象征军人；梅花代表三叶花，象征农业；方块代表工匠使用的砖瓦；红桃代表红心，象征牧师。另一说是这四种花色来源于欧洲古代占卜所用器物的图样，其中黑桃代表橄榄叶，象征和平；梅花为三叶草，意味着幸运；方块呈钻石形状，象征财富；而红桃为红心型，象征智慧和爱情。扑克牌的54张模式解释起来也非常奇妙：大王代表太阳、小王代表月亮，其余52张牌代表一年中的52个星期；红桃、方块、梅花、黑桃四种花色分别象征着春、夏、秋、冬四个季节；每种花色有13张牌，表示每个季节有13个星期。如果把J、Q、K当作11、12、13点，大王、小王为半点，一副扑克牌的总点数恰好是365点。而闰年把大、小王各算为1点，共366点。专家普遍认为，以上解释并非巧合，因为扑克牌的设计和发明与星相、占卜以及天文、历法有着千丝万缕的联系。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>关于安卓的问题</title>
    <url>/hobby-android-question/</url>
    <content><![CDATA[1、删除.thumbnails文件夹在DCIM文件夹下删除.thumbnails文件夹，用手机下载re管理器，打开管理器在DCIM文件夹下建立.thumbnails文件（注：是文件不是文件夹）以后就不会再有了。
2、安卓屏蔽文件夹下的媒体文件在该文件夹下新建名为“.nomedia”的文件。
3、手机访问电脑文件ES文件浏览器
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>鼓掌</title>
    <url>/hobby-applause/</url>
    <content><![CDATA[作者：亦舒
华尔街纽约交易所每日下午收市，所有要员必站到小小阳台上，一起鼓掌。这时，钟声噹噹齐鸣，表示大功告成，今日已经功德圆满，明日，又是另外一天。
做人也应当这样吧，生活由千万件琐事组成，日复一日，逐件应付，日日自身挨过，过得了今日，方有明日。一日少于一日，既来之，则安之，每一日都应该像生命中仅有一日那样珍惜，一日完毕，平稳过渡，应大力鼓掌庆幸。
常常听说某人大病一场之后，人生观不一样了，他现在觉得生活真美好，多谢上天给多一次机会，他欣赏生活，不再浪费时间。

也有很多人毋须大难不死，也明白这个道理，每日做好本份，安排后事——明后日之事，十年廿年后的事，然后享受蓝天白云，四季变化。
每一日都不容易过呢，每一日又过得那样快，没有谁可以代替你过这一日，这一日去了也不会回来。
因此，也就不必理会别人说些什么了。尽快为自己赎身，享乐为上，时间极之珍贵，留为己用，陪伴家人，恕不应酬，那样，明天即使不再来，亦无太大遗憾。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>ArtCursors使用教程</title>
    <url>/hobby-artcursors/</url>
    <content><![CDATA[左手使用鼠标你是左撇吗，以至用鼠标都是左手，或者你像我一样，有兴趣经常改变单调的习惯，又或者有意锻炼右边大脑，而有试过把鼠标调成左手习惯？那么你一定会发现，你可以把鼠标拿到键盘左边，把左右键调换，但系统却没有左手方向的指针。
微软似乎从一开始就没有照顾想用左手拿鼠标的人，从win9x年代开始，到现在的vista，从键盘的布局（不清楚是否微软设计），系统快捷键，到鼠标指针，甚至整个系统，没有哪一点是为了方便左手习惯的。也难怪网上会有人说微软歧视左撇子了。
我很理解使用左手但鼠标指针却仍向右撇的别扭－－不要说习惯了也一样～～
之前的确找到过xp下的反向鼠标指针，可是找了很久也没有找到vista下的，又不想牺牲外表用回以前xp下的指针，怎么办呢？
今天找了下，找到个软件，叫ArtCursors。
ArtCursors小档案软件版本：4.21 软件大小：1051KB软件性质：共享软件 适用平台：Windows 9x/ME/NT/2000/XP/2003下载地址：http://www.onlinedown.net/soft/11132.htm


鼠标指针换个方向Step 1运行ArtCursors，在弹出的New Cursor（新建指针）窗口中单击“Cancel（取消）”按钮，因为我们要打开已有的鼠标指针进行编辑。选择菜单命令“File→Open（文件→打开）”或按下Ctrl+O组合键，展开X:\Windows\Cursors（X:表示系统安装盘符）目录，找到某个需要调整方向的指针文件，比如“aero_arrow.cur”，这是“Windows Aero（系统方案）”中的“正常选择”指针。单击“打开”按钮将此指针文件打开。
Step 2在工作区域中单击右键，选择“Flip→Horizontally（翻转→水平方向）”，即可将指针转换成适合左手使用的方向。在窗口右下角可以看到转换后的实际效果图。
光把图标翻转是不够的，还要设置“热点”。所谓热点就是指针用来触发事件的点，对于箭头来说，热点当然就是箭头的尖端了。对于默认的32×32像素的指针，ArtCursors将左上角的坐标定义为（0,0），右下角为（31,31）。因为我们对指针进行了水平翻转，所以将热点的水平坐标改为“31-X（X是原坐标）”，垂直坐标保持不变即可。以“aero_arrow.cur”文件为例，将热点坐标从（0,0）改为（31,0）。
Step 3选择菜单命令“Cursor→Hot Spot（指针→热点）”，在对话框中为翻转后的鼠标指针设置新的热点。
做完以上两步，一个左手的指针就完成了，是不是很简单？但请不要覆盖保存系统自带的图片，选择菜单命令“File→Save as（文件→另存为）”，在打开的保存对话框中，为翻转后的指针命名为你想要的名字，如“aero_left.cur”，以便和原来的右手用指针文件区分开来。
对于有些动态指针，并不是翻转一次就完成，而是要翻转多次，因为它是多帧的，每一帧都要处理。
光标设置使用ArtCursors，我们制作出了自己喜欢的光标。接下来，就可以应用到我们的计算机上了。
1、把自己喜欢的这一套光标放进文件夹（名称随意），郝同学给这个文件夹起名mycursor。然后把mycursor复制到C:\Windows\Cursors文件夹下面。
2、桌面右击，个性化，更改鼠标指针。
3、单击自定义（C）里面的正常选择，浏览，进入mycursor文件夹，找到合适的光标，打开。依次逐个替换自定义（C）里面的光标。
4、修改完成后，另存为mycursor，以后就可以很方便的切换整套光标了。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>AutoHotkey配置鼠标光标在屏幕之间瞬移</title>
    <url>/hobby-autohotkey-mouse-cursor-switch-between-screens/</url>
    <content><![CDATA[双屏幕带来的问题很多同事都会在笔记本电脑之外，再配备一个或两个屏幕，我也另外配备了一块屏幕。但是，使用双屏幕会带来两个问题：一个是窗口的切换移动不方便，另一个是鼠标的切换移动不方便。
《Windows快捷键》一文中，提到了两个可以用于多个屏幕窗口操作的快捷键：1、alt+tab，切换窗口。2、win+shift+左右键，可以移动窗口到另一个屏幕。
窗口的问题基本解决了，但是鼠标的问题还没有解决。怎么办？很多文章说，通过“显示设置”，调整两个屏幕的相对位置，就能更加容易地在两个屏幕间移动鼠标光标。但是，这个方法只是缓解了问题，并没有解决问题，鼠标光标移动依然很麻烦。
此时，就该本文的主角 AutoHotkey 出马了！


AutoHotkey简介
AutoHotkey is a free, open-source scripting language for Windows that allows users to easily create small to complex scripts for all kinds of tasks such as: form fillers, auto-clicking, macros, etc.

正如官方的介绍，autohotkey是一个免费开源的脚本语言，可以帮助用户在Windows上轻松创建脚本，例如：表格填充，自动单击，宏等。
安装1、访问AutoHotkey官网或者AutoHotkey-github，下载安装包，本文中选择下载 AutoHotkey_1.1.32.00_setup.exe 
2、双击安装即可
基本语法helloworld1、新建文件helloworld.ahk，内容为：
!H::Send, helloworldReturn
第一行定义快捷键，其中!代表alt，H就是H。第二行Send命令，,后的是参数。第三行Return停止后面的脚本。
2、启动脚本双击helloworld.ahk，或者右键helloworld.ahk，Run Script。查看系统托盘，可以看到多了一个H的图标，这就是正在运行的脚本。
3、测试脚本打开任意一个文档，按下 alt+H ，发现会自动填入 “helloworld”，nice。
语法说明1、符号说明
#	Win!	Alt^	Control+	Shift&amp;	连接两个按键(含鼠标按键)，合并成一个自定义热键

2、常用命令
Send 发送一段字符SendInput 发送一段字符MsgBox 弹出对话框Run 运行一个软件或者打开网页WinActivate 窗口激活WinWaitActive 等待窗口激活

更多内容参考AutoHotkey官方文档。
定义快捷键利用autohotkey，可以实现自定义快捷键。
双脚本1、新建文件 mousemove1.ahk，内容为
!1::CoordMode, Mouse, ScreenMouseMove, (A_ScreenWidth // 2), (A_ScreenHeight // 2)return

这段脚本运行后，按下 alt+1 ，鼠标光标会跳转到屏幕1的中心。
2、新建文件 mousemove2.ahk，内容为：
!2::CoordMode, Mouse, ScreenMouseMove, (A_ScreenWidth + 100), 100return

这段脚本运行后，按下 alt+2 ，鼠标光标会跳转到屏幕2的左上角的(100,100)位置。
这两个脚本配合，已经可以鼠标光标在两个屏幕间切换，nice。但是，mousemove2.ahk 还有改进的空间。既然屏幕1是跳转到屏幕中间，那么屏幕2自然也是跳转到屏幕中间更好。
屏幕2的分辨率为3840x2160，因此脚本修改为：
!2::CoordMode, Mouse, ScreenMouseMove, (A_ScreenWidth + 1920), 1080return

单脚本以上，已经实现了鼠标光标在两个屏幕间的完美切换。但是，因为切换时有两个快捷键，所以切换鼠标所在屏幕时，还要想一下是切到1还是切到2，这也是一个可以改进的点。
创建文件 mousemove.ahk，内容为：
!J::CoordMode, Mouse, ScreenMouseGetPos, xpos, yposif (xpos &lt;= A_ScreenWidth) and (ypos &lt;= A_ScreenHeight)&#123;    MouseMove, (A_ScreenWidth // 2), (A_ScreenHeight // 2)&#125;else &#123;	MouseMove, (A_ScreenWidth + 1920), 1080&#125;return

这段脚本运行后，按下 alt+J ，可以实现鼠标光标切换到另一个屏幕的中心。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>左神排序算法文字总结</title>
    <url>/dev-zuo-sort/</url>
    <content><![CDATA[前言相见恨晚！看了左神的算法视频，才知道自己到底浪费了多少时间。算法，居然能讲的这么有意思，居然能讲的这么通俗易懂！左神，不愧是左“神”！
《leetcode刷题记录-排序算法总结》一文中，也总结过排序算法，但是和左神的讲解一比，简直就是渣渣。所以，本文按照左神的讲解，再次总结一下排序算法。


排序算法常见的排序算法有9个，分别是冒泡排序、选择排序、插入排序、归并排序、快速排序、堆排序、希尔排序、计数排序和基数排序。它们的时间空间复杂度如下：



算法
时间复杂度
空间复杂度
稳定性



冒泡排序
$O(N^2)$
$O(1)$
稳定


选择排序
$O(N^2)$
$O(1)$
不稳定


插入排序
$O(N^2)$
$O(1)$
稳定


归并排序
$O(N*logN)$
$O(N)$
稳定


快速排序
$O(N*logN)$
$O(logN)到O(N)$
不稳定


堆排序
$O(N*logN)$
$O(1)$
不稳定


希尔排序
$O(N*logN)$
$O(1)$
不稳定


计数排序
$O(N)$
$O(M)$
稳定


基数排序
$O(N)$
$O(M)$
稳定


注：M代表桶数量。
如上图，按照时间复杂度的不同，分为三大类。以下算法描述，实现的都是升序排序，N代表元素个数，a[i]代表i位置的元素。
笨蛋算法冒泡排序1、依次比较，a[i] &lt; a[i+1] 则交换元素，结果最大元素位于N-1位置2、范围缩小1
选择排序1、0到N-1选出最小元素放在0位置（交换元素即可）2、1到N-1选出最小元素放在1位置
插入排序1、1位置和0位置元素比较，小则交换2、2位置和1位置元素比较，小则交换；1位置和0位置元素比较，小则交换
聪明算法归并排序1、数组分割成长度为1的有序区间2、有序区间两两合并，得到长度为2的有序区间
快速排序1、数组中随机选择一个数，小于等于这个数的元素放左，大于这个数的元素放右2、左右两边递归
快速划分过程：（1）左区间初始值为0，划分值放在N-1位置（2）遍历数组，元素大于划分值则跳过，小于等于划分值则交换该元素与左区间加一的元素，到N-1位置则交换划分值与左区间加一的元素。
堆排序1、已有大根堆（数组表示），把堆顶元素与最后一个元素交换，交换后最后一个元素有序2、调整后，把堆顶元素与倒第二个元素交换，交换后最后两个元素有序
希尔排序1、设定初始步长，按照步长比较元素大小并交换2、步长减一，比较元素大小并交换
注：希尔排序是改良版的插入排序
变态算法计数排序1、建立0-M号桶2、把元素按大小放入对应桶3、依次把0-M号桶中的元素倒出
基数排序1、准备0-9号桶2、元素按个位数放入对应桶3、依次把0-9号桶中的元素倒出（先进先出），成为序列4、按序列把元素按十位数放入对应桶
注：计数排序和基数排序都属于桶排序的实现，桶排序是一种排序思想。
后记好记性不如烂笔头，后续计划对其他算法也进行总结。
书签牛客算法基础班
牛客算法进阶班
直通BAT — 求职算法精品课
]]></content>
      <categories>
        <category>专业</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>将文件夹取消与SVN关联</title>
    <url>/hobby-cancel-associate-folder-with-svn/</url>
    <content><![CDATA[Windows Registry Editor Version 5.00[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\DeleteSVN]@="删除该目录下面.svn文件"[HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Folder\shell\DeleteSVN\command]@="cmd.exe /c \"TITLE Removing SVN Folders in %1 &amp;&amp; COLOR 9A &amp;&amp; FOR /r \"%1\" %%f IN (.svn) DO RD /s /q \"%%f\" \""

（1）把上面这段文字保存为“取消SVN文件夹.reg”文件。
（2）双击这个文件,导入到注册表。
（3）右键一个文件夹的时候，会多出来一个菜单”删除该目录下面.svn文件”，执行该命令即可。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>常见的汽车品牌</title>
    <url>/hobby-car-brand/</url>
    <content><![CDATA[前言一直认不清汽车品牌，最近在玩狂野飙车，系统学习了下，做个小结吧！
德国大众（Volkswagen）



宝马（BMW）

奔驰（Mercedes-Benz）

奥迪（Audi）

保时捷（Porsche）

意大利兰博基尼（Lamborghini）

法拉利（Ferrari）

玛莎拉蒂（Maserati）

阿尔法罗密欧（Alfa Romeo）

英国路虎（Landrover）

劳斯莱斯（Rolls-Royce）

宾利（Bentley）

捷豹（Jaguar）

阿斯顿·马丁（AstonMartin）

莲花（lutos）

法国雪铁龙（CITROEN）

标致（peugeot）

布加迪（BUGATTI）

雷诺（Renault S.A.）

美国福特（Ford）

悍马（Hummer）

凯迪拉克（Cadillac）

别克（Buick）

林肯（LINCOLN）

雪佛兰（Chevrolet）

道奇（Dodge）

特斯拉（Tesla Motors）

中国比亚迪（BYD）

中国一汽（FAW）

奇瑞（Chery）

日本丰田（Toyota）

英菲尼迪（Infiniti）

本田（Honda）

日产（NISSAN）

马自达（MAZDA）

雷克萨斯（LEXUS）
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《Clean Code》</title>
    <url>/hobby-clean-code/</url>
    <content><![CDATA[
研究表明，在编程过程中，读代码和写代码的时间比为10:1，所以整洁代码完全必要！


不要重复代码，只做一件事，提高表达力，小规模抽象！


字面编程，编程白话文！一目了然的效果！


匈牙利命名法、前缀命名法已经过时！命名，长度不是问题，明确是王道！


方法名：动词或者动词短语！


只有程序员才会读你的代码，不要吝惜专业术语！


函数的第一原则是短小，第二原则是还要更短小！


类的第一原则是短小，第二原则是还要更短小！



函数只做一件事，做好一件事！


函数参数越少越好！（不要超过两个）


三个以上参数，封装为类！


先随意写，然后修改，像写文章一样！


别给糟蹋的代码加注释——重新写吧！


代码是唯一真正准确的信息来源，如无必要，勿写注释！


变量声明尽可能靠近其使用位置！


相关函数放一起！


被调用函数放在执行调用函数下面！


赋值操作符周围加空格！


做有意义的修改！


学习API的方法:学习性测试！


类的名称应当描述其权责！


单一权责原则——只有一条修改的理由！

]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>常用正则表达式</title>
    <url>/hobby-common-regular-expression/</url>
    <content><![CDATA[正则表达式用于字符串处理、表单验证等场合，实用高效。现将一些常用的表达式收集于此，以备不时之需。
匹配中文字符的正则表达式： [\u4e00-\u9fa5]
匹配双字节字符(包括汉字在内)：[^\x00-\xff]
应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
String.prototype.len=function()&#123;return this.replace([^\x00-\xff]/g,"aa").length;&#125;

匹配空行的正则表达式：\n[\s| ]*\r
匹配HTML标记的正则表达式：/&lt;(.*)&gt;.*&lt;\/\1&gt;|&lt;(.*) \/&gt;/
匹配首尾空格的正则表达式：(^\s*)|(\s*$)


匹配中文字符的正则表达式：[\u4e00-\u9fa5]评注：匹配中文还真是个头疼的事，有了这个表达式就好办了
匹配双字节字符(包括汉字在内)：[^\x00-\xff]评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
匹配空白行的正则表达式：\n\s*\r评注：可以用来删除空白行
匹配HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力
匹配首尾空白字符的正则表达式：^\s*|\s*$评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式
匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*评注：表单验证时很实用
匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*评注：网上流传的版本功能很有限，上面这个基本可以满足需求
匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$评注：表单验证时很实用
匹配国内电话号码：\d{3}-\d{8}|\d{4}-\d{7}评注：匹配形式如 0511-4405222 或 021-87888822
匹配腾讯QQ号：[1-9][0-9]{4,}评注：腾讯QQ号从10000开始
匹配中国邮政编码：[1-9]\d{5}(?!\d)评注：中国邮政编码为6位数字
匹配身份证：\d{15}|\d{18}评注：中国的身份证为15位或18位
匹配ip地址：\d+\.\d+\.\d+\.\d+评注：提取ip地址时有用
匹配特定数字：^[1-9]\d*$　 　 //匹配正整数^-[1-9]\d*$ 　 //匹配负整数^-?[1-9]\d*$　　 //匹配整数^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　　 //匹配正浮点数^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　 //匹配负浮点数^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　 //匹配浮点数^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　　//匹配非正浮点数（负浮点数 + 0）评注：处理大量数据时有用，具体应用时注意修正
匹配特定字符串：^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
  </entry>
  <entry>
    <title>浓和淡</title>
    <url>/hobby-concentration-and-light/</url>
    <content><![CDATA[作者：子沫
女人分两类，浓的和淡的。用两个词形容就是：月黑风高和月白风清。
我认识的朋友有浓有淡。一位在高校教法语的朋友浓眉大眼，丰满盈润，很妖媚，她特别适合化妆，眼影口红一涂上去，整个人立马神采奕奕，顾盼生姿。有一天，几个朋友约着吃饭，她匆匆而来，面容憔悴，问为什么，她说昨天没睡好，赶时间，来不及化妆。说着便掏出小镜，描眉画眼，涂上艳丽的口红，只是5分钟时间，立马光彩照人，又是美人一枚。
我们纷纷夸她，她笑着说，学生也这样说她，说某老师化妆真好看。浓美人吃起火锅来不怕辣，吃得眼神放光，连辣油也可以舀出来喝下去，然后来一口冰啤酒，冰火两重天。朋友们跟她吃饭，往往最过瘾。她很真实，从不隐藏。不装，这也是我们不是同类，但却能成为朋友的原因。


朋友堆里也有位淡的女人，细眉细眼，五官没有亮点，但组合到一起，却像一幅黑白写意画儿，看上去生动明白。她不用化妆，皮肤透明清洁，毛孔细腻，弯弯一道眉，安安静静的。
某一次，大家心血来潮怂恿她化妆，她一上妆，还没有原来好看，显得可笑而笨拙。原来的清灵之气完全都不见了，细眉细眼变得滑稽可笑，亮点瞬间没有了。她不适合化妆。好皮肤就是最好的妆容。她是需要往轻里打扮的人。
某一次，她穿黑色香云纱的改良旗袍，清透的皮肤干干净净，黑白分明，像那种走在戴望舒的雨巷里的女孩，可以悄然进入男人的梦境。她曾是我的一位瑜伽老师，自己还在读着博士。有一天，她从我身边走过，我闻到了一股清澈流动的香味，好像走过冬青树。一问，她笑着说：“我刚洗了手，用了点护手霜。”她是任何时候都会涂上护手霜的女人。淡的女人像天然植物，美感悄悄地影响着周围的人。
编后语：浓和淡都无妨，真性情、正能量就好。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>无法停止通用卷设备</title>
    <url>/hobby-could-not-stop-the-general-volume-equipment/</url>
    <content><![CDATA[安全删除U盘时，大家常常会遇到提示“无法停止‘通用卷’设备，请稍候再停止该设备。”
这种情况下可以强行拔下U盘吗？当然不可以！这时候如果强行拔除的话，很容易损坏计算机U口或者你的U盘。如果你的U盘上有重要的资料，很有可能就此毁坏了。那么应该怎么办呢？
第一种方法：（这也是我建议大家最常用的方法）往往我们在把U盘的文件或者数据取出来的时候，都是用的“复制”“粘贴”方式，而如果复制的是U盘上的文件，这个文件就会一直放在系统的剪切板里，处于待用状态。而如果这种情况下我们要删除U盘的话，就会出现上面的无法停止U盘的提示。
相应的解决办法就是：清空你的剪切板，或者在你的硬盘上随便进行一下复制某文件再粘贴的操作，这时候你再去删除U盘提示符，看看是不是顺利删除了？ 
第二种方法：如果觉得上面那种方法还无效的话，可以使用下面这个方法：
同时按下键盘的”Ctrl”＋”Alt”＋”Del”组合键，这时会出现”任务管理器”的窗口，单击”进程”标签，在”映像名称”中寻找”rundll32.exe”进程，选择”rundll32.exe”进程，然后点击”结束进程”，这时会弹出任务管理器警告，问你确定是否关闭此进程，点击”是”，即关闭了”rundll32.exe”进程。再删除U盘就可以正常删除了。
使用这种方法时请注意：如果有多个”rundll32.exe”进程，需要将多个”rundll32.exe”进程全部关闭。
第三种方法：这种方法同样是借助了任务管理器，同时按下键盘的”Ctrl”＋”Alt”＋”Del”组合键，出现”任务管理器”的窗口，单击”进程”，寻找”EXPLORER.EXE”进程并结束它。这时候你会发现你的桌面不见了，请不要惊慌，继续进行下面的操作，在任务管理器中点击“文件”——“新建任务”——输入EXPLORER.EXE——确定。再删除U盘，你会发现可以安全删除了。
第四种方法：这种方法最简单，但最耗时，那就是，重启你的电脑。
第五种方法：一个国外的十分小巧实用的软件，只有191KB，叫unlocker，十分好用！这个软件能解锁USB连接设备！就能实现100%安全删除USB连接了！ 
预防方法：如果觉得出现问题的时候才解决有些麻烦，可以采用下面这个提前的预防措施：关闭系统的预览功能。
方法：双击我的电脑——工具——文件夹选项——常规——任务——使用windows传统风格的文件夹，然后点击确定就行了。这样一劳永逸了。
小窍门：目前有些U盘的技术很到位了，有的U盘直接插拔也可以的。但无论是多好的U盘，有一种时候是绝对不能直接插拔的，那就是仔细看你U盘的那个小红灯，小灯在不停闪的时候表示正在不停地读写数据，这时候千万不能拔，否则轻则损坏数据，重则U盘报废。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Dell的BIOS设置</title>
    <url>/hobby-dell-bois-setting/</url>
    <content><![CDATA[对于戴尔预装了 Microsoft Windows 8 的笔记本电脑，BIOS 中的 Boot （启动）选项，在默认情况下的设置为



选项
值



Secure Boot
[Enabled]


Load Legacy Option Rom
[Disabled]


Boot List Option
[UEFI]


如下图所示：









在这种设置下，如果使用者希望从光驱或其它USB设备启动，有时候会发生无法引导的情况。此时，需要对 BIOS 的选项做如下修改。



选项
值



Secure Boot
[Disabled]


Load Legacy Option Rom
[Enabled]


Boot List Option
[Legacy]


修改后，能看到 Boot 选项中列出了 USB 存储与光驱等设备。
BIOS 修改好后保存退出，重启电脑的时候按键盘的 F12，重新进入引导菜单，此时就能够从连接的 USB 设备或光驱进行引导。另外请注意：对于支持 UEFI 启动的机型，如果开机无法进入系统，提示 “internal hard disk drive not found” 错误，如下图所示。
请进入 BIOS 检查硬盘在 BIOS 中是否能够被正常识别。如果可以，进入 Boot 页面，务必将 Secure Boot 改为[Disable]。此情况经常发生在用户删除了原厂预装的 Windows 8 并装为 Windows 7 或其它系统之后。因为非 Windows 8 操作系统，不能支持 Secure Boot。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>桌面美化</title>
    <url>/hobby-desktop-beautify/</url>
    <content><![CDATA[前言爱拉风的小伙伴，总喜欢把电脑鼓捣的花里胡哨。郝同学也研究过一段时间，美其名曰“个性”，今天和大家探讨一下（win7为例）。
我的桌面郝同学的桌面经历过几次变革，下面这张图，是现在的样子（使用rainmeter制作）。
微软主题在桌面上右击，个性化，联机获取更多主题。下载安装替换即可。
这种主题，其实只是桌面背景的替换，美化效果不是很明显。
第三方主题安装第三方主题，是最简便的一种美化桌面的方式。用时少，见效好，大部分小伙伴喜闻乐见。
安装1、百度“win7主题”，选择一个主题下载网站进入。2、挑选喜欢的主题，下载。一般是压缩包，解压后会有一个以“.exe”结尾的文件，安装即可。
免安装“安装”就意味着，往注册表写入东西，还要创建很多不必要的文件和文件夹。所以，只要条件允许，郝同学喜欢使用绿色软件，也就是免安装软件。主题也有办法跳过安装实现美化桌面。
原理：主题安装，实际上也就是往Themes、Wallpaper和Cursors文件夹里面写入文件，然后更改设置。我们只要获得win7主题中写入这三个文件夹的文件，就可以实现免安装。怎么搞？虚拟机安装win7主题，然后从这三个文件夹把文件拷贝出来，放入客户机对应的文件夹，稍加设置即可。
主题存放目录：C:\Windows\Rsources\ThemesC:\Windows\Web\WallpaperC:\Windows\Cursors
下面是郝同学使用过的主题，免安装版，分享给大家：http://yunpan.cn/cKDN8aRdgqEtX  访问密码 15ce
这次分享不包含鼠标光标，关于鼠标光标的使用和制作，将会在下一篇文章详细讨论。

问题使用ghost镜像安装的系统，安装第三方主题，一般没有问题。但是，正版Win7系统（纯净版系统），安装了win7主题之后，任务栏和开始菜单都变成白色的，很难看，与主题预览图不一样,窗口颜色那里显示是Windows经典。解决办法是：主题破解。
在此附上win7主题破解工具：http://yunpan.cn/cKDN59AfDPUqR  访问密码 ce5e
rainmeterrainmeter（雨滴），个人比较满意的一款桌面美化工具，我们来研究一下它的使用方法。以下部分内容来自百度贴吧。
步骤一：下载安装官网地址：http://rainmeter.cn/cms/ ，下载安装即可。需要注意的是，最好勾选开机启动。
步骤二：关闭皮肤运行Rainmeter，Rainmeter会自动加载软件自带的皮肤，就是四个黑不溜丢的皮肤。一般人是不会喜欢这四个皮肤的，只要在这四个黑不溜丢的皮肤上点击鼠标右键。找到“关闭皮肤”、逐一关掉即可。
皮肤分享以下是郝同学当年搜集的一些rainmeter皮肤，分享给大家：http://yunpan.cn/cKDh9Hcmuy6qK  访问密码 2bba
步骤三：使用皮肤假设大家已经下载好了自己喜欢的皮肤，这时我们就可以使用皮肤了。1、假设你的系统用户名是Administrator，那么打开C:\Users\Administrator\Documents\Rainmeter\Skins，把下载好的皮肤（包括文件夹）复制进这个文件夹。我们假设你们下载了郝同学分享的皮肤，那么，就把“我的rainmeter”文件夹复制到Skins文件夹下。
2、打开rainmeter，就可以看到刚才复制到Skins的皮肤，如果没有，请刷新。
3、双击那些“*.ini”文件，皮肤就会出现在桌面上，再次双击，消失。
4、选中一个“*.ini”文件，编辑，自定义皮肤的各项属性。我们以“线条0.INI”为例，修改一下名称和路径，就可以成为适用于自己电脑的快捷方式。
进阶今天我们主要讨论的，只是rainmeter的使用。如果你想深入学习，比如皮肤的制作等，就需要系统的学习了。这里分享一本《rainmeter中文手册第三版》：http://yunpan.cn/cKzsFRKGVKDcX  访问密码 b570
小结美无止境，更多方法和工具，等待我们去发现。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>坐功入静</title>
    <url>/hobby-dhyana-meditation/</url>
    <content><![CDATA[作者：那秋生

坐功是静功里最要紧的一个环节，坐功是入静的第一步。坐功有静坐功和动静兼修两种。

李渔《闲情偶寄·颐养》曰：“益寿之方，全凭导引；安生之计，惟赖坐功。”儒家提倡“静坐”。王阳明说：“静坐要省察克治，静坐能使心清静收敛，从而克服自我私欲产生，通过静坐能顿悟明心见性，得道成真。”
道家主张“坐忘”。《庄子·大宗师》：“堕肢体，黜聪明，离形去知，同于大通，此谓坐忘。”即摆脱现实形体的束缚，与自然融为一体，两两相忘。佛家的功夫是“坐禅”。音译“禅那”，简称“禅”，意谓思维修或静虑，就是趺坐而修禅，是佛教修持的主要方法之一。
现代人就是坐不住，成天跑东跑西、忙这忙那，就像丢了魂似的，悲乎！
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的听见音乐了吗</title>
    <url>/hobby-do-you-really-hear-the-music/</url>
    <content><![CDATA[作者：杨照
一个徒弟从师学音乐，晃眼三年，对中国传统音乐的主要系统几乎都精熟了。于是他问：“我什么时候能出去演奏呢？”师父劝他别急：“你真的听见音乐了吗？”徒弟回答：“当然，我怎么可能听不见音乐呢？音乐就在我的乐器里啊！”
师父理解徒弟急着要去闯天下的心情，就说：“这样吧，我带你去见我的师父吧！”
师徒两人走进山里，走了一整天，到了瀑布旁，师父终于停下来，说：“你在这里等，千万别乱走动，免得在山中迷路。我去请我的师父，看他愿不愿意见你，教你出师前最后的本事。”
徒弟等着，一会儿天黑了，接着夜慢慢深了，四处看不见任何东西。他又急又怕，只好竖起耳朵听四周有什么异状，慢慢地，他听到近处远处不同的水声，听到风声，借由风的流动，听出了树的位置与树的形状，他听到虫声，也听到不知名小动物试探的脚步声。

无穷的声音涌动着，让他的耳朵应接不暇。声音与声音相激，产生更多的声音。声音与声音相继出现，似乎也就呼应产生了节奏、韵律。他听到像音乐又不是音乐的东西，以前没有听过，不知该如何形容。
他就这样听了一夜的声音，直到天色开始泛白。他感觉自己仿佛听到了云色亮开的声音。他把眼睛闭上，听到一种神秘的声音，不是从耳朵里来，而是从心底来的，那是太阳爬上对面山顶的声音。
太阳高挂，师父才出现，问：“你遇到我的师父了吗？”徒弟犹豫了一下，回答：“应该遇到了吧。”
从山里回来，徒弟无法再演奏任何乐器。因为相较于山中之夜听到的，乐器的声音如此单薄、贫乏，让他厌倦不堪。徒弟黯然道：“我听见音乐了——天籁，所以我不想再碰触任何人的音乐了。”
师父说：“还没有，你还没听到，再听下去。”
好长一段时间，徒弟躲开街市上的喧闹人声，也不愿意演奏乐器，一心想着山中之夜听到的自然界的声音。有一天，他拿起布满了灰尘的笛子随手擦拭，放到嘴边吹出声音来。吹着吹着，心底有了一种前所未有的兴趣，再吹下去，快乐重新回到他身上，他用力吹，努力吹，吹完之后才发现自己竟然冒了一身汗，而且不知不觉中绕着房子走了好几圈。
师父就在他身边，欣慰地拍拍他说：“现在，你可以去演奏了。”
徒弟大惑不解：“为什么？为什么会有这样的变化？”师父解释：“因为你懂得了不去跟天地竞争，不再试着要演奏出比天籁更美、更丰富的声音，而是专注地让自己的音乐与外在声音相呼应，用你的音乐去改造外面的声音，你的音乐不再是单独存在的。于是，你不再是个乐匠，而是一个乐师了！”
这个故事，是我少年时听老师讲的。那位老师学的是西方乐器小提琴，对小提琴的技巧与音乐表现要求极严。然而每隔一段时间，他都会跟我说一次这个中国音乐哲学的故事。
几十年来，我反复在心里问自己：这故事和音乐，尤其是和从巴赫到巴托克的西方音乐，有什么关系吗？
慢慢地，我似有所悟，领悟到音乐带给我们的，不只是音乐本身，更重要的还有一种听觉能力与听觉习惯。处在现代环境下，许多人成长过程里必要的一种训练，就是如何与噪音共存，也就是如何关起自己的耳朵，学会不要去注意、不要去听外界周遭的声音。
我们的听觉一直在变钝，钝到一定程度，才能帮助我们不受干扰地活下去。可是钝掉的听觉，听不见噪音，也听不见美妙的声音。
音乐，尤其是西方古典音乐，一直在追求一种复杂的和谐。借由对位与和弦原理，众多不同音符层叠架构，绝不彼此冲突。听这样的音乐，我们一方面感受到愉悦，一方面感受到一种想深入了解的冲动，想要专注捕捉每一个音符，以及音符与音符之间的关系，捕捉得越多，收获就越多。
换句话说，这种音乐给予专注大量的回报。懂得专注聆听，就能得到更丰富的感受，久而久之，为了追求那诱人的丰富感受，听音乐的人就会习惯于专注，养成专注的习惯。
于是，耳朵打开来，听到许多原本听不见的声音，也同时懂得了如何分辨值得听和不需要听的声音。我们跟外在世界的联系，因听觉的改变而改变了。
我们可以随时随地，在任何条件下，借由音乐创造出既内于世界又外于世界的自我小宇宙，专注且自在地活在自我小宇宙里，快活安适。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅</title>
    <url>/hobby-elegant/</url>
    <content><![CDATA[作者：吴永进
我欣赏优雅的人，无论是男人还是女人。年轻时看格里高利·派克的影片，给我的感觉就是舒服，这种舒服其实就是优雅。看栗原小卷的影片也是这样的感觉，被她所饰演的人物感动，继而深深迷恋。后来慢慢知道，优雅是可以打动人的，它给人一种气息上的感染，让人觉得心灵的褶皱被熨烫，被抚摩得舒适。因为优雅是一种气质，优雅是一种美，优雅是超然与洒脱，具有精神滋养品的功效。
原本一直以为优雅是有条件的，比如优渥的经济基础、良好的家庭背景、深厚的文化底蕴等等，就像18世纪的贵族。为什么一说到贵族往往就联想到高贵、优雅？因为富有嘛。所以人们常说培养一个贵族需要几代人的积累和努力，恐怕也是这个道理。没有一定的物质基础，怎么优雅得起来呢？
最近接连遇到友人的两件事，方才明白这其实是认识误区。

一是老同事继和，因为经济原因，一次次错过了购房的时机，如今房价已是悬在半空，仰之弥高了，加上女儿渐大，住房自然是相形见绌。可他并未捶胸顿足、怨天尤人，而是选择了另一种生活方式：租房。前一阵，因嫌早先所租的房屋小了，换了一套。正在我们为他烦恼之际，没想到，搬入新居之后，他竟然呼朋唤友，设宴款待，“隆重”庆祝乔迁之喜。据说我们已经是第三批了。进屋后，他们夫妇引我们参观“新居”，介绍住房装修，赞美家具陈设，俨然像那是他们自己新筑的“爱巢”一般。望着他们从心底洋溢出来的满足，在场的人分明感受到一种超然物外的自乐，我脑海里立刻蹦出两个字：优雅。生活虽然清贫如常，心却依然静若止水。
另一位是作家赵长天，罹患重病后，在他生命的最后时光里，他却镇定自若，每天带着欣赏的眼光，阅读长篇小说《大秦帝国》。他在人生的最后一条微博中写道：“住院半年，得以看完几百万字的长篇小说《大秦帝国》。春秋战国人性张扬，思想活跃，智慧绽放，天才辈出。这样的时代在中国唯一，在世界唯一。在此基础上诞生的大秦王朝，岂能用简单一句‘暴政’来概括。现在谈起中华文化传统便是孔儒，似太简单……”从容地评点文学、评点历史，哪里看得出是一个沉疴在身、不久于世的病人。这样一种告别人生的方式，难道不是大优雅吗？作家陈丹燕因此由衷地评价：“书生本色，光彩夺目。”
人生的舞台，时时上演着悲喜剧，面对生活的不如意甚至是生命的绝境，你将如何应对，这其实是谁也绕不过去的话题。上述两位友人，他们一个优雅地对待日常生活，一个优雅地对待生老病死。他们都是生活的智者，也是生活的强者。
在曲曲折折、坎坎坷坷的生命旅途中，在花花绿绿、光怪陆离的喧嚣光影下，需要培养一种姿态，那就是优雅。优雅能保证我们在任何情况下，都能演好自己的角色，不至于狼狈不堪，更不会丑态百出。
人生不平坦，优雅恒久。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>找棵树，靠一靠</title>
    <url>/hobby-find-a-tree-and-rely-on-it/</url>
    <content><![CDATA[作者：陈凤兰
著名女作家张洁在回忆汪曾祺的文章中写道：“感到窒息的时候，便会翻开他的文字，不紧不慢地读着，既不急于知道结果，也不曾想得到什么警人的启示，只是想找棵树靠一靠。”
好的散文就是如此，像棵树。当你疲乏时，当你走累了，如果恰好路旁有棵树，多半就会在那树上靠一靠。也许，这就是“休”字的来源。
红尘中，喧嚣声不绝于耳，繁杂充斥眼帘，我们整天纠缠在明争暗斗、唇枪舌剑的乱麻中不能自拔。于是，我们的心灵想走一走，出去散个步。阅读是放飞心灵最好的翅膀，美文是惬意心灵的最佳去处。可极目而视，桌案旁满满当当的是报纸杂志，书橱里重重叠叠的是经典名著。可我们还是觉得无书可读，就像那些亿万富翁说的“穷得只剩下钱”的困窘。这倒不是矫情，而是选择困难症的再次发作。

翻开报刊，不外乎就是人咬狗的新闻，或者沾着文学名的副刊短文。要么是家长里短，要么是风花雪月，共性是“短”，短得上个厕所正好能看完一版。周遭变得太快，学业渴求凭借百日冲刺有成，艺术水平也依托捷径式的招数提升，连结婚也是“闪婚”，离婚也是“闪离”……“快闪”成了主流，哼着“咿咿呀呀”的戏曲显得无比滑稽和不合时宜。信息的爆炸要求信息要短小简明，我们恨不得只听《新闻联播》里的导语即可。
“快餐文化”成了我们每日的“盘中餐”，吃得越多，我们越是饥饿，越是营养不良。
我们需要厚重的经典与名著，需要那些作家为我们提供源源不断地缓缓流淌的活水。可如慢板的纯文学散文却被许多作家弃如敝屣，他们一转身都卷进了炮制长篇小说的洪流。似乎没有一本厚重的、沉甸甸的长篇，自己都枉为作家，都愧对作家这个伟大的称号。“作家”头衔虽无实质性的经济利益，甚至每年还要奉上一定数额的会费，但没有这个帽子，就像在希特勒时代没别上保命的纳粹徽章一样，没有它，在文学创作的圈子里你就无法被验明正身。所以，作家的头衔是要的，匹配作家头衔的长篇也是要的，如果长篇还能华丽地转身改编为影视剧本，那就可谓名利双收了。
当然，还有相当多的作者既不炮制鸿篇巨制，也不料理“短、平、快”的“快餐”。他们是“匕首”“投枪”型的，对于时事现状，他们或嬉笑怒骂，或舍我其谁。字里行间充盈着“心有苍生”的担当，更有审视、解剖的“血痕”。贫富差距、道德滑坡、回不去的故乡、走不进的城市……他们像杜鹃一样彻夜啼鸣、满嘴染血。可我不会在柔和的灯光下，冲进刀光剑影中，我怕读后无法安然若素，我怕梦中不得全身而退。
累了，更多的时候我想像一只慵懒的猫，在冬日阳台的藤椅上，暖暖地沐浴着阳光，“呼噜呼噜”地打个盹。
我会打开梭罗的《瓦尔登湖》或者乔治·吉辛的《四季随笔》……我只是想让生活慢下来，慢到能看见花蕾爆开的刹那，听得见蚯蚓翻身的“嚓嚓”声……至于别人怎样呼风唤雨、飞沙走石，且随他去，我自溪水潺潺、惠风和畅……
渴吗？来一杯香茗。烦吗？寻幽静的小路散个步。累吗？找棵树靠一靠。也许，这便是极好的。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>自由与理想</title>
    <url>/hobby-freedom-and-ideal/</url>
    <content><![CDATA[作者：吴晓波
在我们这个国家，最昂贵的物品是自由与理想。它们都是具体的，都是不可以被出卖的，而自由与理想，也不可以被互相出卖。
我进大学听的第一次大型讲座，是在复旦四号楼的阶梯教室，因为到的迟了，教室里满满当当都是人，我只能挂在铁架窗台上，把脖子拼命往里伸。那时是 1980 年代中期，存在主义刚刚如同幽灵般地袭入激变中的中国。
一位哲学系的青年讲师站在台上，他大声说，上帝死了。
如今想来，我成为一个具有独立意识的人，大抵是在那个复旦秋夜，我不再隶属于任何意识形态、任何组织或机构，甚至国家。我是一个属于自己的读书人。

“无事袖手谈性情，有难一死报君王。”这段诗句也是大学图书馆里读到的，不记得是哪本书了，但是过目即不忘，耿耿于怀。当时就想，中国书生的千年局促与荒诞就在这十四个字里了，我们这一辈应该学习做一个“没有君王的书生”。
在大学这样的“真空状态”下，当一个思想自由的读书人似乎是容易的，你对社会无所求，社会与你亦无所扰。可是出了校门，后来的二十多年，却是一天接一天的不容易。
大学毕业是 1990 年。这个国家好像一夜之间被推进了商品化的潮流中，大概是在 1992 年前后，一位熄灯之后阔谈康德和北岛的上铺同学，突然给我打电话，说他在新疆能弄到上好的葡萄干，如果在南方找到通路，可以发一笔上万元的大财。又过几周，一位厦门的同学来信，说杭州海鲜市场的基围虾都是从厦门空运的，问我能不能联系一个下家。去电视机厂采访，厂长从上衣口袋里掏出一张盖了圆章的条子，凭这个买彩电可以便宜 300 元，相当于我两个月的工资。
还有一次，陪一位饮料公司老板见市里的副市长。副市长一表人才，气傲势盛。两方坐定，老板突然从包里摸出一台半块砖头大小的摩托罗拉移动手机，小心翼翼地树在茶几前，副市长第一次亲眼目睹此物——在当年它相当于高级公务员十年工资，我分明感觉到他的气势硬生生地被压下了半头。
那个年轻的我，握着一管钢笔的书生，夹在政商之间，猛然又想起性情与君王。
到了年底，单位把大家召集起来，谈明年的工作目标。轮到发言，我说，明年的目标是挣到 5000 元稿费，做“半个万元户”。四座的叔婶辈们齐齐把无比诧异的目光射向坐在墙角的我。
后来的几年里，疯狂地写稿子，为单位写，为单位外的报纸、电台写，为企业写新闻通稿、汇报材料、讲话稿甚至情况说明，为广告公司写报纸文案、电视广告脚本，再然后，写专栏、写书，一本接一本地写书。
那些年，我开始信奉这样一句格言——“作为知识分子，你必须有一份不以此为生的职业”，罗斯福的这句话里有一种决然的挣脱，它告诫我，读书人应摆脱对任何外部组织的人身和物质依附，同时，其职业选择应该来自兴趣和责任，而与生存无关。这是一种来自西方的价值观，最远可追溯到亚里士多德，他将具有道德行为能力的人局限于“有产男性公民”，即“无恒产则不自由，不自由则无道德”。在一个一切均可以用财富量化评估的商业社会里，思想自由不再是一个哲学名词，而是一种昂贵的生存姿态，它应基础于财富的自由。
1990年代末，房地产业悄然趋暖，在财经世界浸淫多年的我，对照欧美和亚洲列国的经验，意识到这将是一个长期行情，而一生中也许只能经历一次。于是，我将几乎所有的稿费积蓄都投掷于购房。这是一个特别单纯的行动，无需寻租、无需出卖。你只要有勇气和懂一些货币杠杆的知识，购入即持有，持有即出租，一有机会便抵押套现，再复循环，财富如溪入壑，水涨船高。
2003年，我决定离开服务了十三年的单位。那时是中国财经媒体的黄金时代，我设想创办国内第一份商业周刊，在此前的 2001 年，我已经写出《大败局》，在商界有了一些信誉，有人愿意掏钱投资，有 4A 公司愿意入股并包销所有广告，我把这些资源打包成一份创业计划书，与至少三家省级报业集团洽谈刊号，不出预料的是，他们都表达了极大的兴趣，但无一例外的是，他们都以国家政策为由，提出控股的要求，有一家集团表示可以让民间持有 49% 的股份，“剩下的 1% 实在不能让出来。”
但在我看来，那剩下的 1% 就是自由的边疆。
最后，我放弃了商业周刊的计划。因为，书生不能有“君王”，即便为了理想，也不行。
不能办杂志，不能办电视台、不能办报纸，但我除了办媒体又不会干别的，于是，最后只剩下一条出路：办出版。
出版的书号也是牌照资源，但它有一个“半公开”的交易市场。
有交易，就有自由，而只有自由前提下的理想才值得去实现。
于是，有了蓝狮子。从第一天起，它的股东就全数为私人。
十年以来，我一直被蓝狮子折磨。就商业的意义上，出版是一个毛利率超低、账期极长、退货率让人难以忍受的“烂行业”，在当今的三百六十行，只有它还在“先铺货，后收款”。在很长时间里，蓝狮子名声在外，但规模和效益却强差人意。不过，我却从来没有后悔和沮丧过，因为它是我的理想，而且是一个可以被掌控的理想，更要紧的是，与我的众多才华横溢的朋友们相比，我没有为了理想，出卖我的“资本自由”。
浮生如梦，这一路走来三步一叹，别别扭扭。
在我们这个国家，最昂贵的物品是自由与理想。它们都是具体的，都是不可以被出卖的，而自由与理想，也不可以被互相出卖。
自由是世俗的，它不在空中，不在别处，它就在地上。作为一个读书人，你能否自由地支配时间，你能否自由地选择和放弃职业，你能否自由地在四月去京都看樱花，你能否自由地与富可敌国的人平等对视，你能否自由地抵制任何利益集团的诱惑，这一切并不仅仅是心态或勇敢的问题，而是一种现实能力。
与自由相比，理想则是一个人的自我期许和自我价值呈现的方式。千百年来，无数中国读书人为了理想以身相许，他们把自由出卖给帝王、党派或豪门，试图以此换取自我价值的实现。在我看来，这是不值得的。理想是一个“人生的泡沫”，可大可小，可逐步实现，也可以不实现，但是，自由不可须臾缺失。加缪在《西西弗神话》中论及“人的荒诞性”，曾说，“一个人始终是自己真理的猎物，这些真理一旦被确认，他就难以摆脱。”
那么，一个人能否拥有与之制衡的能力？
加缪提供了三个结果：我的反抗、我的自由和我的激情。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>沿着最初的理想走下去</title>
    <url>/hobby-go-along-the-original-ideal/</url>
    <content><![CDATA[作者：沈杰辉
电影《10件或更少》中，女主人公是一位年轻貌美、聪慧能干的西班牙女郎，但与她终日相伴的是一家郊区小超市的“10件以下商品收银台”——她深深厌恶着那里机械而繁重的工作，以及自己无比失败的婚姻。后来某天一位老牌演员忽然闯入女主人公的生活场域，并同行整日，以其豁达性情与深厚阅历为这个25岁女孩一洗心头蒙尘，让她看见其实自己的生活没那么糟糕。
整部电影节奏温柔、文艺，且抛出一个相当有趣的数字游戏：说出10件以下你喜欢或讨厌的事情。影片告诉你，真正活得积极有味的灵魂，喜欢的事情会远远多于10件。
寻常市井中，如片中老演员那般“乐活”的姿态实属寥若晨星，多的是女主人公式平凡奋斗的年轻人群，在纷扰都市里搏未来生存的日子毋庸置疑要和无尽辛劳与烦忧形影相伴：疲于奔命、薪水不高、压力过大、工作单调、闲暇稀少……努力不去抱怨已属高度乐观，强颜欢笑从少有的闲适感里挖出10件喜欢之事显然过于梦幻。

令我们真正在意的事不多，10件或更少。我觉得对于在大都市闯荡打拼的年轻人而言，生活的天平其实并不需要那么多砝码，即使你此刻手里仅简简单单攥着一两个前行的理由，维系心灵的平衡和有序才是你应当在意的事情。何时何地，同自己的心和平相处，比什么都重要。
朋友圈里有不少刚离开大学校园、投身社会一年半载的职场新鲜人，与他们交流的若干片段剪辑在一起完全是一部反映青年心态的纪录片，一个经典的情节便是职场新人频频换工作，而其中心境平和者屈指可数。“没意思”“不耐烦”是常见的解释理由，不少人的状态全然表现为一种持续奔波的茫然，他们对自己驻扎过的每一任东家都心存不满，抱怨职业与个人志趣不合，或者自怜明珠暗投被繁琐杂事消耗青春，或者全程一无所获未得到明显技能培养……打游击式换工作一大圈，消极状态却一如从前。这一类职场新人起步时喜好不明，却格外看重自己每一步前行有什么收获，时时计算一份工作给予内心满足感的砝码分量，可谓“步步惊心”。然而反复计较砝码的得失，却不知回头审视和调整内心天平的平衡，导致年纪轻轻竟暮气沉沉，聊起工作即如怨妇。
想说说与众不同的一个。朋友J小姐自中学起便有志于媒体，高三当其他人抱着数理化题库和高考作文指南按部就班备考，她“不务正业”地挤出所有闲暇阅读报刊上的优质新闻报道。上大学担任校刊主编，在宿舍通宵达旦写稿排版，假期通通用于各大社会媒体的实习。毕业季新闻系同学都一窝蜂涌向公务员和外企，她上海的家里也托人给安排了妥舒适稳定的工作，男友留校读研，她却执拗一人拖着行李箱一路北上——那家知名媒体仅提供实习机会并没有承诺offer，“我就是喜欢做新闻，活这么多年唯有这件事带给我快乐。”背对着千里之外家人忧心忡忡的目光，J小姐白日里在偌大的北京城为了一纸新闻四处奔波，晚上回到“蜗居”租房还要对付永远堵塞的下水管道，摆弄不太娴熟的厨艺准备隔日餐食。
大学班级微信群里渐渐涌现各种晒优越感的签约消息，也有人褒贬不明地嘀咕一句：瞧，咱们班也就北漂的那位同学还有新闻理想呢。J小姐淡淡一笑，打开WORD文档继续编辑采访稿。那家知名媒体最终破例给了她offer，还记得她签三方后和我说，最喜欢杨德昌导演的《一一》，因为拍得透彻、明亮，人不可能看到生活的另一面，所以为了避免患得患失，遵从内心的喜好去选择总是没错的，心安为上。
这是几年前的事了，最近一次联系J小姐，她居然人在香港，听筒中依稀可辨四周熙熙攘攘的市井声，没想到她跑去了更远的异乡追随梦想的感召。听到故人问候，J小姐语气里满是激动，吐了一串“好开心”。聊起前程，压力大，异地恋，但暂时不打算回来。“沿着最初的理想走下去，生活的确更累了，不过精神也更安定了。”时光轻飘飘溜走好些年，J小姐生活的天平上始终只有两个砝码——喜欢，理想，可就是少得可怜的两个抽象理由让她心灵世界的运转井然有序，不汲汲于眼前得失，活得骄傲、平和而自在。
说起工作，许多青年将其理解为选择的问题。的确，如今职业选择的范围和自由度都变大了，在一处干得不如意还有若干出口和门路。但这不应成为青年逃避矛盾的万能借口，丰富的选择是为了让每个人更明晰内心真实的喜爱和在乎的人生志向，收获属于自己的生活平衡。
生活不如意事常八九，而人心自有平衡的法则。朋友J小姐执着地追随初心，安然迎接每一场征程赋予的阳光或风雪，然后更加热情有力地拥抱命运在下一个路口的安排。电影《10件或更少》中，老演员教导西班牙女孩，要不顾一切争取抓紧自己在意的任何人生砝码——比如果断甩掉沉闷的小超市去建筑公司面试——但更关键的一点是，无论故事的结尾何种选择降临，你都要学会乐在其中，享受轻重疾徐的步调，不去抱怨。这，就是我们心灵平衡的要义。
人心当有平衡的法则，生活不纠结，世道再难，也能呼吸顺畅。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>励志</tag>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>良朋益友</title>
    <url>/hobby-good-friend/</url>
    <content><![CDATA[作者：魏悌香
若干年前，英国《泰晤士报》曾出了一个谜题，公开征求答案，题目是：“从伦敦到罗马，最短的道路是什么？”很多人拿着地图研究，试着从地理位置上找答案，结果都落选了。获奖答案是：“一个好朋友。”是的，一路上有好友相伴，沿途说说笑笑，很快就可以到达目的地。
有一句话说得真好：“一个人走，走得快，但是一群人走，走得远。”的确，没有人软弱到不能帮助别人，也没有人刚强到不需要别人的帮助。人生的旅途上少不了朋友的相伴，可以一起分享快乐、分担痛苦。因为分享的快乐是加倍的快乐，而分担的痛苦却是一半的痛苦。
花一些工夫，为自己找几个志同道合的朋友，也花一些工夫，努力成为别人的朋友。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>图解博士学位</title>
    <url>/hobby-graphic-dr/</url>
    <content><![CDATA[  1、想象一下，一个包含人类所有知识的圈。   2、完成了小学学习，你知道了一点点。
  3、完成了高中，你又知道了更多一点点。
  4、获得本科学士学位后，你又知道了某一个专业知识。
  5、硕士学位获得后，你在某一专业领域进一步了解更多。
  6、研究论文是关于人类知识的某一个边缘。
  7、然后，你在这个边缘集中进行钻研。
  8、几年后，深入研究。
  9、有一天，突破边界。
  10、然后，你获得了博士学位。
  11、当然，现在对于你来说，世界看起来是不同。
  12、然而，请不要忘记最大的那个圆圈。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入浅出PMP》摘录</title>
    <url>/hobby-head-first-pmp/</url>
    <content><![CDATA[前言软件项目管理大作业：软件项目管理关键要素分析，3000字左右。找了一些相关论文和书籍，最喜欢《深入浅出PMP》一书，摘录下喜欢的内容，作业就差不多了。


项目经理职责范围《PMBOK® Guide》为项目经理定义了4个主要的职责范围：1、识别项目的需求想出让项目成功需要什么东西。2、建立可以达成的目标规划团队努力的目标以及达成目标的方式。每个人都必须同意这些目标，所以他们所作的决策才能帮助彼此成功。3、平衡项目的范围、时间及成本追踪项目执行的情况，并与先前规划的时间进度、预算及质量需求进行比较。每当你改变三者中的任何一个时，另外两个也会受影响。因此，你总是必须对三者一起管理。为了让项目成功，你必须交付你承诺会准时且在预算内完成的东西。4、满足每个人的需要与每个受到你的项目影响的人沟通。PM的大部分工作都与沟通有关。
项目管理实务《PMBOK® Guide》将良好的项目管理实务分为5个过程组：1、启动此过程组包含创建及定义项目范围初步版本的过程。2、计划这里是你计划如何管理项目各个方面的地方，包括范围、风险、时间、成本、质量等。3、执行这里是完成所有工作的地方。在执行过程组中所产出的东西会在下一个过程组中被监视。4、监督及控制与计划作比较及根据需要进行调整后所得到的建议。查看从执行过程组所产生的输入，并持续与计划比较。这会帮助你在该做什么能让项目保持在正轨上进行决策。5、收尾一旦工作完成，你必须做好必要的文书工作，以便公司对你的所作所为有记录。你还应该确认你的团队被空出，以便他们去做其他项目。
知识领域9个知识领域贯穿5个过程组：1、风险为可能发生的（正面或负面的）事情预做规划并且在事情发生时处理它们。2、质量确保你在建立正确的产出并且尽可能有效率。3、范围定义项目会（以及不会）完成的任务。4、采购定义合约内容并且选择承包商来做你的项目。5、沟通建立信息流通的管道，让每个人对项目的相关信息都有清楚的理解。6、时间预估完成项目所需花费的时间并确保在所定的项目最后期限内完成项目。7、整体让所有人朝相同目标前进并且处理变更。8、成本为项目做预算并且追踪正在花费的金钱。9、人力资源找到执行项目工作的人并且激励他们。
整体管理《PMBOK® Guide》将整体管理分成7个过程，通常，人们认为它们是项目经理的“核心”职责。1、制定项目章程新项目要完成的第一件事情就是项目章程的制定。那是授权你进行工作的文件，但是它的产生并非总是牵涉到你——往往它是由赞助人直接交给你。没有项目章程，你就没有权力告诉团队成员应该做什么以及什么时候做。
2、制定初步范围说明书这是展示项目所有目标的文件，你在开始计划项目之前创建它——那就是它是“初步”的原因。当你对项目越来越熟悉，你就会想到更详实的项目范围。
3、制定项目管理计划项目管理计划是整个《PMBOK® Guide》最重要的文件，因为它指导所有发生在项目上的事。它包含所有的知识领域。项目管理计划的绝大部分是关于当问题出现时该如何处理变更。
4、指导与管理项目执行完成计划之后就要执行工作了。你的工作是确保每个人正在做他们应该做的事，以及项目创建的产品或服务满足所有利益相关者的需求。
5、监督与控制项目工作好的项目经理持续监督项目中进行的每一件事。记住，越晚发现问题，修复起来通常就越困难，越昂贵。
6、整体变更控制一旦发现项目有问题，你必须和利益相关者及赞助人协同合作，找出应对之道。你还应该更新项目管理计划，以反映出为完成项目所需采取的额外步骤。更新项目管理计划也可以确保执行项目工作的每个人对项目现况有共识。
7、结束项目你对项目所做的最后一件事就是将它结束。确认你对所有事情做好文档化工作……特别是你和团队一路上所学到的经验。你不会知道这些经验什么时候会在其他项目中帮上忙。
这7个过程分别属于5个过程组。制定项目章程、制定初步范围说明书属于启动过程组；制定项目管理计划属于计划过程组；指导与管理项目执行属于执行过程组；监督与控制项目工作、整体变更控制属于监督与控制过程组；结束项目属于收尾过程组。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《自然史》</title>
    <url>/hobby-histoire-naturelle/</url>
    <content><![CDATA[这是一本很有意思的书，但是实在是太厚了！于是，写了一点点笔记就停下了，我还是安静的看书吧……
马是所有身材高大的动物中，身体比例最匀称、最优美的。
驴时常能够无畏地忍受惩罚和鞭挞，而且对食物质和量的要求也不高；它习惯于最坚硬、最难下咽的草，而这些草是马和别的动物吃剩的，不屑一顾的。驴对子女有强烈的爱心，害怕水。


人工喂养的兔肉，味道总是不佳，受到追赶喜欢往高处跑。
狐狸喜欢吃葡萄。
獾（huan读一声）貘（mo读四声）
河狸：勤劳，建筑师。
鸽子：它们对伴侣有着持久的热情，从不互相厌烦，不发任何脾气，没有任何争吵，它们共同承担所有的事情，雄鸽甚至会与雌鸽轮流孵卵，呵护幼鸽，以便减轻妻子的辛劳。
金丝雀，养鸟的最佳选择。
鹡鸰，“洗衣鸟”，“牧羊鸟”。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>望子成人</title>
    <url>/hobby-hope-sun-be-a-man/</url>
    <content><![CDATA[作者：易中天
我既是一个教书匠，就来说说中国教育的问题。
几年前，在北京《经济观察报》的一个论坛上，当时有一位演讲嘉宾是教育家杨东平，我说请问杨先生，中国教育和中国足球哪个更有希望？他想了半天说，教育吧。我说为什么？他说足球没有希望也就算了，教育不能没有希望。
问题是，我们要考虑的是中国教育是不是大幅度、大面积地提高了我们整个国民的素质。而现在我看到的是什么呢？是中国教育整个把人脑子搞坏了。中国教育和中国文化的问题一样，是弱智化。搞坏的原因是什么呢？是我们的教育评价目标就是“成王败寇”四个字，就是你如果得了诺贝尔奖就是好，没有得奖或者奥数没有得奖就不行。就是一成王败寇，急功近利，见利忘义，忘掉了教育的根本目的。
这种成王败寇的评价标准的结果是不把学生当人，望子成龙，望子成材，望子成器。龙是什么？怪兽。材是什么？木头。器是什么？东西。就是你要成怪兽，你要成木头，你要成东西，就是不要成人。现在口口声声以人为本，最应该以人为本的应该是教育，可是在中国，最应该以人为本的领域最不把人当人。

你看看我们现在的孩子过的什么日子。有一家媒体报道说，夫妻两个白天平时工作比较忙，到了国庆长假，孩子问爸爸妈妈能不能花一天时间陪我到游乐园玩一下。夫妻两个开了一夜的遵义会议，最后咬紧牙关，下定决心，拿出一天时间陪孩子上回游乐园。做了第一个游戏，孩子挺高兴。妈妈就问，好玩吗？好玩。那回去就可以写篇作文了吧。孩子当场脸就拉下来，然后垂头丧气去做第二个游戏。做完第二个游戏妈妈又过来了，问，第二个游戏好玩吗？好玩。那你可以写一篇精彩的作文了吧。孩子说，妈妈我不玩了。一天玩的时间都不给孩子，就盯他的作文，口号是不能让孩子输在起跑线上。那我想请问：人生的终点线在哪儿？殡仪馆。所以从上到下，从教育行政部门到家长，全都是望子成龙。所以现在我旗帜鲜明地提出来，我反对励志，反对培优，反对成功学，反对望子成龙。
我的口号就是今天的主题，望子成人。什么人？真正的人。有标准吗？有，八个字，第一真实，第二善良，第三健康，第四快乐。
首先说真实。有人说不可能。这年头你还能全说真话，不说假话。我说能，因为我的真实标准是不说假话。有人说，那你说的全部是真话？我说是。他说那不可能，说真话要倒霉的。我说很简单，你觉得这个真话说出来要倒霉的话，你可以不说。康德说一个人所说的必须真实，但是他没有义务把所有的真实都说出来。因此真实的办法很简单，就是你觉得这个真实是不可以说的，你就不说，然后假话你也不说，剩下的全都是真话，这就是真实。
第二是善良。善良不是说要你到街头去做什么义工，或者学雷锋的那天去扶老太太过街。善良的底线是恻隐之心。恻隐之心就是不忍之心，不忍心人家受到无辜的伤害，包括对小动物。所以不但不能行凶杀人，也不能虐待小动物。我们要在法律上保证公民的恻隐之心不受伤害。
第三是健康。身体健康和心理健康，而心理的健康比身体的健康更重要。
第四个就是快乐。快乐是非常重要的。在孔夫子那里，做人的最高境界是仁，做事的最高境界是权（权衡），治学的最高境界是乐。知之者不如好之者，好之者不如乐之者，快乐是最高的境界。其实人很简单，成功不成功，是否出人头地，是否光宗耀祖，都不重要，重要的是你是否快乐。（孔子说）一箪食，一瓢饮，在陋巷，人不堪其忧，回也不改其乐。——最后是快乐。
比方说现在为什么千军万马过独木桥，大家都要去考公务员呢？我非常同情大学生毕业以后挤破脑袋去考公务员，虽然我不赞成，但是我非常理解非常同情，他缺乏的是安全感。有一个农村来的孩子就这样对记者说的，我也不想考公务员，但是我爸我妈让我考。我爸我妈说，孩子，你要考上公务员，咱在村里就不受欺负了。他要的就是一个安全感。
所以我们的社会应该给每个公民提供足够的安全感，让每个公民有足够的尊严，不管他从事哪个职业，不管他在哪个岗位上，他都是一个安全的、有尊严的人，这样他才能快乐。这就是我对中国教育的希望。我希望中国教育能让我们每个孩子，中国改革、中国社会能够让我们每个中国公民都成为真正真实的人，善良的人，健康的人，快乐的人，这就是我的中国梦。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>《从你的全世界路过》摘录</title>
    <url>/hobby-i-blonged-to-you/</url>
    <content><![CDATA[总有几分钟，其中的每一秒，你都愿意拿一年去换取。总有几颗泪，其中的每一次抽泣，你都愿意拿满手的承诺去代替。总有几段场景，其中的每幅画面，你都愿意拿全部的力量去铭记。总有几句话，其中的每个字眼，你都愿意拿所有的夜晚去复习。
我希望买的鞋子是你渴望的颜色。我希望拨通电话时你恰好在想我。我希望说早安你也刚起床。我希望写的书是你欣赏的故事。我希望关灯的刹那你正泛起困意。我希望买的水果你永远觉得是甜的。我希望点的歌都是你喜欢唱的。我希望我希望的是你希望的。


看到小清新不要说矫情。看到二逼段子不要说脑残。看到文艺范不要说装X。看到诗歌不要说无病呻吟。看到意识流不要说傻X。每个人有自己的表达方式，如果你不喜欢，只能说明不是为你准备的。你可以不接受，这是一种自由。但不屑和抨击，翻到另外一个世界观，只能说明你的无知和武断。
我知道自己喜欢你。但我不知道自己将来在哪里。因为我知道，无论哪里，你都不会带我去。我知道你喜欢我。但我不知道自己将来在哪里。因为我知道，无论哪里，我都没法带你去。
世事如书，我偏爱你这一句，愿做个逗号，待在你脚边。
故事开头总是这样，适逢其会，猝不及防。故事的结局总是这样，花开两朵，天各一方。
我想和你生活在一起，永远。
遇到事情的时候，就问自己，会不会死？不会。那去他妈的。会。我靠那不能搞。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>IE首页被篡改解决办法</title>
    <url>/hobby-ie-homepage/</url>
    <content><![CDATA[解决办法1:使用360。
解决办法2:1.起始页的修改。展开注册表到HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Explorer\Main，在右半部分窗口中将”Start Page”的键值改为”about:blank”即可。
同理，展开注册表到HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\Main，在右半部分窗口中将”Start Page”的键值改为”about:blank”即可。
注意:有时进行了以上步骤后仍然没有生效，估计是有程序加载到了启动项的缘故，就算修改了，下次启动时也会自动运行程序，将上述设置改回来，解决方法如下:运行注册表编辑器Regedit.exe，然后依次展开HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Run主键，然后将下面的”registry.exe”子键(名字不固定)删除，最后删除硬盘里的同名可执行程序。退出注册编辑器，重新启动计算机，问题就解决了。
2.默认主页的修改。运行注册表编辑器，展开HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Explorer\Main\，将Default-Page-URL子键的键值中的那些恶意网站的网址改正，或者设置为IE的默认值。
注:如果无法修改,请进入安全模式。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
  </entry>
  <entry>
    <title>清白家风</title>
    <url>/hobby-innocent-family/</url>
    <content><![CDATA[作者：子沫
现在是最关注教育的年代，也可以说是最没有教育的年代，因为分数代替了教育，疯狂追求效果的快餐社会，让家风和家教都荡然无存。这不能不说是一个大的缺憾。
前段时间，重读寿岳章子的京都系列之一《千年繁华》，一个日本的女教授，从出生到去世，一直生活在京都古城，写这本书时，她住在父母留下的一栋老房子里已五十四年了，这栋房子盖得非常好，通风状况不错，夏天可以不用空调。这书是她回忆自己在京都生活的点点滴滴。我喜欢这本书，很大程度上却是被她的家风和家教所打动。在一个小城，满满当当小家情怀和世间情谊。
她说，我的双亲并非生性奢华，但对饮食非常讲究。如何吃表现寿岳家的生活精神。
她家里六席榻榻米中间摆了一张矮饭课，代表着家里的某精神象征。无论是吃饭还是喝茶，全家人都会聚拢在这张餐桌周围。开心地谈天说地。有时候，只需一张桌就可聚拢一家人，可是，很多人家里有豪华的餐桌，却常常失去了温馨的氛围，这是钱买不来的。

“家里很多年一直用火盆，生火是父亲的拿手绝活，将前一天晚上埋入灰烬里的火种稍微翻弄一下，添少许木炭，黑炭会慢慢烧红，热水壶也跟着发出腾的响声。烤土司面包，年糕，鱼干，孩子们围绕在母亲身边，也常常烤海苔，一有香味传出，父亲就会从书房走出来：煮什么东西？算我一份吧。”这样的场景真是令人神往。一家人动手做点什么，吃是一件共同的事，一件循序渐进的事，一个过程。
她说起一道母亲常做的料理“山药泥”，这个段落我看了几遍。“母亲去世后，我动手做过两三回，每次我总是边做边流泪。从前这可是一道充满欢乐的料理。山药放在大研钵里研磨一两千下，再加入高汤，从这步骤开始就是全家总动员，四个人都到厨房集合，研钵放在厨房地板上，我或弟弟负责扶稳研钵，母亲一点一点将一大早就熬好的汤，沿着钵体的边缘缓缓加入。使用大量昆布和柴鱼煮出来的高汤比清汤味道浓些，如果一开始全部倒入，山药泥和高汤的美味无法自然调和在一起，将高汤缓缓倒入研钵后，听到父亲指示，再打一颗蛋到研钵里，使用研磨棒时不可以粗鲁地碰撞到研钵体的边缘或底部，正确的力道是让棒轻轻游走在山药泥间。这道料里是父亲的家族传承下来的，制作工程相当复杂。”做好后，每个人的白米饭里浇上山药泥，一家人一起品尝，胃口大开，欢声笑语。这个过程，怎么看都像是一种神圣的仪式，父母能够给孩子留下什么？钱？房子？海外留学？统统不是，这些太过表像，很多年后，能够留下的只是某种对事对物的珍重和珍惜。我们在丢失什么？情怀，耐心，还有万事万物的敬畏。
“关于要不要在家吃饭这件事，如果说好要在家吃饭就绝对要遵守约定，这在我们家可是铁的纪律。有一次母亲发了很大脾气，就是因为父亲不回吃饭没打招呼：从结婚那天开始，我跟你父亲一起生活的时日就一天天减少，所以每一天都是非常珍贵的。正因为如此，我才想和心爱的人多点时间一起用餐，但是他却不明白我的心意，所以，我才会这么生气。”这句话让章子记忆深刻，也真的让我震惊，家也是要有纪律的，每个家都要有精神，这个精神是别人怎么变，我们家仍然在坚持属于我们的纪律。
寿岳家的餐桌就像是心灵交流的场所。
每个季节的佳肴，初夏时节，白萝卜的叶子细嫩铺满白米饭，初秋时的细姜丝淋上麻油。四季流转。情怀分明。在餐桌间细细流淌。
还有一些被人忽略的细节，而这些细节也是真正的教养所在。有人说，这是个有教育没有教养的社会，所以才会出现越来越多的问题儿童，问题中年，问题老年。
有一个削苹果的细节：“母亲要求削苹果时手不能碰果肉，切成两半，果蒂切成小三角形，切半的水果再对切，即可去皮，将切成四分之一大小的水果端出，手碰到果肉，就犯了母亲的大忌。现在，每当我看到别人切水果，就会用不怀好意的眼神观察”。只是一个削苹果的细节，却能观察一个人的教养。就像我看到有的女人把“不抖腿”列入了孩子的家教，一个人，最容易引起别人反感的也是一些细节不到位吧。一个人成不成功并不重要，重要是不要成为令人讨厌的人。
“每天使用的抹布一定要煮沸消毒好几次，厨房要彻底打扫干净，洗菜和洗碗的地方不可混用。钱不可以直接放餐桌上”他们家还有很多诸如此类的生活纪律。“若非长途旅行，绝不会在电车上吃东西，不仅吃相难看，最重要是非常不卫生。现在年轻妈妈们太漫不经心了。出租车司机说小孩把冰淇淋，巧克力弄得到处是；餐厅里小孩胡乱碰盘子，玩弄食物，没有一点用餐的卫生观念，这是我母亲最不喜欢看到的。对于这件事，专注且全心全意。绝对遵守餐桌礼仪。”这才是家风，从小就要求做到的，长大再去做就成了自然而然的事。我在想，为什么有些人看上去那低调谦和，舒适如沫春风，都是有道理的。他们活在一个良好的家教环境里，这个也是与钱无关的。餐桌就是一种家教，只不过被太多人忽略或认为不重要罢了。
“我们常用外出踏青，母亲带出来的爱心便当，特别收藏的糖果盒里，撒上黑芝麻的饭团。多层餐盒里则是竹笋，水煮蛋，木盒的沉香味。我们从不跑太远去旅行，顶多是回父亲的故乡。旅行的大半乐趣来自于母样亲手做的饭团便当。”真好，木盒的沉香味，这样有爱心便当的旅行，让孩子们明白了家的乐趣，而不是钱的乐趣。旅行只是换个地方用餐罢了，并不是你到过什么很高大上的地方，吃什么昂贵的大餐，一家人在一起就很开心了，在免费的绿水青山中，晒晒太阳，呼吸新鲜的空气就好，很多东西真的是钱买不来的。人与人最大的区别是钱买不来的东西你拥有多少？
还有一个关于全家大扫除的情景让我记忆深刻。“一家人的大扫除可说是精彩万分。父亲带头，上半身披上一条大浴巾，下半身一件短衬裤，威风凛凛地出场。用旧棉布制作掸子，用旧毛巾缝制作抹布，毛巾折三折，大针脚夫缝合起来，我目前积存了两百条亲手做的抹布。除了一般湿抹布外，还有好几条干用抹布，擦走廓的，桌子，橱柜的，分门别类到有点复杂的程度。”连抹布都是亲手制作，都能留有回忆，一家人齐齐动手去做一件事。这样的事某种程度上已成了一个家庭事件。真是精彩，有滋有味。
我记得章子提到的这样的场景：“春天的时候，母亲开始在院子里晒布，缝衣。我也永远忘不了母亲在茶室中，面向南面窗户缝制和服的背影，同样的背影也会出现在书房，她在书房中做翻译，或替父亲的诗集上色。总之，我家的家风就是勤奋，认真地生活。”
勤奋，认真并不是过时的词，它才是最好的清白家风。他们只是普通人家，却有着平实的家风。这种家风才是孩子们最重要的成长养料。
细雨的夜晚，这个住在古城里几辈子的人家深深地打动了我。他们也只是普通人。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>安装系统之激活</title>
    <url>/hobby-install-os-active/</url>
    <content><![CDATA[前言纯净系统安装后肯定需要激活，除非是升级系统；ghost系统安装后，一般不需要激活，个别情况下需要激活。
winXP现在，安装winXP的小伙伴已经极少极少。考虑到使用虚拟机的情况，还是分享一下激活密钥和激活工具吧。
正版密钥：MRX3F-47B9T-2487J-KWKMF-RPWBYHTXH6-2JJC4-CDB6C-X38B4-C3GF3 RT4H2-8WYHG-QKK6K-WWHJ2-9427X DYPVX-43TRT-YDBGB-7YQJX-CWXW7 HGM7B-YF7T7-8R7RF-Y6RPY-XTQ77 Windows XP专业版最新注册码 DJQJB-PC83T-FTGJC-CQTCK-RJD8D VMMBM-8WK8W-H44YH-37B4M-KX8QR XRCTF-Y68KJ-VVFTR-7BDFP-4PW7G 6RV7B-FYWR2-PW3C6-DDWDR-68X9C KYMTD-BV7KP-RRM33-P3XKJ-RDKVD X3WYK-H7CR8-KQBMV-7DP6X-W6YQQ CQWK3-CCYJY-TQDFV-2HJDR-W3B2M 2RXYJ-VQWXM-J2V2R-CVXQT-Y6MPY X7TVH-VJTFG-BK22B-XXG6D-27326 VYGXV-YM8VB-4RVQX-QXBMX-G3WV7 4DP2D-CXW4C-TRYDH-CW4CT-PT23X R6M6K-HT7G7-XG4K4-66PGK-9V2RM 86VYW-4RHCG-CCC7Y-64MWM-V8B68 VPM77-Y3YJW-W4MFC-CQTCK-D2XGK K3JD6-DK6G4-YH32B-QT7VP-R8WC7 JRMCK-J3V37-YVCYH-MDJ37-94BHP KJ3XK-3B6KW-XK62M-VDC7W-DJ6V9 WindowsXP可以无限次激活的号码 CXGDD-GP2B2-RKWWD-HG3HY-VDJ7J RK7J8-2PGYQ-P47VV-V6PMB-F6XPQ
激活工具分享：http://yunpan.cn/cKvVDSmX7xBJU  提取码 788e


win7下面这个工具，是郝同学用过的最好用的win7激活工具，屡试不爽！激活工具分享：http://yunpan.cn/cKvjwPMn4NCDA  提取码 a281
win8win8是今后的趋势系统，下面这个工具，是郝同学认为最好用的win8/win8.1激活工具！激活工具分享：http://yunpan.cn/cKvxrq86aFTkX  提取码 8b0b
小结激活方法不止一种，以上提供的工具，都是郝同学亲测可用的。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>安装系统之常见问题</title>
    <url>/hobby-install-os-common-question/</url>
    <content><![CDATA[双击autorun.exe无效系统不兼容，比如，在win8系统下，安装win7，大部分都会失败。解决办法：直接双击ghost.exe文件，如果还是报错，就换U盘安装或者光盘安装。
无法从U盘启动解决办法：百度当前机型的BIOS设置方法，不断尝试。
在winpe下无法打开ghost解决办法：换其他winpe系统。还是不行，就换一个启动盘制作软件，比如老毛桃。
安装系统进度条终止解决办法：换一个系统镜像。如果还是安装失败，换一个U盘，重新制作启动盘。
小结安装系统的过程中，遇到的问题会很多。百度吧，哪怕不能找到答案，也会带给我们很多启发。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>安装系统之双系统</title>
    <url>/hobby-install-os-double-os/</url>
    <content><![CDATA[前言安装双系统，和安装单一系统类似。有时候会失败，如果实在没办法了，就安装虚拟机吧，也是个不错的选择。
windows下安装windowswindows下安装windows，前提，要有两个以上主分区，而且都是活动的。安装成功后，在当前系统下。单击计算机，右击，属性，高级系统设置，高级，启动和故障恢复下的设置。设置默认操作系统和操作系统列表显示时间。
windows下安装linux在硬盘上划分出一块空白区域，不要格式化。然后，从启动盘开始安装linux，安装到那一块空白区域。
windows下安装mac这个，有难度。尤其是非Intel处理器，基本都会失败。Intel处理器的小伙伴，可以搞一搞。话说郝同学前前后后花费了一周左右，也没有安装成功，惭愧惭愧，继续努力。。。
linux下安装linux关键在于启动配置文件的修改。
linux下安装windows挂载、分区、引导等等，总之很复杂。建议使用wine，模拟windows环境，然后就可以一步步往下安装了。
Mac下安装windowsmac下安装windows比较简单，看来苹果公司非常人性化。前提，准备好纯净系统镜像。以下内容摘自百度经验，亲测可用。
步骤一：进入苹果系统，左上角，前往，实用工具，BootCamp 助理，继续

步骤二：1.选第一项，创建win7或更高版本的安装磁盘，这是用苹果自带工具做U盘启动。需要把win7 64位纯净版ISO镜像文件放在桌面，插入U盘（最好是2.0的U盘）大概需要15分钟左右（不要以为卡死了，等着就好，一次没有做好的话重新做就可以了，做U盘启动会格式化U盘，注意备份）U盘启动做好之后选第二项
2.第二项，从Apple下载最新的windows支持软件此为苹果电脑的win7驱动，根据网速大概20分钟，别着急，注意路径（装好win7后要安装此驱动，可以下到U盘上）；（注意：13款的air装win7必须把驱动下载到做U盘启动的U盘内，否则进入win7后触摸板和鼠标将不能使用，或者使用这个方法，见链接教程：http://www.macx.cn/thread-2098963-1-1.html）驱动下载好之后选第三项
3.第三项，安装win7或者更高版本，下一步；
4.划分win7系统和mac系统空间大小，可以均等分割，也可以根据自己的使用习惯分；
5.点击安装，系统会分区，然后系统会自动重启，进入win7安装界面，根据提示操作（如果提示：请使用64位安装系统、或者重启后显示no bootable device–insert boot disk and press any key，说明可能刚才做的U盘启动不识别，重新做一次，如果还是不行，换U盘重新做）
步骤三：选择自定义——选择分区BOOTCAMP（千万选对了，千万别把mac系统给格式化了）——驱动器选项 高级——格式化——确定
然后就开始装系统了，大概需要30分钟，之间会重启多次，然后就进入系统了，win7就装好了
步骤四：安装win7驱动，在win7系统下找到刚才的下载的驱动（应该是个文件夹BootCamp），打开，有个setup.exe程序，双击根据提示安装就可以了，大概5分钟
小结上面已经把安装双系统的重点点明了，搞不定的话，百度更详细的教程吧。这次，郝同学就不展开了，内容实在太多。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>安装系统之驱动</title>
    <url>/hobby-install-os-drive/</url>
    <content><![CDATA[基本概念设备驱动程序，是一种可以使计算机和设备通信的特殊程序，是硬件厂商根据操作系统编写的配置文件。相当于硬件的接口，操作系统只有通过这个接口，才能控制硬件设备的工作，假如某设备的驱动程序未能正确安装，便不能正常工作。
因此，驱动程序被比作“ 硬件的灵魂”、“硬件的主宰”、和“硬件和系统之间的桥梁”等。
常见驱动问题界面变丑还记得第一次安装完系统，开机之后，我靠，那些又大又模糊的图标是怎么回事？！分辨率无法调节是怎么回事？！后来终于懂得，显卡驱动没装好。
无法使用网线联网网卡驱动没有安装好。
无法使用无线联网无线网卡驱动没有安装好。

驱动安装工具windows和linux的驱动安装方法不同，linux更加复杂。以下工具适用于windows。
系统自带单击计算机，右击，管理，设备管理器。
驱动精灵感觉最顺手的一个驱动管理软件。
驱动人生也是很好用的一个驱动管理软件。
小结在学习汇编的时候，曾经想要开发驱动程序，后来发现，太难了！！！驱动，会安装就够了！
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>安装系统之分区</title>
    <url>/hobby-install-os-partition/</url>
    <content><![CDATA[初学者很容易把重新分区和重装系统搞混，这里简要说明一下。大部分内容摘自百度百科。
基本概念MBR（Master Boot Record）下的硬盘分区有三种，主分区、扩展分区、逻辑分区。
一个硬盘，主分区至少有1个，最多4个，扩展分区可以没有，最多1个。且主分区+扩展分区总共不能超过4个。
扩展分区不能直接使用，扩展分区可以分为若干个逻辑分区，最多分为23个逻辑分区。
逻辑分区的信息都被保存在扩展分区内，而主分区和扩展分区的信息被保存在硬盘的MBR内。
在windows下，激活的主分区是硬盘的启动分区，他是独立的，也是硬盘的第一个分区，正常分的话就是C区。 
在linux下，主分区和逻辑分区都可以用来放系统，引导os开机，grub会兼容windows系统开机启动。在linux中，第一块硬盘分区为hda分区，主分区编号为hda1-4，逻辑分区从5开始。

分区格式windowsFAT16、FAT32、NTFS、exFAT等。应用最广泛的是NTFS，我们使用的电脑分区，基本上都是这个格式的。FAT32格式也很常用，常用于做启动盘，但是单个文件大小不能超过4G。
安装linux的时候，前些年，必须从FAT32分区或者linux专用分区读取安装数据，否则无法识别。4G的限制，导致很多linux安装起来很费劲。近两年，不少linux版本，已经可以支持读取NTFS分区上的数据，更加人性化了。
linuxExt2、Ext3、Linux swap、VFAT、Ext4等。最开始搞linux的时候，每种类型的分区应该分多大，对系统运行有很大的影响，不能马虎。现在好了，安装linux的时候，系统会给出建议分区大小，基本不需要修改，更加平民化。
初始分区新买的电脑，大都有自带的系统，常见的有win8和linux。这些电脑，都是分好区的，但是，分区的方式不一定是自己满意的。
比如，win8下，你想要D盘200G，但是，自带系统分了100G。这时，可以在当前系统下修改分区，也可以进去winpe之后修改分区。
比如，linux下，你想改成win8系统。这时，可以通过winpe重新分区，然后安装win8系统。

分区方式分区分为两种：有损分区和无损分区。
有损分区我们常说的分区，一般指的是有损分区。有损分区会清除掉硬盘上所有的数据，所以，分区之前，请备份好数据。
无损分区无损分区指的是，在分区过程中不会损失数据的分区方式。假设，我们想把F盘分成两个盘：F盘和Z盘。这时候，可以把数据集中在F盘，空闲的部分分出来，成为Z盘。
分区工具以下工具适用于windows。linux下，需要分区时查找一下分区命令就好。
系统自带分区工具单击计算机，右击，管理，磁盘管理。这个工具支持无损分区。
DiskGenius郝同学最喜欢的一款分区工具，非常强大。专业版支持硬盘格式转换，牛逼的掉渣。最适合在winpe下使用。
无损分区助手顾名思义，这款软件软件适用于无损分区。
小结分区，很有学问，细节上的东西，郝同学不再展开，感兴趣的小伙伴自行百度。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>安装系统之纯净系统和ghost系统</title>
    <url>/hobby-install-os-pureos-and-ghostos/</url>
    <content><![CDATA[前言微软的原生系统，被称为纯净系统；什么中关村、雨林木风、绿茶系统、新萝卜家园、深度技术等等，出品的系统，都是ghost系统。
纯净系统纯净系统，里面没有QQ、迅雷、酷狗等软件。安装完成之后，桌面上只有一个图标——回收站。纯净系统的安装，和ghost系统类似，也有三种方式。
硬盘安装下载纯净系统镜像，解压，双击setup.exe，按照提示安装。
U盘安装在winpe下双击setup.exe，按照提示安装。

光盘安装从光盘启动后，按照提示安装。
ghost系统ghost系统，里面有很多自带的软件。网上给的教程，基本上都是ghost系统的安装教程。郝同学也写了一篇，请移步http://voidking.com/【专业】安装系统之三种方式/
小结如果没有特殊需求，建议安装ghost系统，简单方便。郝同学也制作过ghost系统，制作方法很简单。但是，如果想要制作出想雨林木风那样的系统镜像，还是有难度的。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>安装系统之概述</title>
    <url>/hobby-install-os-start/</url>
    <content><![CDATA[前言12年，开始接触安装系统。三个年头了，安装的系统，数量过百是肯定的。遇到的各种奇葩问题，数不胜数。winXP，win7，win8，各种版本的Linux，MacOS，安卓手机第三方rom……都研究过一段时间。今天，简单总结一下安装系统的方法，希望对想学习的小伙伴有点帮助。


操作系统理解
三种方式安装系统的教程有很多，最常用的有三种方式：硬盘安装，U盘安装，光盘安装。更多内容参考安装系统之三种方式
分区初学者很容易把重新分区和重装系统搞混，实际上，它们是相关但完全不同的两件事。更多内容参考安装系统之分区
驱动驱动是连接操作系统和硬件的程序。驱动安装不好，计算机会出现各种问题。更多内容参考安装系统之驱动
纯净系统和ghost系统微软的原生系统，被称为纯净系统；什么中关村、雨林木风、绿茶系统、新萝卜家园、深度技术等等，出品的系统，都是ghost系统。更多内容参考安装系统之纯净系统和ghost系统
激活纯净系统安装后肯定需要激活，除非是升级系统；ghost系统安装后，一般不需要激活。更多内容参考安装系统之激活
不同平台Windows、Linux、MacOS、手机rom，不同的平台，安装方式有一些差别。更多内容参考安装系统之不同平台
双系统安装双系统，和安装单一系统类似。更多内容参考安装系统之双系统
常见问题安装系统，难得一帆风顺。遇见问题，解决问题！更多内容参考安装系统之常见问题
结束语几篇短文，不可能面面俱到，有任何问题，欢迎给郝同学留言。
如果想换系统了，那么，备份文件，然后大胆地去折腾吧！重装系统后，也许，你的电脑无法开机了；或者，你的电脑没有声音了；或者，你的电脑无法联网了；或者，你的电脑分区变奇怪了……也许，你的手机无法拍照了；或者，你的手机无法打电话了；或者，你的手机会自动关机……这都没什么，郝同学遇到过更多奇葩的问题，有些几乎无法用语言描述！解决这些问题的过程，你会学到的东西不止可以解决这些问题。
不下水，是永远无法学会游泳的。也许会被呛到，也许会喝几口池水，也许会被人笑话……没关系，最后，我们获得的技能必然是牛逼的，一切都是值得的！
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>安装系统之三种方式</title>
    <url>/hobby-install-os-three-method/</url>
    <content><![CDATA[前言安装系统的教程有很多，最常用三种方式：硬盘安装，U盘安装，光盘安装。
硬盘安装从硬盘安装系统，是最简单的一种方式。这种方式，前提是原系统可以正常开机。
步骤一：下载镜像我们以安装win8为例。1、打开浏览器，然后在地址栏输入一个搜索引擎网址，比如百度。2、在搜索框输入“win8镜像”，单击第一个搜索结果。3、选择一个镜像，进入下载页4、找到下载链接，下载镜像，大小一般在2g到4g，文件名称为*.iso。5、解压下载好的镜像。

步骤二：安装系统1、双击autorun.exe，选择打开ghost安装器。2、在ghost安装器界面，选中需要安装系统的盘符，以及刚才解压出来的win8.gho映像。单击“执行”，安装系统就开始了。3、系统重启几次后，系统安装完成。这个过程，10到30分钟。
U盘安装从U盘安装系统，是最常用的一种方式。如果你的系统彻底崩溃了，或者你想分区后再重装系统，这种方式是很好的选择。
步骤一：下载镜像这个步骤的操作方法和硬盘安装步骤一相同。
步骤二：制作启动盘1、将U盘插入USB接口。2、下载启动盘制作工具，我们以U大师为例。进入U大师官网，然后下载U大师。
3、安装U大师，并启动。4、制作启动盘。
步骤三：拷贝映像步骤一中，我们解压出的文件中有一个win8.gho，复制win8.gho映像到U盘。
步骤四：从U盘启动1、将做好的启动盘插入USB接口。2、点完开机键，狂按F12（一般的品牌机，选择启动项的键都是F12）。出现启动项选择界面，一般可供选择的有光驱、硬盘、网络、可移动磁盘（U盘）。这里我们选择从U盘启动。3、如果按F12没有出现启动项选择界面，请参考下列启动按键。4、如果还是没有出现启动项选择界面，或者出现了启动项选择界面，但是没有从U盘启动这个选项。这时，就需要设置BIOS。不同机器的BIOS差别较大，不展开讲了，给出两个参考，分别来自百度经验和U大师。
步骤五：进入winpe1、假定步骤四我们已经成功完成，这时候，我们会看到下面的界面。
2、有时间的话，这上面的选项你可以挨个试试。这里我们选择【01】进入。
步骤六：安装系统1、winpe系统会自动弹出一个软件——U大师智能快速装机。安装源我们选择U盘里的win8.gho。
2、单击上图中的开始，安装系统开始。
3、系统重启几次后，系统安装完成。这个过程，10到30分钟。
光盘安装从光盘安装系统，是最传统的一种方式。这种方式的前提是，你的电脑要有光驱。
如果，你有系统盘（无论是自己做的，还是从商店买的），那么直接插入光驱，然后从步骤三开始往下看。我们这里假设你没有系统盘，有一张4g的空白光盘。
步骤一：下载镜像这个步骤的操作方法和硬盘安装步骤一相同，需要注意的是，这里不需要解压。
步骤二：制作系统盘1、将空白盘插入光驱。2、下载安装光盘刻录软件，这里郝同学使用的是UltraISO。3、打开UltraISO，将下载的镜像文件*.iso刻录到空白光盘。4、刻录完成后，系统盘也就制作完成了。
步骤三：从光盘启动1、将系统盘插入光驱。2、点完开机键，狂按F12。出现启动项选择界面，我们选择从CD-ROM启动。
步骤四：安装系统选择“安装win8系统到C盘”，开始安装系统。系统自动重启几次，安装完成。在这个界面，我们也可以进入winpe，然后分区或者安装系统。
小结所谓的不同方式，说白了，不过是安装源的存储介质的区别。
还有其他的安装方式，下面再给出两个：1、移动硬盘这种安装方式和从U盘安装类似，甚至，你可以把系统安装在移动硬盘，随身携带。
2、网络在安装linux的时候，可以通过网络获取最新版。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>安装系统之不同平台</title>
    <url>/hobby-install-os-various-platform/</url>
    <content><![CDATA[前言Windows、Linux、MacOS、手机rom，不同的平台，安装方式有一些差别。
Windows这几篇关于安装系统的短文，大都是关于windows的。
LinuxLinux的版本非常多，主流的版本，郝同学都试用过。个人比较喜欢的有CentOS、Ubuntu、Fedora。很多教程喜欢用RetHat，郝同学想说，作为一个商业版linux，RedHat的各种限制会让你吐血。。。如果想学习linux，从CentOS入门吧！至于教程，力荐《鸟哥的linux私房菜》。
镜像下载不同版本的linux镜像，在各自的官网上就可以下载到。也是以“.iso”结尾的文件。
硬盘安装使用频率较低，如果你现在使用的系统是linux，想要安装双系统或者安装新的linux，可以从硬盘安装。
U盘安装从U盘安装，是linux最主流的安装方法。这个方法的重点在于启动盘的制作，给出一个软件，不要告诉别人。秘密入口：Universal USB Installer使用这个软件，把下载的linux镜像刻录到U盘，就做成了启动盘。
光盘安装从光盘安装，是成功率最高的linux安装方法。用UltraISO或其他软件，把下载的linux镜像刻录到光盘，就做成了启动盘。
MacOS郝同学只在虚拟机上玩过Mac。
当时，网上很难找到“.iso”的mac镜像，能找到的，都是“.dmg”，这时候，重点来了！把dmg格式的镜像转换成iso镜像！使用的软件，还是UltraISO！怎么样？发现这个软件的强大了吧！

手机rom我们经常可以听到“刷机”这个词，其实刷机，就是给手机重装系统。电脑安装系统，我们使用镜像；手机安装系统，我们使用rom。
问题来了，rom到底是个啥玩意？它的全称是啥？
ROM是只读内存（Read-Only Memory）的简称，是一种只能读出事先所存数据的固态半导体存储器。其特性是一旦储存资料就无法再将之改变或删除。通常用在不需经常变更资料的电子或电脑系统中，资料并且不会因为电源关闭而消失。
手机中，ROM结构是由：系统空间+用户安装程序空间+用户存储空间。也就是说，手机系统存储在rom当中，刷rom，就是改变rom中的系统。而很多人把待刷系统的安装包称为rom，算是一个词义的延伸，相当于镜像。
刷机比重装系统危险，因为手机有可能会变砖！虽然网上有很多救砖教程，但是，考虑到手机型号多如繁星，真的不敢保证你的手机一定能救回来。
刷机方法很多，这里郝同学写一个通用的方法：卡刷！1、下载需要的rom，一般是*.zip文件。2、拷贝rom到手机外置内存卡。3、开机时，按住开机键+音量减/开机键+音量加/开机键+音量减+音量加，进入recovery模式。4、选择rom，开始刷机。PS：刷第三方的rom的时候，大都需要先刷recovery。
小结不同平台，安装系统有差别，常用的也都是那三种方式。所谓见微知著，举一反三，一通百通。。。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>史蒂夫·乔布斯十三句发人深省的经典名言</title>
    <url>/hobby-jobs-13-saying/</url>
    <content><![CDATA[史蒂夫·乔布斯十三句发人深省的经典名言转自 威锋网

史蒂夫·乔布斯，一个传奇的人物，他遗留下来的遗产不仅仅包含当今世界上最成功的科技公司，还有他那些曾经激励过无数人的直言不讳。日前，外媒《商业内幕》收录了史蒂夫·乔布斯 13 句经典的名言，我们再次来一起缅怀。 

以下为文章全文：

　　史蒂夫·乔布斯，一个传奇的人物，他遗留下来的遗产不仅仅包含当今世界上最成功的科技公司，还有他那些曾经激励过无数人的直言不讳。日前，外媒《商业内幕》收录了史蒂夫·乔布斯 13 句经典的名言，我们再次来一起缅怀：

有关创造力　　
　“Creativity is just connecting things. When you ask creative people how they did something, they feel a little guilty because they didn’t really do it, they just saw something. It seemed obvious to them after a while.”
　　“创造力就是找到事物之间的联系。当你询问有创意的人他们是如何做事时，他们觉得有点内疚，因为他们并没有真的这么做，他们只是看到了其中一些关系。这种感觉在他们过后看来会很明显。”
有关死亡　　
　“Remembering that you are going to die is the best way I know to avoid the trap of thinking you have something to lose. You are already naked. There is no reason not to follow your heart.”
　　“记住，每个人终将会死去，这是我认为能够避免个人患得患失的最好方式，你已经赤裸裸地面对死亡，那就没有什么理由不去追随自己的心。”
有关卓越　　
　　“Be a yardstick of quality. Some people aren’t used to an environment where excellence is expected.”
　　“要做一个质量标杆，有些人还不习惯面对一个卓越的环境。”
有关未来　　
　　“You can’t connect the dots looking forward; you can only connect them looking backwards. So you have to trust that the dots will somehow connect in your future. You have to trust in something – your gut, destiny, life, karma, whatever. This approach has never let me down, and it has made all the difference in my life.”
　　“你无法在展望未来时串联点滴，你只能在回顾过去时将其升华。所以你要相信，这些点滴片段会在未来以某种方式串联起来。你要相信某种东西——直觉也好，命运也好，生命也好，或者因缘甚至是其他一切。这种方法从来没有让我失望，在我的生活中，这种意念造就了我的与众不同。”
有关坚持
　　“Your work is going to fill a large part of your life, and the only way to be truly satisfied is to do what you believe is great work. And the only way to do great work is to love what you do. If you haven’t found it yet, keep looking. Don’t settle. As with all matters of the heart, you’ll know when you find it. And, like any great relationship, it just gets better and better as the years roll on. So keep looking until you find it. Don’t settle.”
　　“你的工作将占据你生活中的很大一部分，能够让你真正满意的唯一方法就是做你相信是伟大的工作，而唯一伟大的工作就是爱你所做的事。如果你还没有找到它，那么继续找，不要停。用心去找，你会知道何时能够找到它。如同任何伟大的关系一样，它只会在时间的证明之下越来越好，所以继续找，不要停，直到你找到它。”
有关追求
　　“Being the richest man in the cemetery doesn’t matter to me … Going to bed at night saying we’ve done something wonderful… that’s what matters to me.”
　　“成为墓地里最有钱的人并不是我最在意的事……真正对我有意义的事，就是在晚上睡觉前说上一句‘我已经做了一些非常棒的事’……这才是我最在乎的。”
有关创新　　
　　“I’m as proud of many of the things we haven’t done as the things we have done. Innovation is saying no to a thousand things.”
　　“我引以为豪的是，许多事情我们选择不去做，而许多事情我们又坚持去完成。创新就是对一千件事情说‘不’。”
有关目标　　
　　“I think if you do something and it turns out pretty good, then you should go do something else wonderful, not dwell on it for too long. Just figure out what’s next.”
　　“我想如果你做了某些事，结果顺利圆满，那么你应该选择转去做别的事情，别专注在美好的事情上太久，要不断寻找下一个目标。”
有关失意
　　“Getting fired from Apple was the best thing that could have ever happened to me. The heaviness of being successful was replaced by the lightness of being a beginner again. It freed me to enter one of the most creative periods of my life.”
　　“从苹果公司离职曾是我人生中最好的一件事，追求成功的沉重被创业者的轻松感觉所取代，这让我感觉如此自由，我重新进入人生中一个最有创造力的阶段。”
有关质量　　
　　“Quality is more important than quantity. One home run is much better than two doubles.”
　　“质量比数量更重要，就像一个本垒打胜过两个双打。”
有关改变　　
　　“When I was 17, I read a quote that went something like: ‘If you live each day as if it was your last, someday you’ll most certainly be right.’ It made an impression on me, and since then, for the past 33 years, I have looked in the mirror every morning and asked myself: ‘If today were the last day of my life, would I want to do what I am about to do today?’ And whenever the answer has been ‘no’ for too many days in a row, I know I need to change something.”
　　“我曾在 17 岁时读过这么一句名言：‘如果你把每一天当成自己人生的最后一天来过，那么将来某一天你会明白其中的真谛’，这句话令我印象深刻，此后的 33 年来，我每天早上都会对着镜子自问：‘如果今天是我生命的最后一天，我还会想去做我今天要去做的事吗？’，每当我心里的答案是‘不’时，我知道自己需要做出改变了。”
有关毅力　　
　　“I’m convinced that about half of what separates successful entrepreneurs from the non-successful ones is pure perseverance.”
　　“我相信成功企业家和不成功企业家的区别有一半的原因在于纯粹的毅力。”
有关自省　　
　　“I want to put a ding in the universe.”
　　“我希望可以在宇宙中安装一口警钟。”
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>只需50个词</title>
    <url>/hobby-just-50-words/</url>
    <content><![CDATA[作者：连岳
阅读能不能让人过上幸福的日子？也许不能，可是，不能阅读肯定过不上幸福的日子。阅读的门槛不高，大可不必放弃这种能力。
有一万个词汇，可以精读《莎士比亚全集》；
有六千个词汇，可以精读《圣经》；
有四千个词汇，可以精读《堂·吉诃德》；

有一千个词汇，可以精读《金刚经》；
只有五十个词汇，可以精读苏斯博士的《绿蛋与火腿》。
1960年，苏斯博士和朋友打赌，可以用五十个词汇写一本好书，他做到了，并且赢了五十美元。这本书讲述一只怪物克服恐惧，吃下绿蛋与火腿的故事。有人说它是童话，有人将之视为人生指南，也有人将之归类为诗歌。五十个词汇，构筑知识迷宫，迷住所有误闯其中的人。
只要认识五十个字，就可以趋近于无限的可能性，这个便宜，一定要捡。 
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>2012北航CS一点感想</title>
    <url>/hobby-kaoyan-2012-beihang-cs/</url>
    <content><![CDATA[本文转载自：http://www.cskaoyan.com/thread-87418-1-2.html
2012北航CS（74 + 75 + 145 + 129 = 423） 一点感想
首先，对于所谓经验贴，大家一定要理性的看。每个人情况不同，别人的方法未必适合你，根据适合情况找到适合自己的路，才是最重要的。特别是对于我这种侥幸考的比较高的，大部分经验都是在吹牛B，所以大家看后一笑了之即可。
要说有用的经验，还真有一条，那就是勤奋。你想比别人考的更高，就得比别人付出的更多，这是最简单的道理却不容易做到。如果复习时还经常去打dota不上自习，那说明研究生对你的诱惑不如dota。另外，还有一个对我帮助特别大的，就是我的研友。我是跟我们寝室另外三个人一起复习的，虽然每天早晨互相等彼此会耽误一点时间，但是从来没有一次因为不想起床而不去上自习，因为别人在等你，可以耽误自己的时间，但不能浪费别人的。而且有人一起的话也有助于减缓压力，适当放松。大家也能一起交流复习心得。最后我们四个都考上了。所以希望大家也能找个志同道合的研友。当然这也是个人感触，也有人自己一个人复习成功的，大家理性看待。

考研大多数内容都是在考基础。我们的目标不是考满分，所以有的题不会做很正常，只要把会做的做对不失误，分数就会很高。我相信只要认真准备过的同学很多做错的题都是会做的，只不过在考场上压力大不小心失误算错了。为什么有的人失误了而有的人却能做对？其实这是一个熟练度的问题。在考场上出错还是说明不熟练，大家没有人会把1+1=2算错吧。怎么样才能熟练呢？方法就是反复，各科都是如此，我用过的数学资料没有只做过一遍的（做而不是看），专业课的课本我看了3遍以上，英语真题更不必说……所谓书读百遍，其义自见，这也是大家都知道的大道理，很多东西，多看几遍，自然理解会更深。当学弟学妹们在复习的过程看到有人在网上晒自己做400题多牛B，平均多少多少分的时候，不用在意；或者自己复习过程中小有成就，感到有些东西很简单的时候，莫骄傲，踏踏实实的重视基础，多多重复。
CS的学生都学过软件工程，其实考研也可以当成一项工程。考研是漫长而枯燥的，对于即将开始的复习，学弟学妹们脑中一定要有个整体的规划，知道自己要怎么复习。如果没想好也没关系，现在到暑假还有一段时间，大家可以参考几个经验贴，看看别人走过的路，慢慢想想应该怎么复习。复习时根据自己的情况制定合理的计划，并严格的执行它。当你按期完成一个个自己设定的里程碑的时候，心里是很有成就感的。然后再给自己放个假，休息一天。第二天再进入新的阶段，这样你的学习状态也会比较好。
关于专业课：考试很重视理解，所以要多看课本。当然看课本是非常无聊的，所以要借着参考书跟着过，做题巩固。知识点很多，是很容易忘记的，我的方法如前所述，就是重复。我是9月开始的，9、10月各一遍，11、12又过了两三遍吧。基本上9月以后每天下午都是在看专业课，看一节课本，然后做点题。关于参考书的选择我只有教训。我当初用的是复旦出版社出的那本，没什么亮点，错误很多，写的也很没有诚意。考试的时候算法题我也没做好，没时间想了，随便写了个n^2的算法，不然还有可能上130。所以参考书的推荐，你们懂得。
一些细节：希望大三下的时候能把单词背了，背单词是很烦人的，在正式复习前解决它，这样复习时就会轻松很多。这几门里最重要的是数学，我8月一个月基本上都是在看数学，为以后的复习和最后的分数打下了很好的基础。在408比较难的情况下，只要数学考高了，基本上就没问题了。时间安排上暑假回家待了10天后正式开始复习。前期有所侧重，7月开始英语，8月重点数学，9月重点专业课，10月开始看政治；11月后平均分配，一般早晨数学，下午专业课，晚上政治英语，再把白天没看完的数学专业课随便看看。作息时间基本是早晨8点-11点半、下午2点-5点、晚上6点-10点，11月后晚上到11点。
关于辅导班，大家各有说法。我也是上过的，我只说一句我的感触，如果你认真听讲，课前预习，课后复习，绝对是有用的；但如果你指望辅导班而不努力，甚至时而逃课，上课玩手机，就是没用的。辅导班只是个辅助，关键还在自己努力！
复习的细节，其他同学说的都很好，我就不说了。机会是给有准备的人的，愿大家能够做一个有准备的人，好好学习，把握考研这次机会。当你们明年的现在如愿以偿，坐在电脑面前无所事事的时候，会懂得那段奋斗的日子是多么的宝贵！
祝大家成功！
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>2015南大MSE大题真题回忆</title>
    <url>/hobby-kaoyan-2015-mse-nanda-old-exam/</url>
    <content><![CDATA[本文转载自：http://www.cskaoyan.com/thread-241687-1-1.html
2015南大MSE大题真题回忆
抱歉昨天回来和朋友吃饭去了，没有第一时间发真题哈哈。今天继续上班中，好，废话少说，真题奉上：A. 数据结构部分（45分，10道选择）

最小生成树 10分
写出一个树的类定义，包括成员属性和方法，用C++语言，并且写出求树高度的递归方法，15分。（这道题很多之前的年份考过）
B. 软件工程部分（45分，无选择题）
名词解释：软件工程（5分）软件需求（5分）
解释面向对象体系结构风格及其优缺点 (5分)
给了一个旅游路线设计的需求规格，让你根据这个需求规格写出分析类图。（需求规格就是很常规的那种，包括前置条件啊，后置条件，操作流程，额外要求等）10分
代码改进，一个init()方法，把几个字段的init都放到同一个方法里面，让你说出哪里不好，并且改进 10分
代码改进，给了一段代码，里面包含了大量的switch-case语句，让你改进 10分

C. 操作系统部分（35分，12道选择题）1.Unix系统的inode节点包含12个直接地址和一级、二级、三级地址，每一个盘块包含1024Byte，含有256个盘块地址。请问28MB的文件要占用多少个直接、一级、二级、三级盘块。3分2. 内存置换，写出OPT，FIFO，LRU，Clock方式 8分
D. 网络部分（25分，6道选择题）

写出TCP、UDP的差别 4分
距离矢量协议中，写出两种避免回路发生的技术。 4分
给出B和C两个路由器的路由表，让你写出B路由器收到C路由表，更新后的路由表。5分

选择题的部分，每个2分，比较琐碎我就不说了。希望各位明年考试成功！
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>成绩出来了，随便聊两句</title>
    <url>/hobby-kaoyan-talk-something-after-score-come-out/</url>
    <content><![CDATA[本文转载自：http://www.cskaoyan.com/thread-246808-1-1.html
说是成绩下午出来，结果上午江苏省教育院网站有漏洞，被群里面的大神给找着网址破解了，然后大家上午就知道成绩了。我看了下我的，成绩也不是很高，反正初试够用就是了。
既然说了随便聊两句，也就称不上什么经验了，各人有各人命运，各人有各人的进路。只是说，等到明年的学弟学妹们开始紧张开始准备的时候，看看我们今年考过的人现在写的这些碎碎念，也算是一种忙里偷闲，或许还能有点安慰，得到点鼓励什么的。

我是工作考研的，大学学了个喜欢的专业，毕业了才发现不好找工作了，还好对编程和计算机方面有些兴趣，学了点java就跑到一个外包公司算是工作了。一直在工作中，大概到了8月份才觉得，如果不考研的话可能就要在码农级别混一辈子了，才下决心考试。真正开始准备时候还剩下100天，那时候还在工作，每天也就下班后和早上上班前看一点书，不到4个小时，加上国庆节假期，算是把组成原理和操作系统给看了。不过比较可笑的是，好不容易才看明白的组成原理，后来转了考软件工程，就没考到。数学刚开始的时候就是看同济的课本，看得拖拖拉拉，如蜗牛般爬，进度很慢很慢。
对了，忘了说了，我刚开始是想考计算机的，按照408的专业课和数一去准备，到了60多天了我发现这么下去时间根本不够了，然后就发现南大的软院专硕考数二，而且只！要！两！年！这个太好了，对于我这样毕业工作了一年的人来说，而且刚好我数学也就复习了数二要求的那么多内容，于是果断转考MSE.
离考试还有50天的时候，真心觉得时间不够用了，于是跟公司请假，说我要复习考研，公司居然批了我50天假期。所有我正式复习的时间也就是50天。而且在这50天里面，我花了80%的时间都在补数学。时间安排大概是，早上8点钟开始学习，到11点半，下午2点中到5点半，晚上8点钟到11点半这样子，一天大概是学习10个小时。2/3的时间都给数学。因为我英语比较好的，所以基本没花时间。专业课由于之前看过书了，花的时间也不是很多。政治这门科目，复习前痛恨，复习时才知道党和国家的关怀啊，完全是当休闲来听的。洗澡的时候，锻炼身体的时候，蹲厕所的时候，手机就放个政治视频听着。基本没花正式的时间。所以我考研几乎完全就是在复习数学。哦，对了，我高中是文科。
复习的时间太短了。数学完全是跟着宇哥学。对的，就是张宇。看了他的强化班视频，认真做比较，然后做了14年的真题。。。。。。。然后。。。。就发现自己连40分都考不了。。。。。还好我最怕的就是自大，最不缺的就是打击。做一套真题，总结一套真题。做完了真题，宇哥八套卷出来了，好吧，又被血虐一翻，低的40几分，高的100分露点头; 我还是不气馁，心里反而很开心，因为看到自己在进步。四套卷出来了，好吧，再血虐一翻。不过我已经习惯了被虐了。这就是我数学所做的所有题目了，2005-2014年的真题，宇哥八套卷，宇哥四套卷，然后就去考试了。还好今年数学不算太难，我居然做完了还有时间检查下。所以说，平时怎么被模拟卷虐，也不要气馁，越虐越开心，才能笑到最后。
英语我没什么好说的，因为没怎么复习。政治想提醒一句吧，石磊是个坑货，肖秀荣肖大大才靠谱。我政治石磊听了一些，后来就发现这家伙完全是在背书啊。选择题做了肖大大的八套卷和四套卷，然后把四套卷的大题背熟了。就这么进考场了。最后考得还不错。
专业课分开说吧。操作系统我看了指定教材一遍，写的太烂，后来专心看王道的操作系统了，基本上把王道总结的知识点都掌握了。数据结构把指定教材看了一遍，然后自己把重要的算法整理出来，最后也就才几页纸的内容。软件工程好混乱的，还好有很多现成的复习资料可以看，我算是把复习资料给看了。网络指定的是思科的三本教材，我就认真看了第一本。其他的我看看课件，google wiki，总算是把那些概念给看懂了，也就是这样了。最后专业课考得完全超乎我的预期。
既然都说到这里，顺便说下我的分数吧，给学弟学妹做参考，政治73+英语80+数学122+专业课124 = 399.
我不觉得我这个经验贴有多少复习的参考价值，复习时间太短了，怕是给学弟学妹造成不好的影响，还是要早做打算认真准备的，我看到群里面还有好多400多分的大神，应该多参考下他们经验。我复习的时间短，又是工作考研，又中途换专业，又跨考，脑袋又不太灵光，可以说种种不利都占着了，我最后初试能过，完全不是靠着我自己，朋友说是运气，说我太幸运了。我心里知道这不是运气，这是神给我安排的剧情。这短短的50天，有打击的时候，有动摇的时候，有气馁的时候，有难受的时候，我都有祂的陪伴，我相信祂给我安排的道路。
在最后的那十几天，我常常在手机上看考研帮，也认识一些基督徒，我也要感谢这些弟兄姊妹们，我想说我们的祷告没有白费。等到快考试的时候，会感到很无助很焦虑。晚上睡不着的时候，就听一段圣经。这是我的方式。考研的学弟学妹们，你们也会有你们的解决方案，有自己的研友，有自己的家人，有自己的同学，或者有自己的同事，记着，一定要好好珍惜他们，如果我有什么经验可以说的话，这是我唯一要说的。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>经纬线</title>
    <url>/hobby-latitude-and-longitude-line/</url>
    <content><![CDATA[作者：亦舒
小女的地理卷子发回来，其中一个问题：“为什么要学习经纬线？举两例。”她这样答：“一、学会经纬线可在地图上找到城市首都。二、学习经纬线可取得好分数。”
老伴与我嘻哈绝倒，乐了半天。
为什么要学习经纬线？与学习天底下所有知识一样，做一个有文化的人呀。
中学会考地理科优等成绩的我如果这样说，老师大抵不会接受，标准答案是经线划分时间区域，纬线标指日光分布。

小提琴家艾萨·史顿说过：“我们学习音乐不是为着要做音乐家，而是学习文化。”
这就差不多了，读书并非用来应付考试，虽然考试最好名列前茅。
什么有用，什么无用，见仁见智。网上炒股票，即日买卖，见好即收，收入一定比打工高得多，可是各行各业仍然欣欣向荣，可见人各有志。
学习是一个十分愉快的过程，懂得越多，越能自处，维持静态优质生活。
读《红楼梦》是为着想做作家？当然不是，看一本好书，是真正欣赏。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>让伤疤微疼</title>
    <url>/hobby-let-the-scars-hurt/</url>
    <content><![CDATA[作者：王纯
去朋友家做客，发现他的书桌上有一个小记事本，封面上写着“让伤疤微疼”。不觉好奇，朋友让我打开看。
只见他的本子上写着：某年某月某天，做了个小手术，虽然不是大毛病，但要记得，是该储蓄健康了，伤疤好了，别忘了疼。还有，某年某月某天，工作失误，第一次犯这样的低级错误，主要原因是马虎，同样的错误不能犯第二次。某年某月某天，母亲突然晕倒，到医院检查是血压高，多关注老人的身体，千万不能忽略了，爱可能会来不及。诸如此类，都是生活中遇到的一些问题，提醒自己一定要警醒，所以他说“让伤疤微疼”。
我不由被朋友的良苦用心打动了。生活中，我们很多人都太容易“好了伤疤忘了疼”。
我一个远方的表舅，事业蒸蒸日上，他也是全身心投入到事业中，加班加点是常有的事。没想到他突然间脑出血，在医院接受治疗时，他叹着气说：“人呐，真没必要拼死拼活地干。身外之物，生不带来，死不带去，只有身体和健康是自己的。”大家也都劝他，把工作放放，少挣点没关系。他点头答应。

刚出院的时候，表舅的手脚还不利落，在家休养。他养花种菜，过得也很开心，大家都以为他想开了。没过多久，他的手脚完全恢复了，虽然每天都吃药，但他感觉没事了。正好有一笔大生意来了，他不顾家人劝阻，接了下来。他以为身体没事，可工作起来费心劳神，他很快就挺不住了。突然有一天，一头栽倒，再也没有起来。
大家都说，表舅吃了“好了伤疤忘了疼”的亏。
其实，复杂多变的生活和工作中，总会出现这样那样的问题。问题的出现，对我们来说是个很好的提醒。有时还有一些让你很受伤的事，刺痛你，但我们习惯了时过境迁，把伤痛忘得一干二净。
让伤疤微疼，是一种智慧。把经历的伤痛默默记在心上，时时提醒自己，伤疤虽然结痂，但要让自己微疼。过去的一切，都是宝贵的经验，失败和伤痛更是一种难得的财富，要懂得利用。
让伤疤微疼，也需要勇气。有了伤疤，有些人千方百计选择各种“疤痕灵”消除伤疤，说是忘记伤痛，重新开始。其实最明智的做法是，在伤疤上纹上一朵淡淡的花，提醒自己，曾经伤过。人要有直面伤疤的勇气，要留有疼痛的记忆。只有这样，才能让自己少受伤害。
每个人都有大大小小的伤疤，身体、工作、情感、生活等等。有让伤疤微疼的能力，就有了获得智慧人生和幸福人生的能力。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>人生三乐</title>
    <url>/hobby-life-3-happiness/</url>
    <content><![CDATA[作者：李银河
恋爱、读书、写作是人生三乐。恋爱时，人沉浸在激情之中，快乐感觉无以复加；读书时，人徜徉在智慧之中，心旷神怡；写作时，人寻寻觅觅，仿佛在寻宝的过程中，一旦有所收获，心花怒放，心情愉悦无与伦比。
恋爱的机会可遇不可求。世界上好人很多，可不一定是你能对他产生激情的。人的情感、性情、经历、想法五花八门，不一定能够正好与你相遇，相知，相爱。所以一旦对某人产生激情之爱，务必珍惜，精心呵护，浸淫其中，最好能够保持终身。这当然是很不容易的事情，有太多偶然因素。但是万一有此幸运，快乐真是无与伦比。

读书倒是可以完全随心所欲，只要有欲望，有时间，就可以在书林书海中尽情徜徉，沉入其中，乐不思蜀。虽然绝大多数的书都不值一读，但是真正的好书也足够人享用的了，尤其像我这样读书速度比较慢的（诵读速度），一本好书别人可以享用一天，我可以细细品尝三天。此生不必担忧把好书读尽，就像走进海盗的藏宝洞，满眼珍宝，享用不尽，快乐真是无与伦比。
写作则像探险，你不知道自己会写出什么，仿佛陷入一个迷宫，或者一个漆黑的洞穴，深一脚浅一脚，有时看到前面有一丝亮光，以为找到出路，一路发足狂奔，结果并没有走出去，心情不免沮丧。但是有时山重水尽疑无路，柳暗花明又一村，心中豁然开朗。看着自己的思绪像涓涓的流水，从内心的泉眼中汨汨涌出，晶莹剔透，绵绵不绝，那愉悦的感觉也是无与伦比。
无论生命还有多长时间，惟愿沉浸在恋爱、读书和写作之中。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux目录结构简析</title>
    <url>/hobby-linux-directory/</url>
    <content><![CDATA[Linux继承了unix操作系统结构清晰的特点。在linux下的文件结构非常有条理。但是，上述的优点只有在对linux相当熟悉时，才能体会到。


/binbin是二进制（binary）英文缩写，这个目录下存放着linux常用的程序和命令。
/boot在这个目录下存放的都是系统启动时要用到的程序。我们在使用lilo引导linux的时候，会用到这里的一些信息。
/cdrom可以将光驱文件系统挂在这个目录下。例如：mount /dev/cdrom /cdrom
/devdev是设备（device）的英文缩写，这个目录中包含了所有linux系统中使用的外部设备。我们可以非常方便地去访问这些外部设备，和访问一个文件，一个目录没有任何区别。例如：cd /dev/cdrom 我们就可以看到光驱中的文件了。同样道理，cd /dev/mouse 就可以看看鼠标的相关文件。在dev下，有一个null设备，如果你向这个设备写入内容，写入的内容就进入了黑洞。
/etcetc这个目录是linux系统中最重要的目录之一。在这个目录下存放了系统管理时要用到的各种配置文件和子目录。我们要用到的网络配置文件，文件系统，系统配置文件，设备配置信息，设置用户信息等都在这个目录下。
/sbin这个目录用来存放系统管理员的程序和命令。
/home如果我们建立一个用户，用户名是”xx”，那么在/home目录下就有一个对应的/home/xx路径，用来存放用户的主目录。
/liblib是库（library）英文缩写，这个目录用来存放系统动态连接共享库。几乎所有的应用程序都会用到这个目录下的共享库。
/lost+found这个目录在大多数情况下都是空的。但是如果你正在工作突然停电，或是没有用正常方式关机，在你重新启动机器的时候，有些文件就会找不到应该存放的地方，对于这些文件，系统将他们放在这个目录下，就像为无家可归的人提供一个临时住所。
/mnt用于挂载的目录。
/proc可以在这个目录下获取系统信息。这些信息是在内存中，由系统自己产生的。
/root如果你是以超级用户的身份登录的，这个就是超级用户的主目录。
/tmp用来存放不同程序执行时产生的临时文件。
/usrunix software resource用户应用程序默认安装的路径，这是linux系统中占用硬盘空间最大的目录。用户安装的应用程序可以安装到/usr/local路径下，/usr/share主要存放一些共享文件，/usr/bin存放普通用户程序所需要用到的命令，/usr/sbin存放系统管理员程序所需要用到的程序。
/opt可选的应用程序的安装路径，安装在这个路径下的应用程序，它的源文件，库文件等都是处于同个目录下，这样卸载程序的时候，只需要直接删除了，不会对其他程序造成影响。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux各版本比较</title>
    <url>/hobby-linux-version-comparison/</url>
    <content><![CDATA[
Linux的核心最早由Linus Benedict Torvalds在1991年开发出来。在这之前，Richard Stallman创建了Free Software Foundation（FSF）组织以及GNU项目，并不断的编写创建GNU程序（此类程序的许可方式均为GPL: General Public License）。在不断的有杰出的程序员和开发者加入到GNU组织中后，便造就了今天我们所看到的Linux，或称GNU/Linux。


Linux的发行版本可以大体分为两类，一类是商业公司维护的发行版本，一类是社区组织维护的发行版本，前者以著名的Redhat（RHEL）为代表，后者以 Debian为代表。下面介绍一下各个发行版本的特点：Redhat，应该称为Redhat系列，包括RHEL(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、Fedora Core(由原来的Redhat桌面版本发展而来，免费版本)、CentOS(RHEL的社区克隆版本，免费)。Redhat应该说是在国内使用人群最多的Linux版本，甚至有人将Redhat等同于Linux，而有些老鸟更是只用这一个版本的Linux。所以这个版本的特点就是使用人群数量大，资料非常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网上的一般Linux教程都是以Redhat为例来讲解的。Redhat系列的包管理方式采用的是基于RPM包的YUM包管理方式，包分发方式是编译好的二进制文件。稳定性方面RHEL和CentOS的稳定性非常好，适合于服务器使用，但是Fedora Core的稳定性较差，最好只用于桌面应用。
Debian，或者称Debian系列，包括Debian和Ubuntu等。Debian是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由Ian Murdock于1993年创建，分为三个版本分支（branch）： stable, testing和unstable。其中，unstable为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。testing的版本都经过unstable中的测试，相对较为稳定，也支持了不少新技术（比如SMP等）。而stable一般只用于服务器，上面的软件包大部分都比较过时，但是稳定和安全性都非常的高。Debian最具特色的是apt-get /dpkg包管理方式，其实Redhat的YUM也是在模仿Debian的APT方式，但在二进制文件发行方式中，APT应该是最好的了。Debian的资料也很丰富，有很多支持的社区，有问题求教也有地方可去:)
Ubuntu严格来说不能算一个独立的发行版本，Ubuntu是基于Debian的unstable版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的Linux桌面系统。根据选择的桌面系统不同，有三个版本可供选择，基于Gnome的Ubuntu，基于KDE的Kubuntu以及基于Xfc的Xubuntu。特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。
Gentoo，伟大的Gentoo是Linux世界最年轻的发行版本，正因为年轻，所以能吸取在她之前的所有发行版本的优点，这也是Gentoo被称为最完美的Linux发行版本的原因之一。Gentoo最初由Daniel Robbins（FreeBSD的开发者之一）创建，首个稳定版本发布于2002年。由于开发者对FreeBSD的熟识，所以Gentoo拥有媲美FreeBSD的广受美誉的ports系统——Portage包管理系统。不同于APT和YUM等二进制文件分发的包管理系统，Portage是基于源代码分发的，必须编译后才能运行，对于大型软件而言比较慢，不过正因为所有软件都是在本地机器编译的，在经过各种定制的编译参数优化后，能将机器的硬件性能发挥到极致。Gentoo是所有Linux发行版本里安装最复杂的，但是又是安装完成后最便于管理的版本，也是在相同硬件环境下运行最快的版本。
最后，介绍一下FreeBSD，需要强调的是：FreeBSD并不是一个Linux系统！但FreeBSD与 Linux的用户群有相当一部分是重合的，二者支持的硬件环境也比较一致，所采用的软件也比较类似，所以可以将FreeBSD视为一个Linux版本来比较。FreeBSD拥有两个分支：stable和current。顾名思义，stable是稳定版，而current则是添加了新技术的测试版。FreeBSD采用Ports包管理系统，与Gentoo类似，基于源代码分发，必须在本地机器编后后才能运行，但是Ports系统没有Portage系统使用简便，使用起来稍微复杂一些。FreeBSD的最大特点就是稳定和高效，是作为服务器操作系统的最佳选择，但对硬件的支持没有Linux完备，所以并不适合作为桌面系统。
下面给为选择一个Linux发行版本犯愁的朋友一些建议：如果你只是需要一个桌面系统，而且既不想使用盗版，又不想花大量的钱购买商业软件，那么你就需要一款适合桌面使用的Linux发行版本了，如果你不想自己定制任何东西，不想在系统上浪费太多时间，那么很简单，你就根据自己的爱好在ubuntu、kubuntu以及xubuntu中选一款吧，三者的区别仅仅是桌面程序的不一样。
如果你需要一个桌面系统，而且还想非常灵活的定制自己的Linux系统，想让自己的机器跑得更欢，不介意在Linux系统安装方面浪费一点时间，那么你的唯一选择就是Gentoo，尽情享受Gentoo带来的自由快感吧！
如果你需要的是一个服务器系统，而且你已经非常厌烦各种Linux的配置，只是想要一个比较稳定的服务器系统而已，那么你最好的选择就是CentOS了，安装完成后，经过简单的配置就能提供非常稳定的服务了。如果你需要的是一个坚如磐石的非常稳定的服务器系统，那么你的唯一选择就是FreeBSD。
如果你需要一个稳定的服务器系统，而且想深入摸索一下Linux的各个方面的知识，想自己定制许多内容，那么我推荐你使用Gentoo。
对各种操作系统的用户分布方面的概括:　　Mac –&gt; Windows –&gt; Linux–&gt; BSD –&gt; UNIX从左边到右边，分别是”使用该OS的人里精通电脑的用户群最少”到”使用该OS的人里精通电脑的用户群最多”的过渡。我们可以看到，Linux的被放置在了中间，而BSD则更接近于右边。许多人会对此有争论，也有些人可能会感觉被冒犯了。但是，个人认为这是一个对”哪些用户使用哪些系统”相当准确的概括。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>m3u8视频下载方法</title>
    <url>/hobby-m3u8-download/</url>
    <content><![CDATA[m3u8格式M3U是一种播放多媒体列表的文件格式，它的设计初衷是为了播放音频文件，比如MP3，但是越来越多的软件现在用来播放视频文件列表，M3U也可以指定在线流媒体音频源。很多播放器和软件都支持M3U文件格式。
M3U8是Unicode版本的M3U，用UTF-8编码。”M3U”和”M3U8”文件都是苹果公司使用的HTTP Live Streaming格式的基础，这种格式可以在iPhone和Macbook等设备播放。
HTTP Live Streaming（缩写是HLS）是由苹果公司提出基于HTTP的流媒体网络传输协议。是苹果公司QuickTime X和iPhone软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。
综上，m3u8是一种文件格式。下载m3u8格式的文件时，会下载一个m3u8文件（文件列表），以及一个包含了很多ts文件（视频片段）的隐藏文件夹。
更多内容参考M3U和HTTP Live Streaming。


怎样下载m3u8格式视频？获取下载地址1、安装chrome插件，Stream Video Downloader。
2、打开一个包含m3u8视频的页面，比如云原生技术的前世今生。点击播放，Stream Video Downloader就可以嗅探到m3u8文件。
3、复制下载地址并保存，此处的下载地址为：https://myun-hw-s3.myun.tv/melj80jz/5a3ydjj0/1551265736611296603.m3u8
FFmpegFFmpeg是一个非常好用的视频格式转换工具，同时可以用来下载m3u8文件。
1、访问github-FFmpeg或者FFmpeg官网，下载FFmpeg，本文中下载ffmpeg-4.2.2-win64-static.zip。
2、解压重命名文件夹为ffmpeg，进入ffmpeg/bin目录。
3、右键加+Shift，打开Powershell，输入下载合并命令：
.\ffmpeg.exe -i "https://myun-hw-s3.myun.tv/melj80jz/5a3ydjj0/1551265736611296603.m3u8" -c copy 01-云原生技术的前世今生.mp4

耐心等待，下载完成即可在ffmpeg/bin目录中看到下载好的mp4视频文件。
m3u8转mp4手机QQ浏览器的视频下载功能确实强大，大部分能看到的视频都可以下线，包括云原生技术的前世今生这个页面中的视频。
下载好的文件，是m3u8格式视频。正如上文所说，这个视频文件实际上是一个视频列表和一个隐藏文件夹组成。想要给它合并转换成mp4格式视频，怎么办？同样可以使用FFmpeg。
1、把视频列表和隐藏文件夹都拷贝到PC。
2、使用sublime打开m3u8文件，批量替换路径。替换前为：
#EXTM3U#EXT-X-TARGETDURATION:11#EXTINF:10.000000,file:///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/0.ts#EXTINF:10.000000,file:///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/1.ts#EXTINF:10.000000,file:///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/2.ts#EXTINF:10.000000,file:///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/3.ts#EXTINF:10.000000,file:///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/4.ts#EXTINF:10.000000,file:///storage/emulated/0/QQBrowser/视频/.820a585fc4f1a85d4875007aff5ba7a5/5.ts
转换后为：
#EXTM3U#EXT-X-TARGETDURATION:11#EXTINF:10.000000,.820a585fc4f1a85d4875007aff5ba7a5/0.ts#EXTINF:10.000000,.820a585fc4f1a85d4875007aff5ba7a5/1.ts#EXTINF:10.000000,.820a585fc4f1a85d4875007aff5ba7a5/2.ts#EXTINF:10.000000,.820a585fc4f1a85d4875007aff5ba7a5/3.ts#EXTINF:10.000000,.820a585fc4f1a85d4875007aff5ba7a5/4.ts#EXTINF:10.000000,.820a585fc4f1a85d4875007aff5ba7a5/5.ts

3、打开Powershell，执行转换命令：
# 直接合并转换（速度快）.\ffmpeg.exe -i input-filename.m3u8 -c copy output-filename.mp4# 合并转码压缩（速度慢）.\ffmpeg.exe -i input-filename.m3u8 output-filename.mp4
执行完成，即可看到转换好的mp4文件。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>chrome</tag>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown文档导出为pdf</title>
    <url>/hobby-markdown-to-pdf/</url>
    <content><![CDATA[一直非常眼热Mac下的Mou，从Markdown导出pdf非常方便，而且格式良好。
没有Mac，只能找一些Windows下可以使用的工具。之前一直使用MarkdownPad2，这货导出格式特别难看就算了，而且，收费！
今天找到了另一种方式，虽然麻烦了一点点，但是格式很不错。现记录如下：1、使用在线编辑器StackEdit：https://stackedit.io/editor
2、预览
3、打印打印时保存为pdf。
4、添加书签使用福昕PDF阅读器添加书签（包括子目录书签）。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>士之德操</title>
    <url>/hobby-men-of-morality/</url>
    <content><![CDATA[作者：张艺谋
高仓健对人是非常非常真诚的。日本人认为他是一个神，在云端，而我在他身上看到了一种“士”的精神，那种古典，就是让你忍不住吸一口气起鸡皮疙瘩的感受，真的不是装的。
我拍了20多年电影，不长也不短。其他演员，如果我们让他先收工，先回去休息，很正常，他们高高兴兴就走了。我在云南这样跟高仓健说过，下午6点左右说“您先回去”，到了晚上9点要收工时，天已经黑了，副导演慌慌张张地过来跟我说：“导演，高仓健没走！”为什么没回去？出事了？他说，导演和全体人员都在这儿工作，他不能走。我说让他来这儿休息一下，这儿有水、有椅子，他说怕打搅我们。他一直在山地的拐角下站着，默默看我们工作，不打搅。我们全队上汽车准备走，老爷子远远地给我们鞠躬，他不过来，鞠完躬就走了，70多岁的人，站了3个小时。工作一天了，让他先回去，这算什么？全世界的演员都会觉得这天经地义，他却觉得他不可以，因为导演还在工作、工作人员还在工作。
好多这样的小事情，都不是装的，他的心就是这样，这就是“士”。还有中井贵一，高仓健的弟子，高仓健只要在东京、只要出远门，不管哪一天的航班，不管白天还是晚上，当高仓健到达机场的时候，中井总是远远地给他鞠一躬，不过来，不打搅，远远地送他。高仓健对我也是这样，我每次去日本，每次赶飞机，他会在地下车库，看我的车走，远远地给我鞠躬。我吓一跳，老爷子什么时候来的？已经来一个多小时了，他也怕人家认出他，站在地下车库，在一堆车后面，远远地送我。

拍《千里走单骑》时，我让民工小徐给高仓健打伞，他说不要，我说不是照顾他，是怕他被紫外线晒了，跟戏不搭。小徐打了3天伞，老爷子把手表摘下来给了小徐。值钱就不说了，是好几万的表，值钱都是次要的，他就是觉得他不知道要怎样感谢这样一位为他打伞的民工。他说：“你辛苦了。”那表小徐现在还珍藏着，舍不得戴。所谓“滴水之恩当涌泉相报”，所谓“士为知己者亡”，我们在文学上描写的士的情怀全在他身上有体现。
他在奥运会开幕前，专门给我送来一把刀。他们说这把刀跟北京的房子一样贵，是日本国宝级的工匠，用了一年时间锻造的。高仓健悄悄一个人买了机票，不告诉我，一下就到了北京，到了我们的开幕式工作中心，给我送来。他回去以后，东京正下大雪，他又驱车几个小时到郊区的一座寺庙为我祈愿。翻译跟我讲，寺庙那天清场，只为我做法事，老和尚带着一群和尚，高仓健一个人站在那里，整个大殿的和尚都在那儿念经，拴着几万个铃铛，风一吹，叮当响，整个环境特肃穆。一个半小时的祈愿，高仓健来回开了七八个小时的车。这事儿高仓健不让告诉我，是翻译偷偷告诉我的。很多事他不想让你知道，因为不是为了做给你看的。那个和尚是他几十年的老朋友，而且他说那个寺庙是最灵的。祈愿完了以后，高仓健给了我一个牌子，我现在还留着，日文写的是：“祝张艺谋导演奥运开幕式成功。”
关于他，真是有好多细节。我以前跟他没有见过，只是他的粉丝，我们见面以后都互相喜欢，所以就这样对待彼此。所以从这里也可以感受到，电影是桥梁，可以沟通人心。
还有一次，我们俩坐在一个大堂酒吧，远处百米外是大堂，但是这个酒吧里人很少。他看不见外面，我能看见，我跟他在那儿坐了一个多小时，大堂里人来人往，有日本人认出他来了，向酒吧门口走过来，距离有四五十米时，深深鞠一躬就走了，也不惊动我们。就这样，来来回回有四五十人给他深深鞠躬，悄悄离开。
有一个导演给他拍纪录片，那个导演礼拜天正在家抱着孩子，突然一接电话，听对方说“我是高仓健”，吓得差点把孩子摔了。他放下电话眼泪哗哗的，第二天早上，他只是一遍一遍跟我说高仓健给他打电话了。从很多细节可以发现，高仓健就是日本民族精神的代表，是日本的国宝。因为他跟我走得近，或者说是因为支持中国，经常遭到日本媒体批评。日本有一些人说他对中国电影过于支持，因为我去东京电影节，他60年都没有走红地毯——他从来不走红地毯，可他陪我走了。所以日本媒体就说他，在日本都不走本国的红地毯，他不管。所以他这个人其实很爱中国，从骨子里爱中国。
我和别人讨论剧本的时候，尤其古装电影，我们谈一些人物的价值取向的时候，我常常讲一些高仓健的小例子，我说这就是士的情怀。默默为你奉献，默默承受，不让你知道，这就是“士”。我们经常拿高仓健的一些事为例子，讲解人物的动作：他不管到哪里，第一件事情都是把母亲的照片拿出来，恭恭敬敬地放在房间里最显眼的地方，放上一束鲜花。我们多次接待他，每次问他有什么要求，都是没有其他要求，只是“可不可以每天给我买一束鲜花回来”。原来不知道是干什么用的，后来知道，是放在他母亲照片前的。有一次我进他的房间，果然看到照片，照片放在写字台上，下面是白色的鲜花，不是正规的遗像，是他光着屁股，与哥哥、姐姐、妹妹和母亲在河边的生活照，很温情、很可爱。他到哪里都先把照片供起来，不是做给我们看的，他去南极拍戏都是这样。这种大孝对我们都是传奇，现在我们谁能做到？几十年，真的很让人感动。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>仁慈</title>
    <url>/hobby-mercy/</url>
    <content><![CDATA[作者：罗西
没有iphone的时候，觉得用iphone的人都是显摆；没有LV的时候，觉得提LV的都是虚荣。当我有了iphone、LV的时候，就觉得它们就是日常用品，没什么特殊的。我们常常误读误判，是因为一开始就站在对立面上。设身处地为对方想想，坚硬、锋芒的心就释然了、柔软了。其实每天我们都在高攀，有时高攀爱情，有时高攀权贵，有时高攀美德……向上或是本能，只是我很清楚，所有的高攀，抵不过我一次仁慈的低头——让一只蚂蚁顺利从我鞋边爬过……明处的牙齿，暗处的吻痕；高处的骄傲，低处的淫荡。位置决定态度，屁股影响脑袋。
好人没有你想象的那么好，坏人也没有你想象的那么坏。好事坏事亦然。所有的判断都是信息碎片的拼装，所有的观点都是感情的一部分。看见一只金苍蝇在追随一只朴素的蝴蝶，莫名地我对它就多了一些好感。所有的归类都是偏见，这个世界只有个体的大世界。

我知道你经不起诱惑、考验，我知道你没有我想象的好、对我的好……这也是我怜悯的一种。因为谅解，我内心渐渐温柔、敞亮；却也因为仁慈，我变得弱小。“不要轻易去挑战或考验人性，人性禁不起这些；它需要的是保全，余地，推挡，遮盖。若你单刀戳入，必然破绽百出。不要尝试去击溃任何人。”只有真正强大的心才经受得起真实和残酷。
或许，“洁”容易“劫”，“善”容易“伤”；但是，没有关系，洁，舒服，善，自在。更重要，无邪可以避邪。
年轻气盛的时候如果被人欺负了，总会恨恨地想以后一定要混出个名堂来，好让人刮目相看；可当真有这么一天的时候，你已经强大到不会恨了，只有更宽厚的包容。原来真正的强大不是原谅别人，而是放过自己。强者容易心生悲悯，小我的哀伤也会温柔、暖和一点。
在南京，一个刚上车的六七岁小男孩请公交司机等一等他妈妈。一分钟后孩子妈妈还没来，车上乘客开始责骂，说母子俩耽误了大家时间。这时，一位腿有残疾的母亲一瘸一拐上车，所有人都沉默了。其实，慢一点，你会看见更多，同时也让宽容跟上！昨夜的月色执迷不悟，今天的阳光豁然开朗。给自己一些时间，别浮躁，即仁慈。
大道理谁都懂，小情绪才考验一个人的修为。
有些锁、有些恨，只是等待的一种；懂得的人，都有一把钥匙、一份爱。常常放不下的，不是自己，是关系。一生不长，而一颗真心抵达另外一颗真心，就足以让我用一生去苦渡与明白。
有一种禅：我在，你也在，一棵开花的药草，刚好同在。身为同类，不妨由己及人，多一些理解。我是很容易看见美好的，虽然这个世界那么肮脏！有时也会疏远那些光、倾慕、热闹……是因为觉得孤独更简单、自在；离云朵更近的地方，与你交汇那些孤独与清高；低处的红尘与摇摆，还是让给那些七嘴八舌的热闹。
不过，你现在的遗世独立，或许只是还来不及与我狼狈为奸。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>玫瑰与胶囊</title>
    <url>/hobby-nose-and-capsule/</url>
    <content><![CDATA[作者：沈奇岚
这几乎是一个悖论：在这个信息爆炸的年代，人们的阅读量大幅下降。并不是人们的阅读力降低，而是人们愿意给予阅读的时间越来越少。
十多年前笔者曾经参加了一个在瑞士举行的国际论坛，有一位非常年轻的企业家介绍自己的新公司，经营的主要业务是“替人读书”。许多大企业的管理人员总是非常忙碌，却很想读书。这家公司就为这些想读书而没有时间读书的人把三百页的大部头著作精简成十页的“精华”，并获取高额报酬。负责读书、摘选和撰写“精华”的人都是具有相当高学历的研究人员，这样可以保证浓缩的一定是精华。这个公司一时间十分受欢迎，它提供的“精华”摘要，犹如读书界的营养胶囊，小小一粒，让人们心理上觉得获得了所有需要的信息和养分，同时大大节约了时间。

当时我就想，这套办法是没法用在文学和哲学书上的吧，否则《安娜·卡列尼娜》的摘要精华，就是一句“已婚的安娜爱上了渥伦斯基，离开了家庭，然后卧轨自杀”，而《简·爱》的摘要就是“家庭教师简·爱在罗切斯特先生家里教书，后来嫁给了他”。如果抽去了这些故事的细节，抽去了一切社会属性和事情发展的时间性，没有一个故事值得一读，没有一个人物值得去爱。好作品是无法压缩成所谓的精华的，尽管这样的阅读必须付出时间和精力，但是这样的阅读才是真正能够回馈至生命本身的阅读。
以获取信息为目的的阅读，或许可以压缩成“精华”，让无暇与心灵对话的读者迅速吞咽，立即获得营养。这是兔子吃胡萝卜式的阅读，是占有性的阅读。另外一种阅读，是更从容的阅读。这样的阅读考验读者的情趣，也试探读者的耐心。在这场近乎舞蹈的阅读中，读者和书中的内容建立起了生命的联系。由此，读者找到了阅读的意义，获得了思维能力和感情容量的增强。生命因此而丰富起来。
读书是个选择。读书的目的不仅仅是获得知识，还是选择如何度过这一段生命时光。或许在一个节奏加快的世界里，选择读书本身就是一件奢侈的事情。获得信息和知识，在这个互联网时代是容易的，而取得思维能力的增强和理解力的增加是有难度的。当网络渐渐分担甚至取代了图书传播信息和知识的功能时，滋养心灵成了书籍更重要的功能。那些不可压缩的是什么？那些不能变成“精华摘要”的是什么？这是每一个写书人和读书人值得思考的问题。这个时代盛产各种各样的营养胶囊，一粒玫瑰胶囊或许有助于皮肤保养，而一朵盛开的红玫瑰可以召唤整个春天。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>Notepad++使用技巧</title>
    <url>/hobby-notepadpp-skill/</url>
    <content><![CDATA[Notepad++比较文本内容参考文本内容比较 Notepad++。
插件，Plugin Manager，Show Plugin Manager，找到Compare，Install。
打开需要对比的两个文件，插件，Compare，Compare。或者直接使用Alt+D。


NotePad++高亮Markdown参考写了一个Notepad++的markdown插件、notepad++安装markdown插件和How to use markdown in notepad++，安装markdown插件。
1、访问Edditoria的github，下载markdown-plus-plus。
2、拷贝userDefineLang.xml到Notepad++的安装目录（郝同学的是D:\Program Files\Notepad++），重启Notepad++。可以看到，在语言选项中，多出了Markdown。
3、出现了问题，安装完成没有效果，重启也无效。原来，notepad++有一个缓存文件夹：C:\Users\Administrator\AppData\Roaming\Notepad++，直接在这个文件夹中替换userDefineLang.xml，再次打开一个.md文件查看，格式果然出现了变化。所以，如果你要替换自定义的markdown语言格式，建议你同时替换上述两个文件夹下的文件。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>《千字文》</title>
    <url>/hobby-one-thousand-word/</url>
    <content><![CDATA[天地玄黄，宇宙洪荒。日月盈昃，辰宿列张。
寒来暑往，秋收冬藏。闰余成岁，律吕调阳。
云腾致雨，露结为霜。金生丽水，玉出昆冈。
剑号巨阙，珠称夜光。果珍李柰，菜重芥姜。


海咸河淡，鳞潜羽翔。龙师火帝，鸟官人皇。
始制文字，乃服衣裳。推位让国，有虞陶唐。
吊民伐罪，周发殷汤。坐朝问道，垂拱平章。
爱育黎首，臣伏戎羌。遐迩一体，率宾归王。
鸣凤在竹，白驹食场。化被草木，赖及万方。
盖此身发，四大五常。恭惟鞠养，岂敢毁伤。
女慕贞洁，男效才良。知过必改，得能莫忘。
罔谈彼短，靡恃己长。信使可覆，器欲难量。
墨悲丝染，诗赞羔羊。景行维贤，克念作圣。
德建名立，形端表正。空谷传声，虚堂习听。
祸因恶积，福缘善庆。尺璧非宝，寸阴是竞。
资父事君，曰严与敬。孝当竭力，忠则尽命。
临深履薄，夙兴温凊。似兰斯馨，如松之盛。
川流不息，渊澄取映。容止若思，言辞安定。
笃初诚美，慎终宜令。荣业所基，籍甚无竟。
学优登仕，摄职从政。存以甘棠，去而益咏。
乐殊贵贱，礼别尊卑。上和下睦，夫唱妇随。
外受傅训，入奉母仪。诸姑伯叔，犹子比儿。
孔怀兄弟，同气连枝。交友投分，切磨箴规。
仁慈隐恻，造次弗离。节义廉退，颠沛匪亏。
性静情逸，心动神疲。守真志满，逐物意移。
坚持雅操，好爵自縻。都邑华夏，东西二京。
背邙面洛，浮渭据泾。宫殿盘郁，楼观飞惊。
图写禽兽，画彩仙灵。丙舍旁启，甲帐对楹。
肆筵设席，鼓瑟吹笙。升阶纳陛，弁转疑星。
右通广内，左达承明。既集坟典，亦聚群英。
杜稿钟隶，漆书壁经。府罗将相，路侠槐卿。
户封八县，家给千兵。高冠陪辇，驱毂振缨。
世禄侈富，车驾肥轻。策功茂实，勒碑刻铭。
盘溪伊尹，佐时阿衡。奄宅曲阜，微旦孰营。
桓公匡合，济弱扶倾。绮回汉惠，说感武丁。
俊义密勿，多士实宁。晋楚更霸，赵魏困横。
假途灭虢，践土会盟。何遵约法，韩弊烦刑。
起翦颇牧，用军最精。宣威沙漠，驰誉丹青。
九州禹迹，百郡秦并。岳宗泰岱，禅主云亭。
雁门紫塞，鸡田赤诚。昆池碣石，钜野洞庭。
旷远绵邈，岩岫杳冥。治本于农，务兹稼穑。
俶载南亩，我艺黍稷。税熟贡新，劝赏黜陟。
孟轲敦素，史鱼秉直。庶几中庸，劳谦谨敕。
聆音察理，鉴貌辨色。贻厥嘉猷，勉其祗植。
省躬讥诫，宠增抗极。殆辱近耻，林皋幸即。
两疏见机，解组谁逼。索居闲处，沉默寂寥。
求古寻论，散虑逍遥。欣奏累遣，戚谢欢招。
渠荷的历，园莽抽条。枇杷晚翠，梧桐蚤凋。
陈根委翳，落叶飘摇。游鹍独运，凌摩绛霄。
耽读玩市，寓目囊箱。易輶攸畏，属耳垣墙。
具膳餐饭，适口充肠。饱饫烹宰，饥厌糟糠。
亲戚故旧，老少异粮。妾御绩纺，侍巾帷房。
纨扇圆洁，银烛炜煌。昼眠夕寐，蓝笋象床。
弦歌酒宴，接杯举殇。矫手顿足，悦豫且康。
嫡后嗣续，祭祀烝尝。稽颡再拜，悚惧恐惶。
笺牒简要，顾答审详。骸垢想浴，执热愿凉。
驴骡犊特，骇跃超骧。诛斩贼盗，捕获叛亡。
布射僚丸，嵇琴阮箫。恬笔伦纸，钧巧任钓。
释纷利俗，并皆佳妙。毛施淑姿，工颦妍笑。
年矢每催，曦晖朗曜。璇玑悬斡，晦魄环照。
指薪修祜，永绥吉劭。矩步引领，俯仰廊庙。
束带矜庄，徘徊瞻眺。孤陋寡闻，愚蒙等诮。
谓语助者，焉哉乎也。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>开发者必备的开放平台注册应用大全</title>
    <url>/hobby-open-platform/</url>
    <content><![CDATA[所谓开放平台，就是首先提供一个基本的服务，然后通过开放自身的接口，使得第三方开发者得以通过运用和组装其接口以及其他第三方服务接口产生新的应用，并且使得该应用能够统一运行在这个平台之上，我们把这样的一种网络服务模式叫做开放平台。开放平台模式成功的要点在于，通过自身服务和第三方应用的互利互惠，提高用户对平台网站的粘性和使用程度，进而提高获利，同时，通过利益分摊，达到平台自身和第三方应用循环刺激而产生的滚雪球式的增长。麦布收集了最新最全的开放平台注册应用，用得着就收藏了吧。


1、新浪微博开放平台：http://open.weibo.com/2、QQ互联：http://connect.qq.com/3、百度开放平台：http://open.baidu.com/4、百度官网认证：http://guanwang.baidu.com/vcard/officialsite5、360官网认证：http://zhanzhang.so.com/?m=SiteCertification&amp;a=siteVerify6、Discuz! 开放平台：http://open.discuz.net/7、PHPCMS开放平台：http://open.phpcms.cn/8、搜搜论坛开放计划：http://open.soso.com/9、搜狗开放平台：http://open.sogou.com/10、QQ空间认证：http://page.opensns.qq.com/apply.html11、微游戏开放平台：http://open.weibo.com/game/12、腾讯微博开放平台：http://dev.open.t.qq.com/13、微信开放平台：http://open.weixin.qq.com/14、腾讯社区开放平台：http://opensns.qq.com/15、腾讯Q+平台：http://dev.qplus.com/16、拍拍网开放平台：http://pop.paipai.com/17、搜狗官网认证：http://help.sogou.com/renzheng/18、搜狗问问开放平台：http://open.wenwen.sogou.com/19、百度开发者中心：http://developer.baidu.com/20、百度知道开放平台：http://open.zhidao.baidu.com/21、人人网开放平台：http://dev.renren.com/22、网易微博开放平台：http://open.t.163.com/23、网易云阅读开放平台：http://open.yuedu.163.com/24、搜狐微博开放平台：http://open.t.sohu.com/25、搜狐新闻客户端全媒体平台：http://mp.k.sohu.com/26、搜狐博客开放平台：http://ow.blog.sohu.com/27、淘宝开放平台：http://open.taobao.com28、支付宝开放平台：http://bizpartner.alipay.com/denglu/index.htm29、阿里巴巴开放平台：http://open.1688.com/30、豆瓣API key：http://www.douban.com/service/apikey/apply31、UC优视开放平台：http://www.uc.cn/business/ucly.shtml32、天涯开放平台：http://open.tianya.cn/33、Google站长开发者：https://www.google.com/accounts/ManageDomains34、开心开放平台：http://open.kaixin001.com/35、天翼开放平台：http://open.189.cn/36、360软件开放平台：http://rz.360.cn/37、360应用开放平台：http://dev.app.360.cn/38、雅虎开放平台：https://developer.apps.yahoo.com/projects39、Twitter开放平台：https://dev.twitter.com/40、Facebook开放平台：https://developers.facebook.com/41、56视频开放平台：http://dev.56.com/42、亿起发–开放平台：http://open.yiqifa.com/43、PHPCMS开放平台：http://open.phpcms.cn/44、UC优视开放平台：http://www.uc.cn/business/ucly.shtml45、淘宝开放平台：http://open.taobao.com
转载自：http://mt.sohu.com/20160628/n456773156.shtml
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
  </entry>
  <entry>
    <title>网页内容无法复制解决办法</title>
    <url>/hobby-page-content-copy/</url>
    <content><![CDATA[很多网站内容不能复制，但是由于某些原因，我们需要复制一些内容。这时，不妨试试void给出的两个方法。
方法一：1、打开http://www.360doc.com/content/15/0410/21/22116372_462274865.shtml ，我们发现，在转载之前内容无法复制。

2、Ctrl+S，保存为网页仅html。
3、双击打开刚才保存的文件，我们发现网页内容可以复制了！

方法二：我们发现，同样的方法，对起点这种神级网站无效！没关系，我们还有进阶教程！1、打开http://read.qidian.com/BookReader/2502372,42712100.aspx，无法复制。
2、同样的，Ctrl+S，保存为网页仅html，双击打开保存的文件，我们发现还是无法复制
3、选择保存的文件，用记事本打开
4、Ctrl+F，搜索关键词“全屏阅读”（关键词不唯一），“查找下一个”，直到找不到那个关键字（目的是为了定位到正文部分）
5、点击“确定”，关闭查找框，我们把“全屏阅读”那一行往上的内容全部删除
6、Ctrl+S，保存后关闭记事本。再次打开保存的html文件，发现已经可以复制了
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
  </entry>
  <entry>
    <title>神情专注的人更长寿</title>
    <url>/hobby-people-who-focus-on-the-look-live-longer/</url>
    <content><![CDATA[作者：梅承鼎医学家经过研究，得出一个可靠的结论：神情专注的人更长寿。比如书法家，他们一般都比平常人寿命长。唐朝著名书法家颜真卿、柳公权、欧阳询，分别活了77岁、88岁、85岁，都属于高寿之人。近代高寿的书画家更是大有人在，吴昌硕活了83岁，齐白石老人活了94岁……
练习书法与练习气功有异曲同工之妙。在练习书法时，必须专心致志，摒除杂念，聚精会神，气沉丹田，心手合一，神至笔至，不能有一丝一毫的分心，其整个过程与练气功殊途同归。
当一个人全心倾注于一项自己喜欢的事业时，他自然也就沉浸在一种愉悦的情绪中，全力以赴地去做，尽心尽力地去做，心平气和地去做。在他全情投入的过程中，很自然地处在一种宁静致远、物我两忘的至高境界。这种境界可以使人乐而忘忧，可以增强人体的免疫功能和抵抗疼痛的能力。
书法家仅仅是神情专注者的其中一个群体，从事其他专注工作的人们，同样也可获得长寿。如作家、科学家、企业家等，他们中都不乏活了八九十岁，甚至年过百岁的长寿老人。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>PS绘制抛物线</title>
    <url>/hobby-ps-parabola/</url>
    <content><![CDATA[需求已有一张 draw.io 绘制出的图像如下。
现在需要在小球之间绘制平抛运动的抛物线。


绘制方法1、使用PS打开原始图像，使用 ctrl+加号 放大到合适的大小。
2、菜单栏图层，新建，图层。
3、工具栏选择钢笔工具。单击上面的小球，然后单击下面的小球并按住鼠标，向下拉伸，移动调整曲线的弧度。
4、右键曲线，建立选区，确定。或者直接 ctrl+Enter ，路径变成选区。
5、菜单栏编辑，描边，确定。ctrl+D 取消选区，选中图层 Enter回车 去掉钢笔笔迹。
6、图层，只显示抛物线，工具栏选择橡皮擦工具，擦除不需要的部分。
7、图层，显示所有图层，即可看到需要的抛物线。
重复上述步骤，完成另外两条抛物线，最终结果如下图。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title>PS盖章抠图</title>
    <url>/hobby-ps-seal-cutout/</url>
    <content><![CDATA[目标从图A中抠出盖章，然后盖到图B中。


抠图方法剪裁1、打开图A，双击背景，转换为图层0。
2、剪裁出盖章部分。
整体抠图1、打开通道面板，复制蓝色通达，只显示蓝色通道副本。
2、单击蓝色通道副本，ctrl+L（图像-调整-色阶），调整输入色阶，使黑的更黑，白的更白。
3、ctrl+I（图像-调整-反向），使黑白颠倒。因为白色的是选区。
4、ctrl+单击蓝色通道副本（选择-载入选区）。
5、回到图层面板，ctrl+C，ctrl+V，只显示新图层1。至此，就把背景去掉了。
去除多余1、新建图层2，双击背景色，选择白色，ctrl+backspace（填充）。把图层2拉到图层1下面。
2、在图层1上，新建蒙版。B键（选择画笔工具），调整画笔大小。前景色选择黑色。
3、使用画笔把黑色的多余文字抹去，文字与盖章重叠部分不处理。
重叠处理1、选中图层1，锁定透明背景像素。
2、使用仿制图章工具。按住alt键锁定红色图章部分作为原点，然后涂抹黑色重叠部分。注意，此时焦点要放在图层1上，而不是图层1的蒙版上。
3、使用橡皮擦工具，擦掉多余像素。
4、ctrl+S，保存为png或者psd格式。
使用1、打开盖章图片和图B。
2、把盖章图片，拖到图B上，成为盖章图层。
2、在图层面板，单击盖章图层，选择正片叠底，至此大功告成。
书签photoshop制作印章ps抠出印章教程
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>ps</tag>
      </tags>
  </entry>
  <entry>
    <title>关于QQ的问题</title>
    <url>/hobby-qq-question/</url>
    <content><![CDATA[1、QQ群共享无法打开解决办法：升级QQ。
2、qq音乐播放歌的时候，QQ来了消息声音就变小解决办法：打开 控制面板-&gt;选择‘声音’-&gt;选择‘通信’-&gt;选择‘不执行任何操作’。
3、去掉腾讯网迷你版小窗口系统设置，资讯提醒，去掉勾
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
  </entry>
  <entry>
    <title>兰迪·波许的最后一课</title>
    <url>/hobby-randy-pausch-last-speech/</url>
    <content><![CDATA[2007年9月18日，美国Carnegie Mellon大学计算机系教授兰迪·波许做过一个著名的演说，演说的名称叫《兰迪·波许的最后一课》（英文名称《Randy Pausch’s Last Lecture》）。演说的反响极大，ABC电视网将他选为“2007年度人物”之一，《时代》杂志将他列入了“世界上影响最大的100人”，同名书籍至今依然在建议类和教育类畅销书前列。
兰迪教授于2008年7月25日安详地离开人世，但他却给无数人留下了心灵的财富，他所提倡的精神也永远鼓励那些敢于追求梦想的人。
YouTube视频链接：Randy Pausch的最後一堂課
中英文对照演讲稿：Randy Pausch’s Last Lecture: Really Achieving Your Childhood Dreams
阮一峰大佬的读后感：Randy Pausch教授的《最后一课》
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>《拒绝平庸（周鸿祎和他的创世记）》</title>
    <url>/hobby-refuse-mediocrity-zhouhongyi/</url>
    <content><![CDATA[《拒绝平庸》，这本书是360创始人周鸿祎的传记。不久前读完了这本书，做了一些笔记，和大家共勉：
1、未来1015年，你到底想要成为什么样的人？未来1015年，你到底最想获得什么？这是最重要的。这个东西，你可以说是梦想，也可以说是价值观。为什么？因为一旦想清楚了，以后你无论作什么判断，作什么选择，就都简单多了。有助于实现我梦想的，我就干；没帮助，我就放弃。把梦想锚定，短期内不管你遇到什么诱惑，遭遇什么困难，都不会左右你的判断和选择。
2、只有这种非利益化的梦想和目标，才能长期激励一个人不断地去追求。
3、创业其实是一种精神，是一种心态。创业有很多种形式，不是只有自己办公司，自己当老板才叫创业。当你的人生还处于起步阶段，你不具备足够的经验和能力，就要给人当学徒，需要学习和积累，其实这个过程也是创业。

4、说真话，也许日子会难过一时，但造假，却可能一辈子抬不起头。
5、这个世界上总是凡人多，既然是凡人，便有凡人的毛病，你有，别人也会有。
6、创业和打工都只是一种生活方式，没有高低优劣之分，只看是否适合自己。
7、被激发起来的热情最后变成什么——是焰火般绚烂后归于沉寂，还是浓缩成一团心火，温暖你仰望星空时的梦想，也照亮你蹒跚前行的路？
8、如果你见都没见过，模仿都谈不上，怎么可能谈创造呢？
9、真正的视野开阔，要靠那些过了脑子再过心最后留下来的东西。
10、你能投机，别人就能取巧，如果一点儿技术壁垒都没有，做什么都是无法长久的。
11、一个优秀的人必定会有其他优秀的人主动来进行价值交换。专注于理想；独善其身并亲近那些独善其身的人。
12、信息，沟通，眼光。
13、因为籍籍无名，所以可以犯错。
14、唯有学习和反思才能让人避免下次再犯同样的错误。
15、优秀要靠专注地积累能量。
16、看到别人做出一款软件，他就会想：如果我做，我会怎么做。尽管他没有真正去做这些项目，但是相当于沙盘推演了一遍。他不断寻找这样的问题，跟团队、同学和认识的相关的人去讨论。
17、卡氏16种人格测试。
18、两类人创业不容易成功，一种是技术人员，一种是文人，因为这两种人都特别自负。
19、谁能想到方正、雅虎、诺基亚的没落？未来不可预知，没有什么不可能，时间就是最好的武器。
20、想要，就着手做点儿什么。
21、有所为，有所成，必然有所不为，有所不成。
22、罗伯特·弗罗斯特：林中有两条路，你永远只能走一条，怀念着另一条。
23、用户至上，创新，创业精神。
24、商业模式无论怎样千变万化，用户基础才是王道。
25、免费是互联网之本。
26、做好产品，服务消费者才是根本，用谁的技术、用什么技术都是手段而已。
27、乔布斯：微小的的创新可以改变世界。周鸿祎：改变数字工业的革命，并不是高瞻远瞩、行思缜密的战略规划使然，而是微创新的必然结果。
28、苹果也好，360也好，微创新一定从冷门开始，从大公司不注意的角落开始，凭着经验和直觉去把握每一步，没有战略规划，每一件事都是做成了再总结。
29、创业精神在人生的每一个阶段都是需要的，其核心就是：为自己奋斗。
30、华为创始人任正非。
31、最重要的是：你在360能不能学到东西，能不能锻炼出能力。
32、做公司很容易，把公司做成功很难。
33、用心，外行也能成为专家。
34、多读书、多看报、多与其他人交流，用外来的崭新的思维力量打破条条框框。
35、看报纸杂志的时候，少看行业高端杂志，多看面向普通用户的杂志。多读这样的刊物，就能帮助你从用户的角度出发看问题。
36、对于优秀的产品经理来说，改善用户体验的机会无处不在。当你走出办公室，你就是其他产品的用户，但你不要做一个抱怨的用户，而要提升一个层次，抱怨完了，想一想其他人是不是像你一样在抱怨，你应该怎么为其做出改善。
37、脸皮厚，不怕骂，没心没肺。
38、YY创始人李学凌。
39、一个人做不了太多事，所以在一点上做到极致，反而找到了简单而锋利的武器。
40、做产品得先考虑怎么让用户满意，让用户觉得舒服，而不是现在怎么挣钱。
41、商业模式不是盈利模式，它包含着盈利模式。盈利模式是商业模式的最后一步，是商业模式一步步发展成熟后水到渠成的结果。
42、商业模式的核心是产品，本质是通过产品为用户创造价值。
43、商业模式：产品模式 -&gt; 用户模式 -&gt; 推广模式 -&gt; 收入模式。
44、他们用你的产品用的好，那是理所当热，很少站出来表扬你。但你一旦用得不爽，就会骂你。
45、hao123和4399创始人李兴平，初中毕业。
46、尤费《柔道战略》。
47、流程再造。
48、哈默《超越再造》、《企业行动纲领》
49、李安：每个人的心中都藏龙卧虎。
50、团队应该像磨石机中的石头一样，碰撞，争论，大吵，不怕有冲突，最后才能产生好的想法。
51、如果你觉得自己是A级人才，你觉得自己很棒，那你的自尊心不需要领导来呵护。
52、管理的目的：服务，所有的管理流程都应该为公司的业务服务。
53、《硅谷热》、《创业的国度》
54、最大的成就就是帮助别人成功，最赚钱的事就是帮助别人赚钱。
55、狼性文化
56、向苹果学习颠覆精神。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>新浪博客手机版转网页版</title>
    <url>/hobby-sina-blog-mobile-to-page/</url>
    <content><![CDATA[用手机访问新浪博客的时候，访问到的是手机版。但是，如果我想要查看PC网页版，应该怎么办？
以下面的手机版url为例：http://blog.sina.cn/dpool/blog/s/blog_675cc1ad0100zegv.html
直接访问该url，在PC端，看到的也是手机版的内容。
经过对比网页版的url，郝同学找到了方法，修改url如下：http://blog.sina.com.cn/s/blog_675cc1ad0100zegv.html
也就是说，在sina后面加上.com，同时删掉/dpool/blog就可以了！
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>停止拍照，学着画画</title>
    <url>/hobby-stop-taking-pictures-and-learn-to-draw/</url>
    <content><![CDATA[译者：安心芮
每当看到有趣或者漂亮的事物时，我们都会有一种自然的冲动，想要将它捕捉并保存下来——在今天，我们会拿出手机拍照。
这看起来像是一个完美的解决方法，但拍照有两个大的问题：第一，因为我们忙于拍照，以至于我们忘记了去观察这个促使我们去拍照的有趣而漂亮的事物;第二，因为我们知道照片保存在我们的手机里，所以我们总是无暇欣赏，因为我们总是想着某一天我们会抽出时间来专门欣赏的。
这个问题在今天很普遍，其实在摄影流行之初，当照相机的尺寸类似于落地大座钟之时，这个问题就被注意到了。问题的发现者是英国的艺术批评家John Ruskin。他是一个观察力敏锐的旅行者，他注意到大多数旅行者在观察和记忆他们看到的美好事物方面的表现让人沮丧。他认为人类对美好事物有表达和主宰的渴望。最差的情况下，我们购买纪念品或者拍照。但是，在Ruskin看来，有一件事情是我们应该做的，那就是尝试将我们看到的有趣的事物画下来，不管我们是否有这种才能。

在摄影技术发明之前，人们绘画的次数远比今天多。那时人们需要用绘画记录生活。但是在19世纪中期，摄影扼杀了绘画。绘画变成了只有艺术家才会做的事情，所以绘画的拥护者和照相机的敌人Ruskin发起了一个让人们重新拿起画笔的活动，他在这个活动上花了四年的时间。他出书、演讲并且资助艺术学校，他的活动并不能让人画得更好，但是他不觉得这是一个悖论：“人们生而为艺术家，就像河马生来就是河马，并且不能让自己成为长颈鹿。”
在Ruskin看来，即使对于没有天赋的人，画画也是有价值的，因为画画能教我们去看、去观察，而不是茫然地注视。在用我们自己的手重现眼前景象的过程中，我们会自然地从漫不经心欣赏美好事物的状态，转变成从美好事物的各部分中得到深刻感悟的状态。
Ruskin觉得，只有很少的人会注意细节，他谴责现代游客的盲目和匆忙，特别是那些以只用一周时间坐火车游完欧洲为荣的游客。高速度不会让我们变得更强、更快乐或更聪明。世界上的东西比人们能够看到的更多，但走得更快并不会让看到的东西变得更好。真正珍贵的是所思和所见，不是速度。人走得慢点并无害处，因为生命的意义不在于行走，而在于亲身体验。
所以他放慢速度，劝告我们花更长的时间观察复杂的事情，甚至是相当简单的事情。从他自己的画中就可以看出这个观点。
假如我们停下来，用一个素描画家能够画一幅速写的时间来盯着一个地方看，这会被认为是不寻常的，这恰恰说明我们对匆忙是如此习惯。画一棵树至少需要十分钟的专心注视，但最漂亮的树也很少能让过路者停下来注视一分钟。
Ruskin总结了这四年他尝试去做的绘画教学和写作指南，他写道：
“两个人出去散步，其中一人是优秀的素描画家，另一个完全不会画画。他们一起沿着林荫道走下去，看到的景象会有很大的不同。一个人会看到小路和树，他会看到树是绿的，会看到阳光，会有愉快的感觉——这几乎就是全部了！但是素描家将看到什么呢？他的眼睛习惯性地去搜索美的来源，并深入美的极小的部分。他向上看，看到阵雨怎样分开阳光，然后洒在头顶闪闪发光的叶子上，直到天空被翠绿的光填满。他会看到一根大的树枝在树叶下浮现，看到宛如宝石光泽的绿色苔藓和斑驳而奇异的地衣，白、蓝、紫、红都混合成一件美丽的衣裳。多孔的树干和蛇形线圈紧紧攥着陡峭的河岸上缠绕的树根，河岸边的斜坡草坪上还镶嵌着五颜六色的鲜花。这不是很值得一看吗？如果你不会像一个素描画家那样观察和思考，当你走过这条林荫道，回到家时，就没有什么能说或者可回想的，你只是走过了这样一条小路。”
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>那些年遇到的奇葩问题</title>
    <url>/hobby-strange-questions/</url>
    <content><![CDATA[1、我的文档移动到“D:\”，然后再也移动不回去了……因为文件夹属性里的“位置”没有了。
2、VM9程序启动特别慢（上个系统时挺快的），估计30秒左右。
3、windows media centre怎么设置都失败。
4、安装office2010和vc2008，错误1317,.尝试创建目录c:\programdata\microsoft\windows\star menu时发生错误，错误1303。
5、ppt无法输入中文，按照网上方法写入注册表东西还是不行。
6、桌面文件重命名无法全选。
6、安卓各个镜像版本的区别

7、C++面向对象程序设计找不到pdf格式的电子书
8、360手机助手每次连接手机都会蓝屏
9、oracle安装报错检查操作系统版本: 必须是5.1 or 5.2。实际为 6.1未通过
10、把一篇pdf转成word之后，在每行的末尾出现了很多的回车符
11、小甲鱼的TAB键
12、虚拟机XP突然不能上网了，百度提示DNS错误，怎么也弄不好
14、红帽linux中vi编辑器无法显示颜色
15、在我的电脑上，myeclipse无论如何都无法破解！
16、2010excel发现不可读取的内容,是否恢复此工作薄的内容
17、pl/sql在64位win7下不可以使用
18、ubuntu不能用root用户登录
19、评论框由Denglu提供
20、voidking.gitcafe.com不可以访问，但是它解析的其他网址却可以访问！
21、图书管理系统使用mysql数据库，存入中文数据变成乱码。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
  </entry>
  <entry>
    <title>地铁站里的实验</title>
    <url>/hobby-subway-experiment/</url>
    <content><![CDATA[作者：周云龙美国媒体二00七年的一个社会实验：一位男子在地铁站用小提琴演奏了巴赫的六首作品。他前面的地上，放一顶口子朝上的帽子。没有人知道，这位卖艺者是世界上最伟大的音乐家之一约夏．贝尔。他演奏的是一首世上最复杂的作品，用的是一把价值三百五十万美元的小提琴……
在约夏．贝尔演奏的四十五分钟里，大约二千人经过，只有六个人停下来听了一会儿，大约二十人给了钱就匆匆离开，他总共收到三十二美元。而两天前，约夏．贝尔在波士顿一家剧院演出，所有门票售罄，聆听他演奏同样的乐曲，平均得花二百美元……
这个实验，给人什么启示？电视圈的朋友甲点评说，环境影响人的评判能力t，环境决定一切！乙补充说，平台太重要啦！丙举例说，不是江苏卫视这样的平台，会做出《非诚勿扰》那样炫目的舞台吗？孟非一个歪瓜裂枣型的主持人能出得来吗？他还可能有那么大的影响力吗？

约夏．贝尔在地铁里的演奏，据说是《华盛顿邮报》主办的关于感知、品味和人的优先选择的社会实验的一部分。实验结束后，《华盛顿邮报》提出了几个问题：一、在一个普通的环境下，在一个不适当的时间内，我们能够感知到美吗？二、如果能够感知到的话，我们会停下来欣赏吗？三、我们会在意想不到的情况下认可天才吗
地铁站的这个实验，内涵很丰富，操作蛮简单，它不过是利用了人们的审美惯性：地铁站里演唱的，都是为生活所逼卖艺的流浪汉。事实上，为生活所逼卖艺的人群中也可能有音乐天才。但是，要让以工薪阶层为主的“地铁一族”在行色匆匆之中能做出准确的判断，那是中彩的概率。说实话，高雅的音乐，本来就属于环境优雅的剧院，本来就属于自愿购票出入剧院的文人雅士。
美国地铁实验者最后得出的结论是：当世界上最好的音乐家，用世上最美的乐器来演奏世上最优秀的音乐时，如果我们连停留一会儿倾听都做不到的话，那么，在我们匆匆而过的人生中，我们又错过了多少其他东西呢？
其实，与我们的错过相比，那些美好的人物、东西被错过，哪个更值得可惜呢？实验，可能只是虚拟的情境，但是，现实的生活中，就是现在，还很可能有?未被发现的音乐天才，正混迹于地铁站，任许多人走过、路过，也错过。
其实，一万人错过也无妨，但是，那双可以引导他走出地铁站走向大剧院的慧眼，不能错过。一个正常的健康的社会，也不该让他一直被错过。
身边的电视同行，常常有人拿“光头”孟非说事，我承认，平台确实很重要、环境也很重要。但是，要知道，孟非做过印刷厂工人，做过体育新闻的摄像记者，在这些并不引人关注的岗位上，就像有些昏暗、嘈杂的地铁站里，那么，谁最早发现了他的主持潜质？“发现”，有时倒还不难，又是谁最早大胆起用了没有主持经歷的他？他在民生新闻栏目做得如鱼得水之后，又是谁把他适时引入娱乐、综艺类节目的主持？主持转型一开始并不成功，可能还有好多非议吧，之后又是谁坚持继续给他试错的机会？
或许，平台的“平”，核心价值可能就在于决策管理者的“水平”。所以，我在关注美国地铁站那个实验之后，最大的感触是，假定我路过那个地铁站了，假定我被音乐吸引了，停留了──我没有“错过”，而且我因为眼前的音乐人才而惊喜，因为他暂时的处境而纠结，那么，我又能有什么资格、有什么途径举荐他？接下来的问题更关键，在一个个更看重学歷、资歷、关系、背景的规则和潜规则设计里，又有谁愿意去重用他？谁能给他一个最适合的舞台？说到底，生活中的每一个个体，如何才能做有追求、有尊严的自主的人？
“我”错过又何妨？——只是错过了一道风景；“他”被错过情何堪！——或许错过的是一生。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>世界上最美的20条街道</title>
    <url>/hobby-the-20-most-beautiful-streets-in-the-world/</url>
    <content><![CDATA[boredpanda网站上投票选出的世界上最美的20条街道。

希腊莱斯沃斯岛



德国波恩





瑞典斯德哥尔摩



美国华盛顿



西班牙瓦伦西亚



南非比勒陀利亚



中国台湾



意大利斯佩罗



澳大利亚格拉夫顿



希腊纳夫普里翁



巴西阿雷格里港



西班牙赫雷斯



意大利波西塔诺



澳大利亚布里斯班



乌克兰爱的隧道



日本紫藤隧道



美国丹佛



津巴布韦哈拉雷



美国萨凡纳



波兰卡卢森

]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>独处的能力</title>
    <url>/hobby-the-ability-to-be-alone/</url>
    <content><![CDATA[作者：杨照
意大利传奇导演费里尼说：“独处是种特别的能力，有这种能力的人并不多见。我向来羡慕那些拥有内在资源、可以享受独处的人，因为独处给你一个独立空间、一份自由，这些是人们嘴上喊‘要’，实际上却害怕的东西：人生在世，没有什么比独处更让人惧怕的了。… …他们害怕寂静无声，害怕那种剩下自己一人与自我思绪及长篇内心独白独处时的静默。”
很有意思，费里尼接受媒体访问时，曾经一再地说他是如何地害羞、不能适合众人场合，可是即使这样，他仍然不是个真正爱好独处独居的人。
在吵闹与安静之间，究竟要怎样才是真正面对自己？究竟怎样才能感受到那个独立空间与那份自由？

在我成长的过程中，从来没有喜欢过团体生活，从来没有习惯过在众人之间。我一直警觉着在众人之间的尴尬与无助无奈。怕成为焦点，怕被挑选出来强迫表演，不管是哪种形式的表演。可是另一方面又很怕被淹没，一点主体的焦虑，一种无法诚实面对自己喜好兴趣的不耐与无聊。
因而理所当然认为自己一定喜欢独处独居。年轻的时候，也的确常常寻找独处独居的机会。从各式各样的关系隙缝里，找到可以不必理谁也不必有谁理我的时刻总是最快乐的。那时候，开车不见得是要去哪里，而是将一个人将车开在山路间，尤其深夜时分，格外享受。速度中有一种宁静，还有一种介于专注与忘神之间的吊诡感觉。一方面专注于操纵轰隆隆吼叫的运动机器，另一方面却又可以在脑海里叫唤出多少平常在错杂生活里无从寻觅的记忆与思考。
简直是心与脑分离独立存在的最佳证明。科学里从来不承认有一颗会感知会思考的心的存在，感知、思考的功能全属脑部。可是几乎每个古老的传统文化里，不论东方或西方，都把心和脑分开处理。这当然可能是个共同的误解。在胸腔里有个砰砰鼓动的机制，那么明显那么热烈，每个人难免都会问：它到底干嘛这样？尤其是几项主要的情绪反应，几乎都牵涉到心跳的改变，难怪我们会以为：心是为了感情而跳的。不过误解里还是有点道理：有些感官的运作其实是可以分离的，人并不随时随地都是个统一的个体。
不过那种年岁，回头想，独处情况毕竟属于生活中的例外，所以格外珍惜。一个人是否真的喜欢独处，真的有能力独处，要到有了大块独处时间才能确定。当独处变成了常态，独处的时间不再是一丝丝一条条的生活装饰，而是大块大块的基本存在时。本来有太多的记忆与情绪，等着在独处的时间里整理；变成了困窘地必须创造出记忆与情绪，努力填满独处的时间。
活在现代的环境中，有太多方式可以让人逃避独处。即使一个人，也很容易有电视、网络可以陪伴，因而我们往往就少了一分诚实的试验，试验自己究竟拥有多少可堪挖掘的内在资源。
独处会让人听到许多声音。比静默更可怕的是这些来自内心的声音。独处使人脆弱，使人比自己想象的更容易心软、更容易感动。为什么费里尼说：要拥有很多内在资源，才能享受独处？因为真正独处时，就只剩下自己可堪挖掘。
在那么忙碌、那么焦躁的环境里，先别说要慢下来，先试试自己一个人，真正自己独处看看。平常让你忙，让你误以为那就是生活意义的事消失了，只剩下自己，会怎么样呢？
大部分人在独处之后，学会了谦虚。因为真正了解到剥除那些表面繁华，自己原来有多么不堪挖掘。有了这么一份谦虚，人也才有资格具体地、实存地讨论自由、独立。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>赚钱以外的功夫</title>
    <url>/hobby-the-effort-outside-of-making-money/</url>
    <content><![CDATA[作者：冯仑
我发现一个非常有趣的现象，李嘉诚在创业的时候，许多人都比他有钱，但后来那些人不见了，或者财富排在他后面。比尔?盖茨创业的时候，比他钱多的人也很多，但盖茨今天成了首富。中国许多企业家也是如此。为什么？
　　因为，在中国由计划经济向市场经济，由封闭向开放，由野蛮的市场经济向文明法制的市场经济转型过程中，最重要的恰好是钱以外的因素。

　　就像你驾驶一辆汽车在高速公路上要并线转弯，既要车不能翻，还要保持速度，这非常难。这时候的问题不在于汽油，而在于司机的技巧，这个技巧就是钱以外的东西。钱以外的能力究竟是什么能力？我讲四种。
　　一、将自己的姿态放低
　　钱以外的能力之一是做人的能力，特别是做人的姿态。我发现凡是生意做得不错的人，都善于把自己的姿态放得很低，在中国文化里这叫给别人面子，就是你得把人尊敬一下。凡是刚开始做生意的时候，他们的姿态都很重要，就是很谦恭、谦虚、谦卑。按北京话来说，挣钱要像孙子，花钱要像大爷。
　　二、价值观
　　钱以外的第二个能力是价值观。价值观是我们判断是非善恶的简单标准。你之所以做这件事而不做那件事，之所以这么做而不是那么做，就是价值观。MBA经常讲差异化竞争，差异化的战略在产品、在营销方法这些方面，几乎都可以模仿。真正不能模仿的是价值观，这就是为什么有些人能够成功，有些人不能够成功。
　　所谓价值观，就是在你心里跟你的合作伙伴、同事、朋友建立金钱关系的时候，你需要拿一个尺度来衡量、来决策，而这个东西会引导你朝不同的方向去走。例如，我们看马云，不要看马云成功的故事，而应该看马云是怎样在微观决策的时候，判断细小的是非。比如马云在上市的时候，他只拿了5%的股份，这就是价值观。还有一些人，会把70%的股份变成自己的。而这个价值观会导致未来非常多的人生故事和结局。
　　三、毅力和耐心
　　钱以外的第三种能力就是毅力、时间。为什么坚持这件事很重要？因为如果你没有理想，就不可能有毅力。所有的人在做事情的时候，最后不是比一个结果，而是比一个过程。一件事情的性质由什么决定，我认为取决于两方面。第一，取决于时间，时间不同，对这件事的评价完全不一样。第二，取决于你跟谁做。
　　做企业也是这样。如果我们在做了三年的时候垮掉了，大家可能把我们随意看待。当我们30年还在这儿的时候，大家开始有一些敬意。当300年后这个公司还在的时候，大家开始顶礼膜拜。所以时间是一个很好的东西，它可以考验你的价值观和做人的姿态。中国历史传统中，没有把事往快里办的办法，大部分都教我们把事往慢里办。通过慢能够把事做好，所以叫事缓则圆，以缓找到方法，以圆作为皈依，这就是中国人的智慧。所以你要有毅力。
　　四、正确判断未来
　　上面讲的都是刚开始挣钱，怎样能挣到钱的故事。当一个企业已经发展得不错的时候，实际上也面临着更大的挑战，钱以外的能力，就是你对未来的看法，对社会的看法是不是准确。
　　我在公司已经做了17年董事长，没有做过一天经理。我发现我能干的工作并不多，但是很费神。因为我就干三件事情：第一，看别人看不见的地方；第二，算别人算不清的账；第三，做别人不做的事情。
　　这其实非常难。第一，你永远要看别人看不见的地方。当一个企业正常发展时，要看那些看不见的东西，包括风险、机会，很多我们还不知道的未来变化的趋势。这些工作需要企业的领导花很多时间。所以我经常说，我要跟神、跟先知做邻居，这样才能看见别人看不见的地方，我们要有一个方法去看趋势、模式、危险、机会，这些很重要。这些东西属于钱以外的东西，并不是说花多少钱就有这个能力，而是要长期去积累和研究去学习。
　　第二，算那些算不清的账。眼前最简单也最现实的是我们捐献灾区多少钱合适，社会的情绪，公众的期待跟捐多少钱有很大的关系。更复杂的账还有，比如说我们要找一个合作伙伴，可能有五个人站在你门口都可以给你钱，有土钱、洋钱，有笨钱、聪明钱，你找谁？土钱的特点是决策快、变化大、干预多；洋钱决策慢、按规则来、干预不多，但是该管你的地方，又决不妥协。所以作为一个企业、一个领导人，这种能力就是你怎么在算不清的账里找到确定。
　　第三，做别人不做的事。例如履行企业公民的责任，去救灾、去环保，做各种各样的事情。这些事情是经理人不太愿意做的事情，因为又占精力又要出钱，董事长就要做他们不做的事情。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10安装Ubuntu</title>
    <url>/hobby-ubuntu-on-windows/</url>
    <content><![CDATA[前言有几十个文件需要批量重命名，按照以前的做法，郝同学都是把文件上传到linux服务器，然后使用rename命令进行重命名，然后再拷贝回来。具体参考《批量重命名和批量替换字符串》。
但是，这次需要重命名的文件太大了，上传不方便，所以想到了另外一个思路：在Win10中使用Linux命令。要使用Linux命令，最简单的是使用git bash，但是只有ls、vim等简单命令。cygwin也可以模拟Linux环境，但是命令也有限。记得微软说Win10集成了Linux，所以决定试试，下面进行记录。


安装Ubuntu1、Win+S，打开搜索，输入“启用或关闭Windows功能”。
2、勾选“适用于 Linux 的 Windows 子系统”，点击确定，然后重启电脑。
3、Shift+右键，打开Powershell，输入bash，会提示访问Microsoft Store安装Linux。
4、访问Microsoft Store，选择Ubuntu，点击进行安装。
5、安装完成后，在Powershell中再次输入bash，即可进入ubuntu的shell，第一次进入会提示设置用户名和密码，这里设置用户名为voidking。
至此，ubuntu on windows就安装完成了。使用方法和正常的ubuntu一模一样，nice。当然也有不同的地方，比如c盘对应的目录为/mnt/c/，d盘对应的目录为/mnt/d/。
使用xshell访问以上，ubuntu安装完成，但是存在一个大毛病，就是从Powershell进入bash特别难用，比如无法复制粘贴。所以，如果能使用xshell访问就好了。
1、ubuntu切换到root用户sudo -i
2、安装ssh服务apt-get install openssh-server
3、vim /etc/ssh/sshd_config，如下修改：
# line 13, uncomment and changePort 3422# line 15, uncommentListenAddress 0.0.0.0# line 56, changePasswordAuthentication yes

4、重启sshservice ssh restart
5、ubuntu中本地测试ssh voidking@localhost -p 3422
6、windows中xshell连接新建会话，主机填写127.0.0.1，端口填写3422，用户名密码是之前安装ubuntu时设置的。
开机自启动ssh重启计算机后，发现无法通过ssh连接ubuntu，原来是因为ubuntu on windows默认不会开机自启动ssh服务。所以需要把ssh服务添加到开启自启动。直接使用systemctl enable ssh命令，无效，所以需要把ssh服务添加到开机自启动脚本，参考ubuntu18.04配置rc.local。
1、创建rc-local.service链接ln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.service
2、vim /etc/systemd/system/rc-local.service，添加：
[Install]WantedBy=multi-user.targetAlias=rc-local.service

3、创建rc.localvim /etc/rc.local，添加：
#!/bin/bash/etc/init.d/ssh startexit 0

4、添加执行权限chmod 755 /etc/rc.local
5、重启ubuntu无法使用reboot等命令重启ubuntu on windows，所以需要重启win10。
然而，重启后依然无效！看来是ubuntu on windows与纯净的ubuntu还是有些差别，参考在Windows子系统（WSL）中配置开机自启动服务进行处理。
1、win10中进入启动目录Win+R输入shell:startup，回车
2、创建wls_rclocal.vbs，内容为：
set ws=wscript.createobject("wscript.shell")ws.run "C:\Windows\System32\bash.exe -c 'sudo /etc/rc.local'",0

3、登录ubuntu，创建sudoers文件vim /etc/sudoers.d/rc-local，内容如下：
voidking * = (root) NOPASSWD: /etc/rc.local

4、重启win10，使用xshell登录ubuntu，成功。
后记最终的效果，比预想的还要好。两个系统可以同时使用，这样就集成了windows和linux两者的优点，完美。
书签开启 Windows 10 的 Linux 子系统
使用xshell登录ubuntu on windows
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>爱好</category>
        <category>电脑</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>youtube、youku、爱奇艺等视频平台下载方法</title>
    <url>/hobby-video-download/</url>
    <content><![CDATA[视频下载的痛点很多时候，我们在youtube、youku、爱奇艺、腾讯视频、bilibili等视频平台看到了喜欢的视频，想要下载到本地，但是无法下载，要么必须要客户端才能下载。好不容易下载到本地，对于不同平台下载的视频，还必须使用不同的客户端进行播放。如果想要作为教学视频放到PPT中，还必须进行转码，不同平台还得寻找不同的转码方法。
太难了，好在一些前辈帮我们解决了这些问题，并且开发出了很多好用的工具。本文中，重点推荐两款个人在用的视频下载工具：youtube-dl和you-get。


youtube-dl1、访问youtube-dl，下载需要的版本，这里以macos版本为例
sudo curl -L https://yt-dl.org/downloads/latest/youtube-dl -o /usr/local/bin/youtube-dlsudo chmod a+rx /usr/local/bin/youtube-dl# or brew install youtube-dl

2、查看视频支持的下载格式，下载视频
youtube-dl -F http://v.youku.com/v_show/id_XODQzMTQ4NDQ=.htmlyoutube-dl -f mp4 http://v.youku.com/v_show/id_XODQzMTQ4NDQ=.html

you-get1、访问you-get，下载需要的版本，这里以macos版本为例
pip3 install you-get# orbrew install you-get

2、查看视频支持的下载格式，下载视频
you-get -i http://v.youku.com/v_show/id_XODQzMTQ4NDQ=.htmlyou-get http://v.youku.com/v_show/id_XODQzMTQ4NDQ=.html#you-get --itag=18 'https://www.youtube.com/watch?v=jNQXAC9IVRw'

对比这两个软件功能上没有太大差别，下载速度也没有太大差别。youtube-dl更加轻量，安装也要比you-get快的多（you-get依赖一堆软件）。对于同一个视频，这两个软件支持的下载格式有所不同，比如上面的例子中，youtube-dl支持mp4格式，you-get支持flv格式。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>下载</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware上跑HelloWorld操作系统</title>
    <url>/hobby-vmware-helloworld-os/</url>
    <content><![CDATA[本文转载自：http://freesoftman.iteye.com/blog/629598
1温故而知新先温习一下汇编语言，当然这个是一个苦活！我是温习了一下《IBM-PC汇编语言程序设计》
2了解操作系统基础概念推荐一本电子书，《自己动手写操作系统》。


书中说只需要10分钟就可以完成操作系统。可是，本人确用了大约二周，惭愧呀！代码只有20行左右，如下：
++++++++++++++boot.asm begin ++++++++++++++++++   org 07c00h ;告诉编译器程序加载到7c00处  mov ax,cs  mov ds,ax  mov es,ax  call DispStr ;调用显示字符串例程  jmp $  ;无限循环    DispStr:    mov ax,BootMessage    mov bp,ax ;es:bp = 串地址    mov cx,16 ;cx = 串长度    mov ax,01301h ;ah = 13, al = 01h    mov bx,000ch ;页号为0（bh = 0） 黑底红字（b1 = 0Ch，高亮）    mov dl,0    int 10h    ret  BootMessage: db "Hello, OS world!"  times 510-($-$$) db 0 ;填充剩下的空间，使生成的二进制代码       ;为512字节  dw 0xaa55    ;结束标志   ++++++++++++++boot.asm end++++++++++++++++++

大家首先需要下载一个NASM的汇编编译器， 我下载的是nasm-2.06-installer(1).exe!一般只要使用迅雷都能获取该编译器。至于上边代码的意思，我就不做多的解释了， 最基本的一些汇编语法。
输入命令：nasm boot.asm -o boot.bin
一会儿就生成了一个镜像文件boot.bin. 该文件就是我所谓的操作系统了。哈哈！其实只是一个boot sector而已。但是这个是我们步入操作系统的第一步， 跨过了这一步，以后就海阔天空理论上偶也只是使用了10分钟左右写完成了。
但是，令人恼火的是，书中介绍的是将该image写入floppy。我的本本没有floppy驱动。那么偶就必须要了解bootloader的概念。
于是，花了1周的时候了解概念，并且设想是不是能使用u盘进行启动， 将自己的boot loader程序写入到u盘的MBR中。于是询问了公司的元老，哈哈，功夫不费有心人。 让我了解了一款向u盘的MBR写入Image的工具。
这里就像大家隆重的推荐一下dd工具， 这款工具本来是Linux自带的用于向任何存储设备写镜像文件的工具。你可以在google中输入 dd for window， 那么你就可以获得window版本的dd。
接下来， 我分步讲解如何将boot.bin写入到u盘的MBR中：1，打开cmd，进入dd.exe所在的目录，偶的路径为C:\NASM。如图：
2，由于dd是命令行的一个小工具，先调用命令–list， 查看一下U盘的Partition。如图：
3，从图中看到， 我的U盘partition是K, 名字为\.\Volume{66b36b20-3a85-11df-b4e4-005056c00008}4，既然找到了partition地址，那么就可以将我们的boot.bin写入到U盘的MBR。
5，命令 dd if=c:\nasm\boot.bin of=\.\Volume{66b36b20-3a85-11df-b4e4-005056c00008} count=1就是这条命令，你就可以把你的boot loader写入到u盘中。参数含义：if， 你要写入的文件绝对地址+文件名of， 你想要写入的地址。bs， 每次写入块大小， 默认为512字节。count， 要写入指定of设备的指定块。
那么上面的命令就是， 将我的boot.bin文件中的512个字节写入到U盘的0扇区。也就是MBR。
OK,经过上面简单的处理， 那么你就可以看看效果了。 于是， 偶就重启电脑， 设置BIOS从U盘启动。
哈哈， 在界面上显示了Hello, OS world! 内心无比喜悦。
之后我想， 可不可以在vmware上使用U盘启动来查看效果呢。毕竟以后主要是在vmware上做实验啊！
但是问题又来了， vmware居然不支持U盘启动， 郁闷啊！
还有， 在网上search了解决方案。步骤如下：
1、先关闭VMware;2、插入可启动的USB设备;3、启动VMware;4、添加硬盘,在DISK选项中选择”use a physical disk”,在device中选择刚刚添加的USB设备;（比如我实机系统已经有了二块硬盘disk0和disk1，这时候USB设备被识别为disk2)5、重启VMware,修改VMware中的BIOS由SCSI启动.
在次令人兴奋的， 在vmware中也跑起来了。如图：
不知不觉就到深夜了，程序员的生涯就是寂寞中度过。接下来， 偶就要开始深入进行Linux内核的研究了。  希望这篇简陋的文章对还在门口徘徊的新人有点帮助！
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>“暖男”当道</title>
    <url>/hobby-warm-man-on-the-street/</url>
    <content><![CDATA[作者：韩松落
生活里缺少什么，人们才会渴望什么。正因为生活日趋坚硬，人们才渴望柔软，所以，“暖男”开始流行。一篇写“暖男”的文章，发布在个人的微信公众号上之后，创下了几百万的浏览量，足以说明，人们的这种渴望有多么强烈。
当我们谈论“暖男”时，首先面临的问题是，该怎么给出定义？综合了诸多的讨论结果之后，百度百科给出了定义：所谓“暖男”，是“能给人温暖感觉的男子”。暖男的要素，更多体现在生活和情感领域。他们温和细腻，能够洞悉和体察别人的情感，他们勤劳肯干，懂得照顾人，是顾家、爱家的生活家，能让别人觉得如沐春风，给身处不安之中的人，提供安全感和舒适感。
那么，世界上到底有没有这么温暖的人？似乎有的吧，在电影里，在小说中，在明星给出的形象里。
例如《来自星星的你》中的都教授，例如电影《横道世之介》的主人公，都是经典暖男。尤其是横道世之介，他爱笑，像是没有心事，他热情洋溢、天真烂漫，让所有人都怀念他，他乐于助人，最后也因为助人而死。他像是某个人，又像是所有人，他分明是有特性的人，呈现他性格的细节，都是那么具体，但他的形象又不那么真实。所以网友说，你会觉得世之介这个人物是真实存在于生活中的，只是想不起他到底在哪里。他是由一千个人合成的，是用理想性格为素材做成的“芭比娃娃”，更是20世纪80年代那个纯真时代的化身。

显然，所谓“暖男”，其实不过是完美男性的另一个名字，只不过，这一次加上了新的表述，换上了温暖牌包装，更注重强调男性的情感能力，隐藏了对他们经济能力的要求。为什么会在这样的年代，出现这么一种需求？心理专家刘丹概括得更好，她认为，现在人们的生活节奏快，情感成本高，人们都在避免感情投入和感情卷入，而所谓“暖男”，其实更是有感情滋养能力和投入能力的男性。
正如电影《卡萨布兰卡》中的那段台词所说，一个男人，有没有钱、有没有地位不重要，重要的是他有没有生命力。尽管，这种生命力必然有世俗意义上的结果，指向财富，指向地位。但让人叹服的，却不是财富和地位，而是滚石上山一样的、绵绵不绝的，与生命之短促、人生之艰难起伏对抗的心力和生命力，以及将周围人凝聚在一起、给他们安全感的能力。总之，在物质生活极大地丰富之后，人们又对男性提出了情感能力上的要求。
这种需求并不过分，但当我们将这种需求不断放大，将“暖男”视为寻找伴侣的最重要模板时，难免会遗憾地发现，能够满足这些条件的男性，实在太少了，甚至可以说，根本不存在。这样的男性只可能存在于电影电视里，以及明星打造的公共形象中。而现实中，每个人都有自己的脾气、性格，以及自己的具体情况。“暖男”其实是一种人造生物，供人们遐想和对照，而我们面对的，只可能是一个个具体的人，有瑕疵、有缺陷，如果要求一个人集一千个人的优点于一身，多少有点虚妄。
隐藏在这种“暖男”心理寄托背后的，还有人们一直以来对完美的渴望。这是一种乌托邦式的性格理想，沉湎在这种对完美的渴望里，只会让人对现实越发失望，对自己的认同感日渐降低。所以，当我们谈论“暖男”时，需要时刻铭记，那是一个理想，也是人性的天堂，而我们掉过头来，还是要面对自己千疮百孔的真实人生，以及漏洞百出的命运。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>引擎是什么？</title>
    <url>/hobby-what-is-engine/</url>
    <content><![CDATA[关于引擎的思考经常看到引擎这个词，比如搜索引擎，游戏引擎，浏览器引擎，javascript引擎，node.js的javascript引擎是V8……百度之，搜到的都是机械上的引擎解释。那么，在猿类的世界里，引擎到底是啥东西？
结论个人认同最佳解释：引擎是最核心的方法、组件或者模块。
理由经过向大神请教，以及群组讨论，得到了很多见解。不保证正确性，下面记录一些个人认同的观点。

最核心的方法，比如搜索引擎就表示你是用的什么搜索方式，众所周知，GOOGLE的搜索要比百度好，就是引擎做得好。


最核心的组件，比如游戏引擎是直接影响着你是3D还是2D。看一款游戏好不好，其实引擎就决定了。QQ斗地主和魔兽世界就完全不同，虽然两者都叫游戏；某些网游基本都一样玩法，就是引擎一样。


linux系统很多，但是使用的linux内核一样，内核就相当于引擎。计算机种类很多，但是很多计算机都使用Intel的CPU，CPU就相当于引擎。汽车种类很多，但是很多汽车都是用的同样的发动机（引擎）。汽车的质量也是看发动机，差的发动机肯定是做不出来法拉利赛车的。

附录
引擎一般用C++编写。


引擎更重要的是方法和理念。

2016.11.08更新一位老师给出的解释：给出一些东西，返回另一些东西，这就是引擎。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>《什么是命中注定的结局》</title>
    <url>/hobby-what-is-fate-ending/</url>
    <content><![CDATA[没有功夫去留意衰老，这就是保持年轻的最佳方法。
——罗素《论老之将至》

嘴巴是肉体的嘴巴，眼睛是精神的嘴巴。
图画的精神，可以陶冶我们的心。

图画就同数学和体育一样。人生不一定要画苹果、香蕉、花瓶、茶壶。原不过要借这种研究来训练人的眼睛，使眼睛正确而又敏感，真而又美。然后拿这真和美来应用到人的物质生活上，使衣食住行都美化起来；应用在人的精神生活上，使人生的趣味丰富起来。
——丰子恺《图画与人生》

人生的目的除了享受人生之外，还有什么呢？
——林语堂《人生快乐的问题》

我这样做一个人，已经够了。
——惠特曼

人，就是生活；我们所感受到的一切，即为宇宙；
——雪莱《论声明》

在早上起床。虽然知道这一天大致会和前一天差不多，但总有点出乎意料之外的事情会发生。像一个很偶然的电话，一个无端端来按门铃的客人。
——亦舒《生活的情趣》

正如劳累的一天带来愉快的睡眠一样，勤劳的生命带来愉快的死亡。
——达芬奇《生与死》

悠然皆生，而不知其所以生；同焉皆得，而不知其所以得。
——庄子

对他们来说，生活自身就是方法，生活自身也就是目的。
生活就是为着生活，别无其他目的。
——朱光潜《人生如戏，导演是自己》

缘是求得的，自造的。
——圣严法师《随缘》

今生似被前缘误。
——刘墉

人生一切美好经历的魅力就在于不可重复，它们因此而永远活在了记忆中。
——周国平《人生的境遇》

相貌也不单是外表，是配合了眼神和谈吐，以及许多小动作而成。
——蔡澜《看人》

友谊不必碰杯，友谊不必友谊，友谊只不过是，我们不会忘记。
愈是不愉快的时候愈要有办法愉悦自己，不能使自己快乐，也要想办法转移自己的注意力，哪怕只忘掉那最不愉快的事15分钟。有了15分钟的忘却，就有可能再平静一个小时，而再平静一个小时的结果也许能绝处逢生，也许能从黑暗中看到光明看到希望，说的夸张一点，也许这是改变你的世界观的开始，是你命运转折的开始。
——王蒙《老年是人生最美好的时候》

要是有些事我没说，地坛，你别以为是我忘了，我什么也没忘，但是有些事只适合收藏。不能说，不能想，却又不能忘。
——史铁生《我与地坛》

在一定的经济基础之上，不断追求生活质量的提高，不断充实各方面的文化修养，这就是“玩”的意义所在了。
——过传忠《玩是要学的》

有一种地方，现在看不到了，然而它的光影，它的气味，它的朦胧模样，不时闪晃在你的忆海里，片片段段，每一片每一段往往相距极远，竟又全是你人生的宝藏，令你每一次飘落居停，皆感满盈愉悦，但又微微的惆怅。
——舒国治《流浪的艺术》

我要劝告愿意充分使用视力这种天赋的人，要像明天你就会变成瞎子一样充分使用你的眼睛。
——海伦·凯勒《假如给我三天光明》

倘若上苍失手，只留了张单人床给你，那就见招拆招，将床搬至窗口，一个人以安静的姿态，微笑地看递嬗的人事，看缤纷的落英，看铺陈在远方的旖旎风景。
——简媜《女子便是好》

死亡原不必悲伤，因为你其实并没有消失，只不过以另外的方式循环往复。
——毕淑敏《带上灵魂去旅行》

爱美不一定要以填饱肚子为前提，再多的美食家也只是美食家。
——赛珍珠《中国之美》

春天姹紫嫣红，夏天荷香盈塘，秋天红染霜叶，冬天六出蔽空。
——季羡林《九十述怀》

若是听得到小草成长的声音，听得到松鼠的心跳，我们大概会因为再也无法感受宁静而被吵死。事实是，只有具备了一定程度的愚蠢，我们才能不顾路上的水洼快步走着。
——乔治·艾洛特

在思索的瞬间，我们才真实的活着，沉思是生命中唯一敏锐的瞬间。
——莫里斯·梅特林克《沙漏》
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>你会杀死那个胖子吗？</title>
    <url>/hobby-will-you-kill-the-fat/</url>
    <content><![CDATA[作者：戴维·埃德蒙兹
一辆火车正在向五个被绑在铁轨上的人飞驰而去。除非它可以停下来，否则那五个人必死无疑。这时，你正站在天桥上向下望，眼睁睁地看着这一幕就要发生的悲剧。站在你身边的是一个陌生的胖子，你可以选择将他推下桥，他会掉在铁轨上。虽然他会因此而死，但是他胖胖的身体将阻挡住前行的火车，从而挽救那五个人的生命。那么，你会选择杀死那个胖子吗？ 这个问题看上去有些古怪，它是一个哲学谜题的经典变体，被称为电车难题。半个世纪以来，这个谜题一直困扰着哲学家们。哲学家与社会学家透过这个问题的思辩来探讨进退两难的道德问题，诸如堕胎、战争、牺牲少数成全多数的各种议题。。。 
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>Win10开热点</title>
    <url>/hobby-win10-wifi/</url>
    <content><![CDATA[问题描述magicbook，使用wifi共享大师、猎豹免费wifi开热点，出现了一个十分诡异的问题：启动热点后，使用手机连接热点，可以正常上网，可以访问电脑上的ftp等服务。但是，如果手机息屏了，大概30秒后，打开手机依然显示wifi连接正常，但是无法再上网，无法再访问电脑的服务。必须先断开连接，然后重新连接wifi，才能恢复正常，非常麻烦。


尝试修改网卡电源管理，去掉“允许计算机关闭此设备以节约电源”前的勾，不行。回退网卡驱动版本，不行。换成360wifi、wifi共享精灵，不行。尝试了国外的connectfy、mhotspot，质量还不如国内的软件。换了几个版本，收费就算了，可以破解，但是有的窗口无法拖动，有的广告很多，有的读不出网卡，有的干脆启动后没反应。。。服！！！
解决办法在尝试各种解决办法的过程中，发现win10其实自带移动热点的功能。但是，使用自带的移动热点，有时连接不上，有时连上没多久就掉线，还不如用第三方软件。
不过，峰回路转，在某次尝试的过程中，把网络频带固定为2.4GHz，居然，好了！再没有任何毛病！不会连接不上，也不会自动断开！
整个设置过程如下：
1、右键右下角网络图标，选择打开“网络和Internet”设置。2、点击“移动热点”，“编辑”。3、设置网络名称和密码，重点是网络频带选择2.4GHz，切记！4、然后，就能开开心心上网了，再也没有出现过自动断开的情况，比所有的wifi共享软件都好用！
如果出现其他问题，参考知乎：win10系统开启移动热点一段时间后就自动关闭了怎么办？
注意假设电脑IP为172.20.110.235，需要特别注意的是：1、在使用第三方软件（比如wifi共享大师）开热点时，如果电脑要启动ftp服务给手机访问，那么需要绑定ftp服务的地址为172.20.110.235。ftp下载速度很快，大概20MB/s。2、在使用win10自带的“移动热点”开热点时，如果电脑要启动ftp服务给手机访问，那么需要绑定ftp服务的地址为192.168.137.1。ftp下载速度很慢，大概2MB/s。如果想要加速到20MB/s，那么网络频带选择5GHz，这时有些设备无法连接。
很神奇，如果不这么设置，就访问不到ftp服务。由上面的经验可以总结如下：如果使用win10自带的移动热点，那么此时的虚拟网卡相当于插在电脑上的一块网卡，可以通过访问它的IP而访问到电脑里的服务。如果使用第三方软件，那么此时的虚拟网卡相当于路由器，所以访问它的IP只是访问到了路由器，需要访问电脑的IP才能访问到电脑的服务。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>一件旧衣服的价值</title>
    <url>/hobby-the-value-of-an-old-clothes/</url>
    <content><![CDATA[13岁的那年，父亲有一天突然递给他一件旧衣服。
“这件衣服能值多少钱？”
“大概一美元。”他回答。
“你能将它卖到两美元吗？”父亲用探询的目光看着他。
“傻子才会买！”他赌着气说。

父亲的目光真诚中透着渴求：“你为什么不试一试呢？你知道的（佳人微信公众号：jiarenorg），家里日子并不好过，要是你卖掉了，也算帮了我和你的妈妈。”
他这才点了点头：“我可以试一试，但是不一定能卖掉。”
他很小心地把衣服洗净，没有熨斗，他就用刷子把衣服刷平，铺在一块平板上阴干。第二天，他带着这件衣服来到一个人流密集的地铁站，经过六个多小时的叫卖，他终于卖出了这件衣服。
他紧紧攥着两美元，一路奔回了家。以后，每天他都热衷于从垃圾堆里淘出旧衣服，打理好后，去闹市里卖。
如此过了十多天，父亲突然又递给他一件旧衣服：“你想想，这件衣服怎样才能卖到20美元？”
“怎么可能？这么一件旧衣服怎么能卖到20美元，它至多值两美元。”
“你为什么不试一试呢？”父亲启发他，“好好想想，总会有办法的。”
终于，他想到了一个好办法。他请自己学画画的表哥在衣服上画了一只可爱的唐老鸭与一只顽皮的米老鼠。他选择在一个贵族子弟学校的门口叫卖。不一会儿，一个管家为他的小少爷买下了这件衣服，那个十来岁的孩子十分喜爱衣服上的图案，一高兴，又给了他5美元的小费。25美元，这无疑是一笔巨款！相当于他父亲一个月的工资。
回到家后，父亲又递给他一件旧衣服：“你能把它卖到200美元吗？”父亲目光深邃。
这一回，他没有犹疑，他沉静地接过了衣服，开始了思索。
两个月后，机会终于来了。当红电影《霹雳娇娃》的女主角拉佛西来到纽约做宣传。记者招待会结束后，他猛地推开身边的保安，扑到了拉佛西身边，举着旧衣服请她签名。拉佛西先是一愣，但是马上就笑了，没有人会拒绝一个纯真的孩子。
拉佛西流畅地签完名。他笑着说：“拉佛西女士，我能把这件衣服卖掉吗？”“当然，这是你的衣服，怎么处理完全是你的自由！”
他“哈”的一声欢呼起来：“拉佛西小姐亲笔签名的运动衫，售价200美元！”经过现场竞价，一名石油商人以1200美元的高价买了这件运动衫。
回到家里，他和父亲，还有一家人陷入了狂欢。父亲感动得泪水横流（佳人微信公众号：jiarenorg），不断地亲吻着他的额头：“我原本打算，你要是卖不掉，我就叫人买下这件衣服。没想到你真的做到了！你真棒我的孩子，你真的很棒……”
一轮明月升上山头，透过窗户柔柔地洒了一地月光。这个晚上，父亲与他抵足而眠。
父亲问：“孩子，从卖这三件衣服中，你有明白什么吗？”
“我明白了。您是在启发我，”他感动地说，“只要开动脑筋，办法总是会有的。”
父亲点了点头，又摇了摇头：
“你说得不错，但这不是我的初衷。”
“我只是想告诉你，一件只值一美元的旧衣服，都有办法高贵起来。何况我们这些活着的人呢？我们有什么理由对生活丧失信心呢？我们只不过黑一点、穷一点，可这又有什么关系？”
“是的，连一件旧衣服都有办法高贵，我还有什么理由妄自菲薄呢！”
20年后，他的名字传遍了世界的每一个角落。他的名字叫——迈克尔·乔丹。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>驯服你的大脑</title>
    <url>/hobby-train-your-brain/</url>
    <content><![CDATA[驯服你的大脑慢慢来，理解越多，越不需要强记别只顾着翻页，记得停下来，好好思考。书中提出的问题，别完全不思考就直接看答案。想象是另外一个人面对面地向你提问，如果能够强迫大脑思考得更深入，就越有机会理解并记得更多的知识。
勤做练习，写下心得学以致用才能掌握知识点，实践之后，写下心得，最好在博客上。之后哪怕遗忘，也能很快记忆起来。
多提问联想，思考，会产生很多问题。在解决问题的过程中，你会学到很多东西。

将读书作为睡前最后一件事，至少是睡前最后一件具有挑战性的活动学习的一部分反应（特别是转化为长期记忆的过程）发生在放下书本之后。你的大脑需要进一步处理新知识的时间。如果处理期间塞进其他新知识，某些刚学过的东西将会遗失。
喝水，多喝水你的大脑需要浸泡在丰沛的液体内，才能运作良好，脱水（往往发生在感觉口渴前）会减缓认知功能。
念出声音，大声念出来“说话”将驱动大脑的不同部位。如果需要理解某项事物或试图增强记忆，请大声说出来，解释给别人听的效果更佳。你会学的更快，甚至触发许多新想法，光靠阅读无法有这种效果。
倾听大脑的声音注意你的大脑是否过度负荷，如果你发现自己开始恍神，或者过目即忘，就是应该休息的时候。当你错过某些重点是，请放慢脚步，否则将失去更多。
用心感受必须让大脑知道这一切很重要。试着融入故事情景，为照片加上自己的说明，即使是抱怨笑话不太好笑，都比毫无感觉更好。任何情绪反应对学习效果都有帮助。
动手吧学习编程只有一种方式：试着多多设计这种语言的代码。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Win7不用软件开wifi热点</title>
    <url>/hobby-win7-no-software-open-wifi/</url>
    <content><![CDATA[标准设置流程首先win+R，输入cmd，打开命令符提示界面，然后用以下命令来完成设置
netsh wlan set hostednetwork mode=allownetsh wlan set hostednetwork ssid="ihelloworld"netsh wlan set hostednetwork key="helloworld"netsh wlan refresh hostednetwork keynetsh wlan start hostednetwork
如果有小伙伴不会做，请直接下载文件wifi.bat，然后双击即可。然后必须执行的一步是：
打开网络和共享中心——更改适配器设置——右击你正在使用的网络连接——属性——共享——然后把两个勾都勾上
至此，理论上你已经成功开启了名为“ihelloworld”，密码为“helloworld”的wifi。如果有什么问题，欢迎留言或直接联系我。


常用命令集锦有时候通过以上命令无法成功启动无线，就需要下面的命令来调试。
显示支持的承载网络

netsh wlan show drivers

显示你的无线承载网络的信息

netsh wlan show hostednetwork

启动无线承载网络

netsh wlan start hostednetwork

停止你的无线承载网络

netsh wlan stop hostednetwork

更改网络名称

netsh wlan set hostednetwork ssid=”你的名称”

更改密码

netsh wlan set hostednetwork key=”你的密码”

如果想密码立即生效可以用

netsh wlan refresh hostednetwork key

最后就是你真的不用这个无线网络了，你停止之后，也不想看到多出来的那块无线网卡，那么就执行

netsh wlan set hostednetwork mode=

就再也看不到那块网卡了，当然你想重新开启的话就执行

netsh wlan set hostednetwork mode=allow

PS：如何设置才能让它开机自动启动？在win7系统下可以这样设置，打开记事本，输入netsh wlan start hostednetwork，保存（文件名为”启动wifi.bat”，保存类型选所有文件）。打开开始-所有程序-附件-系统工具-任务计划程序-创建基本任务-填写名称（自己命名）-下一步-选择计算机启动时-下一步-浏览-找你建的那个文件选定-下一步-完成。OK了,下次在你开机的时候就会自己启动了。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>wifi</tag>
      </tags>
  </entry>
  <entry>
    <title>穷人和富人的人脉</title>
    <url>/hobby-the-poor-and-the-rich-network/</url>
    <content><![CDATA[作者：万维钢
引导语：中国人喜欢谈人脉，有句戏言称：“社会关系就是生产力。”拉关系，很多人都做。不管你有多么不喜欢，但在社会中做事情往往就是要依赖各种关系。
　　弱联系作用大
　　也许在很多人眼中，建立有价值人脉的关键，是寻求一种比较亲密的关系，比如“一起同过窗、一起扛过枪”，而社会学家们恰恰不这么认为。
　　斯坦福大学教授马克·格兰诺维特，曾经在20世纪70年代研究过在波士顿近郊居住的技术人员和经理人员是怎么找到工作的。格兰诺维特找到282人，随机选取100人做面对面的访问。他发现，通过正式渠道（比如看广告投简历）得到工作的不到一半。100人中，有54人是通过个人关系找到工作的。这是一个相当可观的数字。

　　这里面，真正有意思的不是靠关系，而是靠什么关系。
　　所谓多个朋友多条路，那么，这条路到底更有可能是什么样的朋友给的呢？格兰诺维特发现，真正有用的关系，不是亲朋好友这种经常见面的“强联系”，而是“弱联系”。在这些靠关系找到工作的人中，只有16.7%经常能见到他们的这个“关系”，也就是每周至少见两次面。而55.6%的人用到的关系人，仅仅偶然能见到，亦即每周见面不到两次，但每年至少能见一次。另有约28%的帮忙者，一年也见不到一次。也就是说，大多数你真正用到的关系，是那些并不经常见面的人。这些人未必是什么大人物，他们可能是不常联系的老同学或同事，甚至可能是你不太熟悉的人。他们的共同特点是：不在你当前的社交圈里。
　　接触圈外的人
　　格兰诺维特对这个现象有一个解释。整天跟你混在一起的这帮人，很可能干的事跟你差不多，想法必然很接近。如果你不知道有一个这样的工作机会，他们又怎么会知道？只有“弱联系”才有可能告诉你一些你不知道的事情。
　　“弱联系”的真正意义，是把不同社交圈子连接起来，从圈外给你提供有用的信息。根据弱联系理论，一个人在社会上获得机会的多少，与他的社交网络结构有很大关系。如果你只跟亲朋好友交往，或者认识的人都是与自己背景类似的人，那么，你大概就不如那些三教九流什么人都认识的人机会多。人脉的关键，不在于你融入哪个圈子，而在于你能接触多少圈外的人。(感人爱情故事 www.wenzhangba.com)
　　这样说来，岂不是从一个人的社交网络结构，就能判断这个人的经济地位如何？
　　2010年，美国研究人员把2005年8月整个英国几乎所有的电话通讯记录拿过来，涵盖90%的手机和超过99%的固定电话。这些电话记录，构成了可见的社交网络。研究者很难知道每个人的经济状况，但是，英国政府有全国每个小区的经济状况数据，可以查到哪里是富人区，哪里是穷人区。就这样，他们把电话通讯记录跟其所在的3万多个小区的居民的经济排名进行对比。
　　结果非常明显，越是富裕的小区，其交往的多样性越明显。但是，这个结果如果细看的话，还有更多有意思的东西。在统计上，我们使用“相关系数”来表示二者之间的相关性，它的值在-1和1之间，越接近1，就表示这二者越容易一起变大或变小，负值则表示二者变化的方向相反。小区的经济排名与其居民社交网络的“社会多样性”和“地区多样性”的相关系数，分别是0.73和0.58。
　　这意味着，越是富人越容易跟不同阶层和不同地区的人联络，阶层多样性要比地区多样性更重要，正所谓“贫居闹市无人问，富在深山有远亲”。我们设想富人的联系人数也应该较多，因为他们认识的人比穷人多，这也是对的，但联系人数和经济排名的相关系数只有0.44，并不太重要。最有意思的一点是，打电话时间长短，跟经济排名的相关系数是-0.33，也就是说，富人虽然爱跟各种人联系，但真正通话时间比穷人短。
　　信息传递的价值
　　这种数据分析只能告诉我们，社交网络跟经济地位之间有这样的关系，但不能告诉我们到底是谁导致谁。你富，才有不同的人愿意跟你接触，还是因为你愿意跟不同类型的人接触，你才富有？格兰诺维特的理论，还说明另一个问题：事实上，我们每个人与认识的大多数人，都是“弱联系”，“强联系”只是少数。如果让所有认识的人每人给我们一条工作信息，最后有用的这条信息，当然有更大的可能性来自“弱联系”。
　　格兰诺维特对此提出一个解释：生活中，“强联系”和“弱联系”跟我们交流的次数相差极大。我们跟“强联系”之间交流的信息，要远远多于“弱联系”。这种交流到底多多少，他没有办法量化计算，但是来自“弱联系”的信息总量，可能并不比“强联系”多。那么，这样看来，还是“弱联系”重要，因为它传递的有价值信息的比例更大。
　　所以，弱联系理论的本质不是人脉，而是信息的传递。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows运行命令大全</title>
    <url>/hobby-windows-cmd-all/</url>
    <content><![CDATA[
gpedit.msc—–组策略 

sndrec32——-录音机

Nslookup——-IP地址侦测器

explorer——-打开资源管理器

logoff———注销命令

tsshutdn——-60秒倒计时关机命令

lusrmgr.msc—-本机用户和组

services.msc—本地服务设置

oobe/msoobe /a—-检查XP是否激活

notepad——–打开记事本

cleanmgr——-垃圾整理

net start messenger—-开始信使服务


compmgmt.msc—计算机管理

net stop messenger—–停止信使服务

conf———–启动netmeeting

dvdplay——–DVD播放器

charmap——–启动字符映射表

diskmgmt.msc—磁盘管理实用程序

calc———–启动计算器

dfrg.msc——-磁盘碎片整理程序

chkdsk.exe—–Chkdsk磁盘检查

devmgmt.msc— 设备管理器

regsvr32 /u *.dll—-停止dll文件运行

drwtsn32—— 系统医生

rononce -p —-15秒关机

dxdiag———检查DirectX信息

regedt32——-注册表编辑器

Msconfig.exe—系统配置实用程序

rsop.msc——-组策略结果集

mem.exe——–显示内存使用情况

regedit.exe—-注册表

winchat——–XP自带局域网聊天

progman——–程序管理器

winmsd———系统信息

perfmon.msc—-计算机性能监测程序

winver———检查Windows版本 

sfc /scannow—–扫描错误并复原

taskmgr—–任务管理器（2000／xp／2003

winver———检查Windows版本 

wmimgmt.msc—-打开windows管理体系结构(WMI) 

wupdmgr——–windows更新程序 

wscript——–windows脚本宿主设置 

write———-写字板 

winmsd———系统信息 

wiaacmgr——-扫描仪和照相机向导 

winchat——–XP自带局域网聊天

mem.exe——–显示内存使用情况 

Msconfig.exe—系统配置实用程序 

mplayer2——-简易widnows media player 

mspaint——–画图板 

mstsc———-远程桌面连接 

mplayer2——-媒体播放机 

magnify——–放大镜实用程序 

mmc————打开控制台 

mobsync——–同步命令

dxdiag———检查DirectX信息 

drwtsn32—— 系统医生 

devmgmt.msc— 设备管理器 

dfrg.msc——-磁盘碎片整理程序 

diskmgmt.msc—磁盘管理实用程序 

dcomcnfg——-打开系统组件服务 

ddeshare——-打开DDE共享设置 

dvdplay——–DVD播放器

net stop messenger—–停止信使服务 

net start messenger—-开始信使服务 

notepad——–打开记事本 

nslookup——-网络管理的工具向导 

ntbackup——-系统备份和还原 

narrator——-屏幕“讲述人” 

ntmsmgr.msc—-移动存储管理器 

ntmsoprq.msc—移动存储管理员操作请求 

netstat -an—-(TC)命令检查接口

syncapp——–创建一个公文包 

sysedit——–系统配置编辑器 

sigverif——-文件签名验证程序 

sndrec32——-录音机 

shrpubw——–创建共享文件夹 

secpol.msc—–本地安全策略 

syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码 

services.msc—本地服务设置 

Sndvol32——-音量控制程序 

sfc.exe——–系统文件检查器 

sfc /scannow—windows文件保护

tsshutdn——-60秒倒计时关机命令 

tourstart——xp简介（安装完成后出现的漫游xp程序） 

taskmgr——–任务管理器

eventvwr——-事件查看器 

eudcedit——-造字程序 

explorer——-打开资源管理器

packager——-对象包装程序 

perfmon.msc—-计算机性能监测程序 

progman——–程序管理器

regedit.exe—-注册表 

rsop.msc——-组策略结果集 

regedt32——-注册表编辑器 

rononce -p —-15秒关机 

regsvr32 /u *.dll—-停止dll文件运行 

regsvr32 /u zipfldr.dll——取消ZIP支持

cmd.exe——–CMD命令提示符 

chkdsk.exe—–Chkdsk磁盘检查 

certmgr.msc—-证书管理实用程序 

calc———–启动计算器 

charmap——–启动字符映射表 

cliconfg——-SQL SERVER 客户端网络实用程序 

Clipbrd——–剪贴板查看器 

conf———–启动netmeeting 

compmgmt.msc—计算机管理 

cleanmgr——-垃圾整理 

ciadv.msc——索引服务程序

osk————打开屏幕键盘 

odbcad32——-ODBC数据源管理器 

oobe/msoobe /a—-检查XP是否激活 

lusrmgr.msc—-本机用户和组 

logoff———注销命令

iexpress——-木马捆绑工具，系统自带

Nslookup——-IP地址侦测器

fsmgmt.msc—–共享文件夹管理器

utilman——–辅助工具管理器

gpedit.msc—–组策略


]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows快捷键</title>
    <url>/hobby-windows-shortcut-key/</url>
    <content><![CDATA[f系列F1 帮助F2 改名F3 搜索F4 地址F5 刷新F6 切换F10 菜单


ctrl系列ctrl+A 全选ctrl+C 复制ctrl+X 剪切ctrl+V 粘贴ctrl+Z 撤消ctrl+O 打开ctrl+P 打印ctrl+S 保存ctrl+F4 关闭tab页ctrl+esc 开始菜单Ctrl+1,2,3…　切换到从左边数起第1,2,3…个标签 
shift系列shift+delete 永久删除shift+右键 可以选择打开powershell
alt系列alt+F4 关闭软件alt+enter 属性alt+tab 切换窗口alt+空格 窗口菜单 
win系列win 开始菜单win+F1 帮助win+D 显示桌面win+R 运行win+E 打开我的电脑win+F 搜索文件或文件夹win+U 打开设置win+tab 切换窗口win+P 多显示器设置
三键组合系列ctrl+alt+delete 切换用户、注销、更改密码、任务管理器ctrl+shift+esc 任务管理器win+shift+左右键 移动窗口到另一个屏幕
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows的一些技巧</title>
    <url>/hobby-windows-skill/</url>
    <content><![CDATA[1、realtek高清晰音频管理器，关闭图标开始&gt;运行&gt;输入msconfig&gt;启动&gt;取消勾选”realtek高清晰音频管理器”的开机自启动项&gt;OK&gt;重启生效
2、菜单栏消失控制面板-外观和个性化-文件夹选项-查看-始终显示菜单
3、删除用户开始-控制面板-性能和维护-管理工具-计算机管理-本地用户和组-用户删掉你不想要的用户。
4、切换管理员账户计算机右击-管理-本地用户和组-用户-administrator-帐户已禁用去掉勾-关机旁的切换用户


5、设置自动关机进入命令提示符界面，输入“at 18:30 shutdown -s”，表示设置在18:30自动关机。输入“at”可以查看当前任务。取消自动关机，“at /del”或者“at 1 /del”。
6、修改盘符计算机右击，管理，磁盘管理，选中需要修改的卷，右击，更改驱动器号和路径。
7、去除用户账户控制控制面板，用户账户（大图标），更改用户账户控制设置，将按钮调到最低（从不通知）。
8、隐藏NVIDIA 控制面板双击（或者右击）打开“NVIDIA控制面板”，（不行的话就在控制面板里面打开）然后点“桌面”，去掉那些勾。有个右下角的，还有个桌面的，去掉就可以了。
9、移动桌面C盘，Users（或者用户），当前用户文件夹（一般是Administrator），找到桌面文件夹。右键，属性，位置，把“C:\Users\Administrator\Desktop”改为你想存放的位置，比如“D:\桌面”，然后点移动就OK。
10、能上QQ不能打开网页DNS服务器配置错误。
11、win7修改文件名不能使用搜狗输入法修改完hosts文件后，出现这个问题。解决办法：重启。
12、ISO镜像制作使用UltraISO
13、pagefile.sys转移右击计算机，属性，高级系统设置，高级，性能设置。性能选项窗口中，高级，虚拟内存更改。
14、hiberfil.sys删除命令提示符下：powercfg -h off
15、右击文件夹出现Runtime Errorwinmount这款软件的问题，卸载了就OK了，或者设置去掉右键菜单。迷你版的mini winmount，官方介绍说功能跟标准版一样。
16、在cmd里结束进程tasklisttaskkill /f /t /im firefox.exe
17、网络管理命令ping/?nslookup
18、使用SYSTEM超级管理员账户（最高权限）taskkill /f /im explorer.exeat 20:00 /interactive %systemroot%\explorer.exe
19、批量修改文件名dir /b&gt;rename.xls使用wps打开rename.xls，在B1单元格输入1.jpg，其余行自动生成。在C1单元格输入公式=”ren “&amp;A1&amp;” “&amp;B1，其余行自动生成。复制C列，粘贴到记事本，重命名为.bat文件。双击.bat文件。
20、利用系统加密文件夹(适用XP)md f:\my..start f:\my..\
21、win7库的使用计算机，库，音乐库，点击蓝色的n个位置。计算机，库，右击音乐库，属性。
22、豆丁文档免费下载。百度快照或者豆丁文档下载器
23、捉弄人的高招截屏，设置为桌面
24、如何在ppt中批量插入图片插入，图片，分页插入图片
25、校园视频网破解云窗(校园视频网)破解版，安徽师范大学2010级计算机王宇辉开发。http://wangyuhui.com.cn
26、文件合成copy /b test.jpg + test.rar finish.jpg
27、win7运行ewb时，拖动原件以后背景会变成某一时刻的桌面背景解决办法：在exe上右键，属性，兼容性，两个禁用选一下，点应用。
28、win10右键显示设置和个性化，出现“该文件没有与之关联的程序来执行该操作……”。解决办法：WIN+R打开运行，输入regedit，地址栏输入HKEY_CURRENT_USER\Software\Classes\ms-settings，把ms-settings重命名为ms-settings1。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>单词缩写</title>
    <url>/hobby-word-abbreviation/</url>
    <content><![CDATA[缩写    全称POSIX    Portable Operating System Interface of Unix（可移植操作系统接口）LSB           Linux Standard Base (Linux标准基础)FHS        File system Hierarchy Standard(文件系统层次标准)GNU        GNU’s Not UnixFSF        Free Software FoundationBSD        Berkeley Software DistributionLFS        Linux From ScratchBLFS    Beyond Linux From ScratchCLFS    Cross Linux From ScratchHLFS    Hardened Linux From ScratchMBR        Master Boot RecorderGNOME    The GNU Network Object Model Environment

SELinux    Security Enhanced LinuxLPI        Linux Professional Instituteext3    Third Extended File System(第三文件扩展系统)VFS        Virtual Filesystem Switch(虚拟文件交换系统)KDE        Kool Desktop EnvironmentIDE        Integrated Development Environment(集成开发环境)CLI        command-line interface(命令行界面)GUI        Graphical User Interface(图形用户界面)GPT        全局唯一标识分区表(GUID Partition Table)VPS        Virtual Private Server （虚拟专用服务器）DNSR    domain name system resolutionSSH        Secure ShellPAM     Pluggable Authentication Modules, 嵌入式模块SEO        Search Engine Optimizationrss        Really Simple Syndication | RDF Site Summary | Rich Site SummaryRDF        Resource Description FrameworkVPN        Virtual Private NetworkRE        Regular Expression(正则表达式)RHCA    Red Hat Certified Architect(红帽认证架构师)RHCT    红帽认证技师RHCE    红帽认证工程师RHEL    Red Hat Enterprise LinuxOSI(OSI/RM)        Open System Interconnection Reference ModelMAC        Media Access ControlLLC        Logic Link ContorlWLAN    Wireless Local Area NetworkNOS        Network Operation SystemTCP        Transmission Control ProtocolIP        Internet ProtocolUDP        User Datagram protocolARP        Address Resolution ProtocolRARP    Reverse Address Resolution ProtocolDHCP    Dynamic Host Configuration Protocoltty        teletypewriterGnome    GNU’s network object model environmentipconfig        Internet Protocol Configuring（IP地址配置）ifconfig        Network Interfaces Configuring（网络接口配置）css        Cascading Style Sheets
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
  </entry>
  <entry>
    <title>word格式刷</title>
    <url>/hobby-word-format-brush/</url>
    <content><![CDATA[前言格式刷位于“格式”工具栏上，相当好认，就是一把“刷子”。用它“刷”格式，可以快速将指定段落或文本的格式延用到其他段落或文本上，让我们免受重复设置之苦。 
复制文字格式1．选中要引用格式的文本。 
2．单击“格式”工具栏上的“格式刷”按钮，此时鼠标指针显示为“I”形旁一个刷子图案。 
3．按住左键刷（即拖选）要应用新格式的文字。 


复制段落格式1．选中要引用格式的整个段落（可以不包括最后的段落标记），或将插入点定位到此段落内，也可以仅选中此段落末尾的段落标记。 
2．单击“格式”工具栏上的“格式刷”按钮。
3．在应用该段落格式的段落中单击，如果同时要复制段落格式和文本格式，则需拖选整个段落（可以不包括最后的段落标记）。 
提示1．单击“格式刷”按钮，使用一次后，按钮将自动弹起，不能继续使用；如要连续多次使用，可双击“格式刷”按钮。如要停止使用，可按键盘上的Esc键，或再次单击“格式刷”按钮。执行其他命令或操作（如“复制”），也可以自动停止使用格式刷。 
2．复制格式的组合键：Ctrl+Shift+C、Ctrl+Shift+V。而且Ctrl+Shift+V还有一个特点，只要曾经复制过某种格式，就可以反复使用此快捷键将此格式应用到其他段落或文字上，不受其间其他操作的影响，直到复制了一种新的格式。 
3．使用上述方法，可以在不同的Word文档间进行格式复制。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title>word通配符的使用</title>
    <url>/hobby-word-wildcard/</url>
    <content><![CDATA[常见的几种通配符的使用方法任意单个字符：“?”可以代表任意单个字符，输入几个“?”就代表几个未知字符。如：输入“? 国”就可以找到诸如“中国”、“美国”、“德国”等字符；输入“???国”可以找到“孟加拉国”等字符。
任意多个字符：“*”可以代表任意多个字符。如：输入“*国”就可以找到“中国”、“美国”、 “孟加拉国”等字符。
指定字符之一：“[]”框内的字符可以是指定要查找的字符之一，如：输入“[中美]国”就可以找到“中国”、“美国”。 又如：输入“th[iu]g”，就可查找到“thigh”和“thug”。 输入“[学硕博]士”，查找到的将会是学士、士、硕士、博士。


指定范围内的任意单个字符：“[x-x]”可以指定某一范围内的任意单个字符，如：输入“[a-c]mend”的话，Word查找工具就可以找到“amend”、“bmend”、“cmend”等字符内容。
排除指定范、排除指定范围内的任意单个字符： “[!x-x]”可以用来排除指定范围内的任意单个字符，如：输入“[!a-c]”的话，word程序就可以找到“good”、“see”、“these”等目标字符，而所有包含字符a、b、c之类的内容都不会在查找结果中出现。
指定前一字符的个数：“{n}”可以用来指定要查找的字符中包含前一字符的个数，如：输入“cho{1} se”就是说包含1个前一字符“o”，可以找到“chose”，输入“cho{2}se”就是说包含2个前一字符“o”，可以找到， “choose”。
指定前一字符、指定前一字符数范围：“{x,x}”可以用指定要查找字符中前一字符数范围，如：输入“cho{1,2}”，则说明包含前一字符“o”数目范围是1-2个，则可以找到“chose”、“choose”。
一个以上的前一字符：“@”可以用来指定要查找字符中包含一个以上的前一字符，如：输入”，就可以找到， “chose”、“choose”等字符。
指定起始字符串：“&lt;”可以用来指定要查找字符中的起始字符串，如：输入“&lt;ag”，就说明要查找的字符的起始字符为“ag”，可以找到 “ago”、“agree”、“again”等字符。输入“&lt;te”的话，可能查到“ten”、“tea”等。
指定结尾字符串： “&gt;”可以用来指定要查找字符中的结尾字符串，如：输入“er&gt;”，就说明要查找的字符的结尾字符为“er”，可以找到 “ver”、“her”、“lover”等等。输入“en&gt;”， 就说明要查找到以“en”结尾的所有目标对象，可能找到“ten”、“pen”、“men”；输入“up&gt;”，就说明要查找到以“up”结尾的所有目标对象，例如会找到“setup”、“cup”等等。
去除回车想必大家都有过这种经历，从网页上或者txt文档上复制一段文字到Word中，本该是一段完整内容的文字，被回车分成了一行行的（如下图），编辑起来非常不方便，一个个的删除又太麻烦，太浪费时间，这个时候大家不妨来试试下面的方法。1、选中该段文字，Ctrl + H ，打开查找替换窗口；2、单击“更多”按钮，在使用通配符前面选中；3、在查找内容处输入([!。：……？！）])^13{1,}，在替换为处输入\1，单击全部替换；4、关闭查找替换窗口，我们就会奇迹般地发现，原先被回车乱七八糟的内容，变为了完整的一段。
为完形填空中添加下划线在制作英语试卷的阅读理解时，最麻烦的就是在英语的文章中输入带下划线的数字了。常规的方法是用“格式刷”工具一个一个地复制格式，能不能用格式替换的方法来实现呢？答案是肯定的。
在输入这些带有下划线的数字时无需设置任何格式或在其左右添加过多的空格，输入完成后选中该段文本，按“Ctrl+H”组合键打开“查找和替换”对话框，切换到“替换”选项卡，单击“高级”按钮，勾选“使用通配符”复选框，在“查找内容”框中输入“[0-9]{1，}”(其中“[0-9]{1，}”表示1个以上的数字);在“替换为”框中输入“^32^&amp;^32”(即在查找到的数字前后各加一个半角空格，其中“^32”为半角空格，“^&amp;”为查找到的数字，如图1)。
单击对话框下方的“格式”按钮，选中“字体”命令，在弹出的对话框中选择需要的“下划线线形”，确定后返回替换对话框中，单击“全部替换”按钮可以看到替换后的效果了(如图2)。
小提示：当前操作是对选中的文本进行操作的，在替换完毕后系统会提示要不要查找文档的其余部分，此时应选“否”。
将数字间的句号改为小数点在文本录入时经常会遇到将数字间的小数点误输入成句号“。”的情况，在替换时要注意如果句号出现在数字中间那就需要将其转换为小数点即“.”;如果句号出现在数字的末尾就无需替换，所以不能简单地查找句号然后再替换为小数点。
使用通配符查找的方法就可以轻松解决这个问题了。打开替换对话框，勾选“使用通配符”复选框，在“查找内容”框中输入“([0-9]{1，})。([0-9]{1，})”，其含义是查找数字中间含有“。”的字符串;在“替换为”框中输入“\1.\2”(其中“\1”和“\2”分别代表原数字字符串中“。”左右的两个数字表达式，如图3)，单击“全部替换”按钮，数字间的“。”就全部替换为小数点了。
删除中英文混排中的空格如果遇到中英文混排的文档中有许多的空格，有时连续的空格还不止一个，如何去掉中文中的空格同时保留英语单词间的空格呢？由于涉及的条件比较复杂，一次替换的确有些困难，所以在多次尝试后发现用下面的两步替换就可以实现了。
首先要将文档中的多个连续的空格变成一个半角空格，方法是在勾选“使用通配符”的替换对话框中查找“^32{1，}”(其含义是一个以上的空格)，在“替换为”框中输入“^32”，这样替换后连续的多个空格就替换为一个半角空格了。
然后将“查找内容”更改为“([!a-zA-Z])( )([!a-z，A-Z])”(即查找非英文字符间的空格，其中“[!a-zA-Z]”的含义是除大小写字母以外的其他任意字符)，在“替换为”框中输入“\1\3”，单击“全部替换”按钮后就可以看到除英文间的空格保留之外，其余多余的空格都被删除了(如图4)。
小结word中的通配符替换功能的确强大，用好它可以帮我们解决日常办公中的许多难题。
说到通配符，不得不提到正则表达式。基本区别，就是通配符是系统命令使用，一般用来匹配文件名；而正则表达式是操作字符串，以行为单位来匹配字符串使用的。但是，这个区别，放在windows中似乎不太合适，因为word恰恰使用通配符来处理字符串。
linux中，通配符多用在文件名上，比如查找find、ls、cp；在文本过滤工具里，都是用正则表达式，比如grep、awk、sed，是针对文件的内容的。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>windows</tag>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title>你总会信仰些什么</title>
    <url>/hobby-you-alway-believe-something/</url>
    <content><![CDATA[作者：白岩松
读书读久了，你总会信仰些什么。
当我们翻开一本书，要在翻开的这本书里头寻找到什么呢？这个话题似乎要从我们刚刚出生来到这个世界上开始说起。当人生的这本书刚刚翻开，在未来漫长的岁月里，在这本书里，我们又要寻找到什么呢？也许两者的答案有很多是相似的。首先翻开一本书，我们希望知道自己是谁，我的家乡在哪里，而世界又在哪里。
如果我不打开书，我会以为世界就像我生活的这座城市一样，有草原，有森林，有很多和善的人们。但是当我打开书才知道，《上下五千年》里有那么多的历史；当我打开书的时候，我知道在《一千零一夜》里还有另外一个跟我们完全不一样的世界；当我打开书的时候才知道有好人、有坏人；当我打开书的时候才知道，北京、江苏、四川或者其他的地方怎么怎么样。了解的事情越来越多了，这个世界开始变得越来越大了，结果一个又一个少年该如同我一样，开始向往外面的世界。如果没有书，你不会知道世界是个什么概念，即便后来当你的年岁足够大了，当你来到一个又一个陌生的国度里，你竟然发现一切似乎没那么陌生，因为早在白纸黑字上，早在字里行间，早在曾经翻开的一本又一本书当中，你曾经如此亲密地靠近过它，世界变得不再那么遥远，也不再那么陌生了。

说起来真的有意思，总有很多人问我，对我影响最大的一本书是什么？我的答案永远是一样的，当然是《新华字典》了。如果要是没有《新华字典》，没有我从最简单的一个又一个汉字开始认识起，一直到后来，我怎么会有勇气、有能力翻开一本又一本或厚或薄的书呢？如果我不能翻开那些书，我的很多困惑、我的很多未知怎么能在我的面前陆续打开呢？成长是什么？成长不仅是年岁慢慢增长，更重要的是内心所累积的一个又一个问号慢慢地得到答案。
当你的答案越来越多，当你的问号开始慢慢地被抻直的时候，你就是在成长。最小的时候可能在读《十万个为什么》，获取一个又一个答案，如果没有那些书，答案不出现在你的面前，你就永远像是一个仰望星空的孩子。虽然在这一生当中葆有好奇，葆有问号，永远是一个最重要的事情，但是，在你成长的过程中，如果你的一个又一个问题不能得到解答的话，成长怎么可能变成现实呢？从你最初好奇的一加一等于二，到后来一加一等于二不再是一个简简单单的数学题，而是人生，是大的哲学，是你如何去捍卫常识；当别人因为自己的利益，能喊出一加一等于三，甚至等于四的时候，你还有勇气去坚持说一加一等于二。你想想我们走了多远的路程了。从最初只是一个最简单的小学的数学题到后来与常识、与正义、与真理有关，如果没有那一本又一本翻开的书，你怎么可能有这种成长呢？总有人问我读书有什么好处。我说用几个“解”来回答你吧，它可以解惑，它可以解气，有的时候你有很多这种郁闷和生气，打开书看到有与你同样生活在这个世界上的人，或者古人甚至都提前把那种呐喊替你发泄出来，你就觉得挺解气的。
另外，还解决你的很多挣扎和困惑。翻开一本又一本书的时候，你看到答案，拥有了一种解决的方案，道路变得更加清晰了。当然千万别忘了，看书还有另外的功能，那就是有的时候还解闷。哪怕现在人们开玩笑连解手的时候，都需要有那些看起来不那么累的书能陪伴你度过人生当中永远不会没有的这种时光。一天总是琐碎的，但是累加在一起却可能会获取很多知识，因此，我觉得一个能提供这么多“解”的书，会帮助一个又一个人更好地走这样一个成长的道路。
在我们寻找的无数答案当中，最后一种答案可能非常的重要。它帮助我们寻找到平静和幸福，我们可能都记着这样的一句话，“华北之大，已经安放不下一张平静的书桌了”。那是一个屈辱的时代。但是现代在物质大潮快速奔涌而来的时候，这句话可以稍微地变一变了，变成什么呢？
“中国之大，找到一颗平静的心简直太难了。”但是不平静又怎么可能幸福呢？我曾经有过这样的经历，周围是乱的，自己的心里也是乱的，当你打开书想在书里找到平静的时候，最初几页是很难的。但是当最初的几页慢慢读进去了，你就觉得好书真像是一堵又一堵的墙，开始慢慢地升腾起来，把外面的车水马龙还有那些喧嚣的声音都阻拦在了外面。这个时候，你觉得那颗躁动的心慢慢地安静下来，这个世界你似乎又可以在白纸黑字里闻得到花香，听得到鸟的声音，大自然仿佛又回到了你的身边。更重要的是没有平静怎么可能幸福呢？
那么，幸福与读书、与平静有什么关系吗？很有关系，幸福是由三个关键词构成的，那就是物质、情感和精神。只有物质基础、情感依靠、精神支柱这三种因素的分数都不错，加起来你的幸福指数才高。而读书与这三者紧密相关，“读书无用论”的论调早已经慢慢消散了，那个时代也结束了。
早有调查显示，人们读书和知识获取的水平和你的工资收入是成正比的，我想只有你的读书足够多了，你才会更有创意，才会更自信，你才会更有底气，才能获取更多的物质回报。但是这还不是最重要的。书读得多了，你在情感方面会是一个充沛的、获益很多的人，你的依靠会更充实，更重要的是在读书中会寻找到我们的信仰和精神支柱。中国人的信仰千百年来并不是仅仅靠宗教来支撑的，它就在唐诗宋词当中，在爷爷姥姥讲给你的故事里，在《三国演义》里，在《红楼梦》里，在《西游记》里，在无数的经典书籍当中，至今依然被文人用那种美丽的方块字写在字里行间。
读书读久了你总会信一些什么，信一些什么就有了敬，有了畏，因为信仰我认为最重要的是“敬畏”二字。有了敬，有了畏，知道什么是最好的我要去做，知道什么是不好的我不能逾越它，就如同社会这条奔腾的大河两边有了安全的河床，敬和畏这两个河床在，不管这条河流如何奔涌，总是安全的。我们现在正处在慢慢建两边河床的过程中。
因此，如果更多的中国人能够多读书，能够让自己的心平静下来，能在这里慢慢找到幸福感并且找到自己的话，中国就会变得更好。也许读书不能解决所有的问题，但是读书可以改变很多，可以让我们一个又一个人变得更好。
当我们一个又一个人变得更好的时候，你什么样，中国就什么样。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>《你只是看起来很努力》</title>
    <url>/hobby-you-just-look-like-trying-hard/</url>
    <content><![CDATA[
对这个世界来说，没有什么果是没有因的，即使现在因看不出来，但也一定是存在的。


骗别人很容易，骗自己更容易，可是，骗这个世界的因果，有点难。


学习之前，你有没有制定计划，告诉自己今天我要学到什么；背下来什么；掌握什么能力。没有目标的努力，没有计划的奋斗，都只是作秀而已。



《你只是看起来很努力》，看完序章，就有了买书的冲动。
努力，是一个私人的事情，需要踏实、坚持、心无旁骛。任何一个领域，想要超越别人，成为专家，都要付出别人无法付出的努力。这种努力，不是心血来潮，不是一纸计划单。而是知行统一，专注、投入、热爱、癫狂、疯魔。
很自然的，想到了考研。我一直以为，自己已经非常努力。现在想想，当时的我，并没有真正倾尽全力。以劳逸结合的借口，还有时间看非诚勿扰，还有时间关注新闻，还有时间熬夜刷贴吧。。。艾佳生活，一位面试我的前辈，他以前也考研，准备了三个月，每天早6晚12，考研成功。。。不疯魔不成活！再给我一次机会，我能考好吗？不一定！但是，把握会更大！
前人说，不逼自己一把，你永远不知道自己有多么优秀！如果一件事，没有危及到自身的利益，没有让我们羡慕嫉妒恨，我们总是不急着去做。知道锻炼重要，但只有生病的时候，才会下定决心好好锻炼，保持健康；知道健身有益，但只有看到身边的人秀胸肌腹肌的时候，才会因为羡慕嫉妒而去健身；喜欢技术，但只有当这门技术决定前途命运的时候，才会开始用心学习；喜欢钢琴，但只有看到别人十指轻舞的时候，才会再次告诉自己，该去学琴了。。。当危机过去，当热情过去，有多少人，还会继续锻炼、健身、学技术、学钢琴？
机会给有准备的人，而不是给机会来了再去准备的人。厚积薄发，在别人背后偷偷努力，变得优秀，变得卓越，才是一个真正上进的人！
有些事情，不着急，但是更重要。比如孝顺，比如爱情，比如旅行，比如阅读。。。生命不知道何时休止，要考虑清楚，这一生有哪些事情是必须要做，优先要做的。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>你要学习</title>
    <url>/hobby-you-should-study/</url>
    <content><![CDATA[你要是天天一大早六点起床，吃顿好饭，奔去教室背两篇新三，八点坐直在教室的前排，使劲不分心地听完两节还是四节课，课间练字背单词看报纸，放学奔去食堂抢份好饭，吃完回宿舍，洗洗衣服拖拖地消化下，再听VOA，一倍速听完听1.5，1.5听完听2倍，听困了上床歇中觉，下午继续坐直在前排听完四节课，放学去食堂抢个馒头奔回寝室啃完，收拾好书包就去教室上自习，拼到十点半赶在关门前回宿舍，洗漱完了继续听VOA听新三，听累了看书，看累了上床睡觉。周六带一天干粮去泡死在图书馆，周日半天上街采购，半天整内务看闲书，晚上继续滚教室自习，想考北大清华耶鲁牛津的，周日就别放假，你还有个鬼空去迷茫，去忧伤啊！
你要是想到以后吃不起肉，旅不起游，看不起最新大片，连买份三块钱的南方周末都要犹豫挣扎下，你还敢迷茫敢忧伤啊！你当你是少年维特啊，维特的烦恼之所以迷人，那是人家名字前还有少年两个字。你要是混到中年，住不起房，开不起车，泡不起妞，天天对着现实哼哼唧唧，鬼会去聆听你那”凄美感伤”的烦恼。

你说说你都这么把年纪了，还玩什么淡淡的忧伤，深深的迷茫啊，再不拼命，毕业就要去要饭了，就算天上掉个馅饼，你还要比别人先发现张嘴去接着提前准备呢。你迷茫个鬼忧伤个死啊，看人家谈恋爱你羡慕什么，还怕以后找不到老婆吗，看人家拿offer满世界跑你眼红什么，没看到人家怎么呕心沥血苦尽甘来么。还不滚去啃书拼命去，上个P网，偷个P闲！
寂寞。一个人早起晚睡不难，但在一群晚起早睡的人中早起晚睡不简单。没人陪你占座，没人陪你背书，没人陪你写作。学习就是孤独的。没人经常短信你，没人经常鼓励你，没人一直关注你。不管是打雷下雨下雹子还是刀子，都要早起前行去学习，你的伙伴会贪睡不去，但不可以是你。你的同桌室友饭友学友各种友都可以中途打断他们的计划，你不可以！你要学习。你一个人背着书包跑来跑去，你以为很傻很土很幼稚吗？别人笑，是羡慕，你笑，是自信。
欲望。想睡懒觉，想看电影，想吃大餐。但是他们都是花时间的事，占用学习时间的事。可以放假，可以休息。 可要是每天多睡2小时，一年就多睡掉30.4天，一个月没了。每天看两集电视，又是一个月没了。食堂，寝室，教室，你就只能去这三个地方。厕所你都要算好时间再去。
享乐。他去看演唱会了，他去唱K了，他们去开房了。都和我无关，因为我要学习。他们打游戏，他们蜜月旅游，都和我无关，因为我要学习。
你好意思一把年纪了还吃爸妈的么。你有touch nano shuffle iPhone macbook，是你挣的么?你穿Burberry喷Dior拎Prada，你儿子用什么?你爸给你买房买车，你付得起物管，付得起年检么？你穿什么，用什么，开什么，住什么，什么都不算。你读什么，看什么，想什么，做什么，什么都重要。
教室前排的帅哥在你来之前就在那GRE，你走了，他还在GRE。他GRE他GRE他GRE，你连六级的分都刷不高。
你智商不高，情商不高，各种商不高；你背景不够，资本不够，各种不够；你还不学习？
你高中傻乎乎的把自己家的全套钥匙送给女朋友，你以为很浪漫很抒情很温柔很韩剧？你不学习，你连一个钥匙串都买不起。
你追求加内特詹姆斯科比麦蒂邓肯霍华德……你不学习，连一张季前赛门票都买不起。
你想去荷兰，想去普林斯顿，想去各种地方。你不学习，你就继续想吧。
别人花言巧语追女朋友，别人周末上街大包小包，别人假期飞来飞去。都不关我事，我要学习。
别人逃课，兼职，游戏，都不关我的事，我要学习。
你说我没智商，没背景，没资本。没关系，我要学习。
你说我固执，老套，OUT。没关系，我要学习。
所以，学习就是一件要耐的住寂寞放的下欲望舍的得享乐的事。你好意思那么懒那么不守时那么吃那么玩那么啰哩叭嗦不看书么！你好意思穿着各种签名在校园里面游荡，你好意思整天淘宝京东？
你要学习，你要学习，你要学习！
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>励志</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>青春有价</title>
    <url>/hobby-youth-have-price/</url>
    <content><![CDATA[作者：薛涌
许多“一无所有”的年轻人，对房子、汽车望眼欲穿，几乎不惜牺牲一切。我则想说：如果你大学毕业时的裤子日后穿不进去了，这条裤子就不再属于你了。怎么没有人担心自己对这条裤子能拥有多久呢？我这么说，是觉得人们越来越只用一把尺子衡量生活：买了什么牌子的车？买了多大的房？人家有了，我有了没有？但大家都忘记了另外一把尺子：你为了得到，究竟失去了什么？
如今房奴、车奴充斥于世，这充分反映了这种单一价值观对我们生活的塑造力。20多年前，我曾写过一篇随笔，讲新婚之后我们夫妻二人的生活状态。在我看来，当你买一件自己不真正需要的东西时，就开始受这个东西的奴役。比如，我要买一双时髦的旅游鞋，立即会在家庭财政上戳个窟窿。为了补这个窟窿，就得抽出时间去挣钱，哪怕是干不想干的事情。这等于拿自己生命的一部分去换这双鞋。所以，我必须想一想：这双鞋究竟有多重要？

这就是我们当时的生活状况。当时我们俩只有我有工作，拿200多块的死工资，无房无奖金，两人在北京很难过下去。妻子则英文、日文俱佳，当时正赶上外企大举进军北京，机会多多。记得有一次，一家工厂的日本专家找不到翻译无法工作，请她去帮3天忙，一天100块。在那年月，这算是挺吓人的报酬了。
可她从不多干。理由是：我们不会把自己的青春减价出售。我们结婚时一无所有，但都知道自己还年轻，要用青春追求新的生活，即出国留学。当时留学很难，而我的英语几乎要从头开始学。所以，我们很清楚，要尽可能把青春投入自己的发展。20年后，如果我们建立了自己的事业，回首今天的艰辛，当是人生最为美好的时刻。难道就为了100块一天给卖了？不卖，坚决不卖！
当然，生活要维持，必要的工作还是要干的。但是，如果我们除了食物外基本不消费，穿旧衣服，那么就能最大限度地降低出去工作的需要，把青春最大限度地留给自己。就这样，我们闷头发奋4年，妻子先考取了耶鲁大学的博士；缺乏英语才能的我，得以混了个家属的资格跟去，因为在旁听时小有表现，也成了那里的学生。想想都是多亏没有贱卖青春，留着给自己长了点本事。
到耶鲁后，我先是家属，后来读硕士课程，免学费但无奖学金。那时妻子拿的全额奖学金，其实比当地的最低生活线还少几百块。那时也有些校内打工的机会，我们在没有办法时也干过一点，但只要生活能维持，就不会干。道理还是：青春不减价拍卖。
在美国的头几年，我的衣服几乎全是街上邻居搬家清理旧货时买的，比如10美分一条的牛仔裤等等，尺寸不对也勉强凑合着穿。但那时却是我们求知生涯中最珍贵的，那时一无所有的状态，其实是最为富足的。如今年过半百，回想起来，最为庆幸的还是：青春有价，没有贱卖。当然，我们从来没有忘了锻炼身体，对裤子的所有权绝不肯放弃。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>ApacheBenchmark和gnuplot</title>
    <url>/dev-ab-and-gnuplot/</url>
    <content><![CDATA[前言《虚拟机在线迁移的性能统计》一文中，提到了虚拟机迁移的四个性能指标。但是文中只记录了迁移时间、停机时间、迁移数据量的测量方法，对于应用程序的性能，由于没有想到好的测量方法，最终搁置。
又参考了一些论文，发现他们在考虑Web应用程序性能时，主要考虑吞吐量。本文，就来研究一下ApacheBench测量吞吐量的方法，并且使用gnuplot绘制出吞吐量与时间的关系。


ApacheBenchApacheBench（ab）是Apache自带的一个Web压力测试工具，也可以单独下载使用。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等。
安装1、安装apacheapt install apache2
2、测试
curl localhostab -V

单独下载ab的话，可以使用apt install apache2-utils。
使用ab命令使用说明：ab [options] [http[s]://]hostname[:port]/path
可选参数如下：
-n requests     Number of requests to perform-c concurrency  Number of multiple requests to make at a time-t timelimit    Seconds to max. to spend on benchmarking                This implies -n 50000-s timeout      Seconds to max. wait for each response                Default is 30 seconds-b windowsize   Size of TCP send/receive buffer, in bytes-B address      Address to bind to when making outgoing connections-p postfile     File containing data to POST. Remember also to set -T-u putfile      File containing data to PUT. Remember also to set -T-T content-type Content-type header to use for POST/PUT data, eg.                'application/x-www-form-urlencoded'                Default is 'text/plain'-v verbosity    How much troubleshooting info to print-w              Print out results in HTML tables-i              Use HEAD instead of GET-x attributes   String to insert as table attributes-y attributes   String to insert as tr attributes-z attributes   String to insert as td or th attributes-C attribute    Add cookie, eg. 'Apache=1234'. (repeatable)-H attribute    Add Arbitrary header line, eg. 'Accept-Encoding: gzip'                Inserted after all normal header lines. (repeatable)-A attribute    Add Basic WWW Authentication, the attributes                are a colon separated username and password.-P attribute    Add Basic Proxy Authentication, the attributes                are a colon separated username and password.-X proxy:port   Proxyserver and port number to use-V              Print version number and exit-k              Use HTTP KeepAlive feature-d              Do not show percentiles served table.-S              Do not show confidence estimators and warnings.-q              Do not show progress when doing more than 150 requests-l              Accept variable document length (use this for dynamic pages)-g filename     Output collected data to gnuplot format file.-e filename     Output CSV file with percentages served-r              Don't exit on socket receive errors.-m method       Method name-h              Display usage information (this message)-Z ciphersuite  Specify SSL/TLS cipher suite (See openssl ciphers)-f protocol     Specify SSL/TLS protocol                (TLS1, TLS1.1, TLS1.2 or ALL)

1、模拟10个client，总共发送100个请求（每个client发送10个请求）ab -n 100 -c 10 http://localhost/注意网址后面要加”/“或者明确的path。运行结果如下：
This is ApacheBench, Version 2.3 &lt;$Revision: 1706008 $&gt;Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/Licensed to The Apache Software Foundation, http://www.apache.org/Benchmarking localhost (be patient).....doneServer Software:        Apache/2.4.18Server Hostname:        localhostServer Port:            80Document Path:          /Document Length:        11321 bytesConcurrency Level:      10Time taken for tests:   0.013 secondsComplete requests:      100Failed requests:        0Total transferred:      1159500 bytesHTML transferred:       1132100 bytes# 相当于LoadRunner中的每秒事务数Requests per second:    7841.29 [#/sec] (mean)# 相当于LoadRunner中的平均事务响应时间Time per request:       1.275 [ms] (mean)# 每个连接请求实际运行时间的平均值Time per request:       0.128 [ms] (mean, across all concurrent requests)Transfer rate:          88788.85 [Kbytes/sec] receivedConnection Times (ms)              min  mean[+/-sd] median   maxConnect:        0    0   0.1      0       1Processing:     0    1   0.3      1       1Waiting:        0    0   0.2      0       1Total:          1    1   0.3      1       2Percentage of the requests served within a certain time (ms)  50%      1  66%      1  75%      1  80%      1  90%      2  95%      2  98%      2  99%      2 100%      2 (longest request)

性能测试得到的最重要的指标是QPS(Requests per second)，反映了接口的并发承受能力，也就是系统的峰值性能。如果对接口的调用超过了这一限制，就要考虑提升硬件或者做一些优化了。更多结果说明参考Web性能压力测试工具之ApacheBench详解。
2、指定测试的最大时间为10秒ab -t 10 -n 1000000 http://localhost/“-t”可以指定测试的最大时间，如果还不到此数请求已经发完，那么测试也会结束。当使用”-t”参数时，ab内部默认最大的请求数为50000，为了同时使用”-n”指定的参数，可以将”-t”参数放在”-n”参数之前。更多内容参考按时间进行压力测试。
3、测试结果存入gnuplot格式的文件ab -g t10.dat -t 10 -n 1000000 http://localhost/
gnuplotgnuplot是一个小巧实用的数据处理工具，主要用来绘制2D/3D的数据或者函数图像，但是也包含数学计算、拟合等功能。虽然它的名字里有个“gnu”，但是它和大名鼎鼎的GNU没什么关系，使用的授权协议也不是GNU GPL，所以这里的“gnu”是小写，全名应该读作“new plot”。
安装1、终端输入gnuplot，提示：
The program 'gnuplot' can be found in the following packages: * gnuplot-nox * gnuplot-qt * gnuplot-x11 * gnuplot5-nox * gnuplot5-qt * gnuplot5-x11Try: sudo apt install &lt;selected package&gt;
可见gnuplot在多个软件包中都包含，这里我们选择安装gnuplot-nox或者gnuplot-qt。
2、安装gnuplot-noxapt install gnuplot-nox
3、测试gnuplot -V
其他平台的安装，参考谈谈gnuplot（一）：安装。
使用1、启动输入gnuplot，进入gnuplotshell。这里包含gnuplot的版本、系统、版权等信息。最关键的是最后一条：Terminal type set to ‘unknown’什么是terminal？在gnuplot中，terminal就是说你打算用什么方式输出图片。这里默认的terminal是unknown，因为我们安装了gnuplot-nox。一般需要修改为wxt，也就是直接输出到电脑屏幕上。
2、设置terminal
set terminal dumbplot sin(x)
以上，设置terminal为dumb，也就是直接在shell中显示绘图结果。
3、图形界面显示在shell中绘图，太粗糙，我们想要在图形界面中显示。（1）使用vncserver连接服务器，参考Linux下使用VirtualBox（2）启动gnuplot，设置terminalset terminal wxt或者set terminal x11无法成功，因为没有安装图形界面支持。（3）安装图形界面支持apt install gnuplot-x11之后再启动gnuplot，默认terminal为x11。（4）尝试绘图更多绘制方法，参考程序员的绘图利器 — Gnuplot。
4、gnuplot脚本（1）新建sin.plt脚本，内容为：
# 绘制sinset xlabel 'x'set ylabel 'y'plot sin(x)
（2）运行脚本gnuplot sin.plt或者在gnushell中执行load &#39;sin.plt&#39;，值得一提的是，前一种方法绘制的图像会一闪而过。（3）保存脚本如果在gnushell执行了一些set命令，然后plot进行绘图，想要保存这些操作，方便下次使用，那么可以使用save &#39;filename.plt&#39;命令保存脚本。
绘制ab数据在ab使用一节，已经保存两个文件，n10000.dat和t10.dat，接下来我们把该文件中的数据绘制一下。主要参考使用Apache Bench 和 Gnuplot产生性能测试图。
响应时间1、查看t10.dat文件tail t10.dat

starttime：人类可读的开始时间
seconds：开始时间的unix时间戳值
ctime：对应的ab输出中的Connection Times(ms)中的Connect
dtime：对应的ab输出中的Connection Times(ms)中的Processing
ttime：对应的ab输出中的Connection Times(ms)中的Total
wait：对应的ab输出中的Connection Times(ms)中的Waiting

2、新建t10.plt脚本，绘制request与response time的关系图
# output as png imageset terminal png# save file to "t10.png"set output "t10.png"# graph titleset title "ab -g t10.dat -t 10 -n 1000000 http://localhost/"# nicer aspect ratio for image sizeset size 1,0.7# y-axis gridset grid y#x-axis labelset xlabel "request"#y-axis labelset ylabel "response time (ms)"#plot data from "t10.dat" using column 9 with smooth sbezier linesplot "t10.dat" using 9 smooth sbezier with lines title "t10"

3、执行t10.plt脚本gnuplot t10.plt生成的t10.png图像如下：这张图，和教程中给的结果差别很大，看不出逐渐增长的趋势。从上图可以看出，10s内发送了接近6万个请求，response time最大才12ms，应该是因为本机性能太好导致的。所以，郝同学决定换一个主机测试。
4、测试个人博客ab -g t10.dat -t 10 -n 1000000 http://www.voidking.com/
5、再次执行t10.plt脚本生成的图像如下：由上图可以看出，10s内发送了接近120个请求，response time逐渐增长，最大为99ms。
吞吐量上面的效果并不是我们最终想要的，我们需要的，是response per second与time的关系，也就是吞吐量。
1、新建pt10.sh脚本，处理t10.dat
#!/bin/bashstart_time=`awk '&#123;print $6&#125;' t10.dat | grep -v 'wait' | sort | uniq -c|head -1|awk '&#123;print $2&#125;'`awk '&#123;print $6&#125;' t10.dat | grep -v 'wait' | sort | uniq -c|awk -v t=$start_time '&#123;print $2-t,$1&#125;' &gt; epochtime.dat

2、执行pt10.sh
chmod a+x pt10.sh./pt10.sh

3、新建throughput.plt脚本
# output as png imageset terminal png  size 1000,560set output "throughput.png"#graph titleset title "Throughput"set key invert reverse Left outside# nicer aspect ratio for image size#set size 1,0.6# y-axis gridset grid y# x-axis labelset xlabel "time"# y-axis labelset ylabel "responses per second"plot "epochtime.dat" using 1:2 with lines title "t10"

生成的图像如下：
后记以上，完成了ApacheBenchmark和gnuplot的基础学习。gnuplot确实是一个很棒的绘图工具，绘出的图看起来就专业。以后就不用excel绘图了，安装一个windows版gnuplot，完美。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>AIOps概览</title>
    <url>/dev-aiops-summary/</url>
    <content><![CDATA[AIOps是什么？运维的发展，经历了手工运维、自动化运维、DevOps、AIOps。
Gartner公司2013提出ITOA（IT Operations Analytics），2016年将ITOA概念升级为AIOps（Algorithmic IT Operations），2017年发现AI越来越火，于是把AIOps重新定义为Artificial Intelligence for IT Operations，也就是智能运维。AIOps将人工智能应用于运维领域，基于已有的运维数据（日志、监控信息、应用信息等），通过机器学习的方式来进一步解决自动化运维没办法解决的问题。
AIOps的目标是，利用大数据、机器学习和其他分析技术，通过预防预测、个性化和动态分析，直接和间接增强IT业务的相关技术能力，实现所维护产品或服务的更高质量、合理成本及高效支撑。


AIOps做什么？知识领域AIOps涉及到行业领域知识、运维场景领域知识和机器学习领域知识，如下图：
团队构成一个AIOps团队，要有运维工程师、运维开发工程师、运维AI工程师，如下图：
研究方向研究方向按照时间来分，可以分为针对历史事件、针对当前事件、针对未来事件，如下图：
研究方向按照应用场景来分，可以分为效率提升、质量保障、成本管理，如下图：
AIOps平台能力分级AIOps 的建设可以先由无到局部单点探索、再到单点能力完善，形成解决某个局部问题的运维AI“学件” ，再由多个具有 AI 能力的单运维能力点组合成一个智能运维流程。AIOps 能力分级可具体可᧿述为5级，如下图：
1) 开始尝试应用AI能力，还无较成熟单点应用2) 具备单场景的AI运维能力，可以初步形成供内部使用的学件3) 有由多个单场景AI运维模块串联起来的流程化AI运维能力，可以对外提供可靠的运维AI学件4) 主要运维场景均已实现流程化免干预AI运维能力，可以对外提供可靠的AIOps服务。5) 有核心中枢AI，可以在成本、质量、效率间从容调整，达到业务不同生命周期对三个方面不同的指标要求，可实现多目标下的最优或按需最优。
“学件”（Learnware）一词由南京大学周志华老师原创，学件=模型+规约。
学件，亦称AI运维组件，类似程序中的API或公共库，但API及公共库不含具体业务数据，只是某种算法，而 AI 运维组件（或称学件），则是在类似API的基础上，兼具对某个运维场景智能化解决的“记忆”能力，将处理这个场景的智能规则保存在了这个组件中。
这个智能规则是在一定量的数据下学习而来的，且具有“可重用” 、“可演进”、“可了解”的特性，既可共享由专家利用数据训练的算法，又可保护数据和隐私。
能力框架基于上述 AIOps 能力分级， 对应的 AIOps 能力框架如下。
能力体系AIOps工作平台能力体系主要功能是为AIOps的实际场景建设落地而提供功能的工具或者产品平台，其主要目的是降低AIOps的开发人员成本，提升开发效率，规范工作交付质量。 AIOps平台功能与一般的机器学习(或者数据挖掘)平台极为类似，此类产品国外的比如Google的AutoML。
平台要素AIOps平台从底层到上层应该包含如下要素：
1) 数据源：大量并且种类繁多的 IT 基础设施2) 大数据平台：用于处理历史和实时的数据3) 计算与分析：通过已有的 IT 数据产生新的数据，例如数据清洗、去除噪声等4) 算法：用于计算和分析，以产生 IT 运维场景所需要的结果5) 机器学习：这里一般指无监督学习，可根据基于算法的分析结果来产生新的算法
AIOps关键技术数据采集数据采集负责将智能运维所需要的数据接入至AIOps平台，所接入的运维数据类型一般包括（但不限于）日志数据，性能指标数据，网络抓包数据，用户行为数据，告警数据，配置管理数据，运维流程类数据等。
数据采集方式可分为无代理采集以及有代理采集两种。其中无代理采集为服务端采集，支持SNMP、数据库JDBC、TCP/UDP监听、SYSLOG、Web Service，消息队列采集等主流采集方式。有代理采集则用于本地文件或目录采集，容器编排环境采集，以及脚本采集等。
数据处理1) 数据字段提取：通过正则解析，KV解析，分隔符解析等解析方式提取字段2) 规范化数据格式：对字段值类型重定义和格式转换3) 数据字段内容替换：基于业务规则替换数据字段内容，比如必要的数据脱敏过程，同时可实现无效数据、缺失数据的替换处理4) 时间规范化：对各类运维数据中的时间字段进行格式统一转换5) 预聚合计算：对数值型字段或指标类数据基于滑动时间窗口进行聚合统计计算，如取1分钟CPU平均值
数据存储1) 数据需要进行实时全文检索，分词搜索。可选用主流的 ElasticSearch 引擎2) 时间序列数据（性能指标），主要以时间维度进行查询分析的数据，可选用主流的rrdtool、graphite、influxdb等时序数据库3) 关系类数据，以及会聚集在基于关系进行递归查询的数据可选择图数据库4) 数据的长期存储和离线挖掘以及数据仓库构建，可选用主流的 Hadoop、Spark 等大数据平台
离线和在线计算离线计算：针对存储的历史数据进行挖掘和批量计算的分析场景，用于大数据量的离线模型训练和计算，如挖掘告警关联关系，趋势预测/容量预测模型计算，错误词频分析等场景。
在线计算：对流处理中的实时数据进行在线计算，包括但不限于数据的查询、预处理和统计分析，数据的实时异常检测，以及部分支持实时更新模型的机器学习算法运用等。主流的流处理框架包括：Spark Streaming、Kafka Streaming、Flink、Storm等。
算法技术运维场景通常无法直接基于通用的机器学习算法以黑盒的方式解决，因此需要一些面向AIOps 的算法技术，作为解决具体运维场景的基础。
1) 指标趋势预测：通过分析指标历史数据，判断未来一段时间指标趋势及预测值，常见有Holt-Winters、时序数据分解、ARIMA等算法。该算法技术可用于异常检测、容量预测、容量规划等场景。2) 指标聚类: 根据曲线的相似度把多个 KPI 聚成多个类别。该算法技术可以应用于大规模的指标异常检测：在同一指标类别里采用同样的异常检测算法及参数，大幅降低训练和检测开销。常见的算法有DBSCAN、K-medoids、CLARANS等，应用的挑战是数据量大，曲线模式复杂。3) 多指标联动关联挖掘: 多指标联动分析判断多个指标是否经常一起波动或增长。该算法技术可用于构建故障传播关系，从而应用于故障诊断。常见的算法有Pearson correlation、Spearman correlation、Kendall correlation等，应用的挑战为KPI种类繁多，关联关系复杂。4) 指标与事件关联挖掘: 自动挖掘文本数据中的事件与指标之间的关联关系（ 比如在程序 A 每次启动的时候 CPU 利用率就上一个台阶）。该算法技术可用于构建故障传播关系，从而应用于故障诊断。常见的算法有 Pearson correlation、J-measure、Two-sample test等，应用的挑战为事件和KPI种类繁多，KPI测量时间粒度过粗会导致判断相关、先后、单调关系困难。5) 事件与事件关联挖掘: 分析异常事件之间的关联关系，把历史上经常一起发生的事件关联在一起。该算法技术可用于构建故障传播关系，从而应用于故障诊断。常见的算法有 FP-Growth、Apriori、随机森林等，但前提是异常检测需要准确可靠。6) 故障传播关系挖掘：融合文本数据与指标数据，基于上述多指标联动关联挖掘、指标与事件关联挖掘、事件与事件关联挖掘等技术、由 tracing 推导出的模块调用关系图、辅以服务器与网络拓扑，构建组件之间的故障传播关系。该算法技术可以应用于故障诊断，其有效性主要取决于其基于的其它技术。
顶会推荐ACM SIGCOMMACM IMCACM/USENIX NSDIACM MobiSysACM CoNEXTACM MobiComACM SIGMETRICSIEEE INFOCOMACM KDDUSENIX SecurityIEEE Security &amp; PrivacyACM CCSNDSS
后记总而言之，AIOps就是利用机器学习来做一些运维工作。涉及到行业知识、运维知识、机器学习知识，是一个很大的研究方向，可以细分为很多小的研究方向。
AIOps围绕质量保障、成本管理和效率提升的基本运维场景，逐步构建智能化运维场景。在质量保障方面，保障现网稳定运行细分为异常检测、故障诊断、故障预测、故障自愈等基本场景；在成本管理方面，细分为指标监控，异常检测，资源优化，容量规划，性能优化等基本场景；在效率方面，分为智能预测，智能变更、智能问答，智能决策等基本场景（注：三者之间不是完全独立的，是相互影响的，场景的划分侧重于主影响维度）。
每一个小方向，都是一个研究点，最终成果是一个学件。通过学件的组合，就构成了AIOps平台。
更多内容请参考书签中给出的链接。
书签基于机器学习的智能运维基于机器学习的智能运维-ppt《企业级 AIOps 实施建议》白皮书-V0.6 版本
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>aiops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>aiops</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里云技术体系概览</title>
    <url>/dev-ali-tech-system-summary/</url>
    <content><![CDATA[阿里云据Gartner发布的2017年度全球公有云市场份额分析报告，全球范围内的公有云市场已经形成了3A格局：亚马逊AWS、微软Azure、阿里云AliYun。
今年，天猫双11以2135亿的成交额再破记录。这背后，是阿里云的技术在支撑，阿里云的大数据计算平台已经拥有全世界最牛的大数据并发处理能力。
本文，就来研究整理一下阿里云的技术栈。


历史2009年之前IOE（IBM小型机，Oracle数据库，EMC存储设备），Oracle之巅。
2009年9月阿里云成立，愿景是要做一套大数据分布式计算/存储的云平台，自主研发飞天体系，包括三大部分：底层的分布式存储系统——盘古、分布式调度系统——伏羲、开放数据处理服务——ODPS（Open Data Processing Service）。后来又添加了集群诊断系统——华佗、网络连接模块——夸父、监控系统——神农、集群部署——大禹。
2009-2011年期间云梯1（Hadoop）、云梯2（飞天），两套系统，云梯1承载初期集团淘宝的数据业务，云梯2助力阿里金融的第一个产品“牧羊犬”应用上线。
2011年，集团主要业务全部登上云梯1，阿里构建了国内领先的hadoop集群。两座云梯同时发展，开始进行博弈，规则很明确：要想成功肩负起阿里巴巴的底层计算系统，就必须有能力独自调度5000台服务器，“赢者通吃”，继承家业。
2011年，大数据实时计算发展也随业务而生。数据魔方研发了第一个版本的galaxy，b2b搜索团队也研发了一个叫iprocess的流计算系统。在12年7月份，数据平台事业部（CDO）成立，两个团队走到了一起组建了实时计算团队。
2012年冰火鸟：数据业务层统一。云梯1、云梯2运维团队合并。
2013年5K之战：突破集群存储的瓶颈。云梯2突破5K。
2014年-2015年登月计划：打造集团统一大数据平台。云梯1停止，云梯2成为集团统一的大数据平台。ODPS更名为“MaxCompute”。
2015年，支持公有云，阿里大数据计算能力，走出集团服务全球。
2016年，建设主备双链路容灾、实时全链路监控、Tesla运维诊断工具实时全链路保障方案。大力发展实时计算，Galaxy、JStorm和Search dump三支实时计算团队资源整合。
2017年，MaxCompute架构升级，在NewSQL、富结构化、联合计算平台、AliORC多个方向上发力，继续构建高可用、高性能、高自适性的一站式的大数据解决方案开放平台。
更详细历史，参考首次探秘！双11奇迹背后的大数据力量，十年发展五部曲。
阿里大数据技术如何进化？资深技术专家带你回顾一文中作者观滔提到：

如果把阿里巴巴整体数据体系比作这个战队，那么MaxCompute就是中间的那艘航空母舰，几乎阿里巴巴99%的数据存储以及95%的计算能力都在这个平台上产生。

计算平台阿里的计算平台服务主要有MaxCompute、流计算Blink、图计算FLASH、机器学习PAI。
MaxCompute由历史可以看出，现在的阿里技术核心围绕MaxCompute。上图是MaxCompute的技术架构。最下面一层是物理机器，MaxCompute有自己的物理集群，在集群之上有非常重要的能力：它把一个集群组织成了1万台计算机，MaxCompute 2.0很大的特性是集群能力得到了扩展，从5千变成了1万。黑色部分是飞天操作系统，提供整个分布式系统任务协同、资源管理、集群调度等功能，为上层云产品提供统一的操作系统服务。其上是MaxCompute统一的计算引擎，支持SQL、MR、迭代计算、图计算、流计算。
详情参考阿里巴巴大数据计算平台MaxCompute（原名ODPS）全套攻略和性能追求之路——MaxCompute2.0（原ODPS）的前世今生。
BlinkApache Flink是面向数据流处理和批处理的分布式开源计算框架，2016年阿里巴巴引入Flink框架，改造为Blink。2017年，阿里整合了所有流计算产品，决定以Blink引擎为基础，打造一款全球领先的实时计算引擎。当年双11，Blink支持了二十多个事业部／群，同时运行了上千个实时计算job，每秒处理的日志数峰值达到惊人的4.7亿。
详情参考阿里新一代实时计算引擎 Blink，每秒支持数十亿次计算。
FLASHFLASH是阿里的图计算平台。简单的说图计算就是研究在大规模图数据下，如何高效计算，存储和管理图数据等相关问题的领域。
应用：搜索推荐、关联分析、实时预测等。
详情参考FLASH:大规模分布式图计算引擎及其应用和大规模图计算系统综述。
PAIPAI是阿里自己的智能平台，该平台基于阿里云的云计算平台，具有处理超大规模数据的能力和分布式的存储能力，同时整个模型支持超大规模的建模以及GPU计算。此外，该平台还具有社区的特点：实验结果可共享、社区团队相互协作。该智能平台主要分为三层，第一层是Web UI界面，第二层是IDST算法层，最后一层是ODPS平台层。
详情参考阿里云机器学习平台——PAI平台。
技术架构除了MaxCompute，阿里还有很多其他的技术，如下图：1、基础设施新技术大规模文件分发系统、X-Cluster、时间序列异常检测算法、Changefre系统、阿里智能流量调度系统、StarAgent、调度混部技术、网络自愈技术、“无人值守”的全链路压测
2、新零售技术创新时尚大脑、门店发货/自提、智慧门店天梭、随身购物袋、数据银行
3、菜鸟菜鸟方舟
4、支付OceanBase、离在线混部、GeaBase、支付工具精准推荐、海淘正品溯源
5、机器智能“新物种”战队云小蜜、蚂蚁安安、首席拣货官、小G二代：智能配送员、天巡、尖兵、达灵、鲁班、蚂蚁佐罗、无人汽车售卖机
6、云计算阿里云弹性计算ECS、ApsaraCache、阿里云数据集RDS、阿里云内容分发网络CDN、日志服务、移动云、阿里云OSS、阿里云DDoS防御技术、混合云架构、专有网络VPC、负载均衡SLB、高速通道、NAT网关、视频直播、云导播
7、安全霸下——七层流量清洗、钱盾、MTEE3、御城河、CTU
技术点调度混部技术Sigma通过和离线任务的伏羲调度系统深度集成，突破了若干CPU、内存和网络资源隔离的关键技术，实现了在线和离线任务的混合部署。
Sigma调度可以跨多个不同平台来分配双11所需的资源，使双11 IT成本下降50%；混部技术把服务器资源利用率提升30%，复用计算任务集群为双11节约大量服务器。
在线服务的容器就像砖块，而计算任务就像沙子和水。当在线服务压力小的时候，计算任务就占住那些空隙，把空闲的资源都使用起来，而当在线服务忙的时候，计算任务便立即退出空隙，把资源还给在线服务。
详情参考想了解阿里巴巴的云化架构 看这篇就够了。
Pouch容器阿里的容器技术经历了一个从集中式到分布式架构上的演化，最开始是直接跑在物理机上，之后引入了虚拟化技术，但整体的资源使用率不高，因而过渡到了容器技术。2015 年以后，阿里巴巴引入Docker标准，形成一套新的容器技术——Pouch，并集成到整个运维体系。
全网Pouch化实现阿里在线服务全部容器化，内部达到百万级容器部署规模，Pouch容器已对外开源。
全链路压测阿里巴巴双11备战期间，保障系统稳定性最大的难题在于容量规划，而容量规划最大的难题在于准确评估从用户登录到完成购买的整个链条中，核心页面和交易支付的实际承载能力。
最初采用的方式是在线上单机的生产环境的压力测试和容量规划，基于单台服务能力和预估即将到来的业务流量进行容量规划，确定所需服务器的数目。
2010-2012年双11暴露了不少问题，单个系统ready不代表全局ready，究其根本原因在于系统之间相互关联和依赖调用之间相互影响。在做单个系统的容量规划时，所有的依赖环节能力是无限的，进而使得获取的单机能力值是偏乐观的；同时，采用单系统规划时，无法保证所有系统均一步到位，大多数精力都集中核心少数核心系统；此外，部分问题只有在真正大流量下才会暴露，比如网络带宽等等。
阿里从13年起着手进行全链路压测。全链路压测的本质是让双11零点这一刻提前在系统预演（用户无感知），模拟“双11”同样的线上环境、用户规模、业务场景、业务量级，之后再针对性地进行系统调优，是站点的一次高仿真模拟考试。
全链路压测核心要素主要包括四点：

压测环境，它是指具备数据与流量隔离能力的生产环境，不能影响到原有的用户体验和用户流程、BI报表以及推荐算法等；
压测基础数据，它主要包括压测用户、店铺、商品等基础数据；
压测场景模型，它主要是指压测哪些业务场景，每个场景下压测多大量等；
压测流量，它主要由压测请求的协议来决定压测流量的输出

详情参考系统稳定性保障核武器——全链路压测。
OceanBaseOceanBase是阿里完全自主研发的金融级分布式关系数据库，从架构上可以通过扩展机器来解决集群服务能力的扩展需求。OceanBase采用多副本复制的方案解决了可靠性和可用性的需求，而且构建在普通PC服务器上，不依赖于高端引擎。
OceanBase从诞生、到电商数据库、再到金融数据库及最终的云数据库，经历了四个阶段。
详情参考阿里蚂蚁金服的关系型数据库：OceanBase架构详解和OceanBase 2.0 到底如何做到 50% 的性能提升？。
DubboDubbo是阿里巴巴于 2012 年开源的分布式服务治理框架，目前已是国内影响力最大、使用最广泛的开源服务框架之一，在Github上的 fork、star数均已破万。
Dubbo 致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案，使得应用可通过高性能RPC 实现服务的输出和输入功能， 和 Spring 框架无缝集成。Dubbo包含远程通讯、集群容错和自动发现三个核心部分。提供透明化的远程方法调用，实现像调用本地方法一样调用远程方法，只需简单配置，没有任何API侵入。 
同时具备软负载均衡及容错机制，可在内网替代F5等硬件负载均衡器，降低成本，减少单点。可以实现服务自动注册与发现，不再需要写死服务提供方地址，注册中心基于接口名查询服务提供者的 IP 地址，并且能够平滑添加或删除服务提供者。
详情参考分布式服务框架Dubbo疯狂更新！阿里开源要搞大事情？。
StarAgentStarAgent 是一个生态平台。阿里所有的物理机、虚拟机以及容器都会装StarAgent，基本上要和机器交互都需要通过这个平台。它实际上不会做具体的业务，具体的业务还是通过各个业务平台去实现的。
StarAgent 核心功能就是一个命令的通道，它既可以同步执行任务又可以异步执行任务，还可以查询任务状态和插件管理。插件分为两种，一种是静态的，静态的实际上就是脚本、命令之类的。另一种动态的是一个常驻进程，必须常驻在系统里面。我们会守护这个进程，如果它挂了会重新拉起来，如果其占用内存、CPU超过设定的范围会删掉它。整个协议是比较简单的，使用起来耦合度也是比较低的。

详情参考双11黑科技，阿里百万级服务器自动化运维系统StarAgent揭秘、阿里巴巴运维中台的演进与建设、阿里巴巴运维中台的演进与建设ppt。
蜻蜓蜻蜓系统是纯碎的 P2P 的文件分发系统。
详情参考阿里巴巴运维中台的演进与建设。
NormandyNormandy 是运维整个阿里巴巴业务的PaaS平台。这个平台实际上提供三大功能，分别是基础设施即代码（Infrastructure as Code）、部署和应用运维支撑。
详情参考阿里巴巴运维中台的演进与建设。
书签阿里云的这群疯子《阿里技术参考图册》2017杭州云栖大会100位大咖视频+讲义全分享阿里研究员毕玄谈应用运维体系的变迁，DevOPS是大势所趋阿里巴巴毕玄解密AIOps：一文读懂阿里巴巴运维体系的前世今生
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>aiops</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>aiops</tag>
      </tags>
  </entry>
  <entry>
    <title>支付宝手机网站支付流程</title>
    <url>/dev-alipay-process/</url>
    <content><![CDATA[前言公司M站要接入支付宝，借机研究了一下支付宝的支付流程。毕竟，只有公司才能拿到支付接口权限。
主要参考文档：https://doc.open.alipay.com/doc2/detail?treeId=60&amp;articleId=103564&amp;docType=1https://b.alipay.com/order/productDetail.htm?productId=2015110218008816


手机网站支付接口产品简介手机网站支付主要应用于手机、掌上电脑等无线设备的网页上，通过网页跳转或浏览器自带的支付宝快捷支付实现买家付款的功能，资金即时到账。
申请条件1、您申请前必须拥有企业支付宝账号（不含个体工商户账号），且通过支付宝实名认证审核。2、如果您有已经建设完成的无线网站（非淘宝、天猫、诚信通网店），网站经营的商品或服务内容明确、完整（古玩、珠宝等奢侈品、投资类行业无法申请本产品）。3、网站必须已通过ICP备案，备案信息与签约商户信息一致。
配置假设我们已经成功申请到手机网站支付接口，在进行开发之前，需要使用公司账号登录支付宝开放平台。
查看PID1、开发者登录开放平台，点击右上角的“账户及密钥管理”。
2、选择“合作伙伴密钥”，即可查询到合作伙伴身份（PID），以2088开头的16位纯数字。
配置密钥支付宝提供了DSA、RSA、MD5三种签名方式，本次开发中，我们使用RSA签名和加密，那就只配置RSA密钥就好了。
关于RSA加密的详解，参见《支付宝签名与验签》。
应用环境本节可以忽略，本节可以忽略，本节可以忽略！因为官方文档并没有提及应用环境配置的问题。
进入管理中心，对应用进行设置。上图是我的应用配置选项，公司账号也许会有所不同。具体哪些参数需要配置？请参照接口参数说明，需要什么就配置什么。
交互Node端发起支付请求我们公司采用的，就是这种方式，步骤3中Node端获取到的支付宝参数，包括sign。其实，sign的计算工作也可以放在Node端，只不过支付宝没有给出Node的demo，实现起来需要耗费多一点时间。
后端发起支付请求这种方式也很好，而且，步骤4中后端获取到支付页面，也可以不传给Node端，自己显示出来。这样，整个流程就更加简单。
return_url和notify_urlreturn_url，支付完成后的回调url；notify_url，支付完成后通知的url。支付宝发送给两个url的参数是一样的，只不过一个是get，一个是post。
以上两种发起请求的方式中，return_url在Node端，notify_url在后端。我们也可以根据需要，把两个url都放在后端，或者都放在Node端，改变相应业务逻辑即可。
Node端详解Node端发起支付请求有两种选择，一种是获取到后端给的参数后，通过request模块发起get请求，获取到支付宝返回的支付页面，然后显示到页面上；另一种是获取到后端给的参数后，把参数全部输出到页面中的form表单，然后通过js自动提交表单，获取到支付宝返回的支付页面（同时显示出来）。
request发起请求// 通过orderId向后端请求获取支付宝支付参数alidatavar alipayUrl = 'https://mapi.alipay.com/gateway.do?'+ alidata;request.get(&#123;url: alipayUrl&#125;,function(error, response, body)&#123;    res.send(response.body);&#125;);

理论上完全正确的请求，然而，获取到的支付页面，输出到页面上，却是乱码。没错，还是一个错误提示页面。
神奇的地方在于，在刷新页面多次后，正常了！！！啊嘞，这是什么鬼？

先解决乱码问题，看看报什么错！
request.get(&#123;url: alipayUrl&#125;,function(error, response, body)&#123;    var str = response2.body;    str = str.replace(/gb2312/, "utf-8");    res.setHeader('content-type', 'text/html;charset=utf-8');    res.send(str);&#125;);

很遗憾，无效！乱码依然是乱码。。。和沈晨帅哥讨论很久，最终决定换一种方案——利用表单提交。
表单提交请求Node端// node端// 通过orderId向后端请求获取支付宝支付参数alidatafunction getArg(str,arg) &#123;  var reg = new RegExp('(^|&amp;)' + arg + '=([^&amp;]*)(&amp;|$)', 'i');  var r = str.match(reg);  if (r != null) &#123;      return unescape(r[2]);  &#125;  return null;&#125;var alipayParam = &#123;  _input_charset: getArg(alidata,'_input_charset'),  body: getArg(alidata,'body'),  it_b_pay: getArg(alidata, 'it_b_pay'),  notify_url: getArg(alidata, 'notify_url'),  out_trade_no: getArg(alidata, 'out_trade_no'),  partner: getArg(alidata, 'partner'),  payment_type: getArg(alidata, 'payment_type'),  return_url: getArg(alidata, 'return_url'),  seller_id: getArg(alidata, 'seller_id'),  service: getArg(alidata, 'service'),  show_url: getArg(alidata, 'show_url'),  subject: getArg(alidata, 'subject'),  total_fee: getArg(alidata, 'total_fee'),  sign_type: getArg(alidata, 'sign_type'),  sign: getArg(alidata, 'sign'),  app_pay: getArg(alidata, 'app_pay')&#125;;res.render('artist/alipay',&#123;  // 其他参数  alipayParam: alipayParam&#125;);

html&lt;!--alipay.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;支付宝支付&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form id="ali-form" action="https://mapi.alipay.com/gateway.do" method="get"&gt;           &lt;input type="hidden" name="_input_charset" value="&lt;%= alipayParam._input_charset%&gt;"&gt;        &lt;input type="hidden" name="body" value="&lt;%= alipayParam.body%&gt;"&gt;        &lt;input type="hidden" name="it_b_pay" value="&lt;%= alipayParam.it_b_pay%&gt;"&gt;        &lt;input type="hidden" name="notify_url" value="&lt;%= alipayParam.notify_url%&gt;"&gt;        &lt;input type="hidden" name="out_trade_no" value="&lt;%= alipayParam.out_trade_no%&gt;"&gt;        &lt;input type="hidden" name="partner" value="&lt;%= alipayParam.partner%&gt;"&gt;        &lt;input type="hidden" name="payment_type" value="&lt;%= alipayParam.payment_type%&gt;"&gt;        &lt;input type="hidden" name="return_url" value="&lt;%= alipayParam.return_url%&gt;"&gt;        &lt;input type="hidden" name="seller_id" value="&lt;%= alipayParam.seller_id%&gt;"&gt;        &lt;input type="hidden" name="service" value="&lt;%= alipayParam.service%&gt;"&gt;        &lt;input type="hidden" name="show_url" value="&lt;%= alipayParam.show_url%&gt;"&gt;        &lt;input type="hidden" name="subject" value="&lt;%= alipayParam.subject%&gt;"&gt;        &lt;input type="hidden" name="total_fee" value="&lt;%= alipayParam.total_fee%&gt;"&gt;        &lt;input type="hidden" name="sign_type" value="&lt;%= alipayParam.sign_type%&gt;"&gt;        &lt;input type="hidden" name="sign" value="&lt;%= alipayParam.sign%&gt;"&gt;        &lt;input type="hidden" name="app_pay" value="&lt;%= alipayParam.app_pay%&gt;"&gt;    &lt;/form&gt;&lt;% include ../bootstrap.html %&gt;&lt;script type="text/javascript" src="&lt;%= dist %&gt;/js/business-modules/artist/alipay.js?v=2016052401"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

js// alipay.jsseajs.use(['zepto'],function($)&#123;    var index = &#123;        init:function()&#123;            var self = this;            this.bindEvent();        &#125;,        bindEvent:function()&#123;            var self = this;            $('#ali-form').submit();        &#125;    &#125;    index.init();&#125;);

小结选择支付宝支付后，成功跳转到了支付宝支付页面，nice！看来这种方案很靠谱。
开始时，打算把alidata直接输出到form表单的action中接口的后面，因为这样似乎最简便。但是，提交表单时，后面的参数全部被丢弃了。所以，不得不得把所有参数放在form表单中。Node端拆分了一下参数，组装成了一个alipayParam对象，这个工作也可以交给后端来做。
显然，request模拟表单提交和真实表单提交结果的不同，得出的结论是，request并不能完全模拟表单提交。或者，request可以模拟，而我不会-_-|||。
错误排查值得点赞的是，支付宝给的错误代码很明确，一看就懂。上面这个错误，签名不对。因为我给alipayParam私自加了个app_pay属性，没有经过签名。
微信屏蔽支付宝问题描述以上，大功告成？不！还有一个坑要填，因为微信屏蔽了支付宝！在电脑上，跳转支付宝支付页面正常，很完美！然而，在微信浏览器中测试时，却没有跳转，而是出现如下信息。
完美解决办法微信端支付宝支付，iframe改造http://www.cnblogs.com/jiqing9006/p/5584268.html
该办法的核心在于：把微信屏蔽的链接，赋值给iframe的src属性。
Node端res.render('artist/alipay',&#123;  alipayParam: alipayParam,  param: urlencode(alidata) &#125;);

html&lt;input type="hidden" id="param" value="&lt;%= param%&gt;"&gt;&lt;iframe id="payFrame" name="mainIframe" src="" frameborder="0" scrolling="auto" &gt;&lt;/iframe&gt;

jsvar iframe = document.getElementById('payFrame');var param = $('#param').val();iframe.src='https://mapi.alipay.com/gateway.do?'+param;

报错然而，在改造时，先是报错ILLEGAL_SIGN，于是利用urlencode处理了字符串。接着，又报错ILLEGAL_EXTERFACE，没有找到解决办法。
暂时放弃，以后如果有了解决办法再补上。
官方解决办法关于微信公众平台无法使用支付宝收付款的解决方案说明https://cshall.alipay.com/enterprise/help_detail.htm?help_id=524702
该方法的核心在于：确认支付时，提示用户打开外部系统浏览器，在系统浏览器中支付。
html&lt;!--alipay.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;  &lt;meta charset="UTF-8"&gt;  &lt;title&gt;支付宝支付&lt;/title&gt;&lt;/head&gt;&lt;body&gt;  &lt;form id="ali-form" action="https://mapi.alipay.com/gateway.do" method="get"&gt;     &lt;input type="hidden" name="_input_charset" value="&lt;%= alipayParam._input_charset%&gt;"&gt;    &lt;input type="hidden" name="body" value="&lt;%= alipayParam.body%&gt;"&gt;    &lt;input type="hidden" name="it_b_pay" value="&lt;%= alipayParam.it_b_pay%&gt;"&gt;    &lt;input type="hidden" name="notify_url" value="&lt;%= alipayParam.notify_url%&gt;"&gt;    &lt;input type="hidden" name="out_trade_no" value="&lt;%= alipayParam.out_trade_no%&gt;"&gt;    &lt;input type="hidden" name="partner" value="&lt;%= alipayParam.partner%&gt;"&gt;    &lt;input type="hidden" name="payment_type" value="&lt;%= alipayParam.payment_type%&gt;"&gt;    &lt;input type="hidden" name="return_url" value="&lt;%= alipayParam.return_url%&gt;"&gt;    &lt;input type="hidden" name="seller_id" value="&lt;%= alipayParam.seller_id%&gt;"&gt;    &lt;input type="hidden" name="service" value="&lt;%= alipayParam.service%&gt;"&gt;    &lt;input type="hidden" name="show_url" value="&lt;%= alipayParam.show_url%&gt;"&gt;    &lt;input type="hidden" name="subject" value="&lt;%= alipayParam.subject%&gt;"&gt;    &lt;input type="hidden" name="total_fee" value="&lt;%= alipayParam.total_fee%&gt;"&gt;    &lt;input type="hidden" name="sign_type" value="&lt;%= alipayParam.sign_type%&gt;"&gt;    &lt;input type="hidden" name="sign" value="&lt;%= alipayParam.sign%&gt;"&gt;    &lt;div class="wrapper buy-wrapper" style="display: none;"&gt;        &lt;a href="javascript:void(0);"           class="J-btn-submit btn mj-submit btn-strong btn-larger btn-block"&gt;确认支付&lt;/a&gt;    &lt;/div&gt;  &lt;/form&gt;&lt;input type="hidden" id="param" value="&lt;%= param%&gt;"&gt;&lt;% include ../bootstrap.html %&gt;&lt;script type="text/javascript" src="&lt;%= dist %&gt;/js/business-modules/artist/ap.js"&gt;&lt;/script&gt;&lt;script&gt;    var btn = document.querySelector(".J-btn-submit");    btn.addEventListener("click", function (e) &#123;        e.preventDefault();        e.stopPropagation();        e.stopImmediatePropagation();        var queryParam = '';        Array.prototype.slice.call(document.querySelectorAll("input[type=hidden]")).forEach(function (ele) &#123;            queryParam += ele.name + "=" + encodeURIComponent(ele.value) + '&amp;';        &#125;);        var gotoUrl = document.querySelector("#ali-form").getAttribute('action') + '?' + queryParam;        _AP.pay(gotoUrl);        return false;    &#125;, false);    btn.click();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

该页面会自动跳转到同一文件夹下的pay.htm，该文件官方已经提供，把其中的引入ap.js的路径修改一下即可。最终效果如下：
后记支付宝的支付流程和微信的支付流程，有很多相似之处。沈晨指出一点不同：支付宝支付完成后有return_url和notify_url；微信支付完成后只有notify_url。
研读了一下微信支付的开发文档，确实如此。微信支付完成后的通知也分成两路，一路通知到notify_url，另一路返回给调用支付接口的JS，同时发微信消息提示。也就是说，跳转return_url的工作我们需要自己做。
最后，感谢沈晨帅哥提供的思路和帮助，感谢体超帅哥辛苦改后端。
书签支付宝开放平台https://openhome.alipay.com/platform/home.htm
支付宝开放平台-手机网站支付-文档中心https://doc.open.alipay.com/doc2/detail?treeId=60&amp;articleId=103564&amp;docType=1
支付宝WAP支付接口开发http://blog.csdn.net/tspangle/article/details/39932963
wap h5手机网站支付接口唤起支付宝钱包付款
商家服务 - 支付宝 知托付！https://b.alipay.com/order/techService.htm
微信支付-开发文档https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1
微信端支付宝支付，iframe改造http://www.cnblogs.com/jiqing9006/p/5584268.html
微信如何突破支付宝的封锁http://blog.csdn.net/lee_sire/article/details/49530875
JavaScript专题（二）：深入理解iframehttp://www.cnblogs.com/fangjins/archive/2645631.html
关于微信公众平台无法使用支付宝收付款的解决方案说明https://cshall.alipay.com/enterprise/help_detail.htm?help_id=524702
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>支付宝</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda</title>
    <url>/dev-anaconda/</url>
    <content><![CDATA[前言本文转载自优达学城《机器学习工程师》
欢迎来到本课程！我叫 Mat Leonard，是数据分析师纳米学位的项目主管，也是这个简短课程的讲师。我会在课程中介绍两个对于数据分析师最为重要的工具，即 Anaconda 和 Jupyter notebook。
Anaconda 是一个包含数据科学常用包的发行版本。它是基于 conda ——一个包和环境管理器——衍生而来。你将使用 conda 创建环境，以便分隔使用不同 Python 版本和/或不同包的项目。你还将使用它在环境中安装、卸载和更新包。通过使用 Anaconda，使我处理数据的过程更加愉快。
Jupyter notebook 是 Web 文档，能让你将文本、图像和代码全部组合到一个文档中。它已经成为数据分析的标准环境。notebook 源自 2011 年的 IPython 项目，之后迅速流行起来。在本课程的第二节课中，你将获得使用 notebook 进行分析工作的经验。
让我们继续课程！首先学习 Anaconda。


Anaconda欢迎学习本课，即如何使用 Anaconda 来管理 Python 所用的包和环境。Anaconda 能让你轻松安装在数据科学工作中经常使用的包。你还将使用它创建虚拟环境，以便更轻松地处理多个项目。Anaconda 简化了我的工作流程，并且解决了我在处理包和多个 Python 版本时遇到的大量问题。
Anaconda 实际上是一个软件发行版，它附带了 conda、Python 和 150 多个科学包及其依赖项。应用程序 conda 是包和环境管理器。Anaconda 的下载文件比较大（约 500 MB），因为它附带了 Python 中最常用的数据科学包。如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版（仅包含 conda 和 Python）。你仍可以使用 conda 来安装任何可用的包，它只是没有附带这些包而已。
conda 是一种只能通过命令行来使用的程序，因此，如果你觉得它很难用，请查看这个面向 Windows 的命令提示符教程，或者学习我们面向 OSX/Linux 的 Linux 命令行基础知识课程。
你可能已经安装了 Python，并且想知道为何还需要 Anaconda。首先，由于 Anaconda 附带了一大批数据科学包，因此你可以立即开始处理数据。其次，使用 conda 来管理包和环境能减少将来在处理你要使用的各种库时遇到的问题。
管理包
包管理器用于在计算机上安装库和其他软件。你可能已经熟悉 pip，它是 Python 库的默认包管理器。conda 与 pip 相似，不同之处是可用的包以数据科学包为主，而 pip 适合一般用途。但是，conda 并非 像 pip 那样专门适用于 Python，它也可以安装非 Python 的包。它是适用于 任何 软件堆栈的包管理器。也就是说，并非所有的 Python 库都能通过 Anaconda 发行版和 conda 获得。在使用 conda 的同时，你仍可以并且仍将使用 pip 来安装包。
Conda 安装了预编译的包。例如，Anaconda 发行版附带了使用 MKL 库编译的 Numpy、Scipy 和 Scikit-learn，从而加快了各种数学运算的速度。这些包由发行版的贡献者维护，这意味着它们通常滞后于新版本。但是，由于有人需要为许多系统构建这些包，因此，它们往往更为稳定，而且更便于你使用。
环境除了管理包之外，conda 还是虚拟环境管理器。它类似于另外两个很流行的环境管理器，即 virtualenv 和 pyenv。
环境能让你分隔你要用于不同项目的包。你常常要使用依赖于某个库的不同版本的代码。例如，你的代码可能使用了 Numpy 中的新功能，或者使用了已删除的旧功能。实际上，不可能同时安装两个 Numpy 版本。你要做的应该是，为每个 Numpy 版本创建一个环境，然后在适用于项目的环境中工作。
在应对 Python 2 和 Python 3 时，此问题也会常常发生。你可能会使用在 Python 3 中不能运行的旧代码，以及在 Python 2 中不能运行的新代码。同时安装两个版本可能会造成许多混乱和错误。而创建独立的环境会好很多。
也可以将环境中的包的列表导出为文件，然后将该文件与代码包括在一起。这能让其他人轻松加载代码的所有依赖项。pip 提供了类似的功能，即 pip freeze &gt; requirements.txt。
接下来介绍的内容接下来，我会详细介绍 Anaconda 的用法。首先，我会介绍它的安装过程，然后介绍如何使用包管理器，最后介绍如何创建和管理环境。
安装 AnacondaAnaconda 可用于 Windows、Mac OS X 和 Linux。可以在 https://www.continuum.io/downloads 上找到安装程序和安装说明。
如果计算机上已经安装了 Python，这不会有任何影响。实际上，脚本和程序使用的默认 Python 是 Anaconda 附带的 Python。
选择 Python 2.7 版本（你可以在以后安装 Python 3 版本）。此外，如果是 64 位操作系统，则选择 64 位安装程序，否则选择 32 位安装程序。继续并选择合适的版本，然后安装它。之后，继续进行！
完成安装后，会自动进入默认的 conda 环境，而且所有包均已安装完毕，如下面所示。可以在终端或命令提示符中键入 conda list，以查看你安装的内容。

在 Windows 上，会随 Anaconda 一起安装一批应用程序：

Anaconda Navigator，它是用于管理环境和包的 GUI
Anaconda Prompt 终端，它可让你使用命令行界面来管理环境和包
Spyder，它是面向科学开发的 IDE

为了避免报错，我推荐在默认环境下更新所有的包。打开 Anaconda Prompt （或者 Mac 下的终端），键入：conda upgrade --all
并在提示是否更新的时候输入y（Yes）以便让更新继续。初次安装下的软件包版本一般都比较老旧，因此提前更新可以避免未来不必要的问题。
在本课的余下部分，我会要求你在终端中使用命令。我强烈建议你以这种方式开始使用 Anaconda，之后再根据需要使用 GUI。
管理包安装了 Anaconda 之后，管理包是相当简单的。要安装包，请在终端中键入 conda install package_name。例如，要安装 numpy，请键入 conda install numpy。你还可以同时安装多个包。类似 conda install numpy scipy pandas的命令会同时安装所有这些包。还可以通过添加版本号（例如 conda install numpy=1.10）来指定所需的包版本。
Conda 还会自动为你安装依赖项。例如，scipy 依赖于 numpy，因为它使用并需要 numpy。如果你只安装 scipy (conda install scipy)，则 conda 还会安装 numpy（如果尚未安装的话）。
大多数命令都是很直观的。要卸载包，请使用 conda remove package_name。要更新包，请使用 conda update package_name。如果想更新环境中的所有包（这样做常常很有用），请使用 conda update --all。最后，要列出已安装的包，请使用前面提过的 conda list。
如果不知道要找的包的确切名称，可以尝试使用 conda search search_term 进行搜索。例如，我知道我想安装 Beautiful Soup，但我不清楚确切的包名称。因此，我尝试执行 conda search beautifulsoup。它返回可用的 Beautiful Soup 包的列表，并列出了相应的包名称 beautifulsoup4。
管理环境如前所述，可以使用 conda 创建环境以隔离项目。要创建环境，请在终端中使用 conda create -n env_name list of packages。在这里，-n env_name 设置环境的名称（-n 是指名称），而 list of packages 是要安装在环境中的包的列表。例如，要创建名为 my_env 的环境并在其中安装 numpy，请键入 conda create -n my_env numpy。创建环境时，可以指定要安装在环境中的 Python 版本。这在你同时使用 Python 2.x 和 Python 3.x 中的代码时很有用。要创建具有特定 Python 版本的环境，请键入类似于 conda create -n py3 python=3 或 conda create -n py2 python=2 的命令。实际上，我在我的个人计算机上创建了这两个环境。我将它们用作与任何特定项目均无关的通用环境，以处理普通的工作（可轻松使用每个 Python 版本）。这些命令将分别安装 Python 3 和 2 的最新版本。要安装特定版本（例如 Python 3.3），请使用 conda create -n py python=3.3。
进入环境创建了环境后，在 OSX/Linux 上使用 source activate my_env 进入环境。在 Windows 上，请使用 activate my_env。
进入环境后，你会在终端提示符中看到环境名称，它类似于 (my_env) ~ $。环境中只安装了几个默认的包，以及你在创建它时安装的包。可以使用 conda list 检查这一点。在环境中安装包的命令与前面一样：conda install package_name。不过，这次你安装的特定包仅在你进入环境后才可用。要离开环境，请键入 source deactivate（在 OSX/Linux 上）。在 Windows 上，请使用 deactivate。
保存和加载环境共享环境这项功能确实很有用，它能让其他人安装你的代码中使用的所有包，并确保这些包的版本正确。可以使用 conda env export &gt; environment.yaml 将包保存为 YAML。第一部分 conda env export 写出环境中的所有包（包括 Python 版本）。上图可以看到列出了环境的名称和所有依赖项及其版本。导出命令的第二部分 &gt; environment.yaml 将导出的文本写入到 YAML 文件 environment.yaml 中。现在可以共享此文件，而且其他人能够创建和你用于项目相同的环境。
要通过环境文件创建环境，请使用 conda env create -f environment.yaml。这会创建一个新环境，而且它具有在 environment.yaml 中列出的同一库。
列出环境如果忘记了环境的名称（我有时会这样），可以使用 conda env list 列出你创建的所有环境。你会看到环境的列表，而且你当前所在环境的旁边会有一个星号。默认的环境（即当你不在环境中时使用的环境）名为 root。
删除环境如果你不再使用某些环境，可以使用 conda env remove -n env_name 删除指定的环境（在这里名为 env_name）。
最佳做法使用环境对我帮助很大的一点是，我的 Python 2 和 Python 3 具有独立的环境。我使用了 conda create -n py2 python=2 和 conda create -n py3 python=3 创建两个独立的环境，即 py2 和 py3。现在，我的每个 Python 版本都有一个通用环境。在所有这些环境中，我都安装了大多数标准的数据科学包（numpy、scipy、pandas 等）。
我还发现，为我从事的每个项目创建环境很有用。这对于与数据不相关的项目（例如使用 Flask 开发的 Web 应用）也很有用。例如，我为我的个人博客（使用 Pelican）创建了一个环境。
共享环境在 GitHub 上共享代码时，最好同样创建环境文件并将其包括在代码库中。这能让其他人更轻松地安装你的代码的所有依赖项。对于不使用 conda 的人，我通常还会使用 pip freeze（在此处了解详情）将一个 pip requirements.txt 文件包括在内。
了解更多信息要详细了解 conda 和它如何融入到 Python 生态系统中，请查看这篇由 Jake Vanderplas 撰写的文章：Conda myths and misconceptions（有关 conda 的迷思和误解）。此外，有空也可以参考这篇 conda 文档。
书签Video to animated GIF converterhttp://ezgif.com/video-to-gif
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发——Android Studio</title>
    <url>/dev-android-as/</url>
    <content><![CDATA[简介Android Studio 是一个Android开发环境，基于IntelliJ IDEA. 类似 Eclipse ADT，Android Studio 提供了集成的 Android 开发工具用于开发和调试。
在IDEA的基础上，Android Studio 提供：

基于Gradle的构建支持
Android 专属的重构和快速修复
提示工具以捕获性能、可用性、版本兼容性等问题
支持ProGuard 和应用签名
基于模板的向导来生成常用的 Android 应用设计和组件
功能强大的布局编辑器，可以让你拖拉 UI 控件并进行效果预览



界面1、Project 面板用于浏览项目文件。 Project面板会显示当前的所有的module 。
2、Build Variants 面板用于设置当前项目的Build Variants。
3、Android 面板功能类似于Eclipse中的Logcat，但是比其多了一些常用功能，例如：截图，查看系统信息等。
4、编辑区用于编辑文件。
5、Gradle 面板Gradle任务列表，双击可执行Gradle任务。常用任务： build 、 clean 、 assemble 、 assembleRelease 、 assembleDebug 、 lint 。
项目结构Android模式新建一个项目，默认项目结构如下：可以看到和Eclipse的目录结构有很大区别，AS一个窗口只能有一个项目，而Eclipse则可以同时存在很多项目。
Project模式
目录结构中将java代码和资源文件（图片、布局文件等）全部归结为src，在src/main下，有java和res两个文件夹，java文件夹则相当于Eclipse下的src文件夹，res目录结构则一样。
下面详解一下Project模式下的目录结构：
.gradle官网www.gradle.org上介绍Gradle是升级版(evolved)的自动化构建工具。它可以自动构建，测试，发布，部署，同时使更多的软件包或其他类型诸如生成静态网站，文档等项目自动化。
说白了，gradle是maven的同类工具，而且比maven更好用。
打开.gradle文件夹，我们看到，里面除了有配置文件，还有一些二进制文件。由此，郝同学推测，这个目录中存放的就是gracle这款工具。
.ideaProject的配置文件目录，类似Eclipse中的project.properties。
app一个Module，基本开发单位。

build构建目录，相当于Eclipse中默认Java工程的bin目录。 

libs依赖包。

src/main/javaJava代码。

src/main/res/layoutApp布局及界面元素配置。

src/main/res/menuApp菜单配置。

src/main/res/valuesdimens.xml 定义css的配置文件；strings.xml 定义字符串的配置文件；styles.xml 定义style的配置文件。

src/main/res/mipmap-*App图标。

src/main/AndroidMainfest.xmlApp基本信息（名称、版本、SDK、权限等等）。

src/.gitignore顾名思义，郝同学猜测这个文件是用来配置上传到github时忽略的文件夹。

src/app.iml.iml文件是AS识别项目的配置文件，跟Eclipse里面的.project文件作用类似

src/build.gradlegradle构建脚本。

src/proguard-rules.pro混淆规则的声明。混淆代码，可以保护自己的作品不被别人破解。


build
gradle
.gitignore等.gitignore、build.gradle、First.iml三个文件，在Module中也存在，只不过作用范围不一样。
gradle.propertiesProject-wide Gradle settings。
gradlew和gradlew.batgradlew是一个shell脚本，适用于Linux；gradlew.bat是一个批处理文件，适用于windows。
gradlew，是对gradle的一个封装，在使用这个命令时会自动去下载gradle，如果已经安装了gradle则在编译过程中使用的gradlew命令应该都可以替换成gradle。自动下载gradle是根据gradle\wrapper目录中的gradle-wrapper.properties中配置的，distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip
local.propertiesThis file is automatically generated by Android Studio。
setting.gradle配置Project中包含的Module。在完全删除某个Module之前,如果还想要把它添加到当前project中,直接setting.gradle中添加该Module的名称即可。

AS中有Project和Module的概念：project in Android Studio is like a workspace in Eclipse。module in Android Studio is like a project in Eclipse。

增删项目新建Project新建Project的时候，会同时新建一个默认Module，name为app，可以重命名。新建Project和打开Project，都会打开一个新的AS窗口，可以在菜单栏Window中切换Project。
删除Project在工作路径下，删除Project文件夹。
新建Module新建Module，存放在当前的Project下，共享当前Project的一些资源，比如External Libraries和部分配置文件。
删除Module1、File，Project Structure；或者右击项目，Open Module Settings。2、选中Module，单击右上角的“-”号。3、右击Module（此时Module上的手机符号已经没有了），delete。
个性设置编辑器字体1、File，Settings；或者直接点击工具栏的Settings。2、Editor，Color&amp;Fonts，Font。3、把Darcula主题sava as为自己的主题，然后进行设置。
编码格式默认编码格式：File，Other Settings，Default Settings，Editor，File Encodings。
当前Project编码格式：File，Settings，Editor，File Encodings。
代码提示Settings，Editor，General，Code Completion，Case sensitive completion改为None。
悬停提示Settings，Editor，General，Show quick doc on mouse move前打勾。
Lint工具对代码进行测试是一回事，但同样重要的是、我们还需要在编写代码的同时引入各种最佳实践。这不仅能够显著改进性能表现，也能增加应用程序的整体稳定性。另外，经过合理结构调整的项目在维护方面也更为轻松。
Android Studio中提供的Android Lint是一款静态分析工具，它负责对项目源代码加以分析。它能够检测出应用程序中的潜在漏洞以及其它可能被编译器所忽略的其它代码问题。
就以下面这幅截图为例，大家可以看到该布局中的LinearLayout并未得到实际使用。Android Lint的优势在于，它能帮助我们重视警告或报错信息的出现原因，从而更轻松地修复或者解决这些问题。
请大家养成重复使用Android Studio Lint工具的好习惯，这能帮助我们准确检测到项目当中存在的潜在问题。Lint工具甚至能告诉我们应用程序中是否存在重复的图片或者编译内容。
要运行Lint工具，大家首先需要在Android Studio的“Analyze”菜单中选择“Inspect Code…”。当Android Studio完成了对项目的检测之后，它会在窗口底部显示出分析结果。请注意，除了Android Lint之外，Android Studio还提供一系列其它检查功能。只需双击某个已经发现的问题，系统就会帮助大家定位到对应文件中存在问题的位置。
富布局编辑器AS提供一套富布局编辑器，大家可以在其中随意拖拽各类用户界面组件。大家还可以在多屏幕配置中同时查看多种布局的显示效果，这一点我们在前文中已经提到过。
这款富布局编辑器在使用方面非常直观简单。我们首先需要一套要处理的布局方案。浏览到项目中res文件夹下的layout文件夹，右键点击layout文件夹，然后在弹出的菜单中选择New&gt;Layout resource file。
下面为新布局设定一个名称与root元素，而后点击“OK”。AS会自动在窗口右侧的编辑器当中打开该布局。
在编辑器的底部，大家会看到两个标签，分别是Design与Text。点击Text标签后编辑器将被激活，这样我们就能对当前选定的布局方案作出变更。
点击Design标签则会激活另一套编辑器内容，其中显示出布局的预览效果。要向布局当中添加其它功能性组件，我们只需将其从布局左侧的组件列表中拖出并放入布局内即可。是的，就这么简单。

快捷键Settings，Keymap，选择一个Keymaps。如果习惯用Eclipse，那么不妨选择Eclipse。谷歌建议使用默认快捷键，因为比Eclipse要丰富。如果使用默认快捷键，下面的几个快捷键最好记住。
ctrl+shift+enter代码自动补全。
alt+enter代码提示。
ctrl+alt+o引入包管理。
ctrl+q查看定义。
ctrl+alt+t弹出包围结构。
ctrl+j模板提示。
后记AS很强大，不可能面面俱到，先就这些吧。无论使用什么工具，当你开始使用它，一切都会变得简单！
参考文档与Android Studio的第一次亲密接触http://www.imooc.com/learn/206
Android Studio 常用功能介绍http://ask.android-studio.org/?/article/23
Android Studio系列教程二–基本设置与运行http://stormzhang.com/devtools/android-studio-tutorial2/
Android学习系列(41)–Android Studio简单使用http://www.cnblogs.com/qianxudetianxia/p/3848272.html
最全面的Android Studio使用教程http://www.open-open.com/lib/view/open1416883124753.html
Gradle基础http://segmentfault.com/a/1190000002439306
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发——版本控制和代码分享</title>
    <url>/dev-android-version-control/</url>
    <content><![CDATA[前言很自然的，觉得自己该使用一些版本控制工具了。虽然以前也使用过，但一直没有系统学习，现在，搞一搞吧！
以《Android开发——帧动画》中的Demo为例。
git作为一名程序员，不使用git，都不好意思和别人讲话。git的安装过程自行百度，或者参考郝同学的《Hexo环境搭建》。


在github新建repository新建repository，命名为demo。可以看到，repository的地址https://github.com/voidking/demo.git
配置git环境AS中，Settings，Version Control，Git。配置Path to Git executable，然后Test。
git initAS中，VCS，Import into Version Cotrol，Create Git Repository。OK之后，发现Project里的文件变成了红色。

git init，其实就是新建了一个本地仓库.git，相当于hexo里的.deploy_git。

git add单击Project名Demo，VCS，Git，Add。发现Project里的文件变成了绿色。

git add，其实就是把目标文件快照放入暂存区域，同时未曾跟踪过的文件标记为需要跟踪。

git commitVCS，Git，Commit Directory。单击Commit。

git commit，提交时记录的是放在暂存区域的快照，任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。

指定连接目标指定本地库与github的repository相连。
方法一（推荐）：在Demo目录下，右键，Git Bash Heregit remote add origin https://github.com/voidking/demo.git
方法二：VCS，Git，Push。如果没有执行方法一，这时可以看到Define Remote。填入https://github.com/voidking/demo.git，会报错，不知道为什么。
Remote URL is invalid: unable to access 'https://github.com/voidking/demo.git'

git pushVCS，Git，Push。
填入用户名和密码。之后，可以看到窗口最下面有个push进度条在跑。
如果弹出提示：我们勾选Encrypt with OS user credentials，意思是使用本机的SSH key。不明白的地方请见郝同学另一篇文章，《Hexo环境搭建》。
过一会儿，便可以看到成功的提示！
github我们查看一下github上的repository。至此，大功告成！

AS集成了GitHub插件，配置起来比上面的git配置要简单的多，钟爱GitHub的小伙伴不妨百度学习一下。

svn在实习的时候，使用过一段时间的svn。个人感觉，svn在团队开发中很好用。但是，当时在局域网使用，有些局限性。如果svn服务器搭在公网服务器上（比如阿里云），应该是极好的。值得一提的是，利用svn向sae的项目中上传文件，非常方便。
免费SVN服务器比起自己搭建服务器，抠门的郝同学更愿意使用免费svn服务器。但是，这种免费svn服务器极少，找了很久，只找到一个TaoCode。
http://code.taobao.org/
安装svnsvn，分为服务器和客户端，因为服务器使用TaoCode，所以我们只安装客户端就可以了。
1、服务器下载地址https://subversion.apache.org/download/
2、客户端下载地址http://tortoisesvn.net/downloads.html
3、服务器安装略。（突然感觉一个略字大气磅礴，瞬间省了好多字）
4、客户端安装需要注意的是，安装时选择安装command line（默认不安装），为了在AS中使用。
在TaoCode新建项目新建项目，命名为vkdemo。可以看到，svn repo地址为http://code.taobao.org/svn/vkdemo/ 
Checkout from Subversion1、打开AS，VCS，Checkout from Version Control，Subversion。2、点击加号（Add Repository Location）。3、添加Repository URL。此时Repository里啥也没有，咱们就不Checkout了。
Import into Subversion1、打开AS，VCS，Import from Version Control，Import into Subversion。2、选中URL，Import。3、选中需要Import的目录，OK。
点击OK，啊嘞，报错了！
哥哥是见过大世面的人，这点小错算什么！Settings，Version Control，Subversion，去掉General选项卡中所有勾。再次import，成功！不过，由于是整个项目上传，包括编译文件等，上传过程会很慢。
浏览svn文件夹打开AS，VCS，Browse VCS Repository，Browse Subversion Repository，选择URL。
再看Project目录：

文件红色：表示文件没有添加到服务器

绿色：表示没有更新新的修改到服务器

普通黑色：表示和服务器同步


文件夹符号说明
黄色感叹号(有冲突)：这是有冲突了，冲突就是说你对某个文件进行了修改，别人也对这个文件进行了修改，别人抢在你提交之前先提交了，这时你再提交就会被提示发生冲突，而不允许你提交，防止你的提交覆盖了别人的修改。要解决冲突，如果你确认你的修改是无效的，则用TSVN还原你的修改就行了；如果认为你的修改是正确的，别人的提交是无效的，那么用TSVN先标记为“解决冲突”，然后就可以提交了；如果你认为你的修改和别人的修改都有一部分是有效的，那么你就把别人的修改手动合并到你的修改中，然后使用TSVN标注为“解决冲突”，然后就可以提交了。
米字号(有本地修改代码)：这是说明你有未提交的本地代码。 
问号(新加入的资源)：这说明该文件是项目中新增文件资源，新增资源可以是文件、图片、代码等。
红色感叹号(本地代码与库没有保持一致)：这说明本地代码跟库上没有保持一致，如果用户想修复，可以将带红色感叹号图标文件删除，直接update即可。 
灰色向右箭头(本地修改过)：本地代码没有及时上库。
蓝色向左箭头(SVN上修改过)：记得更新代码后修改，提交前跟svn对比习惯。
灰色向右且中间有个加号的箭头(本地比SVN上多出的文件)：修改完记得跟svn保持一致。
蓝色向左且中间有个加号的箭头(SVN上比本地多出的文件)：删除该文件后，再次更新，将svn上文件全部更新下来。 
灰色向右且中间有个减号的箭头(本地删除了,而SVN上未删除的文件)：也就是说你删除确认后，一定要记得上库，跟svn保持一致 
蓝色向左且中间有个减号的箭头(SVN上删除了,而本地未删除的文件)：比对svn库上代码，确定需要删除后，更新svn(删除无用代码)。
红色双向箭头(SVN上修改过,本地也修改过的文件)：这个表示本地和svn上都修改过，最好就是把本地修改合并到svn，修改代码前最后先更新。
单个文件签入签出右键subversionAdd：添加到服务器
Commit：提交
Update：更新，获取新版本
Integrate：合并
后记对于git和svn的区别，哥只想说——啥，啥，这都是啥！。。。还是稍微总结一下吧！
1、git是分布式的，svn不是。

svn貌似进化了，它提供的命令svnsync就可以checkout所有版本到本地，这是分布式的特点哇！

2、git直接记录快照，而非差异比较。
3、git几乎所有操作都是本地执行（因为区别1）。
知道了这三条，平时吹吹牛逼应该够了，不满足的小伙伴请移步参考资料。
参考资料《Pro Git》http://git-scm.com/book/zh/v1
Learn Git Branchinghttp://learngitbranching.js.org/
git-使用简易指南http://www.bootcss.com/p/git-guide/
Android Studio之版本管理工具Githttp://www.wfuyu.com/technology/22499.html
Android studio -VSN 使用笔记http://www.cnblogs.com/shaocm/p/4182380.html
GIT和SVN之间的五个基本区别http://www.oschina.net/news/12542/git-and-svn
Git与svn的区别http://blog.csdn.net/huacuilaifa/article/details/19124635
为什么说 Git 比 SVN 更好http://www.oschina.net/news/29214/why-git-is-better-than-svn
分布式和集中式版本控制工具-svn,git,mercurial比较分析http://blog.csdn.net/augusdi/article/details/29846253
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible实战</title>
    <url>/dev-ansible-in-action/</url>
    <content><![CDATA[目标本文，目标是使用ansible安装lnmp+haproxy。共四台主机，都是ubuntu14 server版，一台作为ansible管理机，另外三台作为ansible客户机用来部署服务。客户机A安装nginx+php+mysql，客户机B安装nginx+php，客户机C安装haproxy用来负载均衡。如下图：


设计项目结构参考最佳实践-Content Organization，如下图：
注意点：

角色分配简单明确。
在hosts中分组添加变量，指定安装软件。
二次执行脚本时不能影响已经安装的服务。

安装流程1、添加密钥2、设置sudo免密3、更新安装源4、时间同步5、安装nginx+php+mysql+haproxy6、检查安装
实践文件准备1、创建项目lnmpmkdir lnmp &amp;&amp; cd lnmp
2、创建角色目录mkdir rolesmkdir -p roles/{1_key,2_sudo,3_sources,4_chrony,5_software,6_check}/{tasks,handlers,vars,files,templates}
3、创建变量目录mkdir group_vars host_vars
4、创建hosts文件，分配安装组，内容如下：
[base]192.168.56.102192.168.56.103192.168.56.104[nginx_php_mysql]192.168.56.102[nginx_php]192.168.56.103[haproxy]192.168.56.104[base:vars]install_nginx=falseinstall_php=falseinstall_mysql=falseinstall_haproxy=false[nginx_php_mysql:vars]install_nginx=trueinstall_php=trueinstall_mysql=trueinstall_haproxy=false[nginx_php:vars]install_nginx=trueinstall_php=trueinstall_mysql=falseinstall_haproxy=false[haproxy:vars]install_nginx=falseinstall_php=falseinstall_mysql=falseinstall_haproxy=true

5、创建site.yml文件，内容为：
---- hosts: all  gather_facts: false  roles:    - 1_key    - 2_sudo    - 3_sources    - 4_chrony    - 5_software    - 6_check

6、关闭第一次使用ansible连接客户端时命令提示sudo vim /etc/ansible/ansible.cfg，如下修改
# line 62, uncommenthost_key_checking = False

添加密钥1、设置用户和密码vim group_vars/base.yml，内容为：
---ansible_ssh_user: voidkingansible_ssh_pass: voidkingansible_sudo: voidkingansible_sudo_pass: voidking

2、vim test.yml，内容为：
---- hosts: all  vars_files:    - group_vars/base.yml  roles:    - 1_key

3、vim roles/1_key/tasks/main.yml，内容为：
---- name: copy public key  copy:    src: /home/voidking/.ssh/id_rsa.pub    dest: /home/voidking/.ssh/id_rsa.pub.tmp    owner: voidking    group: voidking    mode: 0600    force: yes- name: add public key  shell: cd /home/voidking/.ssh &amp;&amp; cat id_rsa.pub.tmp | tee &gt;&gt; authorized_keys

4、vim test_hosts，内容为：
[test]192.168.56.102

5、执行脚本
ansible-playbook test.yml -i test_hosts --syntax-checkansible-playbook test.yml -i test_hosts

5、在客户端查看结果ll .ssh
6、测试登录ssh voidking@192.168.56.102
sudo免密1、vim test.yml，内容为：
---- hosts: all  vars_files:    - group_vars/base.yml  roles:    #- 1_key    - 2_sudo

2、vim roles/2_sudo/tasks/main.yml，内容为：
---- name: add sudo user  shell: 'sudo sh -c "echo voidking ALL = NOPASSWD: ALL &gt;&gt; /etc/sudoers"'  #shell: 'echo "voidking ALL = NOPASSWD: ALL" | sudo tee &gt;&gt; /etc/sudoers'

3、执行脚本
ansible-playbook test.yml -i test_hosts --syntax-checkansible-playbook test.yml -i test_hosts -s


4、在客户端查看结果sudo ls
sudo免密2上面的方法，虽然成功添加了sudo，但是从提示我们看出，在shell模块中sudo马上就不能使用了。
1、vim roles/2_sudo/tasks/main.yml，修改如下：
---- name: add sudo user  become_user: root  become: true  shell: "echo voidking ALL = NOPASSWD: ALL &gt;&gt; /etc/sudoers"

2、执行脚本
ansible-playbook test.yml -i test_hosts --syntax-checkansible-playbook test.yml -i test_hosts


更新安装源1、vim test.yml，内容为：
---- hosts: all  vars_files:    - group_vars/base.yml  roles:    #- 1_key    #- 2_sudo    - 3_sources

2、vim roles/3_sources/files/sources.list，内容为：
deb http://cn.archive.ubuntu.com/ubuntu/ trusty main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu/ trusty-security main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://cn.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiverse##測試版源deb http://cn.archive.ubuntu.com/ubuntu/ trusty-proposed main restricted universe multiverse# 源碼deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty main restricted universe multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-backports main restricted universe multiverse##測試版源deb-src http://cn.archive.ubuntu.com/ubuntu/ trusty-proposed main restricted universe multiverse# Canonical 合作夥伴和附加# deb http://archive.canonical.com/ubuntu/ trusty partner# deb http://extras.ubuntu.com/ubuntu/ trusty main

3、vim roles/3_sources/tasks/main.yml，内容为：
---- name: replace sources.list  copy:    src: ../files/sources.list    dest: /etc/apt/sources.list    force: yes- name: update  become_user: root  become: true  shell: apt update- name: upgrade  become_user: root  become: true  apt:    upgrade: yes

4、执行脚本
ansible-playbook test.yml -i test_hosts --syntax-checkansible-playbook test.yml -i test_hosts

时间同步管理机准备1、管理机安装chronyapt -y install chrony
2、重启chronyservice chrony restart
3、拷贝chrony.confcp /etc/chrony/chrony.conf roles/4_chrony/files/
4、vim roles/4_chrony/files/chrony.conf，如下修改：
# line 20,comment#server 0.debian.pool.ntp.org offline minpoll 8#server 1.debian.pool.ntp.org offline minpoll 8#server 2.debian.pool.ntp.org offline minpoll 8#server 3.debian.pool.ntp.org offline minpoll 8# line 24,addserver 192.168.56.101 iburst

playbook配置1、vim test.yml，内容为：
---- hosts: all  vars_files:    - group_vars/base.yml  roles:    #- 1_key    #- 2_sudo    #- 3_sources    - 4_chrony

2、vim group_vars/base.yml，内容为：
---ansible_ssh_user: voidkingansible_ssh_pass: voidkingansible_sudo: voidkingansible_sudo_pass: voidkingansible_become_user: rootansible_become_pass: voidkingansible_become: true

3、vim roles/4_chrony/tasks/main.yml，内容为：
---- name: install chrony  apt:    name: chrony    state: latest- name: change config  copy:     src: ../files/chrony.conf     dest: /etc/chrony/chrony.conf    owner: root    group: root    mode: 0644    force: yes- name: restart chrony  service:    name: chrony    state: restarted

4、执行脚本
ansible-playbook test.yml -i test_hosts --syntax-checkansible-playbook test.yml -i test_hosts

5、在客户机验证chronychronyc sources
安装核心软件1、vim test_hosts，内容为：
[test]192.168.56.102[test:vars]install_nginx=trueinstall_php=trueinstall_mysql=trueinstall_haproxy=true

2、vim test.yml，内容为：
---- hosts: all  vars_files:    - group_vars/base.yml  roles:    #- 1_key    #- 2_sudo    #- 3_sources    #- 4_chrony    - 5_software

3、vim roles/5_software/tasks/main.yml，内容为：
---- name: install nginx  apt:    name: nginx    state: latest  when: install_nginx- name: install php  apt:    name: "&#123;&#123;item&#125;&#125;"    state: latest    update_cache: yes  with_items:    - php5    - libapache2-mod-php5    - php5-mcrypt    - php5-curl    - php5-imagick    - php5-cli    - php5-json    - php5-fpm    - php5-mysql  when: install_php- name: install mysql  apt:    name: "&#123;&#123;item&#125;&#125;"    state: latest  with_items:    - mysql-common    - mysql-server    - mysql-client    - python-mysqldb  when: install_mysql- name: config mysql passwd  mysql_user:    login_user: root    login_password: "\n"    name: root    password: "voidking"    host: "&#123;&#123;item&#125;&#125;"    priv: '*.*:ALL,GRANT'    state: present    check_implicit_admin: yes  with_items:    - "localhost"    - "%"  when: install_mysql- name: comment bind-address  shell: sed -i 's/^bind-address/#bind-address/g' /etc/mysql/my.cnf  when: install_mysql- name: restart mysql service  service:     name: mysql     state: restarted    enabled: true  when: install_mysql- name: install haproxy  apt:    name: haproxy    state: latest  environment:    RUNLEVEL: 1  when: install_haproxy- name: config haproxy  shell: sed -i 's/ENABLED=0/ENABLED=1/g' /etc/default/haproxy  when: install_haproxy- name: config haproxy port  copy:     src: ../files/haproxy.cfg    dest: /etc/haproxy/haproxy.cfg    force: yes  when: install_haproxy- name: restart haproxy  service:    name: haproxy    state: restarted  when: install_haproxy

4、vim roles/5_software/files/haproxy.cfg，内容为
global  log /dev/log    local0  log /dev/log    local1 notice  chroot /var/lib/haproxy  user haproxy  group haproxy  daemondefaults  log     global  mode    http  option  httplog  option  dontlognull  contimeout 5000  clitimeout 50000  srvtimeout 50000  errorfile 400 /etc/haproxy/errors/400.http  errorfile 403 /etc/haproxy/errors/403.http  errorfile 408 /etc/haproxy/errors/408.http  errorfile 500 /etc/haproxy/errors/500.http  errorfile 502 /etc/haproxy/errors/502.http  errorfile 503 /etc/haproxy/errors/503.http  errorfile 504 /etc/haproxy/errors/504.httpfrontend http_front  bind *:8080  stats uri /haproxy?stats  default_backend http_backbackend http_back  balance roundrobin  option httpchk GET /index.html  option forwardfor header X-Forwarded-For  server node1 192.168.56.102:80 check inter 2000 rise 3 fall 3 weight 30  server node2 192.168.56.103:80 check inter 2000 rise 3 fall 3 weight 30

5、执行脚本
ansible-playbook test.yml -i test_hosts --syntax-checkansible-playbook test.yml -i test_hosts

6、在客户机测试mysql -uroot -p -h 192.168.56.102
curl localhost
curl localhost:8080
整合所有步骤1、执行脚本
ansible-playbook site.yml -i hosts --syntax-checkansible-playbook site.yml -i hosts

2、查看安装
curl 192.168.56.102curl 192.168.56.103curl 192.168.56.104:8080

检查安装1、vim site.yml，修改为：
---- hosts: all  gather_facts: false  roles:    #- 1_key    #- 2_sudo    #- 3_sources    #- 4_chrony    #- 5_software    - 6_check

2、vim roles/6_check/tasks/main.yml，内容为：
---- name: copy index.html  template:    src: ../templates/index.j2    dest: /usr/share/nginx/html/index.html    force: yes  when: install_nginx


3、vim roles/6_check/templates/index.j2，内容为：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Home Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &#123;&#123; ansible_eth0.ipv4.address &#125;&#125;&lt;/body&gt;&lt;/html&gt;

PS：查看变量ansible 192.168.56.102 -m setup &gt; var.txt
4、执行脚本
ansible-playbook site.yml -i hosts --syntax-checkansible-playbook site.yml -i hosts

5、测试访问curl 192.168.56.104:8080多次执行，可以看到两个不同的IP会来回切换。
源码分享项目地址：https://github.com/voidking/lnmp.git
书签Ansible Documentation
Ansible中文权威指南
Ansible精讲
烂泥：高负载均衡学习haproxy之安装与配置
HAproxy 配置参数详解
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ansible</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible Playbooks</title>
    <url>/dev-ansible-playbooks/</url>
    <content><![CDATA[Playbooks简介与ad-hoc任务执行模式相比，Playbooks使用ansible是一种完全不同的方式，并且功能特别强大。
简而言之，playbooks是真正简单的配置管理和多机器部署系统的基础，与已有的系统不同，并且非常适合部署复杂的应用程序。
Playbooks可以声明配置，但它们也可以协调任何手动有序流程的步骤，即使不同的步骤必须按照特定顺序在机器组之间来回跳转。它们可以同步或异步启动任务。更多playbooks的介绍参考官方文档。


Playbooks以YAML格式表示（请参阅YAML语法），具有最少的语法，它不是编程语言或脚本，而是配置或进程的模型。
每个剧本由列表中的一个或多个“戏剧”组成。戏剧的目标是将一组主机映射到一些定义明确的角色，由ansible调用任务表示。在基本级别，任务只不过是对ansible模块的调用（请参阅使用模块）。
通过编写多个“戏剧”的剧本，可以编排多机部署，在Web服务器组中的所有计算机上运行某些步骤，然后在数据库服务器组上执行某些步骤，然后在Web服务器组上执行更多命令，等等。。
你可以有很多戏剧影响你的系统做不同的事情。这并不是说你只是定义了一个特定的状态或模型，而是可以在不同的时间运行不同的戏剧。
Playbooks Demo以下是只包含一个戏剧的剧本：
---- hosts: webservers  vars:    http_port: 80    max_clients: 200  remote_user: root  tasks:  - name: ensure apache is at the latest version    yum:      name: httpd      state: latest  - name: write the apache config file    template:      src: /srv/httpd.j2      dest: /etc/httpd.conf    notify:    - restart apache  - name: ensure apache is running    service:      name: httpd      state: started  handlers:    - name: restart apache      service:        name: httpd        state: restarted


文件开头三个横杠代表yaml文件。
hosts表示一个主机组。
tasks表示动作集合。
name是一个注释说明。
yum和下面两行，表示使用yum安装最新版的httpd。
template和下面两行，表示使用ansible的template模块传输/srv/httpd.j2作为客户机的/etc/httpd.conf。和copy相比，template支持jinja语法。
notify和下面一行，表示传输成功后触发重启apache命令。它需要和handlers组合使用。
handlers中的name和notify中的信息要完全相同。service和下面两行，表示重启httpd。

Playbooks可以包含多个戏剧。您可能有一个首先针对Web服务器，然后是数据库服务器的playbook。例如：
---- hosts: webservers  remote_user: root  tasks:  - name: ensure apache is at the latest version    yum:      name: httpd      state: latest  - name: write the apache config file    template:      src: /srv/httpd.j2      dest: /etc/httpd.conf- hosts: databases  remote_user: root  tasks:  - name: ensure postgresql is at the latest version    yum:      name: postgresql      state: latest  - name: ensure that postgresql is started    service:      name: postgresql      state: started

入门实例目标：编写一个playbook，在客户机上安装chrony，然后检查启动情况。
1、新建chrony.yml，内容为：
---- hosts: commonservers  tasks:  - name: install chrony    apt:      name: chrony      state: latest    notify:    - restart chrony  - name: ensure chrony is running    service:      name: chrony      state: started  handlers:    - name: restart chrony      service:        name: chrony        state: restarted

上面的playbook中用到了apt模块，如果有疑问可以查看帮助，ansible-doc apt。实际上，有一种更加简单的写法，就是把apt模块换成command模块，然后直接写命令。
2、检查playbookansible-playbook chrony.yml --syntax-check
3、以sudo权限执行playbookansible-playbook chrony.yml --user=voidking --private-key=/home/voidking/.ssh/id_rsa -s
4、在客户机测试chronyc sources
角色如果需要将一个大文件拆分为各个小文件，我们经常使用的就是include，这也是原先ansible拆分文件的做法。如今ansible使用roles来拆分文件，将nginx、mysql等分为各个角色，在各个角色内定义具体的小任务，方便管理。另一方面，类似于php类的自动加载，roles基于一个已知的文件结构，可以自动去加载某些vars_files、tasks、handlers等。
目标：使用角色的方式，编写配置playbook，在客户机上安装chrony，然后检查启动情况。
1、创建chrony角色目录mkdir -p roles/chrony/tasks
mkdir -p roles/chrony/handlers
2、创建总的入口文件site.yml，内容为：
---- hosts: commonservers  roles:    - chrony

3、创建安装剧本vim roles/chrony/tasks/main.yml，内容为：
---- name: install chrony  apt:    name: chrony    state: latest  notify:  - restart chrony- name: ensure chrony is running  service:    name: chrony    state: started


vim roles/chrony/handlers/main.yml，内容为：
---- name: restart chrony  service:    name: chrony    state: restarted

4、以sudo权限执行playbookansible-playbook site.yml --user=voidking --private-key=/home/voidking/.ssh/id_rsa -s

5、在客户机测试chronyc sources
简单编程变量---- hosts: commonservers  vars:    pre1: all info is     pre2: hostname is  tasks:  - name: register vars    shell: hostname    register: info  - name: display info    debug: msg="&#123;&#123;pre1&#125;&#125; &#123;&#123;info&#125;&#125;"  - name: display hostname    debug: msg="&#123;&#123;pre2&#125;&#125; &#123;&#123;info.stdout&#125;&#125;"

基本循环---- hosts: commonservers  tasks:  - name: loops demo    debug: msg="&#123;&#123;item&#125;&#125;"    with_items:      - one      - two      - three


循环字典---- hosts: commonservers  tasks:  - name: loops dict    debug: msg="key -&gt; &#123;&#123;item.key&#125;&#125;,value -&gt; &#123;&#123;item.value&#125;&#125;"    with_items:      - &#123;key: 1, value: "one"&#125;      - &#123;key: 2, value: "two"&#125;      - &#123;key: 3, value: "three"&#125;


嵌套循环---- hosts: commonservers  tasks:  - name: loops2     debug: msg="item0 -&gt; &#123;&#123;item[0]&#125;&#125;,item1 -&gt; &#123;&#123;item[1]&#125;&#125;"    with_nested:      - ['1','2']      - ['one','two','three']


散列循环---- hosts: commonservers  vars:    user:       voidking:        name: voidking        tel: 17600000000      haojin:        name: haojin        tel: 15100000000  tasks:  - name: loops3     debug: msg="key -&gt; &#123;&#123;item.key&#125;&#125;,value -&gt; &#123;&#123;item.value&#125;&#125;"    with_dict:      - "&#123;&#123;user&#125;&#125;"


文件循环---- hosts: commonservers  tasks:  - name: loop file    debug: msg="&#123;&#123;item&#125;&#125;"    with_fileglob:      - /home/voidking/*.yml

命令循环---- hosts: commonservers  tasks:    - name: exec command      shell: "&#123;&#123;item&#125;&#125;"      with_items:        - hostname        - uname      register: ret    - name: display result      debug: msg="&#123;% for i in ret.results %&#125; &#123;&#123;i.stdout&#125;&#125; &#123;% endfor %&#125;"


条件判断ansible的条件判断使用关键字when，有两种方式：

python语法支持的原生态格式 conditions &gt; 1 or conditions == “ss”，in，not等等
ansible Jinja2 filters

---- hosts: commonservers  vars:    pre: hostname is  tasks:  - name: register vars    shell: hostname    register: info  - name: display hostname    debug: msg="&#123;&#123;pre&#125;&#125; &#123;&#123;info.stdout&#125;&#125;"  - name: print true    debug: msg="result is ubuntu14"    when: info.stdout == "ubuntu14"  - name: print false    debug: msg="result is not ubuntu14"    when: info.stdout != "ubuntu14"  - name: print warning    debug: msg="client OS is ubuntu"    when: info['stdout'].startswith('u')


后记至此，playbooks最基础的东西学习完毕。更高级的用法，在使用中再慢慢学习。
书签Ansible Documentation
Ansible中文权威指南
Ansible精讲
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ansible</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible入门篇</title>
    <url>/dev-ansible-start/</url>
    <content><![CDATA[前言《Ubuntu16使用Kolla安装OpenStack》一文中，用到了ansible。本文，我们就来研究一下ansible的基本用法。


Ansible简介ansible是一个用于自动化运维的配置管理和应用部署工具。基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric.SaltStack ）的优点，实现了批量系统配置、批量程序部署、批量运行命令等功能。ansible是基于模块工作的，本身没有批量部署的能力，真正具有批量部署能力的是ansible所运行的模块。
ansible的基本架构：

连接插件（connectior plugins）用于连接管理端和被管理端。
核心模块（core modules）连接主机实现操作，它依赖于具体的模块来做具体的事情。
自定义模块（custom modules）根据自己的需求编写具体的模块。
插件（plugins）完成模块功能的补充。
剧本（playbooks）ansible的配置文件，将多个任务定义在剧本中，由ansible自动执行。
主机清单（host inventory）定义ansible需要操作主机的范围。

上述简介摘自ansible基础。
实验环境两台主机，都是ubuntu14.04.4 server版，用户都是voidking。一台作为管理机，IP为192.168.56.101，一台作为被管理机（以下称为客户机），IP为192.168.56.102。
在管理机上安装ansible，一条命令搞定：sudo apt install ansible。不过，安装的ansible版本很低，默认1.5.4。这里我们通过添加源来安装最新版ansible：
sudo apt remove ansiblesudo apt-get install software-properties-commonsudo apt-add-repository ppa:ansible/ansiblesudo apt-get updatesudo apt-get install ansible

这样，就能安装好最新版的ansible。
连接准备1、在管理机生成密钥ssh-keygen，连续回车即可。
2、将公钥写入客户机ssh-copy-id -i .ssh/id_rsa.pub -p 22 voidking@192.168.56.102
3、在管理机添加客户机到hostssudo vim /etc/ansible/hosts，在文档最后添加：
[commonservers]192.168.56.102

4、在管理机第一条命令ansible all -m ping
5、在客户机把voidking用户添加进sudo免密，方便以后的操作sudo vim /etc/sudoers，添加
voidking ALL = NOPASSWD: ALL

ssh-agentansible可能使用到ssh-agent，那就顺便学习一下，参考了解ssh代理：ssh-agent。
ssh-agent是ssh代理程序，ssh-agent可以帮助我们管理私钥。
那么什么时候需要ssh代理帮助我们管理私钥呢？当遇到如下情况时，我们会需要ssh代理。

使用不同的密钥连接到不同的主机时，需要手动指定对应的密钥，ssh代理可以帮助我们选择对应的密钥进行认证，不用手动指定密钥即可进行连接。

当私钥设置了密码，我们又需要频繁的使用私钥进行认证时，ssh代理可以帮助我们免去重复的输入密码的操作。

管理机可以通过密钥连接到客户机A和客户机B，但是客户机A无法通过密钥连接到客户机B，ssh代理可以帮助我们在客户机A也能通过密钥连接到客户机B。


我们以添加.ssh/id_rsa私钥给ssh代理为例，查看一下使用流程。
1、启用ssh-agentssh-agent bash
2、把.ssh/id_rsa添加到ssh代理ssh-add ~/.ssh/id_rsa
3、测试登录ssh voidking@192.168.56.102登录成功。切换到root用户，ssh-agent失效。重新使用voidking登录，ssh-agent失效。想要重新登录依然生效，那就创建个脚本登录时自动执行。
常用命令： 

ssh-agent $SHELL，启动
ssh-agent -k，关闭
ssh-add ~/.ssh/key_name，添加指定私钥
ssh-add -l，查看私钥
ssh-add -L，查看公钥
ssh-add -d /path/of/key/key_name，删除指定私钥
ssh-add -D，删除所有私钥
ssh-add -x，设置密码，锁定ssh代理
ssh-add -X，输入密码，解锁ssh代理

ansible命令基本命令
ansible，主程序，临时命令执行工具
ansible-doc，查看配置文档，模块功能查看工具
ansible-galaxy，下载/上传优秀代码或Roles模块的官网平台
ansible-lint，对playbook的语法进行检查的一个工具。
ansible-playbook，定制自动化任务，编排剧本工具
ansible-pull，远程执行命令的工具
ansible-vault，文件加密工具。
ansible-console，基于console界面与用户交互的执行工具。

配置文件
/etc/ansible/ansible.cfg，主配置文件，配置ansible工作特性
/etc/ansible/hosts，主机清单
/etc/ansible/roles/，存放角色的目录

1、ansible.cfg的配置参考Configuring Ansible，主要留意inventory、forks、poll_interval、remote_port、log_path等参数。
2、hosts文件有一个特性很棒，可以指定变量，例如：
[commonservers]192.168.56.102[commonservers:vars]ansible_ssh_pass='123456'ansible_ssh_port=22[commonservers1]192.168.56.103[commonservers:children]commonservers1

内置变量小结：
# 主机名ansible_ssh_host # 端口号ansible_ssh_port# 用户名 ansible_ssh_user # 密码ansible_ssh_pass # 使用sudo连接用户时的密码ansible_sudo_pass # 秘钥文件如果不想使用ssh-agent管理时可以使用此选项ansible_ssh_private_key_file # shell的类型默认shansible_shell_type # SSH 连接的类型ansible_connection # 指定python解释器的路径ansible_python_interpreter

如果在hosts文件中指定了用户名和密码，使用时报错 to use the ‘ssh’ connection type with passwords, you must install the sshpass program那么需要先安装sshpass，安装命令为：
# ubuntuapt-get install sshpass# centosyum install epel-release -yyum install sshpass -y

ansible格式：ansible &lt;host-pattern&gt; [-m module_name] [options]
ansible是指令核心部分，其主要用于执行ad-hoc命令，即单条命令。默认后面需要跟主机和选项部分，默认不指定模块时，使用的是command模块。command模块不是调用的shell的指令，所以没有bash的环境变量，也不能使用shell的一些操作方式，其他和shell模块没有区别。
例子：
# 查看所有主机ansible all --list-hosts# 指定主机清单ansible all -i ./hosts --list-hosts# 查看commonservers组的主机ansible commonservers --list-hosts# 测试连通ansible all -m ping# 查看客户机的内存ansible all -m command -a "free -h"# 在客户机执行管理机脚本cp /bin/echo ~/echo.shansible all -m script -a "~/echo.sh hello" -vvv# 在客户机执行客户机脚本ansible all -m command -a "cp /bin/echo /home/voidking/echo.sh"ansible all -m shell -a "/home/voidking/echo.sh hello"# 向客户机拷贝文件ansible all -m copy -a "src=/home/voidking/echo.sh dest=/tmp/ owner=voidking group=voidking mode=0755"# 后台执行命令ansible all -m ping -B 3600 -P 0ansible all -m async_status -a "jid='182829279182.2094'"# 批量添加sudo权限ansible all -i hosts -s -m shell -a "echo 'haojin ALL=(ALL) NOPASSWD: ALL' &gt;&gt; /etc/sudoers"# 批量移除sudo权限ansible all -i hosts -s -m shell -a "sed -i '/haojin ALL=(ALL) NOPASSWD: ALL/d' /etc/sudoers"# 使用root用户备份和拷贝文件ansible all -i hosts -s -m shell -a "mv /tmp/run.sh /tmp/run.sh.bak"ansible all -i hosts -b --become-user=root -m shell -a "mv /tmp/run.sh /tmp/run.sh.bak"ansible all -i hosts -s -m copy -a "src=/root/run.sh dest=/tmp/run.sh owner=voidking group=root mode=0755"# 重启服务ansible all -i hosts -s -m shell -a "/tmp/stop.sh"ansible all -i hosts -s -m shell -a "/tmp/run.sh" -u voidking

ansible-doc格式：ansible-doc [options] [module...]
例子：
ansible-doc pingansible-doc -s pingansible-doc -lansible-doc -a

通配符# 匹配所有主机，相当于allansible '*' -m ping# 匹配含有common的主机组ansible '*common*' -m ping# 匹配IP为100-109的主机ansible '192.168.56.10?' -m ping# 匹配IP段ansible '192.168.56.101:192.168.56.200' -m ping# 逻辑与ansible 'commonservers:&amp;dbservers' --list# 逻辑非ansible 'commonservers:!dbservers' --list# 正则表达式ansible '~192\.168\.56\.[1-254]' --list

指定ansible.cfg如果ansible没有指定ansible.cfg，或者想要临时使用自己定义的ansible.cfg，该怎么处理？
1、参考ansible.cfg，创建ansible.cfg文件，假设路径为 /home/voidking/ansible.cfg
2、设置环境变量export ANSIBLE_CONFIG=/home/voidking/ansible.cfg
3、查看配置ansible --version
书签Ansible Documentation
Ansible中文权威指南
Ansible精讲
运维自动化-Ansible ( 一 )
Ansible 运维自动化 ( 配置管理工具 )
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ansible</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>通过远程控制接口批量安装系统</title>
    <url>/dev-batch-install-sys-by-mgmt/</url>
    <content><![CDATA[前言《通过远程控制接口给服务器安装系统》一文中，我们发现通过远程控制接口给服务器安装系统很方便。《Ubuntu系统批量自动安装》一文中，我们学会了使用PXE技术进行系统的批量安装。
这两者结合，能产生怎样的魔力？下面是见证奇迹的时刻。
需求：机房里有40台曙光I620-G20机器需要安装Ubuntu16 Server系统，曙光供应商说需要两天的工作量，报价五千元。那么自己安装的话，需要多长时间？也需要两天吗？


安装步骤1、进入机房，给40台机器配置远程控制接口的IP。参考《通过远程控制接口给服务器安装系统》的远程控制接口配置部分。
2、搭建PXE服务器。参考《Ubuntu系统批量自动安装》，并且进行改进。
3、远程控制批量安装系统。
搭建PXE服务器基本准备1、一台服务器，已经安装好了Ubuntu16 Server版系统，IP为172.16.0.162。2、更换源列表并更新，参考《Ubuntu更换源列表》。3、切换到root用户，sudo -i4、开启路由转发，echo 1 &gt; /proc/sys/net/ipv4/ip_forward。务必开启，因为PXE服务器同时作为网关，不开启的话安装会卡住。5、在PXE服务器上安装DNS服务（可选操作，没有什么影响）。
DHCP和FTP本节主要参考How to Install Ubuntu via PXE Server Using Local DVD Sources。
1、安装DHCP和FTP服务apt-get install dnsmasq
2、指定DHCP网卡ip add，看到正在使用的网卡为ens2f1（172.16.0.162）。
3、配置dnsmasqvim /etc/dnsmasq.conf，在文件末尾添加：
interface=ens2f1dhcp-range=172.16.0.163,172.16.0.254,24hdhcp-option=3,172.16.0.162dhcp-option=6,172.16.0.162dhcp-option=28,172.16.0.255dhcp-option=42,0.0.0.0dhcp-boot=pxelinux.0,172.16.0.162enable-tftptftp-root=/tftpboot# gateway to Internet#dhcp-option=3,172.16.0.135# real dns server#dhcp-option=6,172.20.1.4#server=8.8.4.4
dhcp-option=3表示网关，6表示域名服务器，28表示broadcast，48表示时间服务器。server表示DNS forwarder IPs Address。
需要注意的是，网关一定要配置，否则在使用内网镜像安装时会特别慢。在获取镜像时卡住半小时，查看安装日志如下图所示；在“Updating the list of available packages”时也会卡住半小时。而且，最好不要让服务器连接到外网，否则安装过程中会自动从网络中获取更新，安装就会很慢。就像本文中的配置，网关和域名服务器都设置为PXE服务器的IP，而不是真实的可以访问外网的网关和域名服务器。
4、查看服务systemctl status dnsmasq
配置netboot1、下载网络启动文件，只有43M
wget http://ftp.ubuntu.com/ubuntu/dists/xenial/main/installer-amd64/current/images/netboot/netboot.tar.gz
或者从ubuntu-16.04.4-server-amd64.iso镜像中拷贝，netboot.tar.gz相当于install/netboot目录的压缩文件。
2、解压文件
tar -xzvf netboot.tar.gz -C /tftpboot/
解压后的文件包括：
ldlinux.c32 -&gt; ubuntu-installer/amd64/boot-screens/ldlinux.c32pxelinux.0  -&gt; ubuntu-installer/amd64/pxelinux.0pxelinux.cfg -&gt; ubuntu-installer/amd64/pxelinux.cfg/ubuntu-installer/version.info

安装系统1、远程连接需要安装系统的服务器，设置BIOS，选择从网络启动。
2、选择Install，正常安装系统即可，不过，系统镜像需要从外网下载。这里没有连接外网，就不再往下演示。
以上，实现了从网络安装源安装Ubuntu系统。但是存在两个问题，一个问题是系统镜像需要从外网下载，浪费带宽。另一个问题是安装过程中需要不断交互，浪费时间。
PXE服务器升级配置内网镜像1、安装apache2apt-get install apache2 -y
web根目录是 /var/www/html/
2、测试apache2curl 127.0.0.1
3、重启apache2/etc/init.d/apache2 restart
4、上传ubuntu-16.04.4-server-amd64.iso到用户目录。scp ubuntu-16.04.4-server-amd64.iso test@172.16.0.162:~
5、挂载ubuntu-16.04.4-server-amd64.iso到ubuntu目录。在用户目录执行：
mkdir /var/www/html/ubuntumount ubuntu-16.04.4-server-amd64.iso /var/www/html/ubuntu

6、替换netboot为镜像中的netboot，否则内核版本的差异会导致安装失败。
rm -rf /tftpboot/*cp -r /var/www/html/ubuntu/install/netboot/* /tftpboot/

7、再次安装系统，此时就可以从PXE服务器获取系统镜像了。在选择镜像界面，上拉到enter information manually，回车。archive hostname输入172.16.0.162。directory输入/ubuntu，注意，ubuntu后面不要有斜杠。如果系统安装卡住，那么Alt+F2进入控制台，tail /var/log/syslog查看系统安装日志，根据日志进行排错。查看错误后Alt+F1返回图形安装界面。
8、安装完成的系统，启动后发现卡住。这时Alt+F2切换到第二个终端，就可以正常使用系统了。
添加硬盘启动系统安装完成，如果依然从网络启动的话，那么每次启动依然会进入到Installer boot menu界面，除非再次修改BIOS首选启动项。不妨在Installer boot menu界面添加一个启动项，该启动项允许从本地硬盘启动。主要参考Install Ubuntu 16.04 via PXE and network boot。
1、编辑pxelinux.cfg文件vim /tftpboot/pxelinux.cfg/default，修改为：
# D-I config version 2.0# search path for the c32 support libraries (libcom32, libutil etc.)path ubuntu-installer/amd64/boot-screens/include ubuntu-installer/amd64/boot-screens/menu.cfgdefault ubuntu-installer/amd64/boot-screens/vesamenu.c32prompt 0# add localboot herelabel localboot    menu label Boot from Disk    localboot 0timeout 0
此外，timeout默认是0，这里可以改为60，那么6秒后会自动选择install选项。
2、再次通过网络启动，即可看到硬盘启动选项。选中它回车，即可启动本地硬盘上的系统。
自动选择安装源以上安装，我们需要手动输入archive hostname和directory，能不能在安装过程中自动选择？当然可以。本方法主要参考PXEInstallServer。
1、编辑txt.cfgvim /tftpboot/ubuntu-installer/amd64/boot-screens/txt.cfg，原内容为：
default installlabel install    menu label ^Install    menu default    kernel ubuntu-installer/amd64/linux    append vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiet label cli    menu label ^Command-line install    kernel ubuntu-installer/amd64/linux    append tasks=standard pkgsel/language-pack-patterns= pkgsel/install-language-support=false vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiet
修改为：
default installlabel install        menu label ^Install        menu default        kernel ubuntu-installer/amd64/linux        append ks=http://172.16.0.162/ks.cfg vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiet  label cli        menu label ^Command-line install        kernel ubuntu-installer/amd64/linux        append tasks=standard pkgsel/language-pack-patterns= pkgsel/install-language-support=false vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiet

2、在/var/www/html目录创建ks.cfg文件，内容为：
installurl --url http://172.16.0.162/ubuntu/

3、重新安装系统，即可省去设置archive hostname的步骤。
配置无人值守既然可以自动选择安装源，那么其他交互步骤可不可以自动选择？当然可以。控制安装过程的自动交互主要有两个文件：ks.cfg和ubuntu-server.seed。
ks.cfg1、在安装菜单添加ks.cfg和ubuntu-server.seedvim /tftpboot/ubuntu-installer/amd64/boot-screens/txt.cfg，修改为：
default installlabel install    menu label ^Install    menu default    kernel ubuntu-installer/amd64/linux    append ks=http://172.16.0.162/ks.cfg preseed/url=http://172.16.0.162/ubuntu-server.seed vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quietlabel cli    menu label ^Command-line install    kernel ubuntu-installer/amd64/linux    append tasks=standard pkgsel/language-pack-patterns= pkgsel/install-language-support=false vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiet

2、编辑/var/www/html/ks.cfg文件参考《Ubuntu系统批量自动安装》一文中的ks.cfg。编辑后的ks.cfg文件内容如下：
#Generated by Kickstart Configurator#platform=AMD64 or Intel EM64T#System languagelang en_US#Language modules to installlangsupport en_US#System keyboardkeyboard us#System mousemouse#System timezonetimezone Asia/Shanghai#Root passwordrootpw --disabled#Initial useruser test --fullname "test" --iscrypted --password $1$AKq0i3Yu$Tunuha7bYwq5uUV62F2nF0#Reboot after installationreboot#Use text mode installtext#Install OS instead of upgradeinstall#Use Web installationurl --url http://172.16.0.162/ubuntu/#System bootloader configurationbootloader --location=mbr #Clear the Master Boot Recordzerombr yes#Partition clearing informationclearpart --all --initlabel #System authorization infomationauth  --useshadow  --enablemd5 #Network informationnetwork --bootproto=dhcp --device=ens2f0#Firewall configuration#firewall --disabled --trust=ens2f0 --ssh #Do not configure the X Window Systemskipx
需要注意的是网卡的配置，这里的网卡名指的是需要安装系统的网卡名。
3、在/var/www/html目录创建ubuntu-server.seed文件，内容为空（暂时不配置）。
4、再次安装系统，绝大部分步骤都会自动进行选择了。但是，在分区部分卡住。手动分区后，后续会全部自动安装。安装完成后，系统没有安装openssh服务。
ubuntu-server.seed本文中，ubuntu-server.seed主要用来解决分区、选择软件等ks.cfg没有解决的问题。
1、编辑seed文件vim /var/www/html/ubuntu-server.seed，添加：
d-i pkgsel/include string openssh-serverd-i partman/confirm_write_new_label boolean trued-i partman/choose_partition select Finish partitioning and write changes to diskd-i partman/confirm boolean true
其他配置可以参考/var/www/html/ubuntu/preseed/目录中的文件，不过本文中用不到其他配置了。
2、再次安装系统，此时就会自动分区，并且安装openssh服务了。全程不需要手动帮助设置，完美。
配置手动安装个别情况下，自动安装会失败，这时就需要手动安装，在Installer boot menu界面添加一个手动安装启动项即可。
1、编辑pxelinux.cfg文件vim /tftpboot/pxelinux.cfg/default，修改为：
# D-I config version 2.0# search path for the c32 support libraries (libcom32, libutil etc.)path ubuntu-installer/amd64/boot-screens/include ubuntu-installer/amd64/boot-screens/menu.cfgdefault ubuntu-installer/amd64/boot-screens/vesamenu.c32prompt 0# add localboot herelabel localboot    menu label Boot from Disk    localboot 0label manual install    menu label Manual Install    kernel ubuntu-installer/amd64/linux    append ks=http://172.16.0.162/manual.cfg vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiettimeout 0

2、在/var/www/html目录创建manual.cfg文件，内容为：
installurl --url http://172.16.0.162/ubuntu/

3、重新安装系统，Installer boot menu界面就会出现手动安装选项。
批量安装1、远程连接需要安装系统的服务器，设置BIOS，选择从网络启动。
2、安装正常系统，有些机器在网络部分卡住。此时，可以手动给网卡配置IP。但是，如果系统只检测到一个网卡，而这个网卡没有连接网线，那么无法完成接下来的安装。因为没有IP，所以无法通过获取ks.cfg等文件。Alt+F2进入控制台，ip add看到IP设置成功，但是无法ping通PXE服务器。Alt+F1返回图形界面。此时，最好的做法是进入机房，把网线接到可以检测到的那个网卡。然后Ctrl+Alt+Del重启服务器。
3、再次安装系统，即可顺利安装。
配置静态IP系统安装完成后，此时不能上网，需要给系统配置静态IP和网关，这时发现了一个小问题：系统中没有安装vim，自带的vi也有毛病。怎么办？使用nano。
1、编辑interfacessudo nano /etc/network/interfaces
2、保存文件编辑完成，Ctrl+X退出，系统提示是否保存，输入Y回车，然后再次回车保存。
3、重启网络服务
sudo /etc/init.d/networking restart# orsudo ifdown ens2f0sudo ifup ens2f0
重启网络服务后发现，此时网卡上有两个IP地址，而且只有DHCP分配的旧的IP地址生效（第一个）。
4、取消IP地址并重启网络服务
sudo ip addr flush dev ens2f0sudo /etc/init.d/networking restart
此时静态IP就配置成功了。
后记给40台机器配置远程控制接口的IP，搭建PXE服务器，安装系统，配置静态IP，总计用时一周左右。从效率上讲不如外包找人安装，从研究上讲还是有很多收获的。还好最近清闲了一些，不然还真没时间把整个安装流程搞清楚。之所以用时很久，主要是因为有一些机器之前使用过，所以安装的时候需要手动确认remove volume data，或者disk detect报错需要手动安装，如下图所示。
书签Netboot Install
PXE-netboot-install
Ubuntu 16.04 LTS (Xenial Xerus) Netboot
How to install PXE Server on Ubuntu 16.04
神奇的fdisk和dd命令
PXE网络克隆图文教程
DHCP tftp PXE实现Ghost网络克隆
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>pxe</tag>
      </tags>
  </entry>
  <entry>
    <title>beego入门篇——中</title>
    <url>/dev-beego-start-1/</url>
    <content><![CDATA[前言本文中研究学习beego对于数据库的增删查改。beego的官方ORM DEMO不是很好，demo无法跑通，也无法自动创建表结构。因此，本文重新设计了学习流程。


环境准备1、安装ORMgo get github.com/astaxie/beego/orm
2、安装驱动
go get -u github.com/mattn/go-sqlite3go get -u github.com/go-sql-driver/mysqlgo get -u github.com/lib/pq

First Model本节中创建一个名为User的Model，只有三个字段，Id、Name和Age。运行代码，创建sqlite数据库和user表结构，并且向user表中插入一条数据。
1、在vkbeego/models目录中创建main.go文件，内容为：
package mainimport (    "fmt"    "github.com/astaxie/beego/orm"    _ "vkbeego/routers"    //_ "github.com/go-sql-driver/mysql"    _ "github.com/mattn/go-sqlite3")type User struct &#123;    Id      int    Name    string    Age     int&#125;func create_table()&#123;    // 数据库别名    name := "default"    // drop table 后再建表    force := true    // 打印执行过程    verbose := true    // 遇到错误立即返回    err := orm.RunSyncdb(name, force, verbose)    if err != nil &#123;        fmt.Println(err)    &#125;&#125;func init() &#123;    //orm.RegisterDriver("mysql", orm.DRMySQL)    //orm.RegisterDataBase("default", "mysql", "root:root@/orm_test?charset=utf8")    orm.RegisterDriver("sqlite3", orm.DRSqlite)    orm.RegisterDataBase("default", "sqlite3", "db.sqlite3")    orm.RegisterModel(new(User))    create_table()&#125;func main() &#123;    o := orm.NewOrm()    o.Using("default") // 默认使用 default，你可以指定为其他数据库    user := new(User)    user.Name = "Hankin"    fmt.Println(o.Insert(user))&#125;

2、运行代码在models目录，go run main.go，控制台输出创建表的信息。

3、查看执行效果查看vkbeego/models目录，发现出现了db.sqlite3文件。如果运行代码时右键run，那么db.sqlite3文件会出现在根目录下。使用navicat for sqlite，打开db.sqlite3数据库，可以看到创建的表和数据。
增加数据以上，已经实现了向数据库中添加数据，但是，Model的定义和注册、数据库的连接、插入数据的逻辑都在同一个文件中，非常混乱。因此需要对代码进行拆分，调整结构。
1、删除First Model删除models目录下的main.go和db.sqlite3。
2、在models目录下新建models.go，内容为：
package modelsimport (    "fmt"    "github.com/astaxie/beego/orm"    _ "github.com/mattn/go-sqlite3")type User struct &#123;    Id      int    Username    string    Password     string&#125;func create_table()&#123;    // 数据库别名    name := "default"    // drop table 后再建表    force := false    // 打印执行过程    verbose := true    // 遇到错误立即返回    err := orm.RunSyncdb(name, force, verbose)    if err != nil &#123;        fmt.Println(err)    &#125;&#125;func init() &#123;    orm.RegisterModel(new(User))    orm.RegisterDriver("sqlite3", orm.DRSqlite)    orm.RegisterDataBase("default", "sqlite3", "db.sqlite3")    create_table()&#125;

3、在routers/user.go中添加路由：
beego.Router("/user/add", &amp;user.AddController&#123;&#125;)

4、在controllers/user目录中新建文件add.go，内容为：
package userimport (    "fmt"    "github.com/astaxie/beego"    "github.com/astaxie/beego/orm"    "vkbeego/models")type AddController struct &#123;    beego.Controller&#125;func (c *AddController) Get() &#123;    var username = c.GetString("username")    fmt.Println(username)    c.Ctx.WriteString("Please add user by post request.")&#125;func (c *AddController) Post() &#123;    var username = c.GetString("username")    var password = c.GetString("password")    //fmt.Println(username)    //fmt.Println(password)    var o = orm.NewOrm()    o.Using("default")    var user = new(models.User)    user.Username = username    user.Password = password    o.Insert(user)    c.Ctx.WriteString("add user: " + username)&#125;

5、测试启动beego，使用Postman，发送Post请求到 http://localhost:8080/user/add ，请求参数包括username和password，成功写入参数到数据库。
查看数据1、在routers/user.go中添加路由：
beego.Router("/user/list", &amp;user.ListController&#123;&#125;)

2、在controllers/user目录中新建文件list.go，内容为：
package userimport (    "fmt"    "github.com/astaxie/beego"    "github.com/astaxie/beego/orm"    "vkbeego/models")type ListController struct &#123;    beego.Controller&#125;func (c *ListController) Get() &#123;    var o = orm.NewOrm()    o.Using("default")    var qs orm.QuerySeter    qs = o.QueryTable("user")    var users []*models.User    //num, err := qs.All(&amp;users)    num, err := qs.All(&amp;users,"Id", "Username")    fmt.Printf("Returned Rows Num: %d, %s \n", num, err)    fmt.Println(users[0].Username)    c.Data["users"] = users    c.TplName = "user/list.tpl"&#125;

3、在views/user目录中新建list.tpl文件，内容为：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;User List&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;User List&lt;/h2&gt;    &#123;&#123;range .users&#125;&#125;    &lt;p&gt;        ID为：&#123;&#123;.Id&#125;&#125;，用户名为：&#123;&#123;.Username&#125;&#125;    &lt;/p&gt;    &#123;&#123;end&#125;&#125;    &#123;&#123;range $index,$user := .users&#125;&#125;    &lt;p&gt;        Index为：&#123;&#123;$index&#125;&#125;，ID为：&#123;&#123;$user.Id&#125;&#125;，用户名为：&#123;&#123;$user.Username&#125;&#125;    &lt;/p&gt;    &#123;&#123;end&#125;&#125;&lt;/body&gt;&lt;/html&gt;

4、测试启动beego，使用Postman，发送Get请求到 http://localhost:8080/user/list ，即可看到用户列表。
修改数据1、在routers/user.go中添加路由：
beego.Router("/user/update", &amp;user.UpdateController&#123;&#125;)

2、在controllers/user目录中新建文件update.go，内容为：
package userimport (    "fmt"    "github.com/astaxie/beego"    "github.com/astaxie/beego/orm"    "vkbeego/models")type UpdateController struct &#123;    beego.Controller&#125;func (c *UpdateController) Get() &#123;    c.Ctx.WriteString("Please use post request.")&#125;func (c *UpdateController) Post() &#123;    //id,_ := c.GetInt("id")    username := c.GetString("username")    password := c.GetString("password")    new_password := c.GetString("new_password")    var o = orm.NewOrm()    o.Using("default")    exist := o.QueryTable("user").Filter("UserName", username).Exist()    if !exist&#123;        c.Ctx.WriteString("Username doesn't exist!")        return;    &#125;    var user models.User    o.QueryTable("user").Filter("Username",username).Filter("Password",password).One(&amp;user)    if o.Read(&amp;user) == nil &#123;        user.Password = new_password        if num, err := o.Update(&amp;user); err == nil &#123;            fmt.Println(num)        &#125;    &#125;else &#123;        c.Ctx.WriteString("Username or password is wrong!")        return;    &#125;    c.Ctx.WriteString("Password has been updated!")&#125;

3、测试启动beego，使用Postman，发送Post请求到 http://localhost:8080/user/update 进行密码的更新，请求参数包括username、password和new_password。
删除数据1、在routers/user.go中添加路由：
beego.Router("/user/del", &amp;user.DelController&#123;&#125;)

2、在controllers/user目录中新建文件del.go，内容为：
package userimport (    "fmt"    "github.com/astaxie/beego"    "github.com/astaxie/beego/orm")type DelController struct &#123;    beego.Controller&#125;func (c *DelController) Get() &#123;    c.Ctx.WriteString("Please use post request.")&#125;func (c *DelController) Post() &#123;    id,_ := c.GetInt("id")    var o = orm.NewOrm()    o.Using("default")    num,err := o.QueryTable("user").Filter("Id",id).Delete()    fmt.Printf("Returned Rows Num: %d, %s \n", num, err)    if num != 0 &#123;        c.Ctx.WriteString("User has been deleted!")    &#125;else&#123;        c.Ctx.WriteString("User Id doesn't exist! Can't delete!")    &#125;&#125;

3、测试启动beego，使用Postman，发送Post请求到 http://localhost:8080/user/del 进行删除数据，请求参数为id。
结构体和表上面的代码中，我们并没有指定结构体和数据库表的对应关系，那么它们是怎样关联起来的呢？参考beego框架之orm模块——mysql、BeegoOrm 映射自定义表名以及自定义字段，可知在beego的models模块里，会自动处理结构体和数据库表的对应关系，比如：
type User struct&#123;    // 默认情况对应数据库的表名为：user   MyName  string    // 默认情况对应数据库里user表字段为：my_name   MyAge   string    // 默认情况对应数据库里user表字段为：my_age&#125;orm.RegisterModel(new(User))

新的需求：结构体名为User对应数据库的表名为test_userMyName的成员对应数据库的字段名为MyNameMyAge的成员对应数据库的字段名为MyAge
那么该User的结构体又该如何定义呢？新需求的User结构体：
type User struct&#123;   MyName  string `orm:"column(MyName)"`   MyAge   string `orm:"column(MySex)"`&#125;orm.RegisterModel(new(User))// 自定义表名（系统自动调用）func (u *User) TableName() string &#123;    return "test_user"&#125;

后记至此，beego的增删查改操作基本都已经涉及，更高级的查询在使用时再去学习。
源码分享：v0.0.1
书签beego官网beego开发文档
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>beego</tag>
      </tags>
  </entry>
  <entry>
    <title>公交查询系统</title>
    <url>/dev-bus-search-system/</url>
    <content><![CDATA[交互流程1、用户进入首页，看到热门公交线路列表。2、输入关键词，可以搜索到相关公交线路。3、单击选择公交线路，进入线路方向选择页面。4、单击选择线路方向，进入百度地图。5、在初始化百度地图时，传入线路方向。


技术架构前端技术：jquery和art-template。后端技术：servlet、freemarker、jdbc和mysql。
详细设计前端响应式本系统适用于移动端，为了适应不同的屏幕，所以前端使用响应式布局。
html&#123;font-size:10px&#125;@media screen and (min-width:321px) and (max-width:375px)&#123;html&#123;font-size:11px&#125;&#125;@media screen and (min-width:376px) and (max-width:414px)&#123;html&#123;font-size:12px&#125;&#125;@media screen and (min-width:415px) and (max-width:639px)&#123;html&#123;font-size:15px&#125;&#125;@media screen and (min-width:640px) and (max-width:719px)&#123;html&#123;font-size:20px&#125;&#125;@media screen and (min-width:720px) and (max-width:749px)&#123;html&#123;font-size:22.5px&#125;&#125;@media screen and (min-width:750px) and (max-width:799px)&#123;html&#123;font-size:23.5px&#125;&#125;@media screen and (min-width:800px)&#123;html&#123;font-size:25px&#125;&#125;*&#123;    margin: 0;    padding: 0;&#125;

模板引擎搜索后，搜索结果要显示在页面上。这里，我们选用art-template模板引擎，把搜索请求得到的数据渲染到页面上。
&lt;script id="line-template" type="text/html"&gt;&lt;ul&gt;    &#123;&#123;each lineList as line&#125;&#125;    &lt;a href="$&#123;basePath&#125;/Direction?busName=&#123;&#123;line.busName&#125;&#125;"&gt;        &lt;li&gt;&#123;&#123;line.fullName&#125;&#125;(&#123;&#123;line.firstStop&#125;&#125;-&#123;&#123;line.lastStop&#125;&#125;)&lt;/li&gt;    &lt;/a&gt;    &#123;&#123;/each&#125;&#125;&lt;/ul&gt;&lt;/script&gt;

$('#search').click(function(event) &#123;    var basePath = $('#basePath').val();    var key = $('#key').val();    $.ajax(&#123;        url: basePath+'/Search',        type: 'POST',        dataType: 'json',        data: &#123;key: key&#125;,        success: function(data)&#123;            console.log(data);            var html = template('line-template', data);            $('.content').html(html);        &#125;,        error: function(xhr)&#123;            console.log(xhr);        &#125;    &#125;);&#125;);

百度地图最终结果，以百度地图的方式展示，需要用到百度地图api。
&lt;script type="text/javascript"&gt;    function  init() &#123;        window.busName = document.getElementById('busName').value;        window.firstStop = document.getElementById('firstStop').value;        // console.log(window.busName);        // console.log(window.firstStop);    &#125;    // 百度地图API功能    var map = new BMap.Map("l-map");            // 创建Map实例    map.centerAndZoom(new BMap.Point(125.434025,43.83246), 12);    var busline = new BMap.BusLineSearch(map,&#123;        renderOptions:&#123;map:map,panel:"r-result"&#125;,            onGetBusListComplete: function(result)&#123;                var directionArr = result.PA;                console.log(result);                if(result) &#123;                    var line = result.getBusListItem(0);                    var backLine = result.getBusListItem(1);                    console.log(line);                    var regx = /\([\u4E00-\u9FA5\uF900-\uFA2D]*-/;                    var str = line.name;                    console.log(str);                    var rs = str.match(regx)[0];                    rs = rs.slice(1,-1);                    console.log(rs);                    if(rs == window.firstStop)&#123;                        busline.getBusLine(line);                    &#125;else&#123;                        busline.getBusLine(backLine);                    &#125;                &#125;            &#125;    &#125;);    function busSearch()&#123;        busline.getBusList(window.busName);        //console.log(busline);    &#125;    init();    setTimeout(function()&#123;        busSearch();    &#125;,1500);&lt;/script&gt;

后端servlet鉴于本系统业务简单，所以使用servlet就够用了。
package com.voidking.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet("/Home")public class Home extends HttpServlet &#123;    public Home() &#123;        super();    &#125;    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        // TODO Auto-generated method stub        response.getWriter().append("Served at: ").append(request.getContextPath());    &#125;    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;        // TODO Auto-generated method stub        doGet(request, response);    &#125;&#125;

freemarker进入首页时，查询出的数据需要渲染到页面上。这里，我们要选择一个后端模板引擎。不习惯使用jsp，决定使用freemarker。
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    // TODO Auto-generated method stub    //freemarker配置      Configuration config=new Configuration();    ServletContext context = request.getServletContext();    config.setServletContextForTemplateLoading(context, "template");        //加载模板文件      Template template=config.getTemplate("home.ftl");         //创建数据模型      Map&lt;String,Object&gt; map=new HashMap&lt;String,Object&gt;();      map.put("basePath", request.getContextPath());    map.put("lineList", lineList);        response.setCharacterEncoding("utf8");    PrintWriter out = response.getWriter();    try &#123;        // 输出模板到页面上        template.process(map, out);        out.flush();        out.close();    &#125; catch (TemplateException e) &#123;        e.printStackTrace();    &#125;&#125;

json目前，前后端传输数据最常用的格式不外乎xml和json，本系统采用json作为数据传输格式。
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123;    // TODO Auto-generated method stub    response.setCharacterEncoding("utf8");    PrintWriter pw = response.getWriter();        String key = request.getParameter("key");    ArrayList&lt;Line&gt; lineList = lineService.searchLine(key);    if(lineList.size() &gt; 0)&#123;        jsonObj = new JSONObject("&#123;'code':'0','ext':'success'&#125;");        jsonObj.put("lineList", lineList);    &#125;else&#123;        jsonObj = new JSONObject("&#123;'code':'1','ext':'error'&#125;");    &#125;        pw.println(jsonObj);&#125;

jdbc数据库连接和查询，使用jdbc。
public ArrayList&lt;Line&gt; getLines() &#123;    // 结果集合    ArrayList&lt;Line&gt; result = new ArrayList&lt;Line&gt;();    // Step 1: Claim Connection and Statement    Connection conn = null;    Statement stmt = null;    try &#123;        // STEP 2: Register JDBC driver        Class.forName(JDBC_DRIVER);        // STEP 3: Open a connection        System.out.println("Connecting to database...");        conn = DriverManager.getConnection(DB_URL, USER, PASS);        // STEP 4: Execute a query        System.out.println("Creating statement...");        stmt = conn.createStatement();        String sql;        sql = "select * from line";        ResultSet rs = stmt.executeQuery(sql);        // STEP 5: Extract data from result set        while (rs.next()) &#123;            // Retrieve by column name            int id = rs.getInt("id");            String busName = rs.getString("bus_name");            String fullName = rs.getString("full_name");            String firstStop = rs.getString("first_stop");            String lastStop = rs.getString("last_stop");            Line line = new Line(id, busName, fullName, firstStop, lastStop);            result.add(line);        &#125;        // STEP 6: Clean-up environment        rs.close();        stmt.close();        conn.close();    &#125; catch (SQLException se) &#123;        // Handle errors for JDBC        se.printStackTrace();    &#125; catch (Exception e) &#123;        // Handle errors for Class.forName        e.printStackTrace();    &#125; finally &#123;        // finally block used to close resources        try &#123;            if (stmt != null)                stmt.close();        &#125; catch (SQLException se2) &#123;        &#125; // nothing we can do        try &#123;            if (conn != null)                conn.close();        &#125; catch (SQLException se) &#123;            se.printStackTrace();        &#125; // end finally try    &#125; // end try    System.out.println("Goodbye!");    return result;&#125;


数据库数据搜集长春公交有近200条公交线路，这里，我们从8684网站上搜集了常用的11条线路用来做测试。
表设计CREATE TABLE `line` (  `id` int(4) NOT NULL AUTO_INCREMENT,  `bus_name` varchar(32) NOT NULL,  `full_name` tinytext NOT NULL,  `first_stop` varchar(32) DEFAULT NULL,  `last_stop` varchar(32) DEFAULT NULL,  PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;

效果演示
源码分享https://github.com/voidking/bus-search
后记为什么不做实时公交查询？因为拿不到数据。百度地图没有提供实时公交API，也拿不到公交公司的数据。
书签Introducing JSONhttp://www.json.org/
JSON入门之二：org.json的基本用法http://blog.csdn.net/jediael_lu/article/details/25779087
JSON解析工具-org.json使用教程http://www.open-open.com/lib/view/open1381566882614.html
Amaze UI 模板中心http://tpl.amazeui.org/
（淘宝无限适配）手机端rem布局详解http://www.cnblogs.com/well-nice/p/5509589.html
长春公交查询http://changchun.8684.cn/
百度地图JavaScript 开源库http://lbsyun.baidu.com/index.php?title=open/library
百度地图API示例http://lbsyun.baidu.com/jsdemo.htm#a1_2
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS安装配置Jupyter</title>
    <url>/dev-centos-jupyter/</url>
    <content><![CDATA[前言如果在服务器上安装一个jupyter，那么就可以随时随地使用jupyter，很方便。
本文主要记录centos7上jupyter的安装方法，设置密码的方法，添加守护进程的方法，顺便给它设置个域名。


安装jupyter参考《Jupyter notebook》或者官网文档，完成jupyter的安装。
1、升级pippip install --upgrade pip
2、安装jupyterpip install jupyter
如果安装报错：
_scandir.c:14:20: fatal error: Python.h: No such file or directory #include &lt;Python.h&gt;                    ^compilation terminated.error: command 'gcc' failed with exit status 1

那么需要先安装python-develyum install python-devel
3、启动jupyter notebook
如果报错：socket.error: [Errno 99] Cannot assign requested address
那么在启动时加上参数：jupyter notebook --ip 0.0.0.0 --allow-root
4、开放端口firewall-cmd --zone=public --add-port=8888/tcp --permanentfirewall-cmd --reload
5、测试访问访问地址：http://ip:8888进入到jupyter登录页面，如下图：
设置密码在安装完成jupyter后，我们看到，登录页面给出了三种登录方式。方式一：复制启动时的token，粘贴到页面中，直接登录。方式二：参照the documentation on how to enable a password进行配置。方式三：复制启动时的token，粘贴到页面中，同时输入新密码，修改密码并登录。
这里，我们选择方式二，首先关闭jupyter，然后具体配置步骤如下：
1、生成jupyter配置文件jupyter notebook --generate-config该命令会生成文件/root/.jupyter/jupyter_notebook_config.py
2、设置密码jupyter notebook password提示两次输入密码，然后密码被hash化之后保存到jupyter_notebook_config.json中。
3、测试访问再次启动jupyter，使用密码访问成功。
4、禁止启动浏览器此时，启动jupyter时会默认启动本地浏览器，这个需要关闭。vim /root/.jupyter/jupyter_notebook_config.py，修改一行：
c.NotebookApp.open_browser = False

5、指定根目录在哪里执行jupyter notebook，哪里就是根目录，这里，我们也可以指定根目录。（1）创建根目录mkdir /opt/notebook
（2）vim /root/.jupyter/jupyter_notebook_config.py，修改一行：
c.NotebookApp.notebook_dir = u'/opt/notebook'

守护进程参考《CentOS安装配置Supervisor》，安装配置好supervisor。
1、新建配置文件jupyter.confvim /etc/supervisor/jupyter.conf写入内容如下：
[program:jupyter]command=/usr/bin/jupyter notebook --ip 0.0.0.0 --allow-rootuser=rootautostart=trueautostart=trueautorestart=truestdout_logfile=/var/log/supervisor/%(program_name)s.logstderr_logfile=/var/log/supervisor/%(program_name)s.log

2、重启supervisorsystemctl restart supervisord
设置域名假设nginx的安装目录为/usr/local/nginx/。1、创建vhost目录mkdir /usr/local/nginx/conf/vhost
2、修改nginx.conf，添加子配置目录
include /usr/local/nginx/conf/vhost/*.conf;

3、在vhost目录中新建jupyter.voidking.com.conf文件，内容为：
server &#123;    listen 80;    server_name jupyter.voidking.com;    charset utf-8;    location ~* /(api/kernels/[^/]+/(channels|iopub|shell|stdin)|terminals/websocket)/? &#123;        proxy_pass http://127.0.0.1:8888;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header Host $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        # WebSocket support        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection "upgrade";    &#125;&#125;

4、重启nginx/usr/local/nginx/sbin/nginx -s reload
5、本机测试（1）修改hosts文件，添加
127.0.0.1 jupyter.notebook.com
然后用curl命令测试：curl -L jupyter.notebook.com
6、设置域名解析在dnspod上，设置A记录，主机记录填入jupyter，记录值填入服务器IP，稍等几分钟。理论上，此时即可使用域名访问自己的jupyter。
然而，遇到了坑，神坑。。。浏览器访问 http://jupyter.voidking.com ，看到的是nginx的欢迎页面。excuse me? 再次使用curl命令测试，原来，拿到的确实是nginx的页面。那么问题来了？这次解析为什么没有生效？
使用systemctl重启nginx，欢迎页面；指定nginx配置文件重启nginx，欢迎页面；修改jupyter.voidking.com.conf，反向代理到8080的tomcat，欢迎页面；删除jupyter.voidking.com.conf文件，把内容写入nginx.conf，欢迎页面；把新添加内容放在nginx.conf的上部，作为第一个server配置，欢迎页面；换另外一个域名（jupyter.imsnail.com）设置解析，欢迎页面。。。
至此我严重怀疑，nginx有毛病！
卸载nginx上次安装nginx是编译安装，按照下列步骤卸载。
1、删除安装目录
rm -rf /usr/local/nginxrm -rf /var/log/nginxrm -rf /var/temp/nginxrm -rf /var/temp/run/nginx

2、删除开机自启动文件find / -name &quot;nginx*&quot;
rm -rf /usr/lib/systemd/system/nginx.service
systemctl daemon-reload
重新安装nginx接下来，参考nginx官方文档，安装nginx。
1、创建/etc/yum.repos.d/nginx.repo，内容如下：
[nginx]name=nginx repobaseurl=http://nginx.org/packages/centos/7/$basearch/gpgcheck=0enabled=1

2、安装nginxyum install nginx
3、设置开机启动systemctl enable nginx
4、杀死nginx进程，重新启动ps aux | grep nginx
kill -9 [nginx_id]
systemctl start nginx
5、查看运行状态systemctl status nginx -l发现配置文件位置为：/etc/nginx/nginx.conf
6、在/etc/nginx/conf.d/中创建jupyter.voidking.com.conf，内容同上。
7、重启nginxsystemctl restart nginx
接下来，见证奇迹的时刻！再次访问 http://jupyter.voidking.com ，依然是欢迎页面。。。
挣扎大哥，好歹给个报错也行啊！没有报错，访问就欢迎，这是要闹哪样！决定再次换成反向代理8080端口的tomcat，测试一下是不是仍然出现欢迎页面。
1、先创建/var/data/client_body_temp和/var/data/proxy_temp两个目录mkdir -p /var/data/client_body_tempmkdir -p /var/data/proxy_temp
2、然后修改jupyter.voidking.com.conf文件为：
server &#123;    listen 80;    server_name jupyter.voidking.com;    charset utf-8;    location /&#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        client_max_body_size       1024m;        client_body_buffer_size    128k;        client_body_temp_path      /var/data/client_body_temp;        proxy_connect_timeout      90;        proxy_send_timeout         90;        proxy_read_timeout         90;        proxy_buffer_size          4k;        proxy_buffers              4 32k;        proxy_busy_buffers_size    64k;        proxy_temp_file_write_size 64k;        proxy_temp_path            /var/data/proxy_temp;        proxy_pass http://127.0.0.1:8080;    &#125;&#125;

3、重启nginxsystemctl restart nginx
4、测试访问访问 http://jupyter.voidking.com/ ，成功访问到tomcat！看来上一个nginx确实有问题，因为重装nginx前，同样的配置，上一个nginx给我返回的是欢迎界面！
5、jupyter.voidking.com.conf修改成：
server &#123;    listen 80;    server_name jupyter.voidking.com;    charset utf-8;    location /&#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        client_max_body_size       1024m;        client_body_buffer_size    128k;        client_body_temp_path      /var/data/client_body_temp;        proxy_connect_timeout      90;        proxy_send_timeout         90;        proxy_read_timeout         90;        proxy_buffer_size          4k;        proxy_buffers              4 32k;        proxy_busy_buffers_size    64k;        proxy_temp_file_write_size 64k;        proxy_temp_path            /var/data/proxy_temp;        proxy_pass http://127.0.0.1:8888;    &#125;&#125;
重启nginx，测试访问，成功！但是，上面的配置可以访问jupyter页面，却无法连接kernel，也就是说无法执行python代码。
6、jupyter.voidking.com.conf修改为：
server &#123;    server_name jupyter.voidking.com;     listen 80;    location / &#123;        proxy_pass http://127.0.0.1:8888/;         proxy_set_header X-Real-IP $remote_addr;        proxy_set_header Host $host;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_http_version 1.1;        proxy_set_header Upgrade $http_upgrade;        proxy_set_header Connection "upgrade";        proxy_redirect off;    &#125;&#125;

重启nginx，测试访问，成功；执行代码，成功。
后记绕了好大一个圈。
首先是jupyter.voidking.com.conf的配置文件写错了，我也认为是配置文件写错了，于是各种修改配置文件，可无论我怎样修改配置文件，nginx只返回一个欢迎页面。
这就误导我认为nginx出了问题，于是开始了针对nginx的各种测试。修改配置也好，重启nginx也好，nginx只返回一个欢迎页面，于是我认定nginx除了问题。
重装nginx后，保持最开始的jupyter.voidking.com.conf配置，依然返回欢迎页面，但是修改配置文件，正常访问到tomcat，这就说明配置文件写错了。
综上，我认为这个锅是配置文件的。之所以最开始修改配置文件nginx毫无反应，孜孜不倦地返回欢迎页面，要么是存在僵尸进程，要么是浏览器存在缓存，干扰了测试，因为nginx坏的可能性太低。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>nginx</tag>
        <tag>jupyter</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7设置Nginx开机自启动</title>
    <url>/dev-centos-nginx-autostart/</url>
    <content><![CDATA[前言服务器每次重启，都需要手动启动一些服务，这不是一个程序员可以忍受的，难怪大家都喜欢写脚本。接下来三篇文章，分别记录一下nginx、tomcat和mysql的开机自启动配置。


systemdsystemd简介CentOS7已不再使用chkconfig管理启动项，而是使用systemd。关于systemd的衍生和发展，可以参见《CentOS7/RHEL7 systemd详解》和《CentOS7进程管理systemd详解》。简单介绍如下：
Linux系统从启动到提供服务的过程是这样，先是机器加电，然后通过MBR或者UEFI加载GRUB，再启动内核，内核启动服务，然后开始对外服务。
SysV init、UpStart、systemd主要是解决服务引导管理的问题。
SysV init是最早的解决方案，依靠划分不同的运行级别，启动不同的服务集，服务依靠脚本控制，并且是顺序执行的。在CentOS5中使用，配置文件为/etc/inittab。SysV init方案的优点是：原理简单，易于理解；依靠shell脚本控制，编写服务脚本门槛比较低。缺点是：服务顺序启动，启动过程比较慢；不能做到根据需要来启动服务，比如通常希望插入U盘的时候，再启动USB控制的服务，这样可以更好的节省系统资源。
为了解决系统服务的即插即用，UpStart应运而生，在CentOS6系统中，SysV init和UpStart是并存的，UpStart主要解决了服务的即插即用。服务顺序启动慢的问题，UpStart的解决办法是把相关的服务分组，组内的服务是顺序启动，组之间是并行启动。在CentOS6系统中，配置文件为/etc/inittab和/etc/init/*.conf。
但是随着移动互联网的到来，SysV init服务启动慢的问题显得越来越突出，许多移动设备都是基于Linux内核，比如安卓。移动设备启动比较频繁，每次启动都要等待服务顺序启动，显然难以接受，systemd就是为了解决这个问题诞生的。在CentOS7中使用，其配置文件为/usr/lib/systemd/system/ 和 /etc/systemd/system/ 中的文件。systemd的设计思路是：尽可能的快速启动服务；尽可能的减少系统资源占用。
systemd使用在CentOS7中，systemctl命令主要负责控制systemd系统和服务管理器。基本取代了service和chkconfig命令，虽然service和chkconfig命令依然保留，但是据说已经被阉割过。
参考《Centos7下的systemctl命令与service和chkconfig》，整理常用命令如下：

systemctl --version，查看版本。
whereis systemctl，查看位置。
systemctl list-unit-files，列出所有可用单元（服务）。
systemctl list-units，列出所有运行中的单元。
systemctl --failed，列出所有失败的单元。
systemctl list-unit-files | grep enable，查看自启动的软件。
systemctl is-enabled mysqld.service，查看某个单元是否开机启动。
systemctl status mysqld.service，查看某个单元的状态。
systemctl start mysqld.service，启动某个单元。
systemctl restart mysqld.service，重启某个单元。
systemctl stop mysqld.service，停止某个单元。
systemctl daemon-reload，修改了某个单元的配置文件后，重载配置文件。
systemctl reload mysqld.service，重载某个单元。
systemctl enable mysqld.service，设置开机自启动。
systemctl disable mysqld.service，关闭开机自启动。
systemctl kill mysqld，杀死单元。

nginxyum安装nginx参考《如何在CentOS 7上安装Nginx》，安装nginx，安装成功后使用systemctl命令设置自启动。
1、添加epel库yum install epel-release
2、安装nginxyum install nginx安装完成后，nginx的默认配置路径为/etc/nginx/。
3、启动nginxsystemctl start nginx
4、测试访问curl localhost
浏览器如果不能访问，就打开防火墙或者开端口。
# 关闭防火墙systemctl stop firewalld.service# 开放端口firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --reload

5、设置开机启动systemctl enable nginx
手动安装nginx参考《Centos7安装Nginx实战》，安装步骤如下：
1、安装依赖
yum install -y gcc-c++yum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-devel

2、下载nginx1.12.0并解压wget http://nginx.org/download/nginx-1.12.0.tar.gz
tar -xzvf nginx-1.12.0.tar.gz
cd nginx-1.12.0
3、创建目录
mkdir -p /var/temp/nginxmkdir -p /var/temp/run/nginxchmod a+wrx -R /var/temp

4、配置编译选项
./configure \--prefix=/usr/local/nginx \--pid-path=/var/temp/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi \--with-http_gzip_static_module

切记，pid-path不能设置为/var/run/nginx/nginx.pid。因为CentOS每次重启后，都会删除/var/run目录中的自建目录和文件，从而导致nginx自启动失败。
5、编译安装make &amp;&amp; make install
进入/usr/local/nginx查看文件是否存在conf、sbin、html文件夹，若存在则安装成功
6、测试启动/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf如果不指定-c，nginx在启动时默认加载conf/nginx.conf文件。
7、测试访问curl localhost
浏览器如果不能访问，就打开防火墙或者开端口。
# 关闭防火墙systemctl stop firewalld.service# 开放端口firewall-cmd --zone=public --add-port=80/tcp --permanentfirewall-cmd --reload

手动安装全部组件版nginx1、安装依赖
yum install -y gcc-c++yum install -y pcre pcre-develyum install -y zlib zlib-develyum install -y openssl openssl-develyum install -y libxml2 libxml2-develyum install -y libxslt libxslt-develyum install -y gd-develyum install -y perl-ExtUtils-Embedyum install -y GeoIP GeoIP-devel GeoIP-datayum install -y gperftoolsyum install -y libatomic_ops-devel

2、下载nginx1.12.0并解压wget http://nginx.org/download/nginx-1.12.0.tar.gz
tar -xzvf nginx-1.12.0.tar.gz
cd nginx-1.12.0
3、创建目录
mkdir -p /var/temp/nginxmkdir -p /var/temp/run/nginxchmod a+wrx -R /var/temp

4、下载ngx_http_upstream_check_module模块git clone https://github.com/yaoweibin/nginx_upstream_check_module
5、配置编译选项
./configure \--prefix=/usr/local/nginx \--pid-path=/var/temp/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi \--with-http_gzip_static_module \--with-select_module \--with-poll_module \--with-threads \--with-file-aio \--with-ipv6 \--with-http_ssl_module \--with-http_v2_module \--with-http_realip_module \--with-http_addition_module \--with-http_xslt_module \--with-http_xslt_module \--with-http_image_filter_module \--with-http_image_filter_module \--with-http_geoip_module \--with-http_geoip_module \--with-http_sub_module \--with-http_dav_module \--with-http_flv_module \--with-http_mp4_module \--with-http_gunzip_module \--with-http_auth_request_module \--with-http_random_index_module \--with-http_secure_link_module \--with-http_degradation_module \--with-http_slice_module \--with-http_stub_status_module \--with-http_perl_module \--with-mail \--with-mail_ssl_module \--with-stream \--with-stream \--with-stream_ssl_module \--with-google_perftools_module \--with-cpp_test_module \--with-pcre \--with-libatomic \--add-module=./nginx_upstream_check_module

6、编译安装make &amp;&amp; make install
设置开机启动手动安装的nginx，该怎样设置开机自启动？参照《Nginx+Center OS 7.2 开机启动设置(转载)》，步骤如下：
1、在系统服务目录里创建nginx.service文件vi /usr/lib/systemd/system/nginx.service
2、写入内容如下：
[Unit]Description=nginxAfter=network.target  [Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true  [Install]WantedBy=multi-user.target

[Unit]:服务的说明Description:描述服务After:描述服务类别[Service]服务运行参数的设置Type=forking是后台运行的形式ExecStart为服务的具体运行命令ExecReload为重启命令ExecStop为停止命令PrivateTmp=True表示给服务分配独立的临时空间注意：[Service]的启动、重启、停止命令全部要求使用绝对路径[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3
3、设置开机自启动systemctl enable nginx.service
4、查看nginx状态systemctl status nginx.service很奇怪，明明启动成功了，为什么显示Active: inactive (dead)？
5、杀死nginx重启nginxpkill -9 nginx
ps aux | grep nginx
systemctl start nginx
再次查看状态，变成了active，搞定。
6、重启服务器reboot
7、再次连接后，查看服务状态systemctl status nginx.service
看到nginx已经启动，至此，nginx自启动配置成功。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装部署ELK</title>
    <url>/dev-centos7-install-elk/</url>
    <content><![CDATA[ELK简介ELK是一个日志分析平台，它主要由Elasticsearch、Logstash和Kibana三个部分组成。Elasticsearch是一个开源的全文搜索和分析引擎，它可以实现数据的实时全文搜索，可以处理大规模日志数据，比如Nginx、Tomcat、系统日志等功能。Logstash负责日志收集和转发，支持日志过滤，支持普通log、自定义json格式的日志解析。Kibana通过接口调用Elasticsearch的数据，并进行前端数据可视化。


部署规划计划在三台CentOS7机器上部署ELK，其中一台机器作为ELK的服务节点，IP为192.168.56.101；另外两台作为客户节点，IP为192.168.56.102/103。其中服务节点部署Elasticsearch、Logstash和Kibana三个组件，客户节点部署Logstash。
服务节点部署环境准备默认root用户下操作，其他用户请自觉添加sudo。  
1、安装JDK，参考《全平台安装JDK》。
2、关闭防火墙。
systemctl stop firewalldsystemctl disable firewalld

或者设置防火墙规则：
firewall-cmd --add-port=9200/tcp --permanentfirewall-cmd --add-port=9300/tcp --permanentfirewall-cmd --add-port=5601/tcp --permanentfirewall-cmd --reload

3、添加ELK仓库
cat &lt;&lt;EOF | tee /etc/yum.repos.d/elasticsearch.repo[elasticsearch-7.x]name=Elasticsearch repository for 7.x packagesbaseurl=https://artifacts.elastic.co/packages/7.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-mdEOF

4、引入GPG keyrpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch
5、更新yum包
yum clean allyum makecache

Elasticsearch1、安装Elasticsearchyum install -y elasticsearch安装过程中会下载 https://artifacts.elastic.co/packages/7.x/yum/7.2.0/elasticsearch-7.2.0-x86_64.rpm ，但是，下载速度非常慢。这里建议通过浏览器下载，然后上传到服务节点上。上传完成后，执行安装：rpm -ivh elasticsearch-7.2.0-x86_64.rpm提示future versions of Elasticsearch will require Java 11; your Java version does not meet this requirement. 不过没关系，当前版本能用就行。
2、确认Elasticsearch的安装信息rpm -qi elasticsearch
3、启动Elasticsearch并设置开机启动
systemctl daemon-reloadsystemctl start elasticsearchsystemctl enable elasticsearch

4、查看Elasticsearch运行状态
systemctl status elasticsearchps -ef | grep elasticsearchnetstat -nlpt

5、尝试请求curl localhost:9200
6、设置允许其他机器访问当前只能响应本机的请求，想要其他机器也能访问的话，那么需要修改elasticsearch的配置。vim /etc/elasticsearch/elasticsearch.yml，如下修改：
# line 17, uncommentcluster.name: my-application# line 22, uncomment and changenode.name: master# line 55, uncomment and changenetwork.host: 0.0.0.0# line 59, uncommentttp.port: 9200# line 72, uncomment and changecluster.initial_master_nodes: ["master", "node-2"]

7、重启Elasticsearch
systemctl stop elasticsearchsystemctl start elasticsearch# 启动后稍等一会netstat -nlpt

如果可以看到:::9200，就可以通过外部浏览器访问Elasticsearch服务了，至此Elasticsearch安装配置完成。
Kibana1、安装Kibanayum install -y kibana同样的，如果下载速度缓慢，那么可以通过浏览器下载 https://artifacts.elastic.co/packages/7.x/yum/7.2.0/kibana-7.2.0-x86_64.rpm ，然后上传到服务节点，上传后执行安装：rpm -ivh kibana-7.2.0-x86_64.rpm
2、确认Kibana的安装信息rpm -qi kibana
3、启动Kibana并设置开机启动
systemctl start kibanasystemctl enable kibana

4、查看Kibana运行状态
systemctl status kibanaps -ef | grep kibananetstat -nlpt

5、测试访问curl localhost:5601 -L
6、设置允许其他机器访问vim /etc/kibana/kibana.yml，如下修改：
# line 2, uncomment and changeserver.port: 5601# line 7, uncomment and changeserver.host: "0.0.0.0"# line 28, uncommentelasticsearch.hosts: ["http://localhost:9200"]

7、重启Kibana
systemctl stop kibanasystemctl start kibana# 启动后稍等一会netstat -nlpt
如果可以看到0.0.0.0:5601，就可以通过外部浏览器访问Kibana服务了，至此Kibana安装配置完成。
Logstash1、安装Logstashyum install -y logstash也可以通过浏览器下载 https://artifacts.elastic.co/packages/7.x/yum/7.2.0/logstash-7.2.0.rpm ，然后上传到服务节点，上传后执行安装：rpm -ivh logstash-7.2.0.rpm
2、确认Logstash的安装信息rpm -qi logstash
3、启动Logstash
systemctl start logstash

4、查看Logstash运行状态
systemctl status logstashps -ef | grep logstashnetstat -nlpt

启动成功了，然后呢？怎么使用？
5、Logstash hello world
systemctl stop logstash/usr/share/logstash/bin/logstash -e 'input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;'
输入启动命令后，耐心等待服务启动，直到出现Successfully started Logstash API endpoint。输入“hello world”回车，即可打印出输出。logstash通过管道来处理数据，标准的管道包含input、filter和output。以上命令，指定了一个管道的参数，没有filter，input是控制台标准输入，output是控制台标准输出。
6、管道配置写入文件新建配置文件std.conf，内容为：
input &#123;     stdin &#123; &#125; &#125; output &#123;     stdout &#123;&#125; &#125;

7、测试配置文件并启动
/usr/share/logstash/bin/logstash -f ~/std.conf --config.test_and_exit/usr/share/logstash/bin/logstash -f ~/std.conf

8、从文件中读取信息（1）新建/usr/local/test.log文件，内容为：
hello logstash!

（2）新建test.conf，内容为：
input &#123;    file &#123;        path =&gt; ["/usr/local/test.log"]        sincedb_path =&gt; "/dev/null"        start_position =&gt; "beginning"    &#125;&#125;filter &#123;&#125;output &#123;    stdout &#123;        codec =&gt; rubydebug    &#125;&#125;

（3）启动Logstash/usr/share/logstash/bin/logstash -f ~/test.conf
9、写入信息到文件（1）修改test.conf为：
input &#123;    file &#123;        path =&gt; ["/usr/local/test.log"]        sincedb_path =&gt; "/dev/null"        start_position =&gt; "beginning"    &#125;&#125;filter &#123;&#125;output &#123;    file &#123;        path =&gt; ["/usr/local/test.log.out"]    &#125;&#125;

（2）启动Logstash/usr/share/logstash/bin/logstash -f ~/test.conf启动后，/usr/local/目录下多了test.log.out文件。
数据传递Logstash收集到了数据，怎样传递给Elasticsearch显示？怎样传递给Kibana显示？1、修改test.conf为：
input &#123;    file &#123;        path =&gt; ["/usr/local/test.log"]        sincedb_path =&gt; "/dev/null"        start_position =&gt; "beginning"    &#125;&#125;filter &#123;&#125;output &#123;    elasticsearch &#123;        hosts =&gt; ["http://localhost:9200"]    &#125;&#125;

2、启动Logstash/usr/share/logstash/bin/logstash -f ~/test.conf
3、查看索引浏览器访问 http://192.168.56.101:9200/_cat/indices?v其中有个索引是logstash的，这就是我们想要查看的数据索引。
4、查看数据浏览器访问 http://192.168.56.101:9200/logstash-2019.07.24-000001/_search看到了hello logstash!，说明数据已经成功传递到了Elasticsearch。链接后添加?pretty参数，可以进行格式化显示。
5、Kibana添加indices浏览器访问Kibana http://192.168.56.101:5601点击页面上的Logs，然后填写indices相关信息。最后点击Update Source，即可在页面上看到Logstash传递的信息。
6、修改test.log修改test.log为：
hello logstash!the log has been updated.
再次查看Kibana的日志显示，可以看到更新。
客户节点部署环境准备默认root用户下操作，其他用户请自觉添加sudo。
1、安装JDK。
2、关闭防火墙。
systemctl stop firewalldsystemctl disable firewalld

3、添加ELK仓库
cat &lt;&lt;EOF | tee /etc/yum.repos.d/elasticsearch.repo[elasticsearch-7.x]name=Elasticsearch repository for 7.x packagesbaseurl=https://artifacts.elastic.co/packages/7.x/yumgpgcheck=1gpgkey=https://artifacts.elastic.co/GPG-KEY-elasticsearchenabled=1autorefresh=1type=rpm-mdEOF

4、引入GPG keyrpm --import https://artifacts.elastic.co/GPG-KEY-elasticsearch
5、更新yum包
yum clean allyum makecache

Logstash1、安装Logstashyum install -y logstash也可以通过浏览器下载 https://artifacts.elastic.co/packages/7.x/yum/7.2.0/logstash-7.2.0.rpm ，然后上传到服务节点，上传后执行安装：rpm -ivh logstash-7.2.0.rpm
2、确认Logstash的安装信息rpm -qi logstash
3、创建测试文件新建配置文件test.conf，内容为：
input &#123;    file &#123;        path =&gt; ["/usr/local/test.log"]        sincedb_path =&gt; "/dev/null"        start_position =&gt; "beginning"    &#125;&#125;filter &#123;&#125;output &#123;    elasticsearch &#123;        hosts =&gt; ["http://192.168.56.101:9200"]    &#125;&#125;

新建/usr/local/test.log，内容为：
this is a log recorded by 102

4、启动logstash
/usr/share/logstash/bin/logstash -f ~/test.conf

5、在Kibana查看日志刷新Kibana，即可看到客户节点的日志。
后记以上，完成了ELK的基本安装配置，实现了一个最简单的架构。Logstash收集数据，传递给Elasticsearch，然后Kibana显示Elasticsearch中的数据。更多关于ELK的内容，后续会继续学习。
书签How to Install ELK Stack on CentOS 7
Logstash 实用介绍
Getting Started with Logstash
开源日志实时分析平台ELK
logstash的各个场景应用（配置文件均已实践过）
Logstash介绍
在 CentOS7 安装 ELK
ELK-7.0安装部署收集展示
ELK部署安装以及配置
Learn About the Elastic Stack
Elastic 中文社区
Elastic中文社区运维监控实战之架构篇
从零开始搭建ELK+GPE监控预警系统
《ELK Stack 中文指南》
ELK不权威指南
零代码如何打造自己的实时监控预警系统
Docker下ELK三部曲之一：极速体验
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>centos</tag>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS7安装部署Jenkins</title>
    <url>/dev-centos7-install-jenkins/</url>
    <content><![CDATA[Jenkins简介Jenkins是一个开源软件项目，是基于Java开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。
本文研究一下在CentOS7（IP为192.168.56.104）上安装部署Jenkins，可以管理部署GitLab中的项目（IP为192.168.56.103）到Web服务器（IP为192.168.56.105）。


环境准备1、在Jenkins服务器编辑hostsvim /etc/hosts，添加：
192.168.56.103  gitlab.voidking.com

2、创建密钥ssh-keygen/root/.ssh目录下生成了私钥id_rsa和公钥id_rsa.pub。
3、添加公钥到gitlab浏览器访问 https://gitlab.voidking.com/profile/keys ，把公钥粘贴进去。
4、安装gityum install git
安装JenkinsJenkins依赖Java，因此首先参考《全平台安装JDK》，安装配置好JDK，然后如下步骤安装Jenkins。
1、添加jenkins源：
wget -O /etc/yum.repos.d/jenkins.repo http://jenkins-ci.org/redhat/jenkins.repo rpm --import http://pkg.jenkins-ci.org/redhat/jenkins-ci.org.key

2、安装jenkins：
yum install jenkins

3、启动jenkins：
service jenkins start

Jenkins安装目录：/usr/lib/jenkins/。Jenkins配置文件：/etc/sysconfig/jenkins。
4、防火墙设置
firewall-cmd --add-port=8080/tcp --permanentsystemctl reload firewalld

5、基本设置浏览器访问 http://192.168.56.104:8080 ，即可看到jenkins页面。cat /var/lib/jenkins/secrets/initialAdminPassword查看管理员密码，填入页面，继续；安装推荐的插件；创建第一个管理员；设置Jenkins URL；开始使用Jenkins。
使用Jenkins1、新建项目点击新建Item或者创建一个新任务，新建项目。选择Freestyle project，输入名称，确定。
2、设置源码管理点击源码管理Tab页，选择Git，Repository URL填入git@gitlab.voidking.com:root/voidking.git。此时提示没有权限访问，Credentials后面点击添加，Jenkins。Domain全局凭据（unrestricted），类型选择SSH Username with private key，范围选择全局，Username输入root，然后把id_rsa中的内容粘贴进去，添加。然后在Credentials一栏root，页面上的警告就消失了。最后保存即可。
3、构建项目在voidking项目页面，点击立即构建，即可完成项目构建。点击控制台输出，可以看到整个构建过程。从构建过程可以看出，整个过程只拉取了一次代码，其他啥也没做，代码存放在/var/lib/jenkins/workspace/voidking目录。
构建JavaWeb项目构建JavaWeb项目的基本原理：Jenkins从GitLab拉取项目代码，然后在workspace的项目目录中执行mvn install命令生成war包，最后拷贝war包到Web服务器的webapps目录中并启动tomcat。
GitLab项目准备1、使用本地环境（JDK+Tomcat+Maven），生成JavaWeb项目的war包并放入Tomcat进行测试，本文中使用pandawork-start项目。
2、上传Maven JavaWeb项目的源码到gitlab。如果gitlab不允许git push -f，那么在gitlab中点击项目名，Settings，Repository，修改Protected Branches的配置即可。
Web服务器准备1、安装JDK，参考参考《全平台安装JDK》。
2、安装Tomcat，参考CentOS7设置tomcat开机自启动。
3、安装Mysql，参考CentOS7设置mysql开机自启动。
4、配置免密登录，使Jenkins服务器可以免密访问Web服务器，使Jenkins可以免密访问Web服务器。ssh-copy-id -i .ssh/id_rsa.pub -p 22 root@192.168.56.105
Jenkins服务器配置Jenkin服务器配置主要参考Jenkins安装及自动部署Maven项目。
1、安装配置Maven，参考centos7 安装maven。
2、登录Jenkins，系统管理，插件管理，可选插件，下载Maven Integration。
3、返回工作台，系统管理，全局工具配置。配置JDK，配置Maven，保存。
4、Jenkins工作台，新建项目，构建一个Maven项目。源码管理配置gitlab中的Java Web项目。
5、Build选项卡，Goals and Options，输入clean install -Dmaven.test.skip=true。
6、Post Steps选项卡，Add post-build step，执行shell，填入拷贝war包和启动tomcat命令，保存。
scp /var/lib/jenkins/workspace/pandawork-start/target/pandawork-start.war root@192.168.56.105:/opt/apache-tomcat-8.5.43/webapps/ssh root@192.168.56.105 "nohup sh /opt/apache-tomcat-8.5.43/bin/startup.sh &amp;"

7、Jenkins工作台，点击Web项目，立即构建，控制台输出。由上图可以看出，Maven项目构建成功，但是在执行远程拷贝脚本的时候出错，说明之前添加的免密登录没有生效。
8、给Jenkins用户添加免密登录。（1）添加登录权限，vim /etc/passwd，修改jenkins用户权限
#jenkins:x:997:995:Jenkins Automation Server:/var/lib/jenkins:/bin/falsejenkins:x:997:995:Jenkins Automation Server:/var/lib/jenkins:/bin/bash

（2）切换到jenkins用户，su jenkins
（3）生成密钥，ssh-keygen
（4）密钥添加到Web服务器
cd /var/lib/jenkinsssh-copy-id -i .ssh/id_rsa.pub -p 22 root@192.168.56.105

（5）再次构建项目，执行成功！
8、测试服务浏览器访问 http://192.168.56.105:8080/pandawork-start/ ，即可看到hello world。
job并发构建需求：已知有10个Java项目，名称分别为test1、test2、…、test10，现在想要使用jenkins对这10个项目进行构建。问题来了，如果使用同一个job，那么每个项目构建时都需要等待前一个项目构建完成，效率很低。如果使用10个job，那么这10个job的配置基本相同，以后如果有修改，维护成本很高。这种情况下该怎么处理？使用job并发构建，参考jenkins 多用户同时触发构建。
1、登录Jenkins，系统管理，插件管理，可选插件，在过滤中输入build name出现了 Build Name and Description Setter 插件，安装它。安装完成重启jenkins。
2、创建一个自由风格的job，名为test
（1）参数化构建过程，添加字符参数，输入projectName（2）勾选 在必要的时候并发构建（3）增加构建步骤，Update build name，Use macro，Build name macro template，输入#${BUILD_NUMBER}_${projectName}（4）勾选 Insert macro first（5）增加构建步骤，执行shell，输入
pwdfor i in `seq 0 120`do	echo "Project Name: "$&#123;projectName&#125;    sleep 1sdone

（6）两次点击Build with Parameters，分别输入项目名test1和test2进行构建。可以看到，Build History里的构建名称是两个不同的名称。
3、清除workspace并发构建后，workspace下会生成test和test@2两个目录，如果并发量高了还会更多，此时需要清除workspace。在job配置页面，增加构建后操作步骤，选择 Delete workspace when build is done。
添加slave节点1、新建节点系统管理，新建节点，输入节点名称，选中固定节点，确定。
2、完善节点细节输入描述（主机名），执行器数量（一般和节点CPU核数相同，此处填4），远程工作目录（/home/jenkins），标签（用于构建哪些项目，此处填project1），用法（只允许运行绑定到这台机器的Job），启动方式（Launch agent agents via SSH），主机（节点IP），Host Key Verification Strategy（Non verifying Verification Strategy），可用性（尽量保持代理在线）
3、证书配置以上配置还漏了一个Credentials，这个需要详细说一下。（1）在master节点使用root用户生成密钥对，ssh-keygen（2）在slave节点添加master节点的公钥，vim /root/.ssh/authorized_keys，把master节点的id_rsa.pub内容添加进去。（3）在jenkins节点配置页面，上图红框的地方，添加，Jenkins。（4）添加凭据，Domain（全局凭据），类型（SSH Username with private key），范围（全局），描述（root private key），Username（root），Private Key选中Enter directly，Key（粘贴master节点的id_rsa），添加。
4、启动代理节点列表，点击节点名称，启动代理，建立master节点与slave节点的连接。启动日志显示：
&lt;===[JENKINS REMOTING CAPACITY]===&gt;channel startedRemoting version: 3.36This is a Unix agentEvacuated stdoutAgent successfully connected and online...
表示连接成功，成功加入了一个jenkins slave节点。
指定slave节点构建方法一1、在配置job时，勾选限制项目的运行节点，标签表达式输入“project1”（和slave节点的标签对应）。
2、构建项目，因为slave的执行器数量设置为4，所以当同时构建的数量在4以内时，会使用slave1；当同时构建的数量超过4个时，会使用slave2。
方法二1、登录Jenkins，系统管理，插件管理，可选插件，在过滤中输入node找到 Node and Label parameter plugin 插件，安装它。
2、参数化构建过程，添加参数，Node。按住ctrl选择使用的机器，并且选中Allow multi node selection for concurrent builds。
使用上次的参数构建如果一个job的参数很多，那么每次构建都要输入很多参数，很麻烦，此时可以使用Rebuilder插件。1、登录Jenkins，系统管理，插件管理，可选插件，在过滤中输入rebuilder找到 Rebuilder 插件（This plugin is for rebuilding a job using the same parameters.），安装它。
2、构建项目页面，可以看到Rebuild Last选项，点击它使用上次参数再次构建。也可以进入某次Build History，可以看到Rebuild选项，点击它，即可使用该次构建的参数再次构建。
任务超时自动停止如果一个构建任务，因为网络或者其他原因阻塞了，卡住了10分钟以上，这时我们希望这个任务能够自动停止。1、登录Jenkins，系统管理，插件管理，可选插件，在过滤中输入timeout。找到 Build Timeout 插件（This plugin allows builds to be automatically terminated after the specified amount of time has elapsed.），安装它。
2、进入需要配置的job，配置，构建环境，勾选 Abort the build if it’s stuck。

Time-out strategy 保持默认 Absolute 
Timeout minutes 调整为 10 
Time-out variable 不用填
Time-out actions，Add action，Abort the build

Jenkins API1、创建job
curl -X POST JENKINS_URL/createItem \  --user USER:TOKEN \  --data-urlencode json='&#123;"name":"new_job","mode":"copy","from":"old_job"&#125;'

2、构建
curl -X POST JENKINS_URL/job/JOB_NAME/buildWithParameters \  --user USER:TOKEN \  --data-urlencode json='&#123;"parameter": [&#123;"name":"id", "value":"123"&#125;, &#123;"name":"verbosity", "value":"high"&#125;]&#125;'

3、查看buildnum
curl -X POST JENKINS_URL/job/JOB_NAME/lastBuild/buildNumber

如果使用postman测试的话，--user USER:TOKEN 对应 Authorization 中的 Basic Auth，Username和Password。--data-urlencode json 对应 Body 中的 x-www-form-urlencoded。
更多内容参考：

Remote access API
Python Jenkins documentation
jjb/python-jenkins
使用API对Job进行操作
build now option is not coming for job in jenkins
Jenkins api too slow

后记至此，Jenkins安装配置完成，使用Jenkins配置部署了一个Java Web项目。本文中用到了三台服务器，分别是GitLab服务器、Web服务器和Jenkins服务器。Jenkins从GitLab拉取项目代码，然后在workspace的项目目录中执行mvn install命令生成war包，最后拷贝war包到Web服务器的webapps目录中并启动tomcat。
书签CentOS 安装 Jenkins
Jenkins详细安装与构建部署使用教程
持续集成Jenkins+Gitlab
基于gitlab和jenkins的自动化部署实例
Jenkins常用插件之Deploy Plugin
jenkins plugins
Least Load
使用Jenkins进行持续集成
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>tomcat</tag>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>centos</tag>
        <tag>mysql</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>CKA和CKAD备考</title>
    <url>/dev-cka-ckad-prepare/</url>
    <content><![CDATA[Flag《K8S入门篇》一文中，定下了目标：拿到CKA和CKAD证书。转眼过去了大半年，但是一直没有付诸行动。今天，趁生日，立下flag：2020年5月1前考下CKA，2020年6月1日前考下CKAD。
CKA和CKAD是啥？
The Certified Kubernetes Administrator (CKA) program was created by the Cloud Native Computing Foundation (CNCF), in collaboration with The Linux Foundation, to help develop the Kubernetes ecosystem. 


The Certified Kubernetes Application Developer (CKAD) program has been developed by the Cloud Native Computing Foundation (CNCF), in collaboration with The Linux Foundation, to help expand the Kubernetes ecosystem through standardized training and certification. 

简而言之，CKA/CKAD是CNCF和Linux基金会联合推出的两个K8S考试认证。委托给PSI来进行监督考试。其中，CKA侧重于K8S管理，CKAD侧重于K8S开发。通过了这两个考试中的任意一个，就能证明你在K8S领域是一个人才；两个考试都通过了，那么涨薪还会远吗？
想要拿到CKA和CKAD证书，需要哪些准备工作？本文就来梳理一下。主要参考：

CKA及CKAD认证考试经验分享
CKA认证获取历程
How to prepare and pass CKA exam
How to prepare for CKA and CKAD exam ?
Mumshad Mannambeth Courses



注意事项报名网址：Certified Kubernetes Administrator (CKA) Program和Certified Kubernetes Application Developer (CKAD) Program。报名时使用折扣码DEVOPS15可以获得15%的折扣。
报名时需要支持海外支付的信用卡（VISA或者MasterCard）。
稳定的科学上网工具。
在约定的考试时间登录考试系统。
硬件检测：使用Chrome浏览器访问CompatibilityCheck，选择 ”Linux Foundation” as the Exam Sponsor and “CKA” as the Exam。
按照考官要求打开摄像头和麦克风，并且共享桌面。
身份检测：考官查看考生证件，比如护照（身份证不行，需要有照片和Latin字母写的全名）。
环境检测：考官通过摄像头检查房间，要求房间只有考生一个人，桌子只能放电脑，没有其他东西。
软件检测：考官要求打开任务管理器，确认除浏览器之外的没有其他任务，确认无误后考试开始。
要求Chrome浏览器当前只能有一个tab页（就是考试系统），考试过程中可以再打开一个tap页用于访问Kubernetes文档，就是说考试全程最多两个tab页。
CKA一共180分钟，25道题；CKAD一共120分钟，20道题。
考试的网页一半是试题，一半是GateOne的终端界面。
考试中不能喝水、吃东西，可以申请休息。
考试结束后，36个小时之内，CNCF就会通过邮件告诉考生成绩。CKA分数大于74%则通过考试，CKAD分数大于66%则为通过考试，并且附件包含证书。如果考试不通过，考生账号上就会有一次一年内Free Retake的机会。
更多关于考试及考试环境的注意事项，可参见官方的Exam Tips、Candidate Handbook、CNCF FAQ。
报名和约考1、支付完成后，跳转到Certification Status页面。
2、按照提示，Check System Requirements，验证成功后以后也可以再次验证。
3、点击 Schedule Exam，跳转到考试时间安排页面，选择一个考试时间。
4、点击 Get Candidate Handbook，获取考试手册。
5、点击 Verify Name，确认姓名，以后会出现在证书上。
6、点击 Important Tips，获取帮助提示。
7、点击右侧 Schedule Exam，即可看到考试信息，包括考试的时间、倒计时、确认码、考生ID等。
以上，报名和约考完成。
技能GetDocker浙江大学SEL实验室编写的《Docker容器与容器云》Docker Documentation菜鸟教程之Docker教程Learn Docker &amp; Containers using Interactive Browser
K8S《Kubernetes权威指南：从Docker到Kubernetes实践全接触 第4版》Kubernetes Documentationkubernetes中文社区华为云-Cloud Native Lives阿里云-K8s 资源全汇总 | K8s 大咖带你 31 堂课从零入门 K8s阿里云-云原生技术公开课阿里云-云原生技术公开课（备用地址）Certified Kubernetes Administrator (CKA) with Practice TestsLabs - Certified Kubernetes Administrator with Practice TestsKubernetes Certified Application Developer (CKAD) with TestsLabs - Certified Kubernetes Application Developercka&amp;cakd考纲-curriculumStudying for the Certified Kubernetes Administrator ExamK8S TasksLearn Kubernetes using Interactive Browser-Based ScenariosPlay with KubernetesCKA CKAD Simulator
k8s-tool备考的过程中，完善自己的k8s-tool，考试的时候可以使用。
后记5月19日更新三个月忙碌的早晚，无休的周末，终于在今天早上，收到了CKAD的证书。加上4月份拿到的CKA证书，目标达成！CKA考了90%（74%通过），CKAD考了89%（66%通过）。
考试心得CKA和CKAD有什么差别？1、考试内容有重叠，但是也有各自独立的内容。比如CKA会考etcd和k8s部署相关的内容，CKAD不会涉及。CKAD会有cronjob和ha的内容，CKA不会涉及。2、CKAD比CKA难度更大一些。考过了CKA，本以为可以轻松拿下CKAD，结果考试时发现CKAD的题目更复杂一些，花费时间更长。后来想想也合理，毕竟CKA需要74分通过，而CKAD只需要66分就可以通过。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
        <tag>cka</tag>
        <tag>ckad</tag>
      </tags>
  </entry>
  <entry>
    <title>人脉管理系统功能需求</title>
    <url>/dev-connection-management-system-feature-request-1/</url>
    <content><![CDATA[前言本项目来自第六届中国大学生服务外包创新创业大赛。
项目说明问题说明与某人的联系程度，以及亲密度不是十分容易统计，通过人脉管理系统可以清除了解和某人的亲密度。
用户期望智翔集团期望：对人脉的特征进行匹配性的关怀，极大提升关怀效果,极大降低为实施关怀所付出的时间精力成本，从而维护、推动人脉关系的发展。
该平台规划为开放式平台，平台支持个人对人脉进行排程，互动建议，谈资话题搜集，短信群发，人脉微博监控等等。


任务要求参赛者，设计一套基于互联网，以人脉管理为核心的解决方案，该解决方案包括以下要求：
策划方案项目需求分析。项目计划。原型图设计。未来的市场推广方案及计划。
业务模型用户的登陆，退出与注册。
用户对自己的人脉进行特点分析，并进行针对性的人脉互动，以达到人脉关系促进的作用。
为用户对人脉进行排程，互动建议，谈资话题搜集，短信群发，人脉微博监控用户与其他用户进行分享或互动，收集用户对产品使用的各种心得、意见、想法等。
为用户提供名片识别、名片设计、名片交换、云名片管理、备份、同步、分享以及人脉云端管理等等功能；具有优越的用户体验，便捷的手势操作，给手机用户以全新、愉悦的使用体验。
为用户提供相遇信息，他们可交换照片并迅速创建一份基本档案。之后再点击某人照片，便会显示两人的邂逅历史，以及见面时的时间、地点、通讯录、话题、照片甚至当时的笔记等。
技术方案及产品原型基于主流浏览器 PC 端、手机端。
提供整体技术架构解决方案，方案突出大规模访问及海量数据存储的系统规划解决方案。
实现该产品的原型系统。
实施方案请提供该解决方案的实施计划。
提交内容需求文档。原型设计。项目源代码。
功能需求初稿好友好友列表1、好友列表类似于手机的通讯录，在姓名后面紧跟着亲密度（条形显示），可以通过右侧的亲密度迅速定位。2、可以选择排序方式，比如按亲密度升序，按亲密度降序。3、可以选择显示方式，使用此应用的好友或者未使用此应用的好友。4、对于未使用此应用的好友，可以通过发短信的方式邀请使用。5、点开一个好友，可以看到好友的基本信息、名片（如果已经获得）、时间轴、二度人脉等。也可以选择通话、短信、发消息。6、可以特别关心某好友。
即时通讯（聊天）和好友聊天的时候，也许会出现没有话题聊的场面。这时候，选择聊天界面的聊天帮助，选择随机推荐话题、分类查看话题、根据聊天记录智能推荐话题，出现相关话题。
时间轴点开时间轴，可以看到显示两人的邂逅历史，以及见面时的时间、地点、通讯录、话题、照片甚至当时的笔记等。
查看二度人脉点开二度人脉，可以看到好友的好友的信息（如果对方设置允许）。可以选择发送好友请求，发送名片请求。
短信群发，名片群发选择一些好友，群发短信，群发名片。可以选择定时发送。（和手机自带的短信功能也没啥差别。。。）
向好友推荐好友自己拥有好友A和B，但是A和B不是好友，这时可以点击好友推荐，选择通过个人信息或者名片，然后选择A和B。A的个人信息或者名片就发送给B，B的个人信息或者名片就发送给A。同样的方式，可以选择更多的好友。
搜索好友1、条件搜索。选择昵称、性别、行业、职位、范围（所有人或者圈子内的人）等，搜索到符合条件的用户，进行好友请求。
2、精确搜索。输入对方账号进行搜索。
偶遇设置偶遇的条件，比如距离、年龄、职业等，当出现符合条件的用户时，会提醒用户是否添加好友，是否去见面。（偶遇排除好友）
好友名片管理1、包含在应用内不是好友的名片2、名片的添加、删除、搜索
亲密度统计1、使用此应用的人和未使用此应用的人分开统计。2、对于使用者，根据通话记录、短信、本应用内联系信息、微博来统计。3、对于未使用者，根据通话记录、短信来统计。4、根据联系次数、联系时间、联系方式绘制直观的图表。比如最近一年和某个好友的电话联系次数走势图。
个人基本信息昵称，等级，积分，性别，职业，签名，生日，手机，邮箱等。
个人名片管理系统提供一些名片模板，用户通过选择这些模板，填写相应信息，生成名片。名片可以通过扫二维码的方式添加，也可以通过发送名片的方式发送给好友或二度人脉。
空间（个人圈子）1、个人有自己的谈资话题，即好友的谈论。2、发起活动，好友可以看到。
基本设置1、是否开启好友生日提醒功能2、是否开启联系提醒。3、是否开启附近好友提醒。4、是否开启偶遇。
隐私设置1、是否允许好友发送自己的名片给二度人脉2、是否允许好友发送自己的名片给陌生人3、是否接收二度人脉的名片4、是否接收陌生人的名片5、是否可以通过二度人脉看到自己的信息6、是否随时定位自己的位置。7、是否允许被陌生人搜索。8、是否允许系统查看聊天记录。
同步管理1、同步名片到云端，同步名片到本地。2、同步通讯录到云端，同步通讯录到本地。3、同步短信到云端，同步短信到本地。
提醒1、联系提醒一周、一月、一年没有联系过的好友，设置阶段性提醒。
2、附近好友提醒如果和某好友距离在100米之内，就发出提醒，询问是否去见面。
日程1、生日好友的生日会自动同步到自己的日程表中，生日前一天或者当天会有闹钟提醒。2、约会点开日程表，输入约会信息，前一天或者当天会有闹钟提醒。3、圈子聚会圈子管理员发起了活动，如果用户确认参加，聚会的时间地点信息会出现在日程中，前一天或者当天会有闹钟提醒。
话题选择感兴趣的话题分类，积累聊天话题，避免没有话题聊的尴尬。此功能可以和即时通讯（聊天）功能结合。
人脉圈管理1、每个用户都有权利创建人脉圈，创建人脉圈之后，该用户自动成为该人脉圈的管理员，他可以邀请自己的好友加入自己的人脉圈，任命其他的人为管理员。
2、管理员可以设置人脉圈的主题，如亲友圈，朋友圈，同事圈等。
3、管理员可以设置人脉圈的管理制度，可以是“独裁制”，“民主选举制”,“独裁制”暨管理始终不变，“民主选举制”暨管理员定期选举产生。
4、管理员可以发起活动，可以是线下的聚会等活动，聚会现场可以二维码签到；也可以是线上的游戏或讨论。我们鼓励管理员记录人脉圈中活动情况，如：聚会的照片，参与的人员，发生的主要事件，从而生成人脉圈的历史。
5、管理员对人脉圈的隐私信息有设置和修改的权力，如：人脉圈是否公开等。
谈资话题1、每个人脉圈都有各自的谈资话题模块，人脉圈中的所有的都可以在其中发表各自关于该人脉圈的话题，其他用户可以点赞，评论，@。2、管理员对于人脉圈谈资话题有管理权利。3、人脉圈中用户可以针对自己的需求对谈资话题进行搜索。4、用户的话题被评论有相关的推送提示。
圈子拓展1、每个用户都可以根据自己的喜好搜索相关的人脉圈，如果该人脉圈为公开的，用户就可以浏览圈子的相关信息，也可以查看圈子中的人员组成。2、人脉圈的管理员，可以向其他的人脉圈发出联结申请，若两个人脉圈成为联结关系，双方的管理员可以自由交流。3、管理员可以引荐自己圈子里的人给联结圈子的人，引荐的用户不会立即成为联结圈子的成员，而是将信息公布给联结圈子的成员，供联结圈子的用户拓宽自己的人脉（有需求的用户可以自己联系他成为自己的好友），能否成为圈子的成员决定权在于管理者。4、两个圈子发起共同活动，设置可以两个人脉圈合并成为一个新的人脉圈。5、在圈子中可以随意私聊，添加好友。
]]></content>
      <categories>
        <category>专业</category>
      </categories>
  </entry>
  <entry>
    <title>Django开发简单Blog系统——中</title>
    <url>/dev-django-blog-1/</url>
    <content><![CDATA[系统功能1、博客列表展示2、新增博客、修改博客、删除博客、搜索博客3、后台管理


后台管理django自带后台管理系统Admin，被授权的用户可以直接在后台管理系统中操作数据库。同时，我们可以按照需求对Admin进行定制。
1、创建超级用户python manage.py createsuperuser根据提示，输入用户名、邮箱、密码。
2、测试访问访问地址 http://localhost:8000/admin/ ，输入用户名密码，登录后台管理系统。
3、改成中文后台管理系统，默认是英文的，修改settings.py：
# LANGUAGE_CODE = 'en-us'LANGUAGE_CODE = 'zh-hans'
刷新后台管理页面，发现变成了中文。
4、注册model此时，我们在后台管理中看不到article等表数据，要想显示数据，需要在blog/admin.py中注册model。
from django.contrib import adminfrom . import models# Register your models here.admin.site.register(models.Article)
刷新后台管理页面，发现article表已经出现。
5、点击进入Articles，发现里面有很多Article Object，因为我们在blog/models.py中添加了__str__方法，所以显示的名称是文章标题。
def __str__(self):    return self.title

页面开发主页面1、在blog/urls.py中配置路由
url(r'^$', views.index, name='index'),url(r'^index$', views.index, name='index'),

2、在blog/views.py中修改index方法
def index(request):    articles = models.Article.objects.all()    return render(request, 'blog/index.html', &#123;'articles': articles&#125;)

3、修改blog/templates/blog/index.html
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;博客列表&lt;/h2&gt;    &lt;div class="menu"&gt;        &lt;input class="search-input" type="text"&gt;         &lt;span class="search"&gt;搜索&lt;/span&gt;         &lt;a class="add" href="/blog/toadd"&gt;添加&lt;/a&gt;    &lt;/div&gt;    &lt;table&gt;        &lt;thead&gt;            &lt;th&gt;博客标题&lt;/th&gt;            &lt;th&gt;发布时间&lt;/th&gt;            &lt;th&gt;操作&lt;/th&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &#123;% for article in articles %&#125;            &lt;tr data-id="&#123;&#123;article.id&#125;&#125;"&gt;                &lt;td&gt;&lt;a href="/blog/&#123;&#123;article.id&#125;&#125;"&gt;&#123;&#123;article.title&#125;&#125;&lt;/a&gt;&lt;/td&gt;                &lt;td&gt;&#123;&#123;article.pub_time&#125;&#125;&lt;/td&gt;                &lt;td&gt;                    &lt;span class="del"&gt;删除&lt;/span&gt;                &lt;/td&gt;            &lt;/tr&gt;            &#123;% endfor %&#125;        &lt;/tbody&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;

4、测试访问访问地址 http://localhost:8000/blog 或 http://localhost:8000/blog/index
静态资源blog/index.html中，没有添加样式。接下来，我们修改一下项目结构，把样式表放在静态资源目录中。参考DJango 1.8 配置静态资源文件可访问 和 Django 静态文件。
1、新建djsite/static/css层级目录，在css下新建index.css，内容参见源码分享。
2、在settings.py中添加
# 设置STATIC_URL为存储静态文件的路径（基于根目录）STATIC_URL = '/static/' # 配置存储静态文件的路径映射值，这个值用于模版引用路径的转换 STATICFILES_DIRS = (      os.path.join(BASE_DIR, "static"),  )


3、修改blog/index.html为：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &#123;% load staticfiles %&#125;    &lt;link rel="stylesheet" href="&#123;%static 'css/index.css'%&#125;"&gt;    &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--不变--&gt;&lt;/body&gt;&lt;/html&gt;

查看博客页面1、在blog/urls.py中添加：
url(r'^(?P&lt;article_id&gt;[0-9]+)$', views.detail, name='detail'),

2、在blog/views.py中添加方法：
def detail(request,article_id):    article = models.Article.objects.get(pk=article_id)    return render(request, 'blog/article.html',                  &#123;'article': article&#125;)

3、在blog/templates/blog中添加article.html：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &#123;% load staticfiles %&#125;    &lt;link rel="stylesheet" href="&#123;%static 'css/article.css'%&#125;"&gt;    &lt;title&gt;&#123;&#123;article.title&#125;&#125;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;&#123;&#123;article.title&#125;&#125;&lt;/h2&gt;    &lt;div&gt;        &lt;p&gt;&#123;&#123;article.content&#125;&#125;&lt;/p&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;a class="edit" href="/blog/toedit/&#123;&#123;article.id&#125;&#125;"&gt;编辑&lt;/a&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;

4、测试访问访问地址 http://localhost:8000/blog/1
添加博客页面1、在blog/urls.py中添加：
url(r'^toadd$', views.toadd, name='toadd'),

2、在blog/views.py添加方法：
def toadd(request):    return render(request, 'blog/add.html')

3、在blog/templates/blog中添加add.html：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;添加博客&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action="/blog/add" method="post"&gt;        &lt;p&gt;            &lt;label for="title"&gt;标题&lt;/label&gt;            &lt;input id="title" name="title" type="text"&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;label for="content"&gt;内容&lt;/label&gt;            &lt;textarea id="content" name="content" id="" cols="30" rows="10"&gt;&lt;/textarea&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;input type="submit" value="确定"&gt;        &lt;/p&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

4、修改blog/views.py中的add方法为：
@csrf_exemptdef add(request):    title = request.POST.get('title', 'defaultTitle')    content = request.POST.get('content', 'defaultContent')    pub_time = utc2local(timezone.now())    LOCAL_FORMAT = "%Y-%m-%d %H:%M:%S"    pub_time = pub_time.strftime(LOCAL_FORMAT)    models.Article.objects.create(title=title, content=content, pub_time=pub_time)    articles = models.Article.objects.all()    return render(request, 'blog/index.html',&#123;'articles': articles&#125;)

5、测试访问访问地址 http://localhost:8000/blog/toadd
修改博客页面1、在blog/urls.py中添加：
url(r'^toedit/(?P&lt;article_id&gt;[0-9]+)$', views.toedit, name='toedit'),

2、在blog/views.py添加方法：
def toedit(request, article_id):    article = models.Article.objects.get(pk=article_id)    return render(request, 'blog/edit.html', &#123;'article': article&#125;)

3、在blog/templates/blog中添加edit.html：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;修改博客&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action="/blog/edit" method="post"&gt;        &lt;p style="display: none;"&gt;            &lt;input name="id" type="text" value="&#123;&#123;article.id&#125;&#125;"&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;label for="title"&gt;标题&lt;/label&gt;            &lt;input id="title" name="title" type="text" value="&#123;&#123;article.title&#125;&#125;"&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;label for="content"&gt;内容&lt;/label&gt;            &lt;textarea id="content" name="content" id="" cols="30" rows="10"&gt;&#123;&#123;article.content&#125;&#125;&lt;/textarea&gt;        &lt;/p&gt;        &lt;p&gt;            &lt;input type="submit" value="确定"&gt;        &lt;/p&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

4、修改blog/views.py中的edit方法：
@csrf_exemptdef edit(request):    article_id = request.POST.get('id', 0)    title = request.POST.get('title', 'defaultTitle')    content = request.POST.get('content', 'defaultContent')    pub_time = utc2local(timezone.now())    LOCAL_FORMAT = "%Y-%m-%d %H:%M:%S"    pub_time = pub_time.strftime(LOCAL_FORMAT)    article = models.Article.objects.get(pk=article_id)    article.title = title    article.content = content    article.pub_time = pub_time    article.save()    articles = models.Article.objects.all()    return render(request, 'blog/index.html', &#123;'articles': articles&#125;)

删除博客1、修改blog/templates/blog/index.html，添加js引入：
&lt;script src="&#123;% static 'lib/jquery/jquery.min.js'%&#125;"&gt;&lt;/script&gt;&lt;script src="&#123;% static 'lib/layer/layer.js'%&#125;"&gt;&lt;/script&gt;&lt;script src="&#123;% static 'lib/art-template/dist/template-native.js'%&#125;"&gt;&lt;/script&gt;&lt;script src="&#123;% static 'js/index.js'%&#125;"&gt;&lt;/script&gt;

2、创建static/js目录，js目录中新建index.js：
$(function()&#123;    $('table').on('click','.del',function()&#123;        $that = $(this);        layer.confirm('确认删除？', &#123;            btn: ['确认','取消'] //按钮        &#125;, function()&#123;            var $tr = $that.parents('tr');            var id = $tr.attr('data-id');            $.ajax(&#123;                url: '/blog/delete',                type: 'POST',                dataType: 'json',                data: &#123;id: id&#125;,                success: function(data)&#123;                    console.log(data);                    if(data.code == '0')&#123;                        $tr.remove();                        layer.msg('删除成功');                    &#125;                &#125;,                error: function(xhr)&#123;                    console.log(xhr);                &#125;            &#125;);        &#125;, function()&#123;            // nothing        &#125;);            &#125;);&#125;);

3、修改blog/views.py中的delete方法：
@csrf_exemptdef delete(request):    article_id = request.POST.get('id', 0)    models.Article.objects.get(pk=article_id).delete()    result = &#123;'code': 0, 'ext': 'success'&#125;    return HttpResponse(json.dumps(result, ensure_ascii=False))

4、测试访问访问地址 http://localhost:8000/blog/ ，点击文章后面的删除按钮即可。
查找博客1、在blog/urls.py中添加：
url(r'^search$', views.search, name='search')

2、在blog/views.py中添加search方法：
from django.db.models import Q@csrf_exemptdef search(request):    key = request.POST.get('key')    articles = models.Article.objects.filter(Q(title__contains=key) | Q(content__contains=key))    json_data = serializers.serialize("json", articles)    dict_data = json.loads(json_data)    result = &#123;        'code': 0,        'ext': 'success',        'articles': dict_data&#125;    return HttpResponse(json.dumps(result, ensure_ascii=False))


3、在blog/templates/blog/index.html中添加：
&lt;script type="text/template" id="tr_template"&gt;    &lt;% for(var i = 0 ; i &lt; articles.length ; i ++)&#123; %&gt;    &lt;% var article = articles[i]; %&gt;    &lt;tr data-id="&lt;%=article.pk%&gt;"&gt;        &lt;td&gt;&lt;a href="/blog/&lt;%=article.pk%&gt;"&gt;&lt;%=article.fields.title%&gt;&lt;/a&gt;&lt;/td&gt;        &lt;td&gt;&lt;%=article.fields.pub_time%&gt;&lt;/td&gt;        &lt;td&gt;            &lt;span class="del"&gt;删除&lt;/span&gt;        &lt;/td&gt;    &lt;/tr&gt;    &lt;% &#125; %&gt;&lt;/script&gt;

4、在index.js中添加：
$('.search').on('click',function()&#123;    var key = $('.search-input').val();    $.ajax(&#123;        url: '/blog/search',        type: 'POST',        dataType: 'json',        data: &#123;key: key&#125;,        success: function(data)&#123;            console.log(data);            if(data.code == '0')&#123;                var html = template('tr_template',&#123;articles: data.articles&#125;);                $('tbody').html(html);            &#125;        &#125;,        error: function(xhr)&#123;            console.log(xhr);        &#125;    &#125;);&#125;);$('.search-input').keypress(function(event) &#123;    var key = event.which;    // console.log(key);    if(key == 13)&#123;        //do something        $('.search').trigger('click');    &#125;&#125;);

效果演示
源码分享https://github.com/voidking/djsite/releases/tag/v0.2.0
书签django入门与实践
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>Django部署到线上（修改版）</title>
    <url>/dev-django-deploy-advance/</url>
    <content><![CDATA[前言《Django部署到线上》一文中，很多步骤不是必须的，有些部分甚至是错误的，本文就精简修改一下。目标：把djsite项目部署到/home/web目录中，并且给它分配一个域名为djsite.voidking.com。


环境准备supervisor参考《CentOS安装配置Supervisor》，安装配置好supervisor。
python虚拟机参考《CentOS安装配置pyenv》，安装好python3.6.1。
项目部署代码准备1、在/home/web目录中，执行命令克隆项目git clone https://github.com/voidking/djsite.git
2、安装djangopip install django==1.11.7
3、安装pymysqlpip install pymysql
数据库准备1、创建数据库
# mysql -uroot -pmysql&gt; create database `djsite` default character set utf8 collate utf8_general_ci;

2、修改mysql的binlog格式为混合模式：
mysql&gt; set global binlog_format=mixed;mysql&gt; exit;

3、修改djsite/djsite/settings.py中的数据库配置vim djsite/djsite/settings.py
4、创建表结构
python manage.py makemigrationspython manage.py migrate

启动项目1、启动命令python manage.py runserver
2、服务器测试访问curl localhost:8000/blog/index
3、本地测试访问使用浏览器查看 http://ip:8000/blog/index ，无法访问。启动命令改为：python manage.py runserver 0.0.0.0:8000，此时即可在浏览器看到部署好的项目。
如果还是不能访问，尝试先关闭防火墙：systemctl stop firewalld
nginx配置1、首先，在万网上配置域名解析，添加A记录，解析到阿里云服务器IP。假设解析好的域名为django.voidking.com。
2、在nginx的vhost中，添加django.voidking.com.conf，内容为：
server &#123;    listen 80;    server_name django.voidking.com;    charset utf-8;    location /&#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        client_max_body_size       1024m;        client_body_buffer_size    128k;        client_body_temp_path      data/client_body_temp;        proxy_connect_timeout      90;        proxy_send_timeout         90;        proxy_read_timeout         90;        proxy_buffer_size          4k;        proxy_buffers              4 32k;        proxy_busy_buffers_size    64k;        proxy_temp_file_write_size 64k;        proxy_temp_path            data/proxy_temp;        proxy_pass http://127.0.0.1:8000;    &#125;&#125;

3、重启nginx，./nginx -s reload
4、测试访问服务器：curl django.voidking.com/blog/index本地浏览器：http://django.voidking.com/blog/index
至此，django项目已经部署成功，没有用到uwsgi。如果给django添加守护进程，那么我们的部署就接近完美了。那么，uwsgi又能干什么呢，我们继续研究。
uwsgi安装uwsgipip install uwsgi
编写测试：
# test.pydef application(env, start_response):    start_response('200 OK', [('Content-Type','text/html')])    return [b"Hello World"]

启动测试：uwsgi --http :8001 --wsgi-file test.py
访问 http://ip:8001 ，即可看到Hello World 。
一般启动1、编写wsgi.py文件编写django_wsgi.py文件，将其放在与文件manage.py同一个目录下。
#!/usr/bin/env python# coding: utf-8import os,djangofrom django.core.handlers.wsgi import WSGIHandleros.environ.setdefault("DJANGO_SETTINGS_MODULE", "djsite.settings")django.setup()application = WSGIHandler()

2、启动项目uwsgi --http :8000 --chdir /home/web/djsite/ --module django_wsgi
3、查看启动结果lsof -i :8000，ps aux | grep uwsgi
4、测试访问http://ip:8000/blog/index此时，页面是没有样式的，也就是说静态资源加载失败。
5、配置静态资源uwsgi --http :8000 --chdir /home/web/djsite/ --module django_wsgi --static-map=/static=static此时，页面样式就正常了。
高级启动1、新建uwsgi.ini，与manage.py在同一级目录。
[uwsgi]http = :8000chdir = /home/web/djsite/wsgi-file = django_wsgi.pystatic-map = /static=static

2、启动uwsgiuwsgi uwsgi.ini
3、测试访问http://ip:8000/blog/index
使用supervisor管理守护uwsgi1、在/etc/supervisor中新建djsite.conf文件：
[program:djsite]command=/root/.pyenv/versions/3.6.1/bin/uwsgi --http :8000 --chdir /home/web/djsite/ --module django_wsgi --static-map=/static=staticdirectory=/home/web/djsite/startsecs=0stopwaitsecs=0autostart=trueautorestart=true

2、重启supervisor
ps aux | grep supervisordsystemctl stop supervisordsystemctl start supervisord

附：重启djsite命令
supervisorctl -c /etc/supervisord.conf restart djsite

3、测试访问http://ip:8000/blog/index页面显示正常，至此守护进程配置成功。
4、djsite.conf可以精简修改为：
[program:djsite]command=/root/.pyenv/versions/3.6.1/bin/uwsgi --ini uwsgi.inidirectory=/home/web/djsite/startsecs=0stopwaitsecs=0autostart=trueautorestart=true

静态资源问题（可忽略）假设，uwsgi.ini为：
[uwsgi]http = :8000chdir = /home/web/djsite/wsgi-file = django_wsgi.py

静态资源就无法访问了。在不添加static-map的情况下，需要修改两个文件：（1）修改djsite/djsite/settings.py文件，添加：
STATIC_ROOT = '/home/web/djsite/static/'
（2）修改djsite/djsite/settings.py文件为：
from django.conf.urls import url,includefrom django.contrib import adminfrom django.conf.urls.static import staticfrom django.conf import settingsurlpatterns = [    url(r'^admin/', admin.site.urls),    url(r'^blog/', include('blog.urls', namespace='blog')),] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)

admin静态资源问题如果以python manage.py runserver启动django，那么静态资源没有问题。
如果以uwsgi启动django，静态资源看起来没有问题，但是，如果访问 http://ip:8000/admin ，就会发现这个页面的静态资源无法获取。
一个Django应用，一般有两类静态文件。一是应用内的静态文件，二是Django自带的静态文件。应用内的静态文件在djsite/static目录下。此外，在INSTALLED_APPS中配置了django.contrib.admin， 则还会有另外一组静态文件，在Django安装位置里。
例如，一个root在Python 3.6版本安装的Django，admin的静态文件在： /usr/local/lib/python3.6/site-packages/django/contrib/admin/static/admin/。
最终，在STATIC_URL里，会有两类静态文件， /static/* 与 /static/admin/* 。
了解原理，原因就很显然了。python manage.py runserver知道静态文件的位置，而uWSGI不知道静态文件在什么位置。
解决办法如下：（1）修改djsite/djsite/settings.py文件：
SITE_ROOT = os.path.dirname(os.path.abspath(__file__))SITE_ROOT = os.path.abspath(os.path.join(SITE_ROOT, '../'))STATIC_ROOT = os.path.join(SITE_ROOT, 'collectedstatic')

（2）收集所有静态文件到collectedstatic目录python manage.py collectstatic
（3）修改uwsgi.ini配置
[uwsgi]http = :8000chdir = /home/web/djsite/wsgi-file = django_wsgi.pystatic-map = /static=collectedstatic

nginx+uwsgi以上，我们的djsite项目已经通过uwsgi方式启动起来，并且可以保持后台运行。nginx配置不改变的情况下，我们可以正常访问 http://django.voidking.com/blog/index 。此时，nginx作为反向代理，和uwsgi间通过http交互。
接下来，就配置下nginx和uwsgi通过socket结合的方式。原理：用户发送http请求到nginx，nginx通过socket把请求交给uwsgi，uwsgi拿到django的处理结果，通过socket返还给nginx，nginx通过http返回结果给用户。
1、因为nginx和uwsgi通过socket方式交互，我们需要修改uwsgi.ini的配置为：
[uwsgi]socket = :8000chdir = /home/web/djsite/wsgi-file = django_wsgi.pystatic-map = /static=collectedstaticmaster = trueprocesses = 2enable-threads = truedaemonize = /home/web/djsite/uwsgi.log

2、重启supervisorsystemctl stop supervisordsystemctl start supervisord
3、修改nginx配置djsite.voidking.com.conf：
server &#123;    listen      80;    server_name djsite.voidking.com;    charset     utf-8;    location / &#123;        uwsgi_pass     127.0.0.1:8000;        include        uwsgi_params;    &#125;&#125;

5、重启nginx./nginx -s reload
6、测试访问此时，访问 http://ip:8000/blog/index 失败，访问 http://django.voidking.com/blog/index 正常。因为8000端口不再提供http服务，而是一个和nginx连接的socket。
加速静态资源1、修改nginx配置djsite.voidking.com.conf：
server &#123;    listen      80;    server_name djsite.voidking.com;    charset     utf-8;    location / &#123;        uwsgi_pass     127.0.0.1:8000;        include        uwsgi_params;    &#125;    location /static &#123;        alias /root/djsite/collectedstatic;    &#125;&#125;

2、修改nginx.conf
user root;

3、重启nginx./nginx -s reload
小结至此，django部署完毕，我们实现了三种部署方法：

nginx + django（http方式）
nginx + uwsgi（http方式）
nginx + uwsgi（socket方式）

书签使用uWSGI提供静态文件 (更新至1.9)
解决uWSGI里的Django静态文件丢失
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>python</category>
        <category>centos</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>centos</tag>
        <tag>supervisor</tag>
        <tag>uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>Django部署到线上</title>
    <url>/dev-django-deploy/</url>
    <content><![CDATA[前言《Django开发简单Blog系统》系列中，我们已经完成了一个迷你Web项目。那么，怎么把这个项目发布到线上呢？怎样给它一个域名呢？
思路：nginx + uwsgi


环境准备服务器阿里云服务器，centos7系统。
python升级python到3.6.1，统一线上和本地python环境。
1、下载python3.6.1源码wget  https://www.python.org/ftp/python/3.6.1/Python-3.6.1.tar.xz
2、解压源码
xz -d Python-3.6.1.tar.xztar -xvf Python-3.6.1.tar

3、编译源码
mkdir /usr/local/python3cd Python-3.6.1./configure --prefix=/usr/local/python3 --enable-optimizationsmake &amp;&amp; make install

如果编译失败，需要先更新编译环境：
gcc -v g++ -vyum install gccyum install gcc-c++

注：我的环境版本为 gcc version 4.8.5 20150623 (Red Hat 4.8.5-11) (GCC) 。
4、替换python
cd /usr/binmv python python.bakln -s /usr/local/python3/bin/python3.6 /usr/bin/pythonll python*python -V

5、解决遗留问题所有python相关的应用，如果使用/usr/bin/python开头的脚本，替换为/usr/bin/python2.7。比如：
vim /usr/bin/yumvim /usr/libexec/urlgrabber-ext-down

uwsgipip install uwsgi
编写测试：
# test.pydef application(env, start_response):    start_response('200 OK', [('Content-Type','text/html')])    return [b"Hello World"]

启动测试：uwsgi --http :8001 --wsgi-file test.py
报错：uwsgi: command not found，看来我们需要把python3/bin加入到path。vim /etc/profile，在文件最底部找到PATH，添加：
:/usr/local/python3/bin

使配置生效：source /etc/profile
访问 http://ip:8001 ，即可看到Hello World 。
nginx和mysql参考《在CentOS7上配置PHP运行环境》，安装好了nginx和mysql。
项目部署代码准备1、克隆项目到服务器git clone https://github.com/voidking/djsite.git
2、安装djangopip install django
3、安装pymysqlpip install pymysql
数据库准备1、创建数据库
# mysql -uroot -pmysql&gt; create database `djsite` default character set utf8 collate utf8_general_ci; mysql&gt; exit;

2、修改djsite/djsite/settings.py中的数据库配置vim djsite/djsite/settings.py
3、创建表结构
python manage.py makemigrationspython manage.py migrate

报错：
django.db.utils.InternalError: (1665, 'Cannot execute statement: impossible to write to binary log since BINLOG_FORMAT = STATEMENT and at least one table uses a storage engine limited to row-based logging. InnoDB is limited to row-logging when transaction isolation level is READ COMMITTED or READ UNCOMMITTED.')

修改mysql的binlog格式为混合模式：
# mysql -uroot -pmysql&gt; set global binlog_format=mixed;

删除数据库djsite中的所有表，然后再次执行：
python manage.py migrate

启动项目数据库问题cd djsitepython manage.py runserver

报错：
File "/usr/local/python3/lib/python3.6/site-packages/django/db/backends/mysql/base.py", line 36, in &lt;module&gt;    raise ImproperlyConfigured("mysqlclient 1.3.3 or newer is required; you have %s" % Database.__version__)django.core.exceptions.ImproperlyConfigured: mysqlclient 1.3.3 or newer is required; you have 0.7.11.None

解决办法：
vim /usr/local/python3/lib/python3.6/site-packages/django/db/backends/mysql/base.py

进入vim命令模式，输入/version，按N查找下一个，找到：
if version &lt; (1, 3, 3):    raise ImproperlyConfigured("mysqlclient 1.3.3 or newer is required; you have %s" % Database.__version__)
注释掉它，问题解决。
url问题cd djsitepython manage.py runserver

再次报错：
File "/root/djsite/djsite/urls.py", line 21, in &lt;module&gt;    url(r'^blog/', include('blog.urls', namespace='blog')),  File "/usr/local/python3/lib/python3.6/site-packages/django/urls/conf.py", line 39, in include    'Specifying a namespace in include() without providing an app_name 'django.core.exceptions.ImproperlyConfigured: Specifying a namespace in include() without providing an app_name is not supported. Set the app_name attribute in the included module, or pass a 2-tuple containing the list of patterns and app_name instead.

解决办法：
vim /usr/local/python3/lib/python3.6/site-packages/django/urls/conf.py

找到：
if namespace and not app_name:    raise ImproperlyConfigured(        'Specifying a namespace in include() without providing an app_name '        'is not supported. Set the app_name attribute in the included '        'module, or pass a 2-tuple containing the list of patterns and '        'app_name instead.',    )
注释掉它，问题解决。
查看效果cd djsitepython manage.py runserver

启动成功，在服务器上测试访问：curl localhost:8000/blog/index
使用浏览器查看 http://ip:8000/blog/index ，却无法访问。这是因为在settings.py中，ALLOWED_HOSTS的配置为：
ALLOWED_HOSTS = []

官方文档说：

When DEBUG is True and ALLOWED_HOSTS is empty, the host is validated against [‘localhost’, ‘127.0.0.1’, ‘[::1]’].

修改ALLOWED_HOSTS的配置为：
ALLOWED_HOSTS = ['*']

然后启动命令改为：python manage.py runserver 0.0.0.0:8000，此时即可在浏览器看到部署好的项目。
如果还是不能访问，尝试先关闭防火墙：systemctl stop firewalld
nginx配置1、首先，在万网上配置域名解析，添加A记录，解析到阿里云服务器IP。假设解析好的域名为django.voidking.com。
2、在nginx的vhost中，添加django.voidking.com.conf，内容为：
server &#123;    listen 80;    server_name django.voidking.com;    charset utf-8;    location /&#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        client_max_body_size       1024m;        client_body_buffer_size    128k;        client_body_temp_path      data/client_body_temp;        proxy_connect_timeout      90;        proxy_send_timeout         90;        proxy_read_timeout         90;        proxy_buffer_size          4k;        proxy_buffers              4 32k;        proxy_busy_buffers_size    64k;        proxy_temp_file_write_size 64k;        proxy_temp_path            data/proxy_temp;        proxy_pass http://127.0.0.1:8000;    &#125;&#125;

3、重启nginx，./nginx -s reload
4、测试访问服务器：curl django.voidking.com/blog/index本地浏览器：http://django.voidking.com/blog/index
至此，django项目已经部署成功，没有用到uwsgi。如果给django添加守护进程，那么我们的部署就接近完美了。那么，uwsgi又能干什么呢，我们继续研究。
uwsgi一般启动1、编写wsgi.py文件编写django_wsgi.py文件，将其放在与文件manage.py同一个目录下。
#!/usr/bin/env python# coding: utf-8import os,djangofrom django.core.handlers.wsgi import WSGIHandleros.environ.setdefault("DJANGO_SETTINGS_MODULE", "djsite.settings")django.setup()application = WSGIHandler()

2、启动项目uwsgi --http :8000 --chdir ~/djsite/ --module django_wsgi
3、查看启动结果lsof -i :8000，ps aux | grep uwsgi
4、测试访问http://ip:8000/blog/index此时，页面是没有样式的，也就是说静态资源加载失败。
5、配置静态资源uwsgi --http :8000 --chdir ~/djsite/ --module django_wsgi --static-map=/static=static此时，页面样式就正常了。
高级启动1、新建uwsgi.ini，与manage.py在同一级目录。
[uwsgi]http = :8000chdir = /root/djsite/wsgi-file = django_wsgi.pystatic-map = '/static=static'

2、启动uwsgiuwsgi uwsgi.ini
3、测试访问http://ip:8000/blog/index
守护进程安装supervisor关闭shell后，uwsgi服务就很快关闭了。为了让它后台运行，需要让它变成守护进程。参考《CentOS安装配置Supervisor》，安装配置好supervisor。
守护uwsgi1、在/etc/supervisor中新建djsite.conf文件：
[program:djsite]command=/usr/local/python3/bin/uwsgi --http :8000 --chdir /root/djsite/ --module django_wsgi --static-map=/static=staticdirectory=/root/djsite/startsecs=0stopwaitsecs=0autostart=trueautorestart=true

2、重启supervisor
systemctl stop supervisordsystemctl start supervisord

附：重启djsite命令
supervisorctl -c /etc/supervisord.conf restart djsite

3、测试访问http://ip:8000/blog/index页面显示正常，至此守护进程配置成功。
4、退出supervisor环境source deactivate，守护进程并没有受到影响。
nginx+uwsgi以上，我们的djsite项目已经通过uwsgi方式启动起来，并且可以保持后台运行。nginx配置不改变的情况下，我们可以正常访问 http://django.voidking.com/blog/index 。此时，nginx作为反向代理，和uwsgi间通过http交互。
接下来，就配置下nginx和uwsgi通过socket结合的方式。原理：用户发送http请求到nginx，nginx通过socket把请求交给uwsgi，uwsgi拿到django的处理结果，通过socket返还给nginx，nginx通过http返回结果给用户。
1、因为nginx和uwsgi通过socket方式交互，我们需要修改uwsgi.ini的配置为：
[uwsgi]socket = :8000chdir = /root/djsite/wsgi-file = django_wsgi.pystatic-map = '/static=static'master = trueprocesses = 2enable-threads = true# daemonize = /root/djsite/uwsgi.log

2、/etc/supervisor/djsite.conf，修改为
[program:djsite]command=/usr/local/python3/bin/uwsgi uwsgi.inidirectory=/root/djsite/startsecs=0stopwaitsecs=0autostart=trueautorestart=true

3、重启supervisorsystemctl stop supervisordsystemctl start supervisord
4、修改nginx配置djsite.voidking.com.conf：
server &#123;    listen      80;    server_name djsite.voidking.com;    charset     utf-8;    location / &#123;        uwsgi_pass     127.0.0.1:8000;        include        uwsgi_params;    &#125;    location /static &#123;        alias /root/djsite/static;    &#125;&#125;

5、重启nginx./nginx -s reload
6、测试访问此时，访问 http://ip:8000/blog/index 失败，访问 http://django.voidking.com/blog/index 正常。因为8000端口不再提供http服务，而是一个和nginx连接的socket。
7、static请问，此时的静态资源，是通过uwsgi获取的？还是通过nginx直接获取的？做一个测试即可，修改uwsgi为：
[uwsgi]socket = :8000chdir = /root/djsite/wsgi-file = django_wsgi.py# static-map = '/static=static'master = trueprocesses = 2enable-threads = true# daemonize = /root/djsite/uwsgi.log
此时，uwsgi不再提供静态资源。重启supervisor，页面样式正常，可见，静态资源是通过nginx获取的。之所以可以获取到，是因为我们之前在djsite/settings.py中配置了：
STATICFILES_DIRS = (    os.path.join(BASE_DIR, "static"),)


小结至此，django部署完毕，我们实现了三种部署方法：

nginx + django（http方式）
nginx + uwsgi（http方式）
nginx + uwsgi（socket方式）

在此过程中，解决了一些奇怪的bug，学习了升级python的方法，学习了使用pyenv安装多版本python的方法（类似的还有anaconda），学习了给django或者uwsgi添加守护进程的方法，收获颇丰。
书签Python Web部署方式总结
Python网络框架——Web服务器
Django在生产环境中的部署
Django 部署(Nginx)
使用Supervisor管理SpiderKeeper和Scrapyd
使用uWSGI提供静态文件 (更新至1.9)
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>python</category>
        <category>centos</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
        <tag>centos</tag>
        <tag>supervisor</tag>
        <tag>uwsgi</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置Apache和PHP环境（微擎环境）</title>
    <url>/dev-docker-apache-php/</url>
    <content><![CDATA[前言《在CentOS7上配置PHP运行环境》一文中学习了安装配置LNMP环境，《CentOS安装Apache和PHP环境》一文中学习了安装配置Apache和PHP环境。
本文学习使用Docker安装配置Apache和PHP，与Mysql结合，搭建一个容器化的LAMP环境，部署微擎服务。
前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为192.168.56.130。


安装Mysql参考《使用Docker安装配置Mysql》，安装好mysql server和mysql client。
1、登录mysql servermysql -h 127.0.0.1 -u root -p
2、创建数据库
create database `w7` default character set utf8 collate utf8_general_ci;

安装PHP1、登录dockerhub查看需要的PHP - Docker Official Images。
2、下载php镜像（以7.2-apache为例）docker pull php:7.2-apache
选择带有apache的版本，省去了安装apache的步骤。
3、启动php和apache服务
docker run --name vk-php -d \-p 8080:80 \-v /opt/php/w7:/var/www/html \php:7.2-apache

以上命令：

命名容器为vk-php，后台运行
映射宿主机8080端口到容器的80端口
挂载宿主机目录/opt/php/w7到容器目录/var/www/html

更多启动命令参数可以参考How to use this image。
4、创建测试文件vim /opt/php/w7/index.php，内容为：
&lt;?php    echo 'hello php7.2';?&gt;

5、验证安装curl localhost:8080，可以看到hello php7.2。浏览器访问 http://192.168.56.130:8080 ，可以看到hello php7.2。
以上，apache和php环境安装配置完成。
安装微擎初始尝试主要参考《微擎系统搭建》和微擎linux服务器安装。1、下载微擎安装引导文件
cd /opt/php/w7wget https://cdn.w7.cc/download/WeEngine-Laster-Online.zipunzip WeEngine-Laster-Online.zip

2、浏览器访问安装页面http://192.168.56.130:8080/install.php填入用户名密码后，点击验证后安装微擎。没有通过验证，如下图：由报错看，主要是目录权限问题和缺少扩展问题。
重做镜像1、修改sources.list在容器中查看/etc/apt/sources.list，发现镜像版本是debian buster，因此新建一个sources.list为：
deb http://mirrors.aliyun.com/debian/ buster main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster main non-free contribdeb http://mirrors.aliyun.com/debian-security buster/updates maindeb-src http://mirrors.aliyun.com/debian-security buster/updates maindeb http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-updates main non-free contribdeb http://mirrors.aliyun.com/debian/ buster-backports main non-free contribdeb-src http://mirrors.aliyun.com/debian/ buster-backports main non-free contrib

2、编写Dockerfile
FROM php:7.2-apacheCOPY sources.list /etc/apt/sources.listRUN apt-get update &amp;&amp; apt-get install -y libpng-dev libzip-dev \    &amp;&amp; docker-php-ext-install zip gd pdo pdo_mysqlRUN chmod 777 /var/www/html

3、生成新镜像docker build -t voidking/w7:v1.0 .
再次尝试1、删除原有容器
docker stop vk-phpdocker rm vk-php

2、启动新的容器
docker run --name vk-php -d \-p 8080:80 \-v /opt/php/w7:/var/www/html \voidking/w7:v1.0

3、再次安装，再次验证可以看到，这次还剩一个问题：外网不可访问。这就奇怪了，在容器内明明是可以正常访问外网的，为啥报这个错？既然没错，那就忽略它好了。但是这个错存在，就无法进行下一步，因此这里我们换一种安装方式：源码安装。
源码安装1、下载源码
cd /opt/php/w7rm -rf ./*cd ..git clone https://gitee.com/we7coreteam/pros.git w7

2、再次安装，再次验证nice，完美跳过了外网不可访问这个坑。然后，data目录权限报错。修改data目录权限，chmod 777 /opt/php/w7/data/，问题解决。
3、填入数据库连接信息，以及管理员用户名密码
4、然后，安装完成。
5、测试访问浏览器访问首页 http://192.168.56.130:8080/index.php ，即会跳转到微擎登录页。
以上，微擎系统安装配置完成，可以愉快地使用了。
百度云解析备案失败百度智能云年终盛典，全场云服务器一折起，于是151块钱入手了一台1C2G2M的百度云BCC主机。但是，没有想到的是，网站需要新增接入备案，否则无法使用域名！！！这个不怪百度，如果使用百度云备案成功，以后想要接入阿里云或者腾讯云，也需要新增接入备案。
不过百度云比较坑的有两点：第一点是备案期间域名不能解析，而阿里云备案期间可以正常解析。第二点是无法通过百度云的备案审核，提交备案后百度云给出了六条不符合审核条件的理由，而同样的审核材料，一个月前在阿里云通过了备案审核。
真的是没有对比就没有伤害，第一个念头是退货，然而退货失败。不能退货，那该怎样使用这台服务器呢？那该怎样在这台服务器上部署服务，然后通过域名访问呢？
在github找到了一些项目，awesome-selfhosted，想要部署一些不需要域名的服务，好歹给利用起来了。但是，依然不甘心，想要给这些服务加上域名！然后，真的找到了办法！前提是你还有一台可以进行域名接入的主机，无论是备案过的阿里云主机，还是不需要备案的海外主机，都可以。
解析方案已知两台主机：可以域名接入的主机（主机A），百度云主机（主机B）。我们在主机B上部署好了微擎服务，想要给这个服务添加一个域名：w7.voidking.com 
1、安装frp参考《使用frp进行内网穿透》，在主机A上安装配置好frp server，在主机B上安装配置好frp client。主机B上的8080端口，映射为主机A上的3480端口。
2、nginx配置在主机A上，添加nginx解析 w7.voidking.com.conf ，内容为：
server &#123;    server_name w7.voidking.com;    listen 80;    location / &#123;        proxy_pass http://127.0.0.1:3480/;        proxy_set_header X-Real-IP $remote_addr;    &#125;&#125;

注意，不用多加其他参数，不然会出现502等错误。
3、域名解析在dnspod上添加A记录解析到主机A。
以上，可以通过域名访问百度云上的微擎服务了。
微擎后续问题站点URL问题确实可以通过域名访问微擎服务了，但是站点的很多请求地址为 127.0.0.1:3480 ，因为微擎服务使用proxy_pass里的URL作为了站点URL。我们想让微擎服务把域名作为站点URL，解决办法很简单，添加：
proxy_set_header Host $http_host;
但是，添加完这个参数，就会出现502错误，尴尬了吧。。。nginx层没法进行修复，看来这个问题只能通过修改微擎源码来修复了。编辑/opt/php/w7/framework/bootstrap.inc.php，如下修改：
# line 90, change// $_W['siteroot'] = htmlspecialchars($_W['sitescheme'] . (isset($_SERVER['HTTP_HOST']) ? $_SERVER['HTTP_HOST'] : '') . $sitepath);$_W['siteroot'] = 'w7.voidking.com';

然后，请求地址就全部变成 w7.voidking.com ，nice。
跨域问题但是，一些请求报错：
Access to XMLHttpRequest at 'javascript:;' from origin 'http://w7.voidking.com' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.

明明都是同一个url，居然还是跨域错误，没有找到解决办法。
重装微擎既然自己安装微擎问题这么多，那就使用官网给的docker镜像好了，参考docker安装微擎。
1、删除原有环境
docker stop vk-phpdocker rm vk-php

2、启动新的容器
docker run -it --name vk-php -d \-p 8080:80 \-v /opt/w7/mysql:/var/lib/mysql \-v /opt/w7/html:/var/www/html \-e MYSQL\_ROOT\_PASSWORD=123456 -d \--restart=always \ccr.ccs.tencentyun.com/weiqing/nginxphpmysql:1.0

3、重新安装微擎http://ip:8080/install.php
4、设置用户名密码
5、同样修改微擎源码，修改站点URL。
然后，同样有跨域问题，但是站点已经可以正常使用了，就先这么滴吧。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>docker</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>apache</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker部署JavaWeb项目</title>
    <url>/dev-docker-deploy-javaweb/</url>
    <content><![CDATA[部署要求宿主机为CentOS7，上面安装了docker、nginx和mysql。
1、把已经开发好的JavaWeb项目（pandawork-start）部署到docker容器里。2、该JavaWeb项目使用宿主机的mysql。3、容器设置静态ip为192.168.34.10，80端口映射为宿主机28080端口。4、nginx配置可以通过网址pandawork.voidking.com访问该JavaWeb项目。


软件准备1、《Docker安装tomcat服务》一文中配置好的ubuntu/tomcat镜像。
2、假设宿主机中的mysql数据库密码为voidking，那么需要修改pandawork-start项目中的数据库配置文件（mybatis-config.xml），主机修改为192.168.34.1，密码修改为voidking。
3、打包JavaWeb项目的war包一份。在pom.xml所在文件夹，执行mvn package -Dmaven.test.skip=true命令，在target目录下就会生成war包。（把该war包放到tomcat的webapps文件夹里，会自动解压。）
4、使用xftp，上传war包到CentOS7的/download目录下。
数据库准备1、使用navicat连接到宿主机mysql。2、创建数据库pandawork，数据库名为pandawork，字符集选择utf8–UTF-8 Unicode，排序规则选择utf8_general_ci。3、导入pandawork-start项目中的pandawork.sql文件。
部署项目部署war包1、启动ubuntu/tomcat镜像。docker run -i -t -v /download/:/mnt/software/ ubuntu/tomcat /bin/bash
2、移动war包到webapps。cd /mnt/software
mv pandawork-start.war /opt/apache-tomcat-8.0.44/webapps/
3、启动tomcat，自动解压war包。source /etc/profile
cd /opt/apache-tomcat-8.0.44/bin/
./startup.sh
4、测试访问。curl localhost:8080/pandawork-start/hello
5、关闭tomcat。./shutdown.sh
tomcat配置1、配置tomcat端口为80。cd /opt/apache-tomcat-8.0.44/conf/
vi server.xml
找到：
&lt;Connector port="8080" protocol="HTTP/1.1"               connectionTimeout="20000"               redirectPort="8443" /&gt;
修改为：
&lt;Connector port="80" protocol="HTTP/1.1"               connectionTimeout="20000"               redirectPort="8443" /&gt;

2、配置域名访问。找到：
&lt;Engine name="Catalina" defaultHost="localhost"&gt;
修改为：
&lt;Engine name="Catalina" defaultHost="pandawork.voidking.com"&gt;

找到：
&lt;Host name="localhost"  appBase="webapps"      unpackWARs="true" autoDeploy="true"&gt;  &lt;!-- SingleSignOn valve, share authentication between web applications       Documentation at: /docs/config/valve.html --&gt;  &lt;!--  &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;  --&gt;  &lt;!-- Access log processes all example.       Documentation at: /docs/config/valve.html       Note: The pattern used is equivalent to using pattern="common" --&gt;  &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"         prefix="localhost_access_log" suffix=".txt"         pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;&lt;/Host&gt;
修改为：
&lt;Host name="pandawork.voidking.com"  appBase="webapps"      unpackWARs="true" autoDeploy="true"&gt;  &lt;Context path="" docBase="pandawork-start" reloadable="true" /&gt;  &lt;!-- SingleSignOn valve, share authentication between web applications       Documentation at: /docs/config/valve.html --&gt;  &lt;!--  &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;  --&gt;  &lt;!-- Access log processes all example.       Documentation at: /docs/config/valve.html       Note: The pattern used is equivalent to using pattern="common" --&gt;  &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"         prefix="localhost_access_log" suffix=".txt"         pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;&lt;/Host&gt;


测试启动1、启动tomcat。cd /opt/apache-tomcat-8.0.44/bin/
./startup.sh
2、在/etc/hosts文件中，添加
127.0.0.1       pandawork.voidking.com

3、测试访问。curl pandawork.voidking.com
4、关闭tomcat。./shutdown.sh
保存容器1、退出容器exit
2、查看dockeriddocker ps -l
3、保存容器为ubuntu/pandawork镜像。docker commit 87be ubuntu/pandawork
网络配置1、创建自定义网络，选取192.168.34.0网段。
docker network create --subnet=192.168.34.0/24 voidkingnet

2、选取192.168.34.10作为静态IP地址，启动ubuntu/pandawork镜像。
docker run -d -p 28080:80 --name pandawork1.0 --add-host pandawork.voidking.com:127.0.0.1 --net voidkingnet --ip 192.168.34.10 ubuntu/pandawork /run.sh

我们已经在容器中修改了/etc/hosts文件，为什么还需要–add-host参数？这是因为容器中的hosts文件，在重启后会恢复初始设置，改了也没用。
实际上，在容器中配置tomcat的时候，如果
&lt;Engine name="Catalina" defaultHost="localhost"&gt;

&lt;Host name="localhost"  appBase="webapps"      unpackWARs="true" autoDeploy="true"&gt;  &lt;Context path="" docBase="pandawork-start" reloadable="true" /&gt;  &lt;!-- SingleSignOn valve, share authentication between web applications       Documentation at: /docs/config/valve.html --&gt;  &lt;!--  &lt;Valve className="org.apache.catalina.authenticator.SingleSignOn" /&gt;  --&gt;  &lt;!-- Access log processes all example.       Documentation at: /docs/config/valve.html       Note: The pattern used is equivalent to using pattern="common" --&gt;  &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"         prefix="localhost_access_log" suffix=".txt"         pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;&lt;/Host&gt;

那么，–add-host参数不加也可以。貌似画蛇添足，实际上不然，有些项目可移植性比较差，必须配置本地hosts。
3、查看运行状态。docker ps
4、测试访问。curl 192.168.34.10或者curl localhost:28080
5、关闭容器docker kill pandawork1.0
6、再次启动容器docker start pandawork1.0
nginx配置1、在宿主机中，找到nginx安装位置ps aux | grep nginx
2、进入nginx配置目录在《在CentOS7上配置PHP运行环境》一文中，郝同学的nginx是通过EZHTTP安装的。
cd /usr/local/nginx/conf，进入nginx配置文件目录。cd vhost，具体的某个站点的目录，都在vhost目录下。
3、修改nginx配置文件参照项目：https://github.com/voidking/nginx-conf ，在vhost目录下，新建pandawork.voidking.com.conf文件，内容如下：
upstream pandawork&#123;    server 192.168.34.10;    #server 192.168.34.11;用来负载均衡&#125;server&#123;    listen 80;    server_name pandawork.voidking.com;    location / &#123;        proxy_pass http://pandawork;    &#125;&#125;

4、重新加载nginx配置文件cd /usr/local/nginx/sbin，./nginx -s reload
报错：
nginx: [error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

解决办法：/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
然后重新执行./nginx -s reload。
hosts配置1、在宿主机中，修改/etc/hosts文件，添加：
127.0.0.1       pandawork.voidking.com

2、测试访问。在宿主机中，curl pandawork.voidking.com。
最终测试1、在宿主机中关闭防火墙，systemctl stop firewalld.service。
2、假设宿主机IP为192.168.56.101，那么在宿主机同局域网PC中配置hosts：
192.168.56.101    pandawork.voidking.com

3、浏览器中输入http://pandawork.voidking.com，看到“Hello World!”。
4、验证注册登录等功能，全部正常。此次，大功告成。
重启宿主机后报错重新启动宿主机后，启动docker，启动pandawork容器。执行docker start pandawork1.0时，报错如下：
Error response from daemon: driver failed programming external connectivity on endpoint pandawork1.0 (9f3cbc9ebc5030c0cbbbbbac81628ce48374fd392f6995f4d75ac20bce9d2a30):  (iptables failed: iptables --wait -t nat -A DOCKER -p tcp -d 0/0 --dport 28080 -j DNAT --to-destination 192.168.34.10:80 ! -i br-024154a13bb1: iptables: No chain/target/match by that name. (exit status 1))

解决办法：pkill docker
iptables -t nat -F
ifconfig docker0 down
最后重启docker，docker restart docker。
书签Docker部署JavaWeb项目实战
使用 Docker 搭建 Java Web 运行环境
解决docker容器中文乱码，修改docker容器编码格式
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>tomcat</tag>
        <tag>centos</tag>
        <tag>nginx</tag>
        <tag>ubuntu</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Docker安装配置Prometheus</title>
    <url>/dev-docker-prometheus/</url>
    <content><![CDATA[Prometheus简介
Prometheus是在SoundCloud的基础上构建的开源系统监视和警报工具。自从2012年以来，许多公司和组织都采用了Prometheus，该项目拥有非常活跃的开发人员和用户社区。现在，它是一个独立的开源项目，并且独立于任何公司进行维护。为了强调这一点并阐明项目的治理结构，Prometheus在2016年加入了Cloud Native Computing Foundation，这是继Kubernetes之后的第二个托管项目。

Prometheus的主要特性包括：

一个包含时间序列的多维数据模型，由指标名称和键值对进行标记
PromQL，一种灵活的查询语言
不依赖分布式存储；单服务器节点是自治的
时间序列收集是通过HTTP拉取模型实现的
支持通过中间网关推送时间序列
通过服务发现或静态配置发现目标
支持多种图形和仪表板

Prometheus生态系统包含多个组件，其中许多是可选的：

prometheus server，负责收取并存储时间序列数据
client libraries，用于检测应用程序代码
push gateway，支持短期工作
exporters，适用于特定服务的指标收集器，如HAProxy，StatsD，Graphite
alertmanager，处理报警
各种支持工具

更多内容参考Prometheus文档。本文中，我们会使用Docker来安装配置Prometheus，主要参考Prometheus监控系统之入门篇。前置条件是安装配置好了docker环境，安装方法参考《Docker入门》。已知docker宿主机IP为192.168.56.102。


prometheus server1、登录dockerhub查看需要的prometheus server。
2、下载prometheus server镜像（以v2.18.0为例）docker pull prom/prometheus:v2.18.0
3、创建配置文件创建prometheus.yml，内容为
global:  scrape_interval: 15s #默认采集监控数据时间间隔  external_labels:    monitor: 'my-monitor'scrape_configs:  #监控对象设置  - job_name: prometheus #任务名称    scrape_interval: 5s #每隔5s获取一次监控数据    static_configs: #监控对象地址      - targets: ['127.0.0.1:9090']  # 将自己加入到监控对象中
创建rules.yml，内容为空。
4、启动prometheus server
docker run --name=prometheus -d \-p 9090:9090 \-v $(pwd)/prometheus.yml:/etc/prometheus/prometheus.yml \-v $(pwd)/rules.yml:/etc/prometheus/rules.yml \prom/prometheus:v2.18.0 --config.file=/etc/prometheus/prometheus.yml --web.enable-lifecycle

5、测试服务浏览器访问 http://192.168.56.102:9090/
6、查看targets浏览器访问 http://192.168.56.102:9090/targets/
7、查看指标浏览器访问 http://192.168.56.102:9090/metrics/
node exporter1、登录dockerhub查看需要的node exporter。
2、下载node-exporter镜像（以v1.0.0为例）docker pull prom/node-exporter:v1.0.0
3、启动node exporter
docker run --name=node-exporter -d \-p 9100:9100 \docker run --name=node-exporter -d \  -p 9100:9100 \  --net="host" \  --pid="host" \  -v "/:/host:ro,rslave" \  prom/node-exporter:v1.0.0 \  --path.rootfs=/host

promserver收集exporter数据1、修改prometheus.yml
global:  scrape_interval: 15s #默认采集监控数据时间间隔  external_labels:    monitor: 'my-monitor'scrape_configs:  #监控对象设置  - job_name: prometheus #任务名称    scrape_interval: 5s #每隔5s获取一次监控数据    static_configs: #监控对象地址      - targets: ['127.0.0.1:9090']  # 将自己加入到监控对象中      - targets: ['192.168.56.102:9100']        labels:          group: 'client-node-exporter'

2、重新加载配置文件curl -X POST http://localhost:9090/-/reload然而我重新加载配置文件并不生效，最后重启了prometheus server。
3、查看targets浏览器访问 http://192.168.56.102:9090/targets/
push gatewayPrometheus采集数据是用的pull方式，prometheus配置文件设置的5秒就是采集数据的频率。但是有些数据并不适合采用这样的方式，对这样的数据可以使用Push Gateway服务。PushGateway比较适合临时作业和批处理作业，由于这些作业是short-lived的，如果采用pull的模式，可能在prometheus采集之前，作业已经执行结束。pushgateway相当于一个暂存器，这些临时作业将metrics数据缓存到pushgateway中，然后等待Prometheus来pull数据。
1、登录dockerhub查看需要的pushgateway。
2、下载pushgateway镜像（以v1.1.0为例）docker pull prom/pushgateway:v1.1.0
3、启动push gateway
docker run --name=pushgateway -d \-p 9091:9091 \prom/pushgateway:v1.1.0

4、测试服务浏览器访问 http://192.168.56.102:9091/#
5、推送数据给push gateway
echo "exam_metric 100" | curl --data-binary @- http://127.0.0.1:9091/metrics/job/examcat &lt;&lt;EOF | curl --data-binary @- http://127.0.0.1:9091/metrics/job/exam/instance/testchinese 120math 150english 140EOF


promserver收集pushgateway数据1、修改prometheus.yml文件
global:  scrape_interval: 15s #默认采集监控数据时间间隔  external_labels:    monitor: 'my-monitor'scrape_configs:  #监控对象设置  - job_name: prometheus #任务名称    scrape_interval: 5s #每隔5s获取一次监控数据    static_configs: #监控对象地址      - targets: ['127.0.0.1:9090']  # 将自己加入到监控对象中      - targets: ['192.168.56.102:9100']        labels:          group: 'client-node-exporter'      - targets: ['192.168.56.102:9091']        labels:          group: 'pushgateway'

2、重新加载配置或者重启promserver
3、在promserver查看数据
alertmanager1、登录dockerhub查看需要的alertmanager。
2、下载alertmanager镜像（以v0.15.0为例）docker pull prom/alertmanager:v0.15.0
高版本比如v0.20.0打开页面后会报错，Uncaught TypeError: Cannot read property ‘elmFs’ of undefined
3、创建配置文件alertmanager.yml
global:  resolve_timeout: 5mroute:  group_by: ['exam']  #与prometheus配置文件rules.yml中配置规则名对应  group_wait: 10s #报警等待时间  group_interval: 10s #报警间隔时间  repeat_interval: 1m #重复报警间隔时间  receiver: 'web.hook' #告警处理方式，我们这里通过web.hook方式，也可以配置成邮件等方式receivers:  - name: 'web.hook'    webhook_configs:      - url: 'http://192.168.56.102:8080/exam/test' #告警webhook地址，告警信息会post到该地址，需要编写服务接收该告警数据inhibit_rules:  - source_match:      severity: 'critical'    target_match:      severity: 'warning' #目标告警状态    equal: ['alertname', 'dev', 'instance']

4、启动push gateway
docker run --name=alertmanager -d \-p 9093:9093 \-v $(pwd)/alertmanager.yml:/etc/alertmanager/alertmanager.yml \prom/alertmanager:v0.15.0 --config.file=/etc/alertmanager/alertmanager.yml --storage.path=/alertmanager

5、测试服务浏览器访问 http://192.168.56.102:9093/
告警配置1、编辑rules.yml，设置报警规则
groups:  - name: exam    rules:      - alert: exam告警测试        expr: chinese &gt; 100 #语文成绩大于100告警，注：我们在pushgateway推送数据的时候，设置的是120，因此会触发告警        for: 1m        labels:          status: warning        annotations:          summary: "&#123;&#123;$labels.instance&#125;&#125;:语文成绩优秀! nb了!!!"          description: "&#123;&#123;$labels.instance&#125;&#125;: 语文成绩优秀! nbnbnb!!!"

2、编辑prometheus.yml配置文件，添加alertmanager配置和rules.yml文件
global:  scrape_interval: 15s #默认采集监控数据时间间隔  external_labels:    monitor: 'my-monitor'scrape_configs:  #监控对象设置  - job_name: prometheus #任务名称    scrape_interval: 5s #每隔5s获取一次监控数据    static_configs: #监控对象地址      - targets: ['127.0.0.1:9090']  # 将自己加入到监控对象中      - targets: ['192.168.56.102:9100']        labels:          group: 'client-node-exporter'      - targets: ['192.168.56.102:9091']        labels:          group: 'pushgateway'rule_files:  - /etc/prometheus/rules.yml   #告警规则文件路径alerting:   #告警管理器设置  alertmanagers:    - static_configs:      - targets: ['192.168.56.102:9093'] #告警信息会发送给alertmanager进一步处理

3、重新加载配置或者重启promserver
4、在prometheus alerts页面查看告警
或者在alertmanager alerts页面查看告警
告警通知处理alertmanager.yml文件中配置的告警方式是webhook，告警发送到 http://192.168.56.102:8080/exam/test ，因此，我们需要一个服务来接收处理这个告警。
1、安装golang环境，参考《CentOS7部署beego项目》golang安装一节
2、创建main.go
package mainimport (	"fmt"	"io/ioutil"	"github.com/gin-gonic/gin")func main() &#123;	r := gin.Default()	r.POST("/exam/test", func(c *gin.Context) &#123;		res, _ := ioutil.ReadAll(c.Request.Body)		fmt.Println(string(res)) //这里我们只简单打印告警信息		c.JSON(200, gin.H&#123;			"message": "alert message",		&#125;)	&#125;)	r.Run(":8080")&#125;

3、运行代码
go get github.com/gin-gonic/gingo run main.go
如上图，服务接收到了告警信息。
配置更多prometheus配置，参考CONFIGURATION 和 Prometheus 配置
后记以上，配置完成了promserver、exporter、pushgateway、alertmanager，跑通了数据的收集和显示，测试了告警信息的收集。本文就到这里，需要用到prometheus的其他内容时，再继续学习，比如thanos。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos</tag>
        <tag>监控</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker入门篇</title>
    <url>/dev-docker-start/</url>
    <content><![CDATA[容器简介奔驰车生产好之后，经过集装箱封装，从纽约运送到了上海，开箱后奔驰车可以跑在上海的大街上。软件在环境A开发好之后，经过集装箱封装，从环境A运送到了环境B，开箱后软件可以跑在环境B。这种软件集装箱技术，就是容器技术，英文叫做 Linux Container。
起初，容器技术做的最好的就是Docker，Docker也几乎就是容器的代名词，后来CoreOS、Mesos、Containerd也都相继发展壮大。为了统一容器标准，OCI（Open Container Initiative）组织成立了，并于2016年4月推出了第一个开放容器标准，标准主要包括image镜像标准和runtime运行时标准。
Docker简介
Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 

Docker通常用于如下场景：

web应用的自动化打包和发布。
自动化测试和持续集成、发布。
在服务型环境中部署和调整数据库或其他的后台应用。

Docker系统有两个程序：docker服务端和docker客户端。其中docker服务端是一个服务进程，管理着所有的容器。docker客户端则扮演着docker服务端的远程控制器，可以用来控制docker的服务端进程。大部分情况下，docker服务端和客户端运行在一台机器上。


Docker安装以centos7系统为例。
1、安装yum-utilsyum install yum-utils
2、添加docker-ce源
# 官方源yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo# 阿里云源，国内更快yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

3、更新yum包yum makecache fast
4、安装docker-ceyum install docker-ce
5、启动docker-ce并设置开机启动
systemctl start dockersystemctl enable docker

镜像加速器DaoCloud使用 Docker 的时候，需要经常从官方获取镜像，但是拉取镜像的过程非常耗时，严重影响使用 Docker 的体验。因此DaoCloud推出了加速器工具解决这个难题，通过智能路由和缓存机制，提升了国内网络访问 Docker Hub 的速度，目前已经拥有了广泛的用户群体，并得到了 Docker 官方的大力推荐。
1、访问DaoCloud官网，注册一个账号。
2、访问配置 Docker 加速器，可以获得一个专属加速地址（每次访问都会获得不同的地址）。
3、参考Docker 加速器，创建或修改 /etc/docker/daemon.json，内容为：
&#123;    "registry-mirrors": [        "http://2fd0f33c.m.daocloud.io"    ],    "insecure-registries": []&#125;

4、重启docker
systemctl daemon-reloadsystemctl restart docker

5、验证配置docker info
阿里云除了使用DaoCloud的镜像加速器，还可以使用阿里云的镜像加速器。
1、访问阿里云镜像加速器，得到一个专属的加速地址。
2、对于CentOS7平台，创建或修改 /etc/docker/daemon.json，内容为：
&#123;  "registry-mirrors": ["https://7ifvshz6.mirror.aliyuncs.com"]&#125;

3、重启docker
systemctl daemon-reloadsystemctl restart docker

4、验证配置docker info
腾讯云修改 /etc/docker/daemon.json 配置为：
&#123;   "registry-mirrors": [       "https://mirror.ccs.tencentyun.com"  ]&#125;
其他步骤同上。
Docker使用版本和帮助# 查看版本docker version# 查看帮助docker# 查看docker start帮助docker start --helpdocker help start

镜像查找下载github是存储代码的仓库，而docker hub是存储docker镜像的仓库。
docker hub上面的镜像命名方式为：&lt;username&gt;/&lt;imagename&gt;:&lt;tag&gt;，比如voidking/nginx:v1.0其中 tag 可以省略，省略则默认使用 latest 。
有一类比较特殊的镜像，经过官方的验证值得信任，命名方式为：&lt;imagename&gt;:&lt;tag&gt;，比如 busybox:1.25
1、查找镜像方法一：在docker hub上查找镜像，直接搜索即可方法二：使用命令行的工具搜索，例如搜索 busybox 镜像  
docker search busyboxcurl -s "https://registry.hub.docker.com/v1/repositories/busybox/tags" | jq -r .[].name

2、通过docker命令下载镜像，例如下载 busybox 镜像docker pull busybox:1.25
3、查看本地镜像docker images
helloworlddocker镜像运行起来，便会生成一个docker容器。docker容器可以理解为在沙盒中运行的进程，这个沙盒包含了该进程运行所必须的资源，包括文件系统、系统类库、shell 环境等等。这个沙盒默认不会运行任何程序，我们需要指定一个程序在启动容器时运行。这个程序对应的进程是该容器的1号进程，当该进程结束的时候，容器也会完全停止。
看一个例子：docker run busybox:1.25 echo &quot;helloworld&quot;busybox:1.25 镜像作为模板启动一个容器，容器中运行echo程序，参数为”helloworld”。容器启动后，输出了 helloworld ，然后就停止了。这是因为，1号进程（echo进程）停止了，容器也随之停止。
启动容器一般的容器，应该怎么启动呢？答：在启动容器时，指定一个长期运行的前台进程作为1号进程。例如：docker run --name vk-busybox -d busybox:1.25 sleep 3600以上命令的含义： 

docker run 表示启动一个容器
–name 指定容器名为 vk-busybox
-d 表示后台运行容器，并返回容器id
busybox:1.25 是镜像名
sleep 是1号进程，3600是sleep的参数

查看容器容器启动后，怎么查看这些容器？答：使用docker ps命令或者docker inspect命令。  
1、查看运行中的容器docker ps
2、查看历史容器docker ps -l
3、查看所有容器docker ps -a
4、查看容器启动命令docker ps --no-trunc
5、查看容器详细信息  
docker inspect &lt;container_name&gt;docker inspect &lt;container_id&gt;

进入容器容器启动后，怎样进入一个容器？答：使用docker exec命令。docker exec -it vk-busybox /bin/sh
修改容器并保存进入容器后，我们对容器进行了修改，比如创建了一个文件 /tmp/test.txt 。现在想要把这个容器保存成镜像，方便以后复用，该怎么操作？答：使用docker commit命令，类似于git commit。  
docker commit vk-busybox voidking/vk-busybox:v1.0以上命令，把修改后的 vk-busybox 容器保存成了镜像 voidking/vk-busybox:v1.0 。docker commit时，除了使用容器名称，也可以使用容器id。
分享镜像我们在本地保存了 voidking/vk-busybox:v1.0 镜像，怎样把它分享出去？答：使用docker push命令，类似于git push。docker push voidking/vk-busybox:v1.0该命令把 voidking/vk-busybox:v1.0 镜像推送到 docker hub，所属账户为 voidking 。  
记得push前，需要docker login，进行登录鉴权。
删除容器和镜像删除单个容器  
docker rm &lt;container_name&gt;docker rm &lt;container_id&gt;

删除所有容器docker rm $(docker ps -a -q)
删除单个镜像  
docker rmi &lt;image_name&gt;docker rmi &lt;image_id&gt;docker rmi &lt;image_name&gt; -fdocker rmi &lt;image_id&gt; -f

删除所有镜像docker rmi $(docker images -q)
删除停止的容器、删除没有被使用的网络、删除没有被使用的镜像、删除构建产生的缓存
docker system prunedocker system prune -adocker system prune -f

删除以上内容，同时删除没有被使用的volumesdocker system prune -a --volumes
删除没有被使用的volumesdocker volume prune
删除停止的容器docker container prune
删除没有被使用的镜像docker image prune
删除没有被使用的网络docker network prune
删除所有悬空镜像（没有名称的镜像），不删除未使用镜像docker rmi $(docker images -f &quot;dangling=true&quot; -q)
删除未使用镜像和悬空镜像docker rmi $(docker images -q)
删除没有被容器使用的卷docker volume rm $(docker volume ls -qf dangling=true)
删除所有已退出的容器docker rm -v $(docker ps -aq -f status=exited)
删除所有状态为dead的容器docker rm -v $(docker ps -aq -f status=dead)
拷贝文件怎样在宿主机和容器之间互相拷贝文件？答：使用docker cp命令。docker cp /tmp/test.txt vk-busybox:/tmp
查看容器id和容器进程查看容器进程ID  
docker psdocker top vk-busyboxdocker inspect vk-busybox | grep pid -i

查看容器进程的namespace  
ll /proc/$$/nsll /proc/&lt;pid&gt;/ns

在容器net namespace执行命令（需要宿主机上有route命令）  
nsenter -t &lt;pid&gt; -n ip addnsenter -t &lt;pid&gt; -n route -nnsenter -t &lt;pid&gt; -n iptables -A OUTPUT -p tcp --dport 7535 -j DROP

Docker镜像迁移在不联网的情况下，怎样把 docker image 分享给局域网的其他用户？
单个镜像本机有镜像 busybox:1.25，现在想要把这个镜像导出到其他机器。
1、导出镜像docker save -o busybox.tar busybox:1.25
2、导入镜像docker load &lt; busybox.tar
全部镜像假设本机有很多个镜像，现在想要把些镜像全部导出到其他机器。
1、导出所有镜像docker save $(docker images | grep -v REPOSITORY | awk &#39;BEGIN{OFS=&quot;:&quot;;ORS=&quot; &quot;}{print $1,$2}&#39;) -o all.tar
2、导入镜像docker load -i all.tar
书签什么是Docker?
docker入门教程
Docker入门实战
中国第一套Docker实战案例视频课程（入门到高级）
Docker实战案例源码
Docker实战案例文档
微信公众号微信公众号的二维码，文章推送 + 资源分享，一起学习进步。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>centos</tag>
      </tags>
  </entry>
  <entry>
    <title>初见Markdown</title>
    <url>/dev-first-see-markdown/</url>
    <content><![CDATA[什么是 MarkdownMarkdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，粗体 或者 斜体 某些文字，更棒的是，它还可以
书写一个质能守恒公式[^LaTeX]$$E=mc^2$$
高亮一段代码[^code]@requires_authorizationclass SomeClass:    passif __name__ == '__main__':    # A comment    print 'hello world'

高效绘制 流程图st&#x3D;&gt;start: Startop&#x3D;&gt;operation: Your Operationcond&#x3D;&gt;condition: Yes or No?e&#x3D;&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op

高效绘制 序列图Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!

绘制表格


项目
价格
数量



计算机
$1600
5


手机
$12
12


管线
$1
234


更详细语法说明想要查看更详细的语法说明，可以参考我们准备的 Cmd Markdown 简明语法手册，进阶用户可以参考 Cmd Markdown 高阶语法手册 了解更多高级功能。
总而言之，不同于其它 所见即所得 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。

什么是 Cmd Markdown您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 编辑/发布/阅读 Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。
1. 实时同步预览我们将 Cmd Markdown 的主界面一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！
2. 编辑工具栏也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 编辑区 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。

3. 编辑模式完全心无旁骛的方式编辑文字：点击 编辑工具栏 最右测的拉伸按钮或者按下 Ctrl + M，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！
4. 实时的云端文稿为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 编辑工具栏 的最右侧提示 已保存 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。
5. 离线模式在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。
6. 管理工具栏为了便于管理您的文稿，在 预览区 的顶部放置了如下所示的 管理工具栏：

通过管理工具栏可以：
 发布：将当前的文稿生成固定链接，在网络上发布，分享 新建：开始撰写一篇新的文稿 删除：删除当前的文稿 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地 列表：所有新增和过往的文稿都可以在这里查看、操作 模式：切换 普通/Vim/Emacs 编辑模式
7. 阅读工具栏
通过 预览区 右上角的 阅读工具栏，可以查看当前文稿的目录并增强阅读体验。
工具栏上的五个图标依次为：
 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落 视图：互换左边编辑区和右边预览区的位置 主题：内置了黑白两种模式的主题，试试 黑色主题，超炫！ 阅读：心无旁骛的阅读模式提供超一流的阅读体验 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境
8. 阅读模式在 阅读工具栏 点击  或者按下 Ctrl+Alt+M 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。
9. 标签、分类和搜索在编辑区任意行首位置输入以下格式的文字可以标签当前文档：
标签： 未分类
标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：

10. 文稿发布和分享在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击  (Ctrl+Alt+P) 发布这份文档给好友吧！

再一次感谢您花费时间阅读这份欢迎稿，点击  (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！
作者 @ghosert2014 年 07月 07日    
[^LaTeX]: 支持 LaTeX 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 MathJax 参考更多使用方法。
[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，四十一种主流编程语言。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>遗传规划</title>
    <url>/dev-genetic-programming/</url>
    <content><![CDATA[来龙去脉在什么情况下，存在什么问题，遗传规划是从什么样的视角来解决问题的？（整体介绍，通常10分钟左右）


什么是进化算法进化算法，又称演化算法 ，是一个算法集合，包括遗传算法、遗传规划、进化策略和进化规划4种典型方法。进化算法借鉴了进化生物学的遗传、突变、自然选择以及杂交等现象，利用“优胜劣汰”，来处理最优化问题。
由于遗传算法、进化规划和进化策略是不同领域的研究人员分别独立提出的，在相当长的时期里相互之间没有正式沟通。直到90年代，才有所交流。
他们发现彼此的基本思想具有惊人的相似之处，于是提出将这类方法统称为“进化计算” ( Evolutionary Computation ) 。
什么是遗传规划遗传规划，又称遗传编程，是进化算法的一个分支，与遗传算法中每个个体是一段染色体编码不同，它的个体是一个计算机程序。
首先利用计算机随机生成的千百万个程序，然后根据一个程序完成给定的任务的能力来确定某个程序的适合度，应用达尔文的自然选择（适者生存）确定胜出的程序，计算机程序间也模拟两性组合，变异，基因复制，基因删除等代代进化，直到达到预先确定的某个中止条件为止。
遗传规划与遗传算法的关系遗传规划是遗传算法的改进算法。
遗传算法使用字符串作为染色体去表达所研究的问题，而且字符串的长度常常是固定的。然而，现实中的问题往往很复杂，有时不能用简单的字符串表达问题的所有性质，于是就产生了遗传规划。遗传规划用广义的计算机形式表达问题，它的结构和大小都是可以变化的，从而可以更灵活地表达复杂的事物性质，更有利于算法收敛到全局最优解，同时也弥补了遗传算法在某些领域得不到有效应用的不足。
主要内容基本概念（最好举例说明）、遗传规划描述、遗传规划实例、遗传规划特点等。（细节介绍，通常20分钟左右）
主要研究问题利用文献法来总结各种问题的研究现状，把你阅读的文献（至少3篇）提前3天发到云盘中。（重点内容介绍，通常讲解20分钟左右）a)编码问题：比如，在哪年由谁提出了怎样的编码方案？性能如何？主要特点是什么？主要用来解决哪些类问题等。b)参数设置问题：比如，各种操作的参数选择方法等。c)各种启发式实现方法：比如，有记忆的遗传规划等。d)… …
应用领域利用文献法来总结遗传规划各种领域的应用现状，把你阅读的文献（至少3篇）提前3天发到云盘中. （重点内容介绍，通常讲解20分钟左右），比如，a)在哪些领域的哪些方面应用了遗传规划？b)为什么选用这个算法？具体如何实现的？c)性能如何？存在怎样的问题？改进方向如何？
进化算法应用1、结构性优化。通常，工程技术的优化包括结构优化和参数优化。对于后者，人们已经成功地使用了许多方法，如运筹学、数理统计、有限元等数值计算。然而对于结构优化，还缺乏成熟、有效的方法。近年来，人们运用进化算法，成功解决了建筑框架结构、飞机结构设计、电网及管网等网络结构等结构型问题，充分显示进化算法在这一领域的广阔引用前景。
2、人工智能。进化算法继模糊数学、专家系统、人工神经网络之后，成为处理人工智能的又一个有力工具。许多研究工作者利用这种新技术，从事机器学习、自动程序设计、聚类分析、博弈对策等工作。在知识工程方面，进化算法发挥越来越重要的作用。
3、复杂问题的优化。当所要解决的问题具有非线性、多峰值、不确定性时，使用传统的优化方法常常不能奏效。进化算法由于是一种黑箱式的框架型技术，不要求有明确的因果关系数学表达式，因此它是解决这类问题的有力工具，可以解决诸如液体流动、气候变化以及军事战略等非线性动态系统问题。
4、复杂系统分析。多年来，人们应用进化算法从事聚类分析、模式识别、图像处理、调度组织等工作，将表面上杂乱无章的复杂事物条理化。对于这类复杂系统的分析和归纳，进化算法具有很大的引用价值。
5、综合应用。随着科学技术的发展，各种学科不断交叉渗透，相互促进。同样，进化算法也要和其他技术手段相结合，各自发挥特长，综合解决问题。例如，人们已将遗传算法和人工神经网络相结合，成功地解决了机器学习等问题。
由于进化算法具有广阔的应用范围，我们无法一一列举具体的应用领域，只能概括地指明应用方向。随着时间的推移，它的应用范围还会不断扩大。
遗传算法应用1、函数优化是遗传算法的经典应用领域;
2、组合优化实践证明，遗传算法对于组合优化中的NP完全问题非常有效;
3、自动控制如基于遗传算法的模糊控制器优化设计、基于遗传算法的参数辨识、利用遗传算法进行人工神经网络的结构优化设计和权值学习等;
4、机器人智能控制遗传算法已经在移动机器人路径规划、关节机器人运动轨迹规划、机器人逆运动学求解、细胞机器人的结构优化和行动协调等;
5、组合图像处理和模式识别目前已在图像恢复、图像边缘持征提取、几何形状识别等方面得到了应用;
6、人工生命基于遗传算法的进化模型是研究人工生命现象的重要理论基础，遗传算法已在其进化模型、学习模型、行为模型等方面显示了初步的应用能力；
7、遗传程序设计Koza发展了遗传程序设计的慨念，他使用了以LISP语言所表示的编码方法，基于对一种树型结构所进行的遗传操作自动生成计算机程序;
选用和实现1、为什么选用遗传规划？为了解决结构性优化问题等传统方法解决不了的问题。
2、实现的例子以曲线拟合为例，说明遗传规划的基本原理。图1-5的曲线表示实验的结果，现在要确定实验结果的的函数关系y=f(x)。
遗传规划的工作原理大致如下：（1）选择初始结构。采用随机产生的方法，假设y=f(x)的表达式有下述四种：$$1) y = A + Bx$$$$2) y = A + Bx + Cx^2$$$$3) y = xsinx$$$$4) y = Dxsinx$$
（2）计算适应度。将不同的$x_i$带入四种初始表达式中，从而得出一组不同$y_j$，将计算所得的$y_j$与实验数据$y_i$相比较，可以衡量初始表达式的优劣。假设第3种表达式最佳，第1种表达式最差。
（3）复制。根据优胜劣汰的原则，复制效果最佳的第3种表达式，淘汰效果最差的第1种表达式，于是，新一代的表达式由下述方程组成：$$1) y = xsinx$$$$2) y = A + Bx + Cx^2$$$$3) y = xsinx$$$$4) y = Dxsinx$$
（4）交换。为了产生新的表达式，需要使用交换。采用随机选择的方法，假设第2、3种表达式进行交换，交换位置在第一项，则新的表达式为：$$1) y = xsinx$$$$2) y = x + Bx + Cx^2$$$$3) y = Asinx$$$$4) y = Dxsinx$$
（5）突变。在遗传规划中也可以采用突变产生新个体。例如，将表达式中的$sinx$变为$cosx$，不过，遗传规划中的突变远不及在遗传算法中那样重要。
上述（2）~（5）反复执行，使函数表达式y=f(x)不断变化，逐步得到所要求的表达式。
性能、问题和改进1、性能没有找到具体性能评估数据，猜测是用时间和适应度两方面进行衡量。
2、问题（1）求解的是一个描述问题的程序（或者说是一个算法）。（2）通常用树型结构来表示，描述相对复杂。（3）每一代的个体的长度（深度）一般是不同的，即使在同一代中的个体之间的长度（深度）也是不同的。（4）所消耗的资源是不可控的（这里所指的不可控是指不能精确的描述），需要消耗大量的内存空间，因而每一代的进化都比较慢。
3、改进（1）确定初始群体规模的方法的改进。（2）编码技术和程序表达技术的改进。（3）复制、交换、突变等遗传操作的改进。（4）适应度的表达和计算的改进。（5）寻求其他有效的遗传算子，防止近缘杂交、过早收敛等弊病。
参考文档进化算法遗传算法遗传编程
]]></content>
      <categories>
        <category>专业</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>知识工程</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>Git实用命令</title>
    <url>/dev-git-command/</url>
    <content><![CDATA[Git简介
Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency.

Git是一个免费的开源分布式版本控制系统，旨在快速高效地管理项目的所有文件。Git中的项目被称为仓库(repository)，或者是代码库。
学习工作中，越来越习惯使用Git，本文记录一下常用的Git命令，方便以后查阅。参考文档：

Git - Documentation
阮一峰 Git 教程
常用 Git 命令清单
Git远程操作详解



初始配置用户名和邮箱1、全局配置
git config --global --listgit config --global user.name "voidking"git config --global user.email "voidking@qq.com"

2、针对单独项目配置
git config --listgit config user.name "haojin"git config user.email "voidking@vip.qq.com"
提交的时候，如果项目自身没有配置信息就会使用全局配置，有配置就会使用单独的配置信息。
免密上传下载本节以github为例，gitlab的配置方法类似。
使用ssh密钥1、生成ssh密钥ssh-keygen -t rsa -C &quot;voidking@qq.com&quot;，按3个回车，密码为空。
在C:\Users\Administrator\.ssh下，得到两个文件id_rsa和id_rsa.pub。需要注意的是，命令中的-C参数，后面跟的内容是注释。也就是说，内容随意，与github完全无关。
2、在github上添加ssh公钥打开id_rsa.pub，复制全文。访问github的 settings-ssh 页面，New SSH key，粘贴进去。
3、测试ssh git@github.com，提示：
The authenticity of host 'github.com (192.30.252.128)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,192.30.252.128' (RSA) to the list of known hosts.Hi voidking! You've successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.

4、指定ssh私钥方法一：修改 ~/.ssh/config 文件，添加：
host github.com  HostName github.com  IdentityFile ~/.ssh/id_rsa_github  User git

方法二：使用环境变量，比如：
GIT_SSH_COMMAND="ssh -i ~/.ssh/id_rsa_github -F /dev/null" git clone https://github.com/voidking/wecms.git

使用 access token1、生成access token访问github的 Personal access tokens 页面，Generate new token。Note输入 voidking-pc ，Select scope选择repo，然后点击Generate token。生成了一个token，保存它。
2、开启密码记录git config --global credential.helper store用户家目录下的 .gitconfig 文件末尾会添加：
[credential]    helper = store

3、记住密码再次使用git pull或者git push，系统会提示输入git用户名和密码，这里的密码输入access token即可，不要使用真实密码。系统会记住用户的access token，存储在用户家目录下的 .git-credentials 文件中。之后就不再需要输入git密码了。
使用代理如果克隆项目特别慢，自己又有科学上网的ssr，那么可以开启代理。
git config --global http.proxy 'socks5://127.0.0.1:1080' git config --global https.proxy 'socks5://127.0.0.1:1080'

关闭代理：
git config --global --unset http.proxygit config --global --unset https.proxy

clone代码# 普通克隆git clone https://github.com/voidking/voidking.git# 克隆并重命名为vkgit clone https://github.com/voidking/voidking.git vk# 使用access token克隆项目git clone https://&lt;gh_token&gt;@github.com/voidking/voidking.git

PS：下载失败问题解决 SSL certificate problem
git config --global http.sslVerify false

pull代码pull相关配置.git/config文件里，配置了remote和branch，以下为例。
[core]    repositoryformatversion = 0    filemode = false    bare = false    logallrefupdates = true    symlinks = false    ignorecase = true[remote "origin"]    url = https://github.com/voidking/voidking.git    fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"]    remote = origin    merge = refs/heads/master
拉取项目的时候，会根据这个配置来拉取。
pull相关命令# 查看本地分支追踪的远程分支# 一个本地分支可以追踪多个远程分支git branch -vv# 格式说明git pull &lt;远程仓库名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;# 拉取当前分支追踪的唯一远程分支git pull# 拉取当前分支追踪的origin/master分支git pull origin mastergit pull origin# 拉取remote origin的next分支，与本地master合并git pull origin next:master# 拉取origin主机的next分支，与当前分支合并git pull origin next

分支操作1、查看分支
git branch -a

2、切换分支和新建分支
# 切换远程分支git checkout origin/branch_name# 新建与当前分支相同的分支git checkout -b new_branch# 新建与远程分支相同的分支git checkout -b new_branch origin/branch_name

commit代码单行commitgit add .git commit -m "something"

多行commitgit add .git commit -m "dquote&gt; &lt;类型&gt;[可选的作用域]: &lt;描述&gt;dquote&gt;dquote&gt; [可选的正文]dquote&gt;dquote&gt; [可选的脚注]dquote&gt; "

查看commit记录1、最常用查看commit记录git log只可以查看到当前分支的commit日志，而且不能查看已经删除了的commit操作。
2、查看单个文件commit记录git log filename
3、查看全局日志
git refloggit log -g
可以查看所有分支的所有操作记录，包括reset操作、checkout操作、已经删除了的commit操作等等。
4、查看所有分支的commit
git log --graph --pretty=oneline --abbrev-commit

查看变更commit之前commit之前，查看修改了哪些文件。git status
commit之后commit之后，获取最近一次修改的文件列表git diff --name-only HEAD~ HEAD
获取两次commit之间修改的文件git diff --name-only &lt;commit-1&gt; &lt;commit-2&gt;
push代码push分支# 格式说明git push &lt;远程仓库名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;# 上传代码到唯一远程追踪分支git push# 上传到指定远程追踪分支git push origin HEAD:branch_name

同时push多个git仓库1、编辑 .git/config，添加
[remote "all"]    url = https://github.com/voidking/hexo-backup    url = https://gitee.com/voidking/hexo-backup

2、push代码git push all
push到其他git仓库需求：已有仓库voidking，包含多个分支。现在想要把该仓库根据不同的分支拆分成多个项目，于是创建项目voidkingA和voidkingB。接下来，该怎么把voidking的不同分支，push到voidkingA和voidkingB呢？
cd voidkinggit checkout -b voidkingA origin/branchAgit push --force --quiet "https://voidking:xxxxxx@github.com/voidking/voidkingA" voidkingA:maingit checkout -b voidkingB origin/branchBgit push --force --quiet "https://voidking:xxxxxx@github.com/voidking/voidkingB" voidkingB:main

git push 403公司电脑（win10系统）以前有一个用户，github账号是haojin。现在电脑分配给我使用，但是，我的github账号是voidking，在我git push的时候报错403。
$ git pushremote: Permission to voidking/hexo-back-up.git denied to haojin.fatal: unable to access 'https://github.com/voidking/hexo-back-up.git/': The requested URL returned error: 403
哪怕重置了全局设置的user.name和user.email，依然会报错。原因：win10系统自动保存用户凭据，gitpush的时候默认使用以前的用户凭据。解决办法：Win+X，搜索，控制面板，用户账户，凭据管理器，管理Windows凭据，普通凭据，删除github的凭据即可。
版本回退版本回退常用git reset和git revert命令，这两个命令都是作用于当前分支（HEAD所在的分支）。git reset 是把HEAD向后移动了一下，而git revert是HEAD继续前进，只是新的commit的内容和要revert的内容正好相反，能够抵消要被revert的内容。
reset1、每个文件单独版本回退
git statusgit loggit reset  1fe37e1bcbb894a1b594cf405ae31880cbaa6cd7 filepath/filenamegit checkout filepath/filename

2、全部文件版本回退
git reset --hard 1fe37e1bcbb894a1b594cf405ae31880cbaa6cd7

3、远程仓库回退
git reset --hard 1fe37e1bcbb894a1b594cf405ae31880cbaa6cd7git push -f

4、回退后回退reset后，回退版本之后的commit操作记录，都被删除掉了。如果回退过之后又后悔了，那么，需要查看全局日志，然后再次执行reset操作。
git refloggit reset a246dcd --hard

需要注意的是，版本回退，我们没有使用git checkout。假设当前在bugFix分支，使用git checkout，理论上输入如下命令：
git refloggit checkout a246dcd

这时，输入git log，发现版本完美回退了。但是，这只是假象，输入git branch -a，发现HEAD从bugFix分支切换到了a246dcd那个commit。而bugFix分支，没有进行任何改变。所以，我们不使用git checkout进行版本回退，而是使用它进行历史版本的查看。
revert1、全部文件版本回退
git revert cf000

2、远程仓库回退
git push origin HEAD:branch_name

回退过之后又后悔了，那么，执行reset操作即可。
git loggit reset a246dcd --hard

git stash本地有修改，但是想拉取远端仓库上的最新代码到本地。
# 保存stashgit stashgit stash save "something"# 拉取最新代码git pull# 查看stashgit stash list# 弹出之前的修改git stash pop# 弹出之前的修改（只能恢复一次）git stash pop stash@&#123;num&#125;# 弹出之前的修改（可恢复多次）git stash apply stash@&#123;num&#125;# 删除stashgit stash drop stash@&#123;num&#125;# 删除所有stashgit stash clear

合并分支场景一：基于 master 拉出来一个开发分支 dev，在 dev 上开发了一段时间后要把 master 分支提交的新内容更新到 dev 分支。操作：切换到 dev 分支，使用 git rebase master
场景二：dev 分支开发完成了之后，要合并到 master 上。操作：切换到 master 分支，使用 git merge dev
合并时难免代码冲突，git会将冲突的代码用 &lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标识出来，方便我们手动解决。在冲突标记中，=======之前表示的是ours分支，之后表示theirs分支。
如果想要保留两个分支中的某一个，可以使用 git chekout --ours &lt;fileName&gt; 或者 git checkout --theirs &lt;fileName&gt;。
对于merge和rebase来说，这两个选项对应的分支正好是相反的。在使用 merge 时，ours指的是当前分支（master），theirs指的是要被合并的分支（dev）。而在 rebase 时，theirs指的是当前分支（dev），ours指向（master）。
解决冲突流程示例：
git statusgit checkout --ours .git add .git rebase --continuegit rebase --skipgit statusgit checkout --theirs .git add .git rebase --continue

统计# 统计个人代码量git log --author="voidking" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc &#125;' -# 统计每个人代码量git log --format='%aN' | sort -u | while read name; do echo -en "$name\t"; git log --author="$name" --pretty=tformat: --numstat | awk '&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf "added lines: %s, removed lines: %s, total lines: %s\n", add, subs, loc &#125;' -; done# 统计提交者前五git log --pretty='%aN' | sort | uniq -c | sort -k1 -n -r | head -n 5# 统计提交者数量git log --pretty='%aN' | sort -u | wc -l# 统计提交数git log --oneline | wc -l# 添加或修改的代码行数git log --stat|perl -ne 'END &#123; print $c &#125; $c += $1 if /(\d+) insertions/'


]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang包管理工具</title>
    <url>/dev-golang-gpm/</url>
    <content><![CDATA[包管理工具简介大一点的项目，通常会依赖很多第三方包。Golang把所有的第三方包都放在GOPATH/src目录下，且每个包仅保留一个版本。如果两个项目依赖不同版本的第三方包，就会产生问题。
为了解决这个问题，go在1.5版本引入了vendor属性（默认关闭），并在1.6版本中默认开启了vendor属性。简单来说，vendor属性就是让go编译时，优先从项目源码树根目录下的vendor目录查找代码（可以理解为切了一次GOPATH），如果vendor中有，则不再去GOPATH中去查找。
但是vendor目录又带来了新的问题：（1）vendor目录中依赖包没有版本信息。这样依赖包脱离了版本管理，对于升级、问题追溯，会有点困难。（2）如何方便的得到本项目依赖了哪些包，并方便的将其拷贝到vendor目录下？
为了解决这些问题，开发者在vendor基础上开发了多个管理工具，比较常用的有godep、govendor、glide，以及官方的dep和gomod。下面来学习一下godep、govendor和gomod，更多内容参考go依赖包管理工具对比、golang包管理解决之道——go modules初探、再探go modules：使用与细节。


理论篇godepgodep的使用者众多，如docker、kubernetes、coreos等go项目很多都是使用godep来管理其依赖，当然原因可能是早期也没的工具可选。
godep早期版本并不依赖vendor，所以对go的版本要求很松，go 1.5之前的版本也可以用，只是行为上有所不同。在vendor推出以后，godep也改为使用vendor了。
godep使用很简单，当项目编写完成，使用GOPATH的依赖包测试没问题的时候，执行godep save，该命令会做两件事：（1）扫描项目的代码，将项目依赖的包及该包的版本号（即git commit）记录到Godeps/Godeps.json文件中。（2）将依赖的包从GOPATH/src中拷贝到vendor目录（忽略依赖包的.git目录）。对于不支持vendor的早期版本，则会拷贝到Godeps/_workspace/里。
其他命令：
# 安装go get -u -v github.com/tools/godep# 安装新的包go get github.com/voidking/k8s-client-goimport "github.com/voidking/k8s-client-go"godep save# 更新依赖包go get -u github.com/voidking/k8s-client-gogodep update github.com/voidking/k8s-client-go# orgodep update github.com/voidking/...# 下载godeps.json里的包到GOPATH/srcgodep restore

govendorgovendor是在vendor之后出现的，功能相对godep多一点，不过就核心问题的解决来说基本是一样的。govendor生成vendor目录的时候需要2条命令：govendor init生成vendor/vendor.json，此时文件中只有本项目的信息。govendor add +external更新vendor/vendor.json，并拷贝GOPATH下的第三方包到vendor目录中。
其他命令：
# 安装go get -u github.com/kardianos/govendor# 获取指定版本的包govendor fetch golang.org/x/net/context@v1# 查看依赖的包govendor list# 查看哪些包使用了fmtgovendor list -v fmt

gomodgo modules随着golang1.11的发布和我们见面了，这是官方提倡的新的包管理，乃至项目管理机制，可以不再需要GOPATH的存在。
现在modules机制仍在早期阶段，所以golang提供了一个环境变量“GO111MODULE”，默认值为auto，如果当前目录里有go.mod文件，就使用go modules，否则使用旧的GOPATH和vendor机制，因为在modules机制下go get只会下载go modules，这一行为会在以后版本中成为默认值，这里我们保持auto即可，如果你想直接使用modules而不需要从GOPATH过度，那么把“GO111MODULE”设置为on。
modules和传统的GOPATH不同，不需要包含例如src，bin这样的子目录，一个源代码目录甚至是空目录都可以作为module，只要其中包含有go.mod文件。
1、启用modules机制
# linux and macexport GO111MODULE=on# windows powershell$env:GO111MODULE = "on"

2、初始化test项目为modulego mod init test初始化之后，目录下会自动生成go.mod文件。当我们使用go build，go test以及go list时，go会自动得更新go.mod文件，将依赖关系写入其中。
3、整理依赖go mod tidy -v

这条命令会自动下载依赖的module到cache，清除无用的module。
生成go.mod的require部分，和go.sum文件。go.sum是一个构建状态跟踪文件，它会记录当前module所有的顶层和间接依赖，go modules根据这些记录去寻找对应的依赖。
依赖的module下载到GOPATH/pkg/cache/和GOPATH/pkg/mod/目录下。

4、Goland启用gomodFile，Settings，Go，Go Modules，勾选Enable Go Modules(vgo) integration，Apply。
其他命令：
# 帮助go help mod# 已有go.mod，下载依赖到cachego mod download# 拷贝依赖到vendor（没有则先下载）go mod vendor# 清空cachego clean -modcache

gomod实践篇安装client-go假设一个项目依赖client-go，那么参考官方说明进行安装。
1、查看k8s版本kubectl versionClient Version表示kubectl的版本，Server Version表示apiserver的版本（假设版本为v1.15.0）。
2、查找对应版本的client-go在kubernetes/client-go上查找k8s v1.15.0对应的client-go版本，找到版本为12.0
3、安装对应版本的client-gogo get k8s.io/client-go/12.0/kubernetes这里有个坑，国内无法访问k8s.io，需要科学上网（恰好我的搬瓦工服务器也访问不到k8s.io）。因此，这里使用GOPROXY的方式来解决，参考一键解决 go get golang.org/x 包失败。
# export GOPROXY=https://goproxy.cnexport GOPROXY=https://goproxy.ioexport GO111MODULE=ongo get k8s.io/client-go/12.0/kubernetes


失败了，返回404，猜测是12.0版本在代理服务器不存在，使用另外一种下载方式。
go get k8s.io/client-go@kubernetes-1.15.0
此处下载了两个版本的client-go，我们使用v0.0.0版本。
4、安装client-go相关依赖client-go默认下载到$GOPATH/pkg/mod/k8s.io目录下，把k8s.io目录移动到$GOPATH/src目录下。然后把client-go@v0.0.0重命名为client-go，然后在client-go目录下执行安装依赖的命令：
export GOPROXY=https://goproxy.ioexport GO111MODULE=ongo mod vendor
完成之后，所有的依赖都下载到了client-go/vendor目录下，一个完整的client-go依赖库就准备好了。
依赖库版本管理client-go依赖库准备好了，但是另一个问题来了：假设项目vk-project依赖client-go和库A，client-go依赖库A，两个依赖库A版本不一致，那么vk-project在编译时，会同时依赖两个不同的库A，导致编译出的二进制包有问题。
此时，一个简单的办法是把GOPATH/src/k8s.io/client-go/vendor目录剪切覆盖vk-project/vendor目录，然后把GOPATH/src/k8s.io/client-go目录移动到vk-project/vendor/k8s.io/目录下。这么做的话，client-go就和自己的依赖是平级的存在了。
但是，这么做有另一个问题：依赖库版本没有记录。因为没有版本记录，那么在上传vk-project项目时，就要把依赖全部上传，否则别人下载了vk-project也没办法正确安装依赖。
这里，使用gomod进行依赖库版本管理。
go mod init vk-projectgo mod tidy -vgo mod vendor

上传代码时忽略vendor目录，在gitignore中添加：
/vendor/

安装依赖1、下载项目后，进入项目目录cd vk-project
2、下载依赖go mod download
3、拷贝依赖到vendor（可选）go mod vendor
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>k8s</category>
        <category>golang</category>
      </categories>
      <tags>
        <tag>golang</tag>
        <tag>client-go</tag>
        <tag>godep</tag>
        <tag>govendor</tag>
      </tags>
  </entry>
  <entry>
    <title>图像去噪</title>
    <url>/dev-gp-image-denoise/</url>
    <content><![CDATA[理论噪声噪声在图像上常表现为一引起较强视觉效果的孤立像素点或像素块。一般，噪声信号与要研究的对象不相关，它以无用的信息形式出现，扰乱图像的可观测信息。通俗的说就是噪声让图像不清楚。
图像常见噪声基本上有四种：高斯噪声，泊松噪声，乘性噪声，椒盐噪声。
令f(x,y)表示原始图象，g(x,y)表示图象信号，n(x,y)表示噪声。
根据噪声和信号的关系可将其分为三种形式：1、加性噪声，此类噪声与输入图象信号无关，含噪图象可表示为f(x,y)=g(x,y)+n(x,y)，信道噪声及光导摄像管的摄像机扫描图象时产生的噪声就属这类噪声；2、乘性噪声，此类噪声与图象信号有关，含噪图象可表示为f(x,y)=g(x,y)+n(x,y)g(x,y)，飞点扫描器扫描图象时的噪声，电视图象中的相关噪声，胶片中的颗粒噪声就属于此类噪声；3、量化噪声，此类噪声与输入图象信号无关，是量化过程存在量化误差，再反映到接收端而产生。
更多内容参考图像噪声简介和浅析“高斯白噪声”，“泊松噪声”，“椒盐噪声”的区别。


去噪图像的去噪处理方法基本上可分为空间域法和变换域法两大类。
空间域去噪方法的思想就是在原图像上对图像灰度值进行处理，通常采取“平均”或“平滑”的方法，将突变的噪声分量分散到周围像素中去，使图像变得较为平滑，降低噪声的影响。常用的空间域去噪方法有：均值去噪法，中值去噪法，高斯去噪法、维纳滤波去噪法等。
变换域去噪方法的思想是将原图像进行相关的变换，将图像信息变换到变换域中,再通过一定的方法来对图像信息进行处理，之后再通过反变换恢复图像信息，以达到图像去噪的目的。常用的变换域去噪方法有：傅里叶变换去噪方法，小波变换去噪方法等。
更多内容参考图像降噪和一文道尽传统图像降噪方法。
去噪方法又可以分为线性滤波和非线性滤波，更多内容参考什么是线性滤波、非线性滤波。
实践主要参考Image Denoising、Smoothing Images和OpenCV图像噪声与去噪函数方法对比使用介绍。
OpenCV中有多个可以降低图像噪声、对图像实现平滑滤波的函数，最常见的就是均值模糊与高斯模糊，它们都可以在一定程度上减低上述几种噪声，另外还有中值模糊、双边模糊、非局部去噪等函数方法可以使用，针对特定种类的噪声，使用有针对性函数与合理的参数可以取得较好的效果。

blur：对各种噪声都有一定的抑制作用。
GaussianBlur：对随机噪声比较好，对椒盐噪声效果不好。
medianBlur：对椒盐噪声效果比较好。
fastNlMeansDenoising：只支持灰度图像，非局部去噪，速度很慢，可以调参。
fastNlMeansDenoisingColored：同上，去噪针对彩色图像。

添加噪声参考Python+opencv3对图像添加高斯噪声和椒盐噪声，给图像添加椒盐噪声。
# -*- coding: utf-8 -*-import cv2import numpy as npimport matplotlib.pyplot as plt# 定义添加椒盐噪声的函数def SaltAndPepper(src,percetage):    SP_NoiseImg=np.copy(src)    SP_NoiseNum=int(percetage*src.shape[0]*src.shape[1])    for i in range(SP_NoiseNum):        randX=np.random.random_integers(0,src.shape[0]-1)        randY=np.random.random_integers(0,src.shape[1]-1)        if np.random.random_integers(0,1)==0:            SP_NoiseImg[randX,randY]=0        else:            SP_NoiseImg[randX,randY]=255    return SP_NoiseImgimg = cv2.imread('../image/test.jpg')GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)NoiseImage = SaltAndPepper(GrayImage,0.01)plt.subplot(121),plt.imshow(GrayImage,'gray')plt.subplot(122),plt.imshow(NoiseImage,'gray')plt.show()


简单去噪# -*- coding: utf-8 -*-import numpy as npimport cv2import matplotlib.pyplot as plt# 定义添加椒盐噪声的函数def SaltAndPepper(src,percetage):    SP_NoiseImg=np.copy(src)    SP_NoiseNum=int(percetage*src.shape[0]*src.shape[1])    for i in range(SP_NoiseNum):        randX=np.random.random_integers(0,src.shape[0]-1)        randY=np.random.random_integers(0,src.shape[1]-1)        if np.random.random_integers(0,1)==0:            SP_NoiseImg[randX,randY]=0        else:            SP_NoiseImg[randX,randY]=255    return SP_NoiseImg# 加载图片，灰度化，添加噪声img = cv2.imread('../image/test.jpg')GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)NoiseImage = SaltAndPepper(GrayImage,0.01)# 直接调用opencv函数dst = cv2.fastNlMeansDenoising(NoiseImage,10,7,21)plt.subplot(121),plt.imshow(NoiseImage,'gray')plt.subplot(122),plt.imshow(dst,'gray')plt.show()

dst=cv.fastNlMeansDenoising(src, h[, dst[, templateWindowSize[, searchWindowSize[, normType]]]])参数说明：

src：输入8位1通道，2通道，3通道或4通道图像。
dst：输出与src具有相同大小和类型的图像。
h：参数调节滤波器强度。大h值可以完美地消除噪点，但也可以消除图像细节，较小的h值可以保留细节，但也会保留一些噪点。
templateWindowSize：用于计算权重的模板修补程序的窗口大小，奇数，推荐值7像素。
searchWindowSize：窗口的像素大小，用于计算给定像素的加权平均值，奇数，推荐21像素。

均值滤波去噪法# -*- coding: utf-8 -*-import numpy as npimport cv2import matplotlib.pyplot as plt# 定义添加椒盐噪声的函数def SaltAndPepper(src,percetage):    SP_NoiseImg=np.copy(src)    SP_NoiseNum=int(percetage*src.shape[0]*src.shape[1])    for i in range(SP_NoiseNum):        randX=np.random.random_integers(0,src.shape[0]-1)        randY=np.random.random_integers(0,src.shape[1]-1)        if np.random.random_integers(0,1)==0:            SP_NoiseImg[randX,randY]=0        else:            SP_NoiseImg[randX,randY]=255    return SP_NoiseImgimg = cv2.imread('../image/test.jpg')GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)NoiseImage = SaltAndPepper(GrayImage,0.01)dst = cv2.blur(NoiseImage, (3,3))plt.subplot(121),plt.imshow(NoiseImage,'gray')plt.subplot(122),plt.imshow(dst,'gray')plt.show()


dst=cv.blur(src, ksize[, dst[, anchor[, borderType]]])参数说明：

src：输入的图片。
ksize：模糊内核大小。
anchor：锚点，默认值Point(-1，-1)表示锚点位于内核中心。
borderType：边界模式用于外推图像外的像素。

均值滤波是一种典型的线性滤波算法，主要是利用像素点邻域的像素值来计算像素点的值。其具体方法是首先给出一个滤波模板kernel，该模板将覆盖像素点周围的其他邻域像素点，去掉像素本身，将其邻域像素点相加然后取平均值即为该像素点的新的像素值，这就是均值滤波的本质。官方给出的kernel模板如下：
中值滤波去噪法# -*- coding: utf-8 -*-import numpy as npimport cv2import matplotlib.pyplot as plt# 定义添加椒盐噪声的函数def SaltAndPepper(src,percetage):    SP_NoiseImg=np.copy(src)    SP_NoiseNum=int(percetage*src.shape[0]*src.shape[1])    for i in range(SP_NoiseNum):        randX=np.random.random_integers(0,src.shape[0]-1)        randY=np.random.random_integers(0,src.shape[1]-1)        if np.random.random_integers(0,1)==0:            SP_NoiseImg[randX,randY]=0        else:            SP_NoiseImg[randX,randY]=255    return SP_NoiseImgimg = cv2.imread('../image/test.jpg')GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)NoiseImage = SaltAndPepper(GrayImage,0.01)dst = cv2.medianBlur(NoiseImage, 3)plt.subplot(121),plt.imshow(NoiseImage,'gray')plt.subplot(122),plt.imshow(dst,'gray')plt.show()

dst=cv.medianBlur(src, ksize[, dst])参数说明：

src：输入的图片。
ksize：窗口的尺寸。它必须是奇数且大于1，例如：3、5、7。

中值滤波法和均值滤波法类似，不同的是，它将每一像素点的灰度值设置为该点某邻域窗口内的所有像素点灰度值的中值。
高斯滤波去噪法# -*- coding: utf-8 -*-import numpy as npimport cv2import matplotlib.pyplot as plt# 定义添加椒盐噪声的函数def SaltAndPepper(src,percetage):    SP_NoiseImg=np.copy(src)    SP_NoiseNum=int(percetage*src.shape[0]*src.shape[1])    for i in range(SP_NoiseNum):        randX=np.random.random_integers(0,src.shape[0]-1)        randY=np.random.random_integers(0,src.shape[1]-1)        if np.random.random_integers(0,1)==0:            SP_NoiseImg[randX,randY]=0        else:            SP_NoiseImg[randX,randY]=255    return SP_NoiseImgimg = cv2.imread('../image/test.jpg')GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)NoiseImage = SaltAndPepper(GrayImage,0.01)dst = cv2.GaussianBlur(NoiseImage, (3,3), 0.8, 0.8)plt.subplot(121),plt.imshow(NoiseImage,'gray')plt.subplot(122),plt.imshow(dst,'gray')plt.show()

dst=cv.GaussianBlur(src, ksize, sigmaX[, dst[, sigmaY[, borderType]]])参数说明：

src：输入的图片。
ksize：高斯核大小。ksize.width和ksize.height可以不同，但​​它们都必须是正数和奇数。或者，它们可以为零，然后根据sigma计算。
sigmaX：X方向的高斯核标准偏差。
sigmaY：Y方向的高斯核标准偏差。如果sigmaY为零，则将其设置为等于sigmaX，如果两个sigma均为零，则分别从ksize.width和ksize.height计算。

高斯滤波的原理参考高斯滤波器详解。
傅里叶变换去噪# -*- coding: utf-8 -*-import numpy as npimport cv2import matplotlib.pyplot as plt# 定义添加椒盐噪声的函数def SaltAndPepper(src,percetage):    SP_NoiseImg=np.copy(src)    SP_NoiseNum=int(percetage*src.shape[0]*src.shape[1])    for i in range(SP_NoiseNum):        randX=np.random.random_integers(0,src.shape[0]-1)        randY=np.random.random_integers(0,src.shape[1]-1)        if np.random.random_integers(0,1)==0:            SP_NoiseImg[randX,randY]=0        else:            SP_NoiseImg[randX,randY]=255    return SP_NoiseImg# 加载图片，灰度化，添加噪声img = cv2.imread('../image/test.jpg')GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)NoiseImage = SaltAndPepper(GrayImage,0.01)# dftdft = cv2.dft(np.float32(NoiseImage),flags = cv2.DFT_COMPLEX_OUTPUT)dft_shift = np.fft.fftshift(dft)rows, cols = NoiseImage.shapecrow, ccol = int(rows/2) , int(cols/2)# create a mask first, center square is 1, remaining all zerosmask = np.zeros((rows,cols,2),np.uint8)mask[crow-30:crow+30, ccol-30:ccol+30] = 1# apply mask and inverse DFTfshift = dft_shift*maskf_ishift = np.fft.ifftshift(fshift)img_back = cv2.idft(f_ishift)dst = cv2.magnitude(img_back[:,:,0],img_back[:,:,1])plt.subplot(121),plt.imshow(NoiseImage,'gray')plt.subplot(122),plt.imshow(dst,'gray')plt.show()

dst=cv.dft(src[, dst[, flags[, nonzeroRows]]])参数说明：

src：输入数组可能是实数或复数。
flag：转换标志，代表DftFlags的组合。
nonezeroRows：当参数不为零时，该函数假定只有输入数组的第一个非零行或仅输出数组的第一个非零行包含非零。因此，函数可以更有效地处理其余行并节省一些时间，这种技术对于使用DFT计算阵列互相关或卷积非常有用。

更多内容参考：

傅里叶分析之掐死教程
opencv python 傅里叶变换
OpenCV+Python离散傅里叶变换DFT
opencv dft官方文档
小波和傅里叶变换之间关系详细讲解。

后记以上，实现了部分滤波去噪法。对于维纳滤波去噪法和小波变换去噪法，数学原理比较复杂，就先放一边，等有需要了再来进行实现。对于傅里叶变换去噪法，一知半解，还需要继续学习。
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>毕设</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>图像倾斜矫正</title>
    <url>/dev-gp-image-tilt-correction/</url>
    <content><![CDATA[理论没有找到关于图像倾斜矫正的综述性文献，那就自己整理一下吧。
图像倾斜可以分为两种情况，一种是平面倾斜，这种情况下拍照设备与试卷平行，拍出来的图像只需要进行旋转即可完成矫正；另一种是Z轴倾斜，这种情况下拍照设备与试卷存在一定的角度，拍出来的图像要先进行透视变换，然后再进行旋转等操作才可以完成矫正。
图像倾斜矫正关键在于根据图像特征自动检测出图像倾斜方向和倾斜角度。
对于平面倾斜，先利用边缘（轮廓）检测算法算法找到图像的边界，然后利用Radon变换法（基于投影的方法）、Hough变换法、线性回归法等找到倾斜角度，然后再利用仿射变换进行旋转。
对于Z轴倾斜，先利用边缘（轮廓）检测算法找到图像的边界，然后利用透视变换把视平面上的点投影到现实平面，然后再利用仿射变换进行旋转。


实践边缘检测# -*- coding: utf-8 -*-import numpy as npimport cv2img = cv2.imread('../image/tilt.jpg')GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)CannyImage = cv2.Canny(GrayImage,50, 150, apertureSize=3)cv2.imshow('gray',GrayImage)cv2.imshow('canny',CannyImage)cv2.waitKey(0)

edges=cv.Canny(image, threshold1, threshold2[, edges[, apertureSize[, L2gradient]]])参数说明：

image：输入图像。
threshold1：最小阈值。
threshold2：最大阈值。
apertureSize：Sobel算子的孔径大小。

更多内容参考：

OpenCV Canny
Canny边缘检测
基于Sobel和Canny边缘检测
Python-OpenCV 处理图像（五）：图像中边界和轮廓检测

以上代码，调用了OpenCV中的canny方法找到了边缘，但是，文字的边缘也被显示出来了。那么，怎么去掉文字边缘，只要长方形框的边缘呢？OpenCV也提供了方法，使用findContours来查找轮廓，使用drawContours来绘制轮廓。
# -*- coding: utf-8 -*-import numpy as npimport cv2img = cv2.imread('../image/tilt.jpg')GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)CannyImage = cv2.Canny(GrayImage,50, 150, apertureSize=3)ret,BinImage=cv2.threshold(CannyImage,127,255,cv2.THRESH_BINARY)_, contours, _= cv2.findContours(BinImage, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)cv2.imshow('bin',BinImage)cv2.drawContours(img, contours, -1, (0,255, 0), 1)cv2.imshow('edge',img)cv2.waitKey(0)


contours, hierarchy = cv.findContours(image, mode, method[, contours[, hierarchy[, offset]]])参数说明：

image：输入图像，二值化图像。
mode：轮廓检索模式，请参阅RetrievalModes。
method：轮廓近似方法，请参见ContourApproximationModes。

如果按照官方文档调用，会报错，参考ValueError: too many values to unpack解决。实际上，这是因为opencv3之后该函数的返回值有三个，而官方文档有多个版本，比如这一版中就说明了有三个参数。
计算倾斜角以上，已经找到了图片的边缘，接下来计算倾斜角度。
# -*- coding: utf-8 -*-import numpy as npimport cv2img = cv2.imread('../image/tilt.jpg')GrayImage = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)CannyImage = cv2.Canny(GrayImage,50, 150, apertureSize=3)ret,BinImage=cv2.threshold(CannyImage,127,255,cv2.THRESH_BINARY)lines = cv2.HoughLinesP(BinImage, 1, np.pi / 180, 160, minLineLength=200, maxLineGap=180)# 寻找长度最长的线distance = []for line in lines:    x1, y1, x2, y2 = line[0]    dis = np.sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2))    distance.append(dis)max_dis_index = distance.index(max(distance))max_line = lines[max_dis_index]x1, y1, x2, y2 = max_line[0]# 获取旋转角度angle = cv2.fastAtan2((y2 - y1), (x2 - x1))print(angle)

以上代码，很尴尬，并不是利用findContours的结果进行计算的，而是一个新的思路。为什么没有使用contours？因为不会写代码。。。如果要继续findContours思路，那么可以参考图像矫正技术深入探讨进行改写。
仿射变换求出倾斜角度之后，利用仿射变换进行旋转。
# 计算图片中心centerpoint = (img.shape[1]/2,img.shape[0]/2)# 获取旋转矩阵rotate_mat = cv2.getRotationMatrix2D(centerpoint,angle,1.0)correct_image = cv2.warpAffine(img,rotate_mat,(img.shape[1],img.shape[0]),borderValue =(255,255,255) )cv2.imshow('right',correct_image)cv2.waitKey(0)


Z轴倾斜import cv2import numpy as npdef gray_and_bin(init_img):    gray_img = cv2.cvtColor(init_img, cv2.COLOR_BGR2GRAY)    blur_img = cv2.GaussianBlur(gray_img, (3, 3), 0)                     # 高斯模糊去噪（设定卷积核大小影响效果）    canny_img = cv2.Canny(blur_img, 35, 189, apertureSize=3)    _, bin_img = cv2.threshold(canny_img, 127, 255, cv2.THRESH_BINARY)  # 设定阈值165（阈值影响开闭运算效果）    return gray_img, bin_imgdef points_and_box(init_img, bin_img):    image, contours, hierarchy = cv2.findContours(bin_img, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)    c = sorted(contours, key=cv2.contourArea, reverse=True)[0]   # 计算最大轮廓的旋转包围盒    rect = cv2.minAreaRect(c)                                    # 获取包围盒（中心点，宽高，旋转角度）    box = np.int0(cv2.boxPoints(rect))                           # box    # box_img = cv2.drawContours(init_img.copy(), [box], -1, (0, 0, 255), 2)    # cv2.imshow('box',box_img)    empty_img = np.zeros(init_img.shape, np.uint8) # 创建空白图像    empty_img[...] = 255 # 设置白底    # cv2.imshow('test',empty_img)    cv2.drawContours(empty_img, contours, -1, (0, 0, 0), 1) # 在空白图像上绘制试卷轮廓    # cv2.imshow('edge', empty_img)    _, bin_img2 = gray_and_bin(empty_img)    # cv2.imshow('bin',bin_img2)    lines = cv2.HoughLinesP(bin_img2, 1, np.pi / 180, 100, minLineLength=200, maxLineGap=10)    for i in range(int(np.size(lines) / 4)):        for x1, y1, x2, y2 in lines[i]:            cv2.line(empty_img, (x1, y1), (x2, y2), (255, 255, 0), 1)    # cv2.imshow('line',empty_img)    points = None    if len(contours) &gt; 0:        contours = sorted(contours, key=cv2.contourArea, reverse=True)        for c in contours:            peri = cv2.arcLength(c, True)  # 轮廓按大小降序排序            approx = cv2.approxPolyDP(c, 0.02 * peri, True)  # 获取近似的轮廓            if len(approx) == 4:  # 近似轮廓有四个顶点                points = approx                break    print('piont[0]', points[0]) # 左下    print('piont[1]', points[1]) # 左上    print('piont[2]', points[2]) # 右上    print('piont[3]', points[3]) # 右下    print('box[0]:', box[0]) # 右下    print('box[1]:', box[1]) # 右上    print('box[2]:', box[2]) # 左上    print('box[3]:', box[3]) # 左下    return points,boxdef perspective_transform(box,points,init_img):    # 原图中试卷的四个顶点    pts1 = np.float32([points[0], points[1], points[2], points[3]])    # box中的四个顶点    pts2 = np.float32([box[3], box[2], box[1], box[0]])    # 生成透视变换矩阵；进行透视变换    M = cv2.getPerspectiveTransform(pts1,pts2)    result_img = cv2.warpPerspective(init_img, M, (1200, 1300))    return result_imgif __name__=='__main__':    init_img = cv2.imread('../image/init.jpg')    gray_img, bin_img = gray_and_bin(init_img)    points, box = points_and_box(init_img,bin_img)    result_img = perspective_transform(box,points,init_img)    # cv2.imshow('init',init_img)    cv2.namedWindow('result', 0)    cv2.resizeWindow('result', 640, 1200)    cv2.imshow('result', result_img)    # cv2.imwrite('result.jpg',result_img)    cv2.waitKey(0)

以上结果，并不是很理想。透视矫正完成了，但是存在黑边白边，试卷长宽比例也有问题，也没有进行平面倾斜矫正。就先这样吧，作为一个小白，做成这样已经很不容易了。
更多内容参考利用opencv库，实现校正图片中的A4纸、用numpy+OpenCV快速实现矫正图像的功能、OpenCV—python图像矫正和对倾斜的图像进行修正——基于opencv透视变换。
后记图像倾斜矫正这部分，是图像预处理中的一个难点。以上，虽然实现了基本的图像倾斜矫正算法，但是算法原理还需要进一步学习。而且，上面的代码中使用的图片都是理想的，干扰很小，而实际拍摄的图片，除了目标物体（试卷），还会出现其他物体，比如签字笔文具盒等等。所以，后续还需要考虑其他物体的干扰。
另外，发现OpenCV成为了开发过程中的瓶颈，想要实现一些功能，每次都要求助于百度谷歌。因此，必须找时间系统学习一下OpenCV。
书签图像矫正原理说明
图像矫正-基于opencv实现
利用包围轮廓和仿射变换进行图像倾斜校正
对Z轴倾斜的图像进行校正–基于OpenCV透视变换
OpenCV实现基于傅里叶变换的旋转文本校正
Python+OpenCV实现旋转文本校正
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>毕设</tag>
        <tag>opencv</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo环境搭建</title>
    <url>/dev-hexo-build-environment/</url>
    <content><![CDATA[前言重装了系统，Hexo没法使用了。第一次安装的时候，没有做任何记录，这次刚好记录一下。
hexo官网http://hexo.io/
下载安装gitgit官方下载地址：http://git-scm.com/download/分享一个14年版本：http://yunpan.cn/cwqWapRIyFWrA  访问密码 8f1b下载好之后，双击安装，一路next即可。唯一需要注意的是，在Select Components界面，点选Simple context menu。
下载安装Node.jsNode.js官方下载地址：https://nodejs.org/ ，Current version: v0.12.4分享一个v0.10.31：http://yunpan.cn/cwqtqY8FCpdZc  访问密码 951e下载好之后，双击安装，一路next即可。
安装Hexo右击任意位置，选择Git Bash Here。执行命令：npm install -g hexo，报错如下：
npm ERR! Error: shasum check failed for C:\Users\ADMINI~1\AppData\Local\Temp\npm-30024-KDJHJzgP\registry.npmjs.org\hexo-cli\-\hexo-cli-0.1.6.tgznpm ERR! Expected: 7dc3ab939d0889c4bed6a961605ff3e2d67f67a2npm ERR! Actual:   41de7d67a9b764352eb07c49c32fc38dd7f479b9npm ERR! From:     https://registry.npmjs.org/hexo-cli/-/hexo-cli-0.1.6.tgznpm ERR!     at d:\Program Files\nodejs\node_modules\npm\node_modules\sha\index.js:38:8npm ERR!     at ReadStream.&lt;anonymous&gt; (d:\Program Files\nodejs\node_modules\npm\node_modules\sha\index.js:85:7)npm ERR!     at ReadStream.emit (events.js:117:20)npm ERR!     at _stream_readable.js:943:16npm ERR!     at process._tickCallback (node.js:419:13)npm ERR! If you need help, you may report this *entire* log,npm ERR! including the npm and node versions, at:npm ERR!     &lt;http://github.com/npm/npm/issues&gt;npm ERR! System Windows_NT 6.2.9200npm ERR! command "d:\\Program Files\\nodejs\\node.exe" "d:\\Program Files\\nodejs\\node_modules\\npm\\bin\\npm-cli.js" "install" "-g" "hexo"npm ERR! cwd C:\Users\Administrator\Desktopnpm ERR! node -v v0.10.31npm ERR! npm -v 1.4.23npm ERR! registry error parsing jsonnpm ERR!npm ERR! Additional logging details can be found in:npm ERR!     C:\Users\Administrator\Desktop\npm-debug.lognpm ERR! not ok code 0
莫非是因为被墙了？换国内镜像源试试。npm config set registry=&quot;http://registry.cnpmjs.org&quot;，然后再次执行npm install -g hexo，成功！

创建hexo文件夹在任意文件夹下（如E:\hexo），打开Git Bash，执行命令：hexo init，Hexo 即会在目标文件夹建立网站所需要的所有文件。
安装依赖包npm install
命令缩写hexo generate = hexo ghexo server = hexo shexo deploy = hexo dhexo new = hexo n
本地查看执行以下命令：hexo g，hexo s，然后到浏览器输入http://localhost:4000查看效果。至此，本地博客已经搭建起来了，别人看不到的。
部署到GitHub注册GitHub官网：http://www.github.com
创建repositorycreat new repository，Repository name和自己的用户名相同。比如我的用户名为voidking，那么Repository name就填voidking.github.io。
_config.yml编辑E:\hexo下的_config.yml，修改Deployment部分：
# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy:  type: git  repository: https://github.com/voidking/voidking.github.io.git  branch: master

部署hexo d，执行该命令，报错：
ERROR Deployer not found: git
执行命令：npm install hexo-deployer-git --save，再次执行hexo d,报错：
INFO  Deploying: gitINFO  Clearing .deploy folder...INFO  Copying files from public folder...warning: LF will be replaced by CRLF in hello-world/index.html.The file will have its original line endings in your working directory.......*** Please tell me who you are.Run  git config --global user.email "you@example.com"  git config --global user.name "Your Name"to set your account's default identity.Omit --global to set the identity only in this repository.fatal: unable to auto-detect email address (got 'Administrator@PC-201505290750.(none)')Username for 'https://github.com': voidkingPassword for 'https://voidking@github.com':error: src refspec master does not match any.error: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.htmlError: error: src refspec master does not match any.error: failed to push some refs to 'https://github.com/voidking/voidking.github.io.git'    at ChildProcess.&lt;anonymous&gt; (E:\hexo\node_modules\hexo-deployer-git\node_modules\hexo-util\lib\spawn.js:42:17)    at ChildProcess.emit (events.js:98:17)    at maybeClose (child_process.js:756:16)    at Process.ChildProcess._handle.onexit (child_process.js:823:5)
估计必须要先配置SSH，然后才可以上传文件。
GitHub之SSH key1、设置Git的user.name和user.email在第一次使用Git时，你需要告诉你的协同开发者，你是谁以及你的邮箱，在你提交的时候，Git需要这两个信息。具体通过以下命令设置：git config --global user.name &quot;voidking&quot;git config --global user.email &quot;voidking@qq.com&quot;需要注意的是，这里的name随意，邮箱是你的联系邮箱，与github完全无关。查看配置命令：git config --list
2、生成SSH密钥ssh-keygen -t rsa -C &quot;voidking@qq.com&quot;，按3个回车，密码为空。
Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa):Created directory '/c/Users/Administrator/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa.Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub.The key fingerprint is:e6:9e:e7:ae:ad:ee:9f:f0:e5:6b:60:63:85:e8:cd:ae voidking@qq.com

在C:\Users\Administrator\.ssh下，得到两个文件id_rsa和id_rsa.pub。需要注意的是，命令中的-C参数，后面跟的内容是注释。也就是说，内容随意，与github完全无关。
3、在GitHub上添加SSH密钥打开id_rsa.pub，复制全文。https://github.com/settings/ssh ，Add SSH key，粘贴进去。
4、测试ssh git@github.com，提示：
The authenticity of host 'github.com (192.30.252.128)' can't be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,192.30.252.128' (RSA) to the list of known hosts.Hi voidking! You've successfully authenticated, but GitHub does not provide shell access.Connection to github.com closed.

再次部署hexo d，根据提示输入用户名和密码，等待一会儿便成功了！
INFO  Deploying: gitINFO  Clearing .deploy folder...INFO  Copying files from public folder...warning: LF will be replaced by CRLF in hello-world/index.html.The file will have its original line endings in your working directory.......[master (root-commit) 7124e90] Site updated: 2015-05-30 23:04:14 28 files changed, 5746 insertions(+) create mode 100644 hello-world/index.html ......warning: LF will be replaced by CRLF in hello-world/index.html.The file will have its original line endings in your working directory.......Username for 'https://github.com': voidkingPassword for 'https://voidking@github.com':Branch master set up to track remote branch master from https://github.com/voidking/voidking.github.io.git.To https://github.com/voidking/voidking.github.io.git * [new branch]      master -&gt; masterINFO  Deploy done: git

访问测试访问：http://voidking.github.io/ ，可以看到，Hexo已经搭建成功！
参考文档官方文档：http://hexo.io/docs/
GitHub Pageshttps://pages.github.com/
hexo系列教程：（二）搭建hexo博客http://zipperary.com/hexo-guide-2/
Git SSH Key 生成步骤http://blog.csdn.net/hustpzb/article/details/8230454/
Getting Started - First-Time Git Setuphttp://git-scm.com/book/en/v2/Getting-Started-First-Time-Git-Setup
git-scmhttp://git-scm.com/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用Gulp压缩静态资源</title>
    <url>/dev-hexo-gulp/</url>
    <content><![CDATA[Gulp简介gulp是一个自动化构建工具，能够强化我们的前端工作流。

gulp is an open-source JavaScript toolkit created by Eric Schoffstall used as a streaming build system (similar to a more package-focussed Make) in front-end web development.


It is a task runner built on Node.js and npm, used for automation of time-consuming and repetitive tasks involved in web development like minification, concatenation, cache busting, unit testing, linting, optimization, etc.


gulp uses a code-over-configuration approach to define its tasks and relies on its small, single-purpose plugins to carry them out. The gulp ecosystem includes more than 3500 such plugins.

更多内容，参考wikipedia-gulp.js、Gulp官网和Gulp中文网。本文中，会使用gulp来压缩hexo生成的静态资源文件，加快站点的访问速度。


安装配置gulp1、安装gulpnpm install --global gulp-cli
2、安装gulp模块
npm install gulp --savenpm install gulp-htmlclean gulp-htmlmin gulp-clean-css gulp-uglify gulp-imagemin --savenpm install gulp-babel babel-preset-env babel-preset-mobx --savenpm install -D @babel/core @babel/preset-react @babel/preset-env --save
最终生成的package.json为：
&#123;  "name": "hexo-site",  "version": "0.0.0",  "private": true,  "scripts": &#123;    "build": "hexo generate",    "clean": "hexo clean",    "deploy": "hexo deploy",    "server": "hexo server"  &#125;,  "hexo": &#123;    "version": "4.2.0"  &#125;,  "dependencies": &#123;    "babel-preset-env": "^1.7.0",    "babel-preset-mobx": "^2.0.0",    "gulp": "^4.0.2",    "gulp-babel": "^8.0.0",    "gulp-clean-css": "^4.2.0",    "gulp-htmlclean": "^2.7.22",    "gulp-htmlmin": "^5.0.1",    "gulp-imagemin": "^7.1.0",    "gulp-uglify": "^3.0.2",    "hexo": "^4.0.0",    "hexo-generator-archive": "^1.0.0",    "hexo-generator-baidu-sitemap": "^0.1.6",    "hexo-generator-category": "^1.0.0",    "hexo-generator-feed": "^2.2.0",    "hexo-generator-index": "^1.0.0",    "hexo-generator-searchdb": "^1.2.0",    "hexo-generator-sitemap": "^2.0.0",    "hexo-generator-tag": "^1.0.0",    "hexo-neat": "^1.0.4",    "hexo-renderer-ejs": "^1.0.0",    "hexo-renderer-marked": "^2.0.0",    "hexo-renderer-stylus": "^1.1.0",    "hexo-server": "^1.0.0"  &#125;,  "devDependencies": &#123;    "@babel/core": "^7.8.4",    "@babel/preset-env": "^7.8.4",    "@babel/preset-react": "^7.8.3"  &#125;&#125;

4、在hexo目录创建gulpfile.js，内容为：
let gulp = require('gulp')let cleanCSS = require('gulp-clean-css')let htmlmin = require('gulp-htmlmin')let htmlclean = require('gulp-htmlclean')let babel = require('gulp-babel') /* 转换为es2015 */let uglify = require('gulp-uglify')let imagemin = require('gulp-imagemin')// 设置根目录const root = './public'// 匹配模式， **/*代表匹配所有目录下的所有文件const pattern = '**/*'// 压缩htmlgulp.task('minify-html', function() &#123;  return gulp    // 匹配所有 .html结尾的文件    .src(`$&#123;root&#125;/$&#123;pattern&#125;.html`)    .pipe(htmlclean())    .pipe(      htmlmin(&#123;        removeComments: true,        minifyJS: true,        minifyCSS: true,        minifyURLs: true      &#125;)    )    .pipe(gulp.dest('./public'))&#125;)// 压缩cssgulp.task('minify-css', function() &#123;  return gulp    // 匹配所有 .css结尾的文件    .src(`$&#123;root&#125;/$&#123;pattern&#125;.css`)    .pipe(      cleanCSS(&#123;        compatibility: 'ie8'      &#125;)    )    .pipe(gulp.dest('./public'))&#125;)// 压缩jsgulp.task('minify-js', function() &#123;  return gulp    // 匹配所有 .js结尾的文件    .src(`$&#123;root&#125;/$&#123;pattern&#125;.js`)    .pipe(      babel(&#123;        presets: ['env']      &#125;)    )    .pipe(uglify())    .pipe(gulp.dest('./public'))&#125;)// 压缩图片gulp.task('minify-images', function() &#123;  return gulp    // 匹配public/images目录下的所有文件    .src(`$&#123;root&#125;/images/$&#123;pattern&#125;`)    .pipe(      imagemin(        [          imagemin.gifsicle(&#123; optimizationLevel: 3 &#125;),          imagemin.jpegtran(&#123; progressive: true &#125;),          imagemin.optipng(&#123; optimizationLevel: 7 &#125;),          imagemin.svgo()        ],        &#123; verbose: true &#125;      )    )    .pipe(gulp.dest('./public/images'))&#125;)gulp.task('default', gulp.series('minify-html', 'minify-css', 'minify-js'))

4、执行压缩gulp
命令精简使用了gulp时候，构建发布需要四个命令：
hexo cleanhexo ggulphexo d
这四个命令，可以都写在package.json。
"scripts": &#123;  "build": "hexo clean &amp;&amp; hexo g &amp;&amp; gulp",  "deploy": "hexo clean &amp;&amp; hexo g &amp;&amp; gulp &amp;&amp; hexo d"&#125;
构建只需要执行npm run build，构建发布只需要执行npm run deploy。
travis配置对应的，修改.travis.yml配置为：
sudo: falselanguage: node_jsnode_js:- 10.16.3cache: npmbranches:  only:  - master # build master branch onlyenv:  global:  - GIT_USER: voidking  - HEXO_BACKUP_REPO: github.com/voidking/hexo-backup.git  - HEXO_THEME_REPO: github.com/voidking/hexo-theme-next.git  - GITHUB_PAGES_REPO: github.com/voidking/voidking.github.io.git  - VOIDKING_REPO: github.com/voidking/voidking.gitbefore_install:- export TZ='Asia/Shanghai'- npm install hexo -g- npm install gulp-cli -ginstall:- npm installscript:- git clone https://$&#123;HEXO_THEME_REPO&#125; themes/next- git clone https://$&#123;GIT_USER&#125;:$&#123;GITHUB_TOKEN&#125;@$&#123;HEXO_BACKUP_REPO&#125; hexo-backup- mv hexo-backup/source .- rm -rf source/private- npm run buildafter_success:- git config --global user.name "voidking"- git config --global user.email "voidking@qq.com"- git clone https://$&#123;GIT_USER&#125;:$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_PAGES_REPO&#125; voidking- unalias cp- cp -rf public/. voidking- cd voidking- git add .- git commit -m "Travis CI Auto Builder"- git push --force --quiet "https://$&#123;GIT_USER&#125;:$&#123;GITHUB_TOKEN&#125;@$&#123;GITHUB_PAGES_REPO&#125;" master:master

精简search.xmlhtml、css和js都压缩了，很开心。但是，还有一个大文件没有压缩，就是本地搜索的DB文件search.xml。我的博客有接近600篇文章，这个search.xml文件的大小为7.5M，很大。打开search.xml文件，发现里面不止包含文章内容，还包含html标签。参考hexo-generator-searchdb，发现可以设置不生成标签。
修改localsearch配置1、修改hexo/_config.yml的localsearch配置为：
# local searchsearch:  path: search.xml  field: post  format: striptags  limit: 10000

2、重新生成search.xml文件，新的文件只有3.5M。
3、修改local-search.js为了正常使用搜索功能，需要修改hexo主题的local-search.js。如果不修改的话，搜索时只搜索标题，不会搜索内容。编辑next/source/js/local-search.js，如下修改：
// line 120// let content = data.content ? data.content.trim().replace(/&lt;[^&gt;]+&gt;/g, '') : '';let content = data.content;

以上，实现了search.xml的精简，nice。
自定义精简但是，3.5M依然很大，能不能再精简一下？可以。1、localsearch的format改回html。
2、修改xml_generator.js编辑hexo/node_modules/hexo-generator-searchdb/lib/xml_generator.js，定义自己想要删除的字符：
'use strict';const path = require('path');const fs = require('fs');const nunjucks = require('nunjucks');var env = new nunjucks.Environment();var searchTmplSrc = path.join(__dirname, '../templates/search.xml');var searchTmpl = nunjucks.compile(fs.readFileSync(searchTmplSrc, 'utf8'), env);var stripe_code_line_num = function(str) &#123; // 去除代码    return str.replace(/&lt;figure class="highlight.*?&lt;\/figure&gt;/ig, '');&#125;var stripe = function (str) &#123; // 去除html标签    return str.replace(/(&lt;([^&gt;]+)&gt;)/ig, '');&#125;var minify = function (str) &#123; // 压缩成一行    return str.trim().replace(/\n/g, ' ').replace(/\s+/g, ' ');&#125;module.exports = function(locals) &#123;  var config = this.config;  var database = require('./database')(locals, config);  database.forEach( function(element, index) &#123;    element.content = minify(stripe(stripe_code_line_num(element.content)));  &#125;);  var xml = searchTmpl.render(&#123;    articles: database,    config  : config.search  &#125;);  return &#123;    path: config.search.path,    data: xml  &#125;;&#125;;

3、重新生成search.xml，这次只有2.5M，nice。
以上两种精简search.xml的方法都很好，这里我选择使用修改localsearch format的方法。因为如果在xml_generator.js不删除文章中的代码，两种方法的压缩结果基本相同，而方法一通用性更好。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>hexo</category>
        <category>CICD</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>cicd</tag>
        <tag>gulp</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo启用https加密连接</title>
    <url>/dev-hexo-https/</url>
    <content><![CDATA[前言访问个人网站，偶尔会跳出广告，看来网站被运营商劫持了。为了避免这种情况，郝同学决定对网站进行https加密。早在2015年，美国政府就要求所有联邦政府网站使用https加密连接，这次郝同学也算是赶上了国际潮流的尾巴。


https简介HTTPS（全称：Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。这个系统的最初研发由网景公司(Netscape)进行，并内置于其浏览器Netscape Navigator中，提供了身份验证与加密通讯方法。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。
配置原理https是在http下加入ssl层，那么，怎么加入呢？很简单，在nginx、apache等web服务器中加入ssl安全证书的配置即可。
ssl证书申请很多网站都提供免费的ssl证书，收集整理如下：

Let’s Encrypt官网和Certbot官网，用法参考《使用Let’s Encrypt加密你的小站》。
阿里云免费SSL证书，保护类型选择1个域名，选择品牌选择Symantec，即可看到免费型DV SSL。
腾讯云免费SSL证书
七牛免费SSL证书

推荐使用阿里云、腾讯云和七牛，注册登录，根据提示填写信息，不久就可以拿到证书。解压www.voidking.com.zip，可以得到下列文件：
www.voidking.com│  www.voidking.com.csr│├─Apache│      1_root_bundle.crt│      2_www.voidking.com.crt│      3_www.voidking.com.key│├─IIS│      keystorePass.txt│      www.voidking.com.pfx│├─Nginx│      1_www.voidking.com_bundle.crt│      2_www.voidking.com.key│└─Tomcat        keystorePass.txt        www.voidking.com.jks

思路gitlabgithub和coding，都不支持上传ssl证书。但是，gitlab支持啊！最简单的思路就是，把网站迁到gitlab上。
按照这个思路，参考《利用gitlab pages和hexo搭建一个个人博客》和《零成本打造安全博客的简单办法》。
1、打开gitlab的项目，Settings，Pages，New Domain，即可进入域名配置页面。
2、Domain填入www.voidking.com，Certificate (PEM)填入1_www.voidking.com_bundle.crt中的内容，Key (PEM)填入2_www.voidking.com.key中的内容。
反向代理反向代理是普遍思路，无论我们的真实服务器在github、coding还是gitlab，都可以使用反向代理的方式完成https加密连接。前提是你有一个公网服务器，上面安装了nginx。
用户访问域名；域名解析到公网IP，访问到nginx；nginx反向代理到coding等真实服务器，通过http方式拿到页面；nginx拿到页面后进行ssl加密，然后返回给用户加密后的页面。
CloudflareCloudflare是一家CDN提供商，它提供了免费的https服务（但不是应用SSL证书）。实现模式就是，用户到CDN服务器的连接为https，而CDN服务器到真实服务器的连接为http。也就是说，在CDN服务器那里加上反向代理。没错，又是反向代理，只不过这次的代理服务器归属于Cloudflare，不是我们自己的。
这种方式，好处是你不需要拥有自己的公网服务器，坏处是你必须把域名的dns服务器换成cloudflare。
具体设置步骤参考《让个人域名下GithubPage完美支持https》。
详细步骤郝同学决定选用最通用的方式，通过nginx反向代理来实现https访问（假设已经申请好了ssl证书）。
修改域名解析原来的域名解析位CNAME记录，指向pages.coding.me，现在修改为A记录，指向公网IP。
上传证书1、服务器上，创建目录sslmkdir /etc/nginx/ssl
2、使用xftp上传 www.voidking.com/Nginx 文件夹中的 1_www.voidking.com_bundle.crt 和 2_www.voidking.com.key 到ssl目录。
配置nginx配置nginx，参考《Nginx开启SSL与重定向优化》
1、coding pages配置不变，依然绑定 www.voidking.com 域名。
2、/etc/nginx/conf.d中新建配置文件 www.voidking.com.conf ，内容如下：
server &#123;    listen 80;    server_name www.voidking.com;    charset utf-8;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_pass http://voidking.coding.me;    &#125;&#125;server &#123;    # SSL configuration    listen 443 ssl;    server_name www.voidking.com;    charset utf-8;    ssl_certificate /etc/nginx/ssl/1_www.voidking.com_bundle.crt;     ssl_certificate_key  /etc/nginx/ssl/2_www.voidking.com.key;     ssl_session_timeout  5m;      ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers  HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_pass http://voidking.coding.me;    &#125;&#125;

3、重启nginxsystemctl restart nginx
4、测试访问访问 https://www.voidking.com ，已经可以正常访问网址，只不过有些脚本是通过http方式引用的，会提示不安全，等下我们修改了hexo主题就好了。
修改hexo主题1、访问 https://www.voidking.com ，F12，启用调试模式，查看哪些文件是不安全的。
2、修改hexo主题，把那些不安全的文件全部修改为https引用。
jquery1.9.0在hexo/themes/yilia/layout/_partial中找到head.ejs，修改jquery引用地址为：
&lt;script src="https://libs.baidu.com/jquery/1.9.0/jquery.js"&gt;&lt;/script&gt;

mathjax《Hexo中使用Mathjax的冲突问题》一文中，我们引用mathjax的方式也是http，引用单位是整个主题（所有的页面）。下面我们把引用方式修改为https，引用单位改为单个页面。
1、把hexo/themes/yilia/layout/_partial中的mathjax.ejs移动到hexo/themes/yilia/layout/_partial/post。
2、修改mathjax.ejs中的js引用：
&lt;script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"&gt;

3、删除after-footer.ejs中关于mathjax的引用。
4、修改hexo/themes/yilia/layout/_partial/article.ejs，在最后添加：
&lt;% if (!index &amp;&amp; post.mathjax)&#123; %&gt;&lt;%- partial('post/mathjax') %&gt;&lt;% &#125; %&gt;

5、修改markdown文档。使用mathjax的文档，在头部加上：
mathjax: true

畅言在hexo/themes/yilia/layout/_partial/post中找到changyan.ejs，其中的两个js引用，改成https。
jiathisjiathis和baidushare都不提供https方式的引用，所以只能将其本地化（下载所有源码并修改源码），或者利用反向代理。实在费劲，郝同学决定换成overtrue同学的share.js。
原post/share.ejs为：
&lt;div class="share"&gt;    &lt;!-- JiaThis Button BEGIN --&gt;    &lt;div class="jiathis_style"&gt;        &lt;span class="jiathis_txt"&gt;分享到：&lt;/span&gt;        &lt;a class="jiathis_button_tsina"&gt;&lt;/a&gt;        &lt;a class="jiathis_button_cqq"&gt;&lt;/a&gt;        &lt;a class="jiathis_button_douban"&gt;&lt;/a&gt;        &lt;a class="jiathis_button_weixin"&gt;&lt;/a&gt;        &lt;a class="jiathis_button_tumblr"&gt;&lt;/a&gt;        &lt;a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"&gt;&lt;/a&gt;    &lt;/div&gt;    &lt;script type="text/javascript" src="https://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"&gt;&lt;/script&gt;    &lt;!-- JiaThis Button END --&gt;&lt;/div&gt;

修改为：
&lt;div class="share"&gt;    &lt;div class="social-share"&gt;&lt;/div&gt;    &lt;!--  css &amp; js --&gt;    &lt;link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"&gt;    &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"&gt;&lt;/script&gt;&lt;/div&gt;


源码分享个人yilia地址：https://github.com/voidking/hexo-theme-yilia
配置nginx进阶至此，已经可以通过http和https两种方式访问 www.voidking.com 了。既然已经有了https，http不妨重定向到https。
修改 www.voidking.com.conf 为：
server &#123;    listen 80;    listen 443 ssl;    server_name www.voidking.com;    charset utf-8;    ssl_certificate /etc/nginx/ssl/1_www.voidking.com_bundle.crt;    ssl_certificate_key  /etc/nginx/ssl/2_www.voidking.com.key;    ssl_session_timeout  5m;    ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2;    ssl_ciphers  HIGH:!ADH:!EXPORT56:RC4+RSA:+MEDIUM;    ssl_prefer_server_ciphers on;    if ($ssl_protocol = "") &#123;        return 301 https://$host$request_uri;    &#125;    location / &#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header   X-Forwarded-For  $proxy_add_x_forwarded_for;        proxy_pass http://voidking.coding.me;    &#125;&#125;

SSL的配置不要加 ssl on ，否则启动时会存在一个警告：
[warn] 1#1: the "ssl" directive is deprecated, use the "listen ... ssl" directive instead in /etc/nginx/conf.d/www.voidking.com.conf:11

重启nginx，访问 http://www.voidking.com ，会自动跳转到 https://www.voidking.com ，说明配置成功。
小结这里，我们并没有配置 voidking.com 和 blog.voidking.com ，可以参照上面的步骤进行配置。但是，更加简单的配置方式，是在dnspod上配置显性url，直接跳转到 http://www.voidking.com 。
本文主要研究Hexo启用https加密连接，围绕hexo来谈，最终配置成功。其实，平时建站的时候，也可以给网站启用https加密连接，原理类似。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>开发</category>
        <category>hexo</category>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>nginx</tag>
        <tag>https</tag>
        <tag>mathjax</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo更换主题为Next</title>
    <url>/dev-hexo-theme-next/</url>
    <content><![CDATA[前言使用Yilia主题很久了，自己也进行了很多个性化的定制。今日始，决定把博客主题换成更加炫酷强大的Next，本文记录一下替换过程。


下载主题1、进入hexo/themes目录下，克隆next主题git clone https://github.com/voidking/hexo-theme-next.git next
2、编辑hexo/_config.yml
theme: next

个性化风格Next主题支持多种风格，默认使用Muse风格。这里切换成自己更喜欢的Pisces风格，编辑next/_config.yml
scheme: Gemini

导航编辑next/_config.yml，启用about、tags、categories、archives。
menu:  home: / || home  about: /about/ || user  tags: /tags/ || tags  categories: /categories/ || th  archives: /archives/ || archive

tags原Yilia主题中，是没有tags页面的，因此需要创建。1、创建tags页面hexo new page tags
2、编辑tags/index.md
---title: tagstype: "tags"layout: "tags"comments: false---

头像和签名百年老店，需要logo。1、把avatar.jpg放入next/source/images目录
2、编辑next/_config.yml，启用avatar
# Sidebar Avataravatar:  # Replace the default image and set the url here.  url: /images/avatar.jpg  # If true, the avatar will be dispalyed in circle.  rounded: false  # If true, the avatar will be rotated with the cursor.  rotated: false

不过，黑白主题配这个头像，有种搞绿化的感觉，哈哈。
3、编辑hexo/_config.yml，修改签名
# Sitetitle: VoidKingsubtitle: 好好学习，天天向上！description: 学而不思则罔，思而不学则殆！author: VoidKinglanguage: zh-CNtimezone:

favicon1、把favicon.png放入next/source/images目录
2、编辑next/_config.yml，配置favicon
favicon:  small: /images/favicon.png  medium: /images/favicon.png

scrollpercent在阅读文章过程中，scroll to top按钮显示当前滚动的百分比。
back2top:  enable: true  # Back to top in sidebar.  sidebar: false  # Scroll percent label in b2t button.  scrollpercent: true

社交链接编辑next/_config.yml，配置社交链接
# Social Linkssocial:  E-Mail: mailto:voidking@qq.com || envelope  GitHub: https://github.com/voidking || github  Weibo: http://weibo.com/voidking  || weibo  Twitter: https://twitter.com/voidking_com || twitter# `Follow me on GitHub` banner in the top-right corner.github_banner:  enable: true  permalink: https://github.com/voidking  title: Follow me on GitHub

关闭更新时间编辑next/_config.yml，关闭文章的更新时间。
# Post meta display settingspost_meta:  item_text: true  created_at: true  updated_at:    enable: false    another_day: false  categories: true

功能强化评论原Yilia主题的评论插件是自己添加的livere，而Next主题支持livere。
编辑next/_config.yml，启用livere
livere_uid: MTAyMC8zODU3Mi8xNTEwMA==

分享1、编辑next/_config.yml，添加needmoreshare2分享
needmoreshare2:  enable: true  postbottom:    enable: true    options:      iconStyle: box      boxForm: horizontal      position: bottomCenter      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook  float:    enable: true    options:      iconStyle: box      boxForm: horizontal      position: topRight      networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook

2、修复微信分享bugneedmoreshare2有一个bug，微信分享不能用，显示loading wechat image编辑next/source/lib/needsharebutton/needsharebutton.js，如下修改：
# var imgSrc = "https://api.qinco.me/api/qr?size=400&amp;content=" + encodeURIComponent(myoptions.url);var imgSrc = "http://api.qrserver.com/v1/create-qr-code/?size=150x150&amp;data=" + encodeURIComponent(myoptions.url);

搜索1、hexo目录下，安装搜索插件npm install hexo-generator-searchdb --save
2、编辑hexo/_config.yml，添加
# local searchsearch:  path: search.xml  field: post  format: html  limit: 10000

3、编辑next/_config.yml，启用搜索功能
# Local Searchlocal_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 1  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false

阅读量统计1、编辑next/_config.yml，启用不蒜子统计
busuanzi_count:  enable: true  total_visitors: true  total_visitors_icon: user  total_views: true  total_views_icon: eye  post_views: true  post_views_icon: eye

2、修复404问题不蒜子的原有js地址已经过期，因此插件需要修改。编辑next/layout/_third-party/analytics/busuanzi-counter.swig，如下修改
&lt;!-- &lt;script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt; --&gt;&lt;script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"&gt;&lt;/script&gt;

seo1、编辑next/_config.yml，修改keywords
keywords: "VoidKing, Hankin, 好好学习的好, 郝锦"

2、启用seo优化
canonical: trueseo: trueindex_with_subtitle: true

3、启用百度统计
baidu_analytics: b759ac2a7fa45129e3ef060bf68259f0

MathJax编辑next/_config.yml，启用mathjax。这里指定某些页面启用mathjax，而不是全局。
# Math Formulas Render Supportmath:  per_page: true  mathjax:    enable: true    mhchem: false  katex:    enable: false    copy_tex: false

背景动画编辑next/_config.yml，启用背景动画
# Canvas-nestcanvas_nest:  enable: true  onmobile: true # Display on mobile or not  color: "0,0,255" # RGB values, use `,` to separate  opacity: 0.5 # The opacity of line: 0~1  zIndex: -1 # z-index property of the background  count: 99 # The number of lines

烟火动画1、在next/source/js/src目录下新建fireworks.js文件
"use strict";function updateCoords(e) &#123;    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left,    pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123;    var t = anime.random(0, 360) * Math.PI / 180,    a = anime.random(50, 180),    n = [ - 1, 1][anime.random(0, 1)] * a;    return &#123;        x: e.x + n * Math.cos(t),        y: e.y + n * Math.sin(t)    &#125;&#125;function createParticule(e, t) &#123;    var a = &#123;&#125;;    return a.x = e,    a.y = t,    a.color = colors[anime.random(0, colors.length - 1)],    a.radius = anime.random(16, 32),    a.endPos = setParticuleDirection(a),    a.draw = function() &#123;        ctx.beginPath(),        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),        ctx.fillStyle = a.color,        ctx.fill()    &#125;,    a&#125;function createCircle(e, t) &#123;    var a = &#123;&#125;;    return a.x = e,    a.y = t,    a.color = "#F00",    a.radius = 0.1,    a.alpha = 0.5,    a.lineWidth = 6,    a.draw = function() &#123;        ctx.globalAlpha = a.alpha,        ctx.beginPath(),        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),        ctx.lineWidth = a.lineWidth,        ctx.strokeStyle = a.color,        ctx.stroke(),        ctx.globalAlpha = 1    &#125;,    a&#125;function renderParticule(e) &#123;    for (var t = 0; t &lt; e.animatables.length; t++) &#123;        e.animatables[t].target.draw()    &#125;&#125;function animateParticules(e, t) &#123;    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;        n.push(createParticule(e, t))    &#125;    anime.timeline().add(&#123;        targets: n,        x: function(e) &#123;            return e.endPos.x        &#125;,        y: function(e) &#123;            return e.endPos.y        &#125;,        radius: 0.1,        duration: anime.random(1200, 1800),        easing: "easeOutExpo",        update: renderParticule    &#125;).add(&#123;        targets: a,        radius: anime.random(80, 160),        lineWidth: 0,        alpha: &#123;            value: 0,            easing: "linear",            duration: anime.random(600, 800)        &#125;,        duration: anime.random(1200, 1800),        easing: "easeOutExpo",        update: renderParticule,        offset: 0    &#125;)&#125;function debounce(e, t) &#123;    var a;    return function() &#123;        var n = this,        i = arguments;        clearTimeout(a),        a = setTimeout(function() &#123;            e.apply(n, i)        &#125;,        t)    &#125;&#125;var canvasEl = document.querySelector(".fireworks");if (canvasEl) &#123;    var ctx = canvasEl.getContext("2d"),    numberOfParticules = 30,    pointerX = 0,    pointerY = 0,    tap = "mousedown",    colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"],    setCanvasSize = debounce(function() &#123;        canvasEl.width = 2 * window.innerWidth,        canvasEl.height = 2 * window.innerHeight,        canvasEl.style.width = window.innerWidth + "px",        canvasEl.style.height = window.innerHeight + "px",        canvasEl.getContext("2d").scale(2, 2)    &#125;,    500),    render = anime(&#123;        duration: 1 / 0,        update: function() &#123;            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)        &#125;    &#125;);    document.addEventListener(tap,    function(e) &#123;        "sidebar" !== e.target.id &amp;&amp; "toggle-sidebar" !== e.target.id &amp;&amp; "A" !== e.target.nodeName &amp;&amp; "IMG" !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))    &#125;,    !1),    setCanvasSize(),    window.addEventListener("resize", setCanvasSize, !1)&#125;"use strict";function updateCoords(e) &#123;    pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left,    pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top&#125;function setParticuleDirection(e) &#123;    var t = anime.random(0, 360) * Math.PI / 180,    a = anime.random(50, 180),    n = [ - 1, 1][anime.random(0, 1)] * a;    return &#123;        x: e.x + n * Math.cos(t),        y: e.y + n * Math.sin(t)    &#125;&#125;function createParticule(e, t) &#123;    var a = &#123;&#125;;    return a.x = e,    a.y = t,    a.color = colors[anime.random(0, colors.length - 1)],    a.radius = anime.random(16, 32),    a.endPos = setParticuleDirection(a),    a.draw = function() &#123;        ctx.beginPath(),        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),        ctx.fillStyle = a.color,        ctx.fill()    &#125;,    a&#125;function createCircle(e, t) &#123;    var a = &#123;&#125;;    return a.x = e,    a.y = t,    a.color = "#F00",    a.radius = 0.1,    a.alpha = 0.5,    a.lineWidth = 6,    a.draw = function() &#123;        ctx.globalAlpha = a.alpha,        ctx.beginPath(),        ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0),        ctx.lineWidth = a.lineWidth,        ctx.strokeStyle = a.color,        ctx.stroke(),        ctx.globalAlpha = 1    &#125;,    a&#125;function renderParticule(e) &#123;    for (var t = 0; t &lt; e.animatables.length; t++) &#123;        e.animatables[t].target.draw()    &#125;&#125;function animateParticules(e, t) &#123;    for (var a = createCircle(e, t), n = [], i = 0; i &lt; numberOfParticules; i++) &#123;        n.push(createParticule(e, t))    &#125;    anime.timeline().add(&#123;        targets: n,        x: function(e) &#123;            return e.endPos.x        &#125;,        y: function(e) &#123;            return e.endPos.y        &#125;,        radius: 0.1,        duration: anime.random(1200, 1800),        easing: "easeOutExpo",        update: renderParticule    &#125;).add(&#123;        targets: a,        radius: anime.random(80, 160),        lineWidth: 0,        alpha: &#123;            value: 0,            easing: "linear",            duration: anime.random(600, 800)        &#125;,        duration: anime.random(1200, 1800),        easing: "easeOutExpo",        update: renderParticule,        offset: 0    &#125;)&#125;function debounce(e, t) &#123;    var a;    return function() &#123;        var n = this,        i = arguments;        clearTimeout(a),        a = setTimeout(function() &#123;            e.apply(n, i)        &#125;,        t)    &#125;&#125;var canvasEl = document.querySelector(".fireworks");if (canvasEl) &#123;    var ctx = canvasEl.getContext("2d"),    numberOfParticules = 30,    pointerX = 0,    pointerY = 0,    tap = "mousedown",    colors = ["#FF1461", "#18FF92", "#5A87FF", "#FBF38C"],    setCanvasSize = debounce(function() &#123;        canvasEl.width = 2 * window.innerWidth,        canvasEl.height = 2 * window.innerHeight,        canvasEl.style.width = window.innerWidth + "px",        canvasEl.style.height = window.innerHeight + "px",        canvasEl.getContext("2d").scale(2, 2)    &#125;,    500),    render = anime(&#123;        duration: 1 / 0,        update: function() &#123;            ctx.clearRect(0, 0, canvasEl.width, canvasEl.height)        &#125;    &#125;);    document.addEventListener(tap,    function(e) &#123;        "sidebar" !== e.target.id &amp;&amp; "toggle-sidebar" !== e.target.id &amp;&amp; "A" !== e.target.nodeName &amp;&amp; "IMG" !== e.target.nodeName &amp;&amp; (render.play(), updateCoords(e), animateParticules(pointerX, pointerY))    &#125;,    !1),    setCanvasSize(),    window.addEventListener("resize", setCanvasSize, !1)&#125;;

2、添加next/layout/_third-party/fireworks.swig，内容如下：
&#123;% if theme.fireworks %&#125;   &lt;canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" &gt;&lt;/canvas&gt;    &lt;script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"&gt;&lt;/script&gt;    &lt;script type="text/javascript" src="/js/src/fireworks.js"&gt;&lt;/script&gt;&#123;% endif %&#125;

3、编辑next/layout/_layout.swig，在&lt;/body&gt;上面添加：
&#123;% include '_third-party/fireworks.swig' %&#125;

4、编辑next/_config.yml，添加并启用firework
# Fireworksfireworks: true

后记至此，完成了Hexo主题从Yilia到Next的替换。进行了一些个性化设置，并且应用了Next的很多新特性。更多关于Next主题的内容，需要时再去学习使用。
书签theme-next/hexo-theme-next
Next
iissnan/hexo-theme-next
IIssNan’s Notes
Elegant Theme for Hexo
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo主题优化</title>
    <url>/dev-hexo-theme-optimize/</url>
    <content><![CDATA[前言大概一年前开始使用hexo，主题一直使用jacman。后来Hexo更新到3.0，主题也跟着更新，但是，懒惰的郝同学并没有参与这一更新活动。如今，安装了hexo3.0，问题来了——主题不匹配。当年千辛万苦优化过的主题，又要重新搞起！
选择主题啊嘞，几个月不见，hexo已经如此牛逼！不仅官网更加高端大气上档次，而且主题数量翻了几翻！https://github.com/hexojs/hexo/wiki/Themes ，可以看到，群众的力量是巨大的！换个主题，换个心情，这次我选择了yilia，简洁大气！
添加“关于”hexo new page &quot;about&quot;，编辑hexo/source/about/index.md，编辑hexo/themes/yilia/_config.yml，添加如下：
menu:  关于: /about

添加RSSnpm install hexo-generator-feed --save，
注意，后面的参数--save绝对不能省，否则该插件信息不会写入package.json。hexo clean，hexo g，查看public文件夹，可以看到atom.xml文件。
添加sitemapnpm install hexo-generator-sitemap --save。hexo clean，hexo g，查看public文件夹，可以看到sitemap.xml文件。sitemap的初衷是给搜索引擎看的，为了提高搜索引擎对自己站点的收录效果，我们最好手动到google和百度等搜索引擎提交sitemap.xml。
添加多说http://duoshuo.com/ ，注册一个账号。登录，添加新站点voidking。在工具，获取代码界面，可以看到通用代码：
&lt;!-- 多说评论框 start --&gt;	&lt;div class="ds-thread" data-thread-key="请将此处替换成文章在你的站点中的ID" data-title="请替换成文章的标题" data-url="请替换成文章的网址"&gt;&lt;/div&gt;&lt;!-- 多说评论框 end --&gt;&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;&lt;script type="text/javascript"&gt;var duoshuoQuery = &#123;short_name:"voidking"&#125;;	(function() &#123;		var ds = document.createElement('script');		ds.type = 'text/javascript';ds.async = true;		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';		ds.charset = 'UTF-8';		(document.getElementsByTagName('head')[0] 		 || document.getElementsByTagName('body')[0]).appendChild(ds);	&#125;)();	&lt;/script&gt;&lt;!-- 多说公共JS代码 end --&gt;

var duoshuoQuery = {short_name:&quot;voidking&quot;};中的voidking，就是我们要用到的duoshuo-key，也有人称之为duoshuo_shortname。打开hexo/themes/yilia/layout/_partial/post/duoshuo.ejs，可以看到：
&lt;div class="duoshuo"&gt;	&lt;!-- 多说评论框 start --&gt;	&lt;div class="ds-thread" data-thread-key="&lt;%=key%&gt;" data-title="&lt;%=title%&gt;" data-url="&lt;%=url%&gt;"&gt;&lt;/div&gt;	&lt;!-- 多说评论框 end --&gt;	&lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;	&lt;script type="text/javascript"&gt;	var duoshuoQuery = &#123;short_name:"&lt;%=theme.duoshuo%&gt;"&#125;;	(function() &#123;		var ds = document.createElement('script');		ds.type = 'text/javascript';ds.async = true;		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';		ds.charset = 'UTF-8';		(document.getElementsByTagName('head')[0] 		 || document.getElementsByTagName('body')[0]).appendChild(ds);	&#125;)();	&lt;/script&gt;	&lt;!-- 多说公共JS代码 end --&gt;&lt;/div&gt;
我们需要填入的，是&lt;%=theme.duoshuo%&gt;的值，那么，在哪里填入呢？在hexo/themes/yilia/_config.yml文件中。是这样的，我们可以认为，_config.yml就是theme，而在_config.yml中写入duoshuo: voidking，就是给duoshuo赋值为voidking。
当然，你也可以直接在duoshuo.ejs中把&lt;%=theme.duoshuo%&gt;替换为voidking。但是不建议这么做，因为这样破坏了作者可复用性设计。
添加头像在hexo/themes/yilia/source/img中添加一个图片headportrait.jpg，然后编辑hexo/themes/yilia/_config.yml：
#你的头像urlavatar: "img/headportrait.jpg"

添加favicon使用Axialis IconWorkshop，制作一个16X16的favicon.png。放置到hexo/themes/yilia/source中，然后编辑hexo/themes/yilia/_config.yml：
favicon: /favicon.png

添加好之后，本地测试，只有主页会显示favicon，其他页面不显示，不知道是什么原因。
找了很久没找到解决办法，狠了狠心，直接上传。惊奇地发现，上传到gitcafe之后，所有页面都可以显示favicon。
archieves数量要修改hexo主题，多少要懂得一点hexo的结构和原理。全局配置文件hexo/_config.yml中有这么一段：
per_page: 5pagination_dir: page

这里的per_page，同时设置index、archive、tag、categoriy。如果想要单独设置，可以这么写：
index_generator:  per_page: 5archive_generator:  per_page: 200  yearly: true    monthly: true tag_generator:  per_page: 10 category_generator:   per_page: 10

CategoriesLitten大哥，你这不要Categories是什么节奏？修改起来，非常不容易哇！需要修改的文件有hexo/themes/yilia/source/js/main.js，hexo/themes/yilia/source/css/_partial/main.styl，hexo/themes/yilia/layout/_partial/left-col.ejs。也许还有别的文件，修改了一下午，以失败告终。。。总之，还是能力不够，看来得找时间系统学习一下hexo主题的制作了。。。先放着吧！
添加文章目录TOC (Table of contents) ，中文翻译做目录。之前用jacman，感觉目录很方便，可以很快定位文章内容，尤其对于长文章来说。但是，yilia貌似没有集成，那就自己添加吧！查找资料，居然找到了好友twiceYuan的写的教程，世界真小哇！详情请访问参考文档，摘录twiceYuan的教程如下：
修改article.ejs打开hexo/themes/yilia/layout/_partial/article.ejs，在&lt;%- post.content %&gt;前面插入：
&lt;% if(post.toc !== false)&#123; %&gt;	&lt;div id="toc" class="toc-article"&gt;	  &lt;strong class="toc-title"&gt;文章目录&lt;/strong&gt;	  &lt;%- toc(post.content) %&gt;	&lt;/div&gt;&lt;%&#125;%&gt;

这里加了一个post.toc的判断，也就是说，只有在启用toc的post会出现目录，而不是每篇文章都出现。
修改article.yml打开hexo/themes/yilia/layout/source/css/_partial/article.yml，在最后插入：
/*toc*/.toc-article  background #eeeeee  margin 2em 0 0 0.2em  padding 1em  border-radius 5px  .toc-title    font-size 120%  strong    padding 0.3em 1ol.toc  width 100%  margin 1em 2em 0 0#toc  line-height 1em  font-size 0.8em  float right  .toc    padding 0     li      list-style-type none  .toc-child     padding-left 0em#toc.toc-aside  display none  width 13%  position fixed  right 2%  top 320px  overflow hidden  line-height 1.5em  font-size 1em  color color-heading  opacity .6  transition opacity 1s ease-out  strong    padding 0.3em 0    color color-font  &amp;:hover    transition opacity .3s ease-out    opacity 1  a    transition color 1s ease-out    &amp;:hover      color color-theme      transition color .3s ease-out

使用编辑.md文档，如果要使用文章目录，就要文章开头添加toc属性并且设置为true。
title: hexo主题优化date: 2015-05-31 16:22:12updated: 2015-05-31 16:22:12tags:categories: 专业toc: true

新的问题小伙伴很靠谱，这个方法可用！但是，新的问题来了，文章目录特别紧凑，不够人性化，应该是因为主题差别。于是，参考格式良好的css文件，改写了article.styl的/*toc*/部分：
/*toc*/.toc-article&#123;  background #eee  margin 0 0 0 0.2em  padding 1em  border-radius 5px  -webkit-border-radius 5px  strong&#123;	padding 0.3em 0  &#125;&#125;  #toc&#123;  line-height 1.5em  font-size 1em  float right  ol&#123;	margin-left: 0  &#125;	  .toc&#123;	padding 0	li&#123;	  list-style-type none	&#125;    &#125;      .toc-child&#123;	padding-left 1.5em  &#125;&#125;
问题完美解决，看来，不同的theme，添加TOC的时候，确实需要个性定制。
奇怪现象添加目录后，出现了一个奇怪的现象：如果一篇文章在主页展示全部内容，也就是没有添加&lt;!--more--&gt;，那么，该文章就会自动生成目录，无论文章中有没有添加toc属性。且不去管它，等到技术更加牛逼了再来处理。……等一下，貌似有了灵感，修改article.ejs如下：
&lt;% if(post.toc &amp;&amp; post.toc !== false)&#123; %&gt;	&lt;div id="toc" class="toc-article"&gt;	  &lt;strong class="toc-title"&gt;文章目录&lt;/strong&gt;	  &lt;%- toc(post.content) %&gt;	&lt;/div&gt;&lt;%&#125;%&gt;


修改完成，执行命令：
hexo clean，hexo g，hexo s。
查看效果，主页目录没有了，Perfect！
书写代码块一直以来，写博客的时候，如果用到代码块，都是用三个反引号包围。现在发现，似乎出现了问题。如果连续两个代码块，那么，经常出现一种情况：判断代码块不准确，两个代码块被当成了一个代码块。而如果代码块使用缩进一个TAB的方法，那么，代码块前面就会没有行号。。。。麻烦的问题，且不去管它。。。
文章模板打开hexo/scaffolds/post.md，可以看到：
title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:---
如果我们想要在每次生成.md文件的时候，自动生成categories和toc，可以修改如下：
title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;tags:categories: toc: true---
参考文档hexo博客的优化技巧续http://zipperary.com/hexo-guide-5/

如何在谷歌站长工具提交网站地图sitemap.xmlhttp://jingyan.baidu.com/article/066074d669a958c3c31cb076.html

Hexo 3.0 静态博客使用指南http://segmentfault.com/a/1190000002592993

hexo你的博客http://ibruce.info/hexo-your-blog/

twiceYuan：为Hexo添加文章目录

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate高级应用</title>
    <url>/dev-hibernate-senior/</url>
    <content><![CDATA[Hibernate批量处理批量插入Hibernate直接处理首先在hibernate.cfg.xml中设置批量尺寸属性hibernate.jdbc.batch_size，最好关闭Hibernate的二级缓存以提高效率。
&lt;hibernate-configuration&gt;	&lt;session-factory&gt;		&lt;property name="hibernate.jdbc.batch_size"&gt;50&lt;/property&gt;		&lt;property name="hibernate.jdbc.use_second_level_cache"&gt;false&lt;/property&gt;	&lt;/session-factory&gt;&lt;/hibernate-configuration&gt;
下面批量插入500个课程到数据库表中：
//KcbBatch.javapackage com.voidking.hibernate.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.hibernate.model.Kcb;public class KcbBatch &#123;	public static void main(String[] args)&#123;		//创建Session对象		Configuration cfg = new Configuration();        SessionFactory sf = cfg.configure().buildSessionFactory();		Session session = sf.openSession();				//创建事务对象		Transaction ts=session.beginTransaction();				for (int i = 0; i &lt; 500; i++) &#123;			Kcb kcb = new Kcb();			kcb.setKch(i+"");			session.save(kcb);			if(i%50==0)			&#123;				session.flush();				session.clear();			&#125;		&#125;				ts.commit();				session.close();		sf.close();			&#125;&#125;



调用JDBC由于Hibernate只是对JDBC进行了轻量级的封装，因此完全可以绕过Hibernate直接用JDBC进行批量插入。因此上面的代码可以改成：
//KcbBatch.javapackage com.voidking.hibernate.test;import java.sql.Connection;import java.sql.PreparedStatement;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.hibernate.model.Kcb;public class KcbBatch2 &#123;	public static void main(String[] args)&#123;		//创建Session对象		Configuration cfg = new Configuration();        SessionFactory sf = cfg.configure().buildSessionFactory();		Session session = sf.openSession();				//创建事务对象		Transaction ts=session.beginTransaction();				Connection conn = session.connection();				try &#123;			PreparedStatement stmt = conn.prepareStatement("insert into kcb(kch) values(?)");			for(int i=0;i&lt;500;i++)			&#123;				stmt.setString(1, i+"");				stmt.addBatch();			&#125;		&#125; catch (Exception e) &#123;			e.printStackTrace();		&#125;				ts.commit();				session.close();		sf.close();			&#125;&#125;

对比在用Hibernate进行操作的时候操作的是表对应的类，而在用JDBC进行操作时操作的是数据库中的表。
批量更新Hibernate直接处理为了使Hibernate的HQL直接支持update/delete的批量更新语法，首先要hibernate.cfg.xml中设置HQL/SQL查询翻译器属性hibernate.query.factory_class。
&lt;property name="hibernate.query.factory_class"&gt;	org.hibernate.hql.ast.ASTQueryTranslatorFactory&lt;/property&gt;
为了防止类名输入错误，可以按住Ctrl键，同时单击这个类名。如果可以跳转到.class文件，说明输入正确，否则输入错误。下面使用HQL批量更新把课程表中XS修改为30。
Query query = session.createQuery("update kcb set xs=30");query.executeUpdate();


调用JDBCtry&#123;	Statement stmt = conn.createStatement();	stmt.executeUpdate("update kcb set xs=30");&#125;catch(Exception)&#123;	e.printStackTrace();&#125;

批量删除Hibernate直接处理删除课程表中课程号大于200的课程。
Query query = session.createQuery("delete kcb where kch &gt; 200");query.executeUpdate();
调用JDBCtry&#123;	Statement stmt = conn.createStatement();	stmt.executeUpdate("delete from kcb where kch&gt;200");&#125;catch(Exception)&#123;	e.printStackTrace();&#125;

实体对象生命周期实体对象，特指Hibernate O/R映射关系中的域对象（即O/R中的O）。
transient（瞬时态）瞬时态，即实体对象在内存中的存在，与数据库中的记录无关。
Student stu = new Student();stu.setSnumber("081101");stu.setSname("李方方");stu.setSage(21);
这里的stu对象，与数据库中的记录没有任何关联。
persisent（持久态）Student stu = new Student();stu.setSnumber("081101");stu.setSname("李方方");stu.setSage(21);Student stu1 = new Student();stu1.setSnumber("081102");stu1.setSname("程明");stu1.setSage(22);Transaction ts = session.beginTransaction();session.save(stu);//stu对象转换为持久态，由Hibernate纳入实体管理器；stu1仍然处于瞬时态ts.commit();Transaction ts2 = session.beginTransaction();stu.setSname("李方");//虽然这个事务没有显式调用session.sava()保存stu对象，但是由于stu为持久态，将自动被固化到数据库stu1.setSname("程明明");//stu1仍是一个普通Java对象，对数据库未产生任何影响ts2.commit();
处于瞬时态的对象，可以通过Session的save()方法转换成持久状态。同样，如果一个实体对象由Hibernate加载，那么，它也处于持久状态。
Student stu = (Student)session.load(Student.class,net Integer(1));
持久对象对应着数据库中的一条记录，可以看做是数据库记录的对象化操作接口，其状态的变更将对数据库中的记录产生影响。
Detached（脱管状态）处于持久化的对象，其对应的Session实例关闭之后，此对象就处于脱管状态。Session实例可以看做是持久对象的宿主，一旦此宿主失效，其从属的持久对象进入脱管状态。
Student stu = new Student();//stu对象为瞬时态stu.setSnumber("081101");stu.setSname("李方方");stu.setSage(21);Transaction ts = session.beginTransaction();session.save(stu);//stu对象由Hibernate纳入管理容器，处于持久状态ts.commit();session.close();//stu对象为脱管状态，因为与其关联的session已经关闭
托管态和瞬时态有什么区别？瞬时状态的stu对象与库表中的数据缺乏对应关系，而脱管状态的stu对象，却在库表中存在相对应的记录，只不过由于脱管对象脱离Session这个数据操作平台，其状态的改变无法更新到库表中对应的记录。
有时候为了方便，将处于瞬时和脱管状态的对象统称为值对象（Value Object，VO），将处于持久态的对象称为持久对象（Persistent Object，PO）。也就是说，对Hibernate实体管理容器而言，非管理的实体对象统称为VO，被管理的对象称为PO。
Hibernate事务管理事务是数据库并发控制不可分割的基本工作单位，具有原子性、一致性、隔离性和持久性的特点。
事务（Transaction）是工作中的基本逻辑单元，可以用于确保数据库能够被正确修改，避免数据只修改一部分而导致数据不完整，或者在修改时受到用户干扰。
基于JDBC的事务管理Hibernate是JDBC的轻量级封装，本身并不具备事务管理能力。在事务管理层，Hibernate将其委托给底层的JDBC或JTA，以实现事务管理和调度功能。
在JDBC中，事务默认是自动提交。也就是说，一条对数据库的更新表达式代表一项事务操作。操作成功后，系统将自动调用commit提交。否则，将调用rollback回滚。
在JDBC中，可以通过调用setAutoCommit(false)禁止自动提交。之后就可以把多个数据库操作的表达式作为一个事务，在操作完成后调用commit进行整体提交。
将事务管理委托给JDBC进行处理是最简单的实现方式，Hibernate对于JDBC事务的封装也比较简单。如下面的代码：
//创建Session对象Configuration cfg = new Configuration();SessionFactory sf = cfg.configure().buildSessionFactory();Session session = sf.openSession();//创建事务对象Transaction ts=session.beginTransaction();seesion.save(stu);ts.commit();session.close();sf.close();
从JDBC层面而言，上面的代码实际对应着：
Connection cn = getConnection;cn.setAutoCommit(false);//JDBC调用相关的SQL语句cn.commit();

在sf.openSession()语句中，Hibernate会初始化数据库连接。与此同时，将其AutoCommit设为关闭状态（false）。即一开始获得的session，其自动提交属性已经被关闭。下面的代码不会对数据库产生任何效果：
//创建Session对象Configuration cfg = new Configuration();SessionFactory sf = cfg.configure().buildSessionFactory();Session session = sf.openSession();seesion.save(stu);session.close();sf.close();
这实际上相当于JDBC Connection的AutoCommit属性被设为false，执行了若干JDBC操作之后，没有调用commit操作。
基于JTA的事务管理JTA（Java Transaction API）是由Java EE Transaction Manager去管理的事务。其最大的特点是调用UserTransaction接口的begin、commit和rollback方法来完成事务范围的界定、事务的提交和回滚。JTA可以实现统一事务对应不同的数据库。
JTA主要用于分布式的多个数据源的两阶段提交的事务，而JDBC的Connection提供单个数据源的事务。后者因为只涉及一个数据源，所以其事务可以由数据库自己单独实现。而JTA事务因为其分布式和多数据库的特性，不可能由任何一个数据源实现事务。因此，JTA中的事务是由“事务管理器”实现的。它会在多个数据源之间统筹事务，具体使用的技术就是所谓的“两阶段提交”。
JTA提供了跨Session的事务管理能力。这一点是与JDBC Transaction最大的差异。JDBC事务由Connection管理，即事务管理实际上是在JDBC Connection中实现。事务周期限于Connection的生命周期之内。同样，对于基于JDBC Transaction的Hibernate事务管理机制而言，事务管理在Session所依托的JDBC Connection中实现，事务周期限于Session的生命周期。
JTA事务管理则由JTA容器实现。JTA对当前加入事务的众多Connection进行调度，实现事务性要求。JTA的事务周期可以横跨多个JDBC Connection生命周期。同样，对于基于JTA事务的Hibernate而言，JTA事务横跨多个Session。
锁Hibernate支持两种锁机制，悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）。悲观锁是指对数据被外界修改保持保守态度。假定任何时刻存取数据时，都可能有一个客户也正在存取同一数据。为了保持数据被操作的移植性，于是对数据采取了数据库层次的锁定状态，依靠数据库提供的锁机制来实现。
乐观锁则乐观地认为数据很少发生同时存取的问题，因此不做数据库层次上的锁定。为了维护正确的数据，乐观锁采用应用程序上的逻辑实现版本控制的方法。
源代码分享Hibernate概述、Hibernate关系映射、Hibernate高级应用，三篇博客中使用的代码，都在下面这个工程。https://github.com/voidking/hibernate.git
参考文档《Java EE基础实用教程》，郑阿奇主编
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IDEA开发Maven JavaWeb迷你项目</title>
    <url>/dev-idea-maven-javaweb-miniproject/</url>
    <content><![CDATA[项目简介本文中，我们使用Mybatis+Spring+SpringMVC来完成一个迷你JavaWeb项目：用户管理系统。功能：普通用户可以注册登录，管理员可以管理普通用户。
环境准备安装jdk参考《全平台安装JDK》。
安装maven下载地址： http://maven.apache.org/download.cgi
1、解压到自己喜欢的目录（这里郝同学放到D:\Server路径下）。2、添加环境变量M2_HOME，值为D:\Server\apache-maven-3.3.93、在Path中添加;%M2_HOME%\bin;。
打开命令提示符，输入mvn -v，如果能够看到maven版本号，说明安装成功。
安装tomcat1、tomcat下载地址：http://tomcat.apache.org/download-80.cgi
2、假设解压目录为D:\Server\apache-tomcat-8.5.9。
3、进入目录D:\Server\apache-tomcat-8.5.9\bin，双击startup.bat。
4、浏览器访问http://localhost:8080，启动成功则显示tomcat管理页面。
idea配置idea配置参考《IDEA快捷键和配置》。
新建Web项目1、打开idea，File，New，Project，右边导航栏选择Maven，勾选Create from archetype，选择maven-archetype-webapp。
2、Next，输入GroupId为“com.voidking.pandawork”，输入ArtifactId为“pandawork-start”。
3、Next，选择自己安装的Maven中的User settings file，选择settings.xml中配置的Local repository。
4、Next，输入Project name，选择Project location，Finish。
5、稍等几十秒，Web项目便可以创建成功。
初始化项目结构1、展开pandawork-start项目，展开src文件夹。
2、右键main文件夹，New，Directory，输入directory name为“java”。
3、右键main/java文件夹，New，Package，输入package name为“com.voidking.pandawork”。右键“com.voidking.pandawork”，新建文件README.md。
3、右键main/resources文件夹，New，Directory，输入directory name为“com.voidking.pandawork”。
3、至此，初始化项目结构完成。


持久层新建数据库1、使用navicat新建mysql数据库，数据库名为pandawork，字符集选择utf8–UTF-8 Unicode，排序规则选择utf8_general_ci。
2、新建表t_user，包括id、username、password三个字段。
DROP TABLE IF EXISTS `t_user`;CREATE TABLE `t_user` (  `id` int(8) NOT NULL AUTO_INCREMENT,  `username` varchar(16) NOT NULL,  `password` varchar(16) NOT NULL,  PRIMARY KEY (`id`)) ENGINE=MyISAM DEFAULT CHARSET=utf8;

mybatis的maven配置在pom.xml中，添加：
&lt;dependency&gt;  &lt;groupId&gt;org.mybatis&lt;/groupId&gt;  &lt;artifactId&gt;mybatis&lt;/artifactId&gt;  &lt;version&gt;3.4.4&lt;/version&gt;&lt;/dependency&gt;

连接mysql1、在pom.xml中，添加：
&lt;!-- mysql驱动 --&gt;&lt;dependency&gt;  &lt;groupId&gt;mysql&lt;/groupId&gt;  &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;  &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt;


2、右键resources文件夹，新建文件mybatis-config.xml，内容如下：
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;    &lt;environments default="development"&gt;        &lt;environment id="development"&gt;            &lt;transactionManager type="JDBC"/&gt;            &lt;dataSource type="POOLED"&gt;                &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt;                &lt;property name="url" value="jdbc:mysql://localhost:3306/pandawork"/&gt;                &lt;property name="username" value="root"/&gt;                &lt;property name="password" value="mysql"/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;    &lt;mappers&gt;        &lt;mapper resource="com/voidking/pandawork/mapper/user.mapper.xml"/&gt;    &lt;/mappers&gt;&lt;/configuration&gt;

3、main/java文件夹下，右键com.voidking.pandawork，新建包util。
4、右键包uitl，新建连接数据库的类ConnetDB.java，内容如下：
package com.voidking.pandawork.util;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class ConnectDB &#123;    private static volatile ConnectDB instance=null;    private SqlSessionFactory sqlSessionFactory=null;    private ConnectDB()&#123;        try &#123;            String resource = "mybatis-config.xml";            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public static ConnectDB getInstance()&#123;        if(instance==null)&#123;            synchronized(ConnectDB.class)&#123;                if(instance==null)&#123;                    instance=new ConnectDB();                &#125;            &#125;        &#125;        return instance;    &#125;    public SqlSessionFactory getSqlSessionFactory()&#123;        return sqlSessionFactory;    &#125;&#125;

entity1、main/java文件夹下，右键com.voidking.pandawork，新建包entity。2、右键包entity，新建类User.java。
mapper1、main/java文件夹下，右键com.voidking.pandawork，新建包mapper。右键包mapper，新建接口UserMapper.java。2、main/resources文件夹下，右键com.voidking.pandawork，新建包mapper。右键包mapper，新建文件user.mapper.xml。
service1、main/java文件夹下，右键com.voidking.pandawork，新建包service。2、右键包service，新建接口UserService.java。3、右键包service，新建包impl。4、打开UserService.java，鼠标光标聚焦到“public interface UserService”一行，按下alt+enter（或者选择code，generate），选择com.voidking.pandawork.service.impl包，新建接口实现文件UserServiceImpl.java。
test打开UserServiceImpl.java，鼠标光标聚焦到“public class UserServiceImpl implements UserService”一行，按下alt+enter，选择com.voidking.pandawork包，新建测试文件UserServiceTest.java。这样，就在test/java/com.voidking.pandawork包中生成了测试文件。
业务逻辑层spring包在pom.xml中，添加springmvc最小化依赖：
&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;4.3.8.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;  &lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;&lt;/dependency&gt;

applicationContext.xml右键main/resources文件夹，新建applicationContext.xml，不配置任何bean，内容如下：
&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"       xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx"       xsi:schemaLocation="http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans-4.0.xsd                           http://www.springframework.org/schema/tx                           http://www.springframework.org/schema/tx/spring-tx-4.0.xsd                           http://www.springframework.org/schema/aop                           http://www.springframework.org/schema/aop/spring-aop-4.0.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt;&lt;/beans&gt;

springmvc-servlet.xml右键main/resources文件夹，新建springmvc-servlet.xml，内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"       xmlns:mvc="http://www.springframework.org/schema/mvc"       xmlns:context="http://www.springframework.org/schema/context"       xmlns:aop="http://www.springframework.org/schema/aop"       xmlns:tx="http://www.springframework.org/schema/tx"       xsi:schemaLocation="http://www.springframework.org/schema/beans                           http://www.springframework.org/schema/beans/spring-beans-4.0.xsd                           http://www.springframework.org/schema/mvc                           http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd                           http://www.springframework.org/schema/context                           http://www.springframework.org/schema/context/spring-context-4.0.xsd                           http://www.springframework.org/schema/aop                           http://www.springframework.org/schema/aop/spring-aop-4.0.xsd                           http://www.springframework.org/schema/tx                           http://www.springframework.org/schema/tx/spring-tx-4.0.xsd"&gt;    &lt;!-- 设置使用注解的类所在的jar包 --&gt;    &lt;context:component-scan base-package="com.voidking.pandawork.controller" /&gt;&lt;/beans&gt;

web.xml打开main/webapp/WEB-INFO/web.xml，修改内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app  version="3.1" xmlns="http://xmlns.jcp.org/xml/ns/javaee"          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"          xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee                              http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"&gt;  &lt;context-param&gt;    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;    &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;    &lt;!-- 默认是/WEB-INF/applicationContext.xml --&gt;  &lt;/context-param&gt;  &lt;listener&gt;    &lt;listener-class&gt;      org.springframework.web.context.ContextLoaderListener    &lt;/listener-class&gt;  &lt;/listener&gt;  &lt;servlet&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;    &lt;init-param&gt;      &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;      &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;      &lt;!-- 默认是/WEB-INF/[servlet名字]-servlet.xml --&gt;    &lt;/init-param&gt;    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;    &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt;    &lt;url-pattern&gt;/&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;

helloworld1、main/java文件夹下，右键com.voidking.pandawork，新建包controller。右键包controller，新建类HelloWorld.java，内容如下：
package com.voidking.pandawork.controller;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controllerpublic class HelloWorld &#123;    @RequestMapping("/hello")    public @ResponseBody String test() &#123;        return "hello, world! This com from spring!";    &#125;&#125;

2、部署项目到tomcat的8080端口，访问http://localhost:8080/hello，即可看到“hello, world! This com from spring!”。
迷你JavaWeb项目实现具体配置和代码实现请自行阅读代码：pandawork-start
书签
mybatis文档
SpringMVC+Spring4+Mybatis3集成，开发简单Web项目+源码下载
手把手教你搭建SpringMVC——最小化配置

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
        <category>工具</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
        <tag>idea</tag>
        <tag>spring</tag>
        <tag>springmvc</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>通过远程控制接口给服务器安装系统</title>
    <url>/dev-install-sys-by-remote-controller-interface/</url>
    <content><![CDATA[前言《制作Ubuntu安装盘方法小结》一文中，总结了U盘和光盘两种安装源的制作方法，也提到了硬盘安装和网络安装。我们已经知道，通过网络安装源可以进行批量安装。而如果使用远程控制接口进行安装，则可以实现远程安装，不用进入机房。本文中，就研究一下远程控制接口的配置方法，并且通过该接口进行系统安装。


远程控制接口配置不同的服务器，有着不同的远程控制接口，具体可以参考书签中的内容。本文中使用的服务器是曙光I620-G20，管理接口名为mgmt。主要参考配置管理口管理曙光服务器。
1、开机点击delete进入BIOS设置，切换到ServerManage。
2、BMC Support设置为Enabled。选中BMC network configuration，进行网络配置。
3、选中Configuration Address source，选择Static。
4、根据网络情况设置静态IP，设置完成后Save Configuration，然后点击F4保存退出。
远程管理基本管理1、浏览器访问服务器的管理IP，即可看到曙光的登录页面。
2、填入用户名密码（默认都是admin），进入管理页面。此外，这组用户名密码，也可以ssh登录到服务器。
3、在管理页面有很多选项卡，这里我们点击“远程控制”。
4、点击控制台重定向，Java终端，网页会下载jviewer.jnlp文件。
5、双击jviewer.jnlp，会提示Java更新（这里更新或者不更新都可以），启动报错。点开详细看到报错：
JNLPException[category: 安全错误 : Exception: null : LaunchDesc: &lt;jnlp spec="1.0+" codebase="http://172.16.101.162:80/Java"&gt;  ......&lt;/jnlp&gt; ]    at com.sun.javaws.security.JNLPSignedResourcesHelper.checkSignedResourcesHelper(Unknown Source)    at com.sun.javaws.security.JNLPSignedResourcesHelper.checkSignedResources(Unknown Source)    at com.sun.javaws.Launcher.prepareResources(Unknown Source)    at com.sun.javaws.Launcher.prepareAllResources(Unknown Source)    at com.sun.javaws.Launcher.prepareToLaunch(Unknown Source)    at com.sun.javaws.Launcher.prepareToLaunch(Unknown Source)    at com.sun.javaws.Launcher.launch(Unknown Source)    at com.sun.javaws.Main.launchApp(Unknown Source)    at com.sun.javaws.Main.continueInSecureThread(Unknown Source)    at com.sun.javaws.Main.access$000(Unknown Source)    at com.sun.javaws.Main$1.run(Unknown Source)    at java.lang.Thread.run(Unknown Source)

6、打开jviewer.jnlp文件，内容为：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;jnlp spec="1.0+" codebase="http://172.16.101.162:80/Java"&gt;     &lt;information&gt;        &lt;title&gt;JViewer&lt;/title&gt;        &lt;vendor&gt;American Megatrends, Inc.&lt;/vendor&gt;        &lt;description kind="one-line"&gt;JViewer Console Redirection Application&lt;/description&gt;        &lt;description kind="tooltip"&gt;JViewer Console Redirection Application&lt;/description&gt;        &lt;description kind="short"&gt;            JViewer enables a user to view the video display of managed server via KVM.              It also enables the user to redirect his local keyboard, mouse for managing the server remotely.        &lt;/description&gt;    &lt;/information&gt;    &lt;security&gt;        &lt;all-permissions/&gt;    &lt;/security&gt;    &lt;resources&gt;        &lt;j2se version="1.5+"/&gt;        &lt;jar href="release/JViewer.jar"/&gt;    &lt;/resources&gt;    &lt;resources&gt;        &lt;j2se version="1.5+"/&gt;        &lt;jar href="release/JViewer-SOC.jar"/&gt;    &lt;/resources&gt;    &lt;resources os="Windows" arch="x86"&gt;        &lt;j2se version="1.5+"/&gt;        &lt;nativelib href="release/Win32.jar"/&gt;    &lt;/resources&gt;        &lt;resources os="Windows" arch="amd64"&gt;           &lt;j2se version="1.5+"/&gt;           &lt;nativelib href="release/Win64.jar"/&gt;    &lt;/resources&gt;    &lt;resources os="Linux" arch="x86"&gt;        &lt;j2se version="1.5+"/&gt;        &lt;nativelib href="release/Linux_x86_32.jar"/&gt;    &lt;/resources&gt;        &lt;resources os="Linux" arch="i386"&gt;        &lt;j2se version="1.5+"/&gt;        &lt;nativelib href="release/Linux_x86_32.jar"/&gt;    &lt;/resources&gt;        &lt;resources os="Linux" arch="x86_64"&gt;        &lt;j2se version="1.5+"/&gt;        &lt;nativelib href="release/Linux_x86_64.jar"/&gt;    &lt;/resources&gt;        &lt;resources os="Linux" arch="amd64"&gt;        &lt;j2se version="1.5+"/&gt;        &lt;nativelib href="release/Linux_x86_64.jar"/&gt;    &lt;/resources&gt;    &lt;resources os="Mac OS X" arch="i386"&gt;    &lt;j2se version="1.5+"/&gt;    &lt;nativelib href="release/Mac32.jar"/&gt;    &lt;/resources&gt;     &lt;resources os="Mac OS X" arch="x86_64"&gt;    &lt;j2se version="1.5+"/&gt;    &lt;nativelib href="release/Mac64.jar"/&gt;    &lt;/resources&gt;     &lt;application-desc&gt;        &lt;argument&gt;-apptype&lt;/argument&gt;&lt;argument&gt;JViewer&lt;/argument&gt;&lt;argument&gt;-hostname&lt;/argument&gt;&lt;argument&gt;172.16.101.162&lt;/argument&gt;&lt;argument&gt;-kvmtoken&lt;/argument&gt;&lt;argument&gt;nOLAdVHdp02q3dSQ&lt;/argument&gt;&lt;argument&gt;-kvmsecure&lt;/argument&gt;&lt;argument&gt;0&lt;/argument&gt;&lt;argument&gt;-kvmport&lt;/argument&gt;&lt;argument&gt;80&lt;/argument&gt;&lt;argument&gt;-vmsecure&lt;/argument&gt;&lt;argument&gt;0&lt;/argument&gt;&lt;argument&gt;-cdstate&lt;/argument&gt;&lt;argument&gt;1&lt;/argument&gt;&lt;argument&gt;-fdstate&lt;/argument&gt;&lt;argument&gt;1&lt;/argument&gt;&lt;argument&gt;-hdstate&lt;/argument&gt;&lt;argument&gt;1&lt;/argument&gt;&lt;argument&gt;-cdnum&lt;/argument&gt;&lt;argument&gt;1&lt;/argument&gt;&lt;argument&gt;-fdnum&lt;/argument&gt;&lt;argument&gt;1&lt;/argument&gt;&lt;argument&gt;-hdnum&lt;/argument&gt;&lt;argument&gt;1&lt;/argument&gt;&lt;argument&gt;-extendedpriv&lt;/argument&gt;&lt;argument&gt;259&lt;/argument&gt;&lt;argument&gt;-localization&lt;/argument&gt;&lt;argument&gt;EN&lt;/argument&gt;&lt;argument&gt;-keyboardlayout&lt;/argument&gt;&lt;argument&gt;AD&lt;/argument&gt;&lt;argument&gt;-websecureport&lt;/argument&gt;&lt;argument&gt;443&lt;/argument&gt;&lt;argument&gt;-singleportenabled&lt;/argument&gt;&lt;argument&gt;1&lt;/argument&gt;&lt;argument&gt;-webcookie&lt;/argument&gt;&lt;argument&gt;q7U2w5QbKeOD77EYPgTQMWyjJzAKblir000&lt;/argument&gt;&lt;argument&gt;-oemfeatures&lt;/argument&gt;&lt;argument&gt;9&lt;/argument&gt;    &lt;/application-desc&gt;&lt;/jnlp&gt;

报错解决1、参考java8u121 unable open topcoder arena，添加例外站点。（1）Win+S，搜索“Java Control Panel”或者“配置Java”。（2）点击“安全”选项卡，编辑站点列表。添加：
http://172.16.101.162:80

重新启动jviewer.jnlp，依然报错。
2、参考Java Web start未签名的应用程序请求对系统无限制访问，对JDK进行降级。（1）卸载JDK8，必须得卸载，否则多个版本JDK会有冲突。（2）下载JDK6，并安装。（3）参考《IDEA的常用配置》中的JDK配置，修改JAVA_HOME为新的JDK安装目录。
重新启动jviewer.jnlp，果然启动成功。（如果找不到打开的软件，可以手动选择javaws.exe）需要注意的是，要先在浏览器中打开控制台重定向的页面，再启动jviewer.jnlp。否则会报错invalid web session，而且只能看到一个黑色的控制台，没有任何内容。而且，jviewer.jnlp文件有使用期限，每次远程控制都需要重新下载，因为该文件中的kvmtoken是会发生变化的。
安装系统1、在Windows系统中创建share目录，并且设置共享。然后把ubuntu-16.04.4-server-amd64.iso镜像拷贝到share目录。
2、在控制台的工具栏上，点击CD/DVD Media，打开选择Virtual Media对话框。
3、选择镜像，然后点击“Connect CD/DVD”，连接成功后close即可。
4、重启服务器，按Del进入BIOS设置，选择从虚拟光驱引导。（如果之前没有安装过系统则不需要此步骤）
5、然后，服务器就进入了正常安装步骤。
后记由本文中的实践可以看出，使用远程控制接口可以帮助机房管理员进行主机的管理，包括系统的安装，非常方便。那么，网络安装源结合远程控制接口，是不是可以实现批量远程安装系统？理论上是完全可行的。
书签华为服务器远程安装系统
DELL iDRAC服务器远程控制设置
BMC ipmitool 对linux服务器进行IPMI管理
曙光天阔服务器远程控制手册
曙光IPMI系统管理平台用户使用指南
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Java API概览</title>
    <url>/dev-java-api/</url>
    <content><![CDATA[前言今天，在开发Android的时候，发现自己对Android缺乏全局掌控的感觉。为什么这么说呢？比如，要实现的功能是帧动画，我根本不知道Android提供了一个AnimationDrawable类。
是因为Java没学好？不是，但是Java确实还有很大的进步空间。借此机会，捋一捋Java各个包和类的作用！


javajava类库是java发布之初就确定了的基础库，是核心包。
applet提供创建 applet 所必需的类和 applet 用来与其 applet 上下文通信的类。 
applet 框架包括两种实体：applet 和 applet 上下文。applet 是一种可嵌入的窗体（参见 Panel 类），它带有几个 applet 上下文用来初始化、启动和终止 applet 的额外方法。 
applet 上下文是负责加载和运行 applet 的应用程序。例如，applet 上下文可能是 Web 浏览器或 applet 开发环境。 
awt包含用于创建用户界面和绘制图形图像的所有类。在 AWT 术语中，诸如按钮或滚动条之类的用户界面对象称为组件。Component 类是所有 AWT 组件的根。有关所有 AWT 组件的公共属性的详细描述，请参见 Component。 
当用户与组件交互时，一些组件会激发事件。AWTEvent 类及其子类用于表示 AWT 组件能够激发的事件。有关 AWT 事件模型的描述，请参见 AWTEvent。 
容器是一个可以包含组件和其他容器的组件。容器还可以具有布局管理器，用来控制容器中组件的可视化布局。AWT 包带有几个布局管理器类和一个接口，此接口可用于构建自己的布局管理器。有关更多信息，请参见 Container 和 LayoutManager。
colordnddatatransfereventfontgeomimimageprintdoc-filesbeans包含与开发 beans 有关的类，即基于 JavaBeans™ 架构的组件。少数类可由 bean 使用，也能以应用程序的形式运行。例如，event 类由激发属性和禁止更改事件的 bean 使用（参见 PropertyChangeEvent）。不过，此包中的大多数类由 bean 编辑器（即自定义 bean 并将其汇集起来以创建应用程序的开发环境）使用。特别要指出的是，这些类帮助 bean 编辑器创建用户可以用来自定义 bean 的用户界面。例如，bean 可能包含 bean 编辑器也许不知道如何处理的特殊类型的属性。通过使用 PropertyEditor 接口，bean 开发人员可以为此特殊类型提供一个编辑器。 
为了最大限度地减少 bean 使用的资源，只在要编辑 bean 时加载 bean 编辑器使用的类。当 bean 以应用程序的形式运行时，不需要这些类，所以不用加载它们。此信息在称为 bean-info 的类中（参见 BeanInfo）。 
除非显式声明，否则 null 值或空 String 对于此包中的方法是无效参数。如果使用这些参数，可能将引发异常。
beancontextio通过数据流、序列化和文件系统提供系统输入和输出。 除非另有说明，否则向此包的任何类或接口中的构造方法或方法传递 null 参数时，都将抛出 NullPointerException。 
lang提供利用 Java 编程语言进行程序设计的基础类。最重要的类是 Object（它是类层次结构的根）和 Class（它的实例表示正在运行的应用程序中的类）。 
把基本类型的值当成一个对象来表示通常很有必要。包装器类 Boolean、Character、Integer、Long、Float 和 Double 就是用于这个目的。例如，一个 Double 类型的对象包含了一个类型为 double 的字段，这表示如果引用某个值，则可以将该值存储在引用类型的变量中。这些类还提供了大量用于转换基值的方法，并支持一些标准方法，比如 equals 和 hashCode。Void 类是一个非实例化的类，它保持一个对表示基本类型 void 的 Class 对象的引用。 
类 Math 提供了常用的数学函数，比如正弦、余弦和平方根。类似地，类 String 和 StringBuffer 提供了常用的字符串操作。 
类 ClassLoader、Process、Runtime、SecurityManager 和 System 提供了管理类的动态加载、外部进程创建、主机环境查询（比如时间）和安全策略实施等“系统操作”。 
类 Throwable 包含了可能由 throw 语句抛出的对象(§14.16)。Throwable 的子类表示错误和异常。
annotationinstrumentmanagementrefreflectmath提供用于执行任意精度整数算法 (BigInteger) 和任意精度小数算法 (BigDecimal) 的类。BigInteger 除提供任意精度之外，它类似于 Java 的基本整数类型，因此在 BigInteger 上执行的操作不产生溢出，也不会丢失精度。除标准算法操作外，BigInteger 还提供模 (modular) 算法、GCD 计算、基本 (primality) 测试、素数生成、位处理以及一些其他操作。 BigDecimal 提供适用于货币计算和类似计算的任意精度的有符号十进制数字。BigDecimal 允许用户对舍入行为进行完全控制，并允许用户选择所有八个舍入模式。 
net为实现网络应用程序提供类。 
java.net 包可以大致分为两个部分：
1、低级 API，用于处理以下抽象：

地址，也就是网络标识符，如 IP 地址。

套接字，也就是基本双向数据通信机制。

接口，用于描述网络接口。 


2、高级 API，用于处理以下抽象：

URI，表示统一资源标识符。

URL，表示统一资源定位符。

连接，表示到 URL 所指向资源的连接。


nio定义作为数据容器的缓冲区，并提供其他 NIO 包的概述。 
NIO API 的集中抽象为： 

缓冲区，它们是数据容器； 

字符集及其相关解码器和编码器，它们在字节和 Unicode 字符之间进行转换；

各种类型的通道，它们表示到能够执行IO操作的实体的连接；以及选择器和选择键，它们与可选择信道 一起定义了多路的、无阻塞的 I/O 设施。 


channelcharsetrmi提供 RMI 包。RMI 指的是远程方法调用 (Remote Method Invocation)。它是一种机制，能够让在某个 Java 虚拟机上的对象调用另一个 Java 虚拟机中的对象上的方法。可以用此方法调用的任何对象必须实现该远程接口。调用这样一个对象时，其参数为 “marshalled” 并将其从本地虚拟机发送到远程虚拟机（该远程虚拟机的参数为 “unmarshalled”）上。该方法终止时，将编组来自远程机的结果并将结果发送到调用方的虚拟机。如果方法调用导致抛出异常，则该异常将指示给调用方。 
activationdgcregistryserversecurity为安全框架提供类和接口。包括那些实现了可方便配置的、细粒度的访问控制安全架构的类。此包也支持密码公钥对的生成和存储，以及包括信息摘要和签名生成在内的可输出密码操作。最后，此包提供支持 signed/guarded 对象和安全随机数生成的对象。此包中提供的许多类（特别是密码和安全随机数生成器类）是基于提供商的。该类本身定义了应用程序可以写入的编程接口。实现本身可由独立的第三方厂商来写，可以根据需要进行无缝的插入。因此，应用程序开发人员可以利用任何数量的基于提供商的实现而不必添加或重写代码。 
aclcertinterfacesspecsql提供使用Java™编程语言访问并处理存储在数据源（通常是一个关系数据库）中的数据的 API。此 API 包括一个框架，凭借此框架可以动态地安装不同驱动程序来访问不同数据源。尽管 JDBC™ API 主要用于将 SQL 语句传递给数据库，但它还可以用于以表格方式从任何数据源中读写数据。通过接口的 javax.sql.RowSet 组可以使用的 reader/writer 实用程序，可以被定制以使用和更新来自电子表格、纯文本文件或其他任何表格式数据源的数据。
text提供以与自然语言无关的方式来处理文本、日期、数字和消息的类和接口。这意味着所编写的主程序或 applet 是与语言无关的，并且它可以依靠独立的、动态链接的本地化资源。这实现了随时为新本地化添加本地化的灵活性。 
这些类能够格式化日期、数字和消息、解析、搜索和排序字符串，以及迭代字符、单词、语句和换行符。此包包含类和接口的三大主要组： 

用于迭代文本的类 
用于格式化和分析的类 
用于整理字符串的类 spi

util包含 collection 框架、遗留的 collection 类、事件模型、日期和时间设施、国际化和各种实用工具类（字符串标记生成器、随机数生成器和位数组）。 
concurrentjarloggingprefsregexspizipjavaxjavax的x是extension的意思，也就是扩展包。javax类库是在java类库上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。
accessibility定义了用户界面组件与提供对这些组件进行访问的辅助技术之间的协定。如果 Java 应用程序完全支持 Java Accessibility API，则它应该与屏幕读取器、屏幕放大器这样的辅助技术保持兼容和友好。使用完全支持 Java Accessibility API 的 Java 应用程序，将不再需要离屏模型的屏幕读取器 ，因为该 API 提供了离屏模型中通常所包含的所有信息。 
activationprocessingactivity包含解组期间通过 ORB 机制抛出的与 Activity 服务有关的异常。 
annotationcrypto为加密操作提供类和接口。在此包中定义的加密操作包括加密、密钥生成和密钥协商，以及消息验证码（Message Authentication Code，MAC）生成。 
加密支持包括对称密码、不对称密码、块密码和流密码。此包还支持安全流和密封的对象。 
此包中提供的许多类都是基于提供者的。该类本身定义可以写入应用程序的编程接口。然后可由独立的第三方供应商编写实现本身，并根据需要无缝嵌入。因此，应用程序开发人员可以利用任意数量的基于提供者的实现，而无需添加或重写代码。 
interfacesspecimageioJava Image I/O API 的主要包。 
使用 ImageIO 类的静态方法可以执行许多常见的图像 I/O 操作。 
此包包含一些基本类和接口，有的用来描述图像文件内容（包括元数据和缩略图）(IIOImage)；有的用来控制图像读取过程（ImageReader、ImageReadParam 和 ImageTypeSpecifier）和图像写入过程（ImageWriter 和 ImageWriteParam）；还有的用来执行格式之间的代码转换 (ImageTranscoder) 和报告错误 (IIOException)。 
enventmetadatapluginsspistreamjwssoaplangmodelmanagement提供 Java Management Extensions 的核心类。
Java Management Extensions (JMXTM) API 是一个用于管理和监视的标准 API。典型用途包括：

查询并更改应用程序配置 
累积有关应用程序行为的统计数据并使其可用 
通知状态更改及错误状况。

JMX API 还可以作为解决方案的一部分来管理系统、网络等。
API 包括远程访问，因此，远程管理程序可以基于这些目的与正在运行的应用程序进行交互。
loadingmonitortimerrelationopenmbeanmodelmbeanremotenaming为访问命名服务提供类和接口。 
此包定义 Java Naming and Directory InterfaceTM (JNDI) 的命名操作。  JNDI 向使用 Java 编程语言编写的应用程序提供命名和目录功能。它被设计成与任何特定的命名或目录服务实现无关。因此可以使用共同的方式对多种服务（新的、新出现的及已经部署的服务）进行访问。
directoryeventldapspinet提供用于网络应用程序的类。这些类包括用于创建套接字的工厂。使用套接字工厂可以封装套接字的创建和配置行为。 
sslprint为 Java™ Print Service API 提供了主要类和接口。Java Print Service API 允许客户端和服务器应用程序具备如下功能： 

根据其性能发现并选择 PrintService。 
指定打印数据的格式。 
向支持所打印文档类型的服务提交 PrintJob。 

attributeeventrmi包含 RMI-IIOP 的用户 API。这些 API 供 RMI-IIOP 应用程序使用，并在 IIOP 或 JRMP 上运行时提等效的语法。另请参阅 javax.rmi.CORBA 包。 
CORBAsslscript脚本 API 由定义 Java™ Scripting Engines 的接口和类组成，并为它们在 Java 应用程序中的使用提供框架。此 API 供那些希望在其 Java 应用程序中执行用脚本语言编写的程序的应用程序编程人员使用。脚本语言程序通常由应用程序的终端用户提供。 
securityauthcertsaslsoundsampledmidisql为通过 Java™ 编程语言进行服务器端数据源访问和处理提供 API。此包补充了 java.sql 包，它从 1.4 版本开始包含在 Java 平台、标准版 (Java SETM) 中。它保留了 Java 平台、企业版 (Java EETM) 中的精华部分。 
java.sql 包中提供以下内容： 

DataSource 接口，用于建立到数据源的连接，是 DriverManager 的替代项。 
连接池和语句池 
分布式事务 
Rowset 

应用程序直接使用 DataSource 和 RowSet API，但连接池和分布式事务 API 只能由中间层基础设施在内部使用。
rowsetswing提供一组“轻量级”（全部是 Java 语言）组件，尽量让这些组件在所有平台上的工作方式都相同。有关使用这些组件的程序员指南，请参阅 Creating a GUI with JFC/Swing，该内容在 The Java Tutorial 的结尾处。有关其他参考资料，请参阅相关文档。
bordercolorchooserfilechoosereventtabletexttreeundoplaftools为能够从程序（例如，编译器）中调用的工具提供接口。 
要求这些接口和类作为 Java™ Platform, Standard Edition (Java SE) 的一部分，但是不要求提供任何实现它们的工具。 
除非明确允许，否则只要给定 null 参数或给定包含 null 元素的列表或集合，此包中的所有方法都将抛出 NullPointerException。类似地，除非明确允许，否则所有方法都不可以返回 null。 
此包是 Java 编程语言编译器框架的主要部分。此框架允许框架的客户端查找并运行程序中的编译器。该框架还为结构化访问诊断（DiagnosticListener）提供服务提供者接口（SPI），为重写文件访问提供文件抽象（JavaFileManager 和 JavaFileObject）。有关使用 SPI 的详细信息，请参阅 JavaCompiler。 
transaction包含解组期间通过 ORB 机制抛出的三个异常。 
xaxml根据 XML 规范定义核心 XML 常量和功能。
parsersbindsoapwstransformcryptodatatypevalidationnamespacexpathstreamorgJava的org包是由企业或者组织提供的java类库。集成到jdk中但大部分不是sun公司的，可以直接使用。其中比较常用的是w3c提供的对XML、网页、服务器的类和接口。
ietfigssomgCORBAstubCORBA_2_3CosNamingSendingContextPortableServerPOrtableInterceptorMessagingIOPDynamicDynamicAnyw3cdomxmlsax后记只展开到了第二级，今后如果有需要，再往下展开。
附上Android API概览：http://www.android-doc.com/reference/packages.html
参考文档《JDK API 1.6.0 中文版》
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java网页爬虫</title>
    <url>/dev-java-crawler/</url>
    <content><![CDATA[功能进阶1、Java网页爬虫，最基础的功能，是能爬取某个页面的html源码。2、图形化界面。3、爬取某个页面的html源码，以及页面需要的静态资源（图片、css和js）。4、爬取某个页面的html源码，以及页面中的链接指向的页面的html源码，并且不断地延伸爬取。
整个开发过程，需要用到网络编程、正则表达式、I/O流、图形界面编程、事件监听、多线程等。为了简化开发，还需要用到一些外部jar包，比如jsoup。


模块划分1、获取页面模块：获取页面文档，以及页面文档的字符串。2、获取页面链接模块：获取页面中存在的各种链接，包括a标签、img标签、css链接、js链接等。3、获取静态文件模块：静态文件分为两种，一种是字符串类型，一种是字节类型。4、保存文件模块：保存页面文档和静态文件。5、界面模块：包括界面设计，事件监听处理。
核心代码摘要获取页面模块public class Page &#123;    Document doc = null;    public Page(String url) &#123;        try &#123;            doc = Jsoup.connect(url).timeout(5000).userAgent("Mozilla").get();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;        public String getHtml()&#123;        return doc.html();    &#125;        public Document getDoc()&#123;        return doc;    &#125;&#125;

获取页面链接模块public class UrlList &#123;    public Document doc = null;    public UrlList(String url) &#123;        try &#123;            doc = Jsoup.connect(url).timeout(5000).userAgent("Mozilla").get();        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;        public ArrayList&lt;Element&gt; getLinkList()&#123;        Elements links = doc.select("link[href]");        ArrayList&lt;Element&gt; resultList = new ArrayList&lt;Element&gt;();        for(Element link : links)&#123;            resultList.add(link);        &#125;        return resultList;    &#125;        public ArrayList&lt;Element&gt; getCssList()&#123;        Elements links = doc.select("link[href]");        ArrayList&lt;Element&gt; resultList = new ArrayList&lt;Element&gt;();        for(Element link : links)&#123;            if("stylesheet".equals(link.attr("rel")))&#123;                resultList.add(link);                           &#125;        &#125;        return resultList;    &#125;        public ArrayList&lt;Element&gt; getAList()&#123;        Elements links = doc.select("a[href]");        ArrayList&lt;Element&gt; resultList = new ArrayList&lt;Element&gt;();        for(Element link : links)&#123;            resultList.add(link);        &#125;        return resultList;    &#125;        public ArrayList&lt;Element&gt; getImgList()&#123;        Elements links = doc.select("img[src]");        ArrayList&lt;Element&gt; resultList = new ArrayList&lt;Element&gt;();        for(Element link : links)&#123;            resultList.add(link);        &#125;        return resultList;    &#125;        public ArrayList&lt;Element&gt; getJsList()&#123;        Elements links = doc.select("script[src]");        ArrayList&lt;Element&gt; resultList = new ArrayList&lt;Element&gt;();        for(Element link : links)&#123;            resultList.add(link);        &#125;        return resultList;    &#125;&#125;

获取静态文件public class Source &#123;    public String getString(String url) &#123; // 定义一个字符串用来存储网页内容        String result = "";        // 定义一个缓冲字符输入流        BufferedReader in = null;        try &#123;            // 将string转成url对象            URL realUrl = new URL(url);            // 初始化一个链接到那个url的连接            URLConnection connection = realUrl.openConnection();            // 开始实际的连接            connection.connect();            // 初始化 BufferedReader输入流来读取URL的响应            in = new BufferedReader(new InputStreamReader(connection.getInputStream()));            // 用来临时存储抓取到的每一行的数据            String line;            while ((line = in.readLine()) != null) &#123;                // 遍历抓取到的每一行并将其存储到result里面                result += line;            &#125;        &#125; catch (Exception e) &#123;            System.out.println("发送GET请求出现异常！" + e);            e.printStackTrace();        &#125; finally &#123;            try &#123;                if (in != null) &#123;                    in.close();                &#125;            &#125; catch (Exception e2) &#123;                e2.printStackTrace();            &#125;        &#125;        return result;    &#125;&#125;

保存文件模块public class SaveFile &#123;    public void saveFile(String path, String htmlStr) &#123;        File file = new File(path + "\\爬取的文件\\index.html");        if (!file.getParentFile().exists()) &#123;            file.getParentFile().mkdirs();        &#125;        // 字节输出流        FileOutputStream fos = null;        try &#123;            fos = new FileOutputStream(file);            OutputStreamWriter writer = new OutputStreamWriter(fos, "UTF-8");            writer.write(htmlStr);            writer.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            try &#123;                fos.close();            &#125; catch (IOException e) &#123;                // TODO Auto-generated catch block                e.printStackTrace();            &#125;        &#125;    &#125;    public void saveCss(String path, ArrayList&lt;Element&gt; cssList) &#123;        for (int i = 0; i &lt; cssList.size(); i++) &#123;            if (!cssList.get(i).attr("abs:href").equals(cssList.get(i).attr("href"))) &#123;                Source source = new Source();                String css = source.getString(cssList.get(i).attr("abs:href"));                String paths[] = cssList.get(i).attr("href").split("\\?");                File file = new File(path + "\\爬取的文件\\" + paths[0]);                if (!file.getParentFile().exists()) &#123;                    file.getParentFile().mkdirs();                &#125;                // 字节输出流                FileOutputStream fos = null;                try &#123;                    fos = new FileOutputStream(file);                    OutputStreamWriter writer = new OutputStreamWriter(fos, "UTF-8");                    writer.write(css);                    writer.close();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125; finally &#123;                    try &#123;                        fos.close();                    &#125; catch (IOException e) &#123;                        // TODO Auto-generated catch block                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;    &#125;    public void saveImg(String path, ArrayList&lt;Element&gt; imgList) &#123;        for (int i = 0; i &lt; imgList.size(); i++) &#123;            if (!imgList.get(i).attr("abs:src").equals(imgList.get(i).attr("src"))) &#123;                String paths[] = imgList.get(i).attr("src").split("\\?");                File file = new File(path + "\\爬取的文件\\" + paths[0]);                if (!file.getParentFile().exists()) &#123;                    file.getParentFile().mkdirs();                &#125;                try &#123;                    URL uri = new URL(imgList.get(i).attr("abs:src"));                      InputStream in = uri.openStream();                      FileOutputStream fo = new FileOutputStream(file);                      byte[] buf = new byte[1024];                      int length = 0;                      while ((length = in.read(buf, 0, buf.length)) != -1) &#123;                          fo.write(buf, 0, length);                      &#125;                      in.close();                      fo.close();                  &#125; catch (Exception e) &#123;                      e.printStackTrace();                  &#125;                              &#125;        &#125;    &#125;        public void saveJs(String path, ArrayList&lt;Element&gt; jsList)&#123;        for (int i = 0; i &lt; jsList.size(); i++) &#123;            if (!jsList.get(i).attr("abs:src").equals(jsList.get(i).attr("src"))) &#123;                Source source = new Source();                String css = source.getString(jsList.get(i).attr("abs:src"));                String paths[] = jsList.get(i).attr("src").split("\\?");                File file = new File(path + "\\爬取的文件\\" + paths[0]);                if (!file.getParentFile().exists()) &#123;                    file.getParentFile().mkdirs();                &#125;                // 字节输出流                FileOutputStream fos = null;                try &#123;                    fos = new FileOutputStream(file);                    OutputStreamWriter writer = new OutputStreamWriter(fos, "UTF-8");                    writer.write(css);                    writer.close();                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125; finally &#123;                    try &#123;                        fos.close();                    &#125; catch (IOException e) &#123;                        // TODO Auto-generated catch block                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;    &#125;&#125;

界面模块代码略，来个图说明设计。
后记未填的坑：1、最终设计做到了功能3，功能4未做。2、爬取文件的相对位置需要另做处理。
源码分享https://github.com/voidking/java-crawler
书签如何用Java写一个爬虫？https://www.zhihu.com/question/30626103
零基础写Java知乎爬虫之先拿百度首页练练手http://www.jb51.net/article/57193.htm
网页爬虫的设计与实现（Java版）http://www.aiuxian.com/article/p-2279197.html
网页爬虫系统的设计http://www.tuicool.com/articles/7JVzIza
专栏：使用JSOUP实现网络爬虫http://blog.csdn.net/column/details/jsoup.html
jsoup Cookbook(中文版)http://www.open-open.com/jsoup/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript学习笔记——基础篇</title>
    <url>/dev-javascript-base/</url>
    <content><![CDATA[什么是JavascriptJavascript是一种基于对象的脚本语言。
基于对象（Object-Based）不提供抽象、继承、重载等有关面向对象语言的功能。而是把其他语言创建的对象统一起来，形成一个对象系统，以供使用。
脚本语言最大的特点就是不需要编译和链接。传统编程语言有四个步骤“编写-&gt;编译-&gt;链接-&gt;运行”，而脚本语言只有两个步骤“编写 -&gt; 运行”。
脚本语言是解释执行而非编译执行。windows下，命令提示符界面，就是输入脚本语言的shell；经常见到的“*.bat”批处理文件，就是脚本文件。而在linux系统里面，脚本、脚本编程的概念更是常见。
shell，提供用户使用界面的软件。在windows中，win+R，输入cmd，出现的那个黑黝黝的窗口就是一个shell；打开任务管理器，看到的那个explorer.exe程序，也是一个shell，它叫做GUI shell。在linux中，如果不使用图形用户界面，那么，你所看到的，就是一个shell，一般的linux系统都会提供几种shell供你选择；而如果使用图形用户界面，你看到的界面，就是一个GUI shell。

什么是对象一切都是对象。比如“你”就是一个对象，你拥有姓名、性别、身高、体重等等属性信息，也有跳跃、奔跑、吃饭、睡觉等等方法。
Javascript中使用的对象，分为内置对象和自定义对象。
常见的内置对象有Array、String、Math、Date、Document、Form、Anchor、Link、Image、Windows、Screen、Navigator、Location、History、Frame、DOM、RegExp、StyleSheet、Event、FileSystemObject、Drive、Folder、File、XMLHttpRequest、Error……
Javascript出现的原因1、表单验证。早期的验证全部在服务端，比如注册时需要输入邮箱，而邮箱有固定格式，中间有一个“@”。为了验证一个邮箱格式，就需要发送请求给服务端，服务端的压力很大，多么令人蛋疼。为了减轻服务器的压力，需要一种可以运行在客户端的精小高效的语言。
2、网页交互性。随着互联网的发展，单纯的网页浏览已经无法满足用户的需求，越来越多的用户渴望与网页进行交互。为了改善用户的交互体验，需要开发一种语言，而这种语言运行在服务端是不合适的。
火药的发明，最初并没有想到可以用来打仗。Javascript的作者也没想到，Javascript能够发展到现在这么强大：（1）在浏览器的状态栏或者警告框里，向访问者显示信息。（2）验证表单内容。（3）当访问者将鼠标指针移动到图像上面时，自动替换图像。（4）创建与访问者交互的广告栏，而不仅仅是显示一幅图像。（5）检测可用浏览器或其属性，并且只在支持它们的浏览器上运行高级功能。（6）检测已安装的插件，并在需要某一插件时通知访问者。（7）在不需要访问者重新加载网页的情况下，修改整个或部分网页。（8）显示从远程服务器检索到的数据，或者与远程服务器交互数据。……总结一下，大致分为表单验证、网页特效、浏览器检测。
语法汉语有语法，英语有语法，编程语言也有语法，Javascript也不例外。
语法，简而言之，就是语言表达的规则。你说“我真帅！”，大家理解你的意思，但是你说“帅真我！”，就没有人明白了！同样的，只有遵循一定的规则，浏览器才能明白你写的某句代码的意思。
数据类型数值型、字符串、布尔型、null、undefined、对象、数组
变量和常量和C、Java基本相同，不多解释，如果你没有学过编程，就按照数学中的理解就好了。
运算符和表达式和C、Java基本相同，不懂的同学请自行百度、读书，此处不展开了。
流程和C、Java基本相同，学过C、Java的同学请自行跳过本节。
其实所有的编程语言的执行流程都可以分为四种：（1）顺序。排队买饭，就是一个顺序流程。
（2）条件。假设有两个窗口，窗口一卖饭，窗口二卖汤。如果你想打饭，就去窗口一；如果你想打汤，就去窗口二。这里的“想打饭”和“想打汤”就是条件。
（3）循环。排队买饭，终于排到我了，这时我发现钱不够，于是我回宿舍拿钱；之后回来排队，终于又排到我了，钱还是不够，于是我又回宿舍拿钱……这个过程，就是循环。终于有一次，我的钱拿够了，买到了饭，这个循环就结束了。
（4）其他。比如continue、break、异常处理等。continue，排队买饭，还没有排到我，我发现钱没带，于是提前结束本次排队，回宿舍拿钱，回来后重新排队。break，排队买饭，还没有排到我，突然不想买了，于是结束排队。异常处理，排队买饭，突然收到一个紧急电话，必须去跑1000米。这个紧急电话，就是一个异常，跑1000米，就是处理。
函数和程序函数是用来实现一个功能的程序块。
举个例子，打电话告诉老爸缺钱了。这个过程，有两个动作，“打电话”和“告诉”。这里的“打电话”和“告诉”就是两个函数，也就是两个程序块。
程序块是什么？那些用大括号括起来的代码就是程序块。
程序呢？程序就是命令序列的集合。通俗一点说，程序就是做一件事情的步骤的集合。
“打电话”是一个程序，可以分为这样几个步骤：掏出手机，找到号码，拨号，等待接通。
当然你可以分的更细，比如“掏出手机”也可以看成一个程序，分为这样几个步骤：伸手拿到手机，提高一厘米，提高一厘米，提高一厘米……
闭包闭包是啥玩意？各种专业文档中给出了void根本看不懂的定义。这里借用阮一峰的理解：闭包就是能够读取和保持其他函数内部变量的函数。
1、作用域要理解闭包，首先必须理解Javascript的变量作用域。变量作用域无非两种：全局变量和局部变量。
Javascript特有“链式作用域”结构。js寻找变量的定义会从最近的区域开始，本地找不到就往上一层区域，直到找到命名空间的顶端，在浏览器的世界里顶端就是window对象了。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。
2、一个例子
&lt;html&gt;	&lt;head&gt;		&lt;/head&gt;	&lt;body&gt;		&lt;script &gt;		function f1()&#123;				var n = "hello voidking";				function f2()&#123;					alert(n);				&#125;				return f2;				&#125;				var result = f1();				result();		&lt;/script&gt;	&lt;/body&gt;&lt;/html&gt;
运行这段代码，浏览器弹出了“hello voidking”对话框。
这段代码中的f2，就是一个闭包。
虽然外部函数已经返回，但是内部函数仍然记得外部函数定义的变量。
由于在Javascript中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。
在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。功能类似于Java对象中的set和get函数。
3、传引用闭包可以更新外部变量的值。
Javascript中函数的传参是传值，而不是传引用。而在闭包中，其存储的是一个对外部变量的引用。
正则表达式说到正则表达式，很多人会想到通配符。正则表达式和通配符的不同在哪里呢？
1、通配符是系统级的，在bash shell界面下可以直接使用；正则表达式是需要工具支持的，比如grep、sed、awk等工具。2、通配符一般用来查找文件、文件夹；正则表达式的匹配更加精确，主要用来文本过滤和字符串的操作。
Javascript对于正则表达式有很好的支持，也就是说，我们可以很方便的进行文本过滤和字符串操作。比如开篇提到的邮箱格式验证，我们就可以用正则表达式来实现。
DOMDOM，文档对象模型（Document Object Model）。
DOM独立于语言和平台，是一套标准接口，用来对XML和HTML文档进行增删查改。
DOM规范的核心就是树模型，对于要解析的HTML文档，解析器会把HTML文档加载到内存中，在内存中为HTML文件建立逻辑形式的节点树。而每一个节点，代表一个可以进行交互的对象。
XMLXML，可扩展标记语言（eXtensible Markup Language）。
它的格式很HTML很像，但是，HTML的标记是固定的，不区分大小写；而XML的标记是自定义的，区分大小写的。
XML文档结构分为3个部分：序言、主体和尾声。其中尾声可有可无。如果把一个HTML文档看做是一个主体（一棵树），那么，XML和HTML文档结构的不同，就在于XML多了一个序言，而且，主体可能不止一棵树。
事件编程语言中的事件，我们可以简单理解为事情。
当一件事情发生，我们可能会产生反应，也许不会。
比如，你们的老师让你们写一篇实验报告，这就是一个事件。这个事件发生后，你就会去写实验报告，这就是反应。也许你会吐槽，告诉远方的某位姑娘，老师多么无聊，让你们写实验报告。这时，虽然姑娘也知道了这件事，但是微微一笑（没有去写报告吧），或者连反应都没有。而更多的不知道这个事件的人，当然就当做没发生。
Javascript中的事件，提供了与窗口以及当前加载文档交互的基础。而Javascript对事件的处理，也就是通常所说的反应。
CookieCookie（小甜饼）是由浏览器存储在客户端系统的文本，而且与浏览器的每次请求一同发送到服务器。使用Cookie可以方便地帮助Web服务器保存有关访客的信息。
Cookie常用于以下场合：（1）保存用户登录状态（2）跟踪用户行为（3）定制界面（4）创建购物车
AjaxAjax，异步Javascript和XML（Asynchronous Javascript and XML），被称为远程脚本技术。
Javascript在早期，和服务器通信的方法只有一个——提交表单，远程脚本技术使两者之间的通信变得更加丰富。它可以使Javascript超越客户端的界限，使其能够处理Web服务器上的文件。
特点：局部更新，节省带宽，提高加载速度。
结束语看完上面的概念，是不是在想：什么玩意儿？看不懂没关系，知道有那么一回事就行，下一篇实践篇将会告诉你Javascript到底怎么玩。以上内容也许理解失误的地方，感谢大家留言指正。
参考文档李炎恢的Javascript视频教程《Javascript完全学习手册（作者张银鹤等）》《Javascript基础教程（第七版，作者Tom Negrino、Dori Smith）》《Javascript开发技术详解（作者李峰、晁阳）》一些技术大牛的博客……
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript正则表达式</title>
    <url>/dev-javascript-regex/</url>
    <content><![CDATA[前言正则表达式（Regular Expression）主要是用来描述一个句法规则的模式。其实说的通俗一点，就是利用字符和元字符的组合，对一些符合既定句法的模式进行模糊匹配。它的主要功能是文本查询和字符串操作。本文讨论一下JavaScript中的正则表达式用法。


定义正则表达式1、定义正则表达式有两种形式，一种是普通方式，一种是构造函数方式。2、普通方式：var reg=/表达式/附加参数表达式：一个字符串，代表了某种规则，其中可以使用某些特殊字符，来代表特殊的规则，后面会详细说明。附加参数：用来扩展表达式的含义，目前主要有三个参数：g：代表可以进行全局匹配。i：代表不区分大小写匹配。m：代表可以进行多行匹配。上面三个参数，可以任意组合，代表复合含义，当然也可以不加参数。例子：
var reg=/a*b/;var reg=/abc+f/g;
3、构造函数方式：var reg=new RegExp(“表达式”,”附加参数”);其中“表达式”与“附加参数”的含义与上面那种定义方式中的含义相同。例子：
var reg=new RegExp("a*b");var reg=new RegExp("abc+f","g");
4、普通方式与构造函数方式的区别普通方式中的表达式必须是一个常量字符串，而构造函数中的表达式可以是常量字符串，也可以是一个js变量，例如根据用户的输入来作为表达式参数等等：
var reg=new RegExp(document.forms[0].exprfiled.value,"g");

表达式模式1、表达式模式，是指表达式的表达方式与样式， 即 var reg=/表达式/附加参数 中的“表达式”怎样去描述？2、从规范上讲，表达式模式分为简单模式和复合模式。3、简单模式：是指通过普通字符的组合来表达的模式，例如
var reg=/abc0d/;
可见简单模式只能表示具体的匹配。4、复合模式：是指含有通配符来表达的模式，例如：
var reg=/a+b?\w/;
其中的+、?和\w都属于通配符，代表着特殊的含义。因此复合模式可以表达更为抽象化的逻辑。复合模式中各个通配符的含义及其使用请阅读下文给出的参考文档。
表达式操作1、表达式操作，在这里是指和表达式相关的方法，我们将介绍六个方法。2、表达式对象（RegExp）方法：
（1）exec(str)，返回str中与表达式相匹配的第一个字符串，而且以数组的形式表现，当然如果表达式中含有捕捉用的小括号，则返回的数组中也可能含有()中的匹配字符串，例如：
var regx=/\d+/;var rs=regx.exec("3432ddf53");
返回的rs值为：{3432}
var regx2=new RegExp("ab(\d+)c");var rs2=regx2.exec("ab234c44");
返回的rs2值为：{ab234c,234}另外，如果有多个合适的匹配，则第一次执行exec返回一个第一个匹配，此时继续执行exec，则依次返回第二个第三个匹配。例如：
var regx=/user\d/g;var rs=regx.exec("ddduser1dsfuser2dd");var rs1=regx.exec("ddduser1dsfuser2dd");
则rs的值为{user1}，rs1的值为{user2}，当然注意regx中的g参数是必须的，否则无论exec执行多少次，都返回第一个匹配。后面还有相关内容涉及到对此想象的解释。
（2）test(str)，判断字符串str是否匹配表达式，返回一个布尔值。例如：
var regx=/user\d+/g;var flag=regx.test("user12dd");
flag的值为true。
3、String对象方法
（1）match(expr)，返回与expr相匹配的一个字符串数组，如果没有加参数g，则返回第一个匹配，加入参数g则返回所有的匹配例子：
var regx=/user\d/g;var str="user13userddduser345";var rs=str.match(regx);
rs的值为：{user1,user3}
（2）search(expr)，返回字符串中与expr相匹配的第一个匹配的index值。例子：
var regx=/user\d/g;var str="user13userddduser345";var rs=str.search(regx);
rs的值为：0
（3）replace(expr,str)，将字符串中匹配expr的部分替换为str。另外在replace方法中，str中可以含有一种变量符号$，格式为$n，代表匹配中被记住的第n的匹配字符串（注意小括号可以记忆匹配）。例子：
var regx=/user\d/g;var str="user13userddduser345";var rs=str.replace(regx,"00");
rs的值为：003userddd0045例子2：
var regx=/u(se)r\d/g;var str="user13userddduser345";var rs=str.replace(regx,"$1");
rs的值为：se3userdddse45对于replace(expr,str)方法还要特别注意一点，如果expr是一个表达式对象则会进行全局替换（此时表达式必须附加参数g，否则也只是替换第一个匹配），如果expr是一个字符串对象，则只会替换第一个匹配的部分，例如：
var regx="user"var str="user13userddduser345";var rs=str.replace(regx,"00");
rs的值为： 0013userddduser345
（4）split(expr)，将字符串以匹配expr的部分做分割，返回一个数组，而且表达式是否附加参数g都没有关系，结果是一样的。例子：
var regx=/user\d/g;var str="user13userddduser345";var rs=str.split(regx);
rs的值为：{3userddd,45}
表达式相关属性1、表达式相关属性，是指和表达式相关的属性，如下面的形式：
var regx=/myexpr/;var rs=regx.exec(str);
其中，和表达式自身regx相关的属性有两个，和表达式匹配结果rs相关的属性有三个，下面将逐一介绍。2、和表达式自身相关的两个属性：
（1）lastIndex，返回开始下一个匹配的位置，注意必须是全局匹配（表达式中带有g参数）时，lastIndex才会有不断返回下一个匹配值，否则该值为总是返回第一个下一个匹配位置，例如：
var regx=/user\d/;var rs=regx.exec("sdsfuser1dfsfuser2");var lastIndex1=regx.lastIndex;rs=regx.exec("sdsfuser1dfsfuser2");var lastIndex2=regx.lastIndex;rs=regx.exec("sdsfuser1dfsfuser2");var lastIndex3=regx.lastIndex;
上面lastIndex1为9，第二个lastIndex2也为9，第三个也是9；如果regx=/user/d/g，则第一个为9，第二个为18，第三个为0。
（2）source，返回表达式字符串自身。例如：
var regx=/user\d/;var rs=regx.exec("sdsfuser1dfsfuser2");var source=regx.source;
source的值为user\d3、和匹配结果相关的三个属性：
（1）index，返回当前匹配的位置。例如：
var regx=/user\d/;var rs=regx.exec("sdsfuser1dfsfuser2");var index1=rs.index;rs=regx.exec("sdsfuser1dfsfuser2");var index2=rs.index; rs=regx.exec("sdsfuser1dfsfuser2");var index3=rs.index;
index1为4，index2为4，index3为4，如果表达式加入参数g，则index1为4，index2为13，index3会报错（index为空或不是对象）。
（2）input，用于匹配的字符串。例如：
var regx=/user\d/;var rs=regx.exec("sdsfuser1dfsfuser2");var input=rs.input;
input的值为sdsfuser1dfsfuser2。
（3）[0]，返回匹配结果中的第一个匹配值，对于match而言可能返回一个多值的数字，则除了[0]外，还可以取[1]、[2]等等。例如：
var regx=/user\d/;var rs=regx.exec("sdsfuser1dfsfuser2");var value1=rs[0];rs=regx.exec("sdsfuser1dfsfuser2");var value2=rs[0];
value1的值为user1,value2的值为user2
实际应用1、实际应用一描述：有一表单，其中有一个“用户名”input域要求：汉字，而且不能少于2个汉字，不能多于4个汉字。实现：
&lt;script&gt;function checkForm(obj)&#123;     var username=obj.username.value;     var regx=/^[\u4e00-\u9fa5]&#123;2,4&#125;$/g;     if(!regx.test(username))&#123;               alert("Invalid username!");               return false;      &#125;     return true;&#125;&lt;/script&gt;&lt;form name="myForm" onSubmit="return checkForm(this)"&gt;    &lt;input type="text" name="username"/&gt;    &lt;input type="submit" vlaue="submit"/&gt;&lt;/form&gt;
2、实际应用二描述：给定一个含有html标记的字符串，要求将其中的html标记去掉。实现：
&lt;script&gt;function toPlainText(htmlStr)&#123;   var regx=/&lt;[^&gt;]*&gt;|&lt;\/[^&gt;]*&gt;/gm;   var str=htmlStr.replace(regx,"");   return str;&#125;&lt;/script&gt;&lt;form name="myForm"&gt;    &lt;textarea id="htmlInput"&gt;&lt;/textarea&gt;    &lt;input type="button" value="submit" onclick="toPlainText(document.getElementById('htmlInput').value"/&gt;&lt;/form&gt;

参考文档js正则表达式语法http://blog.csdn.net/zaifendou/article/details/5746988
正则表达式30分钟入门教程http://demo.voidking.com/reprint/正则表达式/正则表达式30分钟入门教程.htm
常用的正则表达式http://demo.voidking.com/reprint/正则表达式/常用的正则表达式.htm
正则表达式速查表http://demo.voidking.com/reprint/正则表达式/正则表达式速查表.htm
正则表达式测试器http://demo.voidking.com/reprint/正则表达式/正则表达式测试器.htm
正则表达式在线测试器详情请见：http://demo.voidking.com/reprint/regexpal/
deerchao大侠正则表达式原文地址http://www.jb51.net/tools/zhengze.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC概述</title>
    <url>/dev-jdbc-start/</url>
    <content><![CDATA[名词解释JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。
下载jar包MySQL：MySQL Connectors
Oracle：JDBC、SQLJ、Oracle JPublisher 和通用连接池 (UCP)JDBC and Universal Connection Pool (UCP)
SQL Server：Microsoft JDBC Drivers 4.1 and 4.0 for SQL Server


MySQL用户管理创建新用户
mysql -u root -pcreate user 'scott'@'localhost' identified by 'tiger';//创建本地用户create user 'scott'@'%' identified by 'tiger';//创建远程用户，可选命令create database test;grant all prvivileges on test.* to scott;flush privileges;select host,user,password from mysql.user;//查看系统有哪些用户exit

新用户登录
mysql -u scott -pshow databases;use test;show tables;exit

删除新用户
mysql -u root -pdrop user 'scott'@'localhost';drop user 'scott';//相当于drop user 'scott'@'%';

测试连通性以测试eclipse和MySQL连接为例。
设置驱动打开eclipse，Window，Open Perspective，Other…，Database Development，OK。在左侧Data Source Explorer中，右击Database Connections文件夹，New…，选中MySQL，Name随意，Description随意，Next，New Driver Definition，Name/Type中选中一个System Version，然后在JAR List中选中mysql-connector-java-*-bin.jar，Edit JAR/Zip…，然后选中刚才下载解压的jar包，OK。
设置连接在Properties的General选项卡中，输入Database、URL、User name、Password，Save password前打钩。
测试连接设置好连接后，点击Test Connection，即可测试连通性。会提示ping succeeded！或者ping failed！
MySQL demo设计使用scott登录MySQL
use test;create table userbase(id int,username varchar(16),passwd varchar(16));insert into userbase values(1,'voidking','voidking');insert into userbase values(2,'voidking2','voidking2');insert into userbase values(3,'voidking3','voidking3');

创建jdbc工程，创建包com.voidking.jdbc，新建JdbcMySQL类，内容如下。
package com.voidking.jdbc;import java.sql.*;public class JdbcMySQL &#123;	// JDBC driver name and database URL	static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";	static final String DB_URL = "jdbc:mysql://localhost/test";	// Database credentials	static final String USER = "scott";	static final String PASS = "tiger";	public static void main(String[] args) &#123;		Connection conn = null;		Statement stmt = null;		try &#123;			// STEP 2: Register JDBC driver			Class.forName(JDBC_DRIVER);			// STEP 3: Open a connection			System.out.println("Connecting to database...");			conn = DriverManager.getConnection(DB_URL, USER, PASS);			// STEP 4: Execute a query			System.out.println("Creating statement...");			stmt = conn.createStatement();			String sql;			sql = "select id,username,passwd from userbase";			ResultSet rs = stmt.executeQuery(sql);			// STEP 5: Extract data from result set			while (rs.next()) &#123;				// Retrieve by column name				int id = rs.getInt("id");				String username = rs.getString("username");				String passwd = rs.getString("passwd");				// Display values				System.out.print("ID: " + id);				System.out.print(", username: " + username);				System.out.println(", passwd: " + passwd);			&#125;			// STEP 6: Clean-up environment			rs.close();			stmt.close();			conn.close();		&#125; catch (SQLException se) &#123;			// Handle errors for JDBC			se.printStackTrace();		&#125; catch (Exception e) &#123;			// Handle errors for Class.forName			e.printStackTrace();		&#125; finally &#123;			// finally block used to close resources			try &#123;				if (stmt != null)					stmt.close();			&#125; catch (SQLException se2) &#123;			&#125;// nothing we can do			try &#123;				if (conn != null)					conn.close();			&#125; catch (SQLException se) &#123;				se.printStackTrace();			&#125;// end finally try		&#125;// end try		System.out.println("Goodbye!");	&#125;// end main&#125;// end JdbcMySQL

右击JRE System Library，Build Path，Configure Build Path…，Add External JARs…，选中下载解压好的mysql-connector-java-*-bin.jar。
运行项目，即可在控制台看到输出。
SQL Server demo设计使用sa登录SQL Server
create database test;//切换到test数据库create table userbase(id int,username varchar(16),passwd varchar(16));insert into userbase values(1,'voidking','voidking');insert into userbase values(2,'voidking2','voidking2');insert into userbase values(3,'voidking3','voidking3');

新建JdbcSQLServer类，内容如下：
package com.voidking.jdbc;import java.sql.*;public class JdbcSQLServer &#123;	// JDBC driver name and database URL	static final String JDBC_DRIVER = "com.microsoft.sqlserver.jdbc.SQLServerDriver";	static final String DB_URL = "jdbc:sqlserver://127.0.0.1:1433;databaseName=test";	// Database credentials	static final String USER = "sa";	static final String PASS = "123";	public static void main(String[] args) &#123;		Connection conn = null;		Statement stmt = null;		try &#123;			// STEP 2: Register JDBC driver			Class.forName(JDBC_DRIVER);			// STEP 3: Open a connection			System.out.println("Connecting to database...");			conn = DriverManager.getConnection(DB_URL, USER, PASS);			// STEP 4: Execute a query			System.out.println("Creating statement...");			stmt = conn.createStatement();			String sql;			sql = "select id,username,passwd from userbase";			ResultSet rs = stmt.executeQuery(sql);			// STEP 5: Extract data from result set			while (rs.next()) &#123;				// Retrieve by column name				int id = rs.getInt("id");				String username = rs.getString("username");				String passwd = rs.getString("passwd");				// Display values				System.out.print("ID: " + id);				System.out.print(", username: " + username);				System.out.println(", passwd: " + passwd);			&#125;			// STEP 6: Clean-up environment			rs.close();			stmt.close();			conn.close();		&#125; catch (SQLException se) &#123;			// Handle errors for JDBC			se.printStackTrace();		&#125; catch (Exception e) &#123;			// Handle errors for Class.forName			e.printStackTrace();		&#125; finally &#123;			// finally block used to close resources			try &#123;				if (stmt != null)					stmt.close();			&#125; catch (SQLException se2) &#123;			&#125;// nothing we can do			try &#123;				if (conn != null)					conn.close();			&#125; catch (SQLException se) &#123;				se.printStackTrace();			&#125;// end finally try		&#125;// end try		System.out.println("Goodbye!");	&#125;// end main&#125;

Oracle demo设计使用scott用户登录
create table userbase(id int,username varchar(16),passwd varchar(16));insert into userbase values(1,'voidking','voidking');insert into userbase values(2,'voidking2','voidking2');insert into userbase values(3,'voidking3','voidking3');

新建JdbcOracle类，内容如下：
package com.voidking.jdbc;import java.sql.*;public class JdbcOracle &#123;	// JDBC driver name and database URL	static final String JDBC_DRIVER = "oracle.jdbc.OracleDriver";	static final String DB_URL = "jdbc:oracle:thin:@localhost:1521:orcl";	// Database credentials	static final String USER = "scott";	static final String PASS = "tiger";	public static void main(String[] args) &#123;		Connection conn = null;		Statement stmt = null;		try &#123;			// STEP 2: Register JDBC driver			Class.forName(JDBC_DRIVER);			// STEP 3: Open a connection			System.out.println("Connecting to database...");			conn = DriverManager.getConnection(DB_URL, USER, PASS);			// STEP 4: Execute a query			System.out.println("Creating statement...");			stmt = conn.createStatement();			String sql;			sql = "select id,username,passwd from userbase";			ResultSet rs = stmt.executeQuery(sql);			// STEP 5: Extract data from result set			while (rs.next()) &#123;				// Retrieve by column name				int id = rs.getInt("id");				String username = rs.getString("username");				String passwd = rs.getString("passwd");				// Display values				System.out.print("ID: " + id);				System.out.print(", username: " + username);				System.out.println(", passwd: " + passwd);			&#125;			// STEP 6: Clean-up environment			rs.close();			stmt.close();			conn.close();		&#125; catch (SQLException se) &#123;			// Handle errors for JDBC			se.printStackTrace();		&#125; catch (Exception e) &#123;			// Handle errors for Class.forName			e.printStackTrace();		&#125; finally &#123;			// finally block used to close resources			try &#123;				if (stmt != null)					stmt.close();			&#125; catch (SQLException se2) &#123;			&#125;// nothing we can do			try &#123;				if (conn != null)					conn.close();			&#125; catch (SQLException se) &#123;				se.printStackTrace();			&#125;// end finally try		&#125;// end try		System.out.println("Goodbye!");	&#125;// end main&#125;// end JdbcOracle

源代码分享https://github.com/voidking/jdbc.git
小结通过上面三个连接不同数据库的例子，我们发现，代码的差别，仅仅在于驱动包名、数据库的地址、用户名、密码。那么，这四个信息在哪里获得呢？除了自己记忆之外，郝同学提供一个查询测试的方法。Database Development，右击连接，Properties，Driver Properties。这时，已经可以看到驱动、用户名、密码。至于驱动，请接着点开Edit Driver Definition，Properties，Driver Class后面的就是驱动包。至此，四项信息都有了。
参考文档JDBC快速入门教程：http://www.yiibai.com/jdbc/jdbc_quick_guide.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>JPA基础</title>
    <url>/dev-jpa-base/</url>
    <content><![CDATA[简介Java持久化规范，是从EJB2.x以前的实体Bean(Entity bean)分离出来的，EJB3以后不再有实体bean，而是将实体bean放到JPA中实现。JPA是sun提出的一个对象持久化规范，各JavaEE应用服务器自主选择具体实现，JPA的设计者是Hibernate框架的作者，因此Hibernate作为Jboss服务器中JPA的默认实现，Oracle的Weblogic使用EclipseLink(以前叫TopLink)作为默认的JPA实现，IBM的Websphere和Sun的Glassfish默认使用OpenJPA(Apache的一个开源项目)作为其默认的JPA实现。
JPA的底层实现是一些流行的开源ORM(对象关系映射)框架，因此JPA其实也就是java实体对象和关系型数据库建立起映射关系，通过面向对象编程的思想操作关系型数据库的规范。


JPA的持久化策略文件根据JPA规范要求，在实体bean应用中，需要在应用类路径(classpath)的META-INF目录下加入持久化配置文件——persistence.xml，该文件就是持久化策略文件。其内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;persistence version="1.0" xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"&gt;	&lt;persistence-unit name="持久化单元名" transaction-type="JTA"&gt;		&lt;jta-data-source&gt;使用JCA部署在javaEE服务器上的数据源JNDI&lt;/jta-data-source&gt;        &lt;!--指定JPA实现提供者，不指定就采用JavaEE服务器默认的JPA提供者，这里以OpenJPA为例--&gt;	&lt;provider&gt;org.apache.openjpa.persistence.PersistenceProviderImpl&lt;/provider&gt;		&lt;class&gt;实体bean全路径名&lt;/class&gt;		……		&lt;properties&gt;            &lt;!--配置JPA实现提供者的一些信息--&gt;		&lt;/properties&gt;	&lt;/persistence-unit&gt;&lt;/persistence&gt;
注意：可以在持久化策略文件中配置多个持久化单元persistence-unit，在使用分布式数据库时经常配置多个持久化单元。
实体Bean的开发：JPA规范中定义的实体bean开发的基本规范：(1)在实体bean上添加”@Entity”注解，标识该bean为实体bean。(2)实体bean必须序列化。(3)使用”@Table(name=数据库表名)”注解，标识该实体bean映射到关系型数据库中的表名，如果不指定则JPA实现会自动生成默认的表名称。(4)必须有一个使用”@Id”注解标识的主键，如指定自增主键的写法为：
@Id@Column(name=”列名”)@GeneratedValue(Strategy=GenerationType.Auto)private int id;
注意：@Id和@GeneratedValue两个注解必须同时使用，标识了注解之后，要主键的生成策略。(5)Bean的其他属性使用”@Column(name=列名)”注解，指定该属性映射到数据库表中的列名，如果不指定在JPA实现会自动生成默认的列名。(6)实体Bean必须严格遵循JavaBean的规范，提供无参的默认构造方法，属性提供set和get方法。(7)最好重写hashcode()和equals()方法，实体bean的唯一标识是主键，因此，使用实体bean的主键来比较。
实体bean的主键生成策略实体bean的注解生成策略使用”@GeneratedValue”注解来指定主键的生成策略，默认使用Auto自增的策略，JPA不支持Hibernate的UUID主键生成策略，若要使用Hibernate的UUID做主键方式，方法如下：(1)将Hibernate.annotation jar包加入到类路径下。(2)在使用”@Id”的字段上同时加入如下的注解：
@GeneratedValue(generator=”UUID主键生成策略”)@GenericGenerator(name=”UUID主键生成策略”, strategy=”uuid”)

JPA开发的注意事项JPA支持xml方式和注解方式，目前随着注解方式越来越成熟和流行，开发JPA时候，基本都只用注解方式，因此必须在JavaEE5以上版本才行，因为以前的版本没有对注解的支持。和xml文件相比，java注解的优缺点：优势：(1)描述符减少，大大提高开发效率。(2)编译期校验，错误的注解在编译期间就会报错。(3)注解在java代码中，从而避免了额外的文件维护工作。(4)注解被编译成java字节码，消耗的内存小，读取速度快，往往比xml配置文件解析快几个数量级，利用测试和维护。缺点：(1)配置信息分散，不利于集中维护管理。(2)改动时涉及到了程序源代码，需要找到类的源代码才可以，而且必须通过编译这一步。相比较之下xml文件可能不需要找到类源码，同时也不需要重新编译。
JPA注解的使用注意事项JPA的注解支持字段注解，也支持属性注解。字段注解：直接在变量上加注解。属性注解：在set/get方法上加注解。注意：不管使用哪种注解方式，在一个实体类中，不能混用两种注解方式。
JPA其他的常用注解除了@Entity、@Id、@Table、@Column、@GeneratedValue等注解以外，JPA还有以下常用的注解：(1)@Temporal：主要用于标注时间类型，在javax.persistence.TemporalType枚举中定义了3种时间类型：a.DATE：等同于java.sql.Date；b.TIME：等同于java.sql.Time；c.TIMESTAMP：等同于java.sql.Timestamp；(2)@Transient：实体bean中默认所有的字段都会被映射到数据库中，如果某个属性不想被映射到数据库中，则需要对其加该注解。(3)@Lob：将属性持久化为Blob或者Clob类型，为大数据类型。(4)@Basic：一般可以用来控制是否进行延迟加载，用法示例：延迟加载：@Basic(fetch=FetchType.Lazy)非延迟加载：@Basic(fetch=FetchType.EAGER)(5)@NamedQueryies和@NamedQuery：在实体Bean上定义命名查询。名称查询类似于jdbc中的PrepareStatement，是在数据库中预编译的查询，可以大大提高查询效率，用法如下：
@NamedQueries(&#123;       @NamedQuery(name=”命名查询名字”,query=JPQL查询语句),       ……&#125;)
(6)@OneToOne：一对一映射注解，双向的一对一关系需要在关系维护端(owner side)的@OneToOne注解中添加mappedBy属性，建表时在关系被维护端(inverse side)建立外键指向关系维护端的主键列。用法：@OneToOne(optional=true,casecade=CasecadeType.ALL,mappedBy=”被维护端外键”)(7)@OneToMany：一对多映射注解，双向一对多关系中，一端是关系维护端(owner side)，只能在一端添加mapped属性。多端是关系被维护端(inverse side)。建表时在关系被维护端(多端)建立外键指向关系维护端(一端)的主键列。用法：@OneToMany(mappedBy = “维护端(一端)主键”, cascade=CascadeType.ALL)注意：在Hibernate中有个术语叫做维护关系反转，即由对方维护关联关系，使用inverse=false来表示关系维护放，在JPA的注解中，mappedBy就相当于inverse=false，即由mappedBy来维护关系。(8)@ManyToOne：多对一映射注解，在双向的一对多关系中，一端一方使用@OneToMany注解，多端的一方使用@ManyToOne注解。多对一注解用法很简单，它不用维护关系。用法：@ManyToOne(optional = false, fetch = FetchType.EAGER)(9)@ManyToMany：多对多映射，采取中间表连接的映射策略，建立的中间关系表分别引入两边的主键作为外键，形成两个多对一关系。双向的多对多关系中，在关系维护端(owner side)的@ManyToMany注解中添加mappedBy属性，另一方是关系的被维护端(inverse side)，关系的被维护端不能加mappedBy属性，建表时，根据两个多端的主键生成一个中间表，中间表的外键是两个多端的主键。用法：关系维护端——&gt;@ManyToMany(mappedBy=”另一方的关系引用属性”)关系被维护端——&gt;@ManyToMany(cascade=CascadeType.ALL ,fetch = FetchType.Lazy)
JPA的一对一关联映射在JPA中两个实体之间是一一对应的关系称为一对一关联关系映射，如人和身份证号关系。(1)一对一单向关联映射：只能从映射端查找到随关联的一方，而不能反向查找。在关联映射方关联属性上添加@OneToOne注解。(2)一对一双向关联映射：可以双向查找关联关系的实体。关系维护端：在关联属性或字段上添加@OneToOne注解，同时制定@OneToOne注解的mappedBy属性。关系被维护端：在关联属性或字段上添加@OneToOne注解。
一对一关联映射两种策略(1)一对一主键关联：一对一关联映射中，主键关联策略不会在两个关联实体对应的数据库表中添加外键字段，两个实体的表公用同一个主键(主键相同)，其中一个实体的主键既是主键又是外键。主键关联映射：在实体关联属性或方法上添加@OneToOne注解的同时添加@PrimaryKeyJoinColumn注解(在一对一注解关联映射的任意一端实体添加即可)。(2)一对一唯一外键关联：一对一关联关系映射中，唯一外键关联策略会在其中一个实体对应数据库表中添加外键字段指向另一个实体表的主键，也是一对一映射关系中最常用的映射策略。唯一外键关联：在关联属性或字段上添加@OneToOne注解的同时添加@JoinColumn(name=”数据表列名”，unique=true)注解。
一对多关联映射在JPA中两个实体之间是一对多关系的称为一对多关联关系映射，如班级和学生关系。(1)一对多单向关联映射：在一对多单向关联映射中，JPA会在数据库中自动生成公有的中间表记录关联关系的情况。在一端关联集合属性或字段上添加@OneToMany注解即可。(2)一对多双向关联映射：在一对多双向关联映射中，JPA不会在数据库中生成公有中间表。在一端关联集合属性或字段上添加@OneToMany注解，同时指定其mappedBy属性。在多端关联属性或字段上添加@ManyToOne注解。注意：一对多关系映射中，mappedBy只能添加在OneToMany注解中，即在多端生成外键。
多对多关联映射在JPA中两个实体之间是多对多关系的称为多对多关联关系映射，如学生和教师关系。(1)多对多单向映射：在其中任意实体一方关联属性或字段上添加@ManyToMany注解。(2)多对多双向映射：关系维护端关联属性或字段上添加@ManyToMany注解，同时指定该注解的mappedBy属性。关系被维护端关联属性或字段上添加@ManyToMany注解。
JPA中实体继承映射策略在JPA中，实体继承关系的映射策略共有三种：单表继承策略、Joined策略和Table_PER_Class策略。(1)单表继承策略：单表继承策略，父类实体和子类实体共用一张数据库表，在表中通过一列辨别字段来区别不同类别的实体。具体做法如下：a.在父类实体的@Entity注解下添加如下的注解：
@Inheritance(Strategy=InheritanceType.SINGLE_TABLE)@DiscriminatorColumn(name=”辨别字段列名”)@DiscriminatorValue(父类实体辨别字段列值)
b.在子类实体的@Entity注解下添加如下的注解：
@DiscriminatorValue(子类实体辨别字段列值)
(2)Joined策略：Joined策略，父类实体和子类实体分别对应数据库中不同的表，子类实体的表中只存在其扩展的特殊属性，父类的公共属性保存在父类实体映射表中。具体做法：只需在父类实体的@Entity注解下添加如下注解：
@Inheritance(Strategy=InheritanceType.JOINED)
子类实体不需要特殊说明。(3)Table_PER_Class策略：Table_PER_Class策略，父类实体和子类实体每个类分别对应一张数据库中的表，子类表中保存所有属性，包括从父类实体中继承的属性。具体做法：只需在父类实体的@Entity注解下添加如下注解：
@Inheritance(Strategy=InheritanceType.TABLE_PER_CLASS)
子类实体不需要特殊说明。
参考文档JPA学习笔记1——JPA基础http://blog.csdn.net/chjttony/article/details/6086298
JPA学习笔记2——JPA高级http://blog.csdn.net/chjttony/article/details/6086305
JPA学习笔记http://www.blogjava.net/luyongfa/archive/390572.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>jq命令的安装使用</title>
    <url>/dev-jq-command/</url>
    <content><![CDATA[jq命令简介jq 是一款命令行下处理 JSON 数据的工具。其可以接受标准输入，命令管道或者文件中的 JSON 数据，经过一系列的过滤器(filters)和表达式的转后形成我们需要的数据结构并将结果输出到标准输出中。jq 的这种特性使我们可以很容易地在 Shell 脚本中调用它。
更多内容，参考 命令行 JSON 处理工具 jq 的使用介绍。


安装jq1、macos
brew install jq

2、linux
wget https://github.com/stedolan/jq/releases/download/jq-1.6/jq-linux64chmod a+x jq-linux64 &amp;&amp; mv jq-linux64 /usr/bin/jq

3、centos
yum install epel-releaseyum install jq

4、ubuntu
apt updateapt install -y jq

jq表达式举个栗子echo '&#123;"name":"voidking"&#125;' | jq .echo '&#123;"name":"voidking"&#125;' | jq .nameecho '&#123;"name":"voidking"&#125;' | jq -r .name

用户在使用jq时，需要使用jq支持的语法来构建表达式(filters)并将其传给jq。jq根据语法规则解析表达式，并应用在输入的JSON数据上从而得到需要的结果。
上面例子中的 . 和 .name 就是表达式。. 符号表示对表达式输入的整个JSON对象的引用，.name和.name?表示获取JSON对象的属性。当输入不是JSON对象或数组时，带着问号的方式不会抛出异常。
选项的含义查看jq帮助即可，比如-r表示输出raw格式内容。
串行操作echo '&#123;"name":&#123;"firstname":"Void","lastname":"King"&#125;&#125;' | jq .name.firstnameecho '&#123;"name":&#123;"firstname":"Void","lastname":"King"&#125;&#125;' | jq '.name | .firstname'echo '&#123;"name":&#123;"firstname":"Void","lastname":"King"&#125;&#125;' | jq '.name | .firstname,.lastname'echo '[&#123;"firstname":"Void","lastname":"King"&#125;,&#123;"firstname":"Hao","lastname":"Jin"&#125;]' | jq '.[] | .firstname,.lastname' | sed -n "N;s/\n/ /p"

jq表达式支持串行化操作。一个复杂的表达式可以由多个简单的表达式组成，以管道符号 | 分割，串行化执行。管道前面表达式的输出，是管道后面表达式的输入。
逗号 , 表示对同一个输入应用多个表达式。
数组操作echo '[&#123;"name":"voidking"&#125;,&#123;"name":"haojin"&#125;]' | jq .echo '[&#123;"name":"voidking"&#125;,&#123;"name":"haojin"&#125;]' | jq '.[]'echo '[&#123;"name":"voidking"&#125;,&#123;"name":"haojin"&#125;]' | jq '.[0:2]'echo '[&#123;"name":"voidking"&#125;,&#123;"name":"haojin"&#125;]' | jq '.[0,1]'echo '[&#123;"name":"voidking"&#125;,&#123;"name":"haojin"&#125;]' | jq '.[].name'echo '[&#123;"name":"voidking"&#125;,&#123;"name":"haojin"&#125;]' | jq '.[] | .name'echo '[&#123;"name":"voidking"&#125;,&#123;"name":"haojin"&#125;]' | jq '.[] | .["name"]'

jq 提供三种基础表达式来操作数组：迭代器操作.[]，该表达式的输入可以是数组或者JSON对象，输出的是基于数组元素或者JSON对象属性值的迭代器（iterator）。访问特定元素的操作.[index]或.[&quot;attributename&quot;]。用来访问数组元素或者JSON对象的属性值，输出是单个值。数组切片操作.[startindex:endindex]&#39;，其行为类似于 python 语言中数组切片操作。
一个表达式产生的结果是迭代器时，迭代器的每一个值会分别作为的输入，传给后面的表达式。
jq运算echo '&#123;"num":3,"str":"343"&#125;' | jq '.num*3'echo '&#123;"num":3,"str":"343"&#125;' | jq '.num/3'echo '&#123;"num":3,"str":"343"&#125;' | jq '.str+"3"'echo '&#123;"num":3,"str":"343"&#125;' | jq '.str*3'echo '&#123;"num":3,"str":"343"&#125;' | jq '.str/"4"'echo '[&#123;"name":"voidking"&#125;,&#123;"name":"haojin"&#125;]' | jq '.+[&#123;"name":"voidking"&#125;]'echo '[&#123;"name":"voidking"&#125;,&#123;"name":"haojin"&#125;]' | jq '.-[&#123;"name":"voidking"&#125;]'echo '&#123;"name":&#123;"firstname":"Void","lastname":"King"&#125;&#125;' | jq '.+&#123;"name":&#123;"nickname":"Hankin"&#125;&#125;'echo '&#123;"name":&#123;"firstname":"Void","lastname":"King"&#125;&#125;' | jq '.*&#123;"name":&#123;"nickname":"Hankin"&#125;&#125;'echo '&#123;"name":&#123;"firstname":"Void","lastname":"King"&#125;&#125;' | jq '.name.nickname//"Hankin"'jq -n '([1,2]|.[])+([4,6]|.[])'

jq 内部支持的数据类型有：数字，字符串，数组和对象(object)。
数字运算：jq支持加减乘除(/)和求余(%)运算。字符串运算：jq 提供字符串的连接、复制、分割运算。数组运算：并集、差集运算。对象运算：合并。比较运算：jq 内部支持的比较运算，规则与js基本相同。逻辑运算: and/or/not。在 jq 逻辑运算中，除了 false 和 null 外，其余的任何值都等同于 true。默认值运算符：双斜杠。迭代器运算：每一个元素拿出来分别运算。
jq函数jq 支持函数。在使用 jq 函数时，我们应该注意区分两个概念：输入和参数。输入可能是整个表达式的输入数据也可能是表达式别的部分的输出。而参数和函数一起构成新的filter来处理输入。和其他编程语言不同的是，在调用函数时，多个参数之间以分号分隔。jq通过内置函数提供了数据处理时常用的操作，例如：删除、映射，过滤、路径操作等。
删除echo '&#123;"name":&#123;"firstname":"Void","lastname":"King"&#125;&#125;' | jq 'del(.name.firstname)'
删除不需要的元素。
映射echo '[1,2,3,4]'| jq -r 'map(.+1)'

在数据处理过程中，我们经常需要将数据从一种形式转换成另外一种形式，或者改变数据的值。jq提供了两个内置映射函数来实现这种转换：map 和 map_values。其中，map处理的对象是数组，而map_values则处理对象属性的值。map 函数的参数为 filter 表达式。
过滤echo '[1,2,3,4]'| jq -r 'map(select(.&gt;2))'echo '[1,2,3,4]'| jq -r '.[]|select(.&gt;2)'echo '[&#123;"name":"voidking","age": 18&#125;,&#123;"name":"haojin","age": 28&#125;]' | jq '.[]|select(.name=="haojin")'

jq中有两种类型的选择过滤操作。第一种是基于数据类型的过滤，如表达式.[]|arrays的结果只包含数组。可以用来过滤的类型过滤器有：arrays, objects, iterables, booleans, numbers, normals, finites, strings, nulls, values, scalars。第二种是select函数。select接受一个条件表达式作为参数。其输入可以是迭代器，或者和map函数配合使用来处理数组。当输入中的某个元素使select参数中的条件表达式结果为真时，则在结果中保留该元素，否则不保留该元素。
路径jq中的path是指从根到某个叶子属性的访问路径。在jq中有两种表示路径的方式：数组表示法和属性表示法。属性表示法类似于我们在filter中访问某个属性值的方式，如.a.b。数组表示法是将路径中的每一部分表示为数组的一个元素。jq提供了一个内置函数path用来实现路径从属性表示法到数组表示法的转换。
jq还提供了函数用来读取路径的值（getpath）, 设置路径的值（setpath）和删除路径（del）。不过这三个函数对路径的处理并不一致。其中getpath和setpath只接受数组表示法的路径，而del函数只能正确处理属性表示法的路径。
jq还提供了一个函数paths用来枚举可能存在的路径。在没有参数的情况下，paths函数将输出JSON数据中所有可能的路径。paths函数可以接受一个过滤器，来只输出满足条件的路径。
jq中提供了一系列的函数用来判断某个元素或者属性是否存在于输入数据中。其中函数has和in用来判断JSON对象或数组是否包含特定的属性或索引。函数contains和inside用来判断参数是否完全包含在输入数据中。对于不同的数据类型，判断是否完全包含的规则不同。对于字符串，如果A是B的子字符串，则认为A完全包含于B。对于对象类型，如果对象A的所有属性在对象B中都能找到且值相同，则认为A完全包含于B。
数组函数jq -nr '[1,[2,3],4]|flatten'jq -nr '[1,2,3]|reverse'jq -nr '[3,1,2]|sort'jq -nr '[&#123;"a":1&#125;,&#123;"a":2&#125;]|sort_by(.a)'jq -nr '"abcb"|indices("b")'jq -nr '[1,3,2,3]|indices(3)'
jq 提供内置函数用于完成数组的扁平化（flatten），反序（reverse），排序（sort、sort_by），比较（min、min_by、max、max_by）和查找（indices、index、rindex）。其中indices函数的输入数据可以是数组，也可以是字符串。和 index函数不同的是，其结果是一个包含所有参数在输入数据中位置的数组。
jq高级特性变量、Reduce、自定义函数和模块等。未完待续。。。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery学习笔记——Ajax篇</title>
    <url>/dev-jquery-ajax/</url>
    <content><![CDATA[显示欢迎信息Ajax的优点我们已经说过了，上个例子先！
&lt;!--显示欢迎信息.html--&gt;&lt;html&gt;	&lt;head&gt;	&lt;title&gt;显示欢迎信息&lt;/title&gt;	&lt;meta charset="UTF-8"&gt;	&lt;script type="text/javascript" src="jquery-1.11.1.js"&gt;&lt;/script&gt;	&lt;script type="text/javascript"&gt;		$(function()&#123;			$("#submit").click(function()&#123;				var name = $(".uname").val();				var data = "uname=" + name;				$.ajax(&#123;					type:"POST",					url:"http://demo.voidking.com/welcome.php",					data:data,					success: function(html)&#123;						$("#message").html(html);					&#125;				&#125;);				return false;			&#125;);		&#125;);	&lt;/script&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;form&gt;			&lt;label&gt;Enter your name&lt;/label&gt;			&lt;input type="text" name="uname" class="uname" /&gt;&lt;br/&gt;			&lt;input type="submit" id="submit"/&gt;		&lt;/form&gt;		&lt;div id="message"&gt;		&lt;/div&gt;	&lt;/body&gt;&lt;/html&gt;

&lt;!--welcome.php--&gt;&lt;?php	$name = $_POST['uname'];	echo "welcome ".$name;?&gt;
把ajax实例01.html、welcome.php、jquery-1.11.1.js上传到自己的服务器。打开浏览器访问“显示欢迎信息.html”，输入一个名字，就能看到效果了。
为什么要上传服务器，搞的这么麻烦？大哥，ajax主要就是用来和服务器交互的好不好？如果你觉得麻烦，可以直接访问我的服务器查看效果:VoidKing编程实例，接下来的例子也可以在这个网页找到。
当然，你也可以直接本地打开“显示欢迎信息.html”，但是提交数据没有反应，因为同源策略限制交互。怎么破？简单点，本地搭建一个php服务器！高大上点，自行百度，修改代码！


执行认证&lt;!DOCTYPE html&gt;&lt;html&gt;	&lt;head&gt;        &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;        &lt;title&gt;ajax实例02&lt;/title&gt;        &lt;script src="jquery-1.11.1.js" type="text/javascript"&gt;&lt;/script&gt;          &lt;script type="text/javascript"&gt;			$(function() &#123;   				$('#submit').click(function () &#123;           					var name = $('.uname').val();							var pwd = $('.passwd').val();						var data='uname='+name+'&amp;password='+pwd;					$.ajax(&#123;						type:"GET",						url:"logincheck.php", 						data:data,             						success:function(html) &#123;										$("#message").html(html);								&#125;					&#125;);							return false;					&#125;);			&#125;);		&lt;/script&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;p&gt;用户名输入guest，密码输入jquery，会出现欢迎信息，否则显示未注册&lt;/p&gt;&lt;br/&gt;		&lt;form&gt;  		&lt;label&gt;Enter your Name&lt;/label&gt;  		&lt;input type="text"  name="uname" class="uname"/&gt;  &lt;br/&gt;		&lt;label&gt;Enter your Password&lt;/label&gt;  		&lt;input type="password"  name="password" class="passwd"/&gt;  &lt;br/&gt;		&lt;input type="submit" id="submit"/&gt;  		&lt;/form&gt;  		&lt;div id="message"&gt;&lt;/div&gt;	&lt;/body&gt;&lt;/html&gt;
&lt;!--logincheck.php--&gt;&lt;?php   $name = trim($_GET['uname']); $pswd = trim($_GET['password']);    if(($name=="guest") &amp;&amp; ($pswd=="jquery"))  echo "Welcome ".  $name;else  echo "Sorry you are not authorized";?&gt;

验证用户名&lt;html&gt;	&lt;head&gt;		&lt;meta charset="UTF-8"&gt;		&lt;title&gt;验证用户名&lt;/title&gt;		&lt;script type="text/javascript" src="jquery-1.11.1.js"&gt;&lt;/script&gt;		&lt;script type="text/javascript"&gt;			$(function() &#123;   				$('.error').hide();				$('#submit').click(function () &#123;           					var name = $('.uname').val();							var data='uname='+name;					$.ajax(&#123;						type:"POST",						url:"validateuser.php", 						data:data,             						success:function(html) &#123;							$('.error').show();									$('.error').text(html);										&#125;					&#125;);							return false;					&#125;);			&#125;);		&lt;/script&gt;		&lt;/head&gt;	&lt;body&gt;		&lt;p&gt;验证用户名，只能是数字、字母和下划线&lt;/p&gt;&lt;br/&gt;		&lt;form&gt;  			&lt;span class="label"&gt;Enter your Name&lt;/span&gt;  			&lt;input type="text"  name="uname" class="uname"/&gt;  &lt;span class="error"&gt; &lt;/span&gt;&lt;br&gt;			&lt;input type="submit" id="submit"/&gt;  		&lt;/form&gt;  	&lt;/body&gt;&lt;/html&gt;
&lt;!--validateuser.php--&gt;&lt;?php   $name = $_POST['uname']; if (!eregi("^[a-zA-Z0-9_]+$", $name)) &#123;	echo "Invalid User name!";&#125;else&#123;	echo "Great user name!";&#125;?&gt;

使用自动完成&lt;html&gt;	&lt;head&gt;		&lt;meta charset="UTF-8"&gt;		&lt;title&gt;使用自动完成&lt;/title&gt;				&lt;style type="text/css"&gt;			.listbox &#123;				position: relative;				left: 10px;				margin: 10px;				width: 200px;				background-color: #000;				color: #fff;				border: 2px solid #000;			&#125;			.nameslist &#123;				margin: 0px;				padding: 0px;			list-style:none;			&#125;			.hover &#123;				background-color: cyan;				color: blue;			&#125;		&lt;/style&gt;				&lt;script type="text/javascript" src="jquery-1.11.1.js"&gt;&lt;/script&gt;		&lt;script type="text/javascript"&gt;			$(function() &#123;  				$('.listbox').hide(); 				$('.userid').keyup(function () &#123;       					var uid = $('.userid').val();						var data='userid='+uid;					$.ajax(&#123;						type:"POST",						url:"autocomplete.php", 						data:data,             						success:function(html) &#123;							$('.listbox').show();							$('.nameslist').html(html);							$('li').hover(function()&#123;								$(this).addClass('hover');							&#125;,							function()&#123;								$(this).removeClass('hover');							&#125;);							$('li').click(function()&#123;								$('.userid').val($(this).text());								$('.listbox').hide(); 							&#125;);						&#125;					&#125;);						return false;					&#125;);			&#125;);		&lt;/script&gt;		&lt;/head&gt;	&lt;body&gt;		&lt;p&gt;输入名字的第一个字符时，弹出建议框。&lt;/p&gt;&lt;br/&gt;		&lt;form&gt;  			&lt;span class="label"&gt;Enter user id&lt;/span&gt;  			&lt;input type="text"  name="userid" class="userid"/&gt; 			&lt;div class="listbox"&gt;				&lt;div class="nameslist"&gt;				&lt;/div&gt;			&lt;/div&gt;		&lt;/form&gt;   	&lt;/body&gt;&lt;/html&gt;

&lt;?php   	$name = $_POST['userid']; 	$connect = mysql_connect("localhost", "demo", "voidking") or die("Please, check your server connection.");	mysql_select_db("demo");	$query = "SELECT name from user where name like '$name%'";	$results = mysql_query($query) or die(mysql_error());	if($results)	&#123;		while ($row = mysql_fetch_array($results)) &#123;			extract($row);			echo '&lt;li&gt;' . $name. '&lt;/li&gt;';		&#125;	&#125;?&gt;

导入HTML&lt;!--导入HTML--&gt;&lt;html&gt;	&lt;head&gt;		&lt;meta charset="UTF-8"&gt;		&lt;title&gt;导入HTML&lt;/title&gt;		&lt;script type="text/javascript" src="jquery-1.11.1.js"&gt;&lt;/script&gt;		&lt;script type="text/javascript"&gt;			$(function() &#123;   				$('.list').click(function () &#123;           					$('#message').load('namesinfo.html');					return false;   				&#125;);			&#125;);		&lt;/script&gt;		&lt;/head&gt;	&lt;body&gt;		&lt;p&gt;单击超链接，从另一个文件中导入一些HTML内容到当前网页中。&lt;/p&gt;&lt;br/&gt;		&lt;p&gt;We are going to organize the Conference on IT on 2nd Feb 2010&lt;/p&gt;		&lt;a href="http://demo.voidking.com" class="list"&gt;Participants&lt;/a&gt;		&lt;div id="message"&gt;&lt;/div&gt;	&lt;/body&gt;&lt;/html&gt;

&lt;!--namesinfo.html--&gt;&lt;p&gt;The list of the persons taking part in conference &lt;/p&gt;&lt;ul&gt;&lt;li&gt;Jackub&lt;/li&gt;&lt;li&gt;Jenny&lt;/li&gt;&lt;li&gt;Jill&lt;/li&gt;&lt;li&gt;John&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;We wish them All the Best&lt;/p&gt;

取得JSON数据&lt;!--取得JSON数据--&gt;&lt;html&gt;	&lt;head&gt;		&lt;meta charset="UTF-8"&gt;		&lt;title&gt;取得JSON数据&lt;/title&gt;		&lt;script type="text/javascript" src="jquery-1.11.1.js"&gt;&lt;/script&gt;		&lt;script type="text/javascript"&gt;			$(function() &#123;   				$('#submit').click(function () &#123;      					$.ajax(&#123;						type:"GET",						url:"drinkinfo.json",    						dataType:"json",						success: function (data) &#123;   							var drinks="&lt;ul&gt;";							$.each(data, function(i,n)&#123;								drinks+="&lt;li&gt;"+n["optiontext"]+"&lt;/li&gt;";							&#125;);							drinks+="&lt;/ul&gt;";              							$('#message').append(drinks);							&#125;					&#125;);   					return false;					&#125;);					&#125;);		&lt;/script&gt;		&lt;/head&gt;	&lt;body&gt;		&lt;p&gt;从JSON文件中异步地导入信息到当前的网页中。&lt;/p&gt;&lt;br/&gt;		&lt;p&gt;For information from JSON file click the button given below :&lt;br&gt;		&lt;input type="submit" id="submit"/&gt;  		&lt;div id="message"&gt;&lt;/div&gt;  	&lt;/body&gt;&lt;/html&gt;
drinkinfo.json文件内容如下：
[	&#123;"optiontext" : "Tea", "optionvalue" : "Tea"&#125;,	&#123;"optiontext" : "Coffee", "optionvalue" : "Coffee"&#125;,	&#123;"optiontext" : "Juice", "optionvalue" : "Juice"&#125;]
矮油我靠，在服务器上打开浏览器，读取正常；在本地打开浏览器，居然无法读取，404错误！
经过测试，只要把文件名更改一下就好了。即把drinkinfo.json改成drinkinfo.txt。真是个奇葩问题，个人猜测是浏览器传输文件有格式限制。
取得XML数据&lt;html&gt;	&lt;head&gt;		&lt;meta charset="UTF-8"&gt;		&lt;title&gt;取得XML数据&lt;/title&gt;		&lt;script type="text/javascript" src="jquery-1.11.1.js"&gt;&lt;/script&gt;		&lt;script type="text/javascript"&gt;			$(document).ready(function() &#123;   				$('#submit').click(function () &#123;      					$.ajax(&#123;						type:"GET",						url:"student.xml",    						dataType:"xml",						success: function (sturec) &#123;    							var stud="&lt;ul&gt;";							$(sturec).find('student').each(function()&#123;								var name = $(this).find('first-name').text()								stud+="&lt;li&gt;"+name+"&lt;/li&gt;";							&#125;);							stud+="&lt;/ul&gt;"; 							$('#message').append(stud);						&#125;					&#125;);   					return false;					&#125;);					&#125;);		&lt;/script&gt;		&lt;/head&gt;	&lt;body&gt;		&lt;p&gt;从student.xml文件中异步导入信息到当前的网页中。&lt;/p&gt;&lt;br/&gt;		&lt;p&gt;To see the Names of the students extracted from XML file click the button given below :&lt;/p&gt;		&lt;input type="submit" id="submit"/&gt;  		&lt;div id="message"&gt;&lt;/div&gt;	&lt;/body&gt;&lt;/html&gt;
student.xml文件内容如下：
&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;school&gt;  &lt;student&gt;    &lt;roll&gt;101&lt;/roll&gt;    &lt;name&gt;      &lt;first-name&gt;Anil&lt;/first-name&gt;      &lt;last-name&gt;Sharma&lt;/last-name&gt;    &lt;/name&gt;    &lt;address&gt;      &lt;street&gt;        22/10 Sri Nagar Road      &lt;/street&gt;      &lt;city&gt;        Ajmer      &lt;/city&gt;      &lt;state&gt;        Rajasthan      &lt;/state&gt;    &lt;/address&gt;    &lt;marks&gt;      85    &lt;/marks&gt;   &lt;/student&gt;    &lt;student&gt;    &lt;roll&gt;102&lt;/roll&gt;    &lt;name&gt;      &lt;first-name&gt;Manoj&lt;/first-name&gt;      &lt;last-name&gt;Arora&lt;/last-name&gt;    &lt;/name&gt;    &lt;address&gt;      &lt;street&gt;        H.No 11-B Alwar Gate      &lt;/street&gt;      &lt;city&gt;        Ajmer      &lt;/city&gt;      &lt;state&gt;        Rajasthan      &lt;/state&gt;    &lt;/address&gt;    &lt;marks&gt;      92    &lt;/marks&gt;  &lt;/student&gt;&lt;/school&gt;

结束语以上例子，全部摘自《jQuery攻略》，不详解，看代码！
参考文档李炎恢的jQuery视频教程《jQuery攻略（作者B.M.Harwani）》《jQuery实战（作者Bear Bibeault、Yehuda Katz）》《jQuery高级编程（作者 Cesar Otero、Rob Larsen）》《jQuery Javascript 与CSS开发入门经典（作者Richard York）》
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>javascript</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery学习笔记——事件篇</title>
    <url>/dev-jquery-event/</url>
    <content><![CDATA[前言任何基于GUI的现代应用程序都是基于事件驱动的，Web应用程序也不例外。
所有事件驱动的应用程序都采用相同的工作模式：建立事件机制、等待相关事件发生（比如鼠标单击）、对该事件做出相应。
浏览器事件模型忆苦思甜，先了解一下传统的事件模型的缺点，我们才能明白改革开放是多么好的政策！
DOM第0级事件模型也许你听说过网景事件模型、基本事件模型、浏览器事件模型，但是大多数人称其为DOM第0级事件模型。
为什么称其为第0级事件模型呢？因为，虽然该模型并不是一个正式的标准，但是所有主流的浏览器都与之兼容。而且，所有的现代浏览器依然支持这种模型。


插播广告几乎所有的标准、协议、规范，都是在一门技术出现甚至成熟之后，才会形成。所以，我们也不能责怪W3C组织，没有及时给网景推出的事件模型一个名分，毕竟技术要领先于标准。
DOM第2级事件模型等一下？void，你是不是把DOM第1级事件模型漏掉了？没有漏掉，因为没有DOM第1级事件模型。DOM级别1于1998年10月成为W3C推荐标准，但是，该标准中并没有定义事件相关的内容。直到2000年11月，DOM级别2被引入时，W3C才真正为事件处理建立了标准模型。
这个模型得到了所有标准兼容的现代浏览器的支持，比如Firefox、Safari、Opera等。IE浏览器特立独行，它支持DOM第2级事件模型的一个功能子集。
IE事件模型刚才说到，IE不支持DOM第2级事件模型。IE为每个DOM元素定义了一个名为attachEvent()的方法，而不是addEventListener()。
小结以上你可以认为是废话……总而言之，想要使用事件模型，不得不考虑到兼容问题，非常麻烦！这时，我们的jQuery事件模型华丽登场！
jQuery事件模型，jQuery把不一致的代码从页面代码中提取出来，将其隐藏在API中，因此，我们终于不用再去考虑兼容性问题！
使用jQuery绑定事件处理器&lt;html&gt;	&lt;head&gt;			&lt;meta charset="UTF-8"&gt;		&lt;script type="text/javascript" src="jquery-1.10.2.js"&gt;&lt;/script&gt;		&lt;script type="text/javascript"&gt;			$(function()&#123;				$("img").bind("click",function()&#123;alert("hello voidking");&#125;);			&#125;);		&lt;/script&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;img src="./head.jpg" alt="头像"/&gt;			&lt;/body&gt;&lt;/html&gt;
&lt;html&gt;	&lt;head&gt;			&lt;meta charset="UTF-8"&gt;		&lt;script type="text/javascript" src="jquery-1.10.2.js"&gt;&lt;/script&gt;		&lt;script type="text/javascript"&gt;			$(function()&#123;				$("#voidking")				.bind("click",function()&#123;					alert("hello voidking once!");				&#125;)				.bind("click",function()&#123;					alert("hello voidking twice!");				&#125;)				.bind("click",function()&#123;					alert("hello voidking three times!");				&#125;);			&#125;);		&lt;/script&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;img id="voidking" src="./head.jpg" alt="头像"/&gt;			&lt;/body&gt;&lt;/html&gt;
由上面两段代码我们发现，绑定事件很简单，只需要一个bind()函数。而且，一个事件可以对应多个处理器。除了bind()函数，jQuery还为创建特定的事件处理器提供了一些便捷方法。比如one、focusin、focusout等。
删除事件处理器创建了一个事件处理器，那么它在页面剩余的生命周期里就是有效的。但是一些特殊的交互，要求根据一定标准删除处理器。这时我们就要用到unbind()函数，jQuery考虑的很周到啊！
&lt;html&gt;	&lt;head&gt;			&lt;meta charset="UTF-8"&gt;		&lt;script type="text/javascript" src="jquery-1.10.2.js"&gt;&lt;/script&gt;		&lt;script type="text/javascript"&gt;			$(function()&#123;				$("#voidking1").bind("click.voidking",function()&#123;					alert("hello voidking1");					$("*").unbind('click.voidking');				&#125;);								$("#voidking2").bind("click.voidking",function()&#123;					alert("hello voidking2");					$("*").unbind('click.voidking');				&#125;);							&#125;);		&lt;/script&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;img id="voidking1" src="./head.jpg" alt="头像"/&gt;		&lt;img id="voidking2" src="./head.jpg" alt="头像"/&gt;			&lt;/body&gt;&lt;/html&gt;
上面这个例子中，我们实现了一个效果：有任何一张图片被点击了一次，那么两张图都不可以再被点击。
Event实例使用bind()方法，无论是什么浏览器，Event实例都会作为第一个参数传入函数。
那么，怎么处理不同浏览器中Event实例中属性的差异呢？原来，jQuery定义了一个jQuery.Event对象，真正传入的函数的，是这个对象。这个对象复制了大部分原始Event的属性，忽略了Event实例的差异性。就像是一个接口，我们不需要管它怎么实现，只要调用就好了！
预先管理事件处理器当混合使用Ajax时，我们可能在页面的生命周期内频繁引入DOM元素或删除它们。在管理这些动态元素的事件处理器时，就绪处理器就起不到多大作用了，因为这些动态元素在就绪处理器执行时还不存在。
jQuery提供了live()方法，该方法允许预先为那些不存在的元素创建事件处理器。它的语法和bind()非常相似，看上去似乎比bind()更加强大，那么，用live()代替bind()不就好了吗？不是的，首先，“live”事件不是原生的“普通”事件。其次，live()方法只能应用于选择器，不能应用于衍生而来的包装集。
这里不再举例，下面的Ajax会详细探讨。
live()创建的选择器可以使用die()方法来解除绑定，语法和unbind()相似。
触发事件处理器触发事件，听起来就很难懂的样子，我们换个说法：模拟用户动作。比如点击，我们可以用代码去模拟用户点击，达到的效果与真实的鼠标点击是一样的。
&lt;html&gt;	&lt;head&gt;			&lt;meta charset="UTF-8"&gt;		&lt;script type="text/javascript" src="jquery-1.10.2.js"&gt;&lt;/script&gt;		&lt;script type="text/javascript"&gt;			$(function()&#123;				$("#voidking").bind("click",function()&#123;					alert("hello voidking");				&#125;);									$("#voidking").click();//模拟用户单击事件				$("#voidking").trigger("click");//模拟用户单击事件				$("p").bind("myEvent", function (event, message1, message2) &#123;					alert(message1 + ' ' + message2);				&#125;);				$("p").trigger("myEvent", ["hello","trigger"]);	//弹出两次						$('p').triggerHandler("myEvent",["hello","triggerHandler"]); //弹出一次，只触发第一个p元素								$("input").select(function()&#123;								&#125;);				$("#trigger").click(function()&#123;					$("input").trigger("select");//触发select事件，执行select默认操作和select处理器内操作				&#125;);				$("#triggerHandler").click(function()&#123;					$("input").triggerHandler("select");//触发select事件，但是不会执行select默认操作				&#125;);			&#125;);			&lt;/script&gt;	&lt;/head&gt;	&lt;body&gt;		&lt;img id="voidking" src="./head.jpg" alt="头像"/&gt;			&lt;p&gt;&lt;/p&gt;		&lt;p&gt;&lt;/p&gt;		&lt;input type="text"  value="hello voidking" /&gt;		&lt;br /&gt;		&lt;button id="trigger"&gt;激活select事件，同时选中文本&lt;/button&gt;&lt;/br&gt;		&lt;button id="triggerHandler"&gt;激活select事件，不选中文本&lt;/button&gt;	&lt;/body&gt;&lt;/html&gt;
上面这个例子，基本上涵盖了触发事件管理器的所有知识点。这里不详细解释了，自己看注释，不懂的请百度或留言。
更多toggle: 这个方法在jQuery 1.8中宣告过时，在jQuery 1.9中已经移除。为了写出一个图片大中小切换效果，各种百度谷歌，最终没搞出来。开始怀疑，toggle过时了，经过查看官方文档，果然！我靠，各位大神，你们13、14年写的教程，居然使用过时的代码……还有你，w3school，该更新了大哥！
结束语以上总结不可能面面俱到，差不多了，就写到这儿吧！
参考文档李炎恢的jQuery视频教程《jQuery攻略（作者B.M.Harwani）》《jQuery实战（作者Bear Bibeault、Yehuda Katz）》《jQuery高级编程（作者 Cesar Otero、Rob Larsen）》《jQuery Javascript 与CSS开发入门经典（作者Richard York）》
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>JSONPath</title>
    <url>/dev-jsonpath/</url>
    <content><![CDATA[JSONPath简介
JSON (JavaScript Object Notation) allows for easy interchange of data, often between a program and a database.JSONPath is a query language for JSON, similar to XPath for XML. 

如上，json是一种常用的数据格式，jsonpath是json的查询语言，类似于XPath和SQL。


JSONPath语法摘自 json-path/JsonPath
操作符


Operator
Description



$
The root element to query. This starts all path expressions.


@
The current node being processed by a filter predicate.


*
Wildcard. Available anywhere a name or numeric are required.


..
Deep scan. Available anywhere a name is required.


.&lt;name&gt;
Dot-notated child


[&#39;&lt;name&gt;&#39; (, &#39;&lt;name&gt;&#39;)]
Bracket-notated child or children


[&lt;number&gt; (, &lt;number&gt;)]
Array index or indexes


[start:end]
Array slice operator


[?(&lt;expression&gt;)]
Filter expression. Expression must evaluate to a boolean value.


函数Functions can be invoked at the tail end of a path - the input to a function is the output of the path expression.The function output is dictated by the function itself.



Function
Description
Output



min()
Provides the min value of an array of numbers
Double


max()
Provides the max value of an array of numbers
Double


avg()
Provides the average value of an array of numbers
Double


stddev()
Provides the standard deviation value of an array of numbers
Double


length()
Provides the length of an array
Integer


sum()
Provides the sum value of an array of numbers
Double


过滤器Filters are logical expressions used to filter arrays. A typical filter would be [?(@.age &gt; 18)] where @ represents the current item being processed. More complex filters can be created with logical operators &amp;&amp; and ||. String literals must be enclosed by single or double quotes ([?(@.color == &#39;blue&#39;)] or [?(@.color == &quot;blue&quot;)]).   



Operator
Description



==
left is equal to right (note that 1 is not equal to ‘1’)


!=
left is not equal to right


&lt;
left is less than right


&lt;=
left is less or equal to right


&gt;
left is greater than right


&gt;=
left is greater than or equal to right


=~
left matches regular expression  [?(@.name =~ /foo.*?/i)]


in
left exists in right [?(@.size in [‘S’, ‘M’])]


nin
left does not exists in right


subsetof
left is a subset of right [?(@.sizes subsetof [‘S’, ‘M’, ‘L’])]


anyof
left has an intersection with right [?(@.sizes anyof [‘M’, ‘L’])]


noneof
left has no intersection with right [?(@.sizes noneof [‘M’, ‘L’])]


size
size of left (array or string) should match right


empty
left (array or string) should be empty


demoGiven the json
&#123;    "store": &#123;        "book": [            &#123;                "category": "reference",                "author": "Nigel Rees",                "title": "Sayings of the Century",                "price": 8.95            &#125;,            &#123;                "category": "fiction",                "author": "Evelyn Waugh",                "title": "Sword of Honour",                "price": 12.99            &#125;,            &#123;                "category": "fiction",                "author": "Herman Melville",                "title": "Moby Dick",                "isbn": "0-553-21311-3",                "price": 8.99            &#125;,            &#123;                "category": "fiction",                "author": "J. R. R. Tolkien",                "title": "The Lord of the Rings",                "isbn": "0-395-19395-8",                "price": 22.99            &#125;        ],        "bicycle": &#123;            "color": "red",            "price": 19.95        &#125;    &#125;,    "expensive": 10&#125;




JsonPath (click link to try)
Result



$.store.book[*].author
The authors of all books


$..author
All authors


$.store.*
All things, both books and bicycles


$.store..price
The price of everything


$..book[2]
The third book


$..book[-2]
The second to last book


$..book[0,1]
The first two books


$..book[:2]
All books from index 0 (inclusive) until index 2 (exclusive)


$..book[1:2]
All books from index 1 (inclusive) until index 2 (exclusive)


$..book[-2:]
Last two books


$..book[2:]
Book number two from tail


$..book[?(@.isbn)]
All books with an ISBN number


$.store.book[?(@.price &lt; 10)]
All books in store cheaper than 10


$..book[?(@.price &lt;= $[‘expensive’])]
All books in store that are not “expensive”


$..book[?(@.author =~ /.*REES/i)]
All books matching regex (ignore case)


$..*
Give me every thing


$..book.length()
The number of books


在线测试JSONPath Online Evaluator
kubectl + JSONPathkubelet支持JSONPath，具体参考JSONPath 支持。除了标准jsonpath语法外,kubernetes jsonpath模板还额外支持以下语法:

用””双引号来引用JSONPath表达式中的文本
使用range和end来遍历集合
使用负数来从尾部索引集合

查看node的cpu信息：
kubectl get nodes -o=jsonpath='&#123;.items[*].metadata.name&#125;'kubectl get nodes -o=jsonpath='&#123;.items[*].status.capacity.cpu&#125;'kubectl get nodes -o=jsonpath='&#123;.items[*].metadata.name&#125;&#123;.items[*].status.capacity.cpu&#125;'kubectl get nodes -o=jsonpath='&#123;.items[*].metadata.name&#125;&#123;"\n"&#125;&#123;.items[*].status.capacity.cpu&#125;'kubectl get nodes -o=jsonpath='&#123;range .items[*]&#125;&#123;.metadata.name&#125;&#123;"\t"&#125;&#123;.status.capacity.cpu&#125;&#123;end&#125;'kubectl get nodes -o=custom-columns=NODE:.metadata.name,CPU:.status.capacity.cpukubectl get nodes --sort-by=.metadata.namekubectl get nodes --sort-by=.status.capacity.cpu

json2yamljson和yaml可以相互转化，这里推荐一个在线工具JSON to YAML。
如果有python3环境，还可以使用python-json2yaml工具。
pip install PyYAML==5.1pip install python-json2yamlcat a.json | json2yaml &gt; a.yamlcat a.yaml | yaml2json




]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
        <tag>json</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP和servlet概述</title>
    <url>/dev-jsp-servlet-start/</url>
    <content><![CDATA[JSP概述名词解释JSP全名为Java Server Pages，中文名叫java服务器页面，其根本是一个简化的Servlet设计。
JSP文件类似于HTML文件，但又不完全相同，其实JSP是由HTML、Java片段和JSP标记组成的。
ServletJava的运行方式是通过Java虚拟机把*.java的文件编译成*.class文件，但JSP文件却是后缀名为.jsp的文件，怎么执行呢？当*.jsp文件被送到服务器后，先由服务器翻译成Servlet文件，而Servlet文件就是*.java文件，然后*.java文件又被编译成*.class文件，再由Java虚拟机解释执行。

Servlet和Java Applet一样，它们都不是独立的应用程序，都没有main()方法，而是生存在容器中，由容器来管理。编写一个Servlet文件，需要实现javax.servlet.Servlet接口。
Servlet demo设计新建Dynamic Web Project，命名为servlet。新建包com.voidking.servlet，新建类HelloWorld，实现Servlet接口，内容如下：
package com.voidking.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.Servlet;import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class HelloWorld implements Servlet &#123;	@Override	public void destroy() &#123;		// TODO Auto-generated method stub	&#125;	@Override	public ServletConfig getServletConfig() &#123;		// TODO Auto-generated method stub		return null;	&#125;	@Override	public String getServletInfo() &#123;		// TODO Auto-generated method stub		return null;	&#125;	@Override	public void init(ServletConfig arg0) throws ServletException &#123;		// TODO Auto-generated method stub	&#125;	@Override	public void service(ServletRequest req, ServletResponse res)			throws ServletException, IOException &#123;		// TODO Auto-generated method stub		PrintWriter pw = res.getWriter();		pw.println("HelloWorld");	&#125;&#125;

在WebContent/WEB-INF下新建web.xml，内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" 	xmlns="http://java.sun.com/xml/ns/javaee" 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;  &lt;display-name&gt;&lt;/display-name&gt;	  &lt;servlet&gt;  	&lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;  	&lt;servlet-class&gt;com.voidking.servlet.HelloWorld&lt;/servlet-class&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;  	&lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;  	&lt;url-pattern&gt;/helloWorld&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;

发布工程，访问http://localhost:8080/servlet/helloWorld ，即可在界面上看到“HelloWorld”。
原理分析init()：在Servlet实例化之后，Servlet容器会调用init()方法，来初始化该对象。该方法主要是为了让Servlet对象在处理客户请求前可以完成一些初始化工作，例如，建立数据库的连接，获取配置信息等。对于每个Servlet实例，init()方法只能被调用一次。init()方法有一个类型为ServletConfig的参数，Servlet容器通过这个参数向Servlet传递配置信息。Servlet使用该对象从Web应用程序的配置信息中获取初始化参数。另外，在Servlet中，还可以通过ServletConfig对象获取描述Servlet运行环境的ServletContext对象，使用该对象，Servlet可以和它的Servlet容器进行通信。
service()：容器调用service()方法来处理客户端的请求。在init()方法正确完成后，service()方法被容器调用。在service()方法中有用于接受客户端请求信息的请求对象（类型为ServletRequest）和用于对客户端进行响应的响应对象（类型为ServletResponse）的参数。Servlet对象通过ServletRequest对象得到客户端的相关信息和请求信息，在对请求进行处理后，调用ServletResponse对象的方法设置响应信息。
destroy()：当容器检测到一个Servlet对象应该从服务中被移除时，容器会调用该对象的destroy()方法，来释放Servlet对象所使用的资源，保存数据到持久存储设备中。例如，将内存中的数据保存到数据库中，关闭数据库连接等。在Servlet容器调用destroy()方法前，如果还有其他线程正在service()方法中执行，容器会等待这些线程执行完毕或等待服务器设定的最大时间到达。一旦Servlet对象的destroy()方法被调用，容器不会再把其他的请求发送给该对象。如果需要该Servlet对象再次为客户端服务，容器将会重新生成一个Servlet对象来处理客户端的请求。在destroy()方法调用之后，容器会释放这个Servlet对象，在随后的时间内，该对象会被Java的垃圾收集器回收。
getServletConfig()：放回容器调用init()方法时传递给Servlet对象的ServletConfig对象，ServletConfig对象包含了Servlet的初始化参数。
getServletInfo()：放回一个String类型的字符串，其中包括关于Servlet的信息，例如，作者、版本和版权。
web.xml文件中包含配置信息。web.xml文件的第一行是对xml文件的生命，接着就是xml的根元素，其属性中声明了版本等信息。和之间配置的是和，其中的值“HelloWorld”是为Servlet起的一个名字，这个可以随便起名，只要符合Java的命名规则就行；而的值则是自己写的Servlet类的类名，这个必须配置正确，如果有包，还要在前面加上包名。这个类名不带.java，也不带.class。
与之间配置的是和，其中的值就是上面刚刚配置的的值；而的值也可以随便起名，但其前面必须加“/”，如上面例子中的“/helloWorld”。
访问地址：http://localhost:8080/servlet/helloWorld  ，其中，http://localhost:8080 是服务器URL，而后面的servlet是项目名，最后面的helloWorld是在web.xml中配置的的值。
优化GenericServlet类上面的例子中，采用实现Servlet接口的方法，需要实现5个方法。为了简化Servlet的编写，在javax.servlet包中提供了一个抽象的类GenericServlet。它给出了出service()外其他4个方法的简单实现。GenericServlet实现了Servlet接口和ServletConfig接口。HelloWorld.java可以改写为：
package com.voidking.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.GenericServlet;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;public class HelloWorld extends GenericServlet &#123;	@Override	public void service(ServletRequest arg0, ServletResponse arg1)			throws ServletException, IOException &#123;		// TODO Auto-generated method stub		PrintWriter pw = arg1.getWriter();		pw.println("HelloWorld");	&#125;&#125;

HttpServlet类在大部分网络中，都是客户端通过HTTP协议来访问服务端的资源。为了快速开发应用于HTTP协议的Servlet类，在javax.servlet.http包中提供了一个抽象HttpServlet。它继承了GenericServlet类。
当容器接到一个针对HttpServlet对象请求时，该对象就会调用public的service()方法，首先将参数类型转换为HttpServletRequest和HttpServletResponse，然后调用protected的service()方法将参数传进去。
接着调用HttpServletRequest对象的getMethod()方法获取请求方法名来调用相应的doXxx()方法。所以一个Servlet类在继承HttpServlet时，不用覆盖它的service()方法，只需要覆盖相应的doXxx()方法就行了。通常情况下，都是覆盖其doGet()和doPost()方法。然后在其中的一个方法中调用另一个方法，这样就可以做到合二为一。
HelloWorld.java可以改写为：
package com.voidking.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class HelloWorld extends HttpServlet &#123;	protected void doGet(HttpServletRequest req,HttpServletResponse res) throws ServletException,IOException	&#123;		PrintWriter pw = res.getWriter();		pw.println("HelloWorld");	&#125;		protected void doPost(HttpServletRequest req,HttpServletResponse res) throws ServletException,IOException	&#123;		doGet(req, res);	&#125;&#125;

Servlet进阶在一个HTML文件中建立一个表单，里面有一个输入框，当客户输入内容后，提交到一个Servlet类，这个Servlet类取出客户输入的信息，并在HTML页面上显示该内容。
右击servlet项目下的WebContent，New，HTML File，命名为index.html，内容如下：
&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Servlet进阶&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;form action="inputServlet" method="post"&gt;		请输入你想显示的内容：&lt;input type="text" name="input"/&gt;&lt;/br&gt;		&lt;input type="submit" value="提交" /&gt;		&lt;input type="reset" value="重置" /&gt;	&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;

在com.voidking.servlet包下新建InputServlet类，继承HttpServlet，内容如下：
package com.voidking.servlet;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class InputServlet extends HttpServlet &#123;	private static final long serialVersionUID = 1L;           public InputServlet() &#123;        super();    &#125;	protected void doGet(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123;		// TODO Auto-generated method stub		res.setCharacterEncoding("utf8");		req.setCharacterEncoding("utf8");				String input = req.getParameter("input");				PrintWriter pw = res.getWriter();		pw.println("&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;");		pw.println("显示输入内容");		pw.println("&lt;/title&gt;&lt;body&gt;");		pw.println(input);		pw.println("&lt;/body&gt;&lt;/html&gt;");	&#125;	protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123;		// TODO Auto-generated method stub		doGet(req, res);	&#125;&#125;

web.xml修改如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;	&lt;display-name&gt;&lt;/display-name&gt;	&lt;servlet&gt;		&lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;		&lt;servlet-class&gt;com.voidking.servlet.HelloWorld&lt;/servlet-class&gt;	&lt;/servlet&gt;	&lt;servlet-mapping&gt;		&lt;servlet-name&gt;HelloWorld&lt;/servlet-name&gt;		&lt;url-pattern&gt;/helloWorld&lt;/url-pattern&gt;	&lt;/servlet-mapping&gt;	&lt;servlet&gt;		&lt;servlet-name&gt;InputServlet&lt;/servlet-name&gt;		&lt;servlet-class&gt;com.voidking.servlet.InputServlet&lt;/servlet-class&gt;	&lt;/servlet&gt;	&lt;servlet-mapping&gt;		&lt;servlet-name&gt;InputServlet&lt;/servlet-name&gt;		&lt;url-pattern&gt;/inputServlet&lt;/url-pattern&gt;	&lt;/servlet-mapping&gt;&lt;/web-app&gt;

发布工程，访问：http://localhost:8080/servlet/
源码分享https://github.com/voidking/servlet.git
JSP语法数据定义&lt;%! 变量声明 %&gt;，相当于Servlet类里面的变量声明。
程序块&lt;% 程序块 %&gt;，相当于在Servlet类里面service()函数里。
表达式&lt;%=Java表达式 %&gt;，相当于Servlet类里面service()函数里，PrintWriter调用println()函数。
注释&lt;%-- 注释内容[&lt;%=表达式%&gt;]--&gt;，输出注释。&lt;%-- 注释内容--%&gt;，隐藏注释。
指令JSP指令用来提供整个JSP页面的相关信息和设定JSP页面的相关属性，如设定网页的编码方式、脚本语言及导入需要用到的包等。语法格式如下：&lt;%@ 指令名 属性名=&quot;属性值&quot;%&gt;
1、page指令2、include指令3、taglib指令
动作1、&lt;jsp:param&gt;2、&lt;jsp:include&gt;3、&lt;jsp:useBean&gt;4、&lt;jsp:setProperty&gt;5、&lt;jsp:getProperty&gt;6、&lt;jsp:forward&gt;7、&lt;jsp:plugin&gt;
内置对象1、page2、config3、out4、response5、request6、session7、application8、pageContext9、exception
参考文档《Java EE基础实用教程》，郑阿奇主编
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>jsp</tag>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title>使用client-go在K8S集群发布项目</title>
    <url>/dev-k8s-client-go-deploy/</url>
    <content><![CDATA[问题简述怎样在K8S集群中发布一个新的项目？怎样判断一个项目是发布成功了还是失败了？怎样访问一个项目？怎样实现灰度发布？怎样实现发布过程中的并发度控制、暂停、继续、取消？怎样实现回滚？
本文中，会努力寻求这些问题的答案。


准备镜像首先准备两个镜像，分别是nginx:v1.0和nginx:v2.0。
1、启动并进入容器
docker run --name nginx -d -p 80:80 voidking/nginx:latestdocker exec -it nginx /bin/bash

有些小伙伴会有疑问，为什么不使用下面的命令启动并进入容器？只需要一条命令。docker run -it voidking/nginx:latest /bin/bash如果使用这种方式进入容器，修改内容后commit镜像，那么镜像无法正常启动。docker ps -a --no-trunc使用该命令可以看到，voidking/nginx:latest的默认启动命令为：nginx -g &#39;daemon off;&#39;而commit后的镜像，默认启动命令被修改为：/bin/bash看到这里就知道，因为自定义的启动命令覆盖掉了原有的启动命令，所以镜像无法正常启动。为什么会覆盖呢？因为CMD指令允许用户指定容器的默认的执行命令，此命令会在容器启动且docker run没有指定其他命令时运行。当docker run指定其他命令时，则会覆盖默认的执行命令。更多内容参考Dockerfile RUN，CMD，ENTRYPOINT命令区别。
2、修改index.html
cd /usr/share/nginx/htmlsed 's/nginx!/nginx!v1.0/' index.htmlsed -i 's/nginx!/nginx!v1.0/' index.htmlcat index.html

3、commit/push镜像
docker ps -ldocker commit 6efcd878d0d1 voidking/nginx:v1.0docker logindocker push voidking/nginx:v1.0

kubectl在使用go-client之前，我们先来学习一下使用kubectl怎样发布项目、获取状态、访问项目、更新项目。
发布项目以发布一个nginx项目为例。
1、准备deployment yaml文件nginx.yaml
apiVersion: apps/v1kind: Deploymentmetadata:  name: nginxspec:  replicas: 1  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: voidking/nginx:v1.0        ports:        - containerPort: 80        imagePullPolicy: Always

2、发布项目kubectl apply -f nginx.yaml
获取状态kubectl get deployments nginxkubectl get deployments nginx -o jsonkubectl get pods -l app=nginxkubectl get pods -l app=nginx -o jsonkubectl describe deployments nginxkubectl describe pods -l app=nginx
根据获取到的信息，判断发布成功还是失败。
访问项目1、准备service yaml文件nginx-svc.yaml
apiVersion: v1kind: Servicemetadata:  name: nginxspec:  ports:  - port: 80    protocol: TCP    targetPort: 80  selector:    app: nginx  sessionAffinity: None  type: NodePort  #type: LoadBalancer

2、查看服务IP和端口kubectl get svc nginx
3、访问项目minikube service nginx，自动打开浏览器。或者curl http://192.168.99.100:32329/
4、从容器内部访问项目（三种方式）
kubectl get podskubectl exec -it hello-node-6747d458b6-d757m /bin/bash# wget -O- 10.97.151.28curl 10.97.151.28curl nginx.defaultenv | grep NGINXcurl $NGINX_SERVICE_HOST:$NGINX_SERVICE_PORT

如果env命令没有显示出nginx service信息，那么可以重建pod：
kubectl get pod hello-node-6747d458b6-d757m -n default -o yaml | kubectl replace --force -f -

PS：使用kubectl进入容器的方法
kubectl get podskubectl exec -it pod-name /bin/bashkubectl exec -it pod-name -c container-name /bin/bash

更新发布1、修改nginx.yaml中的配置，升级镜像为voidking/nginx:2.0
apiVersion: apps/v1kind: Deploymentmetadata:  name: nginxspec:  replicas: 1  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: voidking/nginx:v2.0        ports:        - containerPort: 80        imagePullPolicy: Always

2、更新发布kubectl apply -f nginx.yaml
3、访问项目curl http://192.168.99.100:32329/
client-go《使用client-go操作K8S》一文中，配置好了k8s-client-go项目，可以使用这个项目对k8s集群进行一些基本操作。在此基础上，本节会实现一些更高阶的操作。
判断发布状态根据deployment和pod的状态，怎样判断一次发布成功还是失败？首先，要知道deployment和pod都有哪些状态。
1、通过kubectl命令获取发布数据
kubectl get deployments hello-node -o jsonkubectl get deployments nginx -o jsonkubectl get pods -l app=hello-node -o jsonkubectl get pods -l app=nginx -o json

2、获取到的发布数据发布成功的json数据：hello-node.json发布失败的json数据：nginx.json
3、具体可用状态有哪些
# deployment部分deployment.generationdeployment.spec.replicasdeployment.status.observedGenerationdeployment.status.replicasdeployment.status.readyReplicas/unavailableReplicasdeployment.status.updatedReplicasdeployment.status.conditions[*].type&#123;Available,Progressing&#125; &amp;&amp; deployment.status.conditions[*].status&#123;True,False&#125;# pod部分pod.status.phase&#123;Pending,Running&#125;pod.status.conditions[*].type&#123;Initialized,Ready,ContainersReady,PodScheduled&#125; &amp;&amp; pod.status.conditions[*].status&#123;True,False&#125;pod.status.containerStatuses[*].state.&#123;waiting,running&#125;

4、判断条件组合参考k8s-client-go/common/deployment.go文件的GetDeploymentStatus函数。
灰度发布常见的发布方案包括蓝绿发布、滚动发布和灰度发布（金丝雀发布），更多内容参考微服务部署：蓝绿部署、滚动部署、灰度发布、金丝雀发布。参考Spinnaker第四节-对接k8s、基于 Spinnaker 的 K8S 灰度发布、灰度发布/蓝绿发布，使用Ingress，可以很好地实现灰度发布。但是，在没有Ingress的情况下，该怎样实现灰度发布？
最简单的方案是发布一个新的deployment，把service的流量分流到新的deployment，测试通过后删除老的deployment，流量就全部到了新的deployment。具体实现参考k8s-client-go/common/deploy.go文件的GrayDeploy和UpdateDeploy函数。
但是，如果只允许维护一个deployment，该怎么处理？创建灰度的deployment，测试通过后删除灰度的deployment，然后正常更新原有的deployment。具体实现参考k8s-client-go/common/deploy.go文件的GrayDeploy2和UpdateDeploy2函数。
后记并发度控制、暂停、继续、取消、回滚等等功能，未完待续。。。
书签Pod 的生命周期
管理资源
Service
10 Most Common Reasons Kubernetes Deployments Fail (Part 1)
10 Most Common Reasons Kubernetes Deployments Fail (Part 2)
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>golang</tag>
        <tag>docker</tag>
        <tag>client-go</tag>
        <tag>kubectl</tag>
      </tags>
  </entry>
  <entry>
    <title>《知识工程》教学大纲</title>
    <url>/dev-knowledge-engineering/</url>
    <content><![CDATA[课程目标人工智能为知识工程的发展提供了理论基础，知识工程的发展进一步将人工智能推向了更广泛的应用领域。具体目标包括：（1）丰富和完善对人工智能领域的理论、方法的学习和研究。（2）学习和研究计算智能的启发式算法。通过自主/合作学习与研究的方法，训练和提升学生分析问题、发现问题和解决实际问题的能力。（3）提高学生获取文献的能力。同时，通过书写文章来提高学生归纳、总结、抽象、提炼研究成果的学术研究素养，为开题报告和毕业论文的完成和将来从事科学研究工作奠定坚实的基础。


课程内容《知识工程》这门课是研究生第一学期《人工智能》专业基础课的后续课程。由于《人工智能》课中对基本的知识表示、知识推理、知识获取、专家系统等方面的基本理论和方法进行了详细的讲授和讨论，所以在《知识工程》这门课中将主要从计算智能的角度来开展教学和研究。本课程共包括4个模块，含7个专题。模块一为人工智能与知识工程概述（专题1）。模块二为传统人工智能基本理论和方法的梳理（专题2-3）。模块三为计算智能研究（专题4-6）。模块四为科技论文书写探讨（专题7）。其中的重难点部分是第三模块。
专题一：人工智能与知识工程概述（2学时 2017-3-1）
1、核心内容人工智能的研究途径；人工智能的应用领域；在大数据环境下人工智能的研究方法和发展趋势；知识工程与知识管理等。
2、思考与讨论问题大数据和人工智能的关系。从IBM的Watson机器人到谷歌DeepMind实验室研发的人工智能围棋程序AlphaGo，给你怎样的启示。什么是计算智能？计算智能和传统人工智能是什么关系？什么是启发式算法？比较著名的启发式算法有哪些？讨论本课程的教学目标、教学内容、教学方式、考核方式等的设置是否合理？
3、阅读文献参考文献1中的第1、7、8章参考文献2中的第1章参考文献3中的第1章参考文献5
专题二：知识表示、知识推理和知识获取的方法（2学时 2017-3-8）
1、核心内容知识表示方法及特点的分析和总结；基本推理方法和实用推理技术的梳理；知识获取的基本过程、手段和工具的分析和总结；各类机器学习方法的回顾与比较等。
2、思考与讨论问题如何理解和应用启发式搜索策略？知识获取的途径有哪些？机器学习、知识发现和数据挖掘是什么关系？
3、阅读文献参考文献1中的第5章参考文献2中的第2、3、4、8章参考文献5
专题三：专家系统（2学时 2017-3-15）
1、核心内容专家系统的结构、原理、建造及评价的分析和总结。探讨大数据环境下的专家系统的设计及实现的关键问题。
2、思考与讨论问题基于知识的系统（专家系统）的研究瓶颈问题有哪些？破解思路是什么？深层知识专家系统、模糊专家系统和神经网络专家系统的深入研究。大型协同分布式专家系统的设计与实现的关键问题分析。
3、阅读文献参考文献1中的第2章参考文献2中的第7章参考文献5
专题四：演化计算（6 学时 2017-3-22 ~2017-4-5）
1、核心内容演化计算概述；遗传算法（比如，模式、编码、适应度等方面的内容）及应用案例的学习与探讨；遗传规划及应用案例的学习与探讨；应用遗传算法来解决TSP问题的关键问题研究。
2、思考与讨论问题编码问题：在哪年由谁提出了怎样的编码方案？性能如何？主要特点是什么？主要用来解决哪些类问题等。对有记忆的遗传算法的深入研究。参数设置问题：各种操作的参数选择方法等。
3、作业 :作业1：利用遗传算法来实现求解TSP问题（或类似问题）的软件系统。具体要求见附录V.
4、阅读文献参考文献1中的第4章参考文献2中的第6章参考文献3中的第4章参考文献4、5
专题五：群智能计算（10学时 2017-4-12 ~2017-5-10）1、核心内容群智能计算概述；蚁群算法及应用实例的学习与探讨；粒子群算法及应用实例的学习与探讨；应用蚁群算法、粒子群算法来解决TSP问题的关键问题研究；遗传算法、蚁群算法、粒群算法在解决优化问题方面的比较研究。
2、思考与讨论问题蚁群算法的改进方法比较与发展趋势分析。蚁群算法、粒子群算法的实现技巧梳理遗传算法、蚁群算法和粒子群算法的综合应用
3、作业作业2：利用蚁群算法来实现求解TSP问题（或类似问题）的软件系统。具体要求见附录V.作业3：利用粒子群算法来实现求解TSP问题（或类似问题）的软件系统。具体要求见附录V.
4、阅读文献参考文献1中的第4章参考文献2中的第9章参考文献3中的第5、6章参考文献4、5
专题六：神经计算（ 10学时 2017-5-17 ~2017-6-14）1、核心内容人工神经网络概述；典型BP前向网络及应用实例的学习与探讨；典型Hopfield反馈网络及应用实例的学习与探讨；应用人工神经网络技术来解决TSP问题的关键问题研究；模糊神经网络的学习与探讨；在解决组合优化问题方面本课中涉及到的各类优化算法的比较研究。
2、思考与讨论问题人工神经网络中的学习方法的比较与选择。如何理解和应用模糊逻辑推理技术？各种优化算法的综合应用。什么是深度学习？它对我们的生活有什么影响？你是如何看待人工智能发展的未来的？
3、作业作业4：利用人工神经网络技术（比如，Hopfield）来实现求解TSP问题（或类似问题）的软件系统。具体要求见附录V.
4、阅读文献参考文献2中的第4、5章参考文献3中的第2、3章参考文献4、5
专题七：科技论文书写（ 4学时 2017-6-21 ~2017-6-28）
1、核心内容科技论文书写的一般格式；科技论文写作的方法；科技论文写作应注意的问题；论文实例的阅读、分析与探讨；自己动手书写论文，对论文质量进行评价，选择合适的期刊杂志和会议等出版单位进行投稿。
2、思考与讨论问题结合这门课的具体内容，来确定论文的选题、框架、突出的主题、针对主题的讨论、结论等。展示自己的成果，和老师、同学一起讨论修改方案，直至形成论文终稿。 
3、阅读文献参考文献5
教学方式本课程主要采用讲授法、研讨法、任务法、文献法等教学方式。基本理论、方法和算法以及具体任务的布置等内容采用讲授法。学生在自主学习/合作学习（组建小组、小组分工、协作讨论、确定方案、成果呈现）过程中经历了搜集资料、制定和实现方案、展示成果等活动，主要应用了文献法、任务法和研讨法等。
学习资源1、知识工程与知识管理，陈文伟，陈晟，清华大学出版社,2010。2、人工智能技术， 曹承志，清华大学出版社，2010。3、计算智能，张军，詹志辉，清华大学出版社，2009.4、自选Matlab 教材.5、高质量的学位论文及核心期刊的相关文章。文献检索例子见附录I。
学习建议1、为了深入地理解和应用各类启发式优化算法，需要学生具备一定的数学基础和会应用Matlab编程环境。2、本课程是实践性很强的课程，学生一定要动手开发具体的应用系统，这就要求同学们要具备相关的系统开发基础。3、要跟上老师的教学进度，及时阅读老师提供的参考资料，作业按时完成，否者会影响后续课程的学习。 
分组注: 每组第一人为组长。第一组3月22日讲授遗传算法及应用案例介绍；第二组3月29日开始讲授遗传规划及应用案例介绍；第三组4月19日开始讲授蚁群算法及应用实例介绍。
考核方式1、总分100分。2、每五个人一组，完成两个作业（具体见分组表），每个作业占总成绩的30分。本部分成绩由老师（80%）和学生（20%）的打分综合形成。要求和评价标准见附录III 和附录IV。 (小组成员成绩有区别)3、根据选择的作业内容，每人写一篇3000字左右的小论文，占总成绩的20分。要求至少15篇高质量的参考文献。4、课堂表现（出勤、演讲、参与度等）占总成绩的20分。本部分成绩由老师（80%）和学生（20%）的打分综合形成。要求和评价标准见附录III 和附录IV。5、作业必须按时完成，超期限者不能得分。
附录附录I：文献检索例子表一 相关文献的检索情况         
搜集到的论文篇数如表一所示。去除相关度太低和年限太久的文献，对剩余的文献进行分析。相关文献主要涵盖以下几方面：1、基本理论研究：涵盖概念、定义、特点、分类、理论方法、研究现状、研究趋势、应用价值等。2、相关技术研究：包括X技术，X X技术，… …3、技术应用研究：应用模式，应用领域，… …4、相关标准研究：A标准， B标准，… …5、… …本文对与本研究相关的XX方面的文献进行了详细阅读和分析整理。具体成果如下。读书报告… …
附录II：项目报告格式及要求一、题目二、报告人三、项目意义、要求及条件：为什么要做这个项目，有哪些具体要求，提供了哪些条件去完成这个项目。四、具体内容1、系统简介：包括采用了哪些理论方法与算法，实现了哪些功能，解决了哪些实际问题。2、系统设计：给出框图，并对模块及模块之间的关系给出解释。3、系统开发环境：硬环境及软环境。4、系统使用说明。五、系统性能分析对好的方面，从理论方法上进行归纳总结。对存在问题的方面，找出原因，并给出改进方法及建议。六、心得体会: 开发中所遇到的困难及解决方法, 从中得到的经验和教训，对以后学习、科研等方面所带来的启示。对这门课的意见及建议。
附录III：课堂讲解要求（以遗传算法为例）
1、来龙去脉：在什么情况下，存在什么问题，遗传算法是从什么样的视角来解决问题的？（整体介绍，通常10分钟左右）2、主要内容：基本概念（最好举例说明）、遗传算法描述、遗传算法实例、遗传算法特点等。（细节介绍，通常20分钟左右）3、主要研究问题：利用文献法来总结各种问题的研究现状，把你阅读的文献（至少3篇）提前3天发到云盘中。（重点内容介绍，通常讲解20分钟左右）a)编码问题：比如，在哪年由谁提出了怎样的编码方案？性能如何？主要特点是什么？主要用来解决哪些类问题等。b)参数设置问题：比如，各种操作的参数选择方法等。c)各种启发式实现方法：比如，有记忆的遗传算法等。d)… …4、应用领域：利用文献法来总结遗传算法各种领域的应用现状，把你阅读的文献（至少3篇）提前3天发到云盘中. （重点内容介绍，通常讲解20分钟左右），比如，a)在哪些领域的哪些方面应用了遗传算法？b)为什么选用这个算法？具体如何实现的？c)性能如何？存在怎样的问题？改进方向如何？
附录IV：课堂讲解评价1、内容方面 （60分）a)准确b)全面2、PPT制作（20分）a)必须自己制作PPT讲稿，可以应用已有模板；b)内容衔接得当，清晰、有逻辑性；c)图片/图表清楚，显示性强，引人入胜，当然也不要过于花哨，喧宾夺主；d)文字要突出重点，不要整页的文字。3、讲解水平（20分）a)声音洪亮、吐字清晰；b)选用合适的串接词，讲出逻辑性，不要照着文字念；c)注意时间分配，突出重点；d)给出一些启发式的话题，适当地互动，集中大家的注意力。
附录V：作业利用启发式算法（遗传算法、蚁群算法、粒群算法、人工神经网络等）来实现求解TSP问题（或类似问题）的软件系统。要求：1、实现一个应用系统，要求有GUI界面，可以对一些关键因子进行调整。同时，系统不仅显示最终结果，还要记录和显示中间结果，给出获得此结果的推理过程。2、在课堂上由一名小组成员演示并讲解所实现的系统。由全体成员来回答其他同学和老师的提问。然后由老师和同学为小组中的成员打分，讲解要求和评分标准见附录III和附录IV。3、提交项目报告（见附录II），源程序。
]]></content>
      <categories>
        <category>专业</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>知识工程</tag>
      </tags>
  </entry>
  <entry>
    <title>kubectl常用命令</title>
    <url>/dev-kubectl/</url>
    <content><![CDATA[kubectl简介
Kubectl is a command line interface for running commands against Kubernetes clusters. 

没错，kubectl是一个命令行工具，用来控制K8S集群。kubectl该怎么读？可以参考HowToPronounce-kubectl，郝同学喜欢读作kubecontrol。
kubectl命令格式为：
kubectl [command] [TYPE] [NAME] [flags]

更多内容，参考：

Overview of kubectl
kubectl Cheat Sheet
The Kubectl Book
Kubernetes kubectl 命令表

《K8S入门篇》一文中，已经学习了kubectl的安装方法，并且使用了一些简单命令。本文整理一下kubectl的常用命令，方便记忆和复习。



环境准备指定配置文件# 指定默认配置文件export KUBECONFIG=~/.kube/config# 查看kubectl配置kubectl config view# 指定配置文件和contextkubectl config --kubeconfig=/root/vk-kube-config use-context voidking@kubenertes# 指定单次运行配置文件kubectl get deployments --kubeconfig=/root/.kube/configkubectl get deployments --kubeconfig /root/.kube/config# 指定默认namespacekubectl config set-context --current --namespace=voidkingkubectl config set-context $(kubectl config current-context) --namespace=voidking# 多个配置整合成一个配置KUBECONFIG=~/.kube/config:~/Downloads/new-config kubectl config view --merge --flatten &gt; ~/.kube/newconfigexport KUBECONFIG=~/.kube/newconfig# 同时使用多个配置export KUBECONFIG=~/.kube/config:~/Download/new-config# 查看使用配置kubectl config get-contextskubectl config use-context voidking@kubenertes

命令自动补全1、linux下配置
yum install -y bash-completionsource &lt;(kubectl completion bash)echo "source &lt;(kubectl completion bash)" &gt;&gt; ~/.bash_profile

2、mac下配置
brew install bash-completionsource &lt;(kubectl completion zsh)echo "source &lt;(kubectl completion zsh)" &gt;&gt; ~/.bash_profile

使用别名缩写# kubectl缩写为k# alias k=kubectlalias k="/usr/local/bin/kubectl"complete -F __start_kubectl k# 可选aliasalias kg="kubectl get"alisa kd="kubectl describe"
建议把配置写入 .bash_profile ，登录后别名自动生效。
查看集群信息# 查看集群信息kubectl cluster-infokubectl cluster-info dump# 查看集群状态kubectl get cs# 查看node资源使用kubectl top node# 查看集群事件kubectl get ev

查看帮助查看资源缩写kubectl describekubectl api-resources
建议记住常用资源的SHORTNAMES，可以提升输入效率。此外，记住常用资源的APIGROUP，可以提高编写yaml文件时的效率。
查看可用api版本kubectl api-versions
yaml帮助yaml文件分成四部分，apiVersion、kind、metadata和spec。apiVersion和kind是关联的，参考kubectl api-resources。metadata必填name、namespace、labels。pod.spec主要填containers的name和image；deployment.spec主要填replicas、template和selector；service.spec主要填selector、ports和type。
编写yaml文件的过程中，如果忘记了某些结构和字段，可以使用kubectl explain命令来获取帮助。
1、查看资源包含哪些字段以查看deployment的yaml包含哪些字段为例：
kubectl explain deploymentkubectl explain deployment --api-version=apps/v1

2、查看子字段以查看节点亲和性字段为例：
kubectl explain deployment.spec.template.spec.affinitykubectl explain deployment.spec.template.spec.affinity.nodeAffinity...kubectl explain deployment.spec.template.spec.affinity.nodeAffinity.requiredDuringSchedulingIgnoredDuringExecution.nodeSelectorTerms.matchExpressions

资源相关查看资源1、查看集群的所有资源
kubectl get allkubectl get all -o wide# 根据label筛选所有资源kubectl get all -l 'env=dev'

2、查看deployment
# 查看deploymentkubectl get deploykubectl get deploy -n voidking -o widekubectl get deploy -l 'env=dev'kubectl get deploy --selector='env=dev'kubectl get deploy --all-namespaceskubectl get deploy --show-labels# 查看deployment实时变化kubectl get deploy --watch# 查看指定deploymentkubectl get deploy/deployment-namekubectl get deploy deployment-name# 指定namespacekubectl get deploy -n voidking# 根据label选择deploymentkubectl get deploy --selector="name=nginx,type=frontend"# 查看deployment详细信息kubectl describe deploy
pod、service、node的查看方法和deployment相同。
创建资源kubectl create -f deploy.yamlkubectl apply -f deploy.yaml

更新资源# 编辑集群中的资源kubectl edit deployment deployment-name# 比较manifest与集群中当前资源的不同kubectl diff -f deploy.yaml# 应用最新定义kubectl replace -f deploy.yamlkubectl apply -f deploy.yaml# 添加labelkubectl label deployment deployment-name new-label=awesome# 添加annotationkubectl annotate deployment deployment-name icon-url=http://goo.gl/XXBTWq # 部分修改deploymentkubectl patch deployment deployment-name --type json -p='[&#123;"op": "remove", "path": "/spec/template/spec/containers/0/livenessProbe"&#125;]'

删除资源kubectl delete deployment deployment-name

扩缩容方法一：通过扩缩容命令。
kubectl scale --replicas=2 deployment deployment-name

方法二：通过更新yaml文件。
暴露服务# 为deployment创建clusterip，暴露clusterip的80端口kubectl expose deployment deployment-name --port=80 --name svc-name# 为deployment创建clusterip，暴露clusterip的6789端口kubectl expose deployment deployment-name --target-port=80 --port=6789kubectl expose -f vk-deploy.yaml --target-port=80 --port=6789# 创建nodeport，暴露clusterip的80端口，暴露node的随机端口kubectl expose deployment deployment-name --port=80 --type=NodePort --name svc-name# 创建clusterip，暴露clusterip的80端口kubectl create service clusterip svc-name --tcp=80:80# 创建nodeport，暴露clusterip的80端口，暴露node的30080端口kubectl create service nodeport svc-name --tcp=80:80 --node-port=30080

版本回退# 查看发布历史kubectl rollout history deployment deployment-name# 查看发布状态kubectl rollout status deployment deployment-name# 回退到上一个版本kubectl rollout undo deployment deployment-name

cm和secret1、创建configmap
kubectl create configmap special-config --from-literal=special.how=very --from-literal=special.type=charmkubectl create configmap game-config-3 --from-file=&lt;my-key-name&gt;=&lt;path-to-file&gt;

2、创建secret
# 在命令中指定key和valuekubectl create secret generic db-user-pass --from-literal=username=voidking --from-literal=password='vkpassword'kubectl get secret db-user-pass -o yaml# 在文件中指定valueecho -n 'voidking' &gt; ./username.txtecho -n 'vkpassword' &gt; ./password.txtkubectl create secret generic db-user-pass --from-file=./username.txt --from-file=./password.txtkubectl create secret generic db-user-pass --from-file=username=./username.txt --from-file=password=./password.txtkubectl get secret db-user-pass -o yaml
在yaml文件中看到的username和password，都是经过base64加密的字符串。
# 加密echo -n 'voidking' | base64# 解密echo 'dm9pZGtpbmc=' | base64 --decode

创建多个资源如果要创建ns，然后在ns中创建configmap，最后创建deployment（依赖configmap），该怎么操作？方法一：挨个apply
kubectl apply -f ns.yamlkubectl apply -f cm.yamlkubectl apply -f deploy.yaml

方法二：按顺序合并，然后apply
cat ns.yaml &lt;(echo "---") cm.yaml &lt;(echo "---") deploy.yaml &gt; ns-cm-deploy.yamlkubecl apply -f ns-cm-deploy.yaml

方法三：多次apply
kubectl apply -f .kubectl apply -f .

方法四：添加编号
mv ns.yaml 00-ns.yamlmv cm.yaml 01-cm.yamlmv deploy.yaml 02-deploy.yamlkubectl apply -f .

资源拼接参考 Kustomize。
yaml相关导出yaml或json文件# 导出deployment的yaml文件kubectl get deploy -o yaml &gt; deploy.yaml# 导出deployment的json文件kubectl get deploy -o json &gt; deploy.json# 导出指定deployment的yaml文件kubectl get deploy/deployment-name -o yaml &gt; deploy-name.yaml# 导出指定deployment的json文件kubectl get deploy/deployment-name -o json &gt; deploy-name.json
pod、service、node的yaml/json文件的导出方法和deployment相同。
pod yaml生成pod的yaml文件模板：
kubectl run vkpod --image=nginx --restart=Never --dry-run=client -oyamlkubectl run vk-pod --image=nginx --generator=run-pod/v1 -l 'name=vk-pod,env=dev' --dry-run -o yamlkubectl run vk-pod --image=nginx --generator=run-pod/v1 --labels='name=vk-pod,env=dev' --dry-run -o yamlkubectl run vk-pod --image=busybox --generator=run-pod/v1 --dry-run -o yaml --command -- sleep 1000

更多内容，参考Kubernetes kubectl run 命令详解和kubectl 的用法约定。
deployment yaml1、生成deployment的yaml文件模板（历史方法）：
kubectl run vk-deploy --image=nginx --dry-run -o yaml
会出现提示：kubectl run –generator=deployment/apps.v1 is DEPRECATED and will be removed in a future version. Use kubectl run –generator=run-pod/v1 or kubectl create instead.因为官方不推荐使用 run-pod/v1 以外的其他生成器，其他生成器不久后就会弃用。更多内容参考kubectl run。
2、从已有K8S集群中已有资源中导出yaml模板文件（历史方法）：
kubectl get deploy/deployment-name -o yaml --export &gt; deploy-name.yaml
也会出现提示：Flag –export has been deprecated, This flag is deprecated and will be removed in future.很尴尬，–export 也要弃用了，且用且珍惜吧。
3、生成deployment的yaml文件模板（推荐方法）：
kubectl create deployment vk-deploy --image=nginx --dry-run -o yaml

更多内容，参考Kubernetes kubectl create deployment 命令详解。
注意，我们并不需要在deployment中指定容器对外暴露的ports，因为该字段只是一个提示作用。

List of ports to expose from the container. Exposing a port here gives the system additional information about the network connections a container uses, but is primarily informational. Not specifying a port here DOES NOT prevent that port from being exposed. Any port which is listening on the default “0.0.0.0” address inside a container will be accessible from the network. Cannot be updated.

service yaml生成service的yaml文件模板（推荐方法）：
kubectl create service clusterip vk-svc --tcp="5678:80" --dry-run -o yaml

更多内容，参考Kubernetes kubectl create service 命令详解和Service。
yaml验证kubectl create --validate -f deployment.yaml

node相关taint和tolerations# 添加taintkubectl taint nodes node1 key1=value1:NoSchedulekubectl taint nodes node1 key2=value2:PreferNoSchedulekubectl taint nodes node1 key3=value3:NoExecute# 删除taintkubectl taint nodes node1 value1:NoSchedule-

同时，要在pod yaml的spec下添加tolerations字段：
spec:  tolerations:  - key: "key1"    operator: "Equal"    value: "value1"    effect: "NoSchedule"  - key: "key2"    operator: "Exists"    effect: "PreferNoSchedule"  - key: "key3"    operator: "Equal"    value: "value3"    effect: "NoExecute"

label和affinity# 添加labelkubectl label nodes node1 key1=value1,key2=value2# 删除labelkubectl label nodes node1 key1-

同时，要在pod yaml中添加tolerations字段：
nodeSelector:  disktype: ssd
或者，使用：
spec:  affinity:    nodeAffinity:      requiredDuringSchedulingIgnoredDuringExecution:        nodeSelectorTerms:        - matchExpressions:          - key: key1            operator: In            values:            - value1            - valuex      preferredDuringSchedulingIgnoredDuringExecution:      - weight: 1        preference:          matchExpressions:          - key: key2            operator: In            values:            - value2            - valuey

node封锁如果node存在问题，或者node需要升级维护，这时需要对node进行封锁，并且驱除pod。
# 封锁node，不允许分配podkubectl cordon nodename# 从指定node驱除podkubectl drain nodename --ignore-daemonsets# 解除node的封锁，允许分配podkubectl uncordon nodename

容器交互执行命令1、登录容器
kubectl exec -it pod-name /bin/bashkubectl exec -it pod-name -c container-name /bin/bashkubectl exec -it pod-name -c container-name sh

2、直接执行命令
kubectl exec pod-name envkubectl exec pod-name -- envkubectl exec pod-name -it -- envkubectl exec -n default pod-name -it -- env# 命令带参数时必须加双横线kubectl exec pod-name -- sh -c 'echo $&#123;LANG&#125;'

拷贝文件# 拷贝pod内容到宿主机kubectl cp podname-564949c96c-m986n:/path/filename .

故障排查故障排查的第一步是先给问题分下类。这个问题是什么？Pods，Replication Controller或者Service？更多内容参考应用故障排查。
Pods排查# 查看pod详细信息kubectl describe pods $&#123;POD_NAME&#125;# 查看容器日志kubectl logs $&#123;POD_NAME&#125; $&#123;CONTAINER_NAME&#125;# 查看crashed容器日志kubectl logs --previous $&#123;POD_NAME&#125; $&#123;CONTAINER_NAME&#125;# 查看运行的容器内部日志kubectl exec $&#123;POD_NAME&#125; -c $&#123;CONTAINER_NAME&#125; -- cat /var/log/cassandra/system.log# 查看运行的容器内部日志（pod只有一个容器）kubectl exec $&#123;POD_NAME&#125; -- cat /var/log/cassandra/system.log

RC排查Replication Controllers排查
# 监控rc相关事件kubectl describe rc $&#123;CONTROLLER_NAME&#125;

Services排查# 查看endpoints资源，service选择到了哪些pod和端口kubectl get endpoints $&#123;SERVICE_NAME&#125;

小技巧service cidr怎样查看一个k8s集群的service ip范围？
kubeadm config view | grep Subnetkubectl get pods -n kube-system kube-apiserver-master -oyaml | grep service-cluster-ip-range

pod cidr怎样查看一个k8s集群的pod ip范围？
kubeadm config view | grep Subnetkubectl cluster-info dump | grep -i cidr

如果上面两个方法都找不到，那么还可以通过网络组件的日志来查看，以weave为例。
docker ps | grep weavedocker logs &lt;weave-container-id&gt; | grep ipalloc-range

k8s工具箱voidking/k8s-tool
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
        <tag>kubectl</tag>
      </tags>
  </entry>
  <entry>
    <title>使用lanproxy进行内网穿透</title>
    <url>/dev-lanproxy/</url>
    <content><![CDATA[内网穿透《微信本地调试》一文中，郝同学提到了使用ngrok、natapp和花生壳进行内网穿透。但是，想要使用自定义域名，都是要收费的。
本文中，我们要搭建一个免费的内网穿透服务器。内网穿透服务器，可选的软件有lanproxy、frp、n2n等等，今天我们选择的是lanproxy。


准备1、一台公网服务器（运行proxy-server）。2、一台内网pc或服务器（运行proxy-client）。
服务端配置安装java参考《全平台安装JDK》。
安装lanproxy1、访问lanproxy下载地址，下载proxy-server-0.1.zip，上传到公网服务器。
或者，直接在服务器上下载
wget https://github.com/ffay/lanproxy/files/1274739/proxy-server-0.1.zipcurl -C - -O -L https://github.com/ffay/lanproxy/files/1274739/proxy-server-0.1.zip

2、解压安装
unzip proxy-server-0.1.zipmv proxy-server-0.1 /usr/local/

3、修改配置文件vim /usr/local/proxy-server-0.1/conf/config.properties修改管理员的用户名和密码。
4、启动服务
cd /usr/local/proxy-server-0.1/binchmod +x startup.sh./startup.sh

5、访问 http://host_ip:8090 ，即可看到登录界面。
nginx反向代理1、添加域名解析local到公网ip。
2、在nginx虚拟主机配置目录中，添加local.voidking.com.conf，内容如下：
server &#123;    listen 80;    server_name local.voidking.com;    charset utf-8;    location /&#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        client_max_body_size       1024m;        client_body_buffer_size    128k;        client_body_temp_path      data/client_body_temp;        proxy_connect_timeout      90;        proxy_send_timeout         90;        proxy_read_timeout         90;        proxy_buffer_size          4k;        proxy_buffers              4 32k;        proxy_busy_buffers_size    64k;        proxy_temp_file_write_size 64k;        proxy_temp_path            data/proxy_temp;                proxy_pass http://127.0.0.1:8090;    &#125;&#125;

3、测试nginx./nginx -t，也许会提示缺少目录，那么新建目录。mkdir -p /usr/local/nginx/data/client_body_temp
mkdir -p /usr/local/nginx/data/proxy_temp
4、重启nginx./nginx -s reload
5、访问 http://local.voidking.com/ ，即可看到登录界面。
使用服务端配置1、登录lanproxy，添加客户端，输入客户端备注名称，生成随机密钥，提交添加。
2、客户端列表中，配置管理中，都会出现新添加的客户端。
3、单击配置管理中的客户端，添加配置（每个客户端可以添加多个配置）。

代理名称，推荐输入客户端要代理出去的端口，或者是客户端想要发布到公网的项目名称。
公网端口，填入一个服务器空闲端口，用来转发请求给客户端。
代理IP端口，填入客户端端口，公网会转发请求给该客户端端口。

客户端配置1、访问lanproxy下载地址，下载proxy-client-0.1.zip，解压到喜欢的目录。
2、进入proxy-client-0.1/conf目录，修改config.properties为：
#与在proxy-server配置后台创建客户端时填写的秘钥保持一致；没有服务器可以登录 https://lanproxy.org/ 创建客户端获取秘钥client.key=7533f855416741d88732954991668715ssl.enable=truessl.jksPath=test.jksssl.keyStorePassword=123456#这里填写实际的proxy-server地址；没有服务器默认即可，自己有服务器的更换为自己的proxy-server（IP）地址server.host=local.voidking.com#proxy-server ssl默认端口4993，默认普通端口4900#ssl.enable=true时这里填写ssl端口，ssl.enable=false时这里填写普通端口server.port=4993

3、进入proxy-client-0.1/bin目录，双击startup.bat，即可启动lanproxy客户端。
如果启动失败，一般是因为jdk没有安装配置成功，参考《IDEA的常用配置》中的安装jdk，安装配置jdk后再次启动即可。
4、访问地址 http://local.voidking.com:50000/ ，即可看到本地访问客户端80端口相同的页面。
至此，代理成功！
进阶配置一个端口一个项目假设，我们本地的4000端口开启了node服务。那么，怎么把这个服务优雅地提供给整个互联网？
1、服务端添加配置
2、启动本地node服务
3、已经启动lanproxy客户端，访问 http://local.voidking.com:50001/
此时，整个互联网都能访问到这个node项目，但是，带着端口号很不友好。那么，我们就给这个项目添加一个单独的域名。
1、添加域名解析node.local到公网ip。
2、在nginx虚拟主机配置目录中，添加node.local.voidking.com.conf，内容如下：
server &#123;    listen 80;    server_name node.local.voidking.com;    charset utf-8;    location /&#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        client_max_body_size       1024m;        client_body_buffer_size    128k;        client_body_temp_path      data/client_body_temp;        proxy_connect_timeout      90;        proxy_send_timeout         90;        proxy_read_timeout         90;        proxy_buffer_size          4k;        proxy_buffers              4 32k;        proxy_busy_buffers_size    64k;        proxy_temp_file_write_size 64k;        proxy_temp_path            data/proxy_temp;                proxy_pass http://127.0.0.1:50001;    &#125;&#125;

3、重启nginx./nginx -s reload
4、访问地址 http://node.local.voidking.com/ ，即可看到本地node服务。
一个端口多个项目1、通过我们开放出的80端口，可以访问web根目录下的很多项目，比如在其他文章中提到过的basic项目和vkphp项目，下文以vkphp项目为例。
2、当前，vkphp项目首页是简单的文字显示。
3、通过外网访问的地址为 http://local.voidking.com:50000/vkphp
此时，整个互联网都能访问到这个vkphp项目，但是，带着端口号和项目名，感觉像是个欺诈网站。那么，我们能否给这个项目添加一个单独的域名呢？当然也是可以的。
1、添加域名解析vkphp.local到公网ip。
2、在nginx虚拟主机配置目录中，添加vkphp.local.voidking.com.conf，内容如下：
server &#123;    listen 80;    server_name vkphp.local.voidking.com;    charset utf-8;    location /&#123;        proxy_set_header   Host             $host;        proxy_set_header   X-Real-IP        $remote_addr;        proxy_set_header  X-Forwarded-For  $proxy_add_x_forwarded_for;        client_max_body_size       1024m;        client_body_buffer_size    128k;        client_body_temp_path      data/client_body_temp;        proxy_connect_timeout      90;        proxy_send_timeout         90;        proxy_read_timeout         90;        proxy_buffer_size          4k;        proxy_buffers              4 32k;        proxy_busy_buffers_size    64k;        proxy_temp_file_write_size 64k;        proxy_temp_path            data/proxy_temp;                proxy_pass http://127.0.0.1:50000;    &#125;&#125;

3、重启nginx./nginx -s reload
4、打开本地apache的http-vhosts.conf，添加配置：
&lt;VirtualHost *:80&gt; #laragon magic!    DocumentRoot "C:/laragon/www/vkphp/"    ServerName vkphp.local.voidking.com    ServerAlias vkphp.local.voidking.com&lt;/VirtualHost&gt;

5、重启本地apache
6、访问地址 http://vkphp.local.voidking.com/ ，即可看到本地vkphp项目。
有趣的是，访问时该地址会自动在后面加上vkphp，成为 http://vkphp.local.voidking.com/vkphp/
结语由上配置我们发现，nginx的反向代理非常好用。稍微调整，便可以适应大多数项目，实在是美化url的神器，哇咔咔。
需要说明的是，在使用centos7作为lanproxy外网服务器的时候，无法代理内网服务器的22端口。所有的ssh连接请求都被centos7当做恶意请求自己处理了，并不会转发到内网。而使用ubuntu16作为lanproxy外网服务器，就没有这个问题。很神奇，没有找到原因。
书签lanproxy源码地址
业余草推荐一款局域网（内网）穿透工具lanproxy
frp源码地址
frp中文文档
使用frp实现内网穿透
n2n源码地址
n2n内网穿透神器(一条命令实现穿透)
n2n内网穿透神器
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>apache</tag>
        <tag>nginx</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Libvirt创建虚拟机</title>
    <url>/dev-libvirt-create-vm/</url>
    <content><![CDATA[libvirt简介参考QEMU和QEMU-KVM的关系，可以了解到，KVM实现对CPU的底层虚拟化和内存的虚拟化，使Linux内核成为虚拟化层，需要x86架构的，支持虚拟化功能的硬件支持（比如Intel VT，AMD-V），是一种全虚拟化架构。QEMU是一套由Fabrice Bellard编写的模拟处理器的自由软件，它是一个完整的可以单独运行的软件，可以独立模拟出整台计算机，包括CPU，内存，IO设备，通过一个特殊的“重编译器”对特定的处理器的二进制代码进行翻译，从而具有了跨平台的通用性。
总的来说，QEMU是一个独立的虚拟化解决方案，并不依赖KVM（它本身自己可以做CPU和内存的模拟，只不过效率较低），而KVM是另一套虚拟化解决方案，对CPU进行虚拟效率较高（采用了硬件辅助虚拟化），但本身不提供其他设备的虚拟化，借用了QEMU的代码进行了定制，所以KVM方案一定要依赖QEMU。
Libvirt是用于管理虚拟化平台的开源的API，后台程序和管理工具。它可以用于管理KVM、Xen、VMware ESX，QEMU和其他虚拟化技术。
Libvirt主要由三个部分组成：API库，一个守护进程libvirtd和一个默认命令行管理工具 virsh。
更多内容参考libvirt 介绍。


实验环境不能直接在OpenStack环境中实验，因为这样会破坏OpenStack。而且，使用kolla安装的OpenStack，没有virsh命令，libvirt是运行在容器中的。
所以，我们搭建一个新的实验环境：两个节点分别为node0和node1，ubuntu16系统，IP分别为192.168.56.200和192.168.56.201。
安装libvirt参考Ubuntu16.04安装QEMU与libvirt，安装QEMU和libvirt。
1、切换到root用户sudo -i
2、查看主机是否支持硬件虚拟化egrep -c &#39;(vmx|svm)&#39; /proc/cpuinfo因为我们的实验本身是在虚拟机中进行的，所以输出0，表示不支持硬件虚拟化。
3、安装QEMU和libvirtapt install -y qemu libvirt-bin bridge-utils virt-manager virt-viewer
如果是支持硬件虚拟化，那么执行安装：apt install -y kvm qemu-kvm libvirt-bin bridge-utils virt-manager virt-viewer
bridge-utils是网桥管理工具。virt-manager是一个通用的桌面管理工具。virt-viewer是一个用于显示虚拟机的图形控制台的最小工具。
4、检查安装
virsh --versionvirt-manager --versionvirt-viewer --version

5、查看网络
ip abrctl showvirsh net-list
安装完成以后，默认是启用了桥接网络virbr0，IP为192.168.122.1/24。如果没有启用，那么参考ubuntu16.04环境安装KVM进行启用。
6、安装vncserverapt-get install vnc4server
qemu创建虚拟机参考嵌套虚拟化—VMware+QEMU/KVM、ubuntu下使用qemu安装虚拟机并配置桥接网络和使用qemu安装虚拟机，进行虚拟机的创建。
1、创建磁盘
mkdir /opt/qemucd /opt/qemuqemu-img create -f qcow2 cirros0.img 5g

qcow2是qemu最常使用的格式，该格式下可以采用来写时复制技术来优化性能；cirros0.img是磁盘名称；5g是指磁盘文件大小。
2、下载cirros系统
wget http://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img

3、安装cirros到磁盘
qemu-system-x86_64 -hda cirros0.img -boot d -cdrom ./cirros-0.4.0-x86_64-disk.img -m 512 -vnc :1

如果是支持硬件虚拟化，那么执行安装：
qemu-system-x86_64 -enable-kvm -hda cirros0.img -boot d -cdrom ./cirros-0.4.0-x86_64-disk.img -m 512 -vnc :1

enable-kvm使用KVM进行加速；hda指定要使用的虚拟磁盘；boot d指定启动位置，d表示从光盘启动；cdrom指定镜像文件；m指定虚拟机内存大小，默认单位是MB；vnc:1通过vnc创建虚拟桌面。
出现警告：warning: TCG doesn’t support requested feature: CPUID.01H:ECX.vmx [bit 5]没啥影响，不去管它。但是另外一个问题来了？怎么进行交互安装？
4、本地打开vncviewer client，输入ip:5901进行连接，即可看到安装过程。卡在了安装界面：
Boot failed: could not read the boot diskNo more network devicesNo bootable device

参考Play with Libvirt/KVM发现，cirros-0.4.0-x86_64-disk.img本身就是一个磁盘，尴尬。。。
5、启动实例
qemu-system-x86_64 -m 512 -smp 4 \-drive file=cirros-0.4.0-x86_64-disk.img \-vnc :1
本地打开vncviewer client，输入ip:5901进行连接，即可看到启动过程。因为没有enable-kvm，所以启动很慢，请耐心等待。
6、查看实例IP登录cirros，然后查看IP、内存和硬盘
ip addfree -mdf -h
IP默认为10.0.2.15；内存512M，是指定的；硬盘默认256M。
当ctrl+c结束qemu-system-x86_64命令后，实例就被关闭了。再次使用qemu-system-x86_64命令启动实例，登录实例后使用history命令，发现之前的命令记录都还在，说明两次使用的都是同一块磁盘，也就是cirros-0.4.0-x86_64-disk.img。
7、设置IPsudo vi /etc/network/interfaces，eth0的配置修改为：
auto eth0iface eth0 inet staticaddress 192.168.122.100netmask 255.255.255.0

然后重启网卡，sudo ifdown eth0，sudo ifup eth0。但是，无法ping通192.168.122.1，说明实例的网卡并没有和virbr0进行连接。
创建网络实例有了，但是还不能连接外部网络。参考访问qemu虚拟机的五种姿势，创建网络，重新启动实例。
1、创建网桥
brctl add virbr0ifconfig virbr0 192.168.122.1 net mask 255.255.255.0 up
网桥已经存在，所以这一步不需要了。
2、创建tap接口，并添加到网桥
apt install uml-utilitiestunctl -t tap0ifconfig tap0 0.0.0.0 upbrctl addif virbr0 tap0

3、让实例使用tap0作为网络设备启动
qemu-system-x86_64 -m 512 -smp 4 \-drive file=cirros-0.4.0-x86_64-disk.img \-netdev tap,id=tapnet,ifname=tap0,script=no \-device rtl8139,netdev=tapnet \-vnc :1

4、测试网络登录实例，ping 192.168.122.1，此时网络已经通了。
libvirt创建虚拟机以上创建虚拟机的过程，其实并没有用到libvirt。下面参考Play with Libvirt/KVM，使用libvirt进行虚拟机的创建。
1、创建虚拟机
virt-install --connect=qemu:///system --name=cirros --ram=512 --vcpus=1 --disk path=cirros-0.4.0-x86_64-disk.img,format=qcow2 --import --network network:default --vnc

无法使用vncviwer进行连接，然后卡在上图的界面，最后ctrl+c强制结束。配置文件位于/etc/libvirt/qemu/cirros.xml，如果要编辑它，使用virsh edit cirros命令。
2、显示vnc portvirsh vncdisplay cirros
3、显示实例列表virsh list
4、查看实例详情virsh dominfo cirros
问题来了，怎么访问这个实例呢？最简单的方法是使用virsh console cirros命令打开控制台，使用ctrl+]关闭控制台，另外就是通过ssh或者vnc。
5、查看实例网络参考Find the IP address of a virtual machine，使用arp -an命令查看实例IP。然后，挨个ping一下192.168.122.0网段的IP，即可找到实例的IP，本次找到的IP为192.168.122.49。
6、访问实例ssh cirros@192.168.122.49输入默认密码gocubsgo，即可登录实例。
7、测试网络ping 8.8.8.8 -c3至此，大功告成，创建实例成功。
8、销毁实例（可选）
virsh destroy cirrosrm /etc/libvirt/qemu/cirros.xmlvirsh# undefine cirros# quit

libvirt配置网络以上我们知道，可以使用arp -an命令查看实例IP，如果查看到的IP都不能访问呢？这时就需要我们来手动配置，参考给libvirt创建的虚拟机指定固定IP。
1、查看libvirt网络virsh net-list --all
2、查看实例的网络virsh domiflist cirros查看到mac地址为52:54:00:7f:0e:77。
3、修改libvirt网络配置virsh net-edit default，如下修改：
&lt;network&gt;  &lt;name&gt;default&lt;/name&gt;  &lt;uuid&gt;cc522162-7487-41dc-82ee-63df0df4003e&lt;/uuid&gt;  &lt;forward mode='nat'/&gt;  &lt;bridge name='virbr0' stp='on' delay='0'/&gt;  &lt;mac address='52:54:00:d6:65:fb'/&gt;  &lt;ip address='192.168.122.1' netmask='255.255.255.0'&gt;    &lt;dhcp&gt;      &lt;range start='192.168.122.2' end='192.168.122.254'/&gt;      &lt;!--line 10, add--&gt;      &lt;host mac='52:54:00:7f:0e:77' name='cirros' ip='192.168.122.100'/&gt;    &lt;/dhcp&gt;  &lt;/ip&gt;&lt;/network&gt;
以上，给cirros实例配置了静态IP为192.168.122.100。
4、重启网络
virsh net-destroy defaultvirsh net-start default#virsh --connect qemu:///system net-destroy default#virsh --connect qemu:///system net-start default

5、重启实例
virsh shutdown cirrosvirsh start cirros


libvirt配置VNC某些情况下，无法通过IP访问实例，这时就需要配置vnc，参考kvm虚拟机VNC的配置。
1、配置vncvirsh edit cirros，找到
&lt;graphics type='vnc' port='-1' autoport='yes'/&gt;
修改为：
&lt;graphics type='vnc' port='5901' autoport='no' listen='0.0.0.0'&gt;         &lt;listen type='address' address='0.0.0.0'/&gt;        &lt;/graphics&gt;

2、重启实例
virsh shutdown cirrosvirsh start cirros

3、vnc访问本地打开vncviewer client，输入ip:5901进行连接。登录实例后，也可以设置静态IP，这样就不用通过virsh net-edit default修改了。
后记其实，虚拟机中安装的虚拟机，也可以支持KVM了，参考KVM嵌套虚拟化 – 在虚拟机中创建虚拟机和Nested KVM，开启嵌套虚拟化即可。
1、查看宿主机是否开启嵌套虚拟化cat /sys/module/kvm_intel/parameters/nestedN代表没有开启。
2、开启嵌套虚拟化echo &#39;options kvm_intel nested=1&#39; &gt;&gt; /etc/modprobe.d/qemu-system-x86.conf然后重启系统。
书签linux初学者-网络桥接篇
Documentation/Networking
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S入门篇</title>
    <url>/dev-k8s-start/</url>
    <content><![CDATA[K8S简介之前浅薄地研究过Docker容器相关技术，我们知道Docker最开始是一个管理容器的工具，后来发展成为容器云。容器云以容器为资源分割和调度的基本单位，封装整个软件运行时环境，为开发者和系统管理员提供用于构建、发布和运行分布式应用的平台。当容器云专注于资源共享与隔离、容器编排与部署时，它更接近传统的IaaS；当容器云渗透到应用支撑与运行时环境时，它是一种PaaS。
但是，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理。于是，Kubernetes出现了。Kubernetes这个单词来自于希腊语，含义是舵手或领航员。缩写为K8S，8代表“ubernete”这8个字符。
更多内容，参考10分钟看懂Docker和K8S和浙大SEL实验室的《Docker 容器与容器云》。


K8S架构K8S起源于Borg，Borg是谷歌内部的大规模集群管理系统，负责对谷歌内部很多核心服务的调度和管理。Borg 的目的是让用户能够不必操心资源管理的问题，让他们专注于自己的核心业务，并且做到跨多个数据中心的资源利用率最大化。Borg 主要由 BorgMaster、Borglet、borgcfg 和 Scheduler 组成。

BorgMaster 是整个集群的大脑，负责维护整个集群的状态，并将数据持久化到 Paxos 存储中；
Scheduer 负责任务的调度，根据应用的特点将其调度到具体的机器上去；
Borglet 负责真正运行任务（在容器中）；
borgcfg 是 Borg 的命令行工具，用于跟 Borg 系统交互，一般通过一个配置文件来提交任务。

K8S借鉴了Borg的设计理念，整体架构跟 Borg 非常像，一个K8S系统，通常称为一个K8S集群（Cluster）。这个集群主要包括两个部分：一个Master节点（主节点）和一群Node节点（计算节点）。Master节点主要还是负责管理和控制。Node节点是工作负载节点，里面是具体的容器。
Master节点包括API Server、Scheduler、Controller manager、Etcd等。

API Server提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制；
Scheduler负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；
Controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；
Etcd保存了整个集群的状态。

Node节点包括Docker、Kubelet、Proxy、Pod等。

Docker负责管理容器。
Kubelet负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理；
Proxy负责为Pod对象提供代理。
Pod是Kubernetes最基本的操作单元。一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。除了Pod之外，K8S还有一个Service的概念，一个Service可以看作一组提供相同服务的Pod的对外访问接口。

除了核心组件，还有一些推荐的 Add-ons：

kube-dns 负责为整个集群提供 DNS 服务
Ingress Controller 为服务提供外网入口
Heapster 提供资源监控
Dashboard 提供 GUI
Federation 提供跨可用区的集群
Fluentd-elasticsearch 提供集群日志采集、存储与查询

更多内容，参考Kubernetes 架构原理。
Minikube安装Minikube是在个人计算机上的虚拟机中运行单节点Kubernetes集群的工具。因为minikube要启动virtualbox虚拟机，在虚拟机中运行k8s集群。所以这里有两个安装思路：思路一、在centos7虚拟机中安装virtualbox，以及minikube。思路二、在本机win10中安装virtualbox，以及minikube。
对于思路一，经过尝试（详见扩展学习），发现virtualbox不支持Intel处理器的嵌套虚拟化，因此minikube无法在centos7虚拟机中再启动虚拟机，该思路不可行。
本文接下来使用思路二进行安装，默认virtualbox已经安装完成。安装方法主要参考Install Minikube and Docker with VirtualBox on Windows 10 Home和Kubernetes 学习笔记之 MiniKube 安装。
安装Docker Toolbox1、下载Docker Toolbox，双击安装。
2、启动Docker Toolbox打开Docker quickstart terminal，Docker会进行初始化。
镜像加速器参考Docker入门中的镜像加速器一节，本文中使用阿里云的镜像加速器。
1、访问阿里云镜像加速器，得到一个专属的加速地址。
2、对于Docker Toolbox用户，首先进入default虚拟机docker-machine ssh default
3、设置加速地址
sudo sed -i "s|EXTRA_ARGS='|EXTRA_ARGS='--registry-mirror=https://wrqtu3hz.mirror.aliyuncs.com |g" /var/lib/boot2docker/profileexit

4、验证配置
docker-machine restart defaultdocker info
如果出现Registry Mirrors和加速地址，则表明设置成功。
常用命令：
# 重启电脑后，需要手动启动default虚拟机docker-machine start default# default虚拟机IP发生变动时，需要重新生成配置docker-machine regenerate-certs defaultdocker-machine enveval $("C:\Program Files\Docker Toolbox\docker-machine.exe" env)

安装Minikube1、下载阿里云版minikube v1.2.0，放入k8s目录，重命名为minikube.exe，并加入环境变量。其他版本修改下载的url即可，版本号可以在github aliyun minikube中找到。
之所以使用阿里云版minikube，是因为原版的minikube在国内启动失败，无法下载Minikube ISO镜像。
2、验证安装右键+Shift打开Powershell，输入minikube version
3、启动minikube
minikube start# orminikube start --vm-driver=virtualbox --registry-mirror=https://registry.docker-cn.com


4、验证启动minikube status
5、启动minikube dashboardminikube dashboard

其他安装方式参考Install Minikube。
安装kubectl1、下载kubectl，同样放到k8s目录。
2、验证安装kubectl version
Hello Minikube参考Hello Minikube，目标：

将部署hello world应用程序部署到Minikube。
运行应用程序。
查看应用日志。

1、使用git bash启动minikubeminikube start
2、准备镜像
# 准备文件docker pull node:6.14.2vi server.jsvi Dockerfile# 创建镜像docker build -t voidking/hello-node .# 登录上传# docker loginwinpty docker logindocker push voidking/hello-node

其中server.js写入内容为：
var http = require('http');var handleRequest = function(request, response) &#123;  console.log('Received request for URL: ' + request.url);  response.writeHead(200);  response.end('Hello World!');&#125;;var www = http.createServer(handleRequest);www.listen(8080);

Dockerfile写入内容为：
FROM node:6.14.2EXPOSE 8080COPY server.js .CMD node server.js

3、创建管理Pod的Deployment，Pod根据提供的Docker镜像运行容器。
kubectl create deployment hello-node --image=voidking/hello-node

4、查看Deployments和Pods
kubectl get deploymentskubectl get podskubectl describe pod hello-node

由上图可以看出，创建pod的过程中，花费时间最长的是下载镜像的步骤，大约10分钟。这里有个疑问，为什么没有使用本地的镜像？
5、创建服务，将Pod公开到公共Internet
kubectl expose deployment hello-node --type=LoadBalancer --port=8080kubectl get servicesminikube service hello-node

在支持负载均衡器的云提供商上，将配置外部IP地址以访问服务。在Minikube上，LoadBalancer类型通过minikube service命令使服务可访问。打开浏览器，访问：http://192.168.99.103:30378/ ，可以看到 Hello World!
6、查看Pod和Servicekubectl get pod,svc -n kube-system

7、删除service和deployment（可选）
kubectl delete service hello-nodekubectl delete deployment hello-node

8、关闭集群，删除集群（可选）
minikube stopminikube delete

minikube常用命令# 进入节点服务器minikube ssh# 执行节点服务器命令，例如查看节点 docker infominikube ssh -- docker info# 查看插件，启用插件minikube addons listminikube addons enable heapsterminikube addons disable heapster

后记至此，跑通了Minikube的第一个Deployment，k8s的万里长征开始了第一步。接下来继续深入学习，目标是拿到双证：Certified Kubernetes Administrator (CKA) Program和Certified Kubernetes Application Developer (CKAD) Program，具体要求参考curriculum。
扩展学习CentOS7中安装VBox在centos7中安装virtualbox，如下流程：
1、添加安装源
yum install epel-releasewget -P /etc/yum.repos.d/ http://download.virtualbox.org/virtualbox/rpm/rhel/virtualbox.repoyum makecache fastyum list | grep virtualbox

2、安装virtualboxyum install VirtualBox-5.2
3、验证安装vboxmanage -V报错：
WARNING: The vboxdrv kernel module is not loaded. Either there is no module         available for the current kernel (3.10.0-957.el7.x86_64) or it failed to         load. Please recompile the kernel module and install it by           sudo /sbin/vboxconfig         You will not be able to start VMs until this problem is fixed.5.2.32r132073

4、修复（1）安装gcc等yum install gcc perl make
（2）安装kernel headeryum install kernel-devel
（3）安装rcvboxdrvrcvboxdrv setup如果依然缺少依赖，那么按照提示继续安装，比如yum install kernel-devel-3.10.0-957.el7.x86_64
（4）再次验证安装vboxmanage -V
centos7安装minikube1、安装kubectl（1）下载最新版kubectl
curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
或者下载指定版本kubectl
curl -LO https://storage.googleapis.com/kubernetes-release/release/v1.15.0/bin/linux/amd64/kubectl

（2）添加执行权限chmod +x ./kubectl
（3）移动kubectl到bin目录mv ./kubectl /usr/local/bin/kubectl
（4）验证安装kubectl version
2、安装minikube（1）下载minikube
curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \  &amp;&amp; chmod +x minikube

（2）移动minikub到bin目录install minikube /usr/local/bin
（3）验证安装minikube version
（4）启动minikubeminikube start如果报错machine does not exist，那么需要清空本地状态：minikube delete
书签Learn Kubernetes Basics
Interactive Tutorial - Creating a Cluster
Installing Kubernetes with Minikube
Kubernetes 学习路径
学习 Kubernetes 和容器技术体系的最佳方法
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令大全——EFGHIJK</title>
    <url>/dev-linux-command-all-efghijk/</url>
    <content><![CDATA[本文摘自《Linux/UNIX指令范例速查手册》。
Ee2fsck
e2fsck: ext2 file system check，检查ext2和ext3文件系统

e2fsck /dev/sda1，检查/dev/sda1的状态是否正常。如果发现异常，则会询问是否修复。
e2label
e2label: ext2 label，设置ext2和ext3文件系统卷标

e2label /dev/sda1 Boot，将文件系统/dev/sda1的卷标设置为Boot。
e2label /dev/sda1，显示文件系统/dev/sda1的卷标。
echo
echo: echo，显示文字

echo &quot;This is a test&quot;，将字符串This is a test显示到屏幕上。
echo &quot;Test: \t example1\nTest: \t example2&quot;，将字符串进行格式化的编排。
w，echo &quot;This is a test&quot; &gt; /dev/pts/1，将字符串This is a test显示到其他终端机/dev/pts/1上。
ed
ed: editor，文本编辑

ed file，编辑文件file。
ed不常用，一般使用vi。
edquota
edquota: edit quota，编辑账号或组所能使用的硬盘容量。

edquota karen，修改账号karen的quota用量。
edquota -p karen john，将karen的设置套用在john上。
egrep
egrep: grep -e，查找文件中的特定字符串

egrep 127.0 /etc/*，列出/etc下包含127.0字符串的所有文件。
eject
eject: eject，光驱的弹出与收回

eject，弹出光驱。
eject -j，收回光驱。
eject /dev/cdrom1，弹出指定光驱。
emerge
emerge: emerge，软件包安装与管理命令

emerge --sync，同步目前最新软件包名称。
emerge -pv apache，emerge -u apache，将apache升级到最新版本。
emerge -u world，将所有软件包升级到最新版本。
enable
enable: enable，启动或关闭shell的默认命令

enable -a，显示当前shell的所有启动的命令。
enable -n cd，关闭shell内置的命令cd。
eval
eval: evaluate，运算求出参数的内容

a1 = "This is a book"a2 = \$a1echo $a2eval echo $a2

ex
ex: vi in execution mode，文件编辑

ex file1，编辑文件file1。
ex相当于vi -e。
exit
exit: exit，退出当前shell

exit，退出并关闭当前的窗口。
export
export: export，设置环境变量

export exp=2.71828，echo $exp，将变量exp设置为2.71828。
export，列出当前的环境变量。
expr
expr: expression，求表达式变量的值

expr length &quot;this is a test&quot;，计算字符串长度。 
expr 14 % 9，计算余数。
expr substr &quot;this is a test&quot; 3 5，从位置处抓取字串。
expr index &quot;testforthegame&quot; e，计算第一个e出现的位置。
Ffc
fc: first command，修改或使用曾经使用的命令

fc -l，列出运行过的指令。
fc -e vi，用vi修改最后运行的指令，修改完自动运行。
fdisk
fdisk: formatted disk，设置硬盘分区

fdisk -l，列出第一块SCSI硬盘上的分区表。
fdisk /dev/sda，进入分区管理。

输入 m 显示所有命令提示。
输入 p 显示硬盘分割情形。
输入 a 设定硬盘启动区。
输入 n 设定新的硬盘分割区。输入 e 硬盘为[延伸]分割区(extend)，输入 p 硬盘为[主要]分割区(primary)。
输入 t 改变硬盘分割区属性。
输入 d 删除硬盘分割区属性。
输入 q 结束不存入硬盘分割区属性。
输入 w 结束并写入硬盘分割区属性。

fg
fg: front ground，将进程放到前台运行

tail -f /var/log/maillog &amp;，fg tail，将该进程放到前台运行。
fgrep
fgrep: grep -f，查找文件中的字符串

fgrep 127.0 /etc/*，列出/etc下文件中包含字符串127.0的所有文件。
file
file: file，显示文件类型

file /etc/hosts，显示一般文件。
file /etc/view，显示连接文件。
filefrag
filefrag: file fragment，显示文件的破碎状态

filefrag -v backupfile，检查文件backupfile的破碎状态。
find
find: find，查找特定的文件或目录名称

find . -name *.c，将目前目录及其子目录下所有扩展名是.c的文件列出来。
find / -name mysql.sock，在整个系统中查找mysql.sock文件。　　find . -type f，将目前目录其其下子目录中所有一般文件列出。　　find . -ctime -20，将目前目录及其子目录下所有最近20分钟内更新过的文件列出。　 
findfs
findfs: find file system，用标签或UUID查找文件系统

findfs LABEL=/，查找名为/的文件系统。
findfs LABEL=SWAP-sda6，查找名为SWAP-sda6的文件系统。
finger
finger: finger，远程查询主机上的账号信息

finger scfeng@localhost，查询本机账号scfeng的状态。
finger是早期远程查询命令，近年来由于安全考虑，几乎没有用户安装finger软件包。
fixfiles
fixfiles: fix files SELinux context，修正文件的SELinux标签

fixfiles restore /etc/vsftpd/*，修正/etc/vsftpd/目录下所有文件的标签。
fmt
fmt: formatter，文件编排

cat file，fmt -w 30 file，进行固定宽度文件编排。
fold
fold: fold，修改文件的显示宽度

cat file，fold -w 20 file，进行固定宽度文件编排。
free
free: free，显示内存使用状况

free，查看内容使用状况。
free -t，查询内存目前的状态，并列出物理内存与虚拟内存的总和。
fsck
fsck: file system check，检查或修复文件系统

在ext2文件系统下，和e2fsck功能完全相同。
ftp
ftp: file transferring protocol，文件传输

ftp 10.0.0.2，put file，bye，使用ftp上传一个名为file的文件。
ftpcount
ftpcount: FTP count，显示当前使用FTP的人数

ftpcount，查看当前登录FTP的人数。
ftpshut
ftpshut: FTP shutdown，停止ProFTP服务器

ftpshut -d 3，3min后关闭FTP服务器。
ftpwho
ftpwho: FTP who，显示当前登录FTP的名单

ftpwho，查看当前登录FTP的名单。
fuser
fuser: file and process user，通过文件或sockets确认进程

fuser -l，列出可以使用的系统信号。
fuser -km /home，删除与/home有关的程序。
Ggcc
gcc: GNU cc complier，C语言编译工具

gcc count.c，将文件count.c编译为可执行文件。
./a.out，运行a.out。
gcc count.c -o cc，将文件count.c编译为可执行文件，并指定可执行文件的名称为cc。
getsebool
getsebool: get SELinux boolean，显示SELinux的布尔值

getsebool ftp_home_dir，显示是否允许通过vsftpd连接到账号的家目录。
getsebool httpd_enable_cgi，显示是否允许httpd执行cgi script。
gpasswd
gpasswd: group password，管理/etc/group的高级工具

gpasswd elex，修改elex组的组密码。
gpasswd -a feng users，将账号feng到users组中。
gpasswd -d feng users，将feng从users组中删除。
gpasswd -A feng users，将feng设为users组中管理员。
gpm
gpm: graphic cut and paste manager，设置鼠标的粘贴功能

gpm -t ps2，启动PS/2鼠标。
grep
grep: global search regular expression，查找文件中的字符串

grep -c sum count.c，显示count.c中包含字符串sum的行数。
grep -v sum count.c，显示count.c中不含字符串sum的行。
grep -f file1 file2，搜寻file2中与file1有相同字符串的内容。
groupadd
groupadd: group add，新建组

groupadd admin，新建名为admin的组。
groupadd -r super，新建一个名为super的系统组。
groupadd -g 566 spot，新建一个组号为566，名为spot的组。
groupdel
groupdel: group del，删除组

groupdel admin，删除名为admin的组。
groupmod
groupmod: group mode，修改组的高级内容

groupmod -n admin super，将组super的名称改成admin。
groupmod -g 666 spot，将组spot的组号改为666。
groups
groups: groups，显示账号所属的组

groups admin，显示账号admin所属的组名称。
grpconv
grpconv: group convert，转换为组投影密码

gunzip
gunzip: GNU un-zip，解压缩gz文件

gunzip -l /var/log/* .gz，显示目录/var/log下所有的gz文件的信息。
gunzip -c file.gz &gt; file2，将file.gz解压缩，并保留原压缩文件。
gunzip -r /home/mark，将/home/mark下的所有gz文件全部解压缩。
gunzip -v file.gz，将file.gz解压缩，并显示过程。
gzexe
gzexe: GNU zip execution，运行压缩文件

gzexe -d a.out，运行已压缩可执行文件的a.out。
gzip
gzip: GNU zip，压缩gz的文件

gzip -v output，压缩output，并显示压缩过程。
gzip h*，压缩当前目录下所有文件名以h开头的文件。
gzip -9 backupfile1，指定压缩率压缩文件。
gzip -l /var/log/*.gz，显示目录/var/log/下所有gz文件的信息。
Hhalt
halt: halt，关闭系统

halt -p，关闭系统并关闭电源。
halt -d，关闭系统，并且不记录在日志文件/var/log/wtmp中。
halt -n，不将内存数据写入硬盘，直接关闭系统。
hash
hash: hash table

hash -l，显示记忆的命令。
hash -t cat，列出命令cat的路径。
hdparm
hdparm: hard disk parameter，显示或设置硬盘参数

hdparm -t /dev/sda，评估硬盘的读取效率。
hdparm -d 1 /dev/sda，启动硬盘的DMA模式。
hdparm -I /dev/sda，侦测硬盘的规格。
hdparm -C /dev/sda，侦测IDE硬盘电源管理模式。
head
head: head of file，输出文件内容前面的内容

head -n 3 install.log，显示前3行内容。
head -c 30 install.log，显示前30字节的内容。
help
help: help，shell内置命令说明

help alias，显示alias命令的说明。
history
history: history，列出使用过的命令

history 5，列出5个最近使用过的命令。
host
host: host，查询主机使用的域名

host www.taobao.com 61.139.2.69，在DNS服务器上61.139.2.69上查询地址www.taobao.com。
host -t mx 126.com 61.139.2.69，在机器61.139.2.69上查询网域126.com的邮件记录。
hostid
hostid: host id，显示主机ID

hostid，显示主机的识别码。
hostname
hostname: host name，显示或设置主机名

hostname，显示当前的主机名称。
hostname -d，显示当前的网域名称。
hostname -i，查询主机名对应的IP地址。
htpasswd
htpasswd: httpd passwd，设置Apache的账户密码

htpasswd -c /etc/htpasswd jack，新建一个Apache登录账号jack。
httpd
httpd: HTTP deamon，管理Apache网页服务器。

httpd -v，显示当前的apache详细信息。
httpd -f /opt/httpd.conf，使用指定的配置文件启动httpd。
httpd -t，测试配置文件的语法是否正确。
httpd -l，显示httpd编译时所包含的模块。
hwclock
hwclock: hardware clock，显示或设置硬件时间

hwclock，显示硬件日期与时间。
hwclock --set --date=&quot;5/1/11 12:15:01&quot;，将硬件时钟修改为2011年5月1日12点15分01秒。
Iiconv
iconv: internet conversion，字符集的转换

iconv -l，列出所有支持的格式。
id
id: identity，显示账号与组的ID

id -a，显示所有的账号信息。
id -g，显示账号所属的主组代码。
id -u，显示账号代码。
ifconfig
ifconfig: interface configuration，设置或查看网络配置

ifconfig，显示当前的网络设备及其状态。
ifconfig eth0 192.168.1.5 netmask 255.255.255.0，将IP地址设置为192.168.1.5，子网掩码设置为255.255.255.0。
ifconfig eth0，显示eth0的状态。
ifconfig eth0 down，将eth0停用。
info
info: information，显示在线帮助信息

info kill，查看kill的在线帮助信息。
init
init: initial，改变系统的运行等级

init 0，关闭计算机。
init 6，重新开机。
init 1，进入单用户模式。
insmod
insmod: insert module，价值模块

insmod brdcom.ko，加载模块brdcom.ko。
ip
ip: internet protocol，显示或设置网络设备的路由策略


ip link：网络设备设置。
ip address：IP地址的管理。
ip route：路由表的管理。
ip neighbour：邻近地址与ARP表的管理。
ip tunnel：IP通道设置。
ip maddr：组广播地址的管理。
ip rule：组广播地址的管理。
ip mroute：列出组路由地址。

ip address show，显示当前网络地址的设置。
ip route show，显示当前的路由列表。
ip route add 172.16.1.0/24 via 192.168.1.1，多重路由的设置：发往172.16.1.0/24的数据包，一律通过192.168.1.1传送。
ipcrm
ipcrm: interprocess communication remove，删除指定ID的IPC进程。

ipcs，ipcrm -m 262149，显示内部程序目前的状态，并将其中的共享内存删除。
ipcs
ipcs: interprocess communication status，显示IPC的状态

ipcs，显示内部程序目前的状态。
iptab
iptab: IP table，显示子网掩码的种类

iptab，显示子网掩码的种类。
iptables
iptables: IP tables，数据包处理与安全管理

iptables -L，显示当前iptables的设置。
iptables -F，iptables -X，将iptables中过滤表格的规则清楚。
echo "1" &gt; /proc/sys/net/ipv4/ip_forwardingiptables -t nat -A POSTROUTING -o eth0 -s 10.1.1.1/24 -j MASQUERADE
开启NAT功能，设置10.1.1.1~10.1.1.254可通过本机连接到互联网。
iptables -A INPUT -p tcp --dport 25 -j ACCEPTiptables -A INPUT -p tcp --dport 80 -j ACCEPTiptables -A INPUT -p tcp -i eth0 -j DROP
仅开启SMTP与HTTP的连接，关闭其他端口的连接。
iptables -A input -d 140.111.1.1 -p tcp -j DROP，不得连到IP地址140.111.1.1。
iptables-save
iptables-save: IP tables save，保存当前iptables的规则

iptables-save，保存当前iptables的规则。
isosize
isosize: ISO size，显示iso9600格式的文件系统大小

isosize /dev/hdc，显示当前光盘的容量。
Jjobs
jobs: job status，显示正在后台运行的任务

jobs，显示在后台运行的任务。
jobs -p，仅列出在后台运行的任务的PID。
join
join: join，合并两个文件中相同的区域

join -t &#39;:&#39; /etc/passwd /etc/shadow，将两个文件结合，以冒号作为字符串的分隔符。
Kkill
kill: kill，传送信息给进程

kill -l，列出所有的信号与代码。
ps -ef | grep mysql，kill -9 6887，查看mysql的PID，并且结束该PID。
killall
killall: kill all，根据给定名称终止进程

killall -9 ntop，将所有关于ntop命令的程序删除。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令大全——LMNOPQ</title>
    <url>/dev-linux-command-all-lmnopq/</url>
    <content><![CDATA[本文摘自《Linux/UNIX指令范例速查手册》。
Llast
last: last login，显示曾登录的账号

last，显示曾登录的账号。
last -x，显示系统关机参数与运行等级。
lastb
lastb: last bad login，显示登录失败的账号

lastb，显示登录失败的账号。
lastb -i，显示IP地址，而不显示主机名称。
ldd
ldd: library dependencies，列出与文件有关的函数库

ldd /bin/netstat，显示/bin/netstat所使用的共享函数库。
ldd /bin/cat，显示/bin/cat所使用的共享函数库。
less
less: less，显示文件内容

less ezhttp.log，分页查看ezhttp.log文件。使用pgup和pgdn上下翻页，使用q退出。
ps -ef | less，ps查看进程信息并通过less分页显示。
lilo
lilo: LInux LOader，开机启动程序

lilo -v -v -v，设置完/etc/lilo.conf开机配置后，使之开机时生效，指定显示第三级模式。
ln
ln: link，新建文件之间的连接

ln -s yy zz，将文件yy产生一个符号链接zz。　　ln yy xx，将文件yy产生一个硬链接zz。
lndir
lindir: link directory，新建目录之间的连接

lndir /etc/vsftpd/，新建目录的连接。
lnstat
lnstat: linux network statistics，列出网络数据统计信息。

lnstat -d，列出支持的统计文件。
locate
locate: locate，在系统中查找包含特定字符串的文件

locate mysql.sock，在整个系统中查找mysql.sock的文件。 
locate -n 100 a.out，在整个系统中查找a.out文件，但最多只显示100个。
locate -u，建立资料库。
系统如果找不到locate命令，需要先安装locate，yum install mlocate，然后更新locate的数据库，updatedb。
logname
logname: login name，列出登录的账号

logname，显示最开始登录系统的账号。
logrotate
logrotate: log rotate，定期或定量将日志文件压缩备份

logrotate /etc/logrotate.conf，执行logrotate命令并采用/etc/logrotate.conf中的设置。
logsave
logsave: log save，将制定程序的输出存为日志文件

logsave ps.txt ps，将ps的输出记录到文件ps.txt中。
lp
lp: line printer，打印文件

lp file1，将file1通过默认的打印机输入。
lpq
lpq: line printer queue，列出正在等待打印机的队列

lpq，列出目前打印机的队列状态。
lprm
lprm: line printer remove，删除正在打印的任务

lprm -，取消所有的打印任务。
ls
ls: list，列出目录或文件名

ls -ltr s*，列出当前工作目录下所有名称是s开头的文件，新的排后面。　　ls -lR /home，将 /home 目录以下所有目录及文件详细资料列出。　　ls -AF，列出目前工作目录下所有文件及目录。目录名称后会加 “/“，可执行文件名称后会加”*”，链接文件后会加”@”。
lsattr
lsattr: list attribute，列出ext2或ext3系统中文件的属性

lsattr，列出当前文件的类别。
lsmod
lsmod: list module，列出内核模块的使用状态

lsmod，列出（部分）内核模块在RedHat与Fedora上的使用状态。
lsusb
lsusb: list usb，列出所有USB设备。

lsusb，列出目前的USB设备。
lynx
lynx: 由大学实验室中命名而来，文字界面上显示网页内容

lynx www.google.com，通过lynx命令在终端机上浏览网页。
Mmail
mail: mail，收发邮件

mail -s &quot;test mail&quot; voidking@qq.com，信件主题为“test mail”，然后输入右键内容。信件结束时，输入一个点并按enter键。然后输入发件人的email地址，没有就按enter键。 
如果没有mail命令，需要先安装mailx，yum install mailx。
mailstats
mailstats: mail status，显示目前的邮件状态

mailstats，列出目前的邮件统计表。
mailq
mailq: mail queque，列出队列中的邮件

mailq，列出所有在队列中尚未寄出邮件。
make
make: make gcc program，维护或编译程序组

make -C /etc/mail，在RedHad下编译sendmail的配置文件。
cd /usr/src/linuxmakemake modules_installmake install
运行编译内核的编译顺序。
makemap
makemap: make map files，产生sendmail的数据库文件

makemap -l，列出支持的转换文件类型。
makemap hash /etc/mail/access.db &lt; /etc/mail/access，通过/etc/mail/access产生/etc/mail/access.db转换文件。
man
man: manual，显示在线帮助信息

man kill，显示kill命令说明。
man -K kill，显示所有与kill有关的说明。
manpath
manpath: manual path，显示在线帮助的搜索路径

manpath，显示在线帮助的搜索路径。
md5sum
md5sum: MD5 check sum，计算并显示MD5 sum。

md5sum file1，检验文件file1的MD5 sum。
cat checktxt，md5sum -c check.txt，检验check.txt中所记载的MD5 sum是否正确。
mesg
mesg: message，控制终端机的写入权限

mesg，查看其他人对当前终端机的写入权限。
mesg n，关闭其他人对当前终端机的写入权限。
mkbootdisk
mkbootdisk: make boot disk，制作启动盘

mkbootdisk --device /dev/fd0 --verbose 2.6.33，使用2.6.33的内核制作启动盘。
mkdir
mkdir: make directory，新建目录

mkdir temp，在当前目录下新建temp子目录。
mkdir -p /opt/www/test，新建所有不存在的目录和上层目录。
mke2fs
mke2fs: make ext2/ext3 file system，格式化为ext2、ext3或ext4的文件系统

mke2fs /dev/sda3，将分区格式化为ext2的文件系统。
mke2fs -j /dev/sda3，将分区格式化为ext3的文件系统。
mke2fs -t ext4 /dev/sda3，将分区格式化为ext4的文件系统。
mkfs
mkfs: make file system，格式化文件系统

mkfs /dev/sda1，将分区/dev/sda1格式化为默认的ext2文件系统。
mkfs.xfs
mkfs.xfs: make XFS file system，格式化为xfs的文件系统

mkfs.xfs /dev/sdc3，将分区格式化为xfs的文件系统。
mkinitrd
mkinitrd: make initial ramdisk images，建立ramdisk的镜像文件

uname -a，创建一个镜像文件。
mkinitrd /boot/initrd-new.img 2.6.33-85.fc13.i686.PAE，创建一个镜像文件。
mkreiserfs
mkreiserfs: make reiser file system，格式化为reiserfs的文件系统

mkreiserfs /dev/sda1，将分区/dev/sda1格式化为reiserfs的文件系统。
mkswap
mkswap: make swap，新建swap空间

mkswap /dev/sda2，新建一个swap空间。
modinfo
modinfo: module information，显示内核模块的信息

modinfo mii，显示mii模块的信息。
modinfo -a snd，只显示snd模块的作者信息。
modprobe
modeprobe: module probe，从内核中新建或删除模块

modprobe -l ext*，显示名称以ext开头的模块名称。
modprobe --show-depends ext2，显示与ext2有关的模块名称。
more
more: more，显示文件内容

more -s testfile，逐页显示 testfile 的文件内容，如有连续两行以上空白行则以一行空白行显示。
more +20 testfile，从第 20 行开始显示 testfile 之文件内容。
mount
mount: mount，挂载文件系统

mount，显示当前的分区状态。
mount -t xfs /dev/sda2 /opt，将分区/dev/sda2挂载到/opt上，并指定文件系统为xfs。
mount -t ext3 server1://data /opt，挂载NFS服务器所共享的文件系统。
mount -t smbfs -o username=tom,password=123 //10.1.1.1/TL /tmp，挂载windows系统的网上邻居中所共享的文件系统。
mtools
mtools: MSDOS tools，显示mtools所支持的命令

mtools，显示所有支持MSDOS文件系统的命令。
mutt
mutt: mail user agent，文字界面的邮件工具

mutt -s &quot;A test mail&quot; josfeng@gmail.com，将邮件寄给 josfeng@gmail.com，信件主题为A test mail。
mv
mv: move，移动或重命名文件或目录

mv aaa bbb，将文件 aaa 更名为 bbb。　　mv *.c finished，将所有的.c文件移动到 finished 目录中。
Nnano
nano: Nano’s another editor，文本编辑

ncftp
ncftp: new command line FTP，传送与接收文件

# ncftp -u max -p abc123 172.20.11.1&gt; get readme&gt; bye&gt; yes
使用ncftp命令下载一个readme文件。
netstat
netstat: net status，查询网络目前的状态

netstat -nt，显示目前TCP的连接状态。
netstat -apt，显示目前TCP应用进程所使用的端口号。
nice
nice: nice，更改优先级

nicenice -n 1 /bin/bashnice
调整shell的优先级。
nohup
nohup: no hup，后台运行指定的程序

nohup script1 &amp;，在后台运行script1，且在脱机后仍可继续运行。
nslookup
nslookup: name server lookup，域名与IP地址的对应

# nslookup&gt; www.163.com&gt; exit
查询www.163.com的网站地址。
# nslookup&gt; set type=mx&gt; qq.com
查询qq.com邮件服务器的地址。
Ood
od: octal dump，以八进制编码输出文件内容

od file，以八进制编码输出文件内容。
od -t c file，以ASCCII码显示文件file的内容。
Ppasswd
passwd: password，修改密码

passwd，一般账号修改密码。
passwd mark，修改账号mark的密码。
passwd -l peter，将peter账号停用。
passwd -u peter，将peter账号启用。
paste
paste: paste，合并文件的内容

paste file1 file2，将两个文件按列合并。
patch
patch: patch，补丁更新

patch file file.patch，以补丁文件file.patch修补文件file。
patch b file file.patch，以补丁文件file.patch修补文件file，并备份原文件。
pg
pg: pagewise，显示文件内容

pg aaa，使用pg显示aaa这个文件。
pgrep
pgrep: process grep，根据PID显示进程

pgrep gdm，列出与字符串gdm有关的PID。
pico
pico: pine composer，文本编辑

pidof
pidof: process ID of something，查找进程的PID

pidof nfs，显示进程nfs所用的PID。
pine
pine: 作者命名，文字界面的邮件工具

新版Linux中，pine已被alpine所取代。
ping
ping: 乒乓碰撞声，用特定的数据包测试主机是否在线

ping -c 5 www.sina.com.cn，发送5次ICMP echo数据包，并显示统计结果。
ping -s 120 192.168.1.1，使用大小为120Byte的数据包进行测试。
ping -r www.sina.com.cn，不通过网关，直接传送数据包。
pkill
pkill: process kill，传送信号给指定的进程

pkill -9 sendmail，将正在运行且含有sendmail的进程终止。
pmap
pmap: process map，显示进程的内存对应

pmap 2245，显示进程2245的运行状态。
postalias
postalias: postfix aliases，产生postfix的aliases数据库文件

postmap
postmap: postfix map，产生postfix的access数据库文件

postqueue
postqueue: postfix queue，postfix队列区的控制命令

mailq，显示在mailq队列中的邮件。
postqueue -f，强制传送队列中的邮件。
postsuper
postsuper: postfix super，postfix邮件队列的高级管理

mailq，postsuper -d B175，删除邮件B175。
postsuper -d ALL，删除所有在队列中的E-mail。
pr
pr: print，打印前的重新排版

ps
ps: process，显示目前的进程

ps，显示当前账号所运行的进程。
ps -ef，完成地列出所有账号的进程。
ps aux，列出所有账号的进程，以及该进程所有的CUP和内存比例。
pstree
pstree: process tree，以树状表示目前的进程

pstree，以树状表示目前的进程运行状况。
pwck
pwck: passwod check，检查密码文件的正确性

pwconv
pwconv: password convert，转换为投影密码

pwd
pwd: print the working directory，显示当前所在的目录

pwd，显示当前所在的目录。
pwunconv
pwunconv: password convert，还原投影密码

Qquota
quota: quota，显示并限制账号的硬盘用量

quota，显示自己的硬盘用量。
quota mark，显示账号mark的硬盘用量。
quotacheck
quotacheck: quota check，检查账号硬盘空间的限制

quotaoff
quotaoff: quota off，关闭账号硬盘空间的限制

quotaon
quotaon: quota on，开启账号硬盘空间的限制

quotastats
quotastats: quota status，显示账号硬盘空间限制的统计数据

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux设置定时任务</title>
    <url>/dev-linux-crontab/</url>
    <content><![CDATA[前言《使用PSSH批量管理Linux》一文中，已经学习了使用pssh批量管理linux的技巧。而很多时候，我们需要定时执行一些任务，或者需要定时执行一些批量任务。因此，本文就来研究一下linux设置定时任务的方法。
主要参考Linux Crontab 定时任务、Linux定时任务Crontab命令详解 和 Linux 定时任务详解 。


理论篇crond简介cron（crond）是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程。linux系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。另外，由于使用者自己也可以设置计划任务，所以，linux系统也提供了使用者控制计划任务的命令：crontab命令。
crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。

/var/spool/cron/crontabs/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名。
/etc/crontab 这个文件负责调度各种管理和维护任务。
/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。
我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期/月执行一次。

linux下的任务调度分为两类，系统任务调度和用户任务调度。
系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。/etc/crontab文件就是系统任务调度的配置文件。
用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在 /var/spool/cron/crontabs/目录中，其文件名与用户名一致。
crontab文件假设我们使用的是Ubuntu14.04.5 Server版，查看/etc/crontab，内容为：
# /etc/crontab: system-wide crontab# Unlike any other crontab you don't have to run the `crontab'# command to install the new version when you edit this file# and files in /etc/cron.d. These files also have username fields,# that none of the other crontabs do.SHELL=/bin/shPATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin# m h dom mon dow user  command17 *    * * *   root    cd / &amp;&amp; run-parts --report /etc/cron.hourly25 6    * * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily )47 6    * * 7   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly )52 6    1 * *   root    test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )

第一行SHELL变量指定了系统要使用哪个shell；第二行PATH变量指定了系统执行 命令的路径。接下来的命令格式为：m h dom mon dow user  command英文全拼为：minute hour day month week user commond

minute：表示分钟，可以是从0到59之间的任何整数。
hour：表示小时，可以是从0到23之间的任何整数。
day：表示日期，可以是从1到31之间的任何整数。
month：表示月份，可以是从1到12之间的任何整数。
week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。
user：表示用户。
command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。

注意，/var/spool/cron目录中的用户调度任务，没有user一项，因为文件名已经代表了user。
在以上各个字段中，还可以使用以下特殊字符：

星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。
逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”
中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”
正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。
同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。

crontab命令crontab命令格式为：crontab [-u username] [file] [ -e | -l | -r ]

-u username，指定设置某个用户的crontab，省略则表示操作当前用户的crontab。
file，将file做为crontab的任务列表文件并载入crontab。如果没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。
-e，编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。
-l，显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。
-r，删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。

实践篇设置系统时间设置定时任务和时间紧密相关，如果服务器的时区时间设置和本地不同，就不能保证计划任务的正确执行。所以使用crontab的第一步，是调节好服务器的时间。
下面参考Ubuntu 16.04将系统时间写入到硬件时间BIOS，对服务器时间进行调节。
时间是有时区的，无论硬件时间还是操作系统时间。hwclock的时区在/etc/default/rcS文件中设置，里面有一个参数UTC，默认值为yes，表示使用UTC时区，如果设置为no，那表示使用osclock的时区。建议hwclock与osclock设置相同的时区，也就是no。
1、查看服务器硬件时间sudo hwclock -r，看到的时间格式为：Wed 23 May 2018 11:02:17 AM HKT  -0.031663 seconds
2、查看服务器系统时间date，看到的时间格式为：Wed May 23 11:02:41 HKT 2018
3、设置hwclock和osclock时区相同sudo vim /etc/default/rcS，找到：
UTC=yes
修改为：
UTC=no

4、将系统时间写入硬件时间sudo hwclock -w
5、修改系统时区osclock的时区配置文件为/etc/timezone，不建议直接修改配置文件。
如果你想修改为CST时间，那么执行sudo tzselect命令时，选择Asia-&gt;China-&gt;Beijing Time即可，这时会提示使用Asia/Shanghai时区。（ubuntu和centos通用）
6、设置即刻生效执行date，发现时区没有变化，依然是HKT。
sudo cp /usr/share/zoneinfo/Asia/Shanghai  /etc/localtimesudo ntpdate time.windows.com
如果执行ntpdate报错：ntpdate[18409]: no server suitable for synchronization found ，那么就换一个时间同步工具。sudo apt-get install rdatesudo rdate -s time-b.nist.gov
再次执行date，发现时区已经变成了CST。
7、硬件时间同步sudo hwclock -r，发现硬件时间落后。sudo hwclock -w，再次把系统时间写入硬件时间，同步完成。
实例实例1：每分钟、每小时、每天、每周、每月、每年执行
* * * * * myCommand0 * * * * myCommand0 0 * * * myCommand0 0 * * 0 myCommand0 0 1 * * myCommand0 0 1 1 * myCommand

实例2：每小时的第3和第15分钟执行3,15 * * * * myCommand
实例3：在上午8点到11点的第3和第15分钟执行3,15 8-11 * * * myCommand
实例4：每隔两天的上午8点到11点的第3和第15分钟执行3,15 8-11 */2  *  * myCommand
实例5：每周一上午8点到11点的第3和第15分钟执行3,15 8-11 * * 1 myCommand
实例6：每晚的21:30重启smb30 21 * * * /etc/init.d/smb restart
实例7：每月1、10、22日的4 : 45重启smb45 4 1,10,22 * * /etc/init.d/smb restart
实例8：每周六、周日的1 : 10重启smb10 1 * * 6,0 /etc/init.d/smb restart
实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb0,30 18-23 * * * /etc/init.d/smb restart
实例10：每星期六的晚上11 : 00 pm重启smb0 23 * * 6 /etc/init.d/smb restart
实例11：每一小时重启smb0 * * * * /etc/init.d/smb restart
实例12：晚上11点到早上7点之间，每隔一小时重启smb0 23-7/1 * * * /etc/init.d/smb restart
实例13：每月的4号与每周一到周三的11点重启smb0 11 4 * mon-wed /etc/init.d/smb restart
实例14：一月一号的4点重启smb0 4 1 jan * /etc/init.d/smb restart
实例15：每小时执行/etc/cron.hourly目录内的脚本01 * * * * root run-parts /etc/cron.hourlyrun-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了。
查看ganglia的状态目标：每分钟查看一下ganglia的状态，并保存到/tmp/log/ganglia目录。
1、创建/tmp/log/ganglia目录sudo mkdir -p /tmp/log/ganglia
sudo chmod a+w /tmp/log/ganglia
2、编辑crontabcrontab -e，选择编辑器为vim
3、在crontab文件中添加一行（注意该命令是错误的，不要直接使用）
* * * * * pssh -h /home/test/hosts.txt -t 30 -i 'ps aux | grep gmond' &gt; /tmp/log/ganglia/ganglia-`date +%Y%m%d-%H%M%S`.log

4、查看crontab任务crontab -l，看到任务已经添加成功。
5、等待了五分钟，发现/tmp/log/ganglia目录下啥也没有。sudo service cron status，状态正常。sudo /etc/init.d/cron restart，重启cron试试。又等待了五分钟，发现/tmp/log/ganglia目录下依然空空。
莫非是因为pssh没有使用绝对路径？whereis pssh，找到pssh路径为/usr/lib/pssh，修改crontab为：
* * * * * /usr/lib/pssh -h /home/test/hosts.txt -t 30 -i 'ps aux | grep gmond' &gt; /tmp/log/ganglia/ganglia-`date +%Y%m%d-%H%M%S`.log
然而，并没有用。还是查看下crontab日志吧！
开启crontab日志以下主要参考Ubuntu下用crontab 部署定时任务。
1、编辑50-default.confsudo vim /etc/rsyslog.d/50-default.conf
2、把cron前的井号去掉，也就是修改为：
cron.*                         /var/log/cron.log

3、重启rsyslog服务sudo service rsyslog restart
4、重启crontab服务sudo service cron restart
5、查看crontab日志less /var/log/cron.log
果然发现了问题：
(test) CMD (/usr/lib/pssh -h /home/test/hosts.txt -t 30 -i 'ps aux | grep gmond' &gt; /tmp/log/ganglia/ganglia-`date +)
也就是说，命令确实按时执行了，只不过没有执行完，被百分号截断了，导致log文件没有正常生成！
修改crontab为：
* * * * * /usr/lib/pssh -h /home/test/hosts.txt -t 30 -i 'ps aux | grep gmond' &gt; /tmp/log/ganglia/ganglia-`date +\%Y\%m\%d-\%H\%M\%S`.log

终于，log文件成功生成，nice！但是，文件内容是空的！因为，/usr/lib/pssh是一个目录，不是pssh命令！真正的pssh命令是parallel-ssh，找到它的位置为/usr/bin/parallel-ssh，修改crontab：
* * * * * /usr/bin/parallel-ssh -h /home/test/hosts.txt -t 30 -i 'ps aux | grep gmond' &gt; /tmp/log/ganglia/ganglia-`date +\%Y\%m\%d-\%H\%M\%S`.log

至此，问题圆满解决。实际使用的时候，一天获取一次ganglia的状态就够了，所以crontab改成：
0 0 * * * /usr/bin/parallel-ssh -h /home/test/hosts.txt -t 30 -i 'ps aux | grep gmond' &gt; /tmp/log/ganglia/ganglia-`date +\%Y\%m\%d`.log

定时执行脚本以上，每天执行一次定时任务，抓取ganglia的运行状态保存到日志文件中。紧接着，我们的目标是使用脚本检查当天的日志文件，如果发现ganglia运行异常，则产生一个错误日志。
1、假设日志文件ganglia-20180524.log的内容为：
[1] 00:00:01 [SUCCESS] test@192.168.56.102ganglia  24810  0.0  0.0  57536  3396 ?        Ssl  May23   0:20 /usr/sbin/gmond --pid-file /var/run/gmond.pidtest     27619  0.0  0.0  11376  2800 ?        Ss   09:05   0:00 bash -c ps aux | grep gmondtest     27621  0.0  0.0  10720  2276 ?        S    09:05   0:00 grep gmond[2] 00:00:01 [SUCCESS] test@192.168.56.103ganglia  25710  0.0  0.0  57536  3396 ?        Ssl  May23   0:20 /usr/sbin/gmond --pid-file /var/run/gmond.pidtest     27622  0.0  0.0  11376  2800 ?        Ss   09:05   0:00 bash -c ps aux | grep gmondtest     27645  0.0  0.0  10720  2276 ?        S    09:05   0:00 grep gmond

2、参考grep命令最经常使用的功能总结，编写脚本checkganglia.sh
#!/bin/bashDATE=`date +%Y%m%d`filename="ganglia-$&#123;DATE&#125;.log"hosts=`grep test@ /tmp/log/ganglia/$&#123;filename&#125; | wc -l`pids=`grep gmond.pid /tmp/log/ganglia/$&#123;filename&#125; | wc -l`if [ $&#123;hosts&#125; == $&#123;pids&#125; ]then    echo "All services are runing!"else    echo "Error occurred!" &gt; /tmp/log/ganglia/error-$&#123;DATE&#125;.logfi

3、执行chmod a+x checkganglia.sh
./checkganglia.sh
如果所有客户机的ganglia运行正常，就会输出All services are runing!。如果有的客户机ganglia进程不存在，则会在/tmp/log/ganglia/目录下生成当天的错误日志。
4、设置定时运行因为日志的检查工作要在日志生成之后，所以时间上延后十分钟。
10 0 * * * /bin/bash /home/test/checkganglia.sh

脚本进阶上面的脚本，还有很多要改进的地方。比如有的客户机宕机了，上面的脚本检查不出来。比如有的客户机ganglia服务没有启动，那么具体是哪几台？针对这两个问题，下面进行改进。假设已经知道客户机的数量为10。
参考csplit命令，checkganglia.sh脚本修改为：
#!/bin/bashDATE=`date +%Y%m%d`filename="ganglia-$&#123;DATE&#125;.log"prefix="ganglia-$&#123;DATE&#125;"hosts=`grep test@ /tmp/log/ganglia/$&#123;filename&#125; | wc -l`pids=`grep gmond.pid /tmp/log/ganglia/$&#123;filename&#125; | wc -l`if [ $&#123;hosts&#125; != 10 ]then    echo "Some hosts are offline!" &gt;&gt; /tmp/log/ganglia/error-$&#123;DATE&#125;.logfiif [ $&#123;hosts&#125; != $&#123;pids&#125; ]then    echo "Some ganglia services have stopped!" &gt;&gt; /tmp/log/ganglia/error-$&#123;DATE&#125;.log    cd /tmp/log/ganglia/    csplit /tmp/log/ganglia/$&#123;filename&#125; /test@/ -n2 -s &#123;*&#125; -f $&#123;prefix&#125; -b ".log.%02d"    rm $&#123;prefix&#125;.log.00    for file in /tmp/log/ganglia/$&#123;prefix&#125;.log.*    do     if [ -f "$&#123;file&#125;" ]    then        #echo "$&#123;file&#125; is file"        if [ `grep gmond.pid $&#123;file&#125; | wc -l` == 0 ]        then            echo `grep test@ $&#123;file&#125;` &gt;&gt; /tmp/log/ganglia/error-$&#123;DATE&#125;.log        fi    fi    donefi

以上脚本，实现了当客户机数量不为10的时候，进行报错；当客户机ganglia服务没有启动时，进行报错，并且筛选出所有没有启动ganglia的客户机。
后记本文中，我们先学习了crontab的基础知识和基本用法。然后通过监控ganglia这一个应用场景来具体学习crontab的详细使用方法，包括查看cron日志的方法，crontab中命令转义的方法，定时执行脚本的方法，以及审阅日志脚本的编写和进阶。
至此，还不够完美，因为我们需要每天登录管理机查看有没有错误日志。下一篇Linux设置邮件提醒中，我们将会研究linux设置邮件提醒的方法。审阅完日志后，如果脚本能够给我们发送一封邮件，告知我们审阅的结果，那么我们就不必再每天查看错误日志。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
        <tag>crontab</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux配置SNAT上网</title>
    <url>/dev-linux-snat/</url>
    <content><![CDATA[前言一个局域网中，主机之间互联，其中只有一台主机可以上网，其他主机想要上网怎么办？答：使用SNAT。
情景模拟有主机A，eth0的IP为内网IP：192.168.56.101，eth1为公网IP：120.77.36.222。有主机B，eth0的IP为内网IP：192.168.56.102。
主机A可以访问外网，主机B和主机A在同一个局域网。下面我们进行配置，让主机B也可以上网。


数据包流向发送数据包B发送数据包时，A也就是NAT主机，分析数据包表头，将此数据包转到可以连接公网的IP上去。由于私有IP与公有IP不能互通，A会通过iptables的NAT table内的Postrounting链将数据包表头伪装成A的公网IP，并且将这两个不同来源的数据包对应关系写入暂存内存中，然后将数据包传送出去。此时传到互联网的这个数据包，已经表现为来自公网IP，而非来自局域网。
接收响应包当互联网把数据响应给B时，会首先进入NAT主机A，A分析数据包的序号，对比刚刚记录到内存中的数据，由于发现该数据包为后端主机之前传送出去的，因此在NAT Prerouting链中，会将目标IP修改成为后端主机，即B的IP，然后发现目标已经不是A的公网IP，开始通过路由分析，将数据包传送到A的局域网接口，再传送到最终目标192.168.56.102上去。
iptables小班snat的配置，主要用到iptables命令，之前在《CentOS7中firewall的使用》简单提过iptables，今天再认真学习一下。
主要参考文档：Basic iptables howtoiptables详解ipatebles详解（1）：iptales概念iptables命令25个iptables常用示例Linux防火墙iptables学习笔记（三）iptables命令详解和举例 
历史防火墙，其实说白了讲，就是用于实现Linux下访问控制的功能的，它分为硬件的或者软件的防火墙两种。无论是在哪个网络中，防火墙工作的地方一定是在网络的边缘。而我们的任务就是需要去定义到底防火墙如何工作，这就是防火墙的策略，规则，以达到让它对出入网络的IP、数据进行检测。
iptables的前身叫ipfirewall （内核1.x时代），这是一个作者从freeBSD上移植过来的，能够工作在内核当中的，对数据包进行检测的一款简易访问控制工具。但是ipfirewall工作功能极其有限（它需要将所有的规则都放进内核当中，这样规则才能够运行起来，而放进内核，这个做法一般是极其困难的）。当内核发展到2.x系列的时候，软件更名为ipchains，它可以定义多条规则，将他们串起来，共同发挥作用，而现在，它叫做iptables，可以将规则组成一个列表，实现绝对详细的访问控制功能。
原理五个关卡iptables工作在用户空间中，是定义规则的工具，本身并不算是防火墙。它定义的规则，可以让内核空间中的netfilter来读取，并且实现让防火墙工作。netfilter的架构就是在整个网络流程的若干位置设置一些关卡（HOOK），而在每个关卡上登记了一些规则，所以这些关卡的术语规则链。
在内核空间中，netfilter选择了5个位置，来作为控制的关卡，专业点叫做规则链。朱双印大神的博客中给出了直观的图像：
根据上图，我们能够想象出某些常用场景中，报文的流向：到本机某进程的报文：PREROUTING –&gt; INPUT由本机转发的报文：PREROUTING –&gt; FORWARD –&gt; POSTROUTING由本机的某进程发出报文（通常为响应报文）：OUTPUT –&gt; POSTROUTING
五个规则链的作用如下：INPUT链：处理输入数据包。OUTPUT链：处理输出数据包。PORWARD链：处理转发数据包。PREROUTING链：用于目标地址转换（DNAT）。POSTOUTING链：用于源地址转换（SNAT）。
表的概念我们再想想另外一个问题，我们对每个”链”上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。
我们把具有相同功能的规则的集合叫做”表”，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，所以，学习iptables之前，我们必须先搞明白每种表的作用。iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下”表”：

filter表：负责过滤功能，防火墙；内核模块：iptables_filter
nat表：network address translation，网络地址转换功能；内核模块：iptable_nat
mangle表：拆解报文，做出修改，并重新封装的功能；iptable_mangle
raw表：关闭nat表上启用的连接追踪机制；iptable_raw

也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张”表”中。
数据包流向可以将数据包通过防火墙的流程总结为下图：我们在写iptables规则的时候，要时刻牢记这张路由次序图，灵活配置规则。
规则规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理。规则由匹配条件和处理动作组成。
匹配条件分为基本匹配条件与扩展匹配条件：基本匹配条件包括源地址Source IP和目标地址 Destination IP。
扩展匹配条件包括源端口Source Port，目标端口Destination Port等等。
动作也可以分为基本动作和扩展动作，此处列出一些常用动作：ACCEPT：允许数据包通过。DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。DNAT：目标地址转换，解决外网用户访问内网的问题。REDIRECT：在本机做端口映射。LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。
命令详解命令格式：iptables [选项] [参数]
选项包括：
-t：指定要操纵的表；-A：向规则链中添加条目；-D：从规则链中删除条目；-I：向规则链中插入条目；-R：替换规则链中的条目；-L：显示规则链中已有的条目；-F：清楚规则链中已有的条目；-Z：清空规则链中的数据包计算器和字节计数器；-N：创建新的用户自定义规则链；-P：定义规则链中的默认目标；-h：显示帮助信息；-p：指定要匹配的数据包协议类型；-s：指定要匹配的数据包源ip地址；-d：指定要匹配的数据包目标ip地址；-j：指定要跳转的目标；-i：指定数据包进入本机的网络接口（网卡）；-o：指定数据包离开本机的网络接口（网卡）；--sport：匹配来源端口号；--dport：匹配目标端口号。

命令选项输入顺序：iptables -t 表名 &lt;-A/I/D/R&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作
实例1、清除已有iptables规则
iptables -Fiptables -Xiptables -Z

2、开放指定的端口
iptables -A INPUT -s 127.0.0.1 -d 127.0.0.1 -j ACCEPT               #允许本地回环接口(即允许本机访问本机)iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT    #允许已建立的或相关连的通行iptables -A OUTPUT -j ACCEPT         #允许所有本机向外的访问iptables -A INPUT -p tcp --dport 22 -j ACCEPT    #允许访问22端口iptables -A INPUT -p tcp --dport 80 -j ACCEPT    #允许访问80端口iptables -A INPUT -p tcp --dport 21 -j ACCEPT    #允许ftp服务的21端口iptables -A INPUT -p tcp --dport 20 -j ACCEPT    #允许FTP服务的20端口iptables -A INPUT -j REJECT       #禁止其他未允许的规则访问iptables -A FORWARD -j REJECT     #禁止其他未允许的规则访问

3、屏蔽IP
iptables -I INPUT -s 123.45.6.7 -j DROP       #屏蔽单个IP的命令iptables -I INPUT -s 123.0.0.0/8 -j DROP      #封整个段即从123.0.0.1到123.255.255.254的命令iptables -I INPUT -s 124.45.0.0/16 -j DROP    #封IP段即从123.45.0.1到123.45.255.254的命令iptables -I INPUT -s 123.45.6.0/24 -j DROP    #封IP段即从123.45.6.1到123.45.6.254的命令是

4、查看已添加的iptables规则iptables -L -n -v
5、删除已添加的iptables规则将所有iptables以序号标记显示，执行：iptables -L -n --line-numbers
比如要删除INPUT里序号为8的规则，执行：iptables -D INPUT 8
snat具体配置主机A接收数据包允许接收局域网网卡的数据包sudo iptables -I INPUT -i eth0 -j ACCEPT
或者sudo iptables -P INPUT ACCEPT
开启路由功能sudo echo 1 &gt; /proc/sys/net/ipv4/ip_forward如果报错：-bash: /proc/sys/net/ipv4/ip_forward: Permission denied那就切换到root用户：sudo -iecho 1 &gt; /proc/sys/net/ipv4/ip_forward
要想永久有效，还要把/etc/sysctl.conf文件里边的net.ipv4.ip_forward的值改为1。
伪装数据包sudo iptables -t nat -A POSTROUTING -s 192.168.56.102 -o eth1 -j MASQUERADE
或者用SNAT直接修改IP数据包的表头来源IPsudo iptables -t nat -A POSTROUTING -s 192.168.56.102 -o eth1 -j SNAT --to 192.168.56.101
如果需要支持整个网段：sudo iptables -t nat -A POSTROUTING -s 192.168.56.0/24 -o eth1 -j SNAT --to 192.168.56.101
如果需要支持连续IP：sudo iptables -t nat -A POSTROUTING -m iprange --src-range 192.168.56.102-192.168.56.104 -o eth1 -j SNAT --to 192.168.56.101
注意：

亲测以上所有命令中的-o eth1可以省略，所以，在分不清哪个网卡是内网哪个网卡是外网的情况下，直接省略即可。
如果想要允许所有IP，-s 192.168.56.0/24也可以省略。
-j SNAT --to 192.168.56.101可以换成-j SNAT --to 120.77.36.222。
-j SNAT --to 120.77.36.222建议换成-j MASQUERADE，尤其在外网IP非固定的情况下。
综上，最简单的万能SNAT命令为sudo iptables -t nat -A POSTROUTING -j MASQUERADE

查看与删除查看NAT表链规则sudo iptables -t nat -nL --line-number
删除POSTROUTING第一条规则sudo iptables -t nat -D POSTROUTING 1
重启后依旧生效1、保存规则sudo chmod a+w -R /optsudo iptables-save &gt; /opt/iptables.rules
2、手动导入规则sudo iptables-restore &lt; /opt/iptables.rules
3、开机自动导入规则在ubuntu下要把一个程序加入开机启动，一般可以通过修改rc.local来完成，但ubuntu下有两个rc.local文件，分别是/etc/rc.local和/etc/init.d/rc.local。因为/etc/init.d/rc.local调用了/etc/rc.local，所以我们的开机脚本最好直接写入/etc/rc.local，写在exit 0之前即可。
sudo vim /etc/rc.local在exit 0之前添加：
/sbin/iptables-restore &lt; /opt/iptables.rules

主机Bcentos如果是centos，那么配置ifcfg文件sudo vim /etc/sysconfig/network-scripts/ifcfg-eth0
DEVICE=eth0BOOTPROTO=staticONBOOT=yesIPADDR=192.168.56.102NETMASK=255.255.255.0GATEWAY=192.168.56.101

然后service network restart
ubuntu如果是ubuntu，那么配置interfaces文件sudo vim /etc/network/interfaces
auto loiface lo inet loopbackauto em1iface em1 inet staticaddress 192.168.56.102netmask 255.255.255.0gateway 192.168.56.101

然后sudo /etc/init.d/networking restart
总之，B主机配置的关键在于网关，网关要设置成主机A的内网IP。
请问，网关不设置成主机A的内网IP可以吗？可以，那就是另外一种稍微复杂的设置方法了。
此时，使用主机B，已经可以ping通外网的IP了。但是ping域名会提示“ping: unknown host”。
DNS配置方法一1、编辑resolv.confsudo vim /etc/resolv.conf，添加nameserver的配置
nameserver 180.76.76.76nameserver 223.6.6.6
上面的两个IP地址，分别是百度和阿里的公共DNS。
2、测试ping www.baidu.com
3、不过，这种方法在重启之后会失效。想要永久生效，还需要编辑base文件。sudo vim /etc/resolvconf/resolv.conf.d/base，添加：
nameserver 180.76.76.76nameserver 223.6.6.6


方法二1、编辑interfacessudo vim /etc/network/interfaces
2、添加nameserver的配置
dns-nameserver 180.76.76.76 223.5.5.5

3、重启服务器sudo reboot实际上，重启后的dns配置会写入到resolv.conf中。
4、测试ping www.baidu.com
结语至此，snat完美配置成功！在这个过程中，顺带学习了一下iptables，收获满满。感觉iptables和route有很大关系，但是在配置过程中没有用到route。书签中有关于route的文档，用到的时候再深入学习。
书签Linux下配置SNAT上网
利用iptables的SNAT功能实现局域网共享上网
linux 路由表设置之 route 指令详解
ubuntu配置静态路由及重启生效
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>linux</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown编辑器</title>
    <url>/dev-markdown-editor/</url>
    <content><![CDATA[前言假设现在要写一篇markdown格式文章，使用什么编辑器比较好？答：sublime或者typora。
假设现在要把一篇markdown格式文章导出成pdf文档，使用什么编辑器比较好？答：typora。
假设现在要把一篇markdown格式文章发布成微信公众号文章，使用什么编辑器比较好？答：wechat-format。
本文主要介绍三款 markdown 编辑器，分别是 sublime、typora和wechat-format。此外，还会介绍几个在线markdown编辑器，测试和预览都很方便。


sublime.md 结尾的文件，在使用 sublime 进行编辑时会自动语法高亮。之所以推荐sublime，是因为这个编辑器是个万能的编辑器，而且非常轻量。使用了六年了，依然情有独钟。
typora简介typora是近两年崛起的markdown编辑器神器。传统的markdown编辑器，左边是编辑器，右边是预览。typora另辟蹊径，没有左右分开，而是把编辑和预览结合在一起，随时切换（command+/），更可以在预览时进行编辑。
自定义主题typora提供各种主题，更是支持用户自定义主题，简单好用。下面我们按照自己的需求来定制主题，熟悉一下自定义主题的流程。
已知需求为：

github主题自己很喜欢，但是标题字号太大，想要改小一点。
标题在显示的时候自动编号。

1、Typora，偏好设置，外观，打开主题文件夹
2、备份github.css为github.css.bak
3、编辑github.css，修改字号
h1 &#123;    font-size: 1.5em;    line-height: 1.2;    border-bottom: 1px solid #eee;&#125;h2 &#123;    font-size: 1.25em;    line-height: 1.225;    border-bottom: 1px solid #eee;&#125;h3 &#123;    font-size: 1.15em;    line-height: 1.43;&#125;h4 &#123;    font-size: 1.05em;&#125;h5 &#123;    font-size: 1em;&#125;h6 &#123;   font-size: 1em;    color: #777;&#125;

4、编辑github.css，给标题前添加自动编号
/* 标题自动编号 */body &#123; counter-reset: h1counter; &#125;h1 &#123; counter-reset: h2counter; &#125;h2 &#123; counter-reset: h3counter; &#125;h3 &#123; counter-reset: h4counter; &#125;h4 &#123; counter-reset: h5counter; &#125;h5 &#123; counter-reset: h6counter; &#125;h6 &#123; &#125;h1:before &#123;  counter-increment: h1counter;  content: counter(h1counter) ".\0000a0\0000a0";&#125;h2:before &#123;  counter-increment: h2counter;  content: counter(h1counter) "."            counter(h2counter) ".\0000a0\0000a0";&#125;h3:before &#123;  counter-increment: h3counter;  content: counter(h1counter) "."            counter(h2counter) "."            counter(h3counter) ".\0000a0\0000a0";&#125;h4:before &#123;  counter-increment: h4counter;  content: counter(h1counter) "."            counter(h2counter) "."            counter(h3counter) "."            counter(h4counter) ".\0000a0\0000a0";&#125;h5:before &#123;  counter-increment: h5counter;  content: counter(h1counter) "."            counter(h2counter) "."            counter(h3counter) "."            counter(h4counter) "."            counter(h5counter) ".\0000a0\0000a0";&#125;h6:before &#123;  counter-increment: h6counter;  content: counter(h1counter) "."            counter(h2counter) "."            counter(h3counter) "."            counter(h4counter) "."            counter(h5counter) "."            counter(h6counter) ".\0000a0\0000a0";&#125;

5、重启typora可见标题字号变小了，同时添加了编号。但是，如果直接复制粘贴内容到微信公众号，这些标题编号不会被复制。而且，换行效果也没有了。因此，从typora直接复制粘贴到微信公众号，不是一个好的方案。
导出pdf文件，导出，PDF。如上，typora导出的pdf文档，简直完美。
wechat-format简介wechat-format最大的优点是：适应微信公众号。比如，微信不支持外链，wechat-format生成的预览会包含 reference。但是，标题居中效果不是我想要的，标题也没有自动编号，所以也需要自定义一下。
自定义主题下载wechat-format源码，主要修改：

src/assets/scripts/themes/default.js
src/assets/scripts/renderers/wx-renderer.js
src/assets/css/app.css

修改后的代码参考 wechat-format，最终效果如下
失败的尝试但是，修改完成之后，复制粘贴到微信公众号，这些标题编号依然不会被复制。那么，怎样才能复制到这些编号？答：使这些编号变成元素，而不是样式。所以，需要使用js给页面添加编号元素。代码如下：
// https://www.cnblogs.com/qiudeqing/p/3229583.htmlfunction number()&#123;    var headings;    if (document.querySelectorAll)        headings = document.querySelectorAll("h1,h2,h3,h4,h5,h6");    else        headings = findHeadings(document.body, []);    function findHeadings(root, sects) &#123;        for(var c = root.firstChild; c != null; c = c.nextSibling) &#123;            if (c.nodeType !== 1) continue;            if (c.tagName.length == 2 &amp;&amp; c.tagName.charAt(0) == "H")                sects.push(c);            else                findHeadings(c, sects);        &#125;        return sects;    &#125;    var sectionNumbers = [0,0,0,0,0,0];    for(var h = 0; h &lt; headings.length; h++) &#123;        var heading = headings[h];        var level = parseInt(heading.tagName.charAt(1));        if (isNaN(level) || level &lt; 1 || level &gt; 6) continue;        sectionNumbers[level-1]++;        for(var i = level; i &lt; 6; i++) sectionNumbers[i] = 0;        var sectionNumber = sectionNumbers.slice(0,level).join(".") + ". ";        var span = document.createElement("span");        span.className = "TOCSectNum";        span.innerHTML = sectionNumber;        heading.insertBefore(span, heading.firstChild);    &#125;&#125;

但是，想要把这个代码应用到wechat-format，是有难度的，假期搞了一天，最终效果不理想，暂时放弃。思路：修改 src/assets/scripts/editor.js ，把number函数改写到这个文件里。中间会用到dom转str和str转dom，代码附上。
// https://developer.mozilla.org/zh-CN/docs/Web/API/DOMParser// https://developer.mozilla.org/zh-CN/docs/XMLSerializerfunction trans(str)&#123;      var parser = new DOMParser();    var doc=parser.parseFromString(str, "text/xml");    doc = number(doc);    var s = new XMLSerializer();    return s.serializeToString(doc);&#125;

在线markdown编辑器mdniceMarkdown Nice是一个支持自定义样式的 Markdown 编辑器，支持导出成微信公众号文章和知乎文章。
值得一提的是，mdnice导出的微信公众号文章，排版非常nice，比 wechat-format 还要美观。尝试了自定义样式，添加了标题编号，同样无法复制到微信公众号。
openwriteOpenWrite是一个博客群发平台，支持一键发文到微信公众号、知乎、头条、博客园、CSDN等平台。其中一项功能是Markdown格式文章导出微信公众号预览。
Cmd MarkdownCmd Markdown是一个用了很多年的在线markdown编辑器，稳定靠谱，支持高亮代码块、LaTeX 公式、流程图。
马克飞象马克飞象是一款专为印象笔记（Evernote）打造的Markdown编辑器，支持高亮代码块、LaTeX 公式、流程图，本地图片以及附件上传。马克飞象同时提供桌面客户端以及离线Chrome App，支持移动端 Web。
StackEditStackEdit支持google登录，发布文章到web（github、gitlab、wordpress等），支持高亮代码块、LaTeX 公式、流程图。
]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>编辑器</tag>
        <tag>sublime</tag>
        <tag>typora</tag>
        <tag>wechat-format</tag>
      </tags>
  </entry>
  <entry>
    <title>matlab入门</title>
    <url>/dev-matlab-start/</url>
    <content><![CDATA[前言
MATLAB是美国MathWorks公司出品的商业数学软件，用于算法开发、数据可视化、数据分析以及数值计算的高级技术计算语言和交互式环境，主要包括MATLAB和Simulink两大部分。

读研以来，耳边不时听到“matlab”，被老师和同学普遍推崇。今天，郝同学就来学习一下matlab的基础操作。


基础设置显示类型计算圆面积时，面积的结果显示，默认是short类型（保留小数点后4位），我们可以通过设置为long类型，来显示更精确的结果。1）通过命令设置format long，这种设置方式临时性的。
2）通过界面设置File，Preferences，Command Window，Numeric format选择long，之后Apply即可。
清屏清屏命令：clc
清数据清数据命令：clear
修改变量在workspace中，双击变量，可以在图形化界面修改变量值。
绘图在workspace中，单击变量，然后点击plot。
查看变量信息who，whos，whos a
重新执行命令在command history中，找到一条命令，右键选择evaluate selection。
保存变量save a，保存变量到当前工作路径，文件名为a.mat。
加载数据文件load a或者load a.mat。
编辑器窗口edit，打开编辑窗口，新建matlab程序。
图像窗口figure
GUI窗口guide
添加搜索路径File，Set Path，Add Folder。
设置初始路径右键matlab快捷方式，在快捷方式选项卡中，修改起始位置。
查找函数路径which sin
设置默认编码中文时，Matlab默认编码格式为GB2312。使用sublime打开文件，显示乱码，郝同学想把Mablab默认编码修改为UTF-8。
1、在Matlab安装目录下的bin目录下（例如D:\Program Files\MATLAB\R2010b\bin），找到lcdata.xml文件。
2、在matlab中，输入命令feature(&#39;locale&#39;)，查看当前使用的编码。
3、编辑lcdata.xml，找到如下一段：
&lt;locale name="zh_CN" encoding="GB2312" xpg_name="zh_CN.GB2312"&gt;    &lt;alias name="zh-Hans"/&gt;&lt;/locale&gt;

修改为：
&lt;locale name="zh_CN" encoding="UTF-8" xpg_name="zh_CN.UTF-8"&gt;    &lt;alias name="zh-Hans"/&gt;&lt;/locale&gt;

然而，修改后重启，matlab依然使用GBK编码。而且，把.m文件转换成UTF-8格式后，Matlab中会出现乱码。
无奈，从另一个方面入手，让sublime支持GBK编码文件，安装插件ConvertToUTF8即可。
Matlab语言基础变量和常量matlab遵循弱类型语言的变量初始化和赋值语法，和python基本相同。
输入数据x = input(&#39;请输入数据&#39;)，输入数据后，数据存入x。
默认赋值如果输入数值，没有赋值给变量，那么默认赋值给内置的ans变量。
基本数据结构输入行矩阵a = [1 2 3]或a = [1,2,3]
输入列矩阵b = [1 2 3]&#39;或b = [1,2,3]&#39;或b = [1;2;3]
输入2*2矩阵c = [1 2; 3 4]
输入特定值矩阵d(2,3) = 8，生成2*3的矩阵，第二行第三列的元素为8，其他元素为0。
内置函数生成矩阵ones(4)，生成4*4的矩阵，所有元素为1。
ones(4,3)，生成4*3的矩阵，所有元素为1。
zeros(4)，生成4*4的矩阵，所有元素为0。
zeros(4,3)，生成4*3的矩阵，所有元素为0。
eye(4)，生成4*4的单位矩阵。
eye(4,3)，生成4*3的矩阵，前三行前三列组成单位矩阵，第四行为0。
magic(4)，生成4*4的魔方数组。
冒号表达式生成矩阵3:9，生成3到9的行向量，增量为1。
3:2:9，生成3到9的行向量，增量为2。
(3:9)&#39;，生成3到9的列向量，增量为1。
读取矩阵数据a = [1 2 3]，a(2)，读取第二个数据。
c = [1 2; 3 4]，c(1,2)，读取第一行第二列的数据。
c(:,2)，读取二列的数据。
c(1,:)，读取第一行的数据。
k = [1 2 3;4 5 6;7 8 9;10 11 12]，k(2:4,2)，读取第二列中第二行到第四行的数据。
拼接矩阵m = [c,c]，横向拼接两个c矩阵。
n = [c:c]，纵向拼接两个c矩阵。
矩阵函数size(n)，返回行列数。
length(n)，返回行数和列数中的较大者。
空数组和子数组空数组nullmatrix = []，创建空数组。
子数组magicmatrix = magic(4)，child = magicmatrix(3,[2,4])
child = magicmatrix(3,2:end)
magicmatrix(3,2) = 3，单个元素赋值。
等差数列linspace(1,99,50)，生成1到99的50个数，等差为2。
等比数列logspace(1,3,3)，生成10 100 1000三个数。
数组变形1:1:9，reshape(ans,3,3)，按列排列变形成为方数组。
时间变量data，clock，year(now)，month(now)，day(now)，day(today)
算术运算符标量运算正常加减乘除，和python基本相同。需要注意的是5/6代表5除以6，5\6代表6除以5。
5^2和power(5,2)都是代表5的平方。
矩阵运算A=[1 2 3; 4 5 6; 7 8 9]，B=magic(3)
A+B，A-B，A*B，A+3，A*3
inv(B)，求B矩阵的逆矩阵。
A/B和A*inv(B)相同。
A.*B，对应位置相乘。
运算函数matlab的运算函数包括幂次方、指数与对数函数、三角与反三角函数等等。
幂次方幂次方的符号就是常用的^记号。指数部分可以是任意数。2^2，2^(-1)，2^(1/2)，2^(1.25) 
指数与对数科学与工程领域惯用「标准指数函数」，也就是以e为底的指数函数。其中，e是一个无理数，大约等于2.71828。Matlab并不提供e这个常数，而是以函数exp()来计算以e为底的指数函数。exp(1)
Matlab 分别提供三个函数 log()、log10()和log2()，分别表示以e为底的对数（自然对数），以10为底的对数（常用对数），以2为底的对数。log(exp(2))，log10(100)，log2(4)，答案都是2。
三角与反三角函数六个三角函数在Matlab 中对应的函数分别为：正弦：sin()余弦：cos()正切：tan()余切：cot()正割：sec()余割：csc()
六个反三角函数在Matlab 中对应的函数分别为：反正弦：asin()反余弦：acos()反正切：atan()反余切：acot()反正割：asec()反余割：acsc()
需要注意的就是使用三角函数时，角度的单位是“弧度”。
复数Matlab 的所有运算符号、所有函数，都懂得如何做复数计算。sqrt(-1)
abs(3+4i)
微积分极限求极限是微积分的基础，求极限的函数limit。limit(f,x,a)，x趋近于a时，f 的极限。limit(f,x,a,&#39;left&#39;)，x左趋近于a时，f 的极限。limit(f,x,a,&#39;right&#39;)，x右趋近于a时，f的极限。
微分diff(f,t,n)，求f 对独立变量t的n次微分值。
积分int(f,&#39;t&#39;,a,b)，求f 对独立变量t 在积分区间[a，b]的积分值。
级数自变量v在[a，b]之间取值时，对通项s求和，用函数symsum(s,v,a,b)。
方程求解代数方程solve(f)
solve(f,a)
常微分方程dsolve(&#39;常微分方程式&#39;,&#39;初始条件&#39;,&#39;自变量&#39;)
可视化二维平面图形折线图plot(x,y)函数，x，y是维度相同的序列或向量。
x=[0 1 2];y=[0 1 0];plot(x,y);

用300段折线画出sin(x)在[-pi,pi]区间内的折线图。
x = linspace(-pi, pi, 301);plot(x, sin(x));

如果要画多条曲线，也可以用plot函数。
x=0:pi/10:2*pi;y1=sin(x);y2=cos(x);plot(x,y1,x,y2);plot(x,y1,'r + -',x,y2,'k * :');
图形是以公共的x元素为横坐标值，y1、y2为纵坐标值绘制曲线图的。如果想要图形更加完美，我们可以用一些特殊的图形函数对它进行修饰。
xlabel('独立变量X');ylabel('变量Y');title('正弦和余弦曲线');text(1.5,0.3,'cos(x)');text(0,0,'sin(x)');%axis([0 2*pi -0.9 0.9]);

如果只给plot()一个参数，例如plot(y)，而y是一个n维向量或列，则它的效果就相当于plot((1:n), y)。
y = [ 1 4 0 2 3 5];plot(y);

多重折线图Matlab在一张图片上可以重复制图。基本上，画一张图的指令，将会自动清除前一张图。但是，如果下了指令hold on，将不会清除前一张图，而是重复画上去。下了hold on指令的所有图将会重迭在一张图片里，直到你下了hold off为止。
我们以 300 个折线段，在一张图片中，画出以下三个函数在[-pi, pi]区间内的曲线图：sin(x)，cos(x)，x。
x = linspace(0, 2*pi, 301);y = sin(x);plot(x, y, 'r');axis([0 2*pi -1.2 1.2]);hold ony = cos(x);plot(x, y, 'g');y = x; plot(x, y, 'b');hold off;

我们还可以采用图形窗口分割的方法，在同一个视图窗口中画出多个小图形。这时要用到subplot(n,m,k)。如果写subplot(2,2,1),即就是把图形窗口分割成2行2列，在第1个位置（第1行第1列）画图。
x = linspace(0, 2*pi, 301);y = sin(x);subplot(2,2,1);plot(x, y);y = cos(x);subplot(2,2,2);plot(x, y);
Matlab对数据是按列存储和计算的。
三维立体图形三维曲线图plot3函数调用格式：plot3(x1,y1,z1,x2,y2,z2,…)。其中x1，y1，z1，x2，y2，z2…等分别为维数相同的向量，分别存储着曲线的三个坐标值。
绘制方程在t=[0,2π]的空间方程。
\begin{cases}x=t \y=sin(t) \z=cos(t)\end{cases}
t=0:pi/10:2*pi;x=t;y=sin(t);z=cos(t);plot3(x,y,z,'r:p');grid on;xlabel('X');ylabel('Y');zlabel('Z');title('sine and cosine');

三维网格图和曲面图Matlab在绘制三维网格图与曲面图时，往往先将要绘制图形的定义区域分成若干网格，然后计算这些网格节点上的二元函数值，最后才能使用mesh和surf函数绘制相应的图形。生成网格矩阵使用meshgrid函数，其调用格式为：
[U, V]=meshgrid(x,y)

函数说明：利用向量x和y生成网格矩阵U和V，以便mesh和surf等函数用来绘图。其中x、y分别是长度为n和m升序排列的行向量。
生成的方法是将x复制n次生成网格矩阵U，将y转置成列向量后复制m次生成网格矩阵V。坐标(uij,vij)表示xoy平面上网格节点的坐标，第三维坐标zij=f(uij,vij)。
例：给定向量x=[1 2 3 4]，y=[10 11 12 13 14]，试由向量x、y生成网格矩阵。
x=[1 2 3 4]; %输入向量xy=[10 11 12 13 14]; %输入向量y[U,V]=meshgrid(x,y); %生成网格矩阵Z=peaks(U,V);mesh(U,V,Z); %绘制三维网格图

Matlab提供了一个peaks函数，可产生一个凹凸有致的曲面，包含了三个局部极大点及三个局部极小点。在matlab中输入peaks()、peaks(5)就可以看到效果。
例：在 -4&lt;x&lt;4，-4&lt;y&lt;4 上绘制 $z=x^2+y^2$ 的三维网格图。
[x,y]=meshgrid(-4:4, -4:4); %定义网格数据向量x,yz=x.^2+y.^2; %计算二元函数值mesh(x,y,z); %绘制三维网格图% surf(x,y,z); %绘制三维曲面图

观察点函数view(azinmuth,elevation)azinmuth：方位角。观察点与坐标原点的连线在水平面上的投影和y轴负方向的夹角。（在水平面上）elevation：仰角。观察点与坐标原点的连线和水平面的夹角。（与水平面垂直）
使用循环和观察点设定来实现动画效果。
Matlab程序设计命令文件Matlab提供两种源程序文件格式：命令文件和函数文件。这两种文件的扩展名相同，均为“.m”，又称为“M文件”。命令文件的执行方式：在提示符后键入命令文件的文件名。命令文件适合于用户做需要理解得到结果的小规模运算。
函数文件函数文件由function语句引导。其格式为：
function [返回变量列表]=函数名(输入变量列表)

1、新建一个求阶乘的函数文件myFunc.m：
function value = myFunc(n);if n&lt;=1    value = 1;else    value = myFunc(n-1)*n;end

2、重写求阶乘的函数文件myFunc2.m：
function value = myFunc2(n);value = 1;while n &gt; 1    value = value*n;    n = n - 1;end

3、重写求阶乘的函数文件myFunc3.m：
function value = myFunc3(n);value = 1;for i=1:1:n    value = value*i;end%for i=n:-1:1%    value = value*i;%end

4、新建传入数值显示结果的函数文件showNum.m：
function showNum(input_var);switch input_var    case 1        disp('1');    case &#123;2,3,4&#125;        disp('2 or 3 or 4');    case 5        disp('5');    otherwise        disp('something else');end

源码分享https://github.com/voidking/matlab-start.git
书签Matlab视频教程http://www.51zxw.net/list.aspx?cid=456
我的学习资料http://pan.baidu.com/s/1bp1oyXT
Mathjax与LaTex公式简介http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>matlab</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven之pom.xml</title>
    <url>/dev-maven-pom/</url>
    <content><![CDATA[pom.xml速览&lt;project&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;groupId&gt;...&lt;/groupId&gt;    &lt;artifactId&gt;...&lt;/artifactId&gt;    &lt;version&gt;...&lt;/version&gt;    &lt;packaging&gt;...&lt;/packaging&gt;    &lt;dependencies&gt;...&lt;/dependencies&gt;    &lt;parent&gt;...&lt;/parent&gt;    &lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;    &lt;modules&gt;...&lt;/modules&gt;    &lt;properties&gt;...&lt;/properties&gt;      &lt;build&gt;...&lt;/build&gt;    &lt;reporting&gt;...&lt;/reporting&gt;      &lt;name&gt;...&lt;/name&gt;    &lt;description&gt;...&lt;/description&gt;    &lt;url&gt;...&lt;/url&gt;    &lt;inceptionYear&gt;...&lt;/inceptionYear&gt;    &lt;licenses&gt;...&lt;/licenses&gt;    &lt;organization&gt;...&lt;/organization&gt;    &lt;developers&gt;...&lt;/developers&gt;    &lt;contributors&gt;...&lt;/contributors&gt;      &lt;issueManagement&gt;...&lt;/issueManagement&gt;    &lt;ciManagement&gt;...&lt;/ciManagement&gt;    &lt;mailingLists&gt;...&lt;/mailingLists&gt;    &lt;scm&gt;...&lt;/scm&gt;    &lt;prerequisites&gt;...&lt;/prerequisites&gt;    &lt;repositories&gt;...&lt;/repositories&gt;    &lt;pluginRepositories&gt;...&lt;/pluginRepositories&gt;    &lt;distributionManagement&gt;...&lt;/distributionManagement&gt;    &lt;profiles&gt;...&lt;/profiles&gt;  &lt;/project&gt;

POM包括了所有的项目信息：

groupId：项目或者组织的唯一标志，并且配置时生成的路径也是由此生成，如org.codehaus.mojo生成的相对路径为：/org/codehaus/mojo
artifactId：项目的通用名称
version：项目的版本
packaging：打包的机制，如pom, jar, maven-plugin, ejb, war, ear, rar, par
classifier：分类



POM关系依赖&lt;dependencies&gt;      &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.0&lt;/version&gt;        &lt;type&gt;jar&lt;/type&gt;        &lt;scope&gt;test&lt;/scope&gt;        &lt;optional&gt;true&lt;/optional&gt;      &lt;/dependency&gt;      ...  &lt;/dependencies&gt;


groupId, artifactId, version:描述了依赖的项目唯一标志
type:相应的依赖产品包形式，如jar，war
scope:用于限制相应的依赖范围，包括以下的几种变量：


compile ：默认范围，用于编译provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpathruntime:在执行时，需要使用test:用于test任务时使用system:需要外在提供相应得元素。通过systemPath来取得


systemPath: 仅用于范围为system。提供相应的路径
optional: 标注可选，当项目自身也是依赖时。用于连续依赖时使用

独占性外在告诉maven你只包括指定的项目，不包括相关的依赖。此因素主要用于解决版本冲突问题。
&lt;dependencies&gt;      &lt;dependency&gt;        &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;        &lt;artifactId&gt;maven-embedder&lt;/artifactId&gt;        &lt;version&gt;2.0&lt;/version&gt;        &lt;exclusions&gt;          &lt;exclusion&gt;            &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;            &lt;artifactId&gt;maven-core&lt;/artifactId&gt;          &lt;/exclusion&gt;        &lt;/exclusions&gt;      &lt;/dependency&gt; &lt;/dependencies&gt;
表示项目maven-embedder需要项目maven-core，但我们不想引用maven-core。
聚合为了能够使用一条命令就能构建account-email和account-persist两个模块，我们需要建立一个额外的名为account-aggregator的模块，然后通过该模块构建整个项目的所有模块。account-aggregator本身也是个 Maven项目，它的 POM如下
&lt;project&gt;	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;	&lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt;	&lt;artifactId&gt;account-aggregator&lt;/artifactId&gt;	&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;	&lt;packaging&gt; pom &lt;/packaging&gt;	&lt;name&gt;Account Aggregator&lt;/name&gt;	 &lt;modules&gt;		&lt;module&gt;account-email&lt;/module&gt;		&lt;module&gt;account-persist&lt;/module&gt;	 &lt;/modules&gt;&lt;/project&gt;

注意：packaging的类型为pom ，module的值是一个以当前POM为主目录的相对路径。
继承父模块配置&lt;project&gt;	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;	&lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt;	&lt;artifactId&gt; account-parent &lt;/artifactId&gt;	&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;	&lt;packaging&gt;pom&lt;/packaging&gt;	&lt;name&gt;Account Parent&lt;/name&gt;		&lt;dependencyManagement&gt;...&lt;/dependencyManagement&gt;  &lt;/project&gt;



子模块配置&lt;project&gt;	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;		&lt; parent &gt;		&lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt;		&lt;artifactId&gt; account-parent &lt;/artifactId&gt;		&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;		&lt; relativePath &gt;../account-parent/pom.xml&lt;/ relativePath&gt;	&lt;/ parent &gt;		&lt;artifactId&gt; account-email &lt;/artifactId&gt;	&lt;name&gt;Account Email&lt;/name&gt;  ...&lt;/project&gt;

注意：1、子模块没有声明groupId和version，这两个属性继承至父模块。但如果子模块有不同与父模块的 groupId、version ，也可指定；2、不应该继承artifactId,如果groupId ，version，artifactId 完全继承的话会造成坐标冲突；另外即使使用不同的 groupId或version，同样的 artifactId也容易产生混淆。
聚合使用继承后，parent也必须像子模块一样加入到聚合模块中。也就是在在聚合模块的 pom中加入&lt;module&gt;account-parent&lt;/module&gt;。聚合的 POM如下：
&lt;project&gt;	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;	&lt;groupId&gt;com.juvenxu.mvnbook.account&lt;/groupId&gt;	&lt;artifactId&gt;account-aggregator&lt;/artifactId&gt;	&lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;	&lt;packaging&gt; pom &lt;/packaging&gt;	&lt;name&gt;Account Aggregator&lt;/name&gt;	&lt;modules&gt;		&lt;module&gt;account-email&lt;/module&gt;		&lt;module&gt;account-persist&lt;/module&gt;		&lt;module&gt; account-parent&lt;/module&gt;	&lt;/modules&gt;&lt;/project&gt;

可继承的元素groupId ：项目组 ID ，项目坐标的核心元素；version ：项目版本，项目坐标的核心元素；description ：项目的描述信息；organization ：项目的组织信息；inceptionYear ：项目的创始年份；url ：项目的 url 地址develoers ：项目的开发者信息；contributors ：项目的贡献者信息；distributionManagerment ：项目的部署信息；issueManagement ：缺陷跟踪系统信息；ciManagement ：项目的持续继承信息；scm ：项目的版本控制信息；mailingListserv ：项目的邮件列表信息；properties ：自定义的 Maven 属性；dependencies ：项目的依赖配置；dependencyManagement ：醒目的依赖管理配置；repositories ：项目的仓库配置；build ：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等；reporting ：包括项目的报告输出目录配置、报告插件配置等。

我们知道dependencies是可以被继承的，这个时候我们就想到让我们的发生了共用的依赖元素转移到parent中，这样我们又进一步的优化了配置。可是问题也随之而来，如果有一天我创建了一个新的模块，但是这个模块不需要这些parent的依赖，这时候如何处理？
是的，maven的依赖管理就是来解决这个问题的：dependencyManagement。从上面的列表中我们发现dependencyManagement也是可以被继承的，这恰恰满足了我们的需要，它既能够让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性。
dependencyManagement的特性：在dependencyManagement中配置的元素既不会给parent引入依赖，也不会给它的子模块引入依赖，仅仅是它的配置是可继承的。
最佳实践：这时候我们就可以在父POM中声明这些依赖：
&lt;properties&gt;	&lt;target.version&gt;2.5.6&lt;/target.version&gt;&lt;/properties&gt;&lt;dependencyManagement&gt;	&lt;dependencies&gt;		&lt;dependency&gt;			&lt;groupId&gt;your groupId&lt;/groupId&gt;			&lt;artifactId&gt;your artifactId&lt;/artifactId&gt;			&lt;version&gt;$&#123;target.version&#125;&lt;/version&gt;		&lt;/dependency&gt;	&lt;/dependencies&gt;&lt;/dependencyManagement&gt;

子模块的POM继承这些配置：子模块继承这些配置的时候，仍然要声明groupId和artifactId，表示当前配置是继承于父POM的，从而直接使用父POM的版本对应的资源。
&lt;dependencies&gt;	&lt;dependency&gt;		&lt;groupId&gt;your groupId&lt;/groupId&gt;		&lt;artifactId&gt;your artifactId&lt;/artifactId&gt;	&lt;/dependency&gt;&lt;/dependencies&gt;
这个可以有效的避免多个子模块使用依赖版本不一致的情况，有助于降低依赖冲突的几率。
注：只有子模块配置了继承的元素，才会真正的有效，否则maven是不会加载父模块中声明的元素。
pluginManagement和dependencyManagement相类似，它是用来进行插件管理的。
聚合和继承的关系区别 ：1、对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在。2、对于继承关系的父POM来说，它不知道有哪些子模块继承与它，但那些子模块都必须知道自己的父 POM是什么。
共同点 ：1.聚合 POM与继承关系中的父POM的packaging都是pom2.聚合模块与继承关系中的父模块除了 POM之外都没有实际的内容。注：在现有的实际项目中一个 POM既是聚合POM，又是父 POM，这么做主要是为了方便。
参考文档Maven POM
maven核心，pom.xml详解
maven 配置篇 之pom.xml(一）
史上最全的maven pom.xml文件教程详解
Maven聚合与继承
Maven详解之聚合与继承
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js学习笔记（二）</title>
    <url>/dev-nodejs-note-2/</url>
    <content><![CDATA[整理自：慕课网
伪造模板数据跑通前后端交互流程本篇博客用到的代码，小伙伴们直接复制粘贴就可以了，你们可知道郝同学一行行敲得多么辛苦T_T，复制粘贴前给个赞啊！
工程结构helloworld/  -bower_components/  -node_modules/  -views/    -includes/      -head.jade      -header.jade    -pages/      -index.jade      -detail.jade      -admin.jade      -list.jade    -layout.jade  -app.js

操作步骤我们在上次helloworld工程的基础上接着做！1、在views文件夹下新建文件夹includes和pages2、在views文件夹下，删除index.jade，新建layout.jade，输入内容：
doctypehtml	head		meta(charset="utf-8")		title #&#123;title&#125;		include ./includes/head	body		include ./includes/header		block content
3、在includes文件夹下，新建文件head.jade和header.jade，分别输入内容：
link(href="/bootstrap/dist/css/bootstrap.min.css",rel="stylesheet")script(src="/jquery/dist/jquery.min.js")script(src="/bootstrap/dist/js/bootstrap.min.js")
.container	.row		.page-header			h1 #&#123;title&#125;			small 天印电影
4、在pages文件夹下，新建文件index.jade、detail.jade、admin.jade和list.jade，分别输入内容：
extends ../layoutblock content	.container		.row			each item in movies				.col-md-2					.thumbnail						a(href="/movie/#&#123;item._id&#125;")							img(src="#&#123;item.poster&#125;",alt="#&#123;item.title&#125;")						.caption							h3 #&#123;item.title&#125;							p: a.btn.btn-primary(href="/movie/#&#123;item._id&#125;",role="button")								观看预告片
extends ../layoutblock content	.container		.row			.col-md-7				embed(src="#&#123;movie.flash&#125;",allowFullScreen="true",quality="high",width="720",height="500",align="middle",type="application/x-shock")			.col-md-5				dl.dl-horizontal					dt 电影名字					dd= movie.title					dt 导演					dd= movie.doctor					dt 国家					dd= movie.country					dt 语言					dd= movie.language					dt 上映年份					dd= movie.year					dt 简介					dd= movie.summary
extends ../layoutblock content	.container		.row			form.form-horizontal(method="post",action="/admin/movie/new")				.form-group					label.col-sm-3.control-label(for="inputTitle") 电影名字					.col-sm-10						input#inputTitle.form-control(type="text",name="movie[title]",value="#&#123;movie.title&#125;")				.form-group					label.col-sm-3.control-label(for="inputDoctor") 导演					.col-sm-10						input#inputTitle.form-control(type="text",name="movie[doctor]",value="#&#123;movie.doctor&#125;")				.form-group					label.col-sm-3.control-label(for="inputCountry") 国家					.col-sm-10						input#inputTitle.form-control(type="text",name="movie[country]",value="#&#123;movie.country&#125;")				.form-group					label.col-sm-3.control-label(for="inputLanguage") 语言					.col-sm-10						input#inputTitle.form-control(type="text",name="movie[language]",value="#&#123;movie.language&#125;")				.form-group					label.col-sm-3.control-label(for="inputYear") 上映年份					.col-sm-10						input#inputTitle.form-control(type="text",name="movie[year]",value="#&#123;movie.year&#125;")				.form-group					label.col-sm-3.control-label(for="inputSummary") 简介					.col-sm-10						input#inputTitle.form-control(type="text",name="movie[summary]",value="#&#123;movie.summary&#125;")										.form-group					label.col-sm-3.control-label(for="inputPoster") 海报地址					.col-sm-10						input#inputTitle.form-control(type="text",name="movie[poster]",value="#&#123;movie.poster&#125;")				.form-group					label.col-sm-3.control-label(for="inputFlash") 片源地址					.col-sm-10						input#inputTitle.form-control(type="text",name="movie[flash]",value="#&#123;movie.flash&#125;")																.form-group					.col-sm-offset-2.col-sum-10					button.btn.btn-default(type="submit") 录入
extends ../layoutblock content	.container		.row			table.table.table-hover.table-bordered				thead					tr						th 电影名称						th 导演						th 国家						th 上映年份						//- th 录入时间						th 查看						th 修改						th 删除				tbody					each item in movies						tr(class="item-id-#&#123;item._id&#125;")							td #&#123;item.title&#125;							td #&#123;item.doctor&#125;							td #&#123;item.country&#125;							td #&#123;item.year&#125;							//- td #&#123;moment(item.meta.createdAt).format('MM/DD/YYYY')&#125;							td: a(target="_blank",href="../movie/#&#123;item._id&#125;") 查看							td: a(target="_blank",href="../admin/update/#&#123;item._id&#125;") 修改							td								button.btn.btn-danger.del(type="button",data-id="#&#123;item._id&#125;") 删除
5、修改helloworld文件夹下app.js，主要是加入模拟数据，内容如下：
var express = require('express');var path = require('path');var port = process.env.PORT || 3000 ;var app = express();app.set('views','./views/pages');app.set('view engine','jade');app.use(express.bodyParser());app.use(express.static(path.join(__dirname, 'bower_components')));app.listen(port);console.log('helloworld started on port ' + port);app.get('/', function(req, res)&#123;  res.render('index',&#123;  title:'首页',  movies: [	  &#123;		title: '机械战警',		_id: 1,		poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',	  &#125;,	  &#123;		title: '机械战警',		_id: 2,		poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',	  &#125;    ]  &#125;)&#125;)app.get('/movie/:id', function(req, res)&#123;  res.render('detail',&#123;  title:'详情页',  movie: &#123;	doctor: '未知',	country: '美国',	title: '机械战警',	year: '2014',	poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',	language: '英语',	flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf',	summary: '无',  &#125;  &#125;)&#125;)app.get('/admin/movie', function(req, res)&#123;  res.render('admin',&#123;  title:'后台录入页',  movie: &#123;	doctor: '',	country: '',	title: '',	year: '',	poster: '',	language: '',	flash: '',	summary: '',  &#125;  &#125;)&#125;)app.get('/admin/list', function(req, res)&#123;  res.render('list',&#123;  title:'列表页',  movies: [	  &#123;		_id: 1,		doctor: '未知',		country: '美国',		title: '机械战警',		year: '2014',		poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',		language: '英语',		flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf',		summary: '无',	  &#125;,	  &#123;		_id: 2,		doctor: '未知',		country: '美国',		title: '机械战警',		year: '2014',		poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',		language: '英语',		flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf',		summary: '无',	  &#125;  ]  &#125;)&#125;)
报错处理至此，已经敲完了Scott大神给的代码，马上就能看到效果了，好激动！哎呦我靠！报错，我改！又报错，我再改！还报错……诶？坏了，改不出来了！记录错误如下：百度“nodejs使用app.use(express.bodyParser());出错”，得到如下结论：1、node.js和windows的兼容性不如POSIX操作系统，因此npm提供给windows的第三方模块较少。2、bodyParser以前是集成在express中的，现在需要单独安装。无论哪个结论，解决办法都是安装body-parser：
npm install body-parser
然后在代码中如下使用：

var bodyParser = require(‘body-parser’);app.use(bodyParser.urlencoded({ extended: false }))app.use(bodyParser.json());

即把app.js的内容修改为如下内容：
var express = require('express');var path = require('path');var port = process.env.PORT || 3000 ;var app = express();var bodyParser = require('body-parser');app.set('views','./views/pages');app.set('view engine','jade');app.use(bodyParser.urlencoded(&#123; extended: false &#125;))app.use(bodyParser.json());app.use(express.static(path.join(__dirname, 'bower_components')));app.listen(port);console.log('helloworld started on port ' + port);app.get('/', function(req, res)&#123;  res.render('index',&#123;  title:'首页',  movies: [	  &#123;		title: '机械战警',		_id: 1,		poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',	  &#125;,	  &#123;		title: '机械战警',		_id: 2,		poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',	  &#125;    ]  &#125;)&#125;)app.get('/movie/:id', function(req, res)&#123;  res.render('detail',&#123;  title:'详情页',  movie: &#123;	doctor: '未知',	country: '美国',	title: '机械战警',	year: '2014',	poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',	language: '英语',	flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf',	summary: '无',  &#125;  &#125;)&#125;)app.get('/admin/movie', function(req, res)&#123;  res.render('admin',&#123;  title:'后台录入页',  movie: &#123;	doctor: '',	country: '',	title: '',	year: '',	poster: '',	language: '',	flash: '',	summary: '',  &#125;  &#125;)&#125;)app.get('/admin/list', function(req, res)&#123;  res.render('list',&#123;  title:'列表页',  movies: [	  &#123;		_id: 1,		doctor: '未知',		country: '美国',		title: '机械战警',		year: '2014',		poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',		language: '英语',		flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf',		summary: '无',	  &#125;,	  &#123;		_id: 2,		doctor: '未知',		country: '美国',		title: '机械战警',		year: '2014',		poster: 'http://ihelloworld.qiniudn.com/%40%2Fimgs%2FiNJIT.jpg',		language: '英语',		flash: 'http://player.youku.com/player.php/sid/XNjM3Njc3MTY4/v.swf',		summary: '无',	  &#125;  ]  &#125;)&#125;)
效果图吼吼，终于搞定了！有图有真相！
结束操作过程中的其他小错误，在此不作记录，有任何问题欢迎留言！
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack计算节点的奇葩问题</title>
    <url>/dev-openstack-compute-node-broken/</url>
    <content><![CDATA[问题描述心态爆炸了！火急火燎！一方面马上要交毕业论文，另一方面马上要提交小论文。就当我打算抽出一天先完成小论文时，实验环境崩了！
之前进行迁移实验都好好的，但是今天进行迁移实验的时候，实例经常死机。本着“重启治百病”的思想，重启了两个计算节点，重新挂载了nfs。然后再次迁移时，实例可以从compute2迁移到compute1。但是，实例从compute1迁移到compute2时，compute2就报错！
ERROR oslo_messaging.rpc.server [req-922596a7-f122-45c8-9f91-1446bb855e05 2c04ede78270421da71953f8f07ef115 8de01ef30eed437193725fb759b9992d - default default] Exception during message handling: InvalidCPUInfo: Unacceptable CPU info: CPU doesn't have compatibility.
重新部署了compute2计算节点，依然是这个错误。重装了compute2计算节点的操作系统，然后重新部署，依然是这个错误！很绝望！


问题分析重装系统无效，那么大概率是控制节点的锅了！那么问题具体出在哪里？凭什么compute1就好好的，compute2就坏了？是因为控制节点的一些残留信息没有清空吗？数据库中记录说compute2已经没有可用CPU了？数据库中记录说不兼容？还是有缓存或者消息？那么该怎么清空关于compute2的信息？。。。还有一个关键的问题是，为什么突然就无法兼容了？之前不是好好的么？然而，没有人可以告诉我答案，搜索引擎不行，社区群聊不行，身边也没有OpenStack的大牛。现在只想赶紧从OpenStack这个大坑中爬出来，遇到问题根本找不到答案，就问你服不服！
垂死挣扎查看数据库1、查看数据库密码less /etc/kolla/passwords.yml | grep password里面有很多密码，我们需要的是nova_database_password。
2、进入mariadb容器docker exec -it mariadb /bin/bash
3、登录mariadb数据库mysql -u nova -p
4、使用nova数据库use nova;
5、查看计算节点的信息select * from compute_nodes\G
重命名计算节点如果，给compute2节点更换hostname和IP呢？比如hostname换成compute3，IP也换成其他的。这样的话，计算节点就不会受控制节点中残留信息的影响了。
1、修改compute2的hostname和IP地址
2、修改multinode文件控制节点中，把multinode文件中的compute2节点换成compute3，/etc/hosts中添加compute3对应的IP。
3、重新部署kolla-ansible -i ./multinode deploy
4、查看计算服务
. admin-openrc.shopenstack compute service list

设置迁移和挂载参考《OpenStack中虚拟机的在线迁移》，在compute3节点设置OpenStack允许迁移。参考《OpenStack中共享存储的虚拟机在线迁移》，在compute3节点挂载nfs。
1、修改nova.conf的配置vim /etc/kolla/nova-compute/nova.conf，在default中添加：
live_migration_flag=VIR_MIGRATE_UNDEFINE_SOURCE,VIR_MIGRATE_PEER2PEER,VIR_MIGRATE_LIVE

2、修改libvirtd.confvim /etc/kolla/nova-libvirt/libvirtd.conf，修改配置如下：
listen_tcp = 1listen_tls = 0auth_tcp = "none"ca_file = ""log_level = 3log_outputs = "3:file:/var/log/kolla/libvirt/libvirtd.log"listen_addr = "0.0.0.0"

3、挂载nfs
apt-get install nfs-commonmount -t nfs 192.168.56.130:/nfs/share/instances /var/lib/docker/volumes/nova_compute/_data/instances/chmod -R 777 /var/lib/docker/volumes/nova_compute/_data/instances/

4、重启nova_compute和nova_libvirt
docker stop nova_computedocker start nova_computedocker stop nova_libvirtdocker start nova_libvirt

再次尝试迁移1、迁移命令nova live-migration demo0 compute3
2、查看状态nova show demo0
3、compute3上查看日志tail -n 20 /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log
虽然迁移失败，但是好歹是不一样的错误了。。。这个错误以前遇到过，重启计算节点就好了。于是重启compute3节点，但是问题没有解决。
4、测试与控制节点的连接curl http://192.168.56.120:35357，结果为：
curl: (7) Failed to connect to 192.168.56.120 port 35357: Connection refused

5、在compute1节点上测试与控制节点的连接curl http://192.168.56.120:35357，结果为：
&#123;"versions": &#123;"values": [&#123;"status": "stable", "updated": "2018-02-28T00:00:00Z", "media-types": [&#123;"base": "application/json", "type": "application/vnd.openstack.identity-v3+json"&#125;], "id": "v3.10", "links": [&#123;"href": "http://192.168.56.120:35357/v3/", "rel": "self"&#125;]&#125;, &#123;"status": "deprecated", "updated": "2016-08-04T00:00:00Z", "media-types": [&#123;"base": "application/json", "type": "application/vnd.openstack.identity-v2.0+json"&#125;], "id": "v2.0", "links": [&#123;"href": "http://192.168.56.120:35357/v2.0/", "rel": "self"&#125;, &#123;"href": "https://docs.openstack.org/", "type": "text/html", "rel": "describedby"&#125;]&#125;]&#125;&#125;
这才是正常的啊！
6、重启compute3并且重新挂载nfs
mount -t nfs 192.168.56.130:/nfs/share/instances /var/lib/docker/volumes/nova_compute/_data/instances/docker stop nova_computedocker start nova_computedocker stop nova_libvirtdocker start nova_libvirt

7、再次执行迁移nova live-migration demo0 compute3依然失败，还是同样的错误。
IP的坑百度谷歌想要找到答案？不存在的。折腾了两天，突然灵光一现！还记得《Kolla安装OpenStack多节点》一文中，控制节点的IP为192.168.56.110。而配置globals.yml时候，kolla_internal_vip_address的值为192.168.56.120。
因此，compute3节点中，nova.conf中的IP有一部分是192.168.56.110，另外一部分是192.168.56.120。
明明所有控制节点的服务都在一个节点上，却有两个IP，看起来就容易闹幺蛾子。实际上，确实闹过幺蛾子！OpenStack刚刚安装成功时，使用192.168.56.120这个IP可以访问到horizon服务，使用192.168.56.110就不可以。后来突然有一天，192.168.56.120这个IP就不能访问horizon了，使用192.168.56.110却可以访问！再后来突然有一天，两个IP都可以访问horizon服务！真的是醉了。。。
这次，会不会也是IP的问题？于是，在compute3上，换一个IP测试访问控制节点。curl http://192.168.56.110:35357，果然可以正常访问！于是，思路就清晰了。
1、修改compute3节点中的nova.conf配置文件vim /etc/kolla/nova-compute/nova.conf，所有的192.168.56.120全部换成192.168.56.110。
2、重启nova_compute
docker stop nova_computedokcer start nova_compute

3、再次迁移，失败，不过报错变了。
依然是IP问题，看来还有其他配置文件中写了192.168.56.120。
4、修改neutron.conf和chrony.conf文件
vim /etc/kolla/neutron-openvswitch-agent/neutron.confvim /etc/kolla/chrony/chrony.conf
所有120替换为110。
5、重启neutron和chrony
docker stop neutron_openvswitch_agentdocker start neutron_openvswitch_agentdocker stop chronydocker start chrony

6、再次迁移，依然失败，报错依然失8780端口。
7、重启所有服务，再次迁移，依然失败。莫非还有什么文件没有注意到？于是放了一个大招，grep -rn &quot;192.168.56.120:8780&quot; *，然而，没有找到包含该配置的文件。
8、重启了compute3，然后，nova_compute无法启动了！启动报错：
/var/lib/docker/volumes/kolla_logs/_data: no such file or directory/var/lib/docker/volumes/libvirtd/_data: no such file or directory/var/lib/docker/volumes/nova_compute/_data: no such file or directory
创建了三个文件夹，依然无法启动nova_compute。
破釜沉舟实在是没办法了，只能使出最后一招：重装整个OpenStack系统！
销毁OpenStack环境1、查看镜像glance image-list
或者进入镜像文件夹查看cd /var/lib/docker/volumes/glance/_data/images
2、导出镜像
glance image-download --file ./ubuntu16-env.img 003ae986-4dd9-45a6-9630-1b80fc8dcab3ll -h

3、在horizon中删除所有镜像
4、在horizon中关闭并删除所有实例
5、编辑multinode文件，取消所有节点的注释
6、销毁整个OpenStack环境kolla-ansible destroy -i ./multinode --yes-i-really-really-mean-it
安装OpenStack参考《Kolla安装OpenStack多节点》进行OpenStack的安装。
考虑到两个IP的坑，这次安装我仔细阅读了一下globals.yml文件中关于kolla_internal_vip_address的描述：

This should be a VIP, an unused IP on your network that will float betweenthe hosts running keepalived for high-availability. If you want to run anAll-In-One without haproxy and keepalived, you can set enable_haproxy to noin “OpenStack options” section, and set this value to the IP of your‘network_interface’ as set in the Networking section below.

这应该是VIP，网络上未使用的IP将在运行keepalived以获得高可用性的主机之间浮动。如果要在没有haproxy和keepalived的情况下运行多功能一体机，可以在“OpenStack选项”部分中将enable_haproxy设置为no，并将此值设置为“network_interface”的IP，如下面的“网络”部分所述。
看来，kolla_internal_vip_address不应该设置为192.168.56.120，因为我们的环境中不需要haproxy。所以，在配置配置globals.yml的时候，kolla_internal_vip_address应该设置为和控制节点相同的IP：192.168.56.110，同时enable_haproxy设置为no。
安装完成后，导入之前备份的镜像：
. admin-openrc.shglance image-create \--name "ubuntu16-env" \--file ./ubuntu16-env.img  \--disk-format qcow2 \--container-format bare \--visibility public \--progress

设置迁移和挂载参考本文中垂死挣扎部分设置迁移和挂载。然后，创建实例，分配浮动IP，测试迁移，成功！nice！
罪魁祸首再次进行迁移，同时启动间隔1ms的ping命令测试停机时间，然后实例迁移后死机了！Ctrl+C关闭ping命令，实例复活。由此猜想是ping命令的锅。
但是，这是一个单向问题！同样是使用间隔1ms的ping命令测试停机时间，实例从compute1迁移到compute2时正常，实例从compute2迁移到compute1时才会死机。就问你神奇不神奇？！
猜测是因为ping的频率太高，给网络或者实例带来了太大的负荷。ping命令降低到10ms一次，双向迁移都正常。
但是，实例从compute1到compute2时，就不会受到ping命令的影响，这次是为什么？两台机器的配置完全相同的啊！诡异，实在是诡异！
更诡异的是，每次迁移的数据居然都通过不同的网卡，也许这次通过eth0（管理网络），下次就通过eth2（外网网络）！还能不能愉快地玩耍了？！
细细回想整个安装流程，突然想到，在安装前设置了三个节点的hosts文件，三个节点通过eth0通信。但是ansible安装OpenStack后，会根据globals.yml中的network_interface（eth1）修改hosts文件，于是hosts中有了两套规则。默认使用hosts文件中靠前的规则，于是我自己设置的规则就把ansible设置的规则覆盖了。eth0既用于节点间通信，又用于实例迁移。由于eth2和eth0属于同一个网段，所以有时会通过eth2网卡进行迁移！
为了验证自己的猜想，修改了三个节点的hosts文件，保留ansible创建的那一份。这样，就指定了迁移时使用的网卡。修改后在控制节点和计算节点重启nova相关服务。
# 计算节点docker stop nova_computedocker start nova_computedocker stop nova_libvirtdocker start nova_libvirt# 控制节点docker stop nova_apidocker start nova_apidocker stop nova_schedulerdocker start nova_schedulerdocker stop placement_apidocker start placement_api

再次迁移实验，迁移数据果然会通过eth1（OpenStack内网网络），而不是eth0或者eth2！而且，双向迁移加1ms的ping命令都可以成功迁移，实例不再死机，问题完美解决！真相大白，罪魁祸首居然是hosts文件！
此外，live_migration_inbound_addr参数也可以指定迁移网络。
风波再起就当我自以为找到了真相，继续实验时，实例再次出现了实例死机的情况。双向迁移都会偶尔出现死机，而且，使用间隔1ms的ping命令时死机概率会更大。如果使用间隔10ms的ping命令来测试停机时间呢？测出来的停机时间是秒级！Are you kidding me ?比如同一个迁移，使用两个ping命令进行测试：
sudo ping instance_float_ip -i 0.001 &gt;&gt; ping.log根据丢包数计算出的downtime为434mssudo ping instance_float_ip -i 0.01 &gt;&gt; ping.log根据丢包数计算出的downtime为3340ms

理论上，应该测出同样的结果才对，然而他们差了一个数量级！诡异，实在是诡异！哪个才是真正的downtime？无论哪个是真正的downtime，ping命令本身绝对存在重大缺陷！
如果downtime是毫秒级，那么就符合理论上的值，实验可以正常进行。但是，使用间隔1ms的ping命令测试停机时间容易实例死机啊大哥！
如果downtime是秒级，那么问题要么是出在OpenStack配置上面，要么是出在网络上面。假设问题出在OpenStack的配置上面，于是参考Configure live migrations，先后设置了最大停机时间，设置了自动收敛，设置了后拷贝。但是，问题依旧，那么应该不是OpenStack的配置问题。假设问题出在网络上面，那么怎么解决呢？给实例的外网（eth3）设置一个单独的网段，不要和管理网络（eth0）在同一个网段？太麻烦。如果，在另外一个实例中对迁移实例进行ping测试呢？这样至少也可以避免了浮动IP的切换问题，是一个好主意。
于是在实例B中运行间隔1ms的ping命令，通过实例间的内网测试实例A，实例A多次迁移，测出的downtime在几十毫秒到几百毫秒不等，而且不会死机。在实例B中使用间隔10ms的ping命令进行测试，测出的downtime在几百毫秒左右，也很合理。所以，不是ping命令的锅？
不管了不管了，总之找到了解决办法！在另外一个实例中对迁移实例使用ping命令通过实例间的内网测试停机时间，而不是在外部机器中使用ping命令通过浮动IP测试停机时间。命令如下：
sudo ping instance_internal_ip -i 0.001 &gt;&gt; ping.log

后记因为实例迁移会死机，所以开始了折腾。折腾了一大圈，重启所有节点，重装计算节点，重装系统，重装OpenStack，最后发现实例迁移依然会死机！这就排除了硬件问题，也排除了软件问题。好在最后灵光一现猜测是hosts的问题，不然这个坑是怎么都爬不出不来了。。。只是没想到刚爬出一个坑，又跌进了一个坑，修改了hosts不死机，只是刚好那几次实验都没死机！在使用了间隔1ms的ping命令之后，死机依然频繁。再次折腾OpenStack配置，失败。再次从网络方面考虑，终于找到了解决方案，太不容易了！
今天（3月24日）终于修复了实验环境，但是，已经错过了cloud2019的deadline。有些遗憾，不过和毕业论文相比，只能先牺牲小论文了。近期还有会议，加把劲，做实验，写论文，投稿！
书签openstack中彻底删除计算节点的操作记录
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
        <tag>ubuntu</tag>
        <tag>ansible</tag>
        <tag>openstack</tag>
        <tag>kolla</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机在线迁移实验V2——上</title>
    <url>/dev-openstack-vm-live-migration-experiment-v2-0/</url>
    <content><![CDATA[前言《虚拟机在线迁移实验》一文中，进行了一些虚拟机迁移实验，并且记录了迁移过程中的指标数据。但是，实验环境是搭建在VirtualBox虚拟机中的，最终的实验结果不理想，会出现停机时间过长，迁移后实例卡住等问题。而且受限于虚拟机的大小，无法创建m1.xlarge这样的大型实例。
最近参照《Ubuntu16使用Kolla安装OpenStack》和《Kolla安装OpenStack多节点》，在物理机环境中重新搭建了OpenStack集群，三个节点分别为controller（network）、compute1、compute2。接下来我们在物理机中重新进行迁移实验，本文记录一下实验的步骤和结果。


实例准备1、在horizon控制台，项目，计算，镜像。使用xenial-server-cloudimg-amd64-disk1.img镜像创建ubuntu16的镜像模板。
2、创建实例类型m1.tiny2，CPU个数为1，内存为512M，磁盘为5GB。
3、使用ubuntu16的镜像模板创建实例ubuntu0、ubuntu1、ubuntu2、ubuntu3、ubuntu4，实例类型分别选择m1.tiny2、m1.small、m1.medium、m1.large、m1.xlarge。之所以不使用默认的m1.tiny，是因为m1.tiny的磁盘太小，只有1G，无法安装ubuntu16。

4、创建成功后，分别分配浮动IP。
PS：在进行迁移实验时，关闭其他实例，防止资源占用产生干扰。
脚本和软件准备总迁移时间在两个计算节点，新建total-time.sh脚本：
#!/bin/bashtime1=`grep nova.virt.libvirt.migration /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log | tail -n 1 |awk '&#123;print $2&#125;'`;time2=`grep 'VM Stopped' /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log | tail -n 1 | awk '&#123;print $2&#125;'`;# 计算时间差time=$(($(date +%s -d $time2) - $(date +%s -d $time1)));echo "$time s";

停机时间在控制节点，新建downtime.sh脚本：
#!/bin/bashtransmitted=`grep 'packets transmitted' ping.log | tail -n 1 | awk '&#123;print $1&#125;'`received=`grep 'packets transmitted' ping.log | tail -n 1 | awk '&#123;print $4&#125;'`lost=`expr $transmitted - $received`echo "downtime is $lost ms"

迁移数据量在两个计算节点，安装iptraf-ng。apt install iptraf-ng
apache在ubuntu0等实例中安装apache：apt install apache2安装的默认版本为Apache/2.4.18 (Ubuntu)。
apachebench在控制节点，安装apachebench：apt install apache2-utils
在控制节点，新建format.sh脚本：
#!/bin/bashfilename=$1start_time=`awk '&#123;print $6&#125;' $filename | grep -v 'wait' | sort | uniq -c|head -1|awk '&#123;print $2&#125;'`awk '&#123;print $6&#125;' $filename | grep -v 'wait' | sort | uniq -c|awk -v t=$start_time '&#123;print $2-t,$1&#125;' &gt; f-$filename# 填充0array_str=`cat f-$filename | awk '&#123;print $1&#125;'`array_str2=`cat f-$filename | awk '&#123;print $2&#125;'`IPS=' 'array=($array_str)array2=($array_str2)index=0count=0max=101echo "#Throutput-$filename" &gt; ff-$filenamewhile ( [ $index -lt $max ] &amp;&amp; [ $count -lt $max ] )do    if [[ $&#123;array[index]&#125; == $count ]]    then        echo "$count $&#123;array2[index]&#125;" &gt;&gt; ff-$filename        index=`expr $index + 1`        count=`expr $count + 1`    else        echo "$count 0"  &gt;&gt; ff-$filename        count=`expr $count + 1`    fidone

xshell使用xshell，打开3个controller节点的shell，一个用来ping实例，一个用来运行apachebench，一个用来执行迁移命令。打开2个compute1节点的shell，一个用来运行iptraf-ng，一个用来执行total-time.sh脚本。打开2个compute2节点的shell，一个用来运行iptraf-ng，一个用来执行total-time.sh脚本。
实验流程假设当前只启动了ubuntu0实例，nova show ubuntu0位于compute1节点。
1、在实例中启动压力测试软件，或者在两个compute节点中启动网络故障模拟软件。（flavor实验中不需要）
2、在两个compute节点启动iptraf-ng，配置参考《虚拟机在线迁移的性能统计》。
3、在三个controller的shell中分别输入好一条命令：
sudo ping 172.16.0.19 -i 0.001 &gt;&gt; ping.logab -g t0.dat -t 100 -n 1000000 http://172.16.0.19/nova live-migration ubuntu0 compute2
然后，依次回车执行这些命令。
4、观察compute节点的iptraf-ng，等到流量不再增加，Ctrl+C结束ping命令。
5、在controller节点执行downtime.sh得到停机时间，在compute1节点执行total-time.sh得到迁移时间，在两个计算节点观察iptraf-ng得到迁移数据量。
6、等到ab命令结束，执行./format.sh t0.dat，得到吞吐量数据ff-t0.dat。
以上流程，适用于接下来的所有实验。
flavor实验1、按照实验流程，分别使用五个flavor，进行五次迁移实验，记录实验结果。
#Flavor    迁移时间s    停机时间ms    迁出数据量MB   迁入数据量MBtiny    19  483    456  459small   20  533    443  446medium  21  509    491  494large   22  455    592  596xlarge  24  531    829  834

2、同时得到五个吞吐量数据文件，ff-t0.dat到ff-t4.dat。
吞吐量问题实验结果绘图，发现五种flavor的吞吐量基本没有差别！都是800上下。为了解决apache吞吐量问题，必须得研究一下。
修改apache配置思路一：提高apache的最大连接数。参考如何设置Apache中的最大连接数、如何设置Apache中的最大连接数。
1、查看apache moduleapachectl -V可以看到Server MPM为event。如果要换成其他MPM，可以参考Ubuntu配置apache2.4的限速功能进行设置，比如换成prefork，这里我们不进行更换。
cd /etc/apache2/mods-enabledsudo ln -s ../mods-available/mpm_prefork.load .sudo ln -s ../mods-available/mpm_prefork.conf .sudo rm mods_event.loadsudo rm mods_event.confsudo service apache2 restart

2、备份配置
cd /etc/apache2/mods-available/sudo cp mpm_event.conf&#123;,.bak&#125;sudo cp mpm_event.load&#123;,.bak&#125;

3、修改配置编辑/etc/apache2/mods-available/mpm_event.conf，原文件为：
# event MPM# StartServers: initial number of server processes to start# MinSpareThreads: minimum number of worker threads which are kept spare# MaxSpareThreads: maximum number of worker threads which are kept spare# ThreadsPerChild: constant number of worker threads in each server process# MaxRequestWorkers: maximum number of worker threads# MaxConnectionsPerChild: maximum number of requests a server process serves&lt;IfModule mpm_event_module&gt;        StartServers             2        MinSpareThreads          25        MaxSpareThreads          75        ThreadLimit              64        ThreadsPerChild          25        MaxRequestWorkers        150        MaxConnectionsPerChild   0&lt;/IfModule&gt;# vim: syntax=apache ts=4 sw=4 sts=4 sr noet

参考关于apache的mpm-event的参数无法调整问题，修改为：
&lt;IfModule mpm_event_module&gt;    ServerLimit              100    StartServers             20    MinSpareThreads          25    MaxSpareThreads          1200#   ThreadLimit              64    ThreadsPerChild          50    MaxRequestWorkers        5000    MaxConnectionsPerChild   10000&lt;/IfModule&gt;
MaxSpareThreads的参数设置，需要根据StartServers*ThreadsPerChild=1000，因此MaxSpareThreads必须大于1000，在此为1200，否则会有StartServers-MaxSpareThreads/ThreadsPerChild个进程被杀掉。
MaxRequestWorkers的参数设置，需要根据ServerLimit*ThreadsPerChild=5000，否则启动会有警告。
4、重启apache2sudo service apache2 restart
然而，并没有用，吞吐量并没有发生什么变化，依然是800左右，不过波动幅度变大了。MPM更换为prefork，吞吐量降到了700左右。
修改ab命令思路二：apachebench的命令有问题。修改ab命令为：ab -g t0.dat -c 1000 -t 100 -n 10000000 http://172.16.0.19/
这次，吞吐量果然上去了，变成8000左右。但是，所有实例的吞吐量都上去了！
更换测试工具思路三：测试工具换成webbench。1、安装webbench
wget http://soft.vpser.net/test/webbench/webbench-1.5.tar.gztar zxvf webbench-1.5.tar.gzcd webbench-1.5sudo make &amp;&amp; sudo make install

2、测试webbench -c 10000 -t 10 http://172.16.0.19/10s成功了80000左右的请求，说明ab测出的吞吐量是真实的。这样看来，问题还是出在apache上，吞吐量固定在8000左右。
更换为nginx思路四：apache更换为nginx。1、修改apache的端口sudo vim /etc/apache2/ports.conf，端口改为8080。
2、安装nginx
sudo apt install -y nginxsudo apt update --fix-missingsudo apt install -y nginx

3、再次测试ab -g t0.dat -c 1000 -t 100 -n 10000000 http://172.16.0.19/吞吐量有所上升，9000左右，但是最坑的地方在于，所有实例都上升了，都是9000左右！
提高ulimit思路五：在实例中提高ulimit。
sudo -iulimit -aulimit -i 257178ulimit -u 257178
然而，吞吐量并没有变化。
网络问题莫非，是因为计算机网络问题？于是，在实例ubuntu0、ubuntu2、ubuntu4内部中进行ab测试，吞吐量结果为：
app ubuntu0 ubuntu2 ubuntu4apache 5298 11290 17706nginx  9380 19745 23124
看到这个结果，总算感觉合理了。问题也可以定位了，网络瓶颈。那么新的问题来了，不能在实例内部进行测试的情况下，怎样测试出准确的吞吐量？
安装应用如果能够把真实吞吐量降到8000以下，是不是就可以通过内网测出真实吞吐量了？很有可能。那么，就安装一个标准测试应用，来试试效果。找到了两款应用，mediawiki和tpcw，这里我们选择mediawiki，参考《MediaWiki安装与配置》。
安装好mediawiki后进行ab测试：
ab -g t0.dat -c 10 -t 100 -n 1000000 http://172.16.0.19/mediawiki/index.php/Main_Page
ubuntu0吞吐量为30左右，ubuntu2的吞吐量为60左右。
实验流程2假设当前只启动了ubuntu0实例，nova show ubuntu0位于compute1节点。
1、在实例中启动压力测试软件，或者在两个compute节点中启动网络故障模拟软件。（flavor实验中不需要）
2、在两个compute节点启动iptraf-ng，配置参考《虚拟机在线迁移的性能统计》。
3、在三个controller的shell中分别输入好一条命令：
sudo ping 172.16.0.19 -i 0.001 &gt;&gt; ping.logab -g t0.dat -c 10 -t 100 -n 1000000 http://172.16.0.19/mediawiki/index.php/Main_Pagenova live-migration ubuntu0 compute2
然后，依次回车执行这些命令。
4、观察compute节点的iptraf-ng，等到流量不再增加，Ctrl+C结束ping命令。
5、在controller节点执行downtime.sh得到停机时间，在compute1节点执行total-time.sh得到迁移时间，在两个计算节点观察iptraf-ng得到迁移数据量。
6、等到ab命令结束，执行./format.sh t0.dat，得到吞吐量数据ff-t0.dat。
以上流程，适用于接下来的所有实验。
flavor实验21、按照实验流程，分别使用安装了mediawiki的五个flavor，进行五次迁移实验，记录实验结果。然而，新的问题出现了，安装了mediawiki的flavor，迁移时间特别久，迁移数据量特别大，等到ab命令结束，迁移才会停止。修改ab命令为：
ab -g t0.dat -t 100 -n 1000000 http://172.16.0.19/mediawiki/index.php/Main_Page
可以成功迁移，但是另一个问题出现了，所有实例的吞吐量都下降为10左右，这日子没发过了！
是mediawiki的问题吗？创建一个index.php文件来测试一下，内容为：
&lt;?php    phpinfo();?&gt;
使用ab命令测试：ab -g t0.dat -c 1000 -t 100 -n 1000000 http://172.16.0.19/index.phpubuntu0吞吐量在800左右，ubuntu2的吞吐量在1200左右，挺不错的结果。然而，如果在ab测试时进行迁移，迁移时间依然会特别久，迁移数据量依然会特别大。ab命令停止，迁移成功停止；ab命令不停止，迁移直到失败。和mediawiki存在同样的问题。
后记实验遇到瓶颈，找叶老师商量后，决定不再适用Apache这种web服务，而是换成系统服务，比如计算任务。在实例内部运行服务记录结果，就不存在网络的影响了。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>apache</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机在线迁移实验V2——下</title>
    <url>/dev-openstack-vm-live-migration-experiment-v2-1/</url>
    <content><![CDATA[前言毕业论文送审的日期是3月22日，cloud2019的deadline也是3月22日。大概从2月27日开始写毕业论文，早八点半晚十点，周末不休，3月22日终于写完送审了，算是完成了一件大事。之后，还有两件大事：一个是实现阅卷系统，一个是发表小论文。
本来打算3月20日抽出一天时间做实验写小论文，没想到实验环境崩了！无奈只能放弃cloud。论文送审后一直在忙着修复实验环境，2月24日晚上十点左右，终于修复成功！是时候完成小论文了！


前情回顾《虚拟机在线迁移实验V2——上》一文中，实验遇到瓶颈，所以不得不重新设计实验。经过思考，打算把web服务换成mysql服务，在实例中进行测试。但是，实验表明，如果在迁移过程中对mysql试压，那么会出现和web服务同样的问题，迁移无法成功。所以，本文中去掉了服务降级这个指标，只测量停机时间、迁移时间和迁移数据量。
实例准备1、在horizon控制台，项目，计算，镜像。使用xenial-server-cloudimg-amd64-disk1.img镜像创建ubuntu16的镜像模板。
2、创建实例类型m1.tiny2，CPU个数为1，内存为512M，磁盘为5GB。
3、使用ubuntu16的镜像模板创建实例ubuntu0、ubuntu1、ubuntu2、ubuntu3、ubuntu4，实例类型分别选择m1.tiny2、m1.small、m1.medium、m1.large、m1.xlarge。之所以不使用默认的m1.tiny，是因为m1.tiny的磁盘太小，只有1G，无法安装ubuntu16。

4、创建成功后，分别分配浮动IP。
PS：在进行迁移实验时，关闭其他实例，防止资源占用产生干扰。
脚本和软件准备总迁移时间在控制节点，新建mtime.sh脚本：
#!/bin/bashtime1=`grep 'live-migration' list.log | head -n 1 | awk '&#123;print $24&#125;'`time2=`grep 'live-migration' list.log | head -n 1 | awk '&#123;print $26&#125;'`time=$(($(date +%s -d $time2) - $(date +%s -d $time1)));echo "$time s";

新建allmtime.sh脚本，可以计算所有迁移时间：
#!/bin/bashtime1=`grep 'live-migration' list.log | awk '&#123;print $24&#125;'`time2=`grep 'live-migration' list.log | awk '&#123;print $26&#125;'`IPS=' 'array1=($time1)array2=($time2)length=$&#123;#array1[@]&#125;COUNTER=0while [ $COUNTER -lt $length ]do    COUNTER=`expr $COUNTER + 1`    t1=$&#123;array1[COUNTER]&#125;    t2=$&#123;array2[COUNTER]&#125;    time=$(($(date +%s -d $t2) - $(date +%s -d $t1)));    echo "$time s";done

停机时间在控制节点，新建downtime.sh脚本：
#!/bin/bashtransmitted=`grep 'packets transmitted' ping.log | tail -n 1 | awk '&#123;print $1&#125;'`received=`grep 'packets transmitted' ping.log | tail -n 1 | awk '&#123;print $4&#125;'`lost=`expr $transmitted - $received`echo "downtime is $lost ms"

迁移数据量在两个计算节点，安装iptraf-ng。apt install iptraf-ng
xshell使用xshell，打开两个controller节点的shell，一个登录实例B后用来ping实例A；一个用来执行迁移命令，迁移之后执行mtime.sh脚本。打开一个compute1节点的shell，用来运行iptraf-ng。打开一个compute2节点的shell，用来运行iptraf-ng。
实验流程假设当前只启动了ubuntu0实例，nova show ubuntu0位于compute1节点。
1、在两个compute节点启动iptraf-ng，配置参考《虚拟机在线迁移的性能统计》。
2、在实例中启动压力测试软件，或者在两个compute节点中启动网络故障模拟软件。（flavor实验中不需要）
3、在实例B中ping实例ubuntu0sudo ping ubuntu0_internal_ip -i 0.001 &gt;&gt; ping.log
4、在controller中执行迁移nova live-migration ubuntu0 compute2
5、观察compute节点的iptraf-ng，等到流量不再增加。关闭压力测试软件或者网络故障模拟软件，然后在实例B中Ctrl+C结束ping命令。
6、在controller节点记录迁移列表nova migration-list &gt; list.log
7、controller节点执行mtime.sh得到迁移时间，在实例B中执行downtime.sh得到停机时间，在两个计算节点观察iptraf-ng得到迁移数据量。
以上流程，适用于接下来的所有实验。
flavor实验按照实验流程，分别使用五个flavor，进行五次迁移实验，记录实验结果。
#Flavor    迁移时间s    停机时间ms    迁出数据量MB   迁入数据量MBtiny    24  297   275  277small   26  14    329  332medium  27  69    373  375large   30  50    846  852xlarge  31  57    923  929

由实验结果可以看出，随着CPU和内存的增加，迁移时间也会随之增加。tiny模板的停机时间最大，其他模板的停机时间在10ms到70ms之间。源主机的迁出数据量和目标主机的迁入数据量也会随之增加，而且迁入数据量要比迁出数据量多2到6MB。
系统压力实验CPU实验接下来的实验，都使用small类型的flavor。1、先给实例安装stress-ngsudo apt install stress-ng
2、在实例中创建一个CPU进程，CPU占用率10%stress-ng -c 1 -l 10
3、创建CPU进程，CPU占用率20%-100%，记录实验结果。
# CPU占用率%   迁移时间s    停机时间ms    迁出数据量MB   迁入数据量MBIdle    26  14    329  33210%     27  15    330  33320%     26  18    331  33330%     24  403   330  33340%     25  3332  330  33450%     25  3175  330  33260%     24  505   327  32970%     26  10372 328  33180%     25  292   329  33190%     26  124   330  333100%    26  573   328  330
由实验结果可以看出，随着CPU占用率的提高，迁移时间没有太大变化。停机时间在CPU使用率大于30%之后，停机时间普遍大于100ms，偶尔会出现停机时间大于3s，没有明显的规律。迁移数据量并没有太大变化，迁入数据一直比迁出数据多2到4MB。
在迁移时，偶尔会出现OpenStack显示实例迁移成功，但是实例停机时间特别长（大于600s）的情况。本文中认为这种情况属于异常，会重做实验，去除这些异常值。
内存实验1、在实例中创建一个200M的内存进程stress-ng --vm 1 --vm-bytes 200M --vm-keep
2、创建内存进程，内存占用400M-1600M，记录实验结果。
# 内存占用MB   迁移时间s    停机时间ms    迁出数据量MB   迁入数据量MBIdle    26      14      329     332200     79      3090    6543    6585400     199     144     21344   21481 600     308     440     33368   33585800     422     560     47712   480191000    541     23560   61417   61814    1200    649     250080  74617   751031400    925     27230   107004  1077021600    1049    3140    121600  122390
从实验结果中可以看出，随着内存使用量的增加，总迁移时间急剧增加。停机时间一般大于100ms，有时甚至超过20s。迁移数据量也急剧增加，数量级变为GB。当内存占用1600MB时，总迁移时间超过1000s，迁移数据大于120GB，传输到目标机器的数据与从源机器传输的数据之间的差异为700MB。
磁盘实验1、在实例中创建2个写入进程，每个进程写入大小为1M的文件。stress-ng -d 2 --hdd-bytes 1M
2、在实例中创建4-20个写入进程，记录实验结果。
# 写入进程数   迁移时间s    停机时间ms    迁出数据量MB   迁入数据量MB0       26      14      329     3322       42      510     2178    21924       50      100     2954    29746       127     3350    12456   125378       137     490     13519   1360810      172     4570    18179   18296 12      182     6340    18948   19072     14      172     6860    18034   1815016      189     410     19569   1969618      179     600     18790   1891020      246     3160    26687   26859
从实验结果中可以看出，随着写入进程的增加，迁移时间也在不断增加。停机时间普遍大于400ms，频繁出现大于3s停机时间。迁移数据量呈现阶梯式变化，数量级变成GB。当写入进程数为20时，迁移时间约为250s，迁移数据约为27GB。
网络故障实验网络故障实验之前，需要重启测试实例，否则测出的迁移数据量会偏大一个数量级。
网络延迟1、在compute节点（迁出节点）添加网络延迟20mssudo tc qdisc add dev eth1 root netem delay 20ms注：原本的延迟在0.2ms上下。
2、将网络延迟修改为40ms-200ms，记录实验结果。sudo tc qdisc replace dev eth1 root netem delay 40ms
# 网络延迟ms   迁移时间s    停机时间ms    迁出数据量MB   迁入数据量MB0       26      14      329     33220      27      6720    354     35640      29      320     354     35660      32      3200    355     35780      39      160     356     358100     39      3370    360     362120     43      320     357     358140     45      310     358     360160     51      580     356     357180     51      5480    356     357  200     59      620     380     382

由实验结果可以看出，随着网络延迟时间的增加，迁移时间也会随之增加。停机时间普遍大于300ms，经常出现3s到7s的停机时间。迁出数据量和迁入数据量没有明显的变化，差值也保持在稳定的范围。
此外，在网络延迟实验中，实例死机（停机时间大于600s）的频率要高于CPU、内存和磁盘实验。
3、取消模拟：sudo tc qdisc del dev eth1 root
丢包1、两个计算节点，都模拟丢包率1%sudo tc qdisc add dev eth1 root netem loss 1%
2、将模拟丢包率修改为1%-10%，记录实验结果。sudo tc qdisc change dev eth1 root netem loss 2%
# 丢包率   迁移时间s    停机时间ms    迁出数据量MB   迁入数据量MB0%      26      14      329     3321%      24      1460    354     3562%      26      4190    355     3563%      30      3990    358     3594%      38      2640    357     3575%      43      7610    359     3606%      67      5960    361     3617%      131     43890   363     3638%      170     20850   368     3689%      283     11430   371     37110%     392     67520   365     365

从实验结果中可以看出，随着丢包率的增大，迁移时间也会明显增加。丢包率大于7%之后，停机时间普遍大于10s，甚至出现了68s的停机时间。迁移数据量变化不大，迁入迁出数据量的差值稳定在1MB以内。
3、取消模拟：sudo tc qdisc del dev eth1 root
包重复1、两个计算节点，都模拟包重复率10%sudo tc qdisc add dev eth1 root netem duplicate 10%随机产生 10% 重复的包。
2、将模拟包重复率修改为20%-100%，记录实验结果sudo tc qdisc change dev eth1 root netem duplicate 20%
# 包重复率   迁移时间s    停机时间ms    迁出数据量MB   迁入数据量MB0%      26      14      329     33210%     32      180     652     65620%     28      180     712     71730%     27      120     769     77440%     28      300     840     84550%     29      3060    887     89360%     29      140     959     96570%     28      540     1016    102380%     32      440     1073    108090%     35      3490    1135    1142100%    32      90      1196    1204
从实验结果可以看出，随着包重复率的增加，总的迁移时间变化不大。停机时间普遍大于100ms，偶尔出现大于3s的情况，没有明显的变化趋势。迁移数据量随着包重复率的增加而增大，迁入数据量和迁出数据量的差值在4M到8M。
3、取消模拟：sudo tc qdisc del dev eth1 root
包损坏1、两个计算节点，都模拟包损坏率1%sudo tc qdisc add dev eth1 root netem corrupt 1%随机产生 1% 损坏的报文（在报文的随机位置造成一个比特的错误）。
在ping的时候会报错：Warning: time of day goes back , taking countermeasures，不过没关系，不影响我们的停机时间统计结果。
2、将模拟包损坏率修改为2%-5%，记录实验结果。sudo tc qdisc change dev eth1 root netem corrupt 2%
# 包损坏率   迁移时间s    停机时间ms    迁出数据量MB   迁入数据量MB0%      26      14      329     3321%      26      660     333     334 2%      27      1120    334     3353%      35      4160    337     3374%      149     2760    342     342 5%      254     15040   352     353 6%      1228    117760  356     356
从实验数据中可以看出，包损坏率大于3%之后，迁移时间会急剧增加。停机时间普遍大于1s，总体呈上升趋势。停机时间在包损坏率等于5%和6%时发生突变。迁移数据量没有明显变化。当包损坏率等于6%时，迁移时间超过20min，停机时间接近120s。
而且，在本文中的实验环境中，包损坏率大于等于7%时，迁移会失败。迁移进行了1600s还没有完成，OpenStack会自动撤销迁移。还有一个有趣的现象是，正常迁移中只要使用49152端口就可以了，在出现包损坏的情况下，会使用49153-49216端口来辅助传输数据。
3、取消模拟：sudo tc qdisc del dev eth1 root
PS：如果迁移无法成功，那么就取消包损坏的模拟，或者撤销迁移。
nova migration-listnova server-migration-show 29a58cf7-646a-43f2-b1d6-89ec421fc9d6 152nova live-migration-abort 29a58cf7-646a-43f2-b1d6-89ec421fc9d6 152

后记从以上结果可以看出，在OpenStack中选择VM进行迁移的时候，为了提高迁移的效率，有以下几个结论：（1）选择更小的flavor，能够减少迁移时间和迁移数据量。（2）基本不用考虑CPU使用率，因为它对迁移影响很小。（3）选择内存占用小的VM，能够减少迁移时间、停机时间和迁移数据量。（4）选择磁盘写入进程较少的VM，能够减少迁移时间、停机时间和迁移数据量。（5）包延迟会稍微增加迁移时间，对停机时间和迁移数据量的影响很小。（6）丢包会急剧增加迁移时间，对停机时间和迁移数据量的影响很小。（7）包重复会增加一些迁移数据量，但是对迁移时间和迁移停机时间的影响很小。（8）包损坏率小于等于3%时，对迁移影响较少，可以忽略。包损坏率大于4%之后，迁移时间和停机时间会急剧上升。包损坏率大于7%时，已经无法迁移成功。
至此，实验完成，数据有了，就差论文了！加油加油！
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>测试</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机在线迁移实验</title>
    <url>/dev-openstack-vm-live-migration-experiment/</url>
    <content><![CDATA[前言《虚拟机在线迁移的性能统计》解决了性能统计的问题，《虚拟机在线迁移过程中的故障注入》解决了环境模拟的问题。接下来我们进行一些虚拟机迁移实验，收集不同环境下迁移过程中产生的性能统计数据。
共享存储和非共享存储的虚拟机迁移，性能差别很大。本次实验，在共享存储的条件下进行。对于非共享存储的虚拟机迁移实验，放在其他文章中记录。


实例准备《OpenStack中虚拟机的在线迁移》和《OpenStack中共享存储的虚拟机在线迁移》两篇文章中，使用cirros作为迁移对象；本次实验中，使用ubuntu16作为迁移对象，因为这样可以更方便地注入故障，实例创建参考《OpenStack添加镜像》和《Ubuntu16手动安装OpenStack——创建实例》。
1、在horizon控制台，项目，计算，镜像。使用xenial-server-cloudimg-amd64-disk1.img镜像创建ubuntu16的镜像模板。
2、使用ubuntu16的镜像模板创建实例ubuntu0，实例类型选择m1.small，配置为1核2G内存20G存储。
3、创建成功后，分配浮动IP。本次分配的浮动IP为10.0.2.154。
4、登录ubuntu0实例，安装stress-ng，方便接下来的实验。
正常虚拟机迁移1、controller节点ping实例并记录sudo ping 10.0.2.154 -i 0.01 &gt;&gt; ping.log
2、在compute和compute2节点，都启动iptraf，监听49152 to 49261。
3、在控制节点执行迁移命令nova live-migration ubuntu0 compute2
4、查看是否迁移完成nova show ubuntu0
5、迁移完成后进行统计。（1）在compute节点执行time.sh，得到总的迁移时间，22s。（2）在controller执行downtime.sh，计算downtime，6.28s。（3）根据iptraf的监听结果，得到迁出和迁入的数据量，283M，248M。
downtime不合理！为什么这么久？理论上是毫秒级的哇！参考《详解openstack下热迁移机制》，发现OpenStack可以进行迁移的参数设置，downtime可以进行调节。查看迁移日志：grep downtime /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log发现日志中显示的downtime都是固定的50ms，每次迁移只有一次停机。感觉挺复杂的样子，先不管它，按照默认设置来实验吧。
取消迁移如果虚拟机迁移失败，可以取消迁移。
1、查看迁移任务nova server-migration-list ubuntu0该命令查看到迁移任务的ID为12。
2、查看迁移过程nova server-migration-show ubuntu0 12
3、取消迁移nova live-migration-abort ubuntu0 12
CPU故障1、在ubuntu0实例中创建一个CPU进程，CPU占用率10%stress-ng -c 1 -l 10使用top可以看到，CPU占用率不稳定，stress-ng进程偶尔跳到最高，占用率10%到90%不等。
2、实例迁移，得到总的迁移时间，34s。
3、设置CPU占用率分别为20%、30%到100%，统计结果如下：
| CPU占用率 | 迁移时间 | 停机时间 | 迁出数据量 | 迁入数据量 || —– | —– | —– | —– | —– | —– || 0%  | 18s | 6.28s | 283M | 248M || 10% | 20s | 6.53s | 353M | 341M || 20% | 19s | 4.52s | 323M | 300M || 30% | 20s | 4.58s | 354M | 338M || 40% | 21s | 4.62s | 336M | 347M || 50% | 20s | 5.41s | 355M | 323M || 60% | 19s | 4.54s | 303M | 309M || 70% | 21s | 5.24s | 356M | 355M || 80% | 19s | 4.41s | 351M | 338M || 90% | 17s | 7.31s | 328M | 362M || 99% | 19s | 5.77s | 351M | 348M |
内存故障1、在实例中创建一个100M的内存进程stress-ng --vm 1 --vm-bytes 100M --vm-keep使用free -h，可以看到内存被使用掉了100M。
2、虚拟机迁移，得到总的迁移时间，22s。
3、设置内存进程分别占用300M、600M到1.5G，统计结果如下：
| 内存占用 | 迁移时间 | 停机时间 | 迁出数据量 | 迁入数据量 || —– | —– | —– | —– | —– | —– || 100M | 22s | 7.63s | 501M | 653M || 300M | 29s | 7.88s | 1238M | 1159M || 600M | 26s | 7.72s | 1341M | 1279M || 900M | 78s | 8.31s | 5572M | 6155M || 1200M | 92s | 8.14s | 8208M | 8070M || 1500M | 102s | 8.47s | 8396M | 9088M |
IO故障1、在实例中创建一个IO进程stress-ng --io 1使用iostat -d -k 2查看IO状态，发现tps稳定在200以上，而磁盘读写都为0。使用top命令可以看到，CPU占用率很高，在90%上下。
2、在实例中创建1-10个IO进程，统计结果如下：
| IO进程数 | 迁移时间 | 停机时间 | 迁出数据量 | 迁入数据量 || —– | —– | —– | —– | —– | —– || 1 | 37s | 7.59s | 2067M | 1954M || 2 | 40s | 6.83s | 2032M | 2007M || 3 | 36s | 7.04s | 2071M | 1788M || 4 | 36s | 8.08s | 1846M | 1969M || 5 | 36s | 6.02s | 2074M | 2012M || 6 | 35s | 7.44s | 1805M | 2032M || 7 | 36s | 5.64s | 2066M | 2010M || 8 | 36s | 8.60s | 1972M | 1987M || 9 | 34s | 10.95s | 2064M | 1880M || 10 | 36s | 7.02s | 1865M | 1981M |
磁盘故障1、在虚拟机中创建一个写入进程stress-ng -d 1使用iostat -d -k 2查看IO状态，发现tps在30上下，kB_wrtn/s在30000上下。使用top命令可以看到，CPU占用率在25%到99%浮动。
2、在实例中创建1-10个写入进程，统计结果如下：
| 写入进程数 | 迁移时间 | 停机时间 | 迁出数据量 | 迁入数据量 || —– | —– | —– | —– | —– | —– || 1 | 35s | 4.83s | 2059M | 2023M || 2 | 37s | 8.70s | 1874M | 1957M || 3 | 34s | 8.92s | 2055M | 1980M || 4 | 36s | 4.97s | 2024M | 1959M || 5 | 36s | 5.50s | 2055M | 1960M || 6 | 35s | 4.64s | 2025M | 1957M || 7 | 34s | 6.02s | 2055M | 2041M || 8 | 43s | 9.11s | 2009M | 1978M || 9 | 35s | 6.60s | 2069M | 1997M || 10 | 34s | 8.89s | 1931M | 1942M | 
网络延迟1、在compute节点（迁出节点）添加网络延迟10mstc qdisc add dev eth0 root netem delay 10ms注：原本的延迟在0.5ms上下。
2、将网络延迟修改为20ms-100mstc qdisc replace dev eth0 root netem delay 20ms
统计结果如下：
| 延迟时间 | 迁移时间 | 停机时间 | 迁出数据量 | 迁入数据量 || —– | —– | —– | —– | —– | —– || 10ms | 28s | 10.43s | 325M | 307M || 20ms | 36s | 8.80s | 305M | 287M || 30ms | 38s | 5.73s | 344M | 305M || 40ms | 43s | 11.28s | 305M | 290M || 50ms | 44s | 6.81s | 240M | 292M || 60ms | 47s | 7.09s | 256M | 295M || 70ms | 52s | 14.48s | 303M | 292M || 80ms | 50s | 12.17s | 242M | 297M || 90ms | 51s | 11.37s | 249M | 297M || 100ms | 63s | 18.22s | 298M | 344M |
在延迟时间大于100ms后，迁移显示成功，实例状态active，但是无法ping通实例。
取消模拟：tc qdisc del dev eth0 root
丢包1、两个计算节点，都模拟丢包率1%tc qdisc add dev eth0 root netem loss 1%
2、将模拟丢包率修改为2%-10%tc qdisc change dev eth0 root netem loss 2%
统计结果如下：
| 丢包率 | 迁移时间 | 停机时间 | 迁出数据量 | 迁入数据量 || —– | —– | —– | —– | —– | —– || 0.5% | 20s | 8.55s | 295M | 330M || 1% | 31s | 11.24s | 301M | 249M || 1.5% | 29s | 7.44s | 335M | 313M || 2% | 28s | 11.62s | 261M | 299M || 2.5% | 40s | 10.34s | 300M | 325M || 3% | 43s | 15.19s | 306M | 268M |
在丢包率大于3%后，迁移显示成功，实例状态active，但是无法ping通实例。
取消模拟：tc qdisc del dev eth0 root
包重复1、两个计算节点，都模拟包重复率1%tc qdisc add dev eth0 root netem duplicate 1%随机产生 1% 重复的包。
2、将模拟包重复率修改为2%-10%-100%tc qdisc change dev eth0 root netem duplicate 2%
统计结果如下：
| 包重复率 | 迁移时间 | 停机时间 | 迁出数据量 | 迁入数据量 || —– | —– | —– | —– | —– | —– || 1% | 18s | 4.82s | 288M | 283M || 2% | 21s | 4.06s | 308M | 288M || 3% | 18s | 8.02s | 249M | 309M || 4% | 21s | 6.37s | 316M | 300M || 5% | 19s | 4.70s | 314M | 307M || 6% | 18s | 4.18s | 285M | 316M || 7% | 21s | 3.81s | 324M | 315M || 8% | 18s | 7.60s | 305M | 234M || 9% | 21s | 6.87s | 328M | 316M || 10% | 18s | 7.71s | 310M | 317M || 20% | 21s | 11.24s | 360M | 347M || 30% | 19s | 9.90s | 381M | 388M || 40% | 22s | 6.67s | 429M | 376M || 50% | 18s | 4.43s | 445M | 434M || 60% | 24s | 8.04s | 499M | 438M || 70% | 19s | 11.30s | 488M | 518M || 80% | 25s | 5.61s | 581M | 485M || 90% | 29s | 5.08s | 745M | 646M || 100% | 21s | 7.89s | 706M | 727M |
取消模拟：tc qdisc del dev eth0 root
包损坏1、两个计算节点，都模拟包损坏率1%tc qdisc add dev eth0 root netem corrupt 1%随机产生 1% 损坏的报文（在报文的随机位置造成一个比特的错误）。
在ping的时候会报错：Warning: time of day goes back , taking countermeasures，不过没关系，不影响我们的停机时间统计结果。
2、将模拟丢包率修改为2%-10%tc qdisc change dev eth0 root netem corrupt 2%
| 包损坏率 | 迁移时间 | 停机时间 | 迁出数据量 | 迁入数据量 || —– | —– | —– | —– | —– | —– || 0.5% | 20s | 4.43s | 359M | 369M || 1% | 24s | 5.90s | 371M | 351M || 1.5% | 30s | 12.13s | 374M | 357M || 2% | 32s | 9.09s | 331M | 362M || 2.5% | 42s | 7.49s | 345M | 337M || 3% | 48s | 13.46s | 378M | 374M |
迁移成功率随着包损坏率的增加而降低，包损坏率大于3%之后，基本不会成功。会停留在迁移状态，每秒几K传输。
取消模拟：tc qdisc del dev eth0 root
后记至此，完成了系统故障对于OpenStack虚拟机在线迁移过程中的性能影响的实验。实验数据和预期差别很大，比如停机时间量级不合理，比如停机时间基本上不受系统故障影响，比如迁移成功后却出现无法ping通的现象等等。
后续任务有两个，一是需要进行共享存储的虚拟机在线迁移实验，用于对比。二是尝试进行调参，把停机时间调整到毫秒级。
再进一步的话，可以研究下虚拟机迁移成功后无法ping通的原因，还可以研究下同样故障下虚拟机迁移时而成功时而失败的原因。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>测试</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>虚拟机在线迁移的性能统计</title>
    <url>/dev-openstack-vm-live-migration-performance/</url>
    <content><![CDATA[前言OpenStack中共享存储和非共享存储的虚拟机迁移环境都已经搭建完成，接下来可以进行实验了。对于不同的宿主机、不同的实例、不同的负载，虚拟机迁移的性能也会有所不同。那么，虚拟机迁移的性能指标有哪些？又该怎样统计呢？本文就来研究一下。


性能指标参考论文《Virt-LM: a benchmark for live migration of virtual machine》，可以得知，虚拟机迁移过程中的主要性能指标有四个：

整体迁移时间：从迁移开始到迁移结束的时间。
虚拟机停机时间：迁移过程中虚拟机停机（停止服务）的时间。
迁移数据量：在虚拟机迁移期间传输的数据总量。
应用程序的性能：迁移过程中对虚拟机中应用程序产生的影响。

测量方法监控既然是实验，那么肯定要收集实验过程中的数据。郝同学给这个四个节点的OpenStack集群安装了ganglia，用来监控各种指标。但是，ganglia更适合监控实时数据和观察变化，不适合进行统计。
迁移时间整体迁移时间怎么测出来？通过观察图表？不靠谱。叶可江老师提供了思路，整体迁移时间的话，可以通过日志来获取：tail -n 40 /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log
通过查看迁出宿主机的日志，然后对比ganglia图表，可以找到两个关键节点：
2018-11-22 09:59:42.442 5 INFO nova.virt.libvirt.migration [req-d9849256-eaa8-4446-9cec-9545b74df126 202e7852a6074540a70638eed185538e eb83bf3b057f45e1b386cbc8c0702ae1 - default default] [instance: eebe068a-ba85-4905-a39b-f003a7480b14] Increasing downtime to 50 ms after 0 sec elapsed time......2018-11-22 10:00:02.984 5 INFO nova.compute.manager [req-4b409237-6c82-4b56-ae4c-9f905a4f932e b2edc935f89d4d2684ec4039c02a21cc ab7e3eb8c00d4299afd8572e1ec437bf - default default] [instance: eebe068a-ba85-4905-a39b-f003a7480b14] VM Stopped (Lifecycle Event)
但是，依然需要手动来计算迁移时间，很麻烦，那就写一个脚本来搞定吧！参考linux shell 时间运算以及时间差计算方法。
#!/bin/bashtime1=`grep nova.virt.libvirt.migration /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log | tail -n 1 |awk '&#123;print $2&#125;'`;time2=`grep 'VM Stopped' /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log | tail -n 1 | awk '&#123;print $2&#125;'`;# 计算时间差time=$(($(date +%s -d $time2) - $(date +%s -d $time1)));echo "$time s";
以上脚本，保存为time.sh，并添加执行权限。
另外，还可以通过nova migration-list &gt; list.log查看到迁移的开始时间和结束时间。然后通过脚本计算迁移时间：
#!/bin/bashtime1=`grep 'live-migration' list.log | head -n 1 | awk '&#123;print $24&#125;'`time2=`grep 'live-migration' list.log | head -n 1 | awk '&#123;print $26&#125;'`time=$(($(date +%s -d $time2) - $(date +%s -d $time1)));echo "$time s";
不过，这种方法测出的迁移时间，比我们从nova-compute.log日志中测出的迁移时间，要多出7秒左右。这种方法应该更准确一些，毕竟是OpenStack自己记录的。
停机时间参考How to measure Migration time and Down time，使用ping命令来测量停机时间。
我们的虚拟机有两个IP，一个是内网IP，一个是浮动IP。外部机器可以直连的，一般是浮动IP，所以在迁移过程中，建议ping浮动IP，比如sudo ping 10.0.2.159 -i 0.01 &gt;&gt; ping.log。ping.log中的信息为：
PING 10.0.2.159 (10.0.2.159) 56(84) bytes of data.64 bytes from 10.0.2.159: icmp_seq=1 ttl=63 time=3.40 ms64 bytes from 10.0.2.159: icmp_seq=2 ttl=63 time=1.15 ms64 bytes from 10.0.2.159: icmp_seq=3 ttl=63 time=1.17 ms64 bytes from 10.0.2.159: icmp_seq=4 ttl=63 time=1.33 ms......64 bytes from 10.0.2.159: icmp_seq=4139 ttl=63 time=1.17 ms64 bytes from 10.0.2.159: icmp_seq=4140 ttl=63 time=1.05 ms64 bytes from 10.0.2.159: icmp_seq=4141 ttl=63 time=1.12 ms64 bytes from 10.0.2.159: icmp_seq=4142 ttl=63 time=1.06 ms--- 10.0.2.159 ping statistics ---4142 packets transmitted, 3668 received, 11% packet loss, time 44127msrtt min/avg/max/mdev = 0.580/1.412/36.648/1.407 ms, pipe 3

由统计信息可以求出停机时间：
# 方法一：(缺失的icmp_seq总数)*(时间间隔)(4142-3668)*0.01=4.74s# 方法二：(总时间)*(icmp_seq缺失百分比)(44127/1000)*0.11 = 4.85s

两种方法相差0.1s，方法一更精确一些。如果想要更加精确，还可以把ping命令的时间间隔调整为1ms。
方法一写成脚本为：
#!/bin/bashtransmitted=`grep 'packets transmitted' ping.log | tail -n 1 | awk '&#123;print $1&#125;'`received=`grep 'packets transmitted' ping.log | tail -n 1 | awk '&#123;print $4&#125;'`lost=`expr $transmitted - $received`# echo "downtime is $lost ms"downtime=$(echo "scale=3; $lost / 1000" | bc)echo "downtime is $downtime s"

方法二写成脚本为：
#!/bin/bashtime_str=`grep 'packets transmitted' ping.log | tail -n 1 | awk '&#123;print $10&#125;'`loss_str=`grep 'packets transmitted' ping.log | tail -n 1 | awk '&#123;print $6&#125;'`time_num=`echo $&#123;time_str%ms&#125;`loss_percent=`echo $&#123;loss_str%\%&#125;`# downtime = (time_num)*(loss_percent/100)/1000num=`expr $time_num \* $loss_percent`downtime=$(echo "scale=3; $num / 100000" | bc)echo "downtime is $downtime s"

以上方法求出的停机时间，是总的停机时间，无论迁移过程中有几次停机，该方法都是适用的。我们会好奇，实际迁移过程中，停机是否只有一次？我们写一个脚本来寻求答案：
#!/bin/bash# 去掉头部和尾部，保留第五列cat ping.log | sed '1d' | tac | sed '1,4d' | tac | awk '&#123;print $5&#125;' &gt; seq.log &amp;&amp;# 得到最后一行的序列号max=`tail -n 1 seq.log | awk -F '=' '&#123;print $2&#125;'`# 所有序列号赋值给数组array_str=`cat seq.log | awk -F '=' '&#123;print $2&#125;'`IPS=' 'array=($array_str)# 打印没有响应的序列号COUNTER=0while [ $COUNTER -lt $max ]do    COUNTER=`expr $COUNTER + 1`    if [[ "$&#123;array[@]&#125;" =~ $COUNTER ]]    then        continue    else        echo $COUNTER  &gt;&gt; result.log    fidone &amp;&amp;# 对比seq数量start=`head -n 1 result.log`end=`tail -n 1 result.log`num=`expr $end - $start + 1`echo "if continuous, num should be $num"result_str=`cat result.log`IPS='\n'result=($result_str)echo "real num is $&#123;#result[@]&#125;"

脚本输出两个474，说明实例没有响应的序列号是连续的，证明了停机只有一次。比如result.log中为{3,4,5,6,7}，那么7-3+1=5，集合中元素个数也为5，证明连续。比如result.log中为{3,4,5,10,11}，那么11-3+1=9，集合中元素个数为5，证明不连续。
带宽测量出的downtime为4.74s，很不合理，因为虚拟机迁移理论上的停机时间是毫秒级的！是因为带宽太低导致停机时间过长吗？可以用如下方法进行测试：1、compute1和compute2上都安装iperfsudo apt install iperf
2、compute1上启动iperf服务iperf -s
3、compute2上启动iperf客户端iperf -c 192.168.56.112 -i 1
迁移数据量对于迁移数据量，可以使用iptables对端口进行监控，参考Linux下对端口流量进行统计和Linux 使用iptables进行shadowsocks流量统计。但是，计算节点网络非常复杂，郝同学不想对其进行修改，所以采用另外一种方案，iptraf，参考使用iptraf查看TCP/UDP某个特定端口的带宽与流量。
1、两个计算节点安装iptrafsudo apt install iptraf
需要注意的是，iptraf只支持名为ethX的网卡。想要显示enoX、enp0sX网卡，要么网卡重命名，要么安装使用iptraf-ng。sudo apt install iptraf-ng
2、启动iptrafsudo iptraf启动后，进入到一个字符界面。
3、设置Configure… -&gt; Additional ports…-&gt; 22 -&gt; Exit Configuration -&gt; Statistical breakdowns… -&gt; By TCP/UDP port -&gt; eth0 -&gt; statistic view
参考Configure live migrations，可以得知：

By default, libvirt uses the TCP port range from 49152 to 49261 for copying memory and disk contents. Compute hosts must accept connections in this range.

所以在实际使用的时候，端口设置为49152 to 49261。重新进入统计页面，之前的统计数据会清零。
应用性能Web应用的性能，主要包括执行时间、传输速度、吞吐量、资源占用率。
基准测试（benchmarking）是一种测量和评估软件性能指标的活动。你可以在某个时候通过基准测试建立一个已知的性能水平（称为基准线），当系统的软硬件环境发生变化之后再进行一次基准测试以确定那些变化对性能的影响。这是基准测试最常见的用途。其他用途包括测定某种负载水平下的性能极限、管理系统或环境的变化、发现可能导致性能问题的条件，等等。详情参考什么是基准测试？。
对于性能的监控，最简单的思路是Apache Benchmark。使用ab来监控Web服务的性能，检查迁移过程中会发生哪些变化。但是，ab什么时候运行？什么时候停止？请求多少次？怎么计算迁移过程中的平均性能？这些都不能确定。如果使用cAdvisor+prometheus呢？参考linux工匠之docker和kubernetes的监控(cadvisor+prometheus)。不行，因为这种方法监控的是docker容器，收集的是CPU、内存等数据，而不是Web性能数据。使用SPEC？也不好，收费，安装使用复杂。
很绝望，前辈们都是怎么进行测试的？不管了，先不考虑应用性能指标。
书签An analysis of the performance of live migration in Openstack
An analysis of the performance of block live migration in Openstack
Performance analysis of “post-copy” live migration in Openstack
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>测试</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Open vSwitch进行VxLAN隧道实验</title>
    <url>/dev-openvswitch-vxlan/</url>
    <content><![CDATA[前言为了加深对VxLAN网络模式的理解，郝同学打算使用Open vSwitch进行VxLAN隧道实验。主要参考搭建基于Open vSwitch的VxLAN隧道实验和基于Open vSwitch的VxLAN隧道实验网络。


虚拟机准备使用VirtualBox创建两个虚拟机，主机名分别为controller和compute，系统均为ubuntu-16.04.4-server-amd64。
这两台虚拟机，都有两块网卡。eth0负责主机间相互通信，eth1负责上网。controller的eth0的IP为192.168.56.110，compute的eth0的IP为192.168.56.111。controller和compute可以互相ping通。
安装openvswitch通过源码安装参考Open vSwitch on Linux, FreeBSD and NetBSD，这里我们不使用源码安装，而是使用apt包管理工具直接安装，参考Debian安装openvswitch。
一条命令搞定：
apt -y install  openvswitch-switch openvswitch-common openvswitch-switch-dpdk

实验一目标如上图，分别给两台虚拟机的br1指定两个 相同网段 的ip，然后通过搭建VXLAN隧道让这两个不同机器的网桥能够实现通信。
controller1、在controller上添加br0和br1两个网桥
ovs-vsctl add-br br0ovs-vsctl add-br br1

2、查看网桥ovs-vsctl show
3、在br0上添加一个端口，将eth0挂载到br0上。这样做的目的是方便我们在虚拟网桥上添加多个端口供我们使用，这样不必受限于eth0的有限端口。ovs-vsctl add-port br0 eth0
4、此时我们将原先eth0分配的ip清除并指定给br0，让虚拟机网络能通过br0继续工作。
ifconfig eth0 0 upifconfig br0 192.168.56.110/24 up

5、根据实际情况配置一下br0的网关（可选）。route add default gw 192.168.56.1 br0
6、给网桥br1分配一个ip。ifconfig br1 172.16.0.1/24 up
7、查看ipifconfig
ip永久生效以上ip配置，在重启后会失效，要想永久有效，需要修改interfaces配置。vim /etc/network/interfaces，如下修改：
auto eth0iface eth0 inet manualup ifconfig $IFACE 0.0.0.0 upup ifconfig $IFACE promiscauto eth1iface eth1 inet dhcpauto br0iface br0 inet staticaddress 192.168.56.110netmask 255.255.255.0auto br1iface br1 inet staticaddress 172.16.0.1netmask 255.255.255.0

compute1、在compute上添加br0和br1两个网桥
ovs-vsctl add-br br0ovs-vsctl add-br br1

2、在br0上添加一个端口，将eth0挂载到br0上。这样做的目的是方便我们在虚拟网桥上添加多个端口供我们使用，这样不必受限于eth0的有限端口。ovs-vsctl add-port br0 eth0
3、此时我们将原先eth0分配的ip清除并指定给br0，让虚拟机网络能通过br0继续工作。
ifconfig eth0 0 upifconfig br0 192.168.56.111/24 up

4、根据实际情况配置一下br0的网关（可选）。route add default gw 192.168.56.1 br0
5、给网桥br1分配一个ip。ifconfig br1 172.16.0.2/24 up
搭建VxLAN隧道1、在controller查看连通性
ping 192.168.56.111 -c3ping 172.16.0.2 -c3
上图可以看到，controller可以ping通过192.168.56.111，却ping不通172.16.0.2。
2、在controller上设置VxLAN，远端ip设置为compute能对外通信的br0的ip。
ovs-vsctl add-port br1 vx1 -- set interface vx1 type=vxlan options:remote_ip=192.168.56.111

此时，依然ping不通172.16.0.2。
3、在compute上设置VxLAN，远端ip设置为controller能对外通信的br0的ip。
ovs-vsctl add-port br1 vx1 -- set interface vx1 type=vxlan options:remote_ip=192.168.56.110

4、在controller上验证VxLAN隧道ping 172.16.0.2 -c3如上图，controller的br1和compute的br1已经连通，实验成功。
实验二目标如上图，分别给两台虚拟机的br1指定两个 不同网段 的ip，然后通过搭建VXLAN隧道让这两个不同网段的网桥能够实现通信。
搭建VxLAN隧道紧接着实验一，我们已经创建了VxLAN隧道，controller和compute在172.16.0.0/24网段可以相互ping通。
1、在compute上修改ip为其他网段ifconfig br1 172.16.1.1/24 up
2、在controller上验证VxLAN隧道ping 172.16.1.1 -c3如上图，controller无法连通compute，这是因为，不通网段间的通信需要路由。
3、在controller上设置路由route add -net 172.16.1.0/24 gw 172.16.0.1 dev br1
4、在compute上设置路由route add -net 172.16.0.0/24 gw 172.16.1.1 dev br1
5、再次在controller上验证VxLAN隧道ping 172.16.1.1 -c3如上图，controller的br1和compute的br1已经连通，实验成功。
路由永久生效以上路由配置，在重启后会失效，要想永久有效，需要修改interfaces配置。controller上，vim /etc/network/interfaces，添加：
up route add -net 172.16.1.0/24 gw 172.16.0.1 dev br1

compute上，vim /etc/network/interfaces，添加：
up route add -net 172.16.0.0/24 gw 172.16.1.1 dev br1

实验三目标紧接着实验二，问题来了，两个虚拟机之间可以创建VxLAN隧道，那么三个虚拟机之间该怎么处理？本实验，就要在三个虚拟机之间建立XxLAN隧道，实现通信。
ip配置参照实验一：controller的br0配置ip为192.168.56.110/24，br1配置ip为172.16.0.1/24。compute1的br0配置ip为192.168.56.111/24，br1配置ip为172.16.1.1/24。compute2的br0配置ip为192.168.56.112/24，br1配置ip为172.16.2.1/24。
搭建VxLAN隧道1、在controller上设置VxLAN，远端ip设置为compute1和compute2能对外通信的br0的ip。
ovs-vsctl add-port br1 vx1 -- set interface vx1 type=vxlan options:remote_ip=192.168.56.111ovs-vsctl add-port br1 vx2 -- set interface vx2 type=vxlan options:remote_ip=192.168.56.112

2、在compute1上设置VxLAN，远端ip设置为controller能对外通信的br0的ip。
ovs-vsctl add-port br1 vx1 -- set interface vx1 type=vxlan options:remote_ip=192.168.56.110

3、在compute2上设置VxLAN，远端ip设置为controller能对外通信的br0的ip。
ovs-vsctl add-port br1 vx1 -- set interface vx1 type=vxlan options:remote_ip=192.168.56.110

5、在controller上添加路由
route add -net 172.16.0.0/16 gw 172.16.0.1 dev br1

6、在compute1上添加路由route add -net 172.16.0.0/16 gw 172.16.1.1 dev br1
7、在compute2上添加路由route add -net 172.16.0.0/16 gw 172.16.2.1 dev br1
8、在controller测试连通compute1和compute2
ping 172.16.1.1 -c3ping 172.16.2.1 -c3
神奇的事情发生了，可以ping通172.16.1.1的时候，172.16.2.1不通；可以ping通172.16.2.1的时候，172.16.1.1不通。这是因为，在完成实验二后，郝同学直接复制了compute虚拟机作为compute2，结果导致两台虚拟机的br1的mac地址相同。compute2删除br1重建，问题解决。
9、在compute1测试连通compute2ping 172.16.2.1 -c3此时，compute1和compute2的br1已经连通。由上面的配置我们知道，它们之间并没有建立直接隧道，而是通过controller进行转发。
有意思的是，使用traceroute查看路由，发现它们连接时并没有经过网关（compute1的172.16.1.1和controller的172.16.0.1），而是直连。
traceroute 172.16.2.1traceroute 172.16.2.1 -I

后记至此，使用Open vSwitch进行VxLAN隧道实验完成。三个实验都比较基础，至于更高级的实验，以后再研究，比如在br1网桥上连接cirros虚拟机、添加tun/tap设备、添加veth设备等。
书签Vxlan学习笔记——原理
最详细的Vlan原理介绍
SDN与OpenFlow技术简介
OpenStack网络实战系列一：通过Openvswitch实践了解交换机的基本概念和操作
Open vSwitch使用案例扩展实验
TAP 设备与 VETH 设备
Linux虚拟网络设备之tun/tap
Linux虚拟网络设备之veth
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统课设</title>
    <url>/dev-os-curriculum-design/</url>
    <content><![CDATA[选题：文件管理系统每个同学，必须完成两个题目，以下是我的两个选题。
1、银行家算法的模拟掌握死锁相关的概念和解决方案，理解银行家算法的工作原理，设计合适的数据结构和算法，模拟实现银行家算法。
2、一个简单文件管理器的实现掌握操作系统关于文件管理的各种原理，熟悉常用的文件操作，编写程序实现文件的常规操作。
对于选题1，找到了前辈的作品，改一改，验收！当然，被老师吐槽一顿是难免的。
对于选题2，文件管理系统，这个就有意思了，借鉴了大神cattong 的思路，下面和大家讨论下。

语言：Java编程三年，个人感觉，最友好的语言就是Java了。本次课设，毫无争议选择了Java。
设计思路界面很简洁的界面，上面输入命令，下面显示结果。废话不多说，上代码！
package com.voidking.file;import java.awt.BorderLayout;import java.awt.FlowLayout;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTextArea;import javax.swing.JTextField;public class MainFrame extends JFrame &#123;	public static void main(String[] args) &#123;				MainFrame thisClass = new MainFrame();		thisClass.setVisible(true);	&#125;		public MainFrame() &#123;		super();		initialize();	&#125;		private void initialize() &#123;		this.setTitle("资源管理");		this.setSize(500, 400);		this.setLocationRelativeTo(null);		this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);		contentPane = new JPanel();		contentPane.setLayout(new BorderLayout());		contentPane.add(getCmdPane(), BorderLayout.NORTH);		contentPane.add(getEchoArea(), BorderLayout.CENTER);		this.add(contentPane);		cmd = new Command(this);		display("C:&gt;");	&#125;	private static final long serialVersionUID = 1L;	private JPanel contentPane = null;	private JPanel cmdPane = null;	private JLabel jLabel = null;	private JTextField cmdText = null;	private JTextArea echoArea = null;	private JScrollPane areaScroll = null;	private Command cmd = null;	private JPanel getCmdPane() &#123;		if (cmdPane == null) &#123;			jLabel = new JLabel();			jLabel.setText("命 令 行:");			cmdPane = new JPanel();			cmdPane.setLayout(new FlowLayout());			cmdPane.add(jLabel, null);			cmdPane.add(getCmdText(), null);		&#125;		return cmdPane;	&#125;	private JTextField getCmdText() &#123;		if (cmdText == null) &#123;			cmdText = new JTextField();			cmdText.setColumns(25);			// 添加键盘监听事件;			cmdText.addKeyListener(new java.awt.event.KeyAdapter() &#123;				public void keyTyped(java.awt.event.KeyEvent e) &#123;				&#125;								public void keyPressed(java.awt.event.KeyEvent e) &#123;					if (e.getKeyCode() == 10) &#123;						// 对文本进行处理;						cmd.operate(cmdText.getText().trim());					&#125;				&#125;			&#125;);		&#125;		return cmdText;	&#125;	private JScrollPane getEchoArea() &#123;		if (echoArea == null) &#123;			echoArea = new JTextArea();			echoArea.setEditable(false);			areaScroll = new JScrollPane();			areaScroll.setViewportView(echoArea);		&#125;		return areaScroll;	&#125;	// 在回显框显示结果;	public void display(String str) &#123;		echoArea.append(str + "\n");		echoArea.setCaretPosition(echoArea.getText().length());		cmdText.setText("");	&#125;&#125;
命令处理在界面初始化函数initialize()中，我们创建了一个Command类的实例：cmd对象。然后，在getCmdText()函数中监听文本框中的内容，调用cmd对象的函数进行处理。
Command类，封装了所有的命令处理函数。结构简单明了，不多解释，直接上代码！
package com.voidking.file;import java.awt.Desktop;import java.io.File;public class Command &#123;	private String currentPath;	private MainFrame mainFrame = null;	private final String cmd[] = &#123; "cd", "dir", "mkdir", "rmdir", "mkfile", "rmfile",			"exit" ,"mkpath","open"&#125;;	private final int cmdInt[] = &#123; 1, 2, 3, 4, 5, 6, 7 ,8,9&#125;;	Command(MainFrame mainFrame) &#123;		currentPath = "C:";		this.mainFrame = mainFrame;	&#125;	public String[] separate(String operation) &#123;		String[] str = operation.split(" ");		//主要解决文件夹或文件中含有空格的情况;		if(str.length&gt;2)&#123;			String[] tempStr=new String[2];			tempStr[0]=str[0];			tempStr[1]=str[1];			for(int i=2;i&lt;str.length;i++)				tempStr[1]+=" "+str[i];			return tempStr;		&#125;		return str;	&#125;	/*	 * 根据参数operation执行相应的操作;	 */	public void operate(String operation) &#123;		String[] str = separate(operation);		String mycmd = "";		int mycmdInt = 0;		String path = "";		if (str.length == 1) &#123;			mycmd = str[0];			//切换盘符			if (mycmd.indexOf(":") != -1) &#123;				File newFile = new File(mycmd);				if (newFile.exists()) &#123;					currentPath = mycmd;					mainFrame.display(getPath());					return;				&#125;			&#125;		&#125;		if (str.length &gt;= 2) &#123;			mycmd = str[0];			path = str[1];		&#125;		for (int i = 0; i &lt; cmd.length; i++) &#123;			if (mycmd.equalsIgnoreCase(cmd[i])) &#123;				mycmdInt = cmdInt[i];			&#125;		&#125;				switch (mycmdInt) &#123;		case 1:			cd(currentPath, path);			break;		case 2:			dir(currentPath);			break;		case 3:			mkdir(path);			break;		case 4:			rmdir(path);			break;		case 5:			mkfile(path);			break;		case 6:			rmfile(path);			break;		case 7:			exit();			break;		case 8:			mkpath(path);			break;		case 9:			open(path);			break;					default:			mainFrame.display("无效的命令!");		&#125;		mainFrame.display(getPath());	&#125;	/*	 * 获得当前所在目录;	 */	public String getPath() &#123;		return currentPath + "&gt;";	&#125;	/*	 * 获得路径path下的文件;	 */	public String[] listAll(String path) &#123;				try &#123;			File f = new File(path);			String[] fileName;			if (f.isDirectory()) &#123;				fileName = f.list();				mainFrame.display("共有" + fileName.length + "个文件");				for (int i = 0; i &lt; fileName.length; i++)					mainFrame.display("    " + fileName[i]);				return fileName;			&#125; else if (f.isFile()) &#123;				mainFrame.display("这是一个文件");				return null;			&#125; else &#123;				//System.out.println(path);				return null;			&#125;		&#125; catch (Exception e) &#123;			return null;		&#125;	&#125;    public String[] listDirectory(String path)&#123;    	File f = new File(path);		String[] fileName;		if (f.isDirectory()) &#123;			fileName = f.list();			//for (int i = 0; i &lt; fileName.length; i++)				//System.out.println("/"+fileName[i]);			return fileName;		&#125; else &#123;			//System.out.println(path+"是文件");			return null;		&#125;    &#125;	/*	 * 判断这个路径是否正确;	 */	public boolean isRightPath(String path) &#123;		File file = new File(path);		if (file.isDirectory() || file.isFile())			return true;		else			return false;	&#125;	/*	 * 进行cd操作;cd&lt;目录名&gt; 功能:进入下一个目录;	 */	public void cd(String path, String file) &#123;		String temp = path + "\\" + file;		if (!isRightPath(temp)) &#123;			mainFrame.display("没有找到这个文件夹");		&#125; else &#123;			if (!file.equals(""))				currentPath += "\\" + file;		&#125;	&#125;	/*	 * 进行dir操作;dir [&lt;目录名&gt;] 功能: 显示目录下的所有文件;	 */	public void dir(String path) &#123;		if (path != null)			listAll(path);	&#125;	/*	 * mkdir &lt;目录名&gt; 功能: 创建新目录	 */	public void mkdir(String directory) &#123;		if (!currentPath.equals("")) &#123;			String temp = currentPath + "\\" + directory;			File newFile = new File(temp);			if (!newFile.exists()) &#123;				try &#123;					if (newFile.isDirectory() == false) &#123;						newFile.mkdirs();						mainFrame.display("文件夹创建成功!");					&#125; else &#123;						mainFrame.display("文件夹创建出错!");					&#125;				&#125; catch (Exception e) &#123;					mainFrame.display("出错信息:" + e.getMessage());				&#125;			&#125; else &#123;				mainFrame.display("文件夹已经存在");			&#125;		&#125;	&#125;	/*	 * rmdir &lt;目录名&gt; 功能: 删除目录;	 */	public void rmdir(String directory) &#123;		if (!currentPath.equals("")) &#123;			String temp = currentPath + "\\" + directory;			File file = new File(temp);			if (file.exists()) &#123;				if (file.delete()) &#123;					mainFrame.display("文件夹删除成功!");				&#125; else &#123;					mainFrame.display("文件夹删除操作出错!");				&#125;			&#125; else &#123;				mainFrame.display("文件夹不存在");			&#125;		&#125;	&#125;	/*	 * mkfile &lt;文件名&gt; 功能: 新建文件	 */	public void mkfile(String file) &#123;		if (!currentPath.equals("")) &#123;			String temp = currentPath + "\\" + file;			File newFile = new File(temp);			if (newFile.exists()) &#123;				mainFrame.display("文件已经存在!");			&#125; else &#123;				try &#123;					newFile.createNewFile();					mainFrame.display("文件创建成功!");				&#125; catch (Exception e) &#123;					mainFrame.display("文件创建失败:" + e.getMessage());				&#125;			&#125;		&#125;	&#125;	/*	 * rmfile &lt;文件名&gt; 功能:删除文件;	 */	public void rmfile(String file) &#123;		if (!file.equals("")) &#123;			String temp = currentPath + "\\" + file;			File dfile = new File(temp);			if (dfile.exists()) &#123;				if (dfile.delete()) &#123;					mainFrame.display("文件删除成功!");				&#125; else &#123;					mainFrame.display("文件删除操作出错!");				&#125;			&#125; else &#123;				mainFrame.display("文件不存在");			&#125;		&#125;	&#125;	/*	 * 进行exit操作; 功能:退出文件系统;	 */	public void exit() &#123;		mainFrame.display("退出系统");		System.exit(1);	&#125;		/*	 * 新建文件，使用绝对路径	 */	public void mkpath(String file)&#123;				if (!currentPath.equals("")) &#123;			String temp = file;			File newFile = new File(temp);			if (newFile.exists()) &#123;				mainFrame.display("文件已经存在!");			&#125; else &#123;				try &#123;					newFile.createNewFile();					mainFrame.display("文件创建成功!");				&#125; catch (Exception e) &#123;					mainFrame.display("文件创建失败:" + e.getMessage());				&#125;			&#125;		&#125;	&#125;		/*	 * 使用系统默认软件打开指定文件	 */	public void open(String file)&#123;				if (!currentPath.equals("")) &#123;			String temp = currentPath + "\\" + file;			File newFile = new File(temp);			if (newFile.exists()) &#123;				try &#123;					Desktop.getDesktop().open(newFile);				&#125; catch (Exception e) &#123;					e.printStackTrace();				&#125;				mainFrame.display("打开文件成功！");			&#125; else &#123;				mainFrame.display("文件不存在，无法打开");			&#125;		&#125;	&#125;&#125;

小结怎么这么简单？没错，代码是很简单，但是，想到这个思路不容易，再次感谢cattong前辈。
源代码分享http://yunpan.cn/cjqdEABf3dxkj  访问密码 7159http://yunpan.cn/cjqdWLKJk4TQL  访问密码 63de
参考文档http://www.oschina.net/project/tag/193?lang=19&amp;show=hotshttp://blog.csdn.net/cattong/article/details/1844916
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Prometheus Operator + Blackbox exporter</title>
    <url>/dev-prometheus-operator-blackbox-exporter/</url>
    <content><![CDATA[前言《Kubernetes Operator》一文中学习了Operator的基础，《Prometheus Blackbox exporter》一文中学习了blackbox exporter的安装配置。
而Prometheus Operator，顾名思义，是负责K8S中自动化管理Prometheus的Custom Controller。更多内容，参考coreos/prometheus-operator
本文中，我们研究的问题是：怎样利用Prometheus Operator，在Kubernetes集群中安装部署Prometheus，并且添加Blackbox exporter组件？


安装Prom Operator参考Prometheus Operator 初体验和coreos/kube-prometheus，安装Prometheus Operator。
1、kubelet配置添加参数vim /etc/systemd/system/kubelet.service.d/10-kubeadm.conf添加：
--authentication-token-webhook=true--authorization-mode=Webhook

2、获取源码，并切换版本（与k8s版本的对应关系可以在github仓库找到）
git clone https://github.com/coreos/kube-prometheus.gitcd kube-prometheuskubectl versiongit branch -agit checkout origin/release-0.4

3、安装Prom Operator
# Create the namespace and CRDs, and then wait for them to be availble before creating the remaining resourceskubectl create -f manifests/setupuntil kubectl get servicemonitors --all-namespaces ; do date; sleep 1; echo ""; donekubectl create -f manifests/

4、查看安装
kubectl get crd | grep coreoskubectl get pod -n monitoringkubectl get svc -n monitoring
以上，Prometheus Operator安装完成，Prometheus也安装完成。
PS：卸载Prom Operator
kubectl delete --ignore-not-found=true -f manifests/ -f manifests/setup

安装Blackbox exporter1、创建yaml文件 blackbox-exporter.yaml
apiVersion: v1data:  config.yml: |    modules:      http_2xx:        prober: http        http:          method: GET          preferred_ip_protocol: "ip4"      http_post_2xx:        prober: http        http:          method: POST          preferred_ip_protocol: "ip4"      tcp:        prober: tcp      ping:        prober: icmp        timeout: 3s        icmp:          preferred_ip_protocol: "ip4"      dns_k8s:        prober: dns        timeout: 5s        dns:          transport_protocol: "tcp"          preferred_ip_protocol: "ip4"          query_name: "kubernetes.default.svc.cluster.local"          query_type: "A"kind: ConfigMapmetadata:  name: blackbox-exporter  namespace: monitoring---apiVersion: apps/v1kind: Deploymentmetadata:  creationTimestamp: null  labels:    name: blackbox-exporter    cluster: ali-huabei2-dev  name: blackbox-exporter  namespace: monitoringspec:  replicas: 1  selector:    matchLabels:      name: blackbox-exporter  strategy: &#123;&#125;  template:    metadata:      creationTimestamp: null      labels:        name: blackbox-exporter        cluster: ali-huabei2-dev    spec:      containers:      - image: prom/blackbox-exporter:v0.16.0        name: blackbox-exporter        ports:        - containerPort: 9115        volumeMounts:        - name: config          mountPath: /etc/blackbox_exporter        args:        - --config.file=/etc/blackbox_exporter/config.yml        - --log.level=info      volumes:      - name: config        configMap:          name: blackbox-exporter---apiVersion: v1kind: Servicemetadata:  #annotations:  #  service.beta.kubernetes.io/alicloud-loadbalancer-address-type: intranet  labels:    name: blackbox-exporter    cluster: ali-huabei2-dev  name: blackbox-exporter  namespace: monitoringspec:  #externalTrafficPolicy: Local  selector:    name: blackbox-exporter  ports:  - name: http-metrics    port: 9115    targetPort: 9115  type: LoadBalancer

2、应用yaml文件
kubectl apply -f blackbox-exporter.yamlkubectl get svc -n monitoringkubectl get deploy -n monitoring

配置使用Blackbox exporter（错误方法）在Prometheus中配置使用Blackbox exporter是很简单的，scrape_configs里配置相应字段即可。但是，k8s中的Prometheus配置，会有一些不同。
1、获取prometheus.yml配置
kubectl get secrets -n monitoring prometheus-k8s -oyaml | grep prometheus.yaml.gz | awk '&#123;print $2&#125;' | base64 --decode | gzip -d &gt; prometheus.yml

2、查看prometheus.yml配置，下面截取一段：
global:  evaluation_interval: 30s  scrape_interval: 30s  external_labels:    prometheus: monitoring/k8s    prometheus_replica: $(POD_NAME)rule_files:- /etc/prometheus/rules/prometheus-k8s-rulefiles-0/*.yamlscrape_configs:- job_name: monitoring/node-exporter/0  honor_labels: false  kubernetes_sd_configs:  - role: endpoints    namespaces:      names:      - monitoring  scrape_interval: 15s  scheme: https  tls_config:    insecure_skip_verify: true  bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token  relabel_configs:  - action: keep    source_labels:    - __meta_kubernetes_service_label_k8s_app    regex: node-exporter  - action: keep    source_labels:    - __meta_kubernetes_endpoint_port_name    regex: https  - source_labels:    - __meta_kubernetes_endpoint_address_target_kind    - __meta_kubernetes_endpoint_address_target_name    separator: ;    regex: Node;(.*)    replacement: $&#123;1&#125;    target_label: node  - source_labels:    - __meta_kubernetes_endpoint_address_target_kind    - __meta_kubernetes_endpoint_address_target_name    separator: ;    regex: Pod;(.*)    replacement: $&#123;1&#125;    target_label: pod  - source_labels:    - __meta_kubernetes_namespace    target_label: namespace  - source_labels:    - __meta_kubernetes_service_name    target_label: service  - source_labels:    - __meta_kubernetes_pod_name    target_label: pod  - source_labels:    - __meta_kubernetes_service_name    target_label: job    replacement: $&#123;1&#125;  - source_labels:    - __meta_kubernetes_service_label_k8s_app    target_label: job    regex: (.+)    replacement: $&#123;1&#125;  - target_label: endpoint    replacement: https  - source_labels:    - __meta_kubernetes_pod_node_name    target_label: instance    regex: (.*)    replacement: $1    action: replace  - source_labels:    - __meta_kubernetes_service_label_cluster    target_label: cluster    regex: (.*)    replacement: $1    action: replace
其中，job_name配置target名称，kubernetes_sd_configs配置k8s的服务发现，relabel_configs配置标签最终的显示。source_labels是样本的原标签，target_label是显示的标签；regex使用正则匹配value，replacement代表最终显示的value。$1代表regex正则匹配到的第一个字符串。
3、添加blackbox exporter的配置
- job_name: monitoring/blackbox-exporter/0  honor_labels: false  kubernetes_sd_configs:  - role: endpoints    namespaces:      names:      - monitoring  scrape_interval: 15s  scheme: http  tls_config:    insecure_skip_verify: true  bearer_token_file: /var/run/secrets/kubernetes.io/serviceaccount/token  relabel_configs:  - action: keep    source_labels:    - __meta_kubernetes_service_label_name    regex: blackbox-exporter  - source_labels:    - __meta_kubernetes_service_label_name    target_label: job    regex: (.+)    replacement: $&#123;1&#125;  - source_labels:    - __meta_kubernetes_service_label_cluster    target_label: cluster    regex: (.*)    replacement: $1    action: replace

4、应用新的配置
# 1. compress prometheus.yamlcat prometheus.yaml | gzip -f | base64 | tr -d "\n"# 2. copy string# 3. edit secretkubectl edit secrets -n monitoring prometheus-k8s# 4. replace prometheus.yaml.gz# 5. get the latest configkubectl get secrets -n monitoring prometheus-k8s -oyaml | grep prometheus.yaml.gz | awk '&#123;print $2&#125;' | base64 --decode | gzip -d | grep blackbox
然而，配置中并没有blackbox，配置没有发生改变！证明了prometheus的配置是自动生成的，手动修改无效。
配置使用Blackbox exporter（正确方法）Prometheus Operator中配置Target，是利用ServiceMonitor进行动态发现的方式。
1、创建servicemonitor的yaml文件，blackbox-exporter-sm.yaml
apiVersion: monitoring.coreos.com/v1kind: ServiceMonitormetadata:  labels:    name: blackbox-exporter    release: p  name: blackbox-exporter  namespace: monitoringspec:  namespaceSelector:    matchNames:    - monitoring  selector:    matchLabels:      name: blackbox-exporter  endpoints:  - interval: 15s    port: http-metrics    path: /probe    relabelings:    - action: replace      regex: (.*)      replacement: $1      sourceLabels:      - __meta_kubernetes_service_label_cluster      targetLabel: cluster    - action: replace      regex: (.*)      replacement: $1      sourceLabels:      - __param_module      targetLabel: module    - action: replace      regex: (.*)      replacement: $1      sourceLabels:      - __param_target      targetLabel: target    params:      module:      - http_2xx      target:      - http://prometheus.io    # Target to probe with http.      - https://prometheus.io   # Target to probe with https.      - http://example.com:8080 # Target to probe with http on port 8080.  - interval: 15s    port: http-metrics    path: /probe    relabelings:    - action: replace      regex: (.*)      replacement: $1      sourceLabels:      - __meta_kubernetes_service_label_cluster      targetLabel: cluster    - action: replace      regex: (.*)      replacement: $1      sourceLabels:      - __param_module      targetLabel: module    - action: replace      regex: (.*)      replacement: $1      sourceLabels:      - __param_target      targetLabel: target    params:      module:      - dns_k8s      target:      - 172.31.16.10 # dns ip address

2、应用到k8s集群kubectl apply -f blackbox-exporter-sm.yaml
3、等待一分钟后，进行验证访问prometheus的graph页面，可以查看blackbox-exporter指标。
&#123;job=~"blackbox-exporter",__name__!~"^go.*"&#125;
查看结果表明，params的配置中，http_2xx 探测只有第一个target生效了，另外两个target根本没有探测记录。本实验证明了，target里只能填写一个域名，多了无效。要想配置多个站点的探测，最简单的办法就是配置多个endpoint。至于N个站点配置M种探测方式，如果你知道怎么配置，欢迎留言告知，感谢~
配置告警《使用Docker安装配置Prometheus》一文中，我们知道配置告警需要在prometheus配置文件中指定alertmanager实例和报警的rules文件。而通过operator部署的prometheus，怎样配置告警呢？这里需要定义PrometheusRule资源，并且具备标签 prometheus=k8s 和 role=alert-rules。这里以配置dns服务告警为例，dns服务出问题，不能正常解析 kubernetes.default.svc.cluster.local 。
1、查看alertmanager配置
kubectl get secrets -n monitoring alertmanager-main -oyaml | grep "alertmanager.yaml" | awk '&#123;print $2&#125;' | base64 -d

2、创建prometheus-rule-dns.yaml
apiVersion: monitoring.coreos.com/v1kind: PrometheusRulemetadata:  labels:    prometheus: k8s    role: alert-rules  name: dns-alert-rules  namespace: monitoringspec:  groups:  - name: DNS    rules:    - alert: DNSServerError      annotations:        summary: No summary        description: No description        webhookToken: xxxxxxxxx      expr: |        probe_success&#123;module="dns_k8s"&#125; == 0      for: 1m      labels:        severity: critical        alertTag: k8s

3、应用rulekubectl apply -f prometheus-rule-dns.yaml
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>监控</tag>
        <tag>prometheus</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PSSH批量管理Linux进阶篇</title>
    <url>/dev-pssh-manage-linux-advance/</url>
    <content><![CDATA[前言《使用PSSH批量管理Linux》一文中，学习了pssh的基本用法，实际上已经涵盖了pssh的大部分内容。
本文主要记录利用pssh和expect脚本来解决一些实际问题，就算是进阶篇了。



批量添加密钥《添加密钥认证访问》一节中，已经写清楚了挨个给客户机添加密钥的方法。但是，在客户机数量非常多的时候，挨个添加也很麻烦，写个脚本吧！（假设所有客户机用户都是test，密码都是123456）
参考无密钥登录的自动脚本实现 和 expect - 自动交互脚本
基线版本1、新建脚本addkey.sh，内容为：
#!/usr/bin/expect set timeout 60set password 123456spawn ssh-copy-id -i /home/test/.ssh/id_rsa.pub -p 22 test@192.168.56.101expect "install the new keys"send "\r"expect "password:"send "$password\r"expect eof

2、执行脚本chmod a+x addkey.sh
./addkey.sh
注意：

如果密码是六个空格，那么set password &quot;      &quot;即可。
expect &quot;install the new keys&quot;这里其实是不需要交互的，但是密码会直接出现在这里，所以加一个回车。

升级版本在使用ssh-copy-id命令的时候，有两种情况，一种是直接输入密码，就像基线版本；另一种情况是会先提示添加主机到known_hosts。
1、新建脚本addkey.sh，主要目的是测试，内容为：
#!/usr/bin/expect set timeout 60set password 123456spawn ssh-copy-id -i /home/test/.ssh/id_rsa.pub -p 22 test@192.168.56.101expect &#123;    #first connect, no public key in ~/.ssh/known_hosts    "Are you sure you want to continue connecting (yes/no)?" &#123;        send "yes\r"; exp_continue    &#125;    #already has public key in ~/.ssh/known_hosts    "install the new keys" &#123;        send "\r"; exp_continue    &#125;    "password:" &#123;        send "$password\r"; exp_continue    &#125;    "Now try logging into the machine" &#123;        #it has authorized, do nothing!        ; exp_continue    &#125;&#125;

2、执行脚本chmod a+x addkey.sh
./addkey.sh
批量版本1、升级脚本，新建addkeys.sh，内容为：
#!/usr/bin/expect set timeout 60set password 123456for &#123;set i 101&#125; &#123;$i &lt; 201&#125; &#123;incr i&#125; &#123;    spawn ssh-copy-id -i /home/test/.ssh/id_rsa.pub -p 22 test@192.168.56.$i    expect &#123;        #first connect, no public key in ~/.ssh/known_hosts        "Are you sure you want to continue connecting (yes/no)?" &#123;            send "yes\r"; exp_continue        &#125;        #already has public key in ~/.ssh/known_hosts        "install the new keys" &#123;            send "\r"; exp_continue        &#125;        "password:" &#123;            send "$password\r"; exp_continue        &#125;        "Now try logging into the machine" &#123;            #it has authorized, do nothing!            ; exp_continue        &#125;    &#125;&#125;

2、执行脚本chmod a+x addkeys.sh
./addkeys.sh
批量删除添加完密钥之后，发现部分机器不能免密登录。检查客户机中的authorized_keys文件，发现添加了两次密钥。于是决定删除重新添加。
1、管理机新建脚本delkeys.sh
#!/usr/bin/expect set timeout 30set password 123456for &#123;set i 101&#125; &#123;$i &lt; 201&#125; &#123;incr i&#125; &#123;    spawn ssh test@192.168.56.$i "rm /home/test/.ssh/authorized_keys"    expect &#123;        "password:" &#123; send "$password\r"&#125;        "No route to host" &#123; send "\r" &#125;    &#125; &#125;

2、执行脚本chmod a+x delkeys.sh
./delkeys.sh
注意，执行完之后检查一下最后一台客户机，也许会删除失败，不知道为什么。
批量修改权限删除后重新添加，依然无法登录，后来发现，是目录权限的问题。用户目录权限是750，~/.ssh权限是700， ~/.ssh/authorized_keys权限是600。
1、权限修改脚本chmods.sh
#!/usr/bin/expect set timeout 30set password 123456for &#123;set i 101&#125; &#123;$i &lt; 201&#125; &#123;incr i&#125; &#123;    spawn ssh test@192.168.56.$i -t "sudo chmod 750 /home/test/ &amp;&amp; sudo chmod 700 /home/test/.ssh &amp;&amp; sudo chmod 600 /home/test/.ssh/authorized_keys"    expect &#123;        "password:" &#123; send "$password\r"; exp_continue &#125;        "password for test" &#123; send "$password\r"; exp_continue &#125;        "No route to host" &#123; send "\r" &#125;    &#125;&#125;

2、执行脚本chmod a+x chmods.sh
./chmods.sh
修改StrictModes设置完权限，依然无法免密登录，猜测是StrictModes的问题。
1、编辑sshd_configsudo vi /etc/ssh/sshd_config
2、找到StrictModes yes，改成StrictModes no。
3、重启sshd，sudo service ssh restart
然后，依然失败。
调试1、不服，进行ssh登录调试，ssh -v test@192.168.56.102或者ssh -vvv test@192.168.56.102。
debug1: Authentications that can continue: publickey,passworddebug1: Next authentication method: publickeydebug1: Offering RSA public key: /home/test/.ssh/id_rsadebug1: Authentications that can continue: publickey,passworddebug1: Trying private key: /home/test/.ssh/id_dsadebug1: Trying private key: /home/test/.ssh/id_ecdsadebug1: Trying private key: /home/test/.ssh/id_ed25519debug1: Next authentication method: password

一番折腾，失败，失败，失败。。。
2、参考ssh免密登录失败问题排查思路，在客户机查看日志，cat /var/log/auth.log。
调试方法：（1）客户机执行tail -f /var/log/auth.log（2）管理机执行ssh -v test@192.168.56.102
然而，各种尝试依然失败，失败，失败。。。
3、然后找到一篇重建home分区后出现的ssh公钥认证失败问题，猜测是SElinux的问题，于是在客户机执行：
sudo apt-get install policycoreutils
restorecon -r -vv /home/
然而，依然没有用。
使用dsa密钥1、生成dsa密钥ssh-keygen -t dsa -P &#39;&#39; -f ~/.ssh/id_dsa
2、添加公钥到客户机ssh-copy-id -i /home/test/.ssh/id_dsa.pub -p 22 test@192.168.56.102
3、管理机测试登录ssh test@192.168.56.102
依然失败。换一个管理机重新添加密钥，依然失败，看来确实是客户机的锅。好吧，放弃了，不玩了！
设置sudo免密以上，假设已经实现了批量添加密钥，也就是实现了所有客户机的免密登录。但是，在客户机执行sudo命令的时候，会提示输入密码，也是很麻烦，所以接下来设置sudo免密执行。
1、管理机新建脚本addsudo.sh，内容为：
#!/usr/bin/expect set timeout 10set password 123456for &#123;set i 101&#125; &#123;$i &lt;= 200&#125; &#123;incr i&#125; &#123;    spawn ssh test@192.168.56.$i -t "sudo -i"    expect "password for test:"    send "$password\r"    expect "*#"    send "echo test ALL = NOPASSWD: ALL &gt;&gt; /etc/sudoers \r"    expect "*#"    send "exit\r"&#125;

2、执行脚本chmod a+x addsudo.sh
./addsudo.sh
批量修改密码《批量修改密码》一节中，我们采用的修改密码的方式是给所有的客户机都安装expect，然后发送脚本到客户机并执行脚本。给每台机器安装expect，不是一个好的做法。不妨参照设置sudo免密，在管理机执行脚本，虽然无法并行，但是胜在不需要给客户机安装expect。
不过，这次我们换一种脚本写法，使用bash脚本循环调用expect脚本。这种写法更好，更加稳定。因为在expect脚本中写循环语句，有些字符串会不显示，影响执行效果。
1、新建expect脚本m-chpasswd.sh
#!/usr/bin/expect set timeout 10set newpassword 12345678set i [lindex $argv 0]spawn ssh test@192.168.56.$i -t "sudo passwd test"expect "Enter new UNIX password:"send "$newpassword\r"expect "Retype new UNIX password:"send "$newpassword\r"expect "closed" send "\r"expect eof

2、新建bash脚本loop-passwd.sh
#!/bin/bashfor ((i=101;i&lt;=200;i++))do    echo "begin..."    echo $i    ./m-chpasswd.sh $i    echo "end..."done

3、执行脚本chmod a+x m-chpasswd.sh
chmod a+x loop-passwd.sh
./loop-passwd.sh
批量修改hosts《批量修改hostname》一节中，我们给三台机器设置了主机名，比较简单。现在假设我们有100台机器需要管理，IP为192.168.56.101-200，现在要给它们设置主机名，同时修改它们的/etc/hosts文件，方便使用主机名相互寻找。
自动生成hosts1、在管理机新建脚本makehosts.sh，内容为：
#!/bin/bashecho "127.0.0.1    localhost" &gt; /home/test/hostsNUM=101while [ $NUM -lt 201 ]do    echo "192.168.56.$NUM    vk$NUM" &gt;&gt; /home/test/hosts    NUM=`expr $NUM + 1`done

2、执行脚本sudo chmod a+x makehosts.sh
./makehosts.sh
3、替换hostssudo cp hosts /etc/hosts
PS：添加一条新的记录到 /etc/hosts ，sudo bash -c &quot;echo 192.168.56.201 vk201 &gt;&gt; /etc/hosts&quot;
修改客户机hosts1、拷贝hosts文件到客户机pscp -h hosts.txt ./hosts /home/test
2、替换hosts文件pssh -h hosts.txt -i &quot;sudo cp /home/test/hosts /etc/hosts&quot;
后记本文在写作之前，思路很明确，以为可以半天搞定，没想到遇到了一个大坑：部分机器无法免密登录。大大小小试了十几种解决办法，未果，折腾了一整天，还是无奈放弃。
设置sudo免密时还有一个方案，就是写一个脚本发送到客户机，在客户机执行修改/etc/sudoers文件。但是要求所有客户机都安装了expect，这个很麻烦，不如在管理机操作。
20180614更新今天，突然冒出一个想法，如果换一个用户呢？不再用test，而是使用test2用户。于是，进行了测试。
1、客户机新建test2用户sudo useradd -m test2 -s /bin/bash
sudo passwd test2
根据需要给予sudo权限，sudo adduser test2 sudo
2、管理机添加免密登录ssh-copy-id -i .ssh/id_rsa.pub -p 22 test2@192.168.56.102
3、测试登录ssh test2@192.168.56.102
登录成功！！！
那么，如果我删除test用户，再添加新的test用户，是不是也可以呢？
1、客户机删除test用户sudo userdel -r test提示userdel: user test is currently used by process 62901
2、查看最近登录情况w，last
并没有人在使用这个账号，那就继续想办法删除。
3、使用vipwsudo vipw，找到test用户那行，删除。
sudo vipw -s，找到test用户那行，删除。
4、删除test目录cd /home &amp;&amp; sudo rm -rf test
5、新建test用户sudo useradd -m test -g test -s /bin/bash
sudo passwd test
sudo adduser test sudo
7、管理机添加免密登录ssh-copy-id -i .ssh/id_rsa.pub -p 22 test@192.168.56.102
8、测试登录ssh test@192.168.56.102
登录成功！！！问题完美结局，不过确实很麻烦。
如果，单纯地拷贝其他客户机的整个test用户目录呢？假设客户机A的IP为192.168.56.102，已经配置完成，可以免密登录；客户机B的IP为192.168.56.103，不可以免密登录。
1、删除客户机B的test目录下所有文件rf -rf ./*
rf -rf ./.*
2、拷贝配置好的客户机A的test目录到客户机Bscp test@192.168.56.102:~/.* .
scp test@192.168.56.102:~/.ssh/* .ssh/
3、在管理机测试登录ssh test@192.168.56.103
登录成功！！！这个方法明显更好，nice。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>使用PSSH批量管理Linux</title>
    <url>/dev-pssh-manage-linux/</url>
    <content><![CDATA[前言《Ubuntu系统批量自动安装》一文中，配置好了PXE服务器，也通过它安装了几台机器。每个机器都重新配置好了IP，已经可以远程访问了。现在新的问题来了，每个机器的主机名都相同，需要修改；每个机器的sources.list都有问题，需要替换。以后，肯定也有很多其他需要批量操作的问题，比如批量安装ganglia，总不能上百台机器一个个手动操作吧！
本文，就研究下linux批量操作的相关方法和工具，重点研究下pssh。


批量操作思路首先定义两个概念：管理机和客户机，本文中的管理机是指管理其他服务器的服务器，客户机是指普通服务器。管理机IP为192.168.56.101，客户机IP为192.168.56.102-104，用户名都是test。
思路一说到批量操作，最容易想到的，肯定是在管理机写一个脚本，里面有个循环语句，挨个连接客户机进行操作。而循环语句里面，主要是ssh，然后执行交互命令。参考 shell实现SSH自动登陆 、 关于SSH 远程执行命令你要知道的二三事 和 shell脚本实现同时多台远程主机执行命令的代码分享。
但是，这种方式很难并行处理，比较浪费时间。
思路二另一个简单的思路，是在管理机写一个在客户机执行的脚本，然后推送给客户机，再在客户机里执行脚本。主要参考SSH 远程执行任务。
这种方式同样很难并行处理，比较浪费时间。如果非要并行处理，那么就只能牺牲反馈信息。
思路三最后一种思路就是借助工具，比如mussh、pdsh、pssh等等。
psshpssh简介pssh是一个python编写可以在多台服务器上执行命令的工具，同时支持拷贝文件，是同类工具中很出色的。类似pdsh，但是相对pdsh更为简便，使用前必须在各个服务器上配置好密钥认证访问。参考pssh命令和pssh HOWTO。
安装1、ubuntu安装pssh，sudo apt-get install pssh
2、ubuntu安装完pssh后，输入pssh，也许会提示：No command ‘pssh’ found, did you mean:…
解决办法参考Why pssh command is not working?，一条命令解决：echo &quot;alias pssh=parallel-ssh&quot; &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc，其中&amp;&amp; . ~/.bashrc代表立即生效。
3、设置相关命令安装完pssh后，实际上还安装了pscp、prsync、pnuke和pslurp。和pssh命令无效的问题相同，它们默认也只能使用全名，不能只用简称。需要执行如下命令：
echo "alias pscp=parallel-scp" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrcecho "alias prsync=parallel-rsync" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrcecho "alias pnuke=parallel-nuke" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrcecho "alias pslurp=parallel-slurp" &gt;&gt; ~/.bashrc &amp;&amp; . ~/.bashrc

其中，pscp把文件并行地复制到多个客户机；prsync使用rsync协议从管理机同步到客户机；pslurp将文件从客户机复制到管理机；pnuke并行地在客户机杀进程。
命令格式命令格式：pssh [OPTIONS] command [...]
选项：
--version：查看版本--help：查看帮助，即此信息-h：主机文件列表，内容格式"[user@]host[:port]"-H：主机字符串，内容格式"[user@]host[:port]"-l：登录使用的用户名-p：并发的线程数【可选】-o：输出的文件目录【可选】-e：错误输入文件【可选】-t：TIMEOUT 超时时间设置，0无限制【可选】-O：SSH的选项-v：详细模式-A：手动输入密码模式-x：额外的命令行参数使用空白符号，引号，反斜线处理-X：额外的命令行参数，单个参数模式，同-x-i：每个服务器内部处理信息输出-P：打印出服务器返回信息

实践篇添加密钥认证访问参考Linux之SSH密钥认证和ssh使用密钥进行认证，在管理机上制作密钥对，将公钥添加给客户机，然后通过ssh免密登录。
1、确认管理机和客户机都安装了ssh。ps aux | grep ssh
2、在管理机上创建密钥对ssh-keygen所有的提示按enter键即可，完成后在home目录执行ll .ssh，即可看到创建好的id_rsa和id_rsa.pub文件。
3、把公钥拷贝到所有客户机中ssh-copy-id -i .ssh/id_rsa.pub -p 22 test@192.168.56.102
4、测试登录上一步拷贝完成后，会提示使用ssh -p &#39;22&#39; &#39;test@192.168.56.102&#39;测试登录。
在管理机中，使用ssh test@192.168.56.102测试登录，我们发现已经不需要输入密码了。
5、查看公钥登录102客户机，ll .ssh，我们发现有一个authorized_keys文件，文件的内容和管理机的id_rsa.pub相同。
5、测试命令ssh test@192.168.56.102 &#39;/sbin/ifconfig&#39;
返回了102客户机的ifconfig执行结果，测试成功。
6、设置sudo命令免密码ssh test@192.168.56.102 &#39;sudo iptables --list&#39;报错：sudo: no tty present and no askpass program specified
这个问题，需要在每个客户机下进行sudo免密设置。进入客户机之后，sudo vim /etc/sudoers，添加：
test ALL = NOPASSWD: ALL

再次执行ssh test@192.168.56.102 &#39;sudo iptables --list&#39;，成功。
获取每台机器的uptime1、在管理机上新建hosts.txt，内容为：
test@192.168.56.102test@192.168.56.103test@192.168.56.104

2、执行uptimepssh -h hosts.txt -i uptime
3、保存执行结果pssh -h hosts.txt -i -o /tmp/pssh/ uptime
ll /tmp/pssh
cat /tmp/pssh
批量修改hostname参考Linux批量修改多台服务器的主机名（hostname），我们把客户机的主机名改为vk102、vk103和vk104。
1、新建hosts文件，内容为：
192.168.56.102    vk102192.168.56.103    vk103192.168.56.104    vk104

2、新建hostname.sh文件，内容为：
#!/bin/baship=`ifconfig eth0 | grep 'inet' | awk '&#123;print $2&#125;' | tr -d 'addr:'`hostname=`cat /home/test/hosts | grep $ip | awk '&#123;print $2&#125;'`echo $ipecho $hostnamehostnamectl set-hostname --static $hostnamehostname $hostname

3、发送到hosts和hostname.sh到客户机/home/test目录下pscp -h hosts.txt ./hosts /home/testpscp -h hosts.txt ./hostname.sh /home/test
4、批量授予hostname.sh可执行权限pssh -h hosts.txt -i  &#39;chmod +x /home/test/hostname.sh&#39;
5、批量执行hostname.shpssh -h hosts.txt -i  &#39;sudo sh /home/test/hostname.sh&#39;报错：Stderr: hostname: you must be root to change the host name命令修改为：pssh -h hosts.txt -i  &#39;sudo sh /home/test/hostname.sh&#39;执行成功。
批量替换sources.list1、新建sources.list，内容为：
deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse

2、客户机备份原sources.listpssh -h hosts.txt -i  &#39;sudo mv /etc/apt/sources.list /etc/apt/sources.list.bak&#39;
3、复制新的sources.list到客户机pscp -h hosts.txt sources.list /home/test/pssh -h hosts.txt &#39;sudo mv /home/test/sources.list /etc/apt/&#39;
4、更新安装源pssh -h hosts.txt -i &#39;sudo apt-get update&#39;
批量安装ganglia参考Ubuntu14.04安装配置Ganglia，假设我们已经配置好了ganglia主节点。
1、把ganglia主节点的/etc/ganglia/gmond.conf文件拷贝到管理机当前目录。
2、编写ganglia安装脚本install-gmond.sh（不要照抄，下面有修改版）
#!/bin/bashsudo apt-get -y install ganglia-monitor rrdtool &amp;&amp; \sudo mv /etc/ganglia/gmond.conf /etc/ganglia/gmond.conf.bak &amp;&amp; \sudo mv /home/test/gmond.conf /etc/ganglia/ &amp;&amp; \sudo /etc/init.d/ganglia-monitor restart &amp;&amp; \sudo rm -rf /home/test/install-gmond.sh

3、拷贝gmond.conf和install-gmond.sh到客户机pscp -h hosts.txt gmond.conf /home/test/pscp -h hosts.txt install-gmond.sh /home/test/
4、添加执行权限pssh -h hosts.txt -i  &#39;chmod +x /home/test/install-gmond.sh&#39;
5、执行安装pssh -h hosts.txt -i &#39;sudo apt-get update&#39;
pssh -h hosts.txt -i &#39;sudo sh /home/test/install-gmond.sh&#39;
脚本虽然顺利执行了，但是报错：Stderr: debconf: unable to initialize frontend: Dialog解决办法是修改脚本为：
#!/bin/bashexport DEBIAN_FRONTEND=noninteractive DEBCONF_NONINTERACTIVE_SEEN=true &amp;&amp; \sudo apt-get -y -q install ganglia-monitor rrdtool &amp;&amp; \sudo mv /etc/ganglia/gmond.conf /etc/ganglia/gmond.conf.bak &amp;&amp; \sudo mv /home/test/gmond.conf /etc/ganglia/ &amp;&amp; \sudo /etc/init.d/ganglia-monitor restart &amp;&amp; \sudo rm -rf /home/test/install-gmond.sh

6、查看运行状态pssh -h hosts.txt -i -o /tmp/pssh/ &#39;ps aux | grep ganglia&#39;
批量修改密码参考shell实现SSH自动登陆 和 6个Expect脚本示例，使用expect命令。
1、管理机上新建chpasswd.sh脚本，内容如下：
#!/usr/bin/expect set timeout 3set user testset password 123456spawn sudo passwd $user  expect "Enter new UNIX password:"  send "$&#123;password&#125;\r"  expect "Retype new UNIX password:"  send "$&#123;password&#125;\r"  expect eof

2、在客户机上安装expect（可以用whereis expect查看是否安装）pssh -h hosts.txt -i &#39;sudo apt-get install expect -y&#39;
3、拷贝chpasswd.sh脚本到客户机pscp -h hosts.txt chpasswd.sh /home/test
5、添加执行权限pssh -h hosts.txt -i &#39;sudo chmod a+x /home/test/chpasswd.sh&#39;
5、执行修改密码pssh -h hosts.txt -i &#39;sudo /home/test/chpasswd.sh&#39;
6、删除chpasswd.sh脚本pssh -h hosts.txt -i &#39;sudo rm -rf /home/test/chpasswd.sh&#39;
批量杀进程假设需要杀死的进程为gmond。方法一：pnuke -h hosts.txt gmondpssh -h hosts.txt -i &#39;ps -ef | grep gmond&#39;这种方法虽然显示success，但是查看进程依然存在，看来存在不确定性。猜测对于sudo启动的进程难以杀死。
方法二：pssh -h hosts.txt -i &#39;sudo pkill -9 gmond&#39;这种方法杀的很彻底，是个好方法。
方法三：pssh -h hosts.txt &#39;sudo ps -ef | grep gmond | awk &#39;{print $2}&#39; | xargs kill -9&#39;这种方法也显示success，但是查看进程依然存在，还是有问题。猜测因为sudo作用在了ps上，所以对于sudo启动的进程难以杀死。
方法四：
pssh -h hosts.txt -i 'sudo kill -s 9 `pgrep gmond`'
这种方法杀的很彻底，是个好方法。
PS：启动gmond命令pssh -h hosts.txt -i &#39;sudo /etc/init.d/ganglia-monitor start
后记以上实践，已经包含了pssh的最常见用法。更高级的用法，就在需要时再去学习吧！
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Python抓取百度百科数据</title>
    <url>/dev-python-crawler-baidu-baike/</url>
    <content><![CDATA[前言本文整理自慕课网《Python开发简单爬虫》，将会记录爬取百度百科“python”词条相关页面的整个过程。


抓取策略确定目标：确定抓取哪个网站的哪些页面的哪部分数据。本实例抓取百度百科python词条页面以及python相关词条页面的标题和简介。分析目标：分析要抓取的url的格式，限定抓取范围。分析要抓取的数据的格式，本实例中就要分析标题和简介这两个数据所在的标签的格式。分析要抓取的页面编码的格式，在网页解析器部分，要指定网页编码，然后才能进行正确的解析。编写代码：在网页解析器部分，要使用到分析目标得到的结果。执行爬虫：进行数据抓取。
分析目标1、url格式进入百度百科python词条页面，页面中相关词条的链接比较统一，大都是/view/xxx.htm。
2、数据格式标题位于类lemmaWgt-lemmaTitle-title下的h1子标签，简介位于类lemma-summary下。
3、编码格式查看页面编码格式，为utf-8。
经过以上分析，得到结果如下：
代码编写项目结构在sublime下，新建文件夹baike-spider，作为项目根目录。新建spider_main.py，作为爬虫总调度程序。新建url_manger.py，作为url管理器。新建html_downloader.py，作为html下载器。新建html_parser.py，作为html解析器。新建html_outputer.py，作为写出数据的工具。最终项目结构如下图：
spider_main.py# coding:utf-8import url_manager, html_downloader, html_parser, html_outputerclass SpiderMain(object):    def __init__(self):        self.urls = url_manager.UrlManager()        self.downloader = html_downloader.HtmlDownloader()        self.parser = html_parser.HtmlParser()        self.outputer = html_outputer.HtmlOutputer()    def craw(self, root_url):        count = 1        self.urls.add_new_url(root_url)        while self.urls.has_new_url():            try:                new_url = self.urls.get_new_url()                print('craw %d : %s' % (count, new_url))                html_cont = self.downloader.download(new_url)                new_urls, new_data = self.parser.parse(new_url, html_cont)                self.urls.add_new_urls(new_urls)                self.outputer.collect_data(new_data)                if count == 10:                    break                count = count + 1            except:                print('craw failed')        self.outputer.output_html()if __name__=='__main__':    root_url = 'http://baike.baidu.com/view/21087.htm'    obj_spider = SpiderMain()    obj_spider.craw(root_url)

url_manger.py# coding:utf-8class UrlManager(object):    def __init__(self):        self.new_urls = set()        self.old_urls = set()    def add_new_url(self, url):        if url is None:            return        if url not in self.new_urls and url not in self.old_urls:            self.new_urls.add(url)    def add_new_urls(self, urls):        if urls is None or len(urls) == 0:            return        for url in urls:            self.add_new_url(url)    def has_new_url(self):        return len(self.new_urls) != 0    def get_new_url(self):        new_url = self.new_urls.pop()        self.old_urls.add(new_url)        return new_url

html_downloader.py# coding:utf-8import urllib.requestclass HtmlDownloader(object):    def download(self, url):        if url is None:            return None        response = urllib.request.urlopen(url)        if response.getcode() != 200:            return None        return response.read()

html_parser.py# coding:utf-8from bs4 import BeautifulSoupimport refrom urllib.parse import urljoinclass HtmlParser(object):    def _get_new_urls(self, page_url, soup):        new_urls = set()        # /view/123.htm        links = soup.find_all('a', href=re.compile(r'/view/\d+\.htm'))        for link in links:            new_url = link['href']            new_full_url = urljoin(page_url, new_url)            # print(new_full_url)            new_urls.add(new_full_url)        #print(new_urls)        return new_urls    def _get_new_data(self, page_url, soup):        res_data = &#123;&#125;        # url        res_data['url'] = page_url        # &lt;dd class="lemmaWgt-lemmaTitle-title"&gt; &lt;h1&gt;Python&lt;/h1&gt;        title_node = soup.find('dd', class_='lemmaWgt-lemmaTitle-title').find('h1')        res_data['title'] = title_node.get_text()        # &lt;div class="lemma-summary" label-module="lemmaSummary"&gt;        summary_node = soup.find('div', class_='lemma-summary')        res_data['summary'] = summary_node.get_text()        # print(res_data)        return res_data    def parse(self, page_url, html_cont):        if page_url is None or html_cont is None:            return        soup = BeautifulSoup(html_cont, 'html.parser')        # print(soup.prettify())        new_urls = self._get_new_urls(page_url, soup)        new_data = self._get_new_data(page_url, soup)        # print('mark')        return new_urls, new_data

html_outputer.py# coding:utf-8class HtmlOutputer(object):    def __init__(self):        self.datas = []    def collect_data(self, data):        if data is None:            return        self.datas.append(data)    def output_html(self):        fout = open('output.html','w', encoding='utf-8')        fout.write('&lt;html&gt;')        fout.write('&lt;body&gt;')        fout.write('&lt;table&gt;')        for data in self.datas:            fout.write('&lt;tr&gt;')            fout.write('&lt;td&gt;%s&lt;/td&gt;' % data['url'])            fout.write('&lt;td&gt;%s&lt;/td&gt;' % data['title'])            fout.write('&lt;td&gt;%s&lt;/td&gt;' % data['summary'])            fout.write('&lt;/tr&gt;')        fout.write('&lt;/table&gt;')        fout.write('&lt;/body&gt;')        fout.write('&lt;/html&gt;')        fout.close()

运行在命令行下，执行python spider_main.py。
编码问题问题描述：UnicodeEncodeError: ‘gbk’ codec can’t encode character ‘\xa0’ in position … 
使用Python写文件的时候，或者将网络数据流写入到本地文件的时候，大部分情况下会遇到这个问题。网络上有很多类似的文章讲述如何解决这个问题，但是无非就是encode，decode相关的，这是导致该问题出现的真正原因吗？不是的。很多时候，我们使用了decode和encode，试遍了各种编码，utf8，utf-8，gbk，gb2312等等，该有的编码都试遍了，可是仍然出现该错误，令人崩溃。
在windows下面编写python脚本，编码问题很严重。将网络数据流写入文件时，我们会遇到几个编码：1、#encoding=’XXX’这里(也就是python文件第一行的内容)的编码是指该python脚本文件本身的编码，无关紧要。只要XXX和文件本身的编码相同就行了。比如notepad++”格式”菜单里面里可以设置各种编码，这时需要保证该菜单里设置的编码和encoding XXX相同就行了，不同的话会报错。
2、网络数据流的编码比如获取网页，那么网络数据流的编码就是网页的编码。需要使用decode解码成unicode编码。
3、目标文件的编码将网络数据流写入到新文件，写文件代码如下：
fout = open('output.html','w')fout.write(str)
在windows下面，新文件的默认编码是gbk，python解释器会用gbk编码去解析我们的网络数据流str，然而str是decode过的unicode编码，这样的话就会导致解析不了，出现上述问题。 解决的办法是改变目标文件的编码：
fout = open('output.html','w', encoding='utf-8')

运行结果
源码分享https://github.com/voidking/baike-spider
书签Python开发简单爬虫http://www.imooc.com/learn/563
The Python Standard Libraryhttps://docs.python.org/3/library/index.html
Beautiful Soup 4.2.0 文档https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html
Python词条http://baike.baidu.com/view/21087.htmhttp://baike.baidu.com/item/Python
Python3.x爬虫教程：爬网页、爬图片、自动登录http://www.2cto.com/kf/201507/417660.html
使用python3进行优雅的爬虫（一）爬取图片http://www.jianshu.com/p/696922f268df
Python UnicodeEncodeError: ‘gbk’ codec can’t encode character 解决方法http://www.jb51.net/article/64816.htm
Scrapy documentationhttps://doc.scrapy.org/en/latest/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫基础</title>
    <url>/dev-python-crawler-base/</url>
    <content><![CDATA[前言Python非常适合用来开发网页爬虫，理由如下：1、抓取网页本身的接口相比与其他静态编程语言，如java，c#，c++，python抓取网页文档的接口更简洁；相比其他动态脚本语言，如perl，shell，python的urllib包提供了较为完整的访问网页文档的API。（当然ruby也是很好的选择）此外，抓取网页有时候需要模拟浏览器的行为，很多网站对于生硬的爬虫抓取都是封杀的。这是我们需要模拟user agent的行为构造合适的请求，譬如模拟用户登陆、模拟session/cookie的存储和设置。在python里都有非常优秀的第三方包帮你搞定，如Requests，mechanize
2、网页抓取后的处理抓取的网页通常需要处理，比如过滤html标签，提取文本等。python的beautifulsoap提供了简洁的文档处理功能，能用极短的代码完成大部分文档的处理。其实以上功能很多语言和工具都能做，但是用python能够干得最快，最干净。

Life is short, you need python.

PS：python2.x和python3.x有很大不同，本文只讨论python3.x的爬虫实现方法。


爬虫架构架构组成URL管理器：管理待爬取的url集合和已爬取的url集合，传送待爬取的url给网页下载器。网页下载器（urllib）：爬取url对应的网页，存储成字符串，传送给网页解析器。网页解析器（BeautifulSoup）：解析出有价值的数据，存储下来，同时补充url到URL管理器。
运行流程
URL管理器基本功能
添加新的url到待爬取url集合中。
判断待添加的url是否在容器中（包括待爬取url集合和已爬取url集合）。
获取待爬取的url。
判断是否有待爬取的url。
将爬取完成的url从待爬取url集合移动到已爬取url集合。

存储方式1、内存（python内存）待爬取url集合：set()已爬取url集合：set()
2、关系数据库（mysql）urls(url, is_crawled)
3、缓存（redis）待爬取url集合：set已爬取url集合：set
大型互联网公司，由于缓存数据库的高性能，一般把url存储在缓存数据库中。小型公司，一般把url存储在内存中，如果想要永久存储，则存储到关系数据库中。
网页下载器（urllib）将url对应的网页下载到本地，存储成一个文件或字符串。
基本方法新建baidu.py，内容如下：
import urllib.requestresponse = urllib.request.urlopen('http://www.baidu.com')buff = response.read()html = buff.decode("utf8")print(html)
命令行中执行python baidu.py，则可以打印出获取到的页面。
构造Request上面的代码，可以修改为：
import urllib.requestrequest = urllib.request.Request('http://www.baidu.com')response = urllib.request.urlopen(request)buff = response.read()html = buff.decode("utf8")print(html)

携带参数新建baidu2.py，内容如下：
import urllib.requestimport urllib.parseurl = 'http://www.baidu.com'values = &#123;'name': 'voidking','language': 'Python'&#125;data = urllib.parse.urlencode(values).encode(encoding='utf-8',errors='ignore')headers = &#123; 'User-Agent' : 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0' &#125;request = urllib.request.Request(url=url, data=data,headers=headers,method='GET')response = urllib.request.urlopen(request)buff = response.read()html = buff.decode("utf8")print(html)

使用Fiddler监听数据我们想要查看一下，我们的请求是否真的携带了参数，所以需要使用fiddler。打开fiddler之后，却意外发现，上面的代码会报错504，无论是baidu.py还是baidu2.py。虽然python有报错，但是在fiddler中，我们可以看到请求信息，确实携带了参数。
经过查找资料，发现python以前版本的Request都不支持代理环境下访问https。但是，最近的版本应该支持了才对。那么，最简单的办法，就是换一个使用http协议的url来爬取，比如，换成http://www.csdn.net。结果，依然报错，只不过变成了400错误。
然而，然而，然而。。。神转折出现了！！！当我把url换成http://www.csdn.net/后，请求成功！没错，就是在网址后面多加了一个斜杠/。同理，把http://www.baidu.com改成http://www.baidu.com/，请求也成功了！神奇！！！
添加处理器
import urllib.requestimport http.cookiejar# 创建cookie容器cj = http.cookiejar.CookieJar()# 创建openeropener = urllib.request.build_opener(urllib.request.HTTPCookieProcessor(cj))# 给urllib.request安装openerurllib.request.install_opener(opener)# 请求request = urllib.request.Request('http://www.baidu.com/')response = urllib.request.urlopen(request)buff = response.read()html = buff.decode("utf8")print(html)print(cj)

网页解析器（BeautifulSoup）从网页中提取出有价值的数据和新的url列表。
解析器选择为了实现解析器，可以选择使用正则表达式、html.parser、BeautifulSoup、lxml等，这里我们选择BeautifulSoup。其中，正则表达式基于模糊匹配，而另外三种则是基于DOM结构化解析。
BeautifulSoup安装测试1、安装，在命令行下执行pip install beautifulsoup4。2、测试
import bs4print(bs4)

使用说明
基本用法1、创建BeautifulSoup对象
import bs4from bs4 import BeautifulSoup# 根据html网页字符串创建BeautifulSoup对象html_doc = """&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class="title"&gt;&lt;b&gt;The Dormouse's story&lt;/b&gt;&lt;/p&gt;&lt;p class="story"&gt;Once upon a time there were three little sisters; and their names were&lt;a href="http://example.com/elsie" class="sister" id="link1"&gt;Elsie&lt;/a&gt;,&lt;a href="http://example.com/lacie" class="sister" id="link2"&gt;Lacie&lt;/a&gt; and&lt;a href="http://example.com/tillie" class="sister" id="link3"&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class="story"&gt;...&lt;/p&gt;"""soup = BeautifulSoup(html_doc)print(soup.prettify())

2、访问节点
print(soup.title)print(soup.title.name)print(soup.title.string)print(soup.title.parent.name)print(soup.p)print(soup.p['class'])

3、指定tag、class或id
print(soup.find_all('a'))print(soup.find('a'))print(soup.find(class_='title'))print(soup.find(id="link3"))print(soup.find('p',class_='title'))

4、从文档中找到所有&lt;a&gt;标签的链接
for link in soup.find_all('a'):    print(link.get('href'))
出现了警告，根据提示，我们在创建BeautifulSoup对象时，指定解析器即可。
soup = BeautifulSoup(html_doc,'html.parser')

5、从文档中获取所有文字内容
print(soup.get_text())

6、正则匹配
link_node = soup.find('a',href=re.compile(r'til'))print(link_node)


后记python爬虫基础知识，至此足够，接下来，在实战中学习更高级的知识。
书签Python开发简单爬虫http://www.imooc.com/learn/563
The Python Standard Libraryhttps://docs.python.org/3/library/index.html
Beautiful Soup 4.2.0 文档https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html
为什么python适合写爬虫？http://www.cnblogs.com/benzone/p/5854084.html
如何学习Python爬虫[入门篇]？https://zhuanlan.zhihu.com/p/21479334?refer=passer
你需要这些：Python3.x爬虫学习资料整理https://zhuanlan.zhihu.com/p/24358829?refer=passer
如何入门 Python 爬虫？https://www.zhihu.com/question/20899988
Python3.X 抓取网络资源http://www.open-open.com/lib/view/open1396062681294.html
python网络请求和”HTTP Error 504:Fiddler - Receive Failure”http://blog.csdn.net/guoguo527/article/details/50709244
怎么使用Fiddler抓取自己写的爬虫的包？https://www.zhihu.com/question/52614615
fiddler对python脚本抓取https包时发生了错误?https://www.zhihu.com/question/42104344?sort=created
HTTPS和HTTP的区别http://blog.csdn.net/whatday/article/details/38147103
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>jQuery学习笔记——选择器篇</title>
    <url>/dev-jquery-selector/</url>
    <content><![CDATA[选择器语法jQuery选择元素的语法为：$(selector,[content]);
如果第一个参数是选择器，那么第二个参数就是指示该操作的上下文，默认为整个DOM文档。上下文参数可以是DOM元素的引用，也可以包含jQuery选择器的字符串，或者是DOM元素包装集。
上文hello voidking中的html文件内容修改为：
&lt;html&gt;&lt;head&gt;		&lt;script type="text/javascript" src="jquery-1.10.2.js"&gt;&lt;/script&gt;	&lt;script type="text/javascript"&gt;		$(function()&#123;			$("p","div#voidking").css("color","red");		&#125;);	&lt;/script&gt;&lt;/head&gt;&lt;body&gt;	&lt;div id="voidking"&gt;		&lt;p&gt;			welcome to jQuery world !		&lt;/p&gt;	&lt;/div&gt;	&lt;p&gt;		welcome to jQuery world !	&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

在浏览器中打开，我们发现，只有第一行是红色的。这是因为，$(“p”,”div#voidking”)指定的范围是：id值为voidking的元素内。
CSS基本选择器id选择器获取一个id为voidking的元素。
在CSS中：
#voidking&#123;	color:red;&#125;
在jQuery中：
$("#voidking").css("color","red");
class选择器获取所有class为voidking的元素。
在CSS中：
.voidking&#123;	color:red;&#125;
在jQuery中：
$(".voidking").css("color","red");
标签选择器获取所有标签名为div的元素。
在CSS中：
div&#123;	color:red;&#125;
在jQuery中：
$("div").css("color","red");
群组选择器获取标签名为span、em和class为voidking的所有元素。
在CSS中：
span,em,.voidking&#123;	color:red;&#125;
在jQuery中：
$("span,em,.voidking").css("color","red");

后代选择器获取标签名为ul下的标签名为li下的标签名为a的所有元素。
在CSS中：
ul li a&#123;	color:red;&#125;
在jQuery中：
$("ul li a").css("color","red");
或者
$("ul").find("li").find("a").css("color", "red");

通配选择器获取所有元素，一般不使用。
在CSS中：
*&#123;	color:red;&#125;
在jQuery中：
$("*").css("color","red");

组合上面的六种选择器，已经可以满足大部分的选择需要。而它们还可以结合起来使用。
$("div.voidking,ul li a").css("color","red");

CSS高级选择器子选择器选择id为voidking的元素下，子标签为p的元素。
在CSS中：
#voidking &gt; p&#123;	color:red;&#125;
在jQuery中：
$("#voidking &gt; p").css("color","red");
或者
$("#voidking").children("p").css("color", "red");

同级下一个选择器选择和id为voidking的元素同级的，下一个标签为p的元素。
在CSS中：
#voidking + p&#123;	color:red;&#125;
在jQuery中：
$("#voidking + p").css("color","red");
或者
$("#voidking").next("p").css("color", "red");

同级所有下面选择器选择和id为voidking的元素同级的，下面所有标签为p的元素。
在CSS中：
#voidking ~ p&#123;	color:red;&#125;
在jQuery中：
$("#voidking ~ p").css("color","red");
或者
$("#voidking").nextAll("p").css("color", "red");
PS在find()、children()、next()、nextAll()四个函数中，如果不传入参数，默认为”*”。
建议使用方法而不是符号，理论上讲，使用方法的效率高于使用符号，而且，使用方法更加易读易懂。
接下来的选择器就没有类似于” “、”&gt;”、”+”、”~”这样的符号了，全部由函数来完成。
同级上一个选择器选择和id为voidking的元素同级的，上一个标签为p的元素。
$("#voidking").prev("p").css("color", "red");
同级所有上面选择器选择和id为voidking的元素同级的，上面所有标签为p的元素。
$("#voidking").prevAll("p").css("color", "red");
同级上下所有选择器$("#voidking").siblings("p").css("color", "red");
等价于
$("#voidking").prevAll("p").css("color", "red");$("#voidking").nextAll("p").css("color", "red");
非指定选择器同级上、下非指定元素选定，遇到则停止。
$("#voidking").prevUntil("p").css("color", "red");$("#voidking").nextUntil("p").css("color", "red");

属性选择器精确匹配$('[id='voidking']').css("color",'red');
$('div[id='voidking']').css("color",'red');

精确不匹配$("p[class != 'voidking']").css("color",'red');

匹配开头$("[id ^= 'void']").css("color","red");

匹配结尾$("[id $= 'king']").css("color","red");

其他


CSS选择器
jQuery选择器
描述



elem[id]
$(“elem[id]”)
选择具有id属性的元素


elem[id |= ‘void’]
$(“elem[id\
= ‘void’]”)


elem[class ~= ‘voidking’]
$(“elem[id ~= ‘voidking’]”)
选择具有class属性，且属性值是一个以空格分格的列表，其中包含voidking的元素


elem[id *= ‘oidki’]
$(“elem[id *= ‘oidki’]”)
选择具有id属性,且属性值中包含”oidki”字串的元素


过滤选择器位置选择器


jQuery选择器
描述



$(“li:first”)
返回匹配集合的第一个元素


$(“li:last”)
返回匹配集合的最后一个元素


$(“li:odd”)
返回匹配集合的奇数成员


$(“li:even”)
返回匹配集合的偶数成员


$(“li:eq(3)”)
返回匹配集合的索引值等于3的元素（第4个元素）


$(“li:not(3)”)
返回匹配集合的索引值不等于3的所有元素


$(“li:gt(2)”)
返回匹配集合的索引值大于2的所有元素


$(“li:lt(3)”)
返回匹配集合的索引值小于3的所有元素


基本过滤选择器基本过滤选择器包括位置选择器，比位置选择器多了一些东东：| 过滤器 |  描述 || ——-  | ——- || :animated |  选择当前正在执行动画的所有元素 || :header |  选择所有的标题元素，比如h1、h2、h3等 |
过滤表单元素


过滤器
描述



:text
选择所有类型为text的元素


:password
选择所有类型为password的元素


:radio
选择所有类型为radio的元素


:checkbox
选择所有类型为checkbox的元素


:checked
匹配所有已被选中的元素


:image
选择所有类型为image的元素


:file
选择所有类型为file的元素


:submit
选择所有类型为submit的元素


:reset
选择所有类型为reset的元素


:button
选择所有button元素和类型为botton的元素


:input
选择所有input、textarea、select和button元素


:selected
选择所有类型已选中的元素


:enabled
选择所有可用元素


:disabled
选择所有不可用元素


可见性过滤器


过滤器
描述



:visible
选择所有可见元素


:hidden
选择所有隐藏元素


内容过滤器


过滤器
描述



:contains()
选择所有包含特定文本内容的元素


:has()
选择至少含有一个元素与制定选择器匹配的元素


:empty
选择所有不包含子元素或文本的空元素


:parent
选择所有含有子元素或文本节点的元素


关系过滤器


过滤器
描述



:first-child
选择每个父元素的第一个子元素


:last-child
选择每个父元素的最后一个子元素


:nth-child
选择每个父元素的第nth-child()个子元素


:only-child
选择具有唯一一个子元素的元素


自定义选择器有些时候，jQuery提供的选择器不够用，我们就需要自己创建选择器。比如，我们需要选择具有绿色背景的元素：
&lt;html&gt;&lt;head&gt;		&lt;script type="text/javascript" src="jquery-1.10.2.js"&gt;&lt;/script&gt;	&lt;script type="text/javascript"&gt;		$(function()&#123;			//通过扩展$.expr[":"]实现自定义选择器			$.expr[":"].greenbg = function(element)&#123;				return $(element).css("background-color") === "green";			&#125;;				//此处兼容性问题。输出在Firefox和IE中有所不同，Firefox值为0，IE值为1。			alert($(":greenbg").length);			$(":greenbg").text("hello voidking");		&#125;);	&lt;/script&gt;&lt;/head&gt;&lt;body&gt;	&lt;div style="width:200 ; height:200 ; background-color:green;" &gt;&lt;/div&gt;	&lt;div style="width:200 ; height:200 ; background-color:red;" &gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;
结束语我靠，选择器这块实在是太难搞了！一天一夜才完成这份总结。内容纯手打，代码测试通过！
参考文档李炎恢的jQuery视频教程《jQuery攻略（作者B.M.Harwani）》《jQuery实战（作者Bear Bibeault、Yehuda Katz）》《jQuery高级编程（作者 Cesar Otero、Rob Larsen）》《jQuery Javascript 与CSS开发入门经典（作者Richard York）》
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>jquery</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基础</title>
    <url>/dev-python-start/</url>
    <content><![CDATA[前言Python，是龟叔在1989年为了打发无聊的圣诞节而编写的一门编程语言，特点是优雅、明确、简单，现今拥有丰富的标准库和第三方库。Python适合开发Web网站和各种网络服务，系统工具和脚本，作为“胶水”语言把其他语言开发的模块包装起来使用，科学计算等等。
郝同学学习Python的理由有三个：为了爬取需要的各种数据，不妨学习一下Python。为了分析数据和挖掘数据，不妨学习一下Python。为了做一些好玩有趣的事，不妨学习一下Python。

准备工作1、在Python官网下载安装喜欢的版本，郝同学使用的，是当前最新版本3.6.0。2、打开IDLE，这是Python的集成开发环境，尽管简单，但极其有用。IDLE包括一个能够利用颜色突出显示语法的编辑器、一个调试工具、Python Shell，以及一个完整的Python3在线文档集。
hello world1、在IDLE中，输入print(&#39;hello world&#39;)，回车，则打印出hello world。PS：语句末尾加不加分号;都可以，郝同学决定不加分号，更简单。
2、使用sublime新建文件hello.py，内容如下：
print('hello world')
在Windows下，shift+右键，在此处打开命令窗口，执行python hello.py，回车，则打印出hello world。
3、使用sublime新建文件hello.py，内容如下：
#!/usr/bin/env pythonprint('hello world')
在Linux或Mac环境下，可以直接运行脚本。首先添加执行权限chmod a+x hello.py，然后执行./hello.py。当然，也可以和Windows一样，使用python hello.py来执行脚本。
引入模块1、新建name.py，内容如下：
name='voidking'
2、执行python name.py。3、进入python shell模式，执行import name，print(name.name)，则打印出voidking。
基础语法常用函数（print）、数据类型、表达式、变量、条件和循环、函数。和其他语言类似，下面选择一部分展开。
list链表数组1、定义数组myList = [&#39;Hello&#39;, 100, True]2、输出数组print(myList)3、输出数组元素print(myList[0])，print(myList[-1])4、追加元素到末尾myList.append(&#39;voidking&#39;)5、追加元素到头部myList.insert(0,&#39;voidking&#39;)6、删除元素myList.pop()，myList.pop(0)7、元素赋值myList[0]=&#39;hello666&#39;
tuple固定数组1、定义数组myTuple = (&#39;Hello&#39;, 100, True)错误定义：myTuple1=(1)，正确定义：myTuple=(1,)2、输出数组print(myTuple)3、输出数组元素print(myTuple[0])4、tuple和list结合t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])，t[2][0]=&#39;X&#39;
if语句ifscore = 75if score&gt;=60:    print 'passed'
两次回车，即可执行代码。
if-elseif score&gt;=60:    print('passed')else:    print('failed')

if-elif-elseif score&gt;=90:    print('excellent')elif score&gt;=80:    print('good')elif score&gt;=60:    print('passed')else:    print('failed')

循环for循环L = [75, 92, 59, 68]sum = 0.0for score in L:       sum += scoreprint(sum / 4)

while循环sum = 0x = 1while x&lt;100:    sum += x    x = x + 1print(sum)

breaksum = 0x = 1while True:    sum = sum + x    x = x + 1    if x &gt; 100:        breakprint(sum)

continueL = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L:    if x &lt; 60:        continue    sum = sum + x    n = n + 1print(sum/n)

多重循环for x in ['A', 'B', 'C']:    for y in ['1', '2', '3']:        print(x + y)

dictdict的作用是建立一组 key和一组value的映射关系。
d = &#123;    'Adam': 95,    'Lisa': 85,    'Bart': 59,    'Paul': 75&#125;print(d)print(d['Adam'])print(d.get('Lisa'))d['voidking']=100print(d)for key in d:    print(key+':',d.get(key))

setset持有一系列元素，这一点和list很像，但是set的元素没有重复，而且是无序的，这点和dict的key很像。
s = set(['Adam', 'Lisa', 'Bart', 'Paul'])print(s)s = set(['Adam', 'Lisa', 'Bart', 'Paul', 'Paul'])print(s)len(s)print('Adam' in s)print('adam' in s)for name in s:    print(name)

s = set([('Adam', 95), ('Lisa', 85), ('Bart', 59)])for x in s:    print(x[0]+':',x[1])

s.add(100)print(s)s.remove(('Adam',95))print(s)

函数自带函数L = [x*x for x in range(1,101)]print(sum(L))

自定义函数def my_abs(x):    if x &gt;= 0:        return x    else:        return -xprint(my_abs(-100))

引入函数库import mathdef quadratic_equation(a, b, c):    x = b * b - 4 * a * c    if x &lt; 0:        return none    elif x == 0:        return -b / (2 *a)    else:        return ((math.sqrt(x) - b ) / (2 * a)) , ((-math.sqrt(x) - b ) / (2 * a))print(quadratic_equation(2, 3, 0))print(quadratic_equation(1, -6, 5))

可变参数def average(*args):    if args:        return sum(args)*1.0/len(args)    else:        return 0.0print(average())print(average(1, 2))print(average(1, 2, 2, 3, 4))

切片list切片L = ['Adam', 'Lisa', 'Bart', 'Paul']print(L[0:3])print(L[:3])print(L[1:3])print(L[:])print(L[::2])

倒序切片print(L[-2:])print(L[-3:-1])print(L[-4:-1:2])

L = range(1, 101)print(L[-10:])print(L[4::5][-10:])
PS：range是有序的list，默认以函数形式表示，执行range函数，即可以list形式表示。
字符串切片def firstCharUpper(s):    return s[0:1].upper() + s[1:]print(firstCharUpper('hello'))

迭代Python的for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用for循环总是可以依次取出集合的每一个元素。集合是指包含一组元素的数据结构，包括：

有序集合：list，tuple，str和unicode；
无序集合：set
无序集合并且具有key-value对：dict

for i in range(1,101):    if i%7 == 0:        print(i)

索引迭代对于有序集合，元素是有索引的，如果我们想在for循环中拿到索引，怎么办？方法是使用enumerate()函数。
L = ['Adam', 'Lisa', 'Bart', 'Paul']for index, name in enumerate(L):    print(index+1, '-', name)myList = zip([100,20,30,40],L);for index, name in myList:    print(index, '-', name)

迭代dict的valued = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;print(d.values())for v in d.values():    print(v)

PS：Python3.x中，dict的方法dict.keys()，dict.items()，dict.values()不会再返回列表，而是返回一个易读的“views”。这样一来，k = d.keys();k.sort()不再有用，可以使用k = sorted(d)来代替。同时，dict.iterkeys()，dict.iteritems()，dict.itervalues()方法不再支持。
迭代dict的key和valued = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;for key, value in d.items():    print(key, ':', value)

列表生成一般表达式L = [x*(x+1) for x in range(1,100)]print(L)

复杂表达式d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;def generate_tr(name, score):    if score &gt;=60:        return '&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score)    else:        return '&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style="color:red"&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score)tds = [generate_tr(name,score) for name, score in d.items()]print('&lt;table border="1"&gt;')print('&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;')print('\n'.join(tds))print('&lt;/table&gt;')

条件表达式L = [x * x for x in range(1, 11) if x % 2 == 0]print(L)

def toUppers(L):    return [x.upper() for x in L if isinstance(x,str)]print(toUppers(['Hello', 'world', 101]))

多层表达式L = [m + n for m in 'ABC' for n in '123']print(L)

L = [a*100+b*10+c for a in range(1,10) for b in range(0,10) for c in range(1,10) if a==c]print(L)

后记至此，Python基础结束。接下来，爬虫飞起！
书签Python官网
Python 3.6.10 documentation
PEP 8 – Style Guide for Python Code
Python入门
如何学习Python爬虫？
你需要这些：Python3.x爬虫学习资料整理
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>scikit-learn</title>
    <url>/dev-scikit-learn/</url>
    <content><![CDATA[前言本文转载自优达学城《机器学习工程师》


scikit-learn 的安装检查您是否装有可用的 python。优达学城使用 python 2.7 作为示例代码和在浏览器中完成作业的代码。
我们会使用 pip 来安装一些程序包。首先，在此处获取并安装 pip。如果你使用Anaconda, 你可以用 conda 命令来安装包。
使用 pip 或 anaconda 来安装 scikit-learn：

打开 Terminal（mac 下是 Terminal， PC 是 cmd）用下列命令安装 sklearn
pip install scikit-learn 或者 conda install scikit-learn
如果你不用 pip 或者 conda，可以在这里找到安装说明。

关于 scikit-learn 版本的重要通知scikit-learn 最近把稳定版升级到了 v0.18。这次升级改变了一些我们将要在课程中讲到的函数的调用方法，例如：train_test_split、gridSearchCV、ShuffleSplit 和 learning_curves。scikit-learn 网站上的文档已经更新到了 v0.18。但是 Katie 导师的讲解以及优达学城（Udacity）的练习，作业还是基于v0.17。如果你需要查询 scikit-learn 的文档，请查询 v0.17 的说明，而非 v0.18。近期我们会把内容统一升级成 v0.18。
这个论坛链接提供了更加详细的说明。如果你还有疑问，可以在论坛和微信群里提出。
Scikit-learn 代码在接下来的部分中，Katie 会演示如何将 scikit-learn（或 sklearn）文档与在“机器学习简介”课程中介绍的高斯朴素贝叶斯模型一起使用。对于本练习，您不必熟悉朴素贝叶斯或者 Katie 演示的代码，而是要熟悉 sklearn 的布局，以便之后能评估和验证任何数据模型。
在即将开始的“监督式机器学习”课程中，我们会更详细地介绍朴素贝叶斯以及其他有用的受监督模型，并运用我们在本课程中学到的知识评估每个模型的优缺点。
如果想提前了解一下朴素贝叶斯，请查看此链接。
sklearn使用入门在谷歌上搜索“sklearn naive bayes”即可。
高斯朴素贝叶斯示例http://scikit-learn.org/stable/modules/generated/sklearn.naive_bayes.GaussianNB.html
有关地形数据的高斯 NB 部署studentMain.py# -*- coding: UTF-8 -*-#!/usr/bin/python""" Complete the code in ClassifyNB.py with the sklearn    Naive Bayes classifier to classify the terrain data.        The objective of this exercise is to recreate the decision     boundary found in the lesson video, and make a plot that    visually shows the decision boundary """from prep_terrain_data import makeTerrainDatafrom class_vis import prettyPicture, output_imagefrom ClassifyNB import classifyimport numpy as npimport pylab as plfeatures_train, labels_train, features_test, labels_test = makeTerrainData()### the training data (features_train, labels_train) have both "fast" and "slow" points mixed### in together--separate them so we can give them different colors in the scatterplot,### and visually identify themgrade_fast = [features_train[ii][0] for ii in range(0, len(features_train)) if labels_train[ii]==0]bumpy_fast = [features_train[ii][1] for ii in range(0, len(features_train)) if labels_train[ii]==0]grade_slow = [features_train[ii][0] for ii in range(0, len(features_train)) if labels_train[ii]==1]bumpy_slow = [features_train[ii][1] for ii in range(0, len(features_train)) if labels_train[ii]==1]# You will need to complete this function imported from the ClassifyNB script.# Be sure to change to that code tab to complete this quiz.clf = classify(features_train, labels_train)### draw the decision boundary with the text points overlaidprettyPicture(clf, features_test, labels_test)output_image("test.png", "png", open("test.png", "rb").read())

class_vis.py# -*- coding: UTF-8 -*-#!/usr/bin/python#from udacityplots import *import warningswarnings.filterwarnings("ignore")import matplotlib matplotlib.use('agg')import matplotlib.pyplot as pltimport pylab as plimport numpy as np#import numpy as np#import matplotlib.pyplot as plt#plt.ioff()def prettyPicture(clf, X_test, y_test):    x_min = 0.0; x_max = 1.0    y_min = 0.0; y_max = 1.0    # Plot the decision boundary. For that, we will assign a color to each    # point in the mesh [x_min, m_max]x[y_min, y_max].    h = .01  # step size in the mesh    xx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])    # Put the result into a color plot    Z = Z.reshape(xx.shape)    plt.xlim(xx.min(), xx.max())    plt.ylim(yy.min(), yy.max())    plt.pcolormesh(xx, yy, Z, cmap=pl.cm.seismic)    # Plot also the test points    grade_sig = [X_test[ii][0] for ii in range(0, len(X_test)) if y_test[ii]==0]    bumpy_sig = [X_test[ii][1] for ii in range(0, len(X_test)) if y_test[ii]==0]    grade_bkg = [X_test[ii][0] for ii in range(0, len(X_test)) if y_test[ii]==1]    bumpy_bkg = [X_test[ii][1] for ii in range(0, len(X_test)) if y_test[ii]==1]    plt.scatter(grade_sig, bumpy_sig, color = "b", label="fast")    plt.scatter(grade_bkg, bumpy_bkg, color = "r", label="slow")    plt.legend()    plt.xlabel("bumpiness")    plt.ylabel("grade")    plt.savefig("test.png")    import base64import jsonimport subprocessdef output_image(name, format, bytes):    image_start = "BEGIN_IMAGE_f9825uweof8jw9fj4r8"    image_end = "END_IMAGE_0238jfw08fjsiufhw8frs"    data = &#123;&#125;    data['name'] = name    data['format'] = format    data['bytes'] = base64.encodestring(bytes)    print image_start+json.dumps(data)+image_end

prep_terrain_data.py# -*- coding: UTF-8 -*-#!/usr/bin/pythonimport randomdef makeTerrainData(n_points=1000):################################################################################## make the toy dataset    random.seed(42)    grade = [random.random() for ii in range(0,n_points)]    bumpy = [random.random() for ii in range(0,n_points)]    error = [random.random() for ii in range(0,n_points)]    y = [round(grade[ii]*bumpy[ii]+0.3+0.1*error[ii]) for ii in range(0,n_points)]    for ii in range(0, len(y)):        if grade[ii]&gt;0.8 or bumpy[ii]&gt;0.8:            y[ii] = 1.0### split into train/test sets    X = [[gg, ss] for gg, ss in zip(grade, bumpy)]    split = int(0.75*n_points)    X_train = X[0:split]    X_test  = X[split:]    y_train = y[0:split]    y_test  = y[split:]    grade_sig = [X_train[ii][0] for ii in range(0, len(X_train)) if y_train[ii]==0]    bumpy_sig = [X_train[ii][1] for ii in range(0, len(X_train)) if y_train[ii]==0]    grade_bkg = [X_train[ii][0] for ii in range(0, len(X_train)) if y_train[ii]==1]    bumpy_bkg = [X_train[ii][1] for ii in range(0, len(X_train)) if y_train[ii]==1]#    training_data = &#123;"fast":&#123;"grade":grade_sig, "bumpiness":bumpy_sig&#125;#            , "slow":&#123;"grade":grade_bkg, "bumpiness":bumpy_bkg&#125;&#125;    grade_sig = [X_test[ii][0] for ii in range(0, len(X_test)) if y_test[ii]==0]    bumpy_sig = [X_test[ii][1] for ii in range(0, len(X_test)) if y_test[ii]==0]    grade_bkg = [X_test[ii][0] for ii in range(0, len(X_test)) if y_test[ii]==1]    bumpy_bkg = [X_test[ii][1] for ii in range(0, len(X_test)) if y_test[ii]==1]    test_data = &#123;"fast":&#123;"grade":grade_sig, "bumpiness":bumpy_sig&#125;            , "slow":&#123;"grade":grade_bkg, "bumpiness":bumpy_bkg&#125;&#125;    return X_train, y_train, X_test, y_test#    return training_data, test_data

ClassifyNB.py# -*- coding: UTF-8 -*-def classify(features_train, labels_train):       ### import the sklearn module for GaussianNB    ### create classifier    ### fit the classifier on the training features and labels    ### return the fit classifier            ### your code goes here!    def classify(traindata,trainlabel):        from sklearn.naive_bayes import GaussianNB        classifier=GaussianNB()        classifier.fit(traindata, trainlabel)        return classifier

]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>在node项目中使用Sea.js</title>
    <url>/dev-seajs-in-node/</url>
    <content><![CDATA[前言Sea.js 追求简单、自然的代码书写和组织方式，具有以下核心特性：

简单友好的模块定义规范：Sea.js遵循CMD规范，可以像Node.js一般书写模块代码。
自然直观的代码组织方式：依赖的自动加载、配置的简洁清晰，可以让我们更多地享受编码的乐趣。

Sea.js还提供常用插件，非常有助于开发调试和性能优化，并具有丰富的可扩展接口。


配置下载seajsseajs官方下载：http://seajs.org/docs/#downloads
项目结构
概念说明下面明确几个概念，方便接下来的描述：1、/（网站根目录），是项目目录nodebase。2、虚拟路径，是node把某个文件（夹）转化之后，该文件（夹）的相对于/的路径。3、访问路径，是通过浏览器url访问的路径。

虚拟路径不一定是访问路径，访问路径不一定是虚拟路径。因为，只有我们指定的资源、指定的路径是开放给用户访问的。

静态资源配置// 把文件夹中的内容添加到网站根目录下，静态文件务必添加，否则访问不到app.use(express.static(path.join(__dirname, 'bower_components')));app.use(express.static(path.join(__dirname, 'public')));
在node项目的入口文件app.js中，加入如上配置，那么，bower_components、public两个文件夹的虚拟路径都变成了/，访问路径都变成了/。
// 静态文件目录var staticDir = path.join(__dirname, 'public');// 虚拟目录app.use('/dist', express.static(staticDir));app.use('/public', express.static(staticDir));
在node项目的入口文件app.js中，加入如上配置，那么，public文件夹的虚拟路径就变成了/dist和/public，访问路径就变成了/dist和/public。
通过上面两个配置，可以看出，静态资源的虚拟路径和访问路径是相同的。
sea-config.jsseajs.config(&#123;    //base: '../',    base: window.host + '/',    alias: &#123;        'jquery': 'seajs/jquery/jquery.min.js',        'layer': 'seajs/layer/layer.js',        'swiper': 'Swiper/dist/js/swiper.min.js'           &#125;&#125;);
如果base的值使用相对路径../，那么页面引入依赖的js文件的时候，就是相对于页面文件的虚拟路径。
app.set('views','./views');// 页面目录配置
举个例子，在app.js中使用了页面目录配置，views文件夹虚拟路径变成了/。注意，views文件夹依然没有访问路径。
views文件夹的目录结构如下：
views|-weixin| |-home.html|-index.html

在路由转发中，index.html和home.html的虚拟路径分别如下：
res.render('index',&#123;    title: 'index'&#125;);res.render('weixin/home',&#123;    title: 'home'&#125;);
在index.html中引入sea-config.js，在加载依赖的js文件的时候，会在index.html的基础上向上一层寻找。因为index.html所在的虚拟路径为/，没有上一层，所以肯定找不到js文件。
而home.html所在的虚拟路径为/weixin/，向上一层寻找，是虚拟路径/。而静态文件的虚拟路径都是/，刚好可以找到需要的js文件。

鉴于相对路径的差异问题，base最好使用绝对路径，配置在全局config.js中。

home.jsseajs.use(['jquery','layer'],function($,layer)&#123;    var index = &#123;        init:function()&#123;            this.saveData();            this.bindEvent();        &#125;,        saveData: function()&#123;            if(window.localStorage)&#123;                var x = window.localStorage.userInfo? JSON.parse(window.localStorage.userInfo):&#123;&#125;;                if((x.unionid == undefined) || (x.unionid == "undefined"))&#123;                    var temp = &#123;                        unionid: $('#unionid').val(),                        openid: $('#openid').val(),                        nickname: $('#nickname').val(),                        headimgurl:$ ('#headimgurl').val()                    &#125;;                    window.localStorage.userInfo = JSON.stringify(temp);                &#125;            &#125;        &#125;,        bindEvent:function()&#123;            layer.alert('layer');        &#125;    &#125;    index.init();&#125;);

引入js文件&lt;script&gt;    window.host = '&lt;%= host%&gt;';&lt;/script&gt;&lt;script src="/seajs/seajs-1.3.1/dist/sea.js"&gt;&lt;/script&gt;&lt;script src="/seajs/sea-config.js"&gt;&lt;/script&gt;&lt;script src="/js/weixin/home.js"&gt;&lt;/script&gt;

CMD模块化不封装因为seajs遵循CMD规范，所以遵循CMD规范的插件，比如swiper，引入后就可以使用。
jquery封装jquery遵循AMD规范，需要封装一下，使其符合CMD规范才可以使用，否则会报错。
define(function(require, exports, module) &#123;    // 模块化jquery源码&#125;);

依赖jquery的插件封装有些插件，是在jquery的基础上的开发的，需要先引入jquery。
define(function(require, exports, module) &#123;    var $ = require('jquery');    // 依赖jquery的模块化代码&#125;);

另外一种方法：
define(function(require, exports, module) &#123;    return function($)&#123;        // 依赖jquery的模块化代码    &#125; &#125;);
这种方法在使用模块前需要先传入jquery进行初始化。
普通插件封装如果是未模块化的插件（普通js代码），需要暴露对应的接口。
define(function(require, exports, module) &#123;    var $ = require('jquery');    var voidking = &#123;        init: function()&#123;            // 未模块化代码            var height = $(document).height();            console.log(height);        &#125;    &#125;;    module.exports = voidking;&#125;);
在使用模块前需要调用init方法初始化。
layer的坑不封装不对layer.js进行封装，直接引入时，会报错jQuery is not defined。需要说明的是，在使用layer-mobile.js的时候，不需要封装就可以正常使用。
封装由上面的报错，可以看出，layer.js需要依赖jquery，那就封装一下，引入jquery吧！
define(function(require, exports, module) &#123;    var jQuery = require('jquery');    // layer.js代码&#125;);
然后，错误就变成了layer.alert is not a function。在控制台输入layer，可以看到layer是一个对象。啊嘞，layer对象明明包含了一个alert方法！！！为啥不能调用捏？
不甘心的郝同学，又尝试了很多其他的封装方法，依然无法使用。
不完美解决办法layer的作者贤心说，layer是CMD规范的。那么，理论上直接引入就可以使用。但是，错误当道，jQuery is not defined。那么问题的关键，就是给layer.js引入jquery。
使用封装的办法，引入jquery，经过测试，行不通。
如果直接把jquery源码粘贴到layer.js文件中，是否可以呢？经过测试，确实可以！！！
好吧，这个坑总算是填上了。虽然不够完美，但是确实是个有效的方法！如果有更好的解决的办法，希望能留言告诉我，谢谢。
seajs模块加载顺序1、从seajs.use方法入口，开始加载use到的模块。2、use到的模块这时mod缓存当中一定是不存在的，seajs创建一个新的mod，赋予一些初始的状态。3、执行mod.load方法。4、一堆逻辑之后走到seajs.request方法，请求模块文件。模块加载完成之后，执行define方法。5、define方法分析提取模块的依赖模块，保存起来，缓存factory但不执行。6、模块的依赖模块再被加载，如果继续有依赖模块，则继续加载，直至所有被依赖的模块都加载完毕。7、所有的模块加载完毕之后，执行use方法的callback。8、模块内部逻辑从callback开始执行，require方法在这个过程当中才被执行。PS: define方法纯粹只是分析模块、存储模块，并没有执行模块。require方法就是根据id在define定义存储的模块缓存中找到相应的模块，并执行它，获得模块定义返回的方法。
后记也许，参加Sea.js的社区维护也是一件很好玩的事情。又多了很多许多需要学习的东西，路漫漫其修远兮！
书签Seajs简易文档http://yslove.net/seajs/
快速上手seajs——简单易用Seajshttp://www.tuicool.com/articles/3uIZzy
seajs base配置http://www.tuicool.com/articles/3Eb6Fj
jQuery 插件的模块化https://lifesinger.wordpress.com/jquery-plugins-modulization/
seajs 加载Jquery的遇到问题?https://www.zhihu.com/question/21703739
如何改造现有文件为 CMD 模块https://github.com/seajs/seajs/issues/971
CMD 模块定义规范https://github.com/seajs/seajs/issues/242
社区https://github.com/seajs/seajs/issues/271
前端模块化开发那点历史https://github.com/seajs/seajs/issues/588
如何参与开发https://github.com/seajs/seajs/issues/276
Develop A Packagehttp://spmjs.io/documentation/develop-a-package
高富帅seajs使用示例及spm合并压缩工具露脸http://www.zhangxinxu.com/wordpress/2012/07/seajs-node-nodejs-spm-npm/
Hello Sea.jshttp://island205.github.io/HelloSea.js/index.html
从零开始编写自己的JavaScript框架（一）http://www.ituring.com.cn/article/48461
Javascript模块化编程（一）：模块的写法http://www.ruanyifeng.com/blog/2012/10/javascript_module.html
JavaSript模块规范 - AMD规范与CMD规范介绍http://blog.chinaunix.net/uid-26672038-id-4112229.html
该如何理解AMD ，CMD，CommonJS规范http://www.cnblogs.com/qianshui/p/5216580.html?utm_source=tuicool&amp;utm_medium=referralhttp://www.tuicool.com/articles/MVrMBrI
(function($){…})(jQuery)是什么意思http://blog.csdn.net/rambo_china/article/details/7742321
深入探寻seajs的模块化与加载方式http://www.jb51.net/article/64024.htm
seajs模块加载机制http://www.jianshu.com/p/1245af09383e
SeaJS中jQuery插件模块化及其调用方式http://my.oschina.net/briviowang/blog/208587
seajs模块化jQuery与jQuery插件http://julabs.com/blog/seajs-jquery-and-plugins/
Sea.js 手册与文档http://www.zhangxinxu.com/sp/seajs/docs/zh-cn/module-definition.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>node</tag>
        <tag>seajs</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp实现短信验证注册</title>
    <url>/dev-sms-verification-code/</url>
    <content><![CDATA[前言小太阳项目最先做的模块，用户管理模块。业主端该模块分为三个功能：注册登录、个人信息修改、认证。注册时需要用到短信验证码，本文记录一下思路和具体实现。短信验证平台使用云片，短信验证码的生成使用thinkphp。


思路1、用户输入手机号，请求获取短信验证码。2、thinkphp生成短信验证码，存储，同时和其他参数一起发送请求给云片。3、云片发送短信验证码到指定手机号。4、用户输入短信验证码。5、thinkphp根据验证码是否正确、验证码是否过期两个条件判断是否验证通过。
代码实现验证接口接口地址：https://sms.yunpian.com/v1/sms/send.json。使用postman，输入三个必须的参数apikey、mobile和text。
php发起http/https请求使用php的curl函数发起https请求，带入参数apikey、mobile和text。
// 获取短信验证码public function getSMSCode()&#123;    // create curl resource     $ch = curl_init();     // set url    $url = 'https://sms.yunpian.com/v1/sms/send.json';     curl_setopt($ch, CURLOPT_URL, $url);     // set param    $paramArr = array(        'apikey' =&gt; '******',        'mobile' =&gt; '******',        'text' =&gt; '【小太阳】您的验证码是1234'    );    $param = '';    foreach ($paramArr as $key =&gt; $value) &#123;        $param .= urlencode($key).'='.urlencode($value).'&amp;';    &#125;    $param = substr($param, 0, strlen($param)-1);    curl_setopt($ch, CURLOPT_POSTFIELDS, $param);    curl_setopt($ch, CURLOPT_HEADER, 0);    curl_setopt($ch, CURLOPT_POST, 1);    //curl默认不支持https协议，设置不验证协议    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);     curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);     //return the transfer as a string     curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);     // $output contains the output string     $output = curl_exec($ch);     // close curl resource to free up system resources     curl_close($ch);     echo $output;&#125;


生成随机短信验证码默认生成四位的随机短信验证码。
// 生成短信验证码public function createSMSCode($length = 4)&#123;    $min = pow(10 , ($length - 1));    $max = pow(10, $length) - 1;    return rand($min, $max);&#125;

整合在数据库新建表sun_smscode：
DROP TABLE IF EXISTS `sun_smscode`;CREATE TABLE `sun_smscode` (  `id` int(8) NOT NULL AUTO_INCREMENT,  `mobile` varchar(11) NOT NULL,  `code` int(4) NOT NULL,  `create_at` datetime NOT NULL,  `update_at` datetime NOT NULL,  PRIMARY KEY (`id`)) ENGINE=MyISAM AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

thinkphp代码：
// 获取短信验证码public function getSMSCode()&#123;    // create curl resource     $ch = curl_init();     // set url    $url = 'https://sms.yunpian.com/v1/sms/send.json';     curl_setopt($ch, CURLOPT_URL, $url);     // set param    $mobile = $_POST['mobile'];    $code = $this-&gt;createSMSCode();    $paramArr = array(        'apikey' =&gt; '******',        'mobile' =&gt; $mobile,        'text' =&gt; '【小太阳】您的验证码是'.$code    );    $param = '';    foreach ($paramArr as $key =&gt; $value) &#123;        $param .= urlencode($key).'='.urlencode($value).'&amp;';    &#125;    $param = substr($param, 0, strlen($param)-1);    curl_setopt($ch, CURLOPT_POSTFIELDS, $param);    curl_setopt($ch, CURLOPT_HEADER, 0);    curl_setopt($ch, CURLOPT_POST, 1);    curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); //不验证证书下同    curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false);     //return the transfer as a string     curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);     // $output contains the output string     $output = curl_exec($ch);     // close curl resource to free up system resources     curl_close($ch);     //$outputJson = json_decode($output);    $outputArr = json_decode($output, true);    //echo $outputJson-&gt;code;    //echo $outputArr['code'];    if($outputArr['code'] == '0')&#123;        $data['mobile'] = $mobile;        $data['code'] = $code;        $smscode = D('smscode');        $smscodeObj = $smscode-&gt;where("mobile='$mobile'")-&gt;find();        if($smscodeObj)&#123;            $data['update_at'] = date('Y-m-d H:i:s');            $success = $smscode-&gt;where("mobile='$mobile'")-&gt;save($data);            if($success !== false)&#123;                $result = array(                    'code' =&gt; '0',                    'ext' =&gt; '修改成功',                    'obj' =&gt; $smscodeObj                );            &#125;            echo json_encode($result,JSON_UNESCAPED_UNICODE);        &#125;else&#123;            $data['create_at'] = date('Y-m-d H:i:s');            $data['update_at'] = $data['create_at'];            if($smscode-&gt;create($data))&#123;                $id = $smscode-&gt;add();                if($id)&#123;                    $smscode_temp = $smscode-&gt;where("id='$id'")-&gt;find();                    $result = array(                        'code'=&gt; '0',                        'ext'=&gt; '创建成功',                        'obj'=&gt;$smscode_temp                    );                    echo json_encode($result,JSON_UNESCAPED_UNICODE);                &#125;            &#125;        &#125;            &#125;&#125;

验证短信验证码验证短信验证码时间是否过期，验证短信验证码是否正确。
// 验证短信验证码是否有效public function checkSMSCode()&#123;    $mobile = $_POST['mobile'];    $code = $_POST['code'];    $nowTimeStr = date('Y-m-d H:i:s');    $smscode = D('smscode');    $smscodeObj = $smscode-&gt;where("mobile='$mobile'")-&gt;find();    if($smscodeObj)&#123;        $smsCodeTimeStr = $smscodeObj['update_at'];        $recordCode = $smscodeObj['code'];        $flag = $this-&gt;checkTime($nowTimeStr, $smsCodeTimeStr);        if(!$flag)&#123;            $result = array(                'code' =&gt; '1',                'ext' =&gt; '验证码过期，请刷新后重新获取'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);            return;        &#125;        if($code != $recordCode)&#123;            $result = array(                'code' =&gt; '2',                'ext' =&gt; '验证码错误，请重新输入'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);            return;        &#125;        $result = array(            'code' =&gt; '0',            'ext' =&gt; '验证通过'        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;&#125;// 验证验证码时间是否过期public function checkTime($nowTimeStr,$smsCodeTimeStr)&#123;    //$nowTimeStr = '2016-10-15 14:39:59';    //$smsCodeTimeStr = '2016-10-15 14:30:00';    $nowTime = strtotime($nowTimeStr);    $smsCodeTime = strtotime($smsCodeTimeStr);    $period = floor(($nowTime-$smsCodeTime)/60); //60s    if($period&gt;=0 &amp;&amp; $period&lt;=20)&#123;        return true;    &#125;else&#123;        return false;    &#125;&#125;


改进为了防止短信轰炸，在请求获取短信验证码时，需要加入图片验证码。
thinkphp提供了生成图片验证码的函数，下面我们来实现验证码的生成、刷新和验证。
生成和刷新图片验证码// 获取图片验证码，刷新图片验证码public function getPicCode()&#123;    $config = array(        'fontSize'=&gt;30,    // 验证码字体大小        'length'=&gt;4,     // 验证码位数        'useNoise'=&gt;false, // 关闭验证码杂点        'expire'=&gt;600    );    $Verify = new \Think\Verify($config);    $Verify-&gt;entry(2333);//2333是验证码标志&#125;

假设，该函数的对应url为http://localhost/owner-bd/index.php/Home/CheckCode/getPicCode，那么，图片验证码的地址就是这个url，放入页面图片标签的src属性即可。
验证图片验证码// 验证验证码是否正确public function checkPicCode($code)&#123;    $verify = new \Think\Verify();    if($verify-&gt;check($code, 2333))&#123;        $result = array(            'code' =&gt; '0',            'ext' =&gt; '验证通过'        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;else&#123;        $result = array(            'code' =&gt; '1',            'ext' =&gt; '验证码错误，请重新输入'        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;;&#125;
以上方法，我们利用了thinkphp提供的check方法，实现起来很简单。但是，如果想要得到验证细节，就没有办法了。比如，验证码错误，可能验证码超时，可能因为输入验证码错误，可能因为验证码已经使用过等等。必要的时候，可以重写thinkphp的验证码类，或者重写thinkphp的check方法。
跑通前后端后端修改验证图片验证码函数，改为被调用函数：
public function checkPicCode($picCode)&#123;    $verify = new \Think\Verify();    if($verify-&gt;check($picCode, 2333))&#123;        return true;    &#125;else&#123;        return false;    &#125;;&#125;

在获取短信验证码函数的最顶部，添加调用图片验证码函数，只有通过验证，才发送请求给云片。
// 获取短信验证码public function getSMSCode()&#123;    $picCode = $_POST['picCode'];    if(!$this-&gt;checkPicCode($picCode))&#123;        $result = array(            'code' =&gt; '1',            'ext' =&gt; '验证码错误，请重新输入'        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);        return;    &#125;    /*省略*/&#125;

前端核心代码&lt;!--register.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh" ng-app="sunApp"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;注册&lt;/title&gt;&lt;/head&gt;&lt;body ng-controller="registerController"&gt;    &lt;form action="" class="register-form" ng-show="isShow1"&gt;        &lt;div class="input-group"&gt;            &lt;input type="text" class="mobile" ng-model="mobile" placeholder="手机号"&gt;        &lt;/div&gt;        &lt;div class="input-group"&gt;            &lt;input type="text" class="pic-code" ng-model="picCode" placeholder="图片验证码"&gt;            &lt;img class="img" src="&#123;&#123;picCodeUrl&#125;&#125;" alt="" ng-click="refresh()"&gt;        &lt;/div&gt;        &lt;div class="input-group"&gt;            &lt;input type="text" class="sms-code" ng-model="SMSCode" placeholder="短信验证码"&gt;            &lt;button class="btn-sms" ng-click="getSMSCode()" ng-disabled="btnSMSDisabled"&gt;&#123;&#123;btnSMSText&#125;&#125;&lt;/button&gt;        &lt;/div&gt;        &lt;button class="confirm-btn" ng-click="next()"&gt;下一步&lt;/button&gt;    &lt;/form&gt;    &lt;form action="" class="register-form" ng-show="isShow2"&gt;        &lt;div class="input-group"&gt;            &lt;input type="text" class="mobile" ng-model="mobile" placeholder="手机号" disabled="true"&gt;        &lt;/div&gt;        &lt;div class="input-group"&gt;            &lt;input type="password" class="password" ng-model="password" placeholder="请输入密码"&gt;            &lt;input type="password" class="password" ng-model="password2" placeholder="请再次输入密码"&gt;        &lt;/div&gt;        &lt;button class="confirm-btn" ng-click="getSMSCode()"&gt;注册&lt;/button&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;


// register.jsangular.module('sunApp').controller('registerController', function ($scope,$http,$httpParamSerializer,$state,$interval) &#123;     $scope.picCodeUrl = '/owner-bd/index.php/Home/CheckCode/getPicCode';    $scope.isShow1 = true;    $scope.isShow2 = false;    $scope.btnSMSText = '获取验证码';    $scope.btnSMSDisabled = false;    $scope.checkOver = false;    // 获取短信验证码    $scope.getSMSCode = function()&#123;        var param = &#123;            mobile: $scope.mobile,            picCode: $scope.picCode        &#125;;        $http(&#123;            method:'POST',            url:'/owner-bd/index.php/Home/SMS/getSMSCode',            //url: '/owner-fd/mock/common.json',            headers:&#123;                'Content-Type':'application/x-www-form-urlencoded'            &#125;,            dataType: 'json',            data: $httpParamSerializer(param)        &#125;).then(function successCallback(response) &#123;            console.log(response.data);            if(response.data.code == '0')&#123;                $scope.checkOver = true;                $scope.btnSMSDisabled = true;                var time = 60;                var timer = null;                timer = $interval(function()&#123;                    time = time - 1;                    $scope.btnSMSText = time+'秒';                    if(time == 0) &#123;                        $interval.cancel(timer);                        $scope.btnSMSDisabled = false;                        $scope.btnSMSText = '重新获取';                    &#125;                &#125;, 1000);            &#125;        &#125;, function errorCallback(response) &#123;            console.log(response.data);        &#125;);    &#125;    // 验证短信验证码    $scope.next = function()&#123;        if(!$scope.checkOver)&#123;            console.log('未通过验证');            return;        &#125;        var param = &#123;            mobile: $scope.mobile,            code: $scope.SMSCode        &#125;;        $http(&#123;            method:'POST',            url:'/owner-bd/index.php/Home/SMS/checkSMSCode',            //url: '/owner-fd/mock/common.json',            headers:&#123;                'Content-Type':'application/x-www-form-urlencoded'            &#125;,            dataType: 'json',            data: $httpParamSerializer(param)        &#125;).then(function successCallback(response) &#123;            console.log(response.data);            if(response.data.code == '0')&#123;                $scope.isShow1 = false;                $scope.isShow2 = true;            &#125;        &#125;, function errorCallback(response) &#123;            console.log(response.data);        &#125;);    &#125;    // 刷新图片验证码    $scope.refresh = function()&#123;        $scope.picCodeUrl = '/owner-bd/index.php/Home/CheckCode/getPicCode?'+Math.random();    &#125;&#125;);

优化以上代码，安全性不是很好，我们可以利用工具绕过前端验证。为了避免这个问题，可以在checkPicCode和checkSMSCode函数中添加session值来标记。
$_SESSION['checkPicCode'] = true;$_SESSION['checkSMSCode'] = true;
在最后一步，向数据库中添加用户时，先验证一下两个session值是否都为true，都为true时再添加。
成果
后记以后也许有用的代码：
echo json_encode($_SESSION);// 打印出session中的数据echo session_id();// 打印当前session的id

书签云片网https://www.yunpian.com/
cURL函数http://php.net/manual/zh/ref.curl.php
curl 基础例子http://php.net/manual/zh/curl.examples.php
在PHP语言中使用JSONhttp://www.ruanyifeng.com/blog/2011/01/json_in_php.html
thinkphp验证码http://document.thinkphp.cn/manual_3_2.html#verify
修改ThinkPHP的验证码类http://www.cnblogs.com/BTMaster/p/3547878.html
ThinkPHP 3.2版本 , 无法读取$_SESSION[‘verify_code’]http://www.cnblogs.com/lovezbs/p/4496117.html
LICEcap - Downloadhttp://licecap.en.softonic.com/
gif动态图局部加马赛克模糊广告文字http://www.leawo.cn/space-138176-do-thread-id-64000.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>angularjs</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>angularjs</tag>
        <tag>php</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring JPA</title>
    <url>/dev-spring-jpa/</url>
    <content><![CDATA[JPA例子（h2database版）这个例子高仿照搬Spring官网给出的例子，只是包不同而已。
新建工程Eclipse，File，New，Maven Project，Create a simple project打上勾，Next。
Group Id输入反向域名加上工程名，Artifact Id输入子工程名，Packaging处选择jar（意思是普通工程；如果是web工程，选择war；如果用来定义父工程，选择pom）。


pom.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0"	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;	&lt;groupId&gt;com.voidking.book&lt;/groupId&gt;	&lt;artifactId&gt;book-jpa&lt;/artifactId&gt;	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;	&lt;parent&gt;		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;		&lt;version&gt;1.2.5.RELEASE&lt;/version&gt;	&lt;/parent&gt;	&lt;properties&gt;		&lt;java.version&gt;1.8&lt;/java.version&gt;	&lt;/properties&gt;	&lt;dependencies&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;			&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;com.h2database&lt;/groupId&gt;			&lt;artifactId&gt;h2&lt;/artifactId&gt;		&lt;/dependency&gt;	&lt;/dependencies&gt;	&lt;build&gt;		&lt;plugins&gt;			&lt;plugin&gt;				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;			&lt;/plugin&gt;		&lt;/plugins&gt;	&lt;/build&gt;	&lt;repositories&gt;		&lt;repository&gt;			&lt;id&gt;spring-releases&lt;/id&gt;			&lt;name&gt;Spring Releases&lt;/name&gt;			&lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;		&lt;/repository&gt;		&lt;repository&gt;			&lt;id&gt;org.jboss.repository.releases&lt;/id&gt;			&lt;name&gt;JBoss Maven Release Repository&lt;/name&gt;			&lt;url&gt;https://repository.jboss.org/nexus/content/repositories/releases&lt;/url&gt;		&lt;/repository&gt;	&lt;/repositories&gt;	&lt;pluginRepositories&gt;		&lt;pluginRepository&gt;			&lt;id&gt;spring-releases&lt;/id&gt;			&lt;name&gt;Spring Releases&lt;/name&gt;			&lt;url&gt;https://repo.spring.io/libs-release&lt;/url&gt;		&lt;/pluginRepository&gt;	&lt;/pluginRepositories&gt;&lt;/project&gt;

Customer.javasrc/main/java/com/voidking/book/entity/Customer.java
package com.voidking.book.entity;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.GenerationType;import javax.persistence.Id;@Entitypublic class Customer &#123;    @Id    @GeneratedValue(strategy=GenerationType.AUTO)    private long id;    private String firstName;    private String lastName;    protected Customer() &#123;&#125;    public Customer(String firstName, String lastName) &#123;        this.firstName = firstName;        this.lastName = lastName;    &#125;    @Override    public String toString() &#123;        return String.format(                "Customer[id=%d, firstName='%s', lastName='%s']",                id, firstName, lastName);    &#125;&#125;

CustomerRepository.javasrc/main/java/com/voidking/book/repository/Customer.java
package com.voidking.book.repository;import java.util.List;import org.springframework.data.repository.CrudRepository;import com.voidking.book.entity.Customer;public interface CustomerRepository extends CrudRepository&lt;Customer, Long&gt; &#123;    List&lt;Customer&gt; findByLastName(String lastName);&#125;
Repository（资源库）：通过用来访问领域对象的一个类似集合的接口，在领域与数据映射层之间进行协调。这个叫法就类似于我们通常所说的DAO，在这里，我们就按照这一习惯把数据访问层叫Repository Spring Data，基础的Repository提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下：Repository：仅仅是一个标识，表明任何继承它的均为仓库接口类，方便Spring自动扫描识别CrudRepository： 继承Repository，实现了一组CRUD相关的方法PagingAndSortingRepository： 继承CrudRepository，实现了一组分页排序相关的方法JpaRepository： 继承PagingAndSortingRepository，实现一组JPA规范相关的方法JpaSpecificationExecutor： 比较特殊，不属于Repository体系，实现一组JPA Criteria查询相关的方法我们自己定义的XxxxRepository需要继承JpaRepository，这样我们的XxxxRepository接口就具备了通用的数据访问控制层的能力。 
Application.javasrc/main/java/com/voidking/book/app/Application.java
package com.voidking.book.app;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import com.voidking.book.entity.Customer;import com.voidking.book.repository.CustomerRepository;@SpringBootApplicationpublic class Application implements CommandLineRunner &#123;    @Autowired    CustomerRepository repository;    public static void main(String[] args) &#123;        SpringApplication.run(Application.class);    &#125;        @Override    public void run(String... strings) throws Exception &#123;        // save a couple of customers        repository.save(new Customer("Jack", "Bauer"));        repository.save(new Customer("Chloe", "O'Brian"));        repository.save(new Customer("Kim", "Bauer"));        repository.save(new Customer("David", "Palmer"));        repository.save(new Customer("Michelle", "Dessler"));        // fetch all customers        System.out.println("Customers found with findAll():");        System.out.println("-------------------------------");        for (Customer customer : repository.findAll()) &#123;            System.out.println(customer);        &#125;        System.out.println();        // fetch an individual customer by ID        Customer customer = repository.findOne(1L);        System.out.println("Customer found with findOne(1L):");        System.out.println("--------------------------------");        System.out.println(customer);        System.out.println();        // fetch customers by last name        System.out.println("Customer found with findByLastName('Bauer'):");        System.out.println("--------------------------------------------");        for (Customer bauer : repository.findByLastName("Bauer")) &#123;            System.out.println(bauer);        &#125;    &#125;&#125;


mvn test异常执行命令mvn test，抛出异常：
Exception in thread "main" java.lang.UnsupportedClassVersionError:com/voidking/book/app/Application : Unsupported major.minor version 52.0
这个异常，是因为本机没有安装jdk8，我就把Properties-&gt;java build path-&gt;Libraries中的JVM8换成JVM7。
解决方法：右击项目，Properties，Java Compiler，Compiler compliance level从1.8改成1.7，之后就可以运行了。
运行异常mvn spring-boot:run，异常：
org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'application': Injection of autowired dependencies failed; nested exception is org.springframework.beans.factory.BeanCreationException: Could not autowire field: com.voidking.book.repository.CustomerRepository com.voidking.book.app.Application.repository; nested exception is org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.voidking.book.repository.CustomerRepository] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Autowired(required=true)&#125;
可以看到，异常层层连锁，看起来那么长，实际上重点在后面。原来是缺少CustomerRepository类型的bean，那么，为什么缺少呢？是否是因为需要一个类似spring.xml的配置文件？
Spring官方代码看看Spring官方给出的例子，确实没有配置文件。mvn spring-boot:run，结果如下：运行成功，可见，这个例子是没有任何问题的。那么，问题出在哪里？因为分了不同的包？
试一试，把所有.java移动到一个包中，运行。。。成功！
醉了从中午12点忙到晚上12点，此问题没有解决，我也是醉了。。。
spring-boot第二天，继续查找资料，终于明白了，这一切都是spring-boot搞的鬼。
spring-boot会自动配置通过jpa进行数据访问需要的bean。
spring-boot会根据classpath包含的内容自动推测用户的需求并自动配置。例如如果在classpath包含了hsqldb，并且用户未配置数据库连接，spring-boot将会配置一个hsqldb内存数据库和数据源。
spring-boot无代码生成，所有的配置可通过代码完成（spring 的javaconfig），不需要使用xml（虽然可以使用）。 
JPA例子（hsql版）h2database和hsql非常类似，适合作为嵌入式数据库使用，其它的数据库大部分都需要安装独立的客户端和服务器端。顺便比较一下各个数据库，如下图：
name属性用于定义持久化单元的名字(name必选,空值也合法);transaction-type指定事务类型(可选)  
JPA例子（Mysql版）源代码分享Spring官方例子git clone https://github.com/spring-guides/gs-accessing-data-jpa.git
后记使用Spring，和单纯的JPA有什么区别？

多了一些标记为Bean的注解，比如@Repository、@Service、@Controller和@Component。

JAP有持久化配置文件persistence.xml（src/META-INF），默认加载。在这个文件中，可以配置数据库连接信息，实体类等；使用了Spring，除了persistence.xml，还多出了一个或多个Spring的配置文件，配置文件间可以通过&lt;import&gt;标签引用；persistence.xml中的内容，可以改写到spring的配置文件中，如果内容全部改写，此时persistence.xml文件可以省略。


参考文档Accessing Data with JPAhttp://spring.io/guides/gs/accessing-data-jpa/
Spring Data JPA - Reference Documentationhttp://docs.spring.io/spring-data/data-jpa/docs/current/reference/html/
使用 Spring Data JPA 简化 JPA 开发http://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/
简单的Spring JPA实现例子http://blog.csdn.net/kongxx/article/details/5653370
spring mvc 的jpa JpaRepository数据层 访问方式汇总http://jishiweili.iteye.com/blog/2088265
使用spring-boot快速开发spring应用http://itindex.net/detail/49108-spring-boot-%E5%BC%80%E5%8F%91
JPA 不在 persistence.xml 文件中配置每个Entity实体类的2种解决办法http://www.cnblogs.com/taven/archive/3351841.html
Jpa规范中persistence.xml 配置文件解析http://www.cnblogs.com/edwardlauxh/archive/2632292.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>spring</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>SSL和TLS</title>
    <url>/dev-ssl-tls/</url>
    <content><![CDATA[SSL和TLS简介《Hexo启用https加密连接》和《CentOS7安装配置GitLab》中都涉及到了SSL/TLS，SSL和TLS是啥？

传输层安全性协议（英语：Transport Layer Security，缩写：TLS）及其前身安全套接层（英语：Secure Sockets Layer，缩写：SSL）是一种安全协议，目的是为互联网通信提供安全及数据完整性保障。SSL包含记录层（Record Layer）和传输层，记录层协议确定传输层数据的封装格式。传输层安全协议使用X.509认证，之后利用非对称加密演算来对通信方做身份认证，之后交换对称密钥作为会谈密钥（Session key）。这个会谈密钥是用来将通信两方交换的数据做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。

更多内容参考维基百科-传输层安全性协议


相关概念PKI
公开密钥基础建设（英语：Public Key Infrastructure，缩写：PKI），又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。密码学上，公开密钥基础建设借着数字证书认证机构（CA）将用户的个人身份跟公开密钥链接在一起。对每个证书中心用户的身份必须是唯一的。链接关系通过注册和发布过程创建，取决于担保级别，链接关系可能由CA的各种软件或在人为监督下完成。PKI的确定链接关系的这一角色称为注册管理中心（Registration Authority，RA）。RA确保公开密钥和个人身份链接，可以防欺诈。在微软的公开密钥基础建设之下，注册管理中心（RA）又被叫做从属数字证书认证机构（Subordinate CA）。

更多内容参考维基百科-公开密钥基础架构
CA
数字证书认证机构（英语：Certificate Authority，缩写为CA），也称为电子商务认证中心、电子商务认证授权机构，是负责发放和管理数字证书的权威机构，并作为电子商务交易中受信任的第三方，承担公钥体系中公钥的合法性检验的责任。

更多内容参考维基百科-证书颁发机构
数字证书
公钥证书（英语：Public key certificate），又称数字证书（digital certificate）或身份证书（identity certificate）。是用于公开密钥基础建设的电子文件，用来证明公开密钥拥有者的身份。此文件包含了公钥信息、拥有者身份信息（主体）、以及数字证书认证机构（发行者）对这份文件的数字签名，以保证这个文件的整体内容正确无误。拥有者凭着此文件，可向电脑系统或其他用户表明身份，从而对方获得信任并授权访问或使用某些敏感的电脑服务。电脑系统或其他用户可以透过一定的程序核实证书上的内容，包括证书有否过期、数字签名是否有效，如果你信任签发的机构，就可以信任证书上的密钥，凭公钥加密与拥有者进行可靠的通信。


公钥证书包括自签证书、根证书、中介证书、授权证书、终端实体证书（TLS服务器证书和TLS客户端证书）。

更多内容参考维基百科-公钥证书
加密原理TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 Hash、对称加密和非对称加密。其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。
TLS 的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥，然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。例如，在 HTTPS 协议中，客户端发出请求，服务端会将公钥发给客户端，客户端验证过后生成一个密钥再用公钥加密后发送给服务端（非对称加密），双方会在 TLS 握手过程中生成一个协商密钥（对称密钥），成功后建立加密连接。通信过程中客户端将请求数据用协商密钥加密后发送，服务端也用协商密钥解密，响应也用相同的协商密钥。后续的通信使用对称加密是因为对称加解密快，而握手过程中非对称加密可以保证加密的有效性，但是过程复杂，计算量相对来说也大。
更多内容参考SSL/TLS 详解
自建CA并签发证书《CentOS7安装配置GitLab》一文中，添加SSL一节详细描述了自建CA并签发SSL证书的过程。更多内容，可以参考基于OpenSSL自建CA和颁发SSL证书和使用 OpenSSL 自建 CA 并签发证书。
k8s中证书管理查看证书1、查看证书位置
ps aux | grep kubelet# find config filecat /var/lib/kubelet/config.yaml | grep staticPodPathcd /etc/kubernetes/manifestscat kube-apiserver.yaml

2、查看证书详情
openssl x509 -in /etc/kubernetes/pki/apiserver.crt -text

签名签名，或者签名过期后重新签名
openssl x509 -req -in /etc/kubernetes/pki/apiserver-etcd-client.csr -CA /etc/kubernetes/pki/etcd/ca.crt -CAkey /etc/kubernetes/pki/etcd/ca.key -CAcreateserial -out /etc/kubernetes/pki/apiserver-etcd-client.crt

通过API签名1、为新用户创建证书
openssl genrsa -out jane.key 2048openssl req -new -key jane.key -subj  "/CN=jane" -out jane.csrcat jane.csr | base64 | tr -d '\n'

2、创建jane-csr.yaml文件
apiVersion: certificates.k8s.io/v1beta1kind: CertificateSigningRequestmetadata:  name: janespec:  groups:  - system:authenticated  usages:  - digital signature  - key encipherment  - server auth  - client auth  request: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURSBSRVFVRVNULS0tLS0KTUlJQ1ZEQ0NBVHdDQVFBd0R6RU5NQXNHQTFVRUF3d0VhbUZ1WlRDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRApnZ0VQQURDQ0FRb0NnZ0VCQUtxbWFIa3BJeE94dDN2UmxJT1FnSUFxSUFsekhQcTRRVTBDTDVhS04xbmY4NXRzCi9LU3o0eml1a1hEQ1NOSVNIT1pWbTY5NzVJa3RXcGFySmhaTXptc1B2eUFSeXFWbWY2L1h0bmwyeE0xblhaUzAKZGc0b0E1dXFuR0w2dHpaQzF3VFY4RVFIZnRlcWYzbUpTN2JtdlppaXFlak12a2UzVkk5RTNFK0xsUUttNnVXRwprS2RDZ2ZHNUszRGJFczR1VzR6M0lMdTdEa1BlamJodWFtYzlxYVZNRVpLSGZ0bnlBYlFITkZVLzhvWVYvR1VzCnRFVWZMRXBBTmlqUFc5U0pPWHJtNUg1NXhOdExXVHMwenU3YlRSZWE0ZjFVaDFCbkZuUkhWYUJqNysydHpITTgKaklJS01KakdWOS9rUVltRmo3UTJZUW1wYzdXWGpPZEFWcHBSc1kwQ0F3RUFBYUFBTUEwR0NTcUdTSWIzRFFFQgpDd1VBQTRJQkFRQUZ2ZUxrUmYxd0xDQmN6cWdMVkJIUGZBa0MzeU1CTDA3VXl0QUlCcVhkR3h1QWtyL3NQT1dkClNxTkhIRkNzQVNmU0lNVC96djBrQS9yN3Fnd25BMCtZREZJSjNzUlBKZkJmNm1Ic3FrbjlPd1htR1E3d0orNFQKWXVCc1lJSllnNWtzVWJoQVhiQkVZekk2OUY0Uk52U0d0K1ZLOHBBdUQzcXRvejJsd3liV0cvaUo4V3FESTZNegpuMURBeDBkRDZmRWhIKy9DTWdSREY5OExCL1ZqMWZOUUlqZ2k3Rmc1aTByU1NtZUdUMllOblJldERZYWN4aWlzCjNFN1B4STdYWDd2QjRjY3pITlUrTG92N3JnSkVXM3lRMXZRTXRCNTZlbWJaNGVnL01XZEhkeWliVXo2aDQ1ZW8KUGN5b3QxaW1wdFRyK3kwSkt0SmJ1YllQOGd2RG5FeFYKLS0tLS1FTkQgQ0VSVElGSUNBVEUgUkVRVUVTVC0tLS0tCg==

3、签名请求并通过
kubectl apply -f jane-csr.yamlkubectl get csr kubectl certificate approve janekubectl get csr jane -o yamlkubectl get csr jane -o jsonpath='&#123;.status.certificate&#125;' | base64 --decode &gt; jane.crt

或者，直接使用openssl命令进行签名：
openssl x509 -req -in /root/jane.csr -CA /etc/kubernetes/pki/etcd/ca.crt -CAkey /etc/kubernetes/pki/etcd/ca.key -CAcreateserial -out /root/jane.crt

PS：查看签名用的CA
cat /etc/kubernetes/manifests/kube-controller-manager.yaml | grep ca.crtcat /etc/kubernetes/manifests/kube-controller-manager.yaml | grep ca.key

更多内容，参考Manage TLS Certificates in a Cluster。
证书格式转换X.509是一种证书标准，定义了证书中应该包含哪些内容，详情参考RFC5280，SSL使用的就是这种证书标准。同样的X.509证书，可能有不同的编码格式，目前有以下两种编码格式。PEM：Privacy Enhanced Mail，BASE64编码，以”—–BEGIN—–”开头，”—–END—–”结尾。查看PEM格式证书的信息：openssl x509 -in cert.pem -text -noout
DER：Distinguished Encoding Rules，二进制格式，不可读。查看DER格式证书的信息：openssl x509 -in cert.der -inform der -text -noout
问题来了，k8s中的证书，除了使用pem格式，还有就是crt格式，并没有der格式啊？这是因为，crt只是一个文件后缀，编码格式可能是pem也可能是der。
那么，pem和der怎样互相转换呢？
# pem to deropenssl x509 -in cert.crt -outform der -out cert.der# der to pemopenssl x509 -in cert.crt -inform der -outform pem -out cert.pem

书签OpenSSL 与 SSL 数字证书概念贴SSL/TLS 原理详解
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>docker</tag>
        <tag>tls</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts2文件上传</title>
    <url>/dev-struts2-upload/</url>
    <content><![CDATA[Struts2文件上传上传单个文件Struts2中，提供了一个很容易操作的文件上传组件。用Struts2上传单个文件的功能非常容易实现，只要使用普通的Action即可。但为了获得一些文件上传的信息，如上传文件名等，需要按照一定规则来为Action类增加一些getter和setter方法。Struts2的文件上传默认使用的是Jakarta的Common-FileUpload文件上传框架。因此需要在Web应用中增加两个Jar包，即common-io-*.jar和common-fileupload-*.jar。
我们接着在struts2概述中的struts2项目中开发文件上传实例。
指定文件夹在D盘下新建upload文件夹，上传的文件放到这个目录下。

upload.jsp在WebContent中新建upload.jsp，代码如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/struts-tags" prefix="s"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;s:form action="upload.action" method="post" enctype="multipart/form-data"&gt;		&lt;s:file name="upload" label="上传的文件"&gt;&lt;/s:file&gt;		&lt;s:submit value="上传"&gt;&lt;/s:submit&gt;	&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt;
UploadActionpackage com.voidking.struts2.action;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import com.opensymphony.xwork2.ActionSupport;public class UploadAction extends ActionSupport&#123;	private File upload;	private String uploadFileName;		public String getUploadFileName() &#123;		return uploadFileName;	&#125;	public void setUploadFileName(String uploadFileName) &#123;		this.uploadFileName = uploadFileName;	&#125;	public File getUpload()	&#123;		return upload;	&#125;		public void setUpload(File upload)	&#123;		this.upload=upload;	&#125;		public String execute() throws Exception&#123;		InputStream is=new FileInputStream(getUpload());		OutputStream os = new FileOutputStream("d:\\upload\\"+uploadFileName);		byte buffer[] = new byte[1024];		int count= 0;		while((count=is.read(buffer))&gt;0)		&#123;			os.write(buffer,0,count);		&#125;		os.close();		is.close();		return SUCCESS;	&#125;	&#125;
上传的文件经过Action处理后，会被写到指定的路径下。其实也可以把上传的文件写入数据库中，之后的例子会介绍如何把照片写入到数据库。需要注意的是，Struts2上传文件的默认大小限制为2MB，如果需要修改默认大小，只需要在Struts2的struts.properties文件中修改struts.multipart.maxSize。如struts.mulitipart.maxSize=1024表示上传文件的总大小不能超过1KB。
struts.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;    &lt;package name="default" namespace="/" extends="struts-default"&gt;        	&lt;interceptors&gt;    		&lt;interceptor name="myInterceptor" class="com.voidking.struts2.tool.MyInterceptor"&gt;&lt;/interceptor&gt;    	&lt;/interceptors&gt;    	&lt;default-interceptor-ref name=""&gt;&lt;/default-interceptor-ref&gt;    	        &lt;default-action-ref name="index" /&gt;        &lt;action name="struts" class="com.voidking.struts2.action.StrutsAction"&gt;            &lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;            &lt;result name="error"&gt;/hello.jsp&lt;/result&gt;            &lt;result name="input"&gt;/hello.jsp&lt;/result&gt;                        &lt;!-- 拦截配置在result后面 --&gt;            &lt;!-- 使用系统默认拦截器栈 --&gt;            &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;            &lt;!-- 配置拦截器 --&gt;            &lt;interceptor-ref name="myInterceptor"&gt;&lt;/interceptor-ref&gt;                    &lt;/action&gt;                &lt;action name="upload" class="com.voidking.struts2.action.UploadAction"&gt;        	&lt;result name="success"&gt;/uploadsuccess.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;

uploadsuccess.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;上传成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	恭喜你，上传成功！&lt;/body&gt;&lt;/html&gt;

404错误部署项目，启动Tomcat，访问：http://localhost:8080/struts2/upload.jsp ，提示 HTTP Status 404 - /struts2/upload.jsp。访问主页：http://localhost:8080/struts2/ ，同样提示404错误！
啊勒，这是肿么回事？想来想去，引起错误的原因，可能是昨天关闭eclipse的时候，没有先关闭Tomcat服务器，引起了一些配置错误。
查看tomcat/conf文件夹下的配置文件，server.xml和tomcat-users.xml，感觉没啥问题。
访问：http://localhost:8080 ，使用manager-gui账户登录tomcat，Manager App，可以看到，struts2项目的Running属性的值为false。奥~这就是问题所在了！点击start按钮，啊勒，无效！
删除webapps下的struts2工程，重新发布，运行tomcat，还是404错误！
再次点击start按钮，同时观察Console下面的信息：
SEVERE: Exception starting filter struts2Unable to load configuration. - package - file:/D:/Server/tomcat/webapps/struts2/WEB-INF/classes/struts.xml:7:67......SEVERE: Error filterStart

经过查找资料，确定了是struts.xml的配置问题。首先修改struts.xm如下：
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;    &lt;package name="default" namespace="/" extends="struts-default"&gt;        	&lt;interceptors&gt;    		&lt;interceptor name="myInterceptor" class="com.voidking.struts2.tool.MyInterceptor"&gt;&lt;/interceptor&gt;    	&lt;/interceptors&gt;    	&lt;default-interceptor-ref name=""&gt;&lt;/default-interceptor-ref&gt;    	        &lt;default-action-ref name="index" /&gt;        &lt;action name="struts" class="com.voidking.struts2.action.StrutsAction"&gt;            &lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;            &lt;result name="error"&gt;/hello.jsp&lt;/result&gt;            &lt;result name="input"&gt;/hello.jsp&lt;/result&gt;                        &lt;!-- 拦截配置在result后面 --&gt;            &lt;!-- 使用系统默认拦截器栈 --&gt;            &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;            &lt;!-- 配置拦截器 --&gt;            &lt;interceptor-ref name="myInterceptor"&gt;&lt;/interceptor-ref&gt;                    &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;
启动Tomcat，项目果然可以访问了！那么，为什么在package中多加了一个action就会出错呢？很多教程中，明明可以多个action写在一个package里啊！再看这个package，有何特殊之处？配置了拦截器！那么，接下来的action是否必须配置拦截器？修改试试。
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;    &lt;package name="default" namespace="/" extends="struts-default"&gt;        	&lt;interceptors&gt;    		&lt;interceptor name="myInterceptor" class="com.voidking.struts2.tool.MyInterceptor"&gt;&lt;/interceptor&gt;    	&lt;/interceptors&gt;    	&lt;default-interceptor-ref name=""&gt;&lt;/default-interceptor-ref&gt;    	        &lt;default-action-ref name="index" /&gt;        &lt;action name="struts" class="com.voidking.struts2.action.StrutsAction"&gt;            &lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;            &lt;result name="error"&gt;/hello.jsp&lt;/result&gt;            &lt;result name="input"&gt;/hello.jsp&lt;/result&gt;                        &lt;!-- 拦截配置在result后面 --&gt;            &lt;!-- 使用系统默认拦截器栈 --&gt;            &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;            &lt;!-- 配置拦截器 --&gt;            &lt;interceptor-ref name="myInterceptor"&gt;&lt;/interceptor-ref&gt;                    &lt;/action&gt;                &lt;action name="upload" class="com.voidking.struts2.action.UploadAction"&gt;        	&lt;result name="success"&gt;/uploadsuccess.jsp&lt;/result&gt;        	&lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;
启动Tomcat，项目可以正常访问。综上，可以得出一个结论：package包中如果定义了拦截器，那么，接下来的action中必须配置拦截器，否则会引起项目无法启动！
警告我们的项目已经可以正常运行，上传功能也正常。但是，当我们访问：http://localhost:8080/struts2/upload.jsp ，会报出如下警告：
'upload.action' in namespace: ''. Form action defaulting to 'action' attribute's literal value.
经过查找资料，原来这是因为没有正确使用tag，upload.jsp修改如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/struts-tags" prefix="s"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;s:form action="upload" namespace="/" method="post" enctype="multipart/form-data"&gt;		&lt;s:file name="upload" label="上传的文件"&gt;&lt;/s:file&gt;		&lt;s:submit value="上传"&gt;&lt;/s:submit&gt;	&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt;
再次访问，已经没有警告了。但是还是有提示信息：
At least one JAR was scanned for TLDs yet contained no TLDs. Enable debug logging for this logger for a complete list of JARs that were scanned but no TLDs were found in them. Skipping unneeded JARs during scanning can improve startup time and JSP compilation time.
对于有洁癖的同学可以参考下面的参考文档去除这个信息，郝同学这里不再赘述。
多文件上传多文件上传和单文件上传类似，只需要改动几个地方即可。
upload.jsp&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/struts-tags" prefix="s"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;文件上传&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;s:form action="upload" namespace="/" method="post" enctype="multipart/form-data"&gt;		&lt;s:file name="upload" label="上传的文件"&gt;&lt;/s:file&gt;		&lt;s:submit value="上传"&gt;&lt;/s:submit&gt;	&lt;/s:form&gt;	&lt;hr/&gt;	&lt;s:form action="upload2" namespace="/" method="post" enctype="multipart/form-data"&gt;		&lt;s:file name="upload2" label="上传的文件"&gt;&lt;/s:file&gt;		&lt;s:file name="upload2" label="上传的文件"&gt;&lt;/s:file&gt;		&lt;s:file name="upload2" label="上传的文件"&gt;&lt;/s:file&gt;		&lt;s:submit value="批量上传"&gt;&lt;/s:submit&gt;	&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt;

Upload2Actionpackage com.voidking.struts2.action;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.InputStream;import java.io.OutputStream;import java.util.List;import com.opensymphony.xwork2.ActionSupport;public class Upload2Action extends ActionSupport&#123;	private List&lt;File&gt; upload2;	private List&lt;String&gt; upload2FileName;				public List&lt;File&gt; getUpload2() &#123;		return upload2;	&#125;	public void setUpload2(List&lt;File&gt; upload2) &#123;		this.upload2 = upload2;	&#125;	public List&lt;String&gt; getUpload2FileName() &#123;		return upload2FileName;	&#125;	public void setUpload2FileName(List&lt;String&gt; upload2FileName) &#123;		this.upload2FileName = upload2FileName;	&#125;	public String execute() throws Exception&#123;				if(upload2!=null || upload2FileName!=null)		&#123;			for(int i=0;i&lt;upload2.size();i++)			&#123;				InputStream is = new FileInputStream(upload2.get(i));				OutputStream os=new FileOutputStream("d:\\upload\\"+getUpload2FileName().get(i));				byte buffer[] = new byte[1024];				int count=0;				while((count=is.read(buffer))&gt;0)				&#123;					os.write(buffer,0,count);				&#125;				os.close();				is.close();								return SUCCESS;			&#125;		&#125;				return ERROR;	&#125;	&#125;
这里需要注意的是属性命名问题，如果private List&lt;File&gt; upload2;，那么必须private List&lt;String&gt; upload2FileName;，否则无法获取到文件名。
struts.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;	&lt;constant name="struts.multipart.saveDir" value="/tmp"/&gt;    &lt;package name="default"  extends="struts-default"&gt;        	&lt;interceptors&gt;    		&lt;interceptor name="myInterceptor" class="com.voidking.struts2.tool.MyInterceptor"&gt;&lt;/interceptor&gt;    	&lt;/interceptors&gt;    	&lt;default-interceptor-ref name=""&gt;&lt;/default-interceptor-ref&gt;    	        &lt;default-action-ref name="index" /&gt;        &lt;action name="struts" class="com.voidking.struts2.action.StrutsAction"&gt;            &lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;            &lt;result name="error"&gt;/hello.jsp&lt;/result&gt;            &lt;result name="input"&gt;/hello.jsp&lt;/result&gt;                        &lt;!-- 拦截配置在result后面 --&gt;            &lt;!-- 使用系统默认拦截器栈 --&gt;            &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;            &lt;!-- 配置拦截器 --&gt;            &lt;interceptor-ref name="myInterceptor"&gt;&lt;/interceptor-ref&gt;                    &lt;/action&gt;                &lt;action name="upload" class="com.voidking.struts2.action.UploadAction"&gt;        	&lt;result name="success"&gt;/uploadsuccess.jsp&lt;/result&gt;        	&lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;        &lt;/action&gt;                &lt;action name="upload2" class="com.voidking.struts2.action.Upload2Action"&gt;        	&lt;result name="success"&gt;/uploadsuccess.jsp&lt;/result&gt;        	&lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;
其中，&lt;constant name=&quot;struts.multipart.saveDir&quot; value=&quot;/tmp&quot;/&gt;最好保留，不然会有提示信息:INFO: Unable to find &#39;struts.multipart.saveDir&#39; property setting.。另一个解决办法是在struts.properties加入：struts.multipart.saveDir = /tmp。
参考文档《Java EE基础实用教程》，郑阿奇主编

Form action defaulting to ‘action’ attribute’s literal value：http://www.blogjava.net/parable-myth/archive/336387.html

解决Tomcat7“At least one JAR was scanned for TLDs yet contained no TLDs”问题：http://mov-webhobo.iteye.com/blog/1939655http://love-love-l.blog.163.com/blog/static/2107830420131159580327/

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>Sublime Text3</title>
    <url>/dev-sublime/</url>
    <content><![CDATA[Sublime简介
Sublime Text is a sophisticated text editor for code, markup and prose.You’ll love the slick user interface, extraordinary features and amazing performance.

sublime是前端神器，支持markdown语法高亮，非常适合作为日常编辑器使用。
Sublime的安装很简单，访问Sublime官网，下载对应系统的安装包，双击安装即可。


常用设置变更字体Sublime默认字体是Consolas，Consolas英文显示很好，但是中文显示不太好看。有一款字体是Consolas和微软雅黑的混合字体，叫做YaHei Consolas Hybrid，小伙伴可以试试看。1、下载安装YaHei Consolas Hybrid2、Sublime菜单栏里点击Preferences，Setting。3、在弹出来的Preferences.sublime-settings——User文本里，添加如下一行:
"font_face": "YaHei Consolas Hybrid",

TAB转空格在用Sublime里编写Python代码时，需要把TAB键（制表键）转换成四个空格。具体做法如下：1、菜单栏里点击Preferences，Setting。2、在弹出来的Preferences.sublime-settings——User文本里，添加如下两行:
&#123;    "tab_size": 4,    "translate_tabs_to_spaces": true&#125;

以上配置，在使用sublime新建文件后，编辑时使用tab键，tab制表符会自动转成4个空格。但是，对于已经存在的使用tab制表符的文件，编辑时使用tab键依然还是tab制表符，不会自动转换成空格。这时，我们可以点击sublime右下角的 “Tab Size: N”，选择 “Convert Indentation to Spaces”。这样处理依然有点麻烦，能不能在保存时自动转换成空格呢？可以的。
3、菜单栏里点击 Preference，Browser Packages…，新建一个目录 ExpandTabsOnSave，目录里新建文件 ExpandTabsOnSave.py，内容为：
import sublime, sublime_plugin, osclass ExpandTabsOnSave(sublime_plugin.EventListener):    def on_pre_save(self, view):        if view.settings().get('expand_tabs_on_save') == 1:            view.window().run_command('expand_tabs')

4，Preferences.sublime-settings——User 里添加一行：
&#123;    "expand_tabs_on_save": true&#125;
以上配置，就可以在保存时自动把tab制表符转换成空格。
关闭更新提示点击菜单栏Preferences，Settings，在弹出的Settings-User部分中添加：
"update_check": false,

PS：前提是sublime已经注册，注册方法参考Sublime Text 3注册码。
1、下载并安装Sublime Text 3.2.2 Build 3211
2、浏览器访问十六进制编辑器Hexed.it
3、打开文件sublime_text.exe，搜索97 94 0D，更改为00 00 00。搜索38 18 0F 94 C1，修改为C6 00 01 90 90。
4、下载修改后的sublime_text.exe，覆盖原有sublime_text.exe
同一个窗口中打开文件双击某个文本使用sublime打开，sublime默认会新开一个窗口。但是大多数时候我们不想新开窗口，而是想和其他文件在同一个窗口中进行编辑。因此，我们需要修改默认配置，使用同一个窗口打开新文本。
点击菜单栏Preferences，Settings，在弹出的Settings-User部分中添加：
"open_files_in_new_window": false

PS：Settings-Default部分无法编辑，open_files_in_new_window 参数值为 true，不用管它，因为Settings-User优先级更高，会覆盖Settings-Default的配置。
常用快捷键
ctrl+D：选择单词，重复可增加选择下一个相同的单词。
ctrl+L：选择行，重复可依次增加选择下一行。
shift+ctrl键组合+↑↓。可实现类似鼠标选中之后移动的效果。
ctrl+P：搜索项目中的文件，模糊匹配文件名。
ctrl+R：前往 method。
ctrl+F：查找字符串。
ctrl+shift+F：在整个项目中查找字符串。如果快捷键不可用，则Find-&gt;Find in Files…。
ctrl+H：查找并替换。
ctrl+shift+P：打开命令面板。输入set syntax:css，可以设置语法为css。
ctrl+shift+[：折叠代码段。
ctrl+shift+V：粘贴并格式化。
ctrl+enter：在当前行后插入一行。
ctrl+shift+enter：在当前行前插入一行。
ctrl+shift+D：快速复制光标所在的一整行，并复制到该行之前。
ctrl+shift+K：删除一行。
ctrl+shift+上下键：可替换行。
ctrl+/：注释当前行。
ctrl+shift+/：当前位置插入注释。
ctrl+shift+A：选中标签内的内容不包括标签，继续按会继续往上一层选择。
f11：全屏。
shift+f11：全屏免打扰模式，只编辑当前文件。
esc：退出各种面板。

Package Control安装1、访问Package Control官网，找到package control的安装代码（不定时更新）。
import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)

2、ctrl + ~ 调出 console（或者View - Show Console），将安装代码粘贴进去并 enter 执行。
3、安装完成后Preferences中出现Package Control。
使用方法1、查看已安装插件ctrl+shift+P，输入package，选择list packages。
2、安装插件ctrl+shift+P，输入package，选择install packages。输入或选择你需要的插件，回车安装（注意左下角的小文字变化，会提示安装成功）。
3、卸载插件ctrl+shift+P，输入package，选择remove packages。
常用插件Soda传说中完美的编码主题，官网：http://buymeasoda.github.io/soda-theme/
EmmetHTML/CSS代码快速编写神器，项目地址：https://github.com/sergeche/emmet-sublime#readme
Javascript Completions测试了多个js插件，这个是最好用的，项目地址：https://github.com/pichillilorenzo/JavaScript-Completions
sublime jQuery提供了额外的语法高亮和几乎所有jQuery方法的片段，项目地址：https://github.com/SublimeText/jQuery/
SideBar Enhancements改进了侧边栏，增加了许多功能。
sublimelinter语法检查插件，安装sublimelinter和sublimelinter-*，*为所用的语言，例如sublimelinter-php。
Jedi - Python autocompletionJedi - an awesome autocompletion/static analysis library for Python.项目地址：https://github.com/davidhalter/jedi
ConvertToUTF8sublime默认不支持GBK编码格式，因此打开GBK编码的文件会出现乱码，本插件可以使sublime支持GBK编码格式。
PackageResourceViewer更改侧边栏字体显示大小，参考Sublime text 3更改侧边栏【sidebar】的字体大小 和 修改Sublime Text3 的侧边栏字体大小。项目地址：https://packagecontrol.io/packages/PackageResourceViewer
代码缩进格式化使用Jetbrains系列IDE进行代码格式化很方便，Windows上 Ctrl+Alt+L ，Mac上 command+option+L 。那么，使用sublime的时候，有没有这么方便的快捷键进行代码格式化呢？没有！
但是，sublime提供了一个调整缩进的方法：1、全选代码2、Edit，Line，Reindent
看起来也很方便，但是这种方法是有问题的。如果代码之前已经有了一些不规范的缩进，比如tab和space混用，比如三个空格缩进，我们会发现，最终格式化出来的代码仍然是有问题的。
正确的代码格式化方法为：1、全选代码2、shift+tab，重复直至所有行都不进行缩进3、Edit，Line，Reindent
当然，这种方法调整的只是缩进，格式化效果不如Jetbrains。
打造便携sublime制作1、在地址栏输入 %appdata% 然后删除该目录下的Sublime Text 3文件夹。2、在sublime的安装目录下（例如，我的电脑上的安装目录是：C:\Program Files\Sublime Text 3），新建 Data 文件夹(注意大小写)。3、打开Sublime Text，所有的配置文件都会生成在Data文件夹中。4、打包压缩Sublime Text 3，即可制作完成便携sublime。
使用方法一直接解压自己制作的压缩包。
使用方法二1、正常安装sublime，安装完成后不要启动。2、把自己制作的压缩包中的Data文件夹解压到sublime的安装目录。3、变更sublime的安装目录权限为完全控制。
]]></content>
      <categories>
        <category>专业</category>
        <category>工具</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>markdown</tag>
        <tag>编辑器</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title>sysbench的基本用法和结果绘图</title>
    <url>/dev-sysbench-usage-and-plot/</url>
    <content><![CDATA[sysbench简介sysbench是一个基于LuaJIT的可编写脚本的多线程基准测试工具。它最常用于数据库基准测试，但也可用于创建不涉及数据库服务器的任意复杂工作负载。
本文来研究一下sysbench的安装使用方法，以及测试结果的绘图方法。


安装部署参考Sysbench环境搭建和sysbench项目，进行sysbench的安装部署。
安装mysql1、安装mysql数据库。sudo apt-get install mysql-server mysql-client
接下来三步是可选操作。
2、sudo vim /etc/mysql/mysql.conf.d/mysqld.cnf，修改绑定IP
bind-address            = 0.0.0.0

3、重启mysqlsudo service mysql restart
4、测试登录mysql -u root -h &lt;hostip&gt; -p
安装sysbench1、安装sysbench
curl -s https://packagecloud.io/install/repositories/akopytov/sysbench/script.deb.sh | sudo bashsudo apt -y install sysbench
务必先下载脚本并执行，否则直接apt install安装的sysbench版本太低，不支持report-interval参数。
2、mysql -u root -p，创建数据库
create database sbtest;

3、验证安装sysbench --version
sysbench指令Usage:  sysbench [options]... [testname] [command]Commands implemented by most tests: prepare run cleanup helpGeneral options:  --threads=N                     number of threads to use [1]  --events=N                      limit for total number of events [0]  --time=N                        limit for total execution time in seconds [10]  --forced-shutdown=STRING        number of seconds to wait after the --time limit before forcing shutdown, or 'off' to disable [off]  --thread-stack-size=SIZE        size of stack per thread [64K]  --rate=N                        average transactions rate. 0 for unlimited rate [0]  --report-interval=N             periodically report intermediate statistics with a specified interval in seconds. 0 disables intermediate reports [0]  --report-checkpoints=[LIST,...] dump full statistics and reset all counters at specified points in time. The argument is a list of comma-separated values representing the amount of time in seconds elapsed from start of test when report checkpoint(s) must be performed. Report checkpoints are off by default. []  --debug[=on|off]                print more debugging info [off]  --validate[=on|off]             perform validation checks where possible [off]  --help[=on|off]                 print help and exit [off]  --version[=on|off]              print version and exit [off]  --config-file=FILENAME          File containing command line options  --tx-rate=N                     deprecated alias for --rate [0]  --max-requests=N                deprecated alias for --events [0]  --max-time=N                    deprecated alias for --time [0]  --num-threads=N                 deprecated alias for --threads [1]Pseudo-Random Numbers Generator options:  --rand-type=STRING random numbers distribution &#123;uniform,gaussian,special,pareto&#125; [special]  --rand-spec-iter=N number of iterations used for numbers generation [12]  --rand-spec-pct=N  percentage of values to be treated as 'special' (for special distribution) [1]  --rand-spec-res=N  percentage of 'special' values to use (for special distribution) [75]  --rand-seed=N      seed for random number generator. When 0, the current time is used as a RNG seed. [0]  --rand-pareto-h=N  parameter h for pareto distribution [0.2]Log options:  --verbosity=N verbosity level &#123;5 - debug, 0 - only critical messages&#125; [3]  --percentile=N       percentile to calculate in latency statistics (1-100). Use the special value of 0 to disable percentile calculations [95]  --histogram[=on|off] print latency histogram in report [off]General database options:  --db-driver=STRING  specifies database driver to use ('help' to get list of available drivers) [mysql]  --db-ps-mode=STRING prepared statements usage mode &#123;auto, disable&#125; [auto]  --db-debug[=on|off] print database-specific debug information [off]Compiled-in database drivers:  mysql - MySQL driver  pgsql - PostgreSQL drivermysql options:  --mysql-host=[LIST,...]          MySQL server host [localhost]  --mysql-port=[LIST,...]          MySQL server port [3306]  --mysql-socket=[LIST,...]        MySQL socket  --mysql-user=STRING              MySQL user [sbtest]  --mysql-password=STRING          MySQL password []  --mysql-db=STRING                MySQL database name [sbtest]  --mysql-ssl[=on|off]             use SSL connections, if available in the client library [off]  --mysql-ssl-cipher=STRING        use specific cipher for SSL connections []  --mysql-compression[=on|off]     use compression, if available in the client library [off]  --mysql-debug[=on|off]           trace all client library calls [off]  --mysql-ignore-errors=[LIST,...] list of errors to ignore, or "all" [1213,1020,1205]  --mysql-dry-run[=on|off]         Dry run, pretend that all MySQL client API calls are successful without executing them [off]pgsql options:  --pgsql-host=STRING     PostgreSQL server host [localhost]  --pgsql-port=N          PostgreSQL server port [5432]  --pgsql-user=STRING     PostgreSQL user [sbtest]  --pgsql-password=STRING PostgreSQL password []  --pgsql-db=STRING       PostgreSQL database name [sbtest]Compiled-in tests:  fileio - File I/O test  cpu - CPU performance test  memory - Memory functions speed test  threads - Threads subsystem performance test  mutex - Mutex performance testSee 'sysbench &lt;testname&gt; help' for a list of options for each test.

sysbench实践参考How to Benchmark Your System (CPU, File IO, MySQL) with Sysbench和使用sysbench对MySQL进行压力测试进行性能测试。
CPU使用以下命令测试CPU性能：sysbench cpu --cpu-max-prime=20000 runtotal time越小，说明CPU性能越好。
Mysql1、创建测试数据
sysbench /usr/share/sysbench/oltp_read_only.lua \--db-driver=mysql \--mysql-host=127.0.0.1 \--mysql-db=sbtest  \--mysql-user=root \--mysql-password=voidking \--mysql-socket=/var/run/mysqld/mysqld.sock \--tables=10 \--table-size=100000 \--threads=8 \--events=100000  \prepare

2、测试
time sysbench /usr/share/sysbench/oltp_read_only.lua \--db-driver=mysql \--mysql-host=127.0.0.1 \--mysql-db=sbtest  \--mysql-user=root \--mysql-password=voidking \--mysql-socket=/var/run/mysqld/mysqld.sock \--tables=10 \--table-size=100000 \--threads=8 \--events=100000  \run
每秒的transactions越高，说明性能越好。
3、测试命令2
time sysbench /usr/share/sysbench/oltp_read_only.lua \--db-driver=mysql \--mysql-host=127.0.0.1 \--mysql-db=sbtest  \--mysql-user=root \--mysql-password=voidking \--mysql-socket=/var/run/mysqld/mysqld.sock \--tables=10 \--table-size=100000 \--threads=8 \--events=0 \--time=30 \run

4、清理数据（可选）
time sysbench /usr/share/sysbench/oltp_read_only.lua \--db-driver=mysql \--mysql-host=127.0.0.1 \--mysql-db=sbtest  \--mysql-user=root \--mysql-password=voidking \--mysql-socket=/var/run/mysqld/mysqld.sock \--tables=10 \--table-size=100000 \--threads=8 \--events=0 \--time=30 \cleanup

绘图sysbench统计数据测试搞定了，数据呢？每秒钟的transactions数据呢？关键在于report-interval参数。修改测试命令为：
sysbench /usr/share/sysbench/oltp_read_only.lua \--db-driver=mysql \--mysql-host=127.0.0.1 \--mysql-db=sbtest  \--mysql-user=root \--mysql-password=voidking \--mysql-socket=/var/run/mysqld/mysqld.sock \--tables=10 \--table-size=100000 \--threads=8 \--events=0 \--time=30 \--report-interval=5 \run &gt;&gt; sysbench.log

sysbench.log内容如下：
sysbench 1.0.16 (using bundled LuaJIT 2.1.0-beta2)Running the test with following options:Number of threads: 8Report intermediate results every 5 second(s)Initializing random number generator from current timeInitializing worker threads...Threads started![ 5s ] thds: 8 tps: 792.49 qps: 12698.90 (r/w/o: 11112.31/0.00/1586.59) lat (ms,95%): 11.24 err/s: 0.00 reconn/s: 0.00[ 10s ] thds: 8 tps: 782.20 qps: 12511.60 (r/w/o: 10947.20/0.00/1564.40) lat (ms,95%): 11.04 err/s: 0.00 reconn/s: 0.00[ 15s ] thds: 8 tps: 784.80 qps: 12561.53 (r/w/o: 10991.94/0.00/1569.59) lat (ms,95%): 11.04 err/s: 0.00 reconn/s: 0.00[ 20s ] thds: 8 tps: 808.85 qps: 12935.60 (r/w/o: 11317.90/0.00/1617.70) lat (ms,95%): 10.84 err/s: 0.00 reconn/s: 0.00[ 25s ] thds: 8 tps: 795.95 qps: 12737.76 (r/w/o: 11145.86/0.00/1591.89) lat (ms,95%): 10.84 err/s: 0.00 reconn/s: 0.00[ 30s ] thds: 8 tps: 816.80 qps: 13065.00 (r/w/o: 11431.60/0.00/1633.40) lat (ms,95%): 10.65 err/s: 0.00 reconn/s: 0.00SQL statistics:    queries performed:        read:                            334810        write:                           0        other:                           47830        total:                           382640    transactions:                        23915  (796.79 per sec.)    queries:                             382640 (12748.68 per sec.)    ignored errors:                      0      (0.00 per sec.)    reconnects:                          0      (0.00 per sec.)General statistics:    total time:                          30.0123s    total number of events:              23915Latency (ms):         min:                                    7.65         avg:                                   10.04         max:                                   32.13         95th percentile:                       10.84         sum:                               240031.54Threads fairness:    events (avg/stddev):           2989.3750/3.74    execution time (avg/stddev):   30.0039/0.00

然后把可以绘图的数据单独提取出来：cat sysbench.log | grep tps &gt; sysbench.dat 
gnuplot绘图# graph titleset title ""set key below box 1# x-axis labelset xlabel "time(ms)"# y-axis labelset ylabel "queries per second"set yrange[10000:15000]set ytics 500plot "sysbench.dat" using 2:9 with linespoints title "sysbench0",\pause mouse

后记至此，sysbench的使用方法和绘图方法就基本掌握了。更详细和高阶的用法，需要的时候再去学习。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>mysql</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow进阶</title>
    <url>/dev-tensorflow-advance/</url>
    <content><![CDATA[分类学习分类和回归的区别在于输出变量的类型上。通俗理解定量输出是回归，或者说是连续变量预测；定性输出是分类，或者说是离散变量预测。如预测房价这是一个回归任务；把东西分成几类, 比如猫狗猪牛，就是一个分类任务。


MNISTMNIST是一个入门级的计算机视觉数据集，它包含各种手写数字图片，它也包含每一张图片对应的标签，告诉我们这个是数字几。接下来，我们将训练一个机器学习模型用于预测图片里面的数字。
下载数据集访问THE MNIST DATABASE，下载：

train-images-idx3-ubyte.gz
train-labels-idx1-ubyte.gz
t10k-images-idx3-ubyte.gz
t10k-labels-idx1-ubyte.gz

把这四个文件放到Tensorflow-Tutorial/tutorial-contents/mnist目录下。
数据中包含55000张训练图片，每张图片的分辨率是28×28，所以我们的训练网络输入应该是28×28=784个像素数据。
编码from __future__ import print_functionimport tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_data# number 1 to 10 datamnist = input_data.read_data_sets('./mnist', one_hot=True)def add_layer(inputs, in_size, out_size, activation_function=None,):    # add one more layer and return the output of this layer    Weights = tf.Variable(tf.random_normal([in_size, out_size]))    biases = tf.Variable(tf.zeros([1, out_size]) + 0.1,)    Wx_plus_b = tf.matmul(inputs, Weights) + biases    if activation_function is None:        outputs = Wx_plus_b    else:        outputs = activation_function(Wx_plus_b,)    return outputsdef compute_accuracy(v_xs, v_ys):    global prediction    y_pre = sess.run(prediction, feed_dict=&#123;xs: v_xs&#125;)    correct_prediction = tf.equal(tf.argmax(y_pre,1), tf.argmax(v_ys,1))    accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))    result = sess.run(accuracy, feed_dict=&#123;xs: v_xs, ys: v_ys&#125;)    return result# define placeholder for inputs to networkxs = tf.placeholder(tf.float32, [None, 784]) # 28x28ys = tf.placeholder(tf.float32, [None, 10])# add output layerprediction = add_layer(xs, 784, 10,  activation_function=tf.nn.softmax)# the error between prediction and real datacross_entropy = tf.reduce_mean(-tf.reduce_sum(ys * tf.log(prediction),                                              reduction_indices=[1]))       # losstrain_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)sess = tf.Session()# important step# tf.initialize_all_variables() no long valid from# 2017-03-02 if using tensorflow &gt;= 0.12if int((tf.__version__).split('.')[1]) &lt; 12 and int((tf.__version__).split('.')[0]) &lt; 1:    init = tf.initialize_all_variables()else:    init = tf.global_variables_initializer()sess.run(init)for i in range(1000):    batch_xs, batch_ys = mnist.train.next_batch(100)    sess.run(train_step, feed_dict=&#123;xs: batch_xs, ys: batch_ys&#125;)    if i % 50 == 0:        print(compute_accuracy(            mnist.test.images, mnist.test.labels))

过拟合过拟合的模型，泛化能力差，不能成功的表达除了训练数据以外的其他数据。
数据量增加数据量，大部分过拟合产生的原因是因为数据量太少了。
正规化运用正规化，L1、l2 regularization等等，这些方法适用于大多数的机器学习，包括神经网络。主要思想是把W（权重）加入到cost，W变得太大，就让cost随之变大，成为一种惩罚机制。
dropout还有一种专门用在神经网络的正规化的方法，叫作 dropout。在训练的时候，我们随机忽略掉一些神经元和神经联结，使这个神经网络变得“不完整”。用一个不完整的神经网络训练一次。到第二次再随机忽略另一些，变成另一个不完整的神经网络。有了这些随机 drop 掉的规则，我们可以想象其实每次训练的时候，我们都让每一次预测结果都不会依赖于其中某部分特定的神经元。
conda install scikit-learn
# View more python learning tutorial on my Youtube and Youku channel!!!# Youtube video tutorial: https://www.youtube.com/channel/UCdyjiB5H8Pu7aDTNVXTTpcg# Youku video tutorial: http://i.youku.com/pythontutorial"""Please note, this code is only for python 3+. If you are using python 2+, please modify the code accordingly."""from __future__ import print_functionimport tensorflow as tffrom sklearn.datasets import load_digitsfrom sklearn.model_selection import train_test_splitfrom sklearn.preprocessing import LabelBinarizer# load datadigits = load_digits()X = digits.datay = digits.targety = LabelBinarizer().fit_transform(y)X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=.3)def add_layer(inputs, in_size, out_size, layer_name, activation_function=None, ):    # add one more layer and return the output of this layer    Weights = tf.Variable(tf.random_normal([in_size, out_size]))    biases = tf.Variable(tf.zeros([1, out_size]) + 0.1, )    Wx_plus_b = tf.matmul(inputs, Weights) + biases    # here to dropout    Wx_plus_b = tf.nn.dropout(Wx_plus_b, keep_prob)    if activation_function is None:        outputs = Wx_plus_b    else:        outputs = activation_function(Wx_plus_b, )    tf.summary.histogram(layer_name + '/outputs', outputs)    return outputs# define placeholder for inputs to networkkeep_prob = tf.placeholder(tf.float32)xs = tf.placeholder(tf.float32, [None, 64])  # 8x8ys = tf.placeholder(tf.float32, [None, 10])# add output layerl1 = add_layer(xs, 64, 50, 'l1', activation_function=tf.nn.tanh)prediction = add_layer(l1, 50, 10, 'l2', activation_function=tf.nn.softmax)# the loss between prediction and real datacross_entropy = tf.reduce_mean(-tf.reduce_sum(ys * tf.log(prediction),                                              reduction_indices=[1]))  # losstf.summary.scalar('loss', cross_entropy)train_step = tf.train.GradientDescentOptimizer(0.5).minimize(cross_entropy)sess = tf.Session()merged = tf.summary.merge_all()# summary writer goes in heretrain_writer = tf.summary.FileWriter("log/train", sess.graph)test_writer = tf.summary.FileWriter("log/test", sess.graph)# tf.initialize_all_variables() no long valid from# 2017-03-02 if using tensorflow &gt;= 0.12if int((tf.__version__).split('.')[1]) &lt; 12 and int((tf.__version__).split('.')[0]) &lt; 1:    init = tf.initialize_all_variables()else:    init = tf.global_variables_initializer()sess.run(init)for i in range(500):    # here to determine the keeping probability    sess.run(train_step, feed_dict=&#123;xs: X_train, ys: y_train, keep_prob: 0.5&#125;)    if i % 50 == 0:        # record loss        train_result = sess.run(merged, feed_dict=&#123;xs: X_train, ys: y_train, keep_prob: 1&#125;)        test_result = sess.run(merged, feed_dict=&#123;xs: X_test, ys: y_test, keep_prob: 1&#125;)        train_writer.add_summary(train_result, i)        test_writer.add_summary(test_result, i)

参考资料
Classification 分类学习
MNIST For ML Beginners
Deep MNIST for Experts
MNIST机器学习入门
MNIST机器学习入门
Softmax函数的特点和作用是什么？

源码分享https://github.com/voidking/Tensorflow-Tutorial.git
书签TensorFlow官网
Tensorflow游乐场
莫烦Tensorflow教程系列
TensorFlow 官方文档中文版
TensorFlow中文社区
youtube CS 20SI: Tensorflow for Deep Learning Research
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>tensorflow入门</title>
    <url>/dev-tensorflow-start/</url>
    <content><![CDATA[tensorflow简介TensorFlow 是一个用于人工智能的开源神器。TensorFlow 是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。TensorFlow 最初由Google大脑小组（隶属于Google机器智能研究机构）的研究员和工程师们开发出来，用于机器学习和深度神经网络方面的研究，但这个系统的通用性使其也可广泛用于其他计算领域。
本文主要参考莫烦同学的教程，进行了少量修改。


安装tensorflow1、参考Installing TensorFlow或者下载与安装，安装TensorFlow。
2、假设我们的环境是anaconda，首先我们切换到3.6的环境，然后pip安装即可。
activate py3pip install --upgrade tensorflow

3、测试
import osos.environ['TF_CPP_MIN_LOG_LEVEL']='2'import tensorflow as tfhello = tf.constant('Hello, TensorFlow!')sess = tf.Session()print(sess.run(hello))

如果屏幕打印出“Hello, TensorFlow!”，则证明安装成功！
tensorflow基础处理结构TensorFlow 让我们可以先绘制计算结构图，也可以称是一系列可人机交互的计算操作， 然后把编辑好的Python文件转换成更高效的 C++，并在后端进行计算。

TensorFlow 首先要定义神经网络的结构，然后再把数据放入结构当中去运算和training

下面动图展示了 TensorFlow 数据处理流程：
因为TensorFlow是采用 数据流图（data flow graphs）来计算， 所以首先我们得创建一个数据流图，然后再将我们的数据（数据以 张量(tensor) 的形式存在）放到数据流图中计算。
图中的 节点（Nodes）一般用来表示施加的数学操作，但也可以表示数据输入（feed in）的起点/输出（push out）的终点，或者是读取/写入持久变量（persistent variable）的终点；线（edges）则表示在节点间相互联系的多维数据数组，即 张量（tensor），训练模型时，tensor 会不断的从数据流图中的一个节点 flow 到另一节点，这就是 TensorFlow 名字的由来。一旦输入端的所有张量准备好，节点将被分配到各种计算设备完成异步并行地执行运算。
它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。

使用图 (graph) 来表示计算任务
在被称之为 会话 (Session) 的上下文 (context) 中执行图
使用 tensor 表示数据
通过 变量 (Variable) 维护状态
使用 feed 和 fetch 可以为任意的操作(arbitrary operation) 赋值或者从其中获取数据

线性预测demo"""Please note, this code is only for python 3+. If you are using python 2+, please modify the code accordingly."""import osos.environ['TF_CPP_MIN_LOG_LEVEL']='2'import tensorflow as tfimport numpy as np# create datax_data = np.random.rand(100).astype(np.float32)y_data = x_data*0.1 + 0.3### create tensorflow structure start ###Weights = tf.Variable(tf.random_uniform([1], -1.0, 1.0))biases = tf.Variable(tf.zeros([1]))y = Weights*x_data + biasesloss = tf.reduce_mean(tf.square(y-y_data))optimizer = tf.train.GradientDescentOptimizer(0.5)train = optimizer.minimize(loss)print(tf.__version__)if int((tf.__version__).split('.')[1]) &lt; 12 and int((tf.__version__).split('.')[0]) &lt; 1:    init = tf.initialize_all_variables()else:    init = tf.global_variables_initializer()### create tensorflow structure end ###sess = tf.Session()sess.run(init)for step in range(201):    sess.run(train)    if step % 20 == 0:        print(step, sess.run(Weights), sess.run(biases))

x_data和y_data是真实数据，y是预测出的数据，loss代表预测误差，optimizer代表调优方法，train代表最小化误差，sess.run(train)代表执行一次调优。
Sessionimport tensorflow as tfm1 = tf.constant([[2, 2]])m2 = tf.constant([[3],                  [3]])dot_operation = tf.matmul(m1, m2)print(dot_operation)  # wrong! no result# method1 use sessionsess = tf.Session()result = sess.run(dot_operation)print(result)sess.close()# method2 use sessionwith tf.Session() as sess:    result_ = sess.run(dot_operation)    print(result_)

从上面代码的执行结果可以看出，以tf开头的那些语句，并没有立即执行，而是在sess.run()的时候才会执行。
Variableimport tensorflow as tfvar = tf.Variable(0)    # our first variable in the "global_variable" setadd_operation = tf.add(var, 1)update_operation = tf.assign(var, add_operation)init = tf.global_variables_initializer()with tf.Session() as sess:    # once define variables, you have to initialize them by doing this    sess.run(init)    for _ in range(3):        sess.run(update_operation)        print(sess.run(var))

如果定义了变量，一定要global_variables_initializer并且run。
placeholderimport tensorflow as tfx1 = tf.placeholder(dtype=tf.float32, shape=None)y1 = tf.placeholder(dtype=tf.float32, shape=None)z1 = x1 + y1x2 = tf.placeholder(dtype=tf.float32, shape=[2, 1])y2 = tf.placeholder(dtype=tf.float32, shape=[1, 2])z2 = tf.matmul(x2, y2)with tf.Session() as sess:    # when only one operation to run    z1_value = sess.run(z1, feed_dict=&#123;x1: 1, y1: 2&#125;)    # when run multiple operations    z1_value, z2_value = sess.run(        [z1, z2],       # run them together        feed_dict=&#123;            x1: 1, y1: 2,            x2: [[2], [2]], y2: [[3, 3]]        &#125;)    print(z1_value)    print(z2_value)

在计算时，给x1赋值1，给y1赋值2。
激励函数激励函数是用来激活神经元的函数。当你的神经网络层只有两三层，不是很多的时候， 对于隐藏层，使用任意的激励函数；在多层神经网络中，则要有所选择。在卷积神经网络中，一般使用relu；在循环神经网络中，一般使用relu或者tanh。
神经网络添加层import tensorflow as tfdef add_layer(inputs, in_size, out_size, activation_function=None):    # add one more layer and return the output of this layer    Weights = tf.Variable(tf.random_normal([in_size, out_size]))    biases = tf.Variable(tf.zeros([1, out_size]) + 0.1)    Wx_plus_b = tf.matmul(inputs, Weights) + biases    if activation_function is None:        outputs = Wx_plus_b    else:        outputs = activation_function(Wx_plus_b)    return outputs

建造神经网络import tensorflow as tfimport numpy as npdef add_layer(inputs, in_size, out_size, activation_function=None):    # add one more layer and return the output of this layer    Weights = tf.Variable(tf.random_normal([in_size, out_size]))    biases = tf.Variable(tf.zeros([1, out_size]) + 0.1)    Wx_plus_b = tf.matmul(inputs, Weights) + biases    if activation_function is None:        outputs = Wx_plus_b    else:        outputs = activation_function(Wx_plus_b)    return outputs# Make up some real datax_data = np.linspace(-1,1,300)[:, np.newaxis]noise = np.random.normal(0, 0.05, x_data.shape)y_data = np.square(x_data) - 0.5 + noise# define placeholder for inputs to networkxs = tf.placeholder(tf.float32, [None, 1])ys = tf.placeholder(tf.float32, [None, 1])# add hidden layerl1 = add_layer(xs, 1, 10, activation_function=tf.nn.relu)# add output layerprediction = add_layer(l1, 10, 1, activation_function=None)# the error between prediction and real dataloss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - prediction),                     reduction_indices=[1]))train_step = tf.train.GradientDescentOptimizer(0.1).minimize(loss)# important stepinit = tf.global_variables_initializer()sess = tf.Session()sess.run(init)for i in range(1000):    # training    sess.run(train_step, feed_dict=&#123;xs: x_data, ys: y_data&#125;)    if i % 50 == 0:        # to see the step improvement        print(sess.run(loss, feed_dict=&#123;xs: x_data, ys: y_data&#125;))

结果可视化import tensorflow as tfimport numpy as npimport matplotlib.pyplot as pltdef add_layer(inputs, in_size, out_size, activation_function=None):    # add one more layer and return the output of this layer    Weights = tf.Variable(tf.random_normal([in_size, out_size]))    biases = tf.Variable(tf.zeros([1, out_size]) + 0.1)    Wx_plus_b = tf.matmul(inputs, Weights) + biases    if activation_function is None:        outputs = Wx_plus_b    else:        outputs = activation_function(Wx_plus_b)    return outputs# Make up some real datax_data = np.linspace(-1,1,300)[:, np.newaxis]noise = np.random.normal(0, 0.05, x_data.shape)y_data = np.square(x_data) - 0.5 + noise# define placeholder for inputs to networkxs = tf.placeholder(tf.float32, [None, 1])ys = tf.placeholder(tf.float32, [None, 1])# add hidden layerl1 = add_layer(xs, 1, 10, activation_function=tf.nn.relu)# add output layerprediction = add_layer(l1, 10, 1, activation_function=None)# the error between prediction and real dataloss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - prediction),                     reduction_indices=[1]))train_step = tf.train.GradientDescentOptimizer(0.1).minimize(loss)# important stepinit = tf.global_variables_initializer()sess = tf.Session()sess.run(init)fig = plt.figure()ax = fig.add_subplot(1,1,1)ax.scatter(x_data, y_data)plt.ion()plt.show()# plt.show(block=False)for i in range(1000):    # training    sess.run(train_step, feed_dict=&#123;xs: x_data, ys: y_data&#125;)    if i % 50 == 0:        # to see the step improvement        # print(sess.run(loss, feed_dict=&#123;xs: x_data, ys: y_data&#125;))        try:            ax.lines.remove(lines[0])        except Exception:            pass        prediction_value = sess.run(prediction,feed_dict=&#123;xs: x_data&#125;)        lines = ax.plot(x_data, prediction_value, 'r-',lw=5)               plt.pause(0.1)

加速神经网络训练加速神经网络训练的方法:

Stochastic Gradient Descent (SGD)
Momentum
AdaGrad
RMSProp
Adam

具体参考《加速神经网络训练 (Speed Up Training)》
optimizer相关资料：

TensorFlow可用的optimizer 链接
各种Optimizer 的对比 链接

一般使用GradientDescentOptimizer就够了，往后学习的话，可以使用MomentumOptimizer、AdamOptimizer、RMSPropOptimizer。
源码分享https://github.com/voidking/Tensorflow-Tutorial.git
书签TensorFlow官网
Tensorflow游乐场
莫烦Tensorflow教程系列
TensorFlow 官方文档中文版
TensorFlow中文社区
TensorFlow入门
youtube CS 20SI: Tensorflow for Deep Learning Research
Tensorflow 的处理结构及基本使用
2016年不可错过的21个深度学习视频、教程和课程
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>ThinkPHP实战</title>
    <url>/dev-thinkphp-in-action/</url>
    <content><![CDATA[前言本着“需要什么就学习什么”的原则，花了几天时间，实践了一下thinkphp框架的使用。整理了一下必须掌握的三个部分：路由控制、模板渲染、增删改查。


准备在《ThinkPHP开发环境搭建》中，我们已经准备好了thinkphp的开发环境。在此基础上，复制Application中的Home文件夹，重命名为Admin。然后，修改Admin/IndexController.class.php文件的namespace为：
namespace Admin\Controller;
好了，可以进入真正的开发了！
路由控制路由控制，在thinkphp开发手册中对应“架构&gt;URL模式”。thinkphp提供了多种URL模式，本次开发采用标准URL格式。
http://serverName/index.php/模块/控制器/操作

比如，我们在Admin/IndexController.class.php文件中添加函数：
public function firstFunc()&#123;    echo '第一个函数';&#125;
那么，这个函数的访问路径为http://localhost/thinkphp/index.php/Admin/Index/firstFunc。访问该路径，我们可以在页面上看到返回值“第一个函数”。
模板渲染模板渲染，在thinkphp开发手册中对应“视图&gt;模板赋值和模板渲染”以及“模板”。在Admin/View/Index文件夹下，新建文件template.html。在Admin/IndexController.class.php文件中添加函数：
public function template()&#123;    $data = '测试数据';    $dataArr = array(        array('name'=&gt;'郝锦','age'=&gt;'24'),        array('name'=&gt;'小帅','age'=&gt;'22'),        array('name'=&gt;'小飞','age'=&gt;'22')    );    $dataObj = new userInfo();    $this-&gt;assign('data2',$data);    $this-&gt;assign('dataArr',$dataArr);    $this-&gt;assign('dataObj',$dataObj);    $this-&gt;display();&#125;
同时，在文件最后添加一个userInfo类：
class userInfo&#123;    public $name = '郝锦';    public $age = '24';    function show()&#123;        echo '一个函数';    &#125;&#125;
那么，$data、$dataArr和$dataObj都会通过assign函数传送到template.html页面。template.html页面代码如下：
&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;模板&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;模板&lt;/h1&gt;    &lt;p&gt;&#123;$data2&#125;&lt;/p&gt;    &lt;p&gt;&#123;$dataObj:name&#125;&lt;/p&gt;    &lt;p&gt;&#123;$dataObj:age&#125;&lt;/p&gt;    &lt;volist name='dataArr' id="item"&gt;        &#123;$item.name&#125;&amp;nbsp;&#123;$item.age&#125;&lt;br/&gt;    &lt;/volist&gt;&lt;/body&gt;&lt;/html&gt;

最终效果如下：
注意，函数名和页面名字是相同的，一一对应的。
增删查改增删查改，在thinkphp开发手册中对应“模型&gt;GURD操作”和“专题&gt;数据分页”。
数据库配置利用navicat等工具连接到本地mysql数据库，创建数据库volunteer，在数据库中创建表volun_admin(int id, varchar name, vachar password)和volun_project(int id, varchar title, varchar content)。注意，编码格式选择utf8。
php配置在进行数据库增删查改之前，我们需要先连接到数据库。打开Application/Common/Conf/config.php文件，修改内容如下：
&lt;?phpreturn array(    //'配置项'=&gt;'配置值'    'DB_TYPE'=&gt;'mysql', //数据库类型    'DB_HOST'=&gt;'localhost', //服务器地址    'DB_NAME'=&gt;'volunteer', //数据库名    'DB_USER'=&gt;'root', //用户名    'DB_PWD'=&gt;'', //密码    'DB_PORT'=&gt;3306, //端口    'DB_PREFIX'=&gt;'volun_', //数据库表前缀    'SHOW_PAGE_TRACE' =&gt;true,);?&gt;

project表的增删查改// 志愿项目增删查改public function projectAdd($title, $content)&#123;    $project = D('project');    $data['title'] = $title;    $data['content'] = $content;    if($project-&gt;create($data))&#123;        $id = $project-&gt;add();        if($id)&#123;            $result = array(                'code'=&gt; '0',                'ext'=&gt; 'success'            );            echo json_encode($result);        &#125;    &#125;&#125;public function projectEdit($id, $title, $content)&#123;    $project = D('project');    $data['title'] = $title;    $data['content'] = $content;    $success = $project-&gt;where("id='$id'")-&gt;save($data);    if($success)&#123;        $result = array(            'code'=&gt; '0',            'ext'=&gt; 'success'        );        echo json_encode($result);    &#125;else &#123;        $result = array(            'code'=&gt; '1',            'ext'=&gt; 'fail'        );        echo json_encode($result);    &#125;&#125;public function projectDelete($id)&#123;    $project = D('project');    $success = $project-&gt;where("id='$id'")-&gt;delete();    if($success)&#123;        $result = array(            'code'=&gt; '0',            'ext'=&gt; 'success'        );        echo json_encode($result);    &#125;else &#123;        $result = array(            'code'=&gt; '1',            'ext'=&gt; 'fail'        );        echo json_encode($result);    &#125;&#125;public function projectList()&#123;    $project = D('project');    $resultArr = $project-&gt;select();    echo json_encode($resultArr,JSON_UNESCAPED_UNICODE);&#125;public function projectPage($pageSize,$pageNum)&#123;    $project = D('project');    $total = $project-&gt;count();    $totalPage = $total%$pageSize ? (int)($total/$pageSize)+1 : (int)($total/$pageSize);        $list = $project-&gt;page($pageNum.','.$pageSize)-&gt;select();    if($list)&#123;        $resultArr = array(            'totalPage'=&gt; $totalPage,            'pageNum'=&gt; $pageNum,            'projectList'=&gt; $list        );        $result = array(            'code'=&gt; '0',            'ext'=&gt; 'success',            'obj'=&gt; $resultArr        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;&#125;

以上方法，在js中，可以使用GET方式请求，也可以使用POST方式请求。
路由控制、模板渲染、增删改查，至此全部跑通，可以进行简单的开发了。至于thinkphp提供的其他更加强大的功能，在需要时查查文档就好。
接口测试上次在给大家演示HttpRequester的时候，验证登录接口，一直出现错误。猜测有四种可能：1、HttpRequester的问题2、thinkphp的问题3、php的问题4、apache的问题
HttpRequester的问题以projectAdd方法为例，在js中使用ajax请求该方法，无论type是GET还是POST，都能成功拿到返回值{&quot;code&quot;:&quot;0&quot;,&quot;ext&quot;:&quot;success&quot;}。
在HttpRequester中，使用GET方式请求该方法，可以拿到返回值；但是，使用POST方式请求，拿不到返回值，提示“参数错误或者未定义:title”，因为projectAdd方法没有拿到我们传过去的参数。
修改projectAdd方法为：
public function projectAdd()&#123;    $title = $_POST['title'];    $content = $_POST['content'];    $project = D('project');    $data['title'] = $title;    $data['content'] = $content;    if($project-&gt;create($data))&#123;        $id = $project-&gt;add();        if($id)&#123;            $result = array(                'code'=&gt; '0',                'ext'=&gt; 'success'            );            echo json_encode($result);        &#125;    &#125;&#125;

再次使用HttpRequester请求projectAdd方法，这次换了个错误：
Column 'content' cannot be null [ SQL语句 ] : INSERT INTO `volun_project` (`title`,`content`) VALUES (NULL,NULL)

显然，错误的原因依然是projectAdd方法没有拿到我们传过去的参数，导致title和content为空。
使用ajax的POST方式请求该方法，成功拿到返回值。可见，这是HttpRequester的问题，它无法模拟ajax的POST请求。
那么问题来了，ajax的POST和HttpRequester的POST到底有什么区别？很遗憾，暂时没有找到答案。
thinkphp的问题在公司开发时，一直使用HttpRequester来验证接口，能用ajax请求的接口，都可以使用HttpRequester来模拟请求。这样看来，就是接口的问题，也就是thinkphp框架的问题！或者，就是php的问题！
php的问题在thinkphp文件下，新建了一个test.php文件：
&lt;?php    $title = $_POST['title'];    $array = array(        'title'=&gt;$title    );    echo json_encode($array);?&gt;
在ajax中，带入参数{title:&#39;测试标题&#39;}，POST请求http://localhost/thinkphp/test.php，成功拿到返回值。
在HttpRequester中，带入参数{title:&#39;测试标题&#39;}，POST请求http://localhost/thinkphp/test.php，提示错误“Notice: Undefined index: title in D:\Server\wamp64\www\thinkphp\test.php on line 2”。
修改test.php文件为：
&lt;?php    $title = $_GET['title'];    $array = array(        'title'=&gt;$title    );    echo json_encode($array);?&gt;
在ajax中，带入参数{title:&#39;测试标题&#39;}，GET请求http://localhost/thinkphp/test.php，成功拿到返回值。
在HttpRequester中，带入参数{title:&#39;测试标题&#39;}，GET请求http://localhost/thinkphp/test.php，成功拿到返回值。
由此排除thinkphp的问题。
apache的问题还有一种可能，apache的问题，于是把test.php文件放到nginx下，经测试，接口同样拿不到参数。由此排除apache的问题。
小结综上，HttpRequester无法测试thinkphp的POST接口问题，有两个可能，一个是HttpRequester存在缺陷，另一个是php存在缺陷。
后记无论哪种原因，总之，无法使用HttpRequester的POST请求来验证我们的thinkphp接口了。需要验证接口时，暂时使用GET请求，因为我们的接口两种请求方式都可以拿到返回值。
注意，本应该是POST请求的接口，接口文档中的请求类型依然写POST，ajax的type也使用POST，保证规范性。
2016.09.14更新Thinkphp3.2.3 接收不到json数据https://segmentfault.com/q/1010000004980405
原来，造成HttpRequester无法测试接口的原因，是Content-Type没有选对。
由于PHP默认只识别Content-Type: application/x-www.form-urlencoded标准的数据类型，因此，对型如application/json的内容无法解析为$_POST数组，故保留原型，交给$GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;]来接收。
file_get_contents(&#39;php://input&#39;)允许读取 POST 的原始数据，和$GLOBALS[&#39;HTTP_RAW_POST_DATA&#39;]比起来，它给内存带来的压力较小，并且不需要任何特殊的php.ini设置。file_get_contents(&#39;php://input&#39;)不能用于enctype=&quot;multipart/form-data&quot;。
书签序言 - ThinkPHP3.2完全开发手册http://document.thinkphp.cn/manual_3_2.html
ThinkPHP框架教程 - 猿团http://edu.yuantuan.com/course/explore/thinkphp
PHP: 语言参考 - Manualhttp://php.net/manual/zh/langref.php
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp中session跨域问题</title>
    <url>/dev-thinkphp-session-cross-domain/</url>
    <content><![CDATA[问题描述《thinkphp实现短信验证注册》中，郝同学不止记录了短信验证码的实现方法，同时还记录了图片验证码的实现方法。本地使用，一切正常；后端项目和前端项目都部署到服务器，一切正常；后端项目部署到服务器，并设置允许跨域访问后，本地前端项目使用服务器上后端项目接口时，问题来了：首先，使用postman测试获取图片验证码接口和验证图片验证码接口，正常。然后，在html中使用获取图片验证码接口，正常；最后，在JS中使用验证图片验证码接口，出错！！！


分析通过问题描述，我们看出，问题出现在跨域上。那么，有两种可能，一种是因为跨域设置不正确；一种是因为thinkphp本身的问题。
采用另外一种跨域配置，问题依然存在。那就是thinkphp本身的问题了，经查找资料，问题定位在thinkphp的session跨域上。
跨子域解决办法其实不管是ThinkPHP还是php本身，在解决session跨域问题的时候都需要设置session.cookie_domain。针对session跨域这一问题的解决方法主要有以下几种：第一种情况：如果目录下没有.htaccess这个文件，也就是没有采取url伪静态的话，那么，在conf/config.php的第一行加上：
ini_set('session.cookie_domain',".domain.com");//跨域访问Session
这时如果你开启了调试，那么可以用！但关闭了调试，就不管用了！
第二种情况：如果你目录下有.htaccess这个文件，那么你在根目录，index.php的第一行加入：
&lt;?php ini_set('session.cookie_domain',".domain.com");//跨域访问Session// 应用入口文件?&gt;
这种方法不管开不开启调试都管用！
然而，我们的问题并不是跨子域的问题，而是完全跨域，所以上述方法无效。
完全跨域解决办法获取图片验证码请求查看获取图片验证码的请求信息，Request Headers为：
Accept:image/webp,image/*,*/*;q=0.8Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4Connection:keep-aliveCookie:pma_lang=zh_CN; pma_collation_connection=utf8_unicode_ci; pma_iv-1=wnpO4gv0eQRW1AMHmGr2ww%3D%3D; pmaUser-1=weZPqS0%2BW7nzFUVHRdqcfA%3D%3DHost:api.voidking.comReferer:http://localhost/ajax/ajax.htmlUser-Agent:Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36

Response Headers为：
Access-Control-Allow-Origin:*Cache-Control:post-check=0, pre-check=0Cache-Control:private, max-age=0, no-store, no-cache, must-revalidateConnection:keep-aliveContent-Type:image/pngDate:Sun, 27 Nov 2016 12:10:44 GMTExpires:Thu, 19 Nov 1981 08:52:00 GMTPragma:no-cacheServer:nginxSet-Cookie:PHPSESSID=721t4sqanvsii550m1dk8gq1o3; path=/; domain=.voidking.comTransfer-Encoding:chunked

验证验证码请求查看验证验证码的请求信息，Request Headers为：
Accept:application/json, text/javascript, */*; q=0.01Accept-Encoding:gzip, deflateAccept-Language:zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4Connection:keep-aliveContent-Length:9Content-Type:application/x-www-form-urlencoded; charset=UTF-8Host:api.voidking.comOrigin:http://localhostReferer:http://localhost/ajax/ajax.htmlUser-Agent:Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36

Response Headers为：
Access-Control-Allow-Origin:*Cache-Control:no-store, no-cache, must-revalidate, post-check=0, pre-check=0Connection:keep-aliveContent-Encoding:gzipContent-Type:text/html; charset=UTF-8Date:Sun, 27 Nov 2016 12:13:21 GMTExpires:Thu, 19 Nov 1981 08:52:00 GMTPragma:no-cacheServer:nginxSet-Cookie:PHPSESSID=149t0hhs2icqaaemvp39onkgp4; path=/; domain=.voidking.comTransfer-Encoding:chunkedVary:Accept-Encoding

再次获取图片验证码请求Request Headers为：
Accept:image/webp,image/*,*/*;q=0.8Accept-Encoding:gzip, deflate, sdchAccept-Language:zh-CN,zh;q=0.8,en-US;q=0.6,en;q=0.4Cache-Control:max-age=0Connection:keep-aliveCookie:pma_lang=zh_CN; pma_collation_connection=utf8_unicode_ci; pma_iv-1=wnpO4gv0eQRW1AMHmGr2ww%3D%3D; pmaUser-1=weZPqS0%2BW7nzFUVHRdqcfA%3D%3D; PHPSESSID=721t4sqanvsii550m1dk8gq1o3Host:api.voidking.comReferer:http://localhost/ajax/ajax.htmlUser-Agent:Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.71 Safari/537.36

Response Headers为：
Access-Control-Allow-Origin:*Cache-Control:private, max-age=0, no-store, no-cache, must-revalidateCache-Control:post-check=0, pre-check=0Connection:keep-aliveContent-Type:image/pngDate:Sun, 27 Nov 2016 13:26:21 GMTExpires:Thu, 19 Nov 1981 08:52:00 GMTPragma:no-cacheServer:nginxTransfer-Encoding:chunked

三次请求比较
第一次获取图片验证码请求，Cookie中没有PHPSESSID，所以，返回信息中有Set-Cookie。第二次获取图片验证码请求，Cookie中含有PHPSESSID，所以，返回信息中没有了Set-Cookie。而且第一次请求返回信息Set-Cookie中的PHPSESSID，和第二次请求请求信息Cookie中的PHPSESSID是相同的。
而验证图片验证码的ajax请求，没有Cookie，自然也没有PHPSESSID，所以，返回信息中也有Set-Cookie。
可见，我们需要在前端做一些修改，使之发送请求时带着Cookie。
前端jquery设置&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;jquery&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;p&gt;        &lt;img src="http://api.voidking.com/owner-bd/index.php/Home/CheckCode/getPicCode" alt=""&gt;        &lt;input type="text" id="picCode"&gt;        &lt;input type="button" id="send" value="验证"&gt;    &lt;/p&gt;&lt;script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"&gt;&lt;/script&gt;&lt;script&gt;    $(function()&#123;        $('#send').click(function()&#123;            //console.log(document.cookie);            $.ajax(&#123;                url: 'http://api.voidking.com/owner-bd/index.php/Home/CheckCode/checkPicCode',                type: 'POST',                crossDomain: true,                xhrFields: &#123;                    withCredentials: true                &#125;,                dataType: 'json',                data: &#123;code: $('#picCode').val()&#125;,                success: function(data)&#123;                    console.log(data);                &#125;,                error: function(xhr)&#123;                    console.log(xhr);                &#125;            &#125;);        &#125;);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

请求时报错如下：
A wildcard '*' cannot be used in the 'Access-Control-Allow-Origin' header when the credentials flag is true. Origin 'http://localhost' is therefore not allowed access. The credentials mode of an XMLHttpRequest is controlled by the withCredentials attribute.

出现了跨域报错，可见后端也需要做一些修改，使之可以接收跨域Cookie。
后端nginx设置add_header Access-Control-Allow-Origin http://localhost;add_header Access-Control-Allow-Credentials true;
注意：服务器端Access-Control-Allow-Credentials参数为true时，Access-Control-Allow-Origin参数的值不能为*。
后端nginx设置后，jquery的ajax请求正常了，可以携带Cookie，后端正常接收数据并返回数据。
由于angular的ajax请求不同于jquery，所以，我们还需要研究一下angular怎么发送携带Cookie的跨域请求。
前端angular设置&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;angular&lt;/title&gt;    &lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp" &gt;    &lt;p ng-controller="myCtrl"&gt;        &lt;img src="http://api.voidking.com/owner-bd/index.php/Home/CheckCode/getPicCode" alt=""&gt;        &lt;input type="text" id="picCode" ng-model="picCode"&gt;        &lt;input type="button" ng-click="send()"  value="验证"&gt;    &lt;/p&gt;&lt;script&gt;    var app = angular.module('myApp', []);    app.controller('myCtrl', function($scope, $http, $httpParamSerializer) &#123;        $scope.send = function()&#123;            $http(&#123;                method:'POST',                url:'http://api.voidking.com/owner-bd/index.php/Home/CheckCode/checkPicCode',                headers:&#123;                    'Content-Type':'application/x-www-form-urlencoded'                &#125;,                withCredentials: true,                dataType: 'json',                data: $httpParamSerializer(&#123;code: $scope.picCode&#125;)            &#125;).then(function successCallback(response) &#123;                console.log(response.data);                $scope.username = response.data.username;            &#125;, function errorCallback(response) &#123;                console.log(response.data);            &#125;);        &#125;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

nginx配置文件结合《thinkphp部署到nginx服务器》中nginx的配置，最终nginx配置配置文件nginx.conf文件内容如下：
error_log  logs/error.log  error ;pid logs/nginx.pid;user  www;worker_processes  auto;worker_rlimit_nofile 51200;events &#123;    use epoll;    worker_connections  51200;&#125;http &#123;    client_body_buffer_size 32k;    client_header_buffer_size 2k;    client_max_body_size 2m;    default_type application/octet-stream;    log_not_found off;    server_tokens off;    include       mime.types;    gzip on;    gzip_min_length  1k;    gzip_buffers     4 16k;    gzip_http_version 1.0;    gzip_comp_level 2;    gzip_types       text/plain text/css text/xml text/javascript application/x-javascript application/xml application/rss+xml application/xhtml+xml application/atom_xml;    gzip_vary on;    #error_page   500 502 503 504  /50x.html;     log_format  access  '$remote_addr - $remote_user [$time_local] "$request" '              '$status $body_bytes_sent "$http_referer" '              '"$http_user_agent" $http_x_forwarded_for';    server &#123;        listen 80 default_server;        server_name localhost api.voidking.com;        root /home/wwwroot/;        index index.php index.html index.htm;            add_header Access-Control-Allow-Origin http://localhost;        add_header Access-Control-Allow-Credentials true;        location ~ \.php &#123;        root /home/wwwroot/;            fastcgi_pass   127.0.0.1:9000;            fastcgi_index  index.php;        fastcgi_split_path_info ^(.+\.php)(.*)$;            fastcgi_param PATH_INFO $fastcgi_path_info;            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;            fastcgi_param  PHP_VALUE        open_basedir=$document_root:/tmp/:/proc/;            include        fastcgi_params;        &#125;    &#125;    include vhost/*.conf;    &#125;

后记至此，大功告成，session跨域问题完美解决。
书签ThinkPHP框架实现session跨域问题的解决方法http://www.jb51.net/article/51722.htm
ThinkPHP二级域名session共享问题http://www.thinkphp.cn/topic/6380.html
php 跨域、跨子域，跨服务器读取sessionhttp://blog.csdn.net/kylinbl/article/details/7634075
跨服务器Session共享的四种方法http://blog.sina.com.cn/s/blog_5f3d71430100jv7q.html
Angular通过CORS实现跨域方案https://my.oschina.net/blogshi/blog/303758
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>thinkphp</tag>
        <tag>session</tag>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu14.04安装配置Ganglia</title>
    <url>/dev-ubuntu-ganglia/</url>
    <content><![CDATA[Ganglia简介Ganglia是UC Berkeley发起的一个开源集群监视项目，设计用于测量数以千计的节点。Ganglia的核心包含gmond、gmetad以及一个Web前端。主要是用来监控系统性能，如：cpu 、mem、硬盘利用率， I/O负载、网络流量情况等，通过曲线很容易见到每个节点的工作状态，对合理调整、分配系统资源，提高系统整体性能起到重要作用。


Ganlia结构Ganglia在结构上由三种守护进程组成gmond 、gmetad和gweb。在操作上，每种守护进程都是独立的，运行时只需要自己的配置文件来操作即可，任意守护进程在缺少其他两种守护进程的情况下也可以正常启动和运行。然而，三者在结构上又是相互协作的，需要同时使用才能发挥功效。
gmondgmond和普通代理一样，安装在每一台需要监控的主机上，负责与操作系统交互以获得需要关注的指标数据，例如CPU负载和硬盘容量。 
gmond在内部采用模块化设计，采用基于C语言编写的、根据操作系统定制的插件进行监控。和其他监控系统采用的客户端代理软件不同，gmond不需要等待外部轮询引擎的数据监测请求，也不将监控数据直接上传至集中式轮询器，而是根据自己本地配置文件定义的调度方案进行轮询。监测数据时使用简单的监听／通告协议，通过 XDR (External Data Representation)在集群内的主机之间共享。因此，Ganglia集群内的每个节点都知道同一集群内所有主机的当前指标数据。远程轮询器可以通过端口8649向集群内任意节点请求获得该集群XML格式的所有数据。 
gmond并不是消极等待被监控系统服务器唤醒，而总是处于激活态，以便进行测量、传输和共享。轮询器不再需要知道从哪些主机获取哪些服务，而只需要一个包含每个集群内至少一台主机名称的列表即可。
gmetadgmetad的作用是整合所有信息。
gmeted是一个简单的轮询器，对网络中每个集群进行轮询，并将每台主机上返回的所有指标数据写入各个集群对应的轮询数据库RRD。作为数据存储的一种流行的解决方案，RRDtool是很好的选择。指标数据存储于轮询数据库（Round Robin Database），这种数据库包含了多个时间块内静态分配的数值。如果每10秒进行一次轮询，每次数据都进行存储，一天将需要8640次存储。考虑到数据保留需求， RRDtool内部以“循环覆盖”的方式管理数据，将新数据的值叠加到原来的数值上来覆盖原有数据。
gwebGanglia可视化工具——gweb无需用户进行任何自定义设置即可便捷、及时地访问网络中任意一台主机的任意一种指标数据。
主节点安装配置ganglia是一个集群监控项目，要分主节点和从节点。首先，我们来完成主节点的安装配置。
1、更新软件源中的软件列表sudo apt-get update
2、安装gmond、gmetad和gwebsudo apt-get install ganglia-monitor rrdtool gmetad ganglia-webfrontend
3、配置gmondsudo vi /etc/ganglia/gmond.conf分别找到：
cluster &#123;  name = "unspecified"  owner = "unspecified"  latlong = "unspecified"  url = "unspecified"&#125;udp_send_channel &#123;  mcast_join = 239.2.11.71  port = 8649  ttl = 1&#125;udp_recv_channel &#123;  mcast_join = 239.2.11.71  port = 8649  bind = 239.2.11.71&#125;

修改为：
cluster &#123;  name = "my cluster"   owner = "unspecified"  latlong = "unspecified"  url = "unspecified"&#125;udp_send_channel &#123;  # mcast_join = 239.2.11.71  host = 192.168.56.103  port = 8649  ttl = 1&#125;udp_recv_channel &#123;  # mcast_join = 239.2.11.71  port = 8649  # bind = 239.2.11.71&#125;

4、配置gmetadsudo vi /etc/ganglia/gmetad.conf
查找cluster，注释掉该行，修改为：
# data_source "my cluster" localhostdata_source "my cluster" 10 192.168.56.103:8649

data_source后面有三个参数，第一个参数”my cluster”是集群名称；第二个参数10是轮询时间（单位：秒）；第三个参数192.168.56.103:8649是要监听的机器的IP和端口（可写多个，用空格隔开）。
5、配置gwebsudo cp /etc/ganglia-webfrontend/apache.conf /etc/apache2/sites-enabled/ganglia.conf
6、重启服务
sudo /etc/init.d/ganglia-monitor restartsudo /etc/init.d/gmetad restartsudo /etc/init.d/apache2 restart

7、测试访问ubuntu测试：curl http://192.168.56.103/ganglia/浏览器访问测试：http://192.168.56.103/ganglia/ 
从节点安装配置以上，已经完成了ganglia主节点的安装配置，但是往往我们要监控的是一个集群。接下里，我们就来研究一下从节点的配置。
Ganglia结构一节中，我们了解到，gmond要安装在每一个节点，负责监控主机情况；gmetad（包括rrdtool）只要安装在主节点就可以，负责收集各个节点的数据；gweb只要安装在主节点，负责显示gmetad收集的数据。
综上，从节点只要安装gmond就可以了。
从节点假设我们有一个从节点，IP为192.168.56.104，那么它的安装配置步骤如下：
1、更新软件源中的软件列表sudo apt-get update
2、安装gmondsudo apt-get install ganglia-monitor
3、配置gmondsudo vi /etc/ganglia/gmond.conf分别找到：
cluster &#123;  name = "unspecified"  owner = "unspecified"  latlong = "unspecified"  url = "unspecified"&#125;udp_send_channel &#123;  mcast_join = 239.2.11.71  port = 8649  ttl = 1&#125;udp_recv_channel &#123;  mcast_join = 239.2.11.71  port = 8649  bind = 239.2.11.71&#125;

修改为：
cluster &#123;  name = "my cluster"   owner = "unspecified"  latlong = "unspecified"  url = "unspecified"&#125;udp_send_channel &#123;  # mcast_join = 239.2.11.71  host = 192.168.56.103  port = 8649  ttl = 1&#125;udp_recv_channel &#123;  # mcast_join = 239.2.11.71  port = 8649  # bind = 239.2.11.71&#125;

没错，从节点的gmond配置和主节点完全相同。
4、重启服务sudo /etc/init.d/ganglia-monitor restart
主节点配置完从节点就好了吗？并没有，主节点也要做相应修改，主要是修改下gmetad配置。
1、sudo vi /etc/ganglia/gmetad.conf
查找cluster，修改为：
# data_source "my cluster" localhostdata_source "my cluster" 10 192.168.56.103:8649 192.168.56.104:8649

这样，就添加好了192.168.56.104这个从节点。
注意：gmetad会依次检测指定主机，并从第一台响应主机开始收集状态数据，而每一台主机上的gmond都知道所在集群的所有状态数据，所以无需在data_source定义里指定集群内的所有主机。假若有节点失效，通常指定两三个主机也就足够保证数据的收集。
2、重启gmetadsudo /etc/init.d/gmetad restart
3、测试访问等待10秒，再次访问 http://192.168.56.103/ganglia/ ，就能看到新加入的从节点。
删除数据由于重设了管理机的系统时间，发现所有的机器状态都变成了Hosts down，这时我们需要删除数据重新开始统计。
1、管理机删除rrds目录下所有文件cd /var/lib/ganglia/rrds &amp;&amp; sudo rm -rf ./*
2、管理机重启gmond和gmetadsudo /etc/init.d/ganglia-monitor restartsudo /etc/init.d/gmetad restart
3、客户机重启gmondsudo /etc/init.d/ganglia-monitor restart
删除机器ganglia默认服务器down机也不会在web前端清除该设备，官方文档介绍的办法如下：
1、登录管理机
2、编辑gmond.conf，sudo vim /etc/ganglia/gmond.conf在globals中找到host_dmax，它的默认值为0，意思是不清除节点。host_dmax的单位为秒，我们把host_dmax的值修改为7天，就是60x60x24x7=604800，即超过7天未汇报数据的节点会从前端清除。
书签Ganglia_简述
ubuntu14.04系统中安装Ganglia
Ganglia 监控实战！
gmetad.conf：gmetad配置文件（1）
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>监控</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>监控</tag>
        <tag>ganglia</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16使用Kolla安装OpenStack</title>
    <url>/dev-ubuntu16-kolla-openstack-all-in-one/</url>
    <content><![CDATA[前言完成了《Ubuntu16手动安装OpenStack——XXX》系列，看上去，我们已经总结出了一套不错的文档。遵照文档，理论上就能成功安装更多的机器。但是，设想是美好的，而在实际安装过程中，又出现很多莫名其妙的报错。有些错误可以解决，很好；有些错误解决不了，那么整个环境就废了，需要重装系统。而且，整个安装流程非常复杂，难以保证每一步都不出错。
于是，郝同学决定寻找更加通用、更加方便的方法。小伙子树添给出建议：能不能使用docker来进行部署？经过讨论和搜索资料，发现这条道路确实可行，而且有OpenStack官方文档。
本文，就来研究一下使用Kolla安装OpenStack Queens版本的方法，架构采用最简单的all-in-one。


Kolla简介Kolla是OpenStack社区“Big Tent”开发模式下的项目，该项目由思科于2014年9月提出。Kolla的优势和使用场景体现在如下几个方面：

原子性升级或者回退OpenStack部署。
基于组件升级OpenStack。
基于组件回退OpenStack。

Kolla为OpenStack的部署提供了有效、快捷、方便、易于维护、方便版本更新与回退的方案。
具体而言，Kolla的最终目标是为OpenStack的每一个服务都创建一个对应的Docker镜像，通过Docker镜像将升级的粒度减小到服务级别，从而在升级时对OpenStack的影响降到最小，并且一旦升级失败，也很容易回滚。升级只需要三步：拉取新版本的容器镜像，停止老版本的容器服务，启动新版本的容器。回滚也不需要重新安装包，直接启动老版本的容器服务就行，非常方便。
Kolla可以使用Ansible、Kubernetes或者Mesos来部署OpenStack环境，Kolla负责容器化OpenStack各个服务；后者则负责部署这些容器，搭建出一个可用的OpenStack环境。来实现基于Docker容器的OpenStack服务全生命周期管理，如安装、升级、回滚、迁移等。在部署Docker容器时，默认的网络配置都是Host模式。因为Kolla的Docker镜像粒度很小，它针对每个OpenStack服务都有特定的镜像，所以我们也可以通过Docker命令来操作某个具体的OpenStack服务。
Kolla项目及其相关的其他项目如下：

Kolla项目，负责docker build OpenStack每个服务，如nova-compute容器等；
Kolla-Ansible项目，使用Ansible部署这些容器，搭建OpenStack环境；
Kolla-Kubernetes项目，使用Kubernetes部署这些容器，搭建OpenStack环境；
Kolla-Mesos项目，使用Mesos部署这些容器，搭建OpenStack环境。

上述Kolla简介摘自微信分享DockOne微信分享（一二八）：容器化部署OpenStack的正确姿势。
环境VirtualBox虚拟机一台，系统为ubuntu-16.04.4-server-amd64，4核8G内存40G存储，主机名为controller，eth0的IP为192.168.56.110，eth1为nat上网网卡，eth2为neutron服务提供网络。
网络设置1、切换到root用户sudo -i
2、vim /etc/network/interfaces，设置网卡为：
# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto eth0iface eth0 inet staticaddress 192.168.56.110netmask 255.255.255.0auto eth1iface eth1 inet dhcpauto eth2iface eth2 inet manualup ifconfig $IFACE 0.0.0.0 upup ifconfig $IFACE promisc

3、启用网卡ifup eth2
安装配置主要参考OpenStack, Ansible, and Kolla on Ubuntu 16.04、kolla queens on centos7.4和Kolla-Ansible’s documentation!。
安装依赖1、安装并升级pip
apt-get updateapt-get install python-pippip install --upgrade pip

2、安装依赖apt-get -y install python-dev libffi-dev gcc libssl-dev python-selinux
3、安装ansibleapt-get -y install ansible
4、vim /etc/ansible/ansible.cfg，添加如下：
line 10, add[defaults]host_key_checking=Falsepipelining=Trueforks=100

安装docker1、安装dockercurl -SSL https://get.docker.io | bash
2、为docker和kolla创建配置文件
mkdir -p /etc/systemd/system/docker.service.dvim /etc/systemd/system/docker.service.d/kolla.conf

修改为：
[Service]MountFlags=shared

3、重启docker
systemctl daemon-reloadsystemctl restart docker

4、查看docker信息docker info报错：
docker: Cannot connect to the Docker daemon. Is the docker daemon running on this host?.

5、重启dockersystemctl restart docker报错：
Failed to restart docker.service: Unit docker.service is not loaded properly: Invalid argument.See system logs and 'systemctl status docker.service' for details.

6、手动启动docker/usr/bin/dockerd报错：
INFO[0000] libcontainerd: new containerd process, pid: 7629 WARN[0000] containerd: low RLIMIT_NOFILE changing to max  current=1024 max=1048576FATA[0001] Error starting daemon: error initializing graphdriver: "/var/lib/docker" contains several valid graphdrivers: aufs, overlay2; Please cleanup or explicitly choose storage driver (-s &lt;DRIVER&gt;)

7、查看docker的aufs挂载情况并取消挂载
cat /proc/mounts | grep "docker"umount /var/lib/docker/aufs

8、删除/var/lib/docker/目录下的文件并重启docker
rm -rf /var/lib/docker/*systemctl start docker

9、再次查看docker信息docker info
加速镜像拉取参考Docker入门中的镜像加速器一节。
安装Kolla-ansible1、安装kolla-ansiblepip install kolla-ansible
报错：ImportError: cannot import name main，参考升级pip后出现ImportError: cannot import name main，编辑/usr/bin/pip文件，如下修改：
# line 9, changefrom pip import __main__if __name__ == '__main__':    sys.exit(__main__._main())

报红：oslo-config 6.4.0 has requirement PyYAML&gt;=3.12, but you’ll have pyyaml 3.11 which is incompatible.忽略。
2、拷贝globals.yml和passwords.yml到/etc/kolla目录cp -r /usr/local/share/kolla-ansible/etc_examples/kolla /etc/
3、拷贝all-in-one和multinode清单文件到当前目录cp /usr/local/share/kolla-ansible/ansible/inventory/* .
4、生成kolla密码kolla-genpwd我们部署中使用的密码存储在/etc/kolla/passwords.yml文件中。此文件中的所有密码都是空白的，必须手动填写或运行随机密码生成器。
配置globals.yml1、查看globals.yml配置grep -vE &#39;^$|^#&#39; /etc/kolla/globals.yml
2、vim /etc/kolla/globals.yml，如下修改：
# line 15,uncommentkolla_base_distro: "centos"# line 18,uncommentkolla_install_type: "binary"# line 21,uncomment and changeopenstack_release: "queens"# line 31,changekolla_internal_vip_address: "192.168.56.120"# line 85,uncomment and changenetwork_interface: "eth0"# line 100,uncomment and changeneutron_external_interface: "eth2"# line 331,uncommentdesignate_backend: "bind9"designate_ns_record: "sample.openstack.org"# line 340,uncomment and changenova_compute_virt_type: "qemu"# othertempest_image_id:tempest_flavor_ref_id:tempest_public_network_id:tempest_floating_network_name:

kolla_internal_vip_address为192.168.56.120，它是一个和OpenStack宿主机内网连接网络（eth0 192.168.56.110）同一个网段的未使用IP。network_interface为eth0，意思是openstack内部网络使用eth0网卡。neutron_external_interface为eth2，意思是openstack的虚拟机外部网络使用eth2网卡。因为是在虚拟机中安装openstack，所以nova_compute_virt_type设置为qemu。
部署1、初始化kolla-ansible -i ./all-in-one bootstrap-servers报错：查找资料，猜测是ansible版本问题。（1）ansible --version，查看ansible版本为2.0.0.2，确实非常低。（2）apt install ansible，提示已经是最新版本。（3）更新apt库，然后重装ansible
apt-get install software-properties-commonapt-add-repository ppa:ansible/ansibleapt-get updateapt-get install ansible
然后，重新编辑/etc/ansible/ansible.cfg，再次执行初始化命令，问题解决。时间比较久，请耐心等待。
2、预检查kolla-ansible -i ./all-in-one prechecks
3、拉取镜像kolla-ansible -i ./all-in-one pull这一步的时间特别久，挺耐心等待。如果拉取失败，就多尝试几次。
4、查看镜像docker images
5、部署kolla-ansible -i ./all-in-one deploy
测试使用openstack1、安装openstack客户端pip install python-openstackclient python-glanceclient python-neutronclient --ignore-installed
2、生成admin-openrc.sh等kolla-ansible post-deploy
3、使admin环境生效source /etc/kolla/admin-openrc.sh
4、查看计算服务openstack compute service list
初始化配置1、执行init-runonce脚本. /usr/local/share/kolla-ansible/init-runonce执行初始化之前，可以参考openstack 之 Kolla部署指南，设置一下外部网络。这样，就可以从路由器给虚拟机分配IP，安装完虚拟机就可以宿主机互相ping通。比如：
EXT_NET_CIDR='192.168.56.0/24'EXT_NET_RANGE='start=192.168.56.200,end=192.168.56.240'EXT_NET_GATEWAY='192.168.56.1'
这里配置的网络范围，对应globals.yml中配置的neutron_external_interface，也就是eth2网卡。
2、根据提示，创建实例
openstack server create \--image cirros \--flavor m1.tiny \--key-name mykey \--nic net-id=e52fe099-c798-4ffd-8c3c-06de424a9de7 \demo1

3、访问horizon服务curl 192.168.56.120 -L
在浏览器访问 http://192.168.56.120 ，使用admin账号登录，密码在passwords.yml文件中查看。less /etc/kolla/passwords.yml | grep keystone_admin_password
后记至此，使用kolla安装openstack成功。但是，我们还不知道实例能否正常使用。关于实例的访问和网络配置，放在下一篇文章中研究。
书签Kolla’s documentation!
Kolla让OpenStack部署更贴心
Kolla安装Ocata单节点
kolla部署openstack ocata版
Install and configure OpenStack Ocata with Kolla as a standalone
Kolla OpenStack系统视频课程
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ansible</tag>
        <tag>openstack</tag>
        <tag>kolla</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——cinder篇</title>
    <url>/dev-ubuntu16-manual-openstack-cinder/</url>
    <content><![CDATA[目标在《Ubuntu16手动安装OpenStack——修改镜像》一文中，我们通过修改镜像，实现了ssh密码访问实例。看上去，这个openstack系统已经可以投入使用了，实际上，也确实可以投入使用了。
但是，我们总是追求更好更多的服务。所以接下来，我们继续安装openstack的服务组件。本文中要安装配置的是cinder，主要参考OpenStack Queens : Configure Cinder和Cinder Installation Guide。


cinder简介块存储服务（cinder）为用户实例提供块存储设备。配置和使用存储的方法由块存储驱动程序确定，或者在多后端配置的情况下由驱动程序确定。有多种驱动程序可用：NAS / SAN，NFS，iSCSI，Ceph等。Block Storage API和调度程序服务通常在控制器节点上运行。根据所使用的驱动程序，卷服务可以在控制器节点，计算节点或独立存储节点上运行。
控制节点root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
数据库1、登录数据库mysql -uroot -p，密码为openstack。
2、创建cinder数据库create database cinder;
3、授权
grant all privileges on cinder.* to cinder@'localhost' identified by 'openstack';grant all privileges on cinder.* to cinder@'%' identified by 'openstack';

4、退出数据库flush privileges;
exit;
证书和端点1、使admin环境生效. admin-openrc
2、创建cinder用户，密码为openstackopenstack user create --domain default --project service --password openstack cinder
3、给cinder用户添加admin角色openstack role add --project service --user cinder admin
4、创建cinder服务
openstack service create --name cinderv2 --description "OpenStack Block Storage" volumev2openstack service create --name cinderv3 --description "OpenStack Block Storage" volumev3

5、创建cinder服务端点
openstack endpoint create --region RegionOne volumev2 public http://controller:8776/v2/%\(project_id\)sopenstack endpoint create --region RegionOne volumev2 internal http://controller:8776/v2/%\(project_id\)sopenstack endpoint create --region RegionOne volumev2 admin http://controller:8776/v2/%\(project_id\)sopenstack endpoint create --region RegionOne volumev3 public http://controller:8776/v3/%\(project_id\)s openstack endpoint create --region RegionOne volumev3 internal http://controller:8776/v3/%\(project_id\)s openstack endpoint create --region RegionOne volumev3 admin http://controller:8776/v3/%\(project_id\)s

安装配置1、下载安装组件apt-get -y install cinder-api cinder-scheduler python-cinderclient
2、备份cinder.confmv /etc/cinder/cinder.conf /etc/cinder/cinder.conf.bak
3、vi /etc/cinder/cinder.conf，新建cinder.conf内容为：
# create new[DEFAULT]# define own IP addressmy_ip = 172.16.0.105rootwrap_config = /etc/cinder/rootwrap.confapi_paste_confg = /etc/cinder/api-paste.inistate_path = /var/lib/cinderauth_strategy = keystone# RabbitMQ connection infotransport_url = rabbit://openstack:openstack@controller# MariaDB connection info[database]connection = mysql+pymysql://cinder:openstack@controller/cinder# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = cinderpassword = openstack[oslo_concurrency]lock_path = $state_path/tmp

4、更改权限chmod 644 /etc/cinder/cinder.conf
chown root:cinder /etc/cinder/cinder.conf
5、生成数据库数据su -s /bin/bash cinder -c &quot;cinder-manage db sync&quot;
6、重启cinder-schedulersystemctl restart cinder-scheduler
7、查看volumeopenstack volume service list
存储节点本文中，我们的存储节点和计算节点在同一个节点，该节点的IP为172.16.0.106。已经安装的服务和virtualbox计算节点（192.168.56.111）相同，包括nova-compute和neutron。
root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
安装配置1、安装cinder-volumeapt-get -y install cinder-volume python-mysqldb
2、备份cinder.confmv /etc/cinder/cinder.conf /etc/cinder/cinder.conf.bak
3、vi /etc/cinder/cinder.conf，新建cinder.conf内容为：
# create new[DEFAULT]# define own IP addressmy_ip = 172.16.0.106rootwrap_config = /etc/cinder/rootwrap.confapi_paste_confg = /etc/cinder/api-paste.inistate_path = /var/lib/cinderauth_strategy = keystone# RabbitMQ connection infotransport_url = rabbit://openstack:openstack@controller# Glance connection infoglance_api_servers = http://controller:9292# OK with empty value nowenabled_backends =# MariaDB connection info[database]connection = mysql+pymysql://cinder:openstack@controller/cinder# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = cinderpassword = openstack[oslo_concurrency]lock_path = $state_path/tmp

4、更改权限chmod 644 /etc/cinder/cinder.conf
chown root:cinder /etc/cinder/cinder.conf
5、重启cinder-volumesystemctl restart cinder-volume
使用lvm卷存储节点1、在存储节点添加硬盘，保证至少有两块硬盘。
2、创建物理卷ll /dev/sd*
pvcreate /dev/sdb
3、创建volume groupvgcreate -s 32M vg_volume01 /dev/sdb
4、安装lvm相关组件apt-get -y install tgt thin-provisioning-tools
5、vi /etc/cinder/cinder.conf，如下修改cinder.conf：
# add a value for enabled_backendsenabled_backends = lvm# add follows to the end[lvm]iscsi_helper = tgtadm# volume group name just createdvolume_group = vg_volume01# IP address of Storage Nodeiscsi_ip_address = 172.16.0.106volume_driver = cinder.volume.drivers.lvm.LVMVolumeDrivervolumes_dir = $state_path/volumesiscsi_protocol = iscsi

6、重启服务systemctl restart cinder-volume tgt
计算节点1、vi /etc/nova/nova.conf，编辑nova.conf文件：
# add to the end[cinder]os_region_name = RegionOne

2、重启compute服务systemctl restart nova-compute
控制节点以上，已经准备好了cinder服务，我们在控制节点使用cinder服务（也可以在其他机器使用）。
1、假设我们已经按照《Ubuntu16手动安装OpenStack——创建实例》一文，创建了一个cirros0实例，ip为10.0.0.206。
2、登录cirros0ssh cirros@10.0.0.206，密码默认为gocubsgo。
3、在cirros0中查看硬盘df -h
ls -l /dev/vd*
sudo fdisk -l
可以看到，当前虚拟机只有一块vda硬盘。
4、控制节点中修改voidking用户环境，并使环境生效echo &quot;export OS_VOLUME_API_VERSION=2&quot; &gt;&gt; ~/voidkingrc
. voidkingrc
5、创建卷disk01，大小为1Gopenstack volume create --size 1 disk01
6、查看卷openstack volume list
7、把卷disk01添加给cirros0实例openstack server list
openstack server add volume cirros0 disk01
8、在cirros0中查看硬盘ls -l /dev/vd*
发现cirros0中多出了一块硬盘vdb。
9、在控制节点查看卷openstack volume list显示disk01已经attach到了cirros0的/dev/vdb，和我们在cirros0中看到的结果一致。
10、移除卷openstack server remove volume cirros0 disk01
后记关于NFS（网络文件系统）的使用，参考OpenStack Queens : Use Cinder Storage (NFS)。
关于LVM和NFS格式卷的混合使用，参考OpenStack Queens : Use Cinder Storage (Multi-BackEnds)。
关于使用cinder备份卷，参考OpenStack Queens : Configure Cinder Backup。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——环境篇</title>
    <url>/dev-ubuntu16-manual-openstack-env/</url>
    <content><![CDATA[前言《Ubuntu16安装OpenStack》一文中，使用devstack在物理机上安装了OpenStack的Queens版本。但是，在后来的《OpenStack添加镜像》实验中，遇到了很多奇怪的问题，遂决定重装OpenStack。
本次安装，计划采用一步步手动安装的方式，在两个节点上，最小安装OpenStack的Queens版本。主要参考OpenStack Queens Installation Guides，首先配置环境，然后安装必要的组件，包括keystone、glance、nova、neutron。再之后，选择安装horizon、cinder和swift。
本文，就记录一下配置环境的过程。


准备本次安装使用两台VirtualBox虚拟机，一个控制节点和一个计算节点，系统均为ubuntu-16.04.4-server-amd64。控制节点1核4G内存40G存储，计算节点1核2G内存40G存储。
这两台虚拟机，都有三块网卡。eth0负责主机间相互通信，eth1负责上网，eth2负责neutron网络服务。两张eth0网卡在同一网络，两张eth2网卡在同一网络。
IP配置参考VirtualBox下CentOS7和Ubuntu16.04网络配置，修改网卡名，然后配置静态IP。控制节点eth0配置为192.168.56.110，计算节点eth0配置为192.168.56.111。
主机名配置参考VirtualBox下CentOS7和Ubuntu16.04网络配置，配置控制节点主机名为controller，计算节点主机名为compute。
然后编辑/etc/hosts，添加：
192.168.56.110  controller192.168.56.111  compute

设置sudo免密编辑sudoers，vim /etc/sudoers在最后添加一行：
test ALL = NOPASSWD: ALL

更换源列表修改/etc/apt/sources.list，参考Ubuntu更换源列表，更换为Ubuntu官方中国的源列表。
最后重启主机，sudo reboot。
root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
环境在安装openstack之前，需要先安装好必须的环境，包括：

Security
Host networking
Network Time Protocol (NTP)
OpenStack packages
SQL database
Message queue
Memcached
Etcd

安装方法参考Environment。
SecurityOpenStack服务支持各种安全方法，包括密码，策略和加密。
本节没有什么安装操作，过。
Host networking在选择部署的体系结构的每个节点上安装操作系统后，必须配置网络接口。openstack官方建议禁用任何自动网络管理工具，并手动编辑网络配置文件。
本文准备工作中已经配置好了IP，过。
NTPNTP服务主要用来各节点之间同步时间。
控制节点1、安装chronyapt -y install chrony
2、配置chronyvim /etc/chrony/chrony.conf
取消两处注释：
allow 0/0allow ::/0

3、重启chronyservice chrony restart
计算节点1、安装chronyapt -y install chrony
2、配置chronyvim /etc/chrony/chrony.conf注释修改如下：
#pool 2.debian.pool.ntp.org offline iburstserver controller iburst

3、重启chronyservice chrony restart
验证安装官方建议在继续操作之前验证NTP同步。某些节点，尤其是那些引用控制器节点的节点，可能需要几分钟才能同步。1、在控制节点执行chronyc sources
“Name/IP”列中的内容表示NTP服务器的主机名或IP地址。MS列中的内容，*代表当前NTP服务器同步成功。
2、在计算节点执行chronyc sources“Name/IP”列中的内容应该表示控制器节点的主机名。
OpenStack packages由于发布计划不同，发行版将OpenStack软件包作为发行版的一部分或使用其他方法发布。在所有节点上执行这些操作。
1、安装openstack queens仓库apt install software-properties-common
add-apt-repository cloud-archive:queens
2、更新软件包apt update &amp;&amp; apt dist-upgrade
3、安装openstack-clientapt -y install python-openstackclient
SQL database大多数OpenStack服务使用SQL数据库来存储信息，数据库通常在控制器节点上运行。本文使用MariaDB（MySQL），OpenStack服务还支持其他SQL数据库，包括PostgreSQL。
1、安装mariadb和连接工具apt -y install mariadb-server python-pymysql
2、编辑50-server.cnfvim /etc/mysql/mariadb.conf.d/50-server.cnf
命令模式下输入:set nu显示行号：
# line 29: changebind-address = 0.0.0.0# line 105: changecharacter-set-server = utf8 #collation-server = utf8mb4_general_ci

3、重启mariadb关闭mariadb，service mysql stop。然后查看netstat -an | grep 3306，确认3306已经关闭。
启动mariadb，service mysql start。
4、设置mariadb密码mysql_secure_installation
按照提示设置密码为openstack。如果设置后无法登录，那么参考MySQL重置密码。
Message queueOpenStack使用消息队列来协调服务之间的操作和状态信息。消息队列服务通常在控制器节点上运行。OpenStack支持多种消息队列服务，包括RabbitMQ，Qpid和ZeroMQ。这里我们安装RabbitMQ，因为大多数发行版都支持它。
1、安装rabbitmsqapt -y install rabbitmq-server
2、创建openstack用户，密码为openstackrabbitmqctl add_user openstack openstack
3、允许openstack用户配置和读写rabbitmqctl set_permissions openstack &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;
MemcachedOpenStack的各个服务的身份认证服务使用Memcached缓存令牌。memcached服务通常在控制器节点上运行。对于生产部署，我们建议启用防火墙，身份验证和加密的组合来保护它。
1、安装memcachedapt -y install memcached python-memcache
2、编辑/etc/memcached.conf文件-l 127.0.0.1修改为-l 0.0.0.0
3、重启memcachedservice memcached restart
4、测试
telnet controller 11211statsquit

EtcdOpenStack服务可能使用Etcd，它是一个可靠的分布式键值存储工具。用于分布式密钥锁定，存储配置，跟踪服务的实时性等。同样安装在控制节点即可。
1、安装etcdapt -y install etcd
2、查看版本etcd -version，这里看到是2.2.5。按照Etcd for Ubuntu文档配置的话，最终会失败，所以，我们换一种配置方法。
3、查看服务状态etcdctl member list
应该会看到：
ce2a822cea30bfca: name=controller peerURLs=http://localhost:2380,http://localhost:7001 clientURLs=http://localhost:2379,http://localhost:4001

4、官方文档给出的/etc/etcd/etcd.conf.yml文件内容为：
name: controllerdata-dir: /var/lib/etcdinitial-cluster-state: 'new'initial-cluster-token: 'etcd-cluster-01'initial-cluster: controller=http://controller:2380initial-advertise-peer-urls: http://controller:2380advertise-client-urls: http://controller:2379listen-peer-urls: http://0.0.0.0:2380listen-client-urls: http://controller:2379

参考etcd.conf.yml，我们在/etc/default/etcd的最后添加：
ETCD_NAME="controller"ETCD_DATA_DIR="/var/lib/etcd/default"ETCD_INITIAL_CLUSTER_STATE="new"ETCD_INITIAL_CLUSTER_TOKEN="etcd-cluster-01"ETCD_INITIAL_CLUSTER="controller=http://controller:2380"ETCD_INITIAL_ADVERTISE_PEER_URLS="http://controller:2380"ETCD_ADVERTISE_CLIENT_URLS="http://controller:2379,http://127.0.0.1:2379"ETCD_LISTEN_PEER_URLS="http://0.0.0.0:2380"ETCD_LISTEN_CLIENT_URLS="http://controller:2379,http://127.0.0.1:2379"

5、设置开机启动systemctl enable etcd
6、重启etcdsystemctl restart etcd
7、查看服务状态etcdctl member list
会看到发生了变化：
ce2a822cea30bfca: name=controller peerURLs=http://localhost:2380,http://localhost:7001 clientURLs=http://127.0.0.1:2379,http://controller:2379

8、在控制节点和计算节点测试curl http://controller:2379/v2/stats/leader
可以看到：
&#123;"leader":"ce2a822cea30bfca","followers":&#123;&#125;&#125;

后记如果修改了/etc/hosts中的controller对应的IP，那么需要重启memcached和etcd，因为它们的配置中使用了主机名而不是IP。
至此，两台虚拟机上，openstack需要的环境已经安装完成。接下来，准备安装keystone。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——创建实例</title>
    <url>/dev-ubuntu16-manual-openstack-instance/</url>
    <content><![CDATA[目标完成了《Ubuntu16手动安装OpenStack——neutron篇》，意味着keystone、glance、nova和neutron都已经安装完成，也就是说，openstack最小安装已经完成。在安装horizon、cinder和swift之前，我们先来通过命令行创建一个实例，验证一下之前的安装。
主要参考OpenStack Queens : Add Users、OpenStack Queens : Add Users 和 OpenStack Queens : Boot Instances。


说明本文操作全部都是在控制节点。为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
网卡配置参考Openstack的网卡设置和和OpenStack Networking Tutorial: Single-host FlatDHCPManager，配置eth2网卡。
1、查看当前网络，ip add
route -n，brctl show
2、vim /etc/network/interfaces，添加：
auto eth2iface eth2 inet manual  up ifconfig $IFACE 0.0.0.0 up  up ifconfig $IFACE promisc#iface eth2 inet manual#up ifconfig eth2 up

3、启用网卡，ifup eth2
创建子网1、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 181: add[ml2_type_flat]flat_networks = physnet1

2、vi /etc/neutron/plugins/ml2/linuxbridge_agent.ini，如下修改：
# line 147: add[linux_bridge]physical_interface_mappings = physnet1:eth2# line 208: uncomment and changeenable_vxlan = false

3、重启neutron-linuxbridge-agentsystemctl restart neutron-linuxbridge-agent
4、获取projectID. admin-openrc
projectID=$(openstack project list | grep service | awk &#39;{print $2}&#39;)
5、创建名为sharednet1的网络
openstack network create --project $projectID \--share --provider-network-type flat --provider-physical-network physnet1 sharednet1

6、在sharednet1中创建子网10.0.0.0/24
openstack subnet create subnet1 --network sharednet1 \--project $projectID --subnet-range 10.0.0.0/24 \--allocation-pool start=10.0.0.200,end=10.0.0.254 \--gateway 10.0.0.1 --dns-nameserver 10.0.0.10

7、查看网络openstack network list
openstack subnet list

添加用户首先使admin环境生效，. admin-openrc。
1、添加siat项目openstack project create --domain default --description &quot;SIAT Project&quot; siat
2、添加voidking用户，密码为openstackopenstack user create --domain default --project siat --password openstack voidking
3、添加clouduser角色openstack role create clouduser
4、给voidking用户添加clouduser角色openstack role add --project siat --user voidking clouduser
5、因为cirros需要的资源很少，所以创建一个类型模板m1.tinyopenstack flavor create --id 0 --vcpus 1 --ram 256 --disk 5 m1.tiny
创建实例环境准备1、vi ~/voidkingrc，创建voidking环境脚本，内容如下：
export OS_PROJECT_DOMAIN_NAME=defaultexport OS_USER_DOMAIN_NAME=defaultexport OS_PROJECT_NAME=siatexport OS_USERNAME=voidkingexport OS_PASSWORD=openstackexport OS_AUTH_URL=http://controller:5000/v3export OS_IDENTITY_API_VERSION=3export OS_IMAGE_API_VERSION=2export PS1='\u@\h \W(keystone)\$ '

2、使环境生效. voidkingrc
3、查看类型模板openstack flavor list
4、查看可用镜像openstack image list
5、查看可用网络openstack network list
6、创建安全组openstack security group create secgroup01

7、查看安全组openstack security group list
8、创建ssh密钥ssh-keygen -q -N &quot;&quot;
密钥文件保存在/home/root/.ssh/目录下。
9、添加公钥openstack keypair create --public-key ~/.ssh/id_rsa.pub vkkey
10、查看公钥openstack keypair list
创建实例1、给netID赋值netID=$(openstack network list | grep sharednet1 | awk &#39;{ print $2 }&#39;)
2、创建实例
openstack server create --flavor m1.tiny \--image cirros --security-group secgroup01 \--nic net-id=$netID --key-name vkkey cirros0

3、查看实例openstack server list
如上图，已经成功启动实例，ip为10.0.0.206，nice。
PS：删除实例命令，openstack server delete cirros0
访问实例配置安全组的安全设置，以便使用SSH和ICMP进行访问。
1、设置允许ICMPopenstack security group rule create --protocol icmp --ingress secgroup01
2、设置允许sshopenstack security group rule create --protocol tcp --dst-port 22:22 secgroup01
3、查看安全组规则openstack security group rule list
4、访问测试ping 10.0.0.206 -c3
ping不通，看来网络出了问题，等会再解决这个问题。
5、查看vnc的url，并复制该urlopenstack console url show cirros0
6、url中的controller替换为192.168.56.110，在浏览器中打开
顺利访问，可以看到，cirros0的ip为192.168.56.102，难怪10.0.0.206无法ping通。
控制节点上，ping 192.168.56.102，依然不通。vnc中，ping 192.168.56.110，也不通。
网络问题网桥支持Configure the Linux bridge agent一节中，提到过要启用网桥支持，那就启用网桥试试。
1、查看ip转发cat /proc/sys/net/ipv4/ip_forward如果值为0，那么改为1。
2、启用网桥支持vim /etc/sysctl.conf，添加
net.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1

3、使配置生效sysctl -p
修改后，依然无法ping通10.0.0.206。
网卡配置1、查看ipip add如上图，和本文开始时相比，多了三个接口。
2、查看网桥brctl show
3、vim /etc/network/interfaces，添加
auto brqedda68f7-72iface brqedda68f7-72 inet staticaddress 10.0.0.1netmask 255.255.255.0bridge_stp offbridge_fd 0

然后启用brqedda68f7-72端口，ifup brqedda68f7-72
或者不配置interfaces，直接执行ifconfig brqedda68f7-72 10.0.0.1/24 up
5、查看网络ip add
route -n

不过，依然无法ping通10.0.0.206。毕竟，cirros0的ip不是10.0.0.206，而是192.168.56.102。这个ip，明显是通过VirtualBox分配的，和虚拟机在同一个网段。
修改ip既然cirros0的ip不对，那就给它手动修改一下，好主意。1、通过vnc登录cirros0
2、sudo vi /etc/network/interfaces，修改eth0的配置为：
auto eth0iface eth0 inet staticaddress 10.0.0.206netmask 255.255.255.0

3、重启eth0sudo ifdown eth0
sudo ifup eth0
4、在控制节点测试连接ping 10.0.0.206 -c3
至此，问题解决。
访问实例1、cirros当前只支持密码访问：ssh cirros@10.0.0.206，输入密码gocubsgo。
登录后执行ls .ssh，并没有authorized_keys文件，看来创建实例时并没有注入密钥，不知道什么原因。
2、在控制节点，添加密钥到cirros0ssh-copy-id -i .ssh/id_rsa.pub -p 22 cirros@10.0.0.206
3、用密钥测试登录ssh cirros@10.0.0.206 -i .ssh/id_rsa
登录成功。
4、如果重启了控制节点，那么需要手动启动cirros0openstack server start cirros0
5、vnc的token也会改变，所以要重新获取openstack console url show cirros0
后记至此，已经完成了吗？想到一些问题：

cirros0理论上应该通过浮动ip进行访问，我们这种直接访问是闹哪样？
以后每次创建实例，都要通过vnc重新配置ip？
以后每次创建实例，都要手动添加密钥？

也许是因为VirtualBox网卡分配不对，也许是因为在虚拟机中安装，也许是因为控制节点网络配置不对。。。不管了，反正创建实例完成，其他问题放在以后的文章中解决。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——keystone篇</title>
    <url>/dev-ubuntu16-manual-openstack-keystone/</url>
    <content><![CDATA[目标紧接着《Ubuntu16手动安装OpenStack——环境篇》，本文我们来安装keystone，主要参考Keystone Installation Tutorial for Ubuntu。


keystone简介OpenStack身份识别服务集成了身份验证，授权和服务目录。
身份服务通常是用户与之交互的第一个服务。一旦通过身份验证，终端用户就可以使用他们的身份访问其他OpenStack服务。同样，其他OpenStack服务利用身份服务来确保用户是他们所说的人，并发现其他服务的位置。身份识别服务还可以与一些外部用户管理系统（如LDAP）集成。
用户和服务可以通过使用由身份服务管理的服务目录来定位其他服务。顾名思义，服务目录是OpenStack部署中可用服务的集合。每个服务可以有一个或多个端点，每个端点可以是以下三种类型之一：admin，internal或public。在生产环境中，出于安全原因，不同类型的终端类型可能会驻留在暴露给不同类型用户的单独网络中。例如，公共API网络可能从互联网上可见，因此客户可以管理他们的云。管理API网络可能仅限于管理云基础架构的组织中的运营商。内部API网络可能仅限于包含OpenStack服务的主机。另外，OpenStack支持多个区域的可伸缩性。为简单起见，本指南针对所有端点类型和默认的RegionOne区域使用管理网络。在身份服务中创建的区域，服务和端点一起构成部署的服务目录。部署中的每个OpenStack服务都需要一个服务条目，并在Identity服务中存储相应的端点。这可以在Identity Service安装和配置完成后完成。
身份服务包含以下组件：服务器集中式服务器使用RESTful接口提供认证和授权服务。
驱动程序驱动程序或服务后端集成到中央服务器。它们用于访问OpenStack外部存储库中的身份信息，并且可能已存在于部署OpenStack的基础架构中（例如，SQL数据库或LDAP服务器）。
模块中间件模块运行在使用Identity服务的OpenStack组件的地址空间中。这些模块拦截服务请求，提取用户凭据并将其发送到中央服务器进行授权。中间件模块和OpenStack组件之间的集成使用Python Web服务器网关接口。
安装记录本节记录如何在控制节点上安装和配置代号为keystone的OpenStack Identity服务。出于可伸缩性的目的，此配置会部署Fernet令牌和Apache HTTP服务器来处理请求。
root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
数据库配置1、登录mariadbmysql -uroot -p，密码为openstack。
2、创建keystone数据库CREATE DATABASE keystone;
3、创建keystone用户，密码为openstack，并授权访问keystone数据库GRANT ALL PRIVILEGES ON keystone.* TO &#39;keystone&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;openstack&#39;;
GRANT ALL PRIVILEGES ON keystone.* TO &#39;keystone&#39;@&#39;%&#39; IDENTIFIED BY &#39;openstack&#39;;
4、退出exit;
5、测试登录
mysql -h localhost -ukeystone -p
mysql -h controller -ukeystone -p
安装组件1、安装keystone、apache2和libapache2-mod-wsgiapt -y install keystone  apache2 libapache2-mod-wsgi
2、vim /etc/keystone/keystone.conf编辑配置：
# line 606: uncomment and specify Memcache Servermemcache_servers = controller:11211# line 740: change ( MariaDB connection info )connection = mysql+pymysql://keystone:openstack@controller/keystone# line 2891: add[token]provider = fernet

3、生成keystone数据库的数据
su -s /bin/bash keystone -c &quot;keystone-manage db_sync&quot;
（非root用户执行sudo keystone-manage db_sync）
查看日志：tail /var/log/keystone/keystone-manage.log，看到done说明执行成功。
不放心的话，可以登录mariadb查看keystone数据库的数据，有数据的话说明执行成功。
如果在日志中看到报错：
2018-06-30 18:37:40.845 4964 WARNING oslo_db.sqlalchemy.engines [-] SQL connection failed. 6 attempts left.: DBConnectionError: (pymysql.err.OperationalError) (2003, "Can't connect to MySQL server on 'controller' ([Errno 111] Connection refused)") (Background on this error at: http://sqlalche.me/e/e3q8)

这是因为，mysql可能绑定了IP。执行netstat -an | grep 3306查看，如果只看到127.0.0.1，那么说明确实绑定了IP。
解决办法是编辑50-server.cnf，把bind-address = 127.0.0.1注释掉，然后重启mariadb，重新执行命令。
4、初始化Fernet密钥存储库keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone
keystone-manage credential_setup --keystone-user keystone --keystone-group keystone
5、引导身份服务，管理密码为openstack
keystone-manage bootstrap --bootstrap-password openstack \  --bootstrap-admin-url http://controller:5000/v3/ \  --bootstrap-internal-url http://controller:5000/v3/ \  --bootstrap-public-url http://controller:5000/v3/ \  --bootstrap-region-id RegionOne


配置apache1、vim /etc/apache2/apache2.conf，添加：
# line 70: specify server nameServerName controller

2、重启apacheservice apache2 restart
3、新建环境变量配置keystonerc
export OS_USERNAME=adminexport OS_PASSWORD=openstackexport OS_PROJECT_NAME=adminexport OS_USER_DOMAIN_NAME=Defaultexport OS_PROJECT_DOMAIN_NAME=Defaultexport OS_AUTH_URL=http://controller:5000/v3export OS_IDENTITY_API_VERSION=3

4、使环境变量生效source keystonerc
5、测试echo $OS_USERNAME
使用记录创建域Identity服务为每个OpenStack服务提供身份验证服务。身份验证服务使用域，项目，用户和角色的组合。
1、引导身份服务步骤中已存在“默认”域，但创建新域的正式方法是：openstack domain create --description &quot;An Example Domain&quot; example
虚拟机中执行成功，但是实体机报错：
Failed to discover available identity versions when contacting http://controller:5000/v3. Attempting to parse version from URL.Internal Server Error (HTTP 500)

netstat -an | grep 5000，发现5000端口服务已经启动。
查看keystone日志，没有新的内容，说明根本没有连接成功。
尝试了重新导入数据，重新安装数据库，都失败了。
如果看到同样的错误，那么极有可能之前安装devstack遗留的问题，最终重装系统后再次安装，执行成功。
2、在default域下创建service项目：openstack project create --domain default --description &quot;Service Project&quot; service
3、常规（非管理员）任务应使用非特权项目和用户。创建demo项目：openstack project create --domain default --description &quot;Demo Project&quot; demo
4、创建demo用户：openstack user create --domain default --password-prompt demo
按照提示设置密码为openstack。
5、创建user角色：openstack role create user
6、将user角色添加到demo项目和demo用户openstack role add --project demo --user demo user
7、查看域、项目、角色、用户
openstack domain listopenstack project listopenstack role listopenstack user list

验证操作在安装其他服务之前验证Identity服务的操作。
1、取消设置临时OS_AUTH_URL和OS_PASSWORD环境变量：unset OS_AUTH_URL OS_PASSWORD
2、作为admin用户，请求身份验证令牌：
openstack --os-auth-url http://controller:5000/v3 \  --os-project-domain-name Default --os-user-domain-name Default \  --os-project-name admin --os-username admin token issue

按照提示输入密码openstack。
3、作为demo用户，请求身份验证令牌：
openstack --os-auth-url http://controller:5000/v3 \  --os-project-domain-name Default --os-user-domain-name Default \  --os-project-name demo --os-username demo token issue

按照提示输入密码openstack。
创建OpenStack客户端环境脚本前面几节使用了环境变量和命令选项的组合，通过openstack客户端与Identity服务进行交互。为了提高客户端操作的效率，OpenStack支持简单的客户端环境脚本，也称为OpenRC文件。这些脚本通常包含所有客户端的常用选项，但也支持独特的选项。
创建脚本为admin和demo项目和用户创建客户端环境脚本。接下来引用这些脚本来加载客户端操作的适当凭据。这些脚本在控制节点和计算节点都适用。
1、创建并编辑admin-openrc文件并添加以下内容：
export OS_PROJECT_DOMAIN_NAME=Defaultexport OS_USER_DOMAIN_NAME=Defaultexport OS_PROJECT_NAME=adminexport OS_USERNAME=adminexport OS_PASSWORD=openstackexport OS_AUTH_URL=http://controller:5000/v3export OS_IDENTITY_API_VERSION=3export OS_IMAGE_API_VERSION=2

2、创建并编辑demo-openrc文件并添加以下内容：
export OS_PROJECT_DOMAIN_NAME=Defaultexport OS_USER_DOMAIN_NAME=Defaultexport OS_PROJECT_NAME=demoexport OS_USERNAME=demoexport OS_PASSWORD=openstackexport OS_AUTH_URL=http://controller:5000/v3export OS_IDENTITY_API_VERSION=3export OS_IMAGE_API_VERSION=2

使用脚本要将客户端作为特定项目和用户运行，只需在运行它们之前加载关联的客户端环境脚本即可。例如：
1、加载admin-openrc文件以使用Identity服务的位置以及管理项目和用户凭据填充环境变量：. admin-openrc或者source admin-openrc
2、请求身份验证令牌：openstack token issue


]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——neutron篇</title>
    <url>/dev-ubuntu16-manual-openstack-neutron/</url>
    <content><![CDATA[目标紧接着《Ubuntu16手动安装OpenStack——nova篇》，本文我们来安装neutron，主要参考Networking service、Install and configure for Ubuntu和OpenStack Queens : Configure Neutron。


neutron简介OpenStack Networking（neutron）允许用户创建和连接接口设备，这些设备由其他OpenStack服务管理并连入网络。可以实现插件以适应不同的网络设备和软件，为OpenStack架构和部署提供灵活性。
它包括以下组件：neutron-server接受API请求，并将请求通过路由找到适当的OpenStack Networking插件以进行操作。
OpenStack Networking plug-ins and agents插拔端口，创建网络或子网，并提供IP寻址。这些插件和代理程序因特定云中使用的供应商和技术而异。OpenStack Networking附带了很多插件和代理，可以用于思科虚拟和物理交换机，NEC OpenFlow产品，Open vSwitch，Linux桥接和VMware NSX产品。
公共代理是L3（第3层），DHCP（动态主机IP寻址）和插件代理。
Messaging queue大多数OpenStack Networking安装使用messaging queue，在neutron-server和各种代理之间传递信息。还用于存储特定插件的网络状态，算是一个数据库。
OpenStack Networking主要与OpenStack Compute交互，为其实例提供网络和连接。
更多信息请参考Networking (neutron) concepts。
主机网络在每个节点上安装操作系统后，必须配置网络接口。官方建议禁用任何自动网络管理工具，并手动编辑配置文件。有关如何配置网络的详细信息，请参阅文档。
出于管理目的，所有节点都需要Internet访问，例如程序包安装，安全更新，域名系统（DNS）和网络时间协议（NTP）。在大多数情况下，节点应通过管理网络接口获得Internet访问。为了突出网络分离的重要性，示例体系结构使用专用地址空间用于管理网络，并假设物理网络基础结构通过网络地址转换（NAT）或其他方法提供Internet访问。
在provider网络架构中，所有实例都直接连接到provider网络。在私网体系结构中，实例可以连接到一个私网或多个私网。私网可以完全属于OpenStack，不接入外网；也可以通过provider网络接入外部网络。


控制节点root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
数据库1、登录数据库mysql -uroot -p，密码为openstack。
2、创建neutron数据库CREATE DATABASE neutron;
3、授权
GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'localhost' IDENTIFIED BY 'openstack';GRANT ALL PRIVILEGES ON neutron.* TO 'neutron'@'%' IDENTIFIED BY 'openstack';

4、退出数据库exit;
证书和端点1、使admin环境生效. admin-openrc
2、创建neutron用户openstack user create --domain default --password-prompt neutron
根据提示设置密码为openstack。
3、添加admin角色给neutron用户openstack role add --project service --user neutron admin
4、创建neutron服务实体openstack service create --name neutron --description &quot;OpenStack Networking&quot; network
5、创建网络服务端点
openstack endpoint create --region RegionOne network public http://controller:9696openstack endpoint create --region RegionOne network internal http://controller:9696openstack endpoint create --region RegionOne network admin http://controller:9696

安装配置1、安装相关组件
apt-get -y install neutron-server neutron-plugin-ml2 neutron-plugin-linuxbridge-agent neutron-l3-agent neutron-dhcp-agent neutron-metadata-agent python-neutronclient

2、备份neutron.confmv /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak
3、vim /etc/neutron/neutron.conf，新建neutron.conf内容为：
[DEFAULT]core_plugin = ml2service_plugins = routerauth_strategy = keystonestate_path = /var/lib/neutrondhcp_agent_notification = Trueallow_overlapping_ips = Truenotify_nova_on_port_status_changes = Truenotify_nova_on_port_data_changes = True# RabbitMQ connection infotransport_url = rabbit://openstack:openstack@controller[agent]root_helper = sudo /usr/bin/neutron-rootwrap /etc/neutron/rootwrap.conf# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = neutronpassword = openstack# MariaDB connection info[database]connection = mysql+pymysql://neutron:openstack@controller/neutron# Nova connection info[nova]auth_url = http://controller:5000auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultregion_name = RegionOneproject_name = serviceusername = novapassword = openstack[oslo_concurrency]lock_path = $state_path/tmp

4、更改权限chmod 640 /etc/neutron/neutron.conf
chgrp neutron /etc/neutron/neutron.conf
5、vi /etc/neutron/l3_agent.ini，如下修改：
# line 17: addinterface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver

6、vi /etc/neutron/dhcp_agent.ini，如下修改：
# line 17: addinterface_driver = neutron.agent.linux.interface.BridgeInterfaceDriver# line 28: uncommentdhcp_driver = neutron.agent.linux.dhcp.Dnsmasq# line 37: uncomment and changeenable_isolated_metadata = true

7、vi /etc/neutron/metadata_agent.ini，如下修改：
# line 22: uncomment and specify Nova API servernova_metadata_host = controller# line 34: uncomment and specify any secret key you likemetadata_proxy_shared_secret = openstack# line 260: uncomment and specify Memcache Servermemcache_servers = controller:11211

8、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 129: add ( it's OK with no value for "tenant_network_types" (set later if need) )[ml2]type_drivers = flat,vlan,vxlantenant_network_types =mechanism_drivers = linuxbridge,l2populationextension_drivers = port_security# line 262: uncomment and addenable_security_group = Truefirewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver# end line: uncommentenable_ipset = True

9、vi /etc/neutron/plugins/ml2/linuxbridge_agent.ini，如下修改：
# line 235: add own IP addresslocal_ip = 192.168.56.110

10、vi /etc/nova/nova.conf，如下修改：
# add follows into [DEFAULT] sectionuse_neutron = Truelinuxnet_interface_driver = nova.network.linux_net.LinuxBridgeInterfaceDriverfirewall_driver = nova.virt.firewall.NoopFirewallDrivervif_plugging_is_fatal = Truevif_plugging_timeout = 300# add follows to the end : Neutron auth info# the value of metadata_proxy_shared_secret is the same with the one in metadata_agent.ini[neutron]auth_url = http://controller:5000auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultregion_name = RegionOneproject_name = serviceusername = neutronpassword = openstackservice_metadata_proxy = Truemetadata_proxy_shared_secret = openstack

完成安装1、创建链接ln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini
2、生成数据库表结构su -s /bin/bash neutron -c &quot;neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/plugin.ini upgrade head&quot;
3、重启网络服务并设置开机启动
for service in server l3-agent dhcp-agent metadata-agent linuxbridge-agent; dosystemctl restart neutron-$servicesystemctl enable neutron-$servicedone

4、重启novasystemctl restart nova-api nova-compute
5、查看网络agentopenstack network agent list
如上图，看到4个agent，都在controller节点上。
计算节点主要参考OpenStack Queens : Configure Neutron。
root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
安装配置1、安装组件apt-get -y install neutron-common neutron-plugin-ml2 neutron-plugin-linuxbridge-agent
2、备份neutron.confmv /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak
3、vim /etc/neutron/neutron.conf，新建neutron.conf如下：
[DEFAULT]core_plugin = ml2service_plugins = routerauth_strategy = keystonestate_path = /var/lib/neutronallow_overlapping_ips = True# RabbitMQ connection infotransport_url = rabbit://openstack:openstack@controller[agent]root_helper = sudo /usr/bin/neutron-rootwrap /etc/neutron/rootwrap.conf# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = neutronpassword = openstack[oslo_concurrency]lock_path = $state_path/lock

4、修改权限chmod 640 /etc/neutron/neutron.conf
chgrp neutron /etc/neutron/neutron.conf
5、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 129: add ( it's OK with no value for "tenant_network_types" (set later if need) )[ml2]type_drivers = flat,vlan,vxlantenant_network_types =mechanism_drivers = linuxbridge,l2populationextension_drivers = port_security# line 262: uncomment and addenable_security_group = Truefirewall_driver = neutron.agent.linux.iptables_firewall.IptablesFirewallDriver# end line: uncommentenable_ipset = True

6、vi /etc/neutron/plugins/ml2/linuxbridge_agent.ini，如下修改：
# line 235: add own Ip addresslocal_ip = 192.168.56.111

7、vi /etc/nova/nova.conf，如下修改：
# add follows into [DEFAULT] sectionuse_neutron = Truelinuxnet_interface_driver = nova.network.linux_net.LinuxBridgeInterfaceDriverfirewall_driver = nova.virt.firewall.NoopFirewallDrivervif_plugging_is_fatal = Truevif_plugging_timeout = 300# add follows to the end: Neutron auth info# the value of metadata_proxy_shared_secret is the same with the one in metadata_agent.ini[neutron]auth_url = http://controller:5000auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultregion_name = RegionOneproject_name = serviceusername = neutronpassword = openstackservice_metadata_proxy = Truemetadata_proxy_shared_secret = openstack

8、创建链接ln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini
9、重启网络服务systemctl restart nova-compute neutron-linuxbridge-agent
10、设置开启自启动systemctl enable neutron-linuxbridge-agent
验证操作在控制节点执行以下命令。
1、使admin环境生效. admin-openrc
2、查看agentsopenstack network agent list如上图，此时就能看到5个agent，其中4个在controller节点，1个在compute节点。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——nova篇</title>
    <url>/dev-ubuntu16-manual-openstack-nova/</url>
    <content><![CDATA[目标紧接着《Ubuntu16手动安装OpenStack——glance篇》，本文我们来安装nova，主要参考Compute service、Install and configure controller node for Ubuntu、Install and configure a compute node for Ubuntu。


nova简介使用OpenStack Compute来托管和管理云计算系统。OpenStack Compute是基础架构即服务（IaaS）系统的主要部分。主要模块用Python实现。
OpenStack Compute与OpenStack Identity交互以进行身份​​验证；OpenStack 镜像服务用于磁盘和镜像管理；OpenStack Dashboard用于用户界面和管理界面。镜像访问受项目和用户的限制；配额受每个项目限制（例如，实例数）。OpenStack Compute可以在标准硬件上水平扩展，下载镜像，然后启动实例。
OpenStack Compute包含以下组件：
nova-api service接受并响应终端用户compute API调用。该服务支持OpenStack Compute API。它强制执行某些策略并启动大多数活动，例如运行实例。
nova-api-metadata service接受来自实例的元数据请求。在nova-network的多主机模式下运行时，通常会使用nova-api-metadata服务。
nova-compute service通过虚拟机管理程序API，创建和终止虚拟机实例。例如：

XenAPI for XenServer/XCP
libvirt for KVM or QEMU
VMwareAPI for VMware

处理相当复杂。基本上，nova-compute守护程序接受来自队列的操作，并执行一系列系统命令，例如启动KVM实例并更新其在数据库中的状态。
nova-placement-api service跟踪每个provider的库存和使用情况。
nova-scheduler service从队列中获取虚拟机实例请求，并确定它运行的计算服务器主机。
nova-conductor module负责nova-compute服务和数据库之间的交互。它消除了nova-compute服务对云数据库的直接访问。nova-conductor module可以水平伸缩。不要将其部署在运行nova-compute服务的节点上。
nova-consoleauth daemon在控制台代理为用户授权tokens，参见nova-novncproxy和nova-xvpvncproxy。必须运行此服务才能使控制台代理生效。可以针对群集配置中的单个nova-consoleauth服务运行任一类型的代理。
nova-novncproxy daemon提供正在运行的实例的代理，该代理通过VNC连接访问。支持基于浏览器的novnc客户端。
nova-spicehtml5proxy daemon提供正在运行的实例的代理，该代理通过SPICE连接访问。支持基于浏览器的HTML5客户端。
nova-xvpvncproxy daemon提供正在运行的实例的代理，该代理通过VNC连接访问。支持OpenStack特定的Java客户端。
The queue用于在守护进程之间传递消息的中央集线器。通常用RabbitMQ实现，也可以用另一个AMQP消息队列实现，比如ZeroMQ。
SQL database存储云基础架构的大多数构建时和运行时状态，包括：

Available instance types
Instances in use
Available networks
Projects

从理论上讲，OpenStack Compute可以支持SQLAlchemy支持的任何数据库。常见的数据库是用于测试和开发工作的SQLite3，MySQL，MariaDB和PostgreSQL。
控制节点root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
数据库1、登录数据库mysql -uroot -p，密码为openstack。
2、创建nova_api，nova，nova_placement和nova_cell0数据库
CREATE DATABASE nova_api;CREATE DATABASE nova;CREATE DATABASE nova_placement; CREATE DATABASE nova_cell0;

3、授权
GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'localhost' IDENTIFIED BY 'openstack';GRANT ALL PRIVILEGES ON nova_api.* TO 'nova'@'%' IDENTIFIED BY 'openstack';GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'localhost' IDENTIFIED BY 'openstack';GRANT ALL PRIVILEGES ON nova.* TO 'nova'@'%' IDENTIFIED BY 'openstack';GRANT ALL PRIVILEGES ON nova_placement.* TO 'nova'@'localhost' IDENTIFIED BY 'openstack';GRANT ALL PRIVILEGES ON nova_placement.* TO 'nova'@'%' IDENTIFIED BY 'openstack';GRANT ALL PRIVILEGES ON nova_cell0.* TO 'nova'@'localhost' IDENTIFIED BY 'openstack';GRANT ALL PRIVILEGES ON nova_cell0.* TO 'nova'@'%' IDENTIFIED BY 'openstack';

4、退出数据库exit;
服务证书和端点1、使admin环境生效. admin-openrc
2、创建nova用户openstack user create --domain default --password-prompt nova
根据提示设置密码为openstack。
3、添加admin角色给nova用户openstack role add --project service --user nova admin
4、创建nova服务实体openstack service create --name nova --description &quot;OpenStack Compute&quot; compute
5、创建计算服务API endpoints
openstack endpoint create --region RegionOne compute public http://controller:8774/v2.1openstack endpoint create --region RegionOne compute internal http://controller:8774/v2.1openstack endpoint create --region RegionOne compute admin http://controller:8774/v2.1

服务证书和端点21、创建Placement service useropenstack user create --domain default --password-prompt placement
按照提示设置密码为openstack。
2、添加Placement user到service project，并且赋予admin角色openstack role add --project service --user placement admin
3、创建placement服务实体openstack service create --name placement --description &quot;Placement API&quot; placement
4、创建Placement API服务端点
openstack endpoint create --region RegionOne placement public http://controller:8778openstack endpoint create --region RegionOne placement internal http://controller:8778openstack endpoint create --region RegionOne placement admin http://controller:8778

安装配置组件1、安装组件apt-get -y install nova-api nova-placement-api nova-conductor nova-consoleauth nova-scheduler nova-novncproxy python-novaclient
2、备份nova.confmv /etc/nova/nova.conf /etc/nova/nova.conf.bak
3、vim /etc/nova/nova.conf，新建nova.conf内容为：
[DEFAULT]# define own IPmy_ip = 192.168.56.110state_path = /var/lib/novaenabled_apis = osapi_compute,metadatalog_dir = /var/log/nova# RabbitMQ connection infotransport_url = rabbit://openstack:openstack@controller[api]auth_strategy = keystone# Glance connection info[glance]api_servers = http://controller:9292[oslo_concurrency]lock_path = $state_path/tmp# MariaDB connection info[api_database]connection = mysql+pymysql://nova:openstack@controller/nova_api[database]connection = mysql+pymysql://nova:openstack@controller/nova# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = novapassword = openstack[placement]auth_url = http://controller:5000os_region_name = RegionOneauth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = placementpassword = openstack[placement_database]connection = mysql+pymysql://nova:openstack@controller/nova_placement[wsgi]api_paste_config = /etc/nova/api-paste.ini


4、更改权限chmod 640 /etc/nova/nova.conf
chgrp nova /etc/nova/nova.conf
5、生成数据库表结构
su -s /bin/bash nova -c "nova-manage api_db sync"su -s /bin/bash nova -c "nova-manage cell_v2 map_cell0"su -s /bin/bash nova -c "nova-manage db sync"su -s /bin/bash nova -c "nova-manage cell_v2 create_cell --name cell1"

完成后查看日志：tail /var/log/nova/nova-manage.log不放心的话，就登录数据库查看数据。
6、验证一下cell0和cell1是否被正确注册nova-manage cell_v2 list_cells
7、重启服务，完成安装
for service in api conductor scheduler consoleauth novncproxy; dosystemctl restart nova-$servicedone

8、查看计算服务列表openstack compute service list
计算节点本节介绍如何在计算节点上安装和配置Compute服务，该服务支持多个虚拟机管理程序来部署实例或虚拟机（VM）。为简单起见，此配置使用Quick EMUlator（QEMU）虚拟机管理程序，和支持虚拟机硬件加速的KVM扩展。可以按照教程进行小改，以便水平扩展计算节点。
安装方法主要参考OpenStack Queens : Add Compute Nodes。
root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
安装配置1、安装组件apt-get -y install nova-compute-kvm
2、备份nova.confmv /etc/nova/nova.conf /etc/nova/nova.conf.bak
3、vim /etc/nova/nova.conf，新建nova.conf内容为：
[DEFAULT]# define own IP addressmy_ip = 192.168.56.111state_path = /var/lib/novaenabled_apis = osapi_compute,metadatalog_dir = /var/log/nova# RabbitMQ connection infotransport_url = rabbit://openstack:openstack@controller[api]auth_strategy = keystone# enable VNC[vnc]enabled = Trueserver_listen = 0.0.0.0server_proxyclient_address = $my_ipnovncproxy_base_url = http://controller:6080/vnc_auto.html# Glance connection info[glance]api_servers = http://controller:9292[oslo_concurrency]lock_path = $state_path/tmp# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = novapassword = openstack[placement]auth_url = http://controller:5000os_region_name = RegionOneauth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = placementpassword = openstack[wsgi]api_paste_config = /etc/nova/api-paste.ini

4、设置权限chmod 640 /etc/nova/nova.conf
chgrp nova /etc/nova/nova.conf
5、硬件加速（可选）egrep -c &#39;(vmx|svm)&#39; /proc/cpuinfo
如果看到大于等于1的数字，说明主机支持硬件加速，不需要额外的配置。
如果此命令返回零值，则计算节点不支持硬件加速，您必须将libvirt配置为使用QEMU而不是KVM。
编辑/etc/nova/nova-compute.conf文件，libvirt部分修改为：
[libvirt]# ...virt_type = qemu

6、重启nova-compute服务systemctl restart nova-compute
添加计算节点到数据库以下操作在controller节点操作。
1、使admin环境生效. admin-openrc
2、查看计算服务列表openstack compute service list
发现，此时已经多了nova-compute服务。
3、查看计算节点openstack compute service list --service nova-compute
4、如果没有看到计算节点，那么需要查找计算节点，并且进行注册su -s /bin/bash nova -c &quot;nova-manage cell_v2 discover_hosts&quot;
添加新的compute节点时，必须在控制器节点上运行nova-manage cell_v2 discover_hosts以注册这些新计算节点。或者，可以在/etc/nova/nova.conf中设置适当的间隔来自动发现和注册节点：
[scheduler]discover_hosts_in_cells_interval = 300

验证操作以下操作在controller节点操作。
1、使admin环境生效. admin-openrc
2、列出服务组件，以验证每个进程的成功启动和注册openstack compute service list
成功的话可以看到四个服务：nova-scheduler、nova-consoleauth、nova-conductor和nova-compute。
3、列出Identity服务中的API端点，以验证与Identity服务的连接openstack catalog list

4、列出镜像服务中的镜像，以验证与镜像服务的连接openstack image list

5、检查cells and placement API是否工作正常nova-status upgrade check
控制节点安装计算服务1、安装组件apt -y install nova-compute-kvm
2、vim /etc/nova/nova.conf，添加vnc配置：
# enable VNC[vnc]enabled = Trueserver_listen = 0.0.0.0server_proxyclient_address = $my_ipnovncproxy_base_url = http://controller:6080/vnc_auto.html

3、硬件加速（可选）egrep -c &#39;(vmx|svm)&#39; /proc/cpuinfo
如果看到大于等于1的数字，说明主机支持硬件加速，不需要额外的配置。
如果此命令返回零值，则计算节点不支持硬件加速，您必须将libvirt配置为使用QEMU而不是KVM。
编辑/etc/nova/nova-compute.conf文件，libvirt部分修改为：
[libvirt]# ...virt_type = qemu

4、重启nova-compute服务systemctl restart nova-compute
5、添加到数据库su -s /bin/bash nova -c &quot;nova-manage cell_v2 discover_hosts&quot;
6、查看计算节点openstack compute service list --service nova-compute
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——openvswitch</title>
    <url>/dev-ubuntu16-manual-openstack-openvswitch/</url>
    <content><![CDATA[目标《Ubuntu16手动安装OpenStack——实例访问外网》一文中，已经配置好了实例访问外网。但是仍有不足，因为我们看不到更详细网络信息，排查问题不方便。
本文，我们把linuxbridge-agent更换为openvswitch-agent，主要参考OpenStack Pike : Configure Neutron、Neutron Configuration Options和Open vSwitch: Self-service networks。


openvswitch简介以下简介摘自openstack底层技术-使用openvswitch。
在过去，数据中心的服务器是直接连在硬件交换机上，后来VMware实现了服务器虚拟化技术，使虚拟服务器(VMs)能够连接在虚拟交换机上。借助这个虚拟交换机，可以为服务器上运行的VMs或容器提供逻辑的虚拟的以太网接口，这些逻辑接口都连接到虚拟交换机上。有三种比较流行的虚拟交换机：VMware virtual switch，Cisco Nexus 1000V和Open vSwitch。
Open vSwitch(OVS)是运行在虚拟化平台上的虚拟交换机，其支持OpenFlow协议，也支持gre/vxlan/IPsec等隧道技术。在OVS之前，基于Linux的虚拟化平台比如KVM或Xen上，缺少一个功能丰富的虚拟交换机，因此OVS迅速崛起并开始在Xen/KVM中流行起来，并且应用于越来越多的开源项目，比如openstack neutron中的网络解决方案。
在虚拟交换机的Flow控制器或管理工具方面，一些商业产品都集成有控制器或管理工具，比如Cisco 1000V的Virtual Supervisor Manager(VSM)，VMware的分布式交换机中的vCenter。而OVS则需要借助第三方控制器或管理工具实现复杂的转发策略。例如OVS支持OpenFlow协议，我们就可以使用任何支持OpenFlow协议的控制器来对OVS进行远程管理。OpenStack Neutron中的ML2插件也能够实现对OVS的管理。但这并不意味着OVS必须要有一个控制器才能工作。在不连接外部控制器情况下，OVS自身可以依靠MAC地址学习实现二层数据包转发功能，就像Linux Bridge。
在基于Linux内核的系统上，应用最广泛的还是系统自带的虚拟交换机Linux Bridge，它是一个单纯的基于MAC地址学习的二层交换机，简单高效，但同时缺乏一些高级特性，比如OpenFlow、VLAN tag、QOS、ACL、Flow等，而且在隧道协议支持上，Linux Bridge只支持vxlan，OVS支持gre/vxlan/IPsec等，这也决定了OVS更适用于实现SDN技术。
控制节点root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
卸载linuxbridge在安装OVS之前，我们先删除实例和网络，卸载掉linuxbridge。
1、使admin环境生效. admin-openrc
2、查看当前网络组件openstack network agent list
3、在dashboard使用admin账户登录，依次删除实例、路由和网络。
4、卸载linuxbridge
systemctl disable neutron-linuxbridge-agentsystemctl stop    neutron-linuxbridge-agentapt remove -y neutron-plugin-linuxbridge-agent

5、查看当前网络组件openstack network agent list此时，controller节点上的Linux bridge agent已经从笑脸变成了XXX。
6、从数据库删除Linux bridge agent
Bridge=`openstack network agent list | grep 'Linux bridge agent'|awk '&#123;print $2&#125;'`echo $Bridgeneutron agent-delete $Bridgeopenstack network agent list

7、重新创建neutron数据库mysql -uroot -p，密码为openstack。
drop database neutron;create database neutron;

8、参考Ubuntu16手动安装OpenStack——neutron篇，创建好证书和服务端点。
安装配置1、安装相关组件
apt-get -y install neutron-server neutron-metadata-agent neutron-plugin-ml2 python-neutronclient

2、备份neutron.confmv /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak
3、vim /etc/neutron/neutron.conf，新建neutron.conf内容为：
[DEFAULT]core_plugin = ml2service_plugins = routerauth_strategy = keystonestate_path = /var/lib/neutrondhcp_agent_notification = Trueallow_overlapping_ips = Truenotify_nova_on_port_status_changes = Truenotify_nova_on_port_data_changes = True# RabbitMQ connection infotransport_url = rabbit://openstack:openstack@controller[agent]root_helper = sudo /usr/bin/neutron-rootwrap /etc/neutron/rootwrap.conf# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = neutronpassword = openstack# MariaDB connection info[database]connection = mysql+pymysql://neutron:openstack@controller/neutron# Nova connection info[nova]auth_url = http://controller:5000auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultregion_name = RegionOneproject_name = serviceusername = novapassword = openstack[oslo_concurrency]lock_path = $state_path/tmp

4、更改权限chmod 640 /etc/neutron/neutron.conf
chgrp neutron /etc/neutron/neutron.conf
5、vi /etc/neutron/metadata_agent.ini，如下修改：
# line 22: uncomment and specify Nova API servernova_metadata_host = controller# line 34: uncomment and specify any secret key you likemetadata_proxy_shared_secret = openstack# line 260: uncomment and specify Memcache Servermemcache_servers = controller:11211

6、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 129: add ( it's OK with no value for "tenant_network_types" (set later if need) )[ml2]type_drivers = flat,vlan,gre,vxlantenant_network_types =mechanism_drivers = openvswitch,l2populationextension_drivers = port_security# line 262: uncomment and addenable_security_group = Truefirewall_driver = neutron.agent.linux.iptables_firewall.OVSHybridIptablesFirewallDriver# end line: uncommentenable_ipset = True

7、vi /etc/nova/nova.conf，如下修改：
# add follows into [DEFAULT] sectionuse_neutron = Truelinuxnet_interface_driver = nova.network.linux_net.LinuxOVSInterfaceDriverfirewall_driver = nova.virt.firewall.NoopFirewallDrivervif_plugging_is_fatal = Truevif_plugging_timeout = 300# add follows to the end : Neutron auth info# the value of metadata_proxy_shared_secret is the same with the one in metadata_agent.ini[neutron]auth_url = http://controller:5000auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultregion_name = RegionOneproject_name = serviceusername = neutronpassword = openstackservice_metadata_proxy = Truemetadata_proxy_shared_secret = openstack

8、创建链接ln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini
9、生成数据库数据
su -s /bin/bash neutron -c "neutron-db-manage --config-file /etc/neutron/neutron.conf --config-file /etc/neutron/plugin.ini upgrade head"

10、重启neutron服务并设置开机启动
systemctl start neutron-server neutron-metadata-agent systemctl enable neutron-server neutron-metadata-agent

11、重启nova-apisystemctl restart nova-api
网络节点本文中，控制节点和网络节点是同一个节点。
1、安装相关组件
apt-get -y install neutron-plugin-ml2 neutron-plugin-openvswitch-agent neutron-l3-agent neutron-dhcp-agent neutron-metadata-agent python-neutronclient

2、备份neutron.confmv /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak
3、vim /etc/neutron/neutron.conf，新建neutron.conf如下：
[DEFAULT]core_plugin = ml2service_plugins = routerauth_strategy = keystonestate_path = /var/lib/neutronallow_overlapping_ips = True# RabbitMQ connection infotransport_url = rabbit://openstack:openstack@controller[agent]root_helper = sudo /usr/bin/neutron-rootwrap /etc/neutron/rootwrap.conf# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = neutronpassword = openstack[oslo_concurrency]lock_path = $state_path/lock

4、修改权限chmod 640 /etc/neutron/neutron.conf
chgrp neutron /etc/neutron/neutron.conf
5、vi /etc/neutron/l3_agent.ini，如下修改：
# line 17: addinterface_driver = neutron.agent.linux.interface.OVSInterfaceDriver# line 100: uncomment and changeexternal_network_bridge = br-eth2

6、vi /etc/neutron/dhcp_agent.ini，如下修改：
# line 17: addinterface_driver = neutron.agent.linux.interface.OVSInterfaceDriver# line 28: uncommentdhcp_driver = neutron.agent.linux.dhcp.Dnsmasq# line 37: uncomment and changeenable_isolated_metadata = true

7、vi /etc/neutron/metadata_agent.ini，如下修改：
# line 22: uncomment and specify Nova API servernova_metadata_host = controller# line 34: uncomment and specify any secret key you likemetadata_proxy_shared_secret = openstack# line 260: uncomment and specify Memcache Servermemcache_servers = controller:11211

8、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 129: add ( it's OK with no value for "tenant_network_types" (set later if need) )[ml2]type_drivers = flat,vlan,gre,vxlantenant_network_types =mechanism_drivers = openvswitch,l2populationextension_drivers = port_security# line 262: uncomment and addenable_security_group = Truefirewall_driver = neutron.agent.linux.iptables_firewall.OVSHybridIptablesFirewallDriver# end line: uncommentenable_ipset = True

9、创建链接ln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini
10、重启openvswitch并设置开机启动
systemctl restart openvswitch-switch systemctl enable openvswitch-switch

11、创建网桥br-intovs-vsctl add-br br-int
12、重启相关服务并设置开机启动
for service in dhcp-agent l3-agent metadata-agent openvswitch-agent; dosystemctl start neutron-$servicesystemctl enable neutron-$servicedone

13、在控制节点查看neutron服务
. admin-openrcopenstack network agent list

计算节点root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
卸载linuxbridge1、卸载linuxbridge
systemctl disable neutron-linuxbridge-agentsystemctl stop    neutron-linuxbridge-agentapt remove -y neutron-plugin-linuxbridge-agent

2、控制节点查看当前网络组件openstack network agent list
3、从数据库删除Linux bridge agent
Bridge=`openstack network agent list | grep 'Linux bridge agent'|awk '&#123;print $2&#125;'`echo $Bridgeneutron agent-delete $Bridgeopenstack network agent list

安装配置1、安装相关组件
apt-get -y install neutron-common neutron-plugin-ml2 neutron-plugin-openvswitch-agent

2、备份neutron.confmv /etc/neutron/neutron.conf /etc/neutron/neutron.conf.bak
3、vim /etc/neutron/neutron.conf，新建neutron.conf如下：
[DEFAULT]core_plugin = ml2service_plugins = routerauth_strategy = keystonestate_path = /var/lib/neutronallow_overlapping_ips = True# RabbitMQ connection infotransport_url = rabbit://openstack:openstack@controller[agent]root_helper = sudo /usr/bin/neutron-rootwrap /etc/neutron/rootwrap.conf# Keystone auth info[keystone_authtoken]www_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = neutronpassword = openstack[oslo_concurrency]lock_path = $state_path/lock

4、修改权限chmod 640 /etc/neutron/neutron.conf
chgrp neutron /etc/neutron/neutron.conf
5、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 129: add ( it's OK with no value for "tenant_network_types" (set later if need) )[ml2]type_drivers = flat,vlan,gre,vxlantenant_network_types =mechanism_drivers = openvswitch,l2populationextension_drivers = port_security# line 262: uncomment and addenable_security_group = Truefirewall_driver = neutron.agent.linux.iptables_firewall.OVSHybridIptablesFirewallDriver# end line: uncommentenable_ipset = True

6、vi /etc/nova/nova.conf，如下修改：
# add follows into [DEFAULT] sectionuse_neutron = Truelinuxnet_interface_driver = nova.network.linux_net.LinuxOVSInterfaceDriverfirewall_driver = nova.virt.firewall.NoopFirewallDrivervif_plugging_is_fatal = Truevif_plugging_timeout = 300# add follows to the end : Neutron auth info# the value of metadata_proxy_shared_secret is the same with the one in metadata_agent.ini[neutron]auth_url = http://controller:5000auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultregion_name = RegionOneproject_name = serviceusername = neutronpassword = openstackservice_metadata_proxy = Truemetadata_proxy_shared_secret = openstack

7、创建链接ln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini
8、重启openvswitch并设置开机启动
systemctl restart openvswitch-switch systemctl enable openvswitch-switch

9、创建网桥br-intovs-vsctl add-br br-int
10、重启nova-compute服务systemctl restart nova-compute
11、重启neutron-openvswitch-agent并设置开机启动
systemctl restart neutron-openvswitch-agent systemctl enable neutron-openvswitch-agent

13、在控制节点查看neutron服务
. admin-openrcopenstack network agent list
可以看到，新添加了compute节点的Open vSwitch agent。
至此，openvswitch安装配置完成。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——vxlan网络进阶</title>
    <url>/dev-ubuntu16-manual-openstack-vxlan-advance/</url>
    <content><![CDATA[目标《Ubuntu16手动安装OpenStack——openvswitch》一文中，配置好了openvswitch作为虚拟交换机。
《Ubuntu16手动安装OpenStack——vxlan网络》一文中，使用linuxbridge虚拟交换机配置过vxlan网络模式。
因为linuxbridge换成了openvswitch，所以，本文就再来研究一下vxlan网络模式的配置。主要参考OpenStack Pike : Neutron Network (VXLAN)和openstack使用openvswitch实现vxlan的方法。如果要配置flat网络模式，参考OpenStack Pike : Neutron Network (FLAT)。


安装配置root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
控制节点0、备份配置（可选操作）：cp /etc/neutron/plugins/ml2/ml2_conf.ini{,.bak}
1、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 130: add a value to tenant_network_typestenant_network_types = vxlan# line 181: add[ml2_type_flat]flat_networks = physnet1# line 235: add[ml2_type_vxlan]vni_ranges = 1:1000

2、重启neutron-serversystemctl restart neutron-server
网络节点这里我们的网络节点和控制节点是同一个节点。
1、创建网桥br-eth2ovs-vsctl add-br br-eth2
2、把br-eth2连接到eth2ovs-vsctl add-port br-eth2 eth2
3、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 130: add a value to tenant_network_typestenant_network_types = vxlan# line 181: add[ml2_type_flat]flat_networks = physnet1# line 235: add[ml2_type_vxlan]vni_ranges = 1:1000

4、vi /etc/neutron/plugins/ml2/openvswitch_agent.ini，如下修改：
# line 117: add[agent]tunnel_types = vxlanl2_population = Trueprevent_arp_spoofing = True# line 195: add (specify IP address of this host for local_ip)[ovs]local_ip = 172.16.0.105bridge_mappings = physnet1:br-eth2

5、重启相关服务
for service in dhcp-agent l3-agent metadata-agent openvswitch-agent; dosystemctl restart neutron-$servicedone

计算节点1、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 130: add a value to tenant_network_typestenant_network_types = vxlan# line 181: add[ml2_type_flat]flat_networks = physnet1# line 235: add[ml2_type_vxlan]vni_ranges = 1:1000

2、vi /etc/neutron/plugins/ml2/openvswitch_agent.ini，如下修改：
# line 117: add[agent]tunnel_types = vxlanl2_population = Trueprevent_arp_spoofing = True# line 195: add (specify IP address of this host for local_ip)[ovs]local_ip = 172.16.0.106

3、重启openvswitch-agentsystemctl restart neutron-openvswitch-agent
使用在控制节点测试使用vxlan，实际上可以在任意节点使用。
内核配置1、vim /etc/sysctl.conf，如下修改：
# line 19, uncomment and changenet.ipv4.conf.default.rp_filter=0net.ipv4.conf.all.rp_filter=0# line 28, uncommentnet.ipv4.ip_forward=1# end line, addnet.bridge.bridge-nf-call-iptables = 1net.bridge.bridge-nf-call-ip6tables = 1

2、使内核配置生效sysctl -p
创建vxlan网络1、使admin环境生效. admin-openrc
2、创建路由router01openstack router create router01
3、创建内部网络int_netopenstack network create int_net --provider-network-type vxlan
4、在内部网络中创建子网
openstack subnet create subnet1 --network int_net \--subnet-range 192.168.100.0/24 --gateway 192.168.100.1 \--dns-nameserver 10.0.0.10

5、把内部网络int_net连接到路由router01上openstack router add subnet router01 subnet1
6、创建外部网络ext_net
openstack network create \--provider-physical-network physnet1 \--provider-network-type flat --external ext_net

7、在外部网络中创建子网subnet2
openstack subnet create subnet2 \--network ext_net --subnet-range 10.0.0.0/24 \--allocation-pool start=10.0.0.200,end=10.0.0.254 \--gateway 10.0.0.1 --dns-nameserver 10.0.0.10 --no-dhcp

8、把ext_net的网关设置为router01openstack router set router01 --external-gateway ext_net
此时，在horizon控制台看到的网络拓扑如下：
授权网络默认情况下，所有项目都可以访问到外部网络，但对于内部网络，只有管理项目可以访问它。因此需要对其他项目进行授权，使项目中的用户可以使用内部网络。
1、查看rbac网络openstack network rbac list
2、查看rbac网络细节openstack network rbac show [rbac-id]
3、查看网络openstack network list
4、查看项目openstack project list
5、授权int_net给siat项目，权限为access_as_shared
netID=$(openstack network list | grep int_net | awk '&#123; print $2 &#125;') prjID=$(openstack project list | grep siat | awk '&#123; print $2 &#125;') openstack network rbac create --target-project $prjID --type network --action access_as_shared $netID

使用vxlan网络1、切换到siat项目的voidking用户环境. voidkingrc
2、查看实例模板、镜像、网络
openstack flavor listopenstack image list openstack network list


3、安全组和密钥使用《Ubuntu16手动安装OpenStack——创建实例》一文中创建的secgroup01和vkkey。
4、创建实例
netID=$(openstack network list | grep int_net | awk '&#123; print $2 &#125;') openstack server create --flavor m1.tiny --image cirros --security-group secgroup01 --nic net-id=$netID --key-name vkkey cirros1

5、查看实例openstack server list
6、给实例添加浮动IP
openstack floating ip create ext_netopenstack server add floating ip cirros1 10.0.0.206

7、查看浮动IPopenstack floating ip show 10.0.0.206
8、再次查看实例openstack server list可以发现，cirros1已经有了两个IP地址。
9、测试连通ping 10.0.0.206，不通。
网络调试连接实例1、测试网关ping 10.0.0.1，不通。
2、将br-eth2的ip设置为10.0.0.1
ifconfig eth2 0.0.0.0 ifconfig br-eth2 10.0.0.1/24

3、测试连通ping 10.0.0.206，已经连通，nice。
4、ssh登录实例ssh cirros@10.0.0.206，默认密码为gocubsgo。
或者vnc登录实例openstack console url show cirros1查看到url后，在浏览器登录cirros1。
连接外网参考Ubuntu16手动安装OpenStack——实例访问外网，配置实例连接外网。
1、在控制节点执行
iptables -I INPUT -i br-eth2 -j ACCEPTiptables -I INPUT -i eth2 -j ACCEPTiptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth1 -j SNAT --to 172.16.0.105

2、登录cirros1ssh cirros@10.0.0.206
2、测试访问ping 8.8.8.8 -c3
3、修改resolv.confsudo vi /etc/resolv.conf添加：
nameserver 180.76.76.76

4、测试访问ping www.baidu.com -c3
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——vxlan网络</title>
    <url>/dev-ubuntu16-manual-openstack-vxlan/</url>
    <content><![CDATA[目标完成了《Ubuntu16手动安装OpenStack——swift篇》，openstack的核心组件就全部安装好了。 
之前的配置中，使用了简单的flatdhcp网络模式配置。本文，我们来把网络模式修改为vxlan，主要参考OpenStack Queens : Neutron Network (VXLAN)。


网络模式参考OpenStack 网络：Neutron 初探和深入理解 Neutron – OpenStack 网络实现，openstack的网络模式可以分为五种，分别是Flat、FlatDHCP、VLAN、GRE和VxLAN。
FlatFlat模式使用一个网桥实现OpenStack的网络，由于所有虚拟机都属于同一个网段，所以称之为扁平化flat。缺点是虚拟机的IP需要手动注入，而且只支持linux操作系统。
在 Flat 模式下工作流程如下：
（1）为所有租户创建一个 IP 池（2）创建租户（3）租户创建虚拟机，为虚拟机分配 IP 池中的可用 IP
FlatDHCPFlatDHCP 与 Flat 的不同在于有一个 DHCP 进程，虚拟机启动时会发送 dhcpdiscover 以获取 IP 地址。
VLANVLAN（Virtual Local Area Network）的中文名为”虚拟局域网”。VLAN 是一种将局域网设备从逻辑上划分成一个个网段，从而实现虚拟工作组的新兴数据交换技术。
在 VLAN 模式下工作流程如下：
（1）创建新的租户，并记下租户的标识（2）为该租户创建独占的私有IP段（3）租户创建虚拟机，从租户的私有IP段内分配IP给虚拟机
与 Flat 模式相比，VLAN 模式为网络增加了：将网络与租户关联和为网络分配一个 VLAN 号。
更多内容参考Neutron Vlan Network 原理- 每天5分钟玩转 OpenStack（92）。
GREGRE（General Routing Encapsulation）是点对点的IP隧道技术，可以用于虚拟网络互连。GRE和VLAN相比，最大的不同在于VLAN的tag转换方式。
在VLAN模式下，虚拟机集群内部网络与外部网络通信时，内部网络的int-VLAN:tag会转换为外部网络的ex-VLAN:tag；外部网络与虚拟机内部网络通信时，外部网络的ex-VLAN:tag会转换为内部网络的int-VLAN:tag。
而GRE模式下，虚拟机集群内部网络与外部网络通信时，内部网络的int-VLAN:tag会转换为外部网络的tunnul:tag；外部网络与虚拟机内部网络通信时，外部网络的tunnel:tag会转换为内部网络的int-VLAN:tag。

VxLANVxLAN（Virtual Extensible LAN）一般认为是 VLAN 技术的延伸或替代者。相较于采用物理VLAN实现的网络虚拟化，VxLAN是UDP隧道，可以穿越IP网络，使得两个VLAN可以实现二层联通，并且突破4095的VLAN ID限制，提供多达1600万的虚拟网络容量。
VxLAN 模式下，网络的架构跟 GRE 模式类似，所不同的是，不同节点之间通过 VxLAN 隧道互通，即虚拟化层是采用的 VxLAN 协议。
VxLAN配置root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
控制节点1、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 130: add a value to tenant_network_typestenant_network_types = vxlan# line 181: add[ml2_type_flat]flat_networks = physnet1# line 235: add[ml2_type_vxlan]vni_ranges = 1:1000

2、重启neutron-serversystemctl restart neutron-server
网络节点这里我们的网络节点和控制节点是同一个节点。
1、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 130: add a value to tenant_network_typestenant_network_types = vxlan# line 181: add[ml2_type_flat]flat_networks = physnet1# line 235: add[ml2_type_vxlan]vni_ranges = 1:1000

2、vi /etc/neutron/plugins/ml2/linuxbridge_agent.ini，如下修改：
# line 118: add[agent]prevent_arp_spoofing = True# line 147: add[linux_bridge]physical_interface_mappings = physnet1:eth2# line 201: add[vxlan]enable_vxlan = Truel2_population = True

3、vi /etc/neutron/dhcp_agent.ini，如下修改：
# line 63: adddnsmasq_config_file = /etc/neutron/dnsmasq-neutron.conf

4、vi /etc/neutron/dnsmasq-neutron.conf，新建dnsmasq-neutron.conf内容如下：
# create newdhcp-option-force=26,1450

5、重启服务
for service in l3-agent dhcp-agent metadata-agent linuxbridge-agent; dosystemctl restart neutron-$servicedone

计算节点1、vi /etc/neutron/plugins/ml2/ml2_conf.ini，如下修改：
# line 130: add a value to tenant_network_typestenant_network_types = vxlan# line 181: add[ml2_type_flat]flat_networks = physnet1# line 235: add[ml2_type_vxlan]vni_ranges = 1:1000

2、vi /etc/neutron/plugins/ml2/linuxbridge_agent.ini，如下修改：
# line 118: add[agent]prevent_arp_spoofing = True# line 201: add[vxlan]enable_vxlan = Truel2_population = True

3、重启neutron-linuxbridge-agentsystemctl restart neutron-linuxbridge-agent
使用清除flat网络《Ubuntu16手动安装OpenStack——创建实例》一文中，已经使用flat网络创建了sharednet1，并在网络中创建了一个实例cirros0。在使用新的网络之前，删除它们。1、使admin环境生效. admin-openrc
2、查看实例openstack server list
3、删除实例openstack server delete cirros0
4、查看网络openstack network list
5、删除sharednet1openstack network delete sharednet1
创建vxlan网络在控制节点测试使用vxlan，实际上可以在任意节点使用。
1、使admin环境生效. admin-openrc
2、创建路由router01openstack router create router01
3、创建内部网络int_netopenstack network create int_net --provider-network-type vxlan
4、在内部网络中创建子网
openstack subnet create subnet1 --network int_net \--subnet-range 192.168.100.0/24 --gateway 192.168.100.1 \--dns-nameserver 10.0.0.10

5、把内部网络int_net连接到路由router01上openstack router add subnet router01 subnet1
6、创建外部网络ext_net
openstack network create \--provider-physical-network physnet1 \--provider-network-type flat --external ext_net

7、在外部网络中创建子网subnet2
openstack subnet create subnet2 \--network ext_net --subnet-range 10.0.0.0/24 \--allocation-pool start=10.0.0.200,end=10.0.0.254 \--gateway 10.0.0.1 --dns-nameserver 10.0.0.10 --no-dhcp

8、把ext_net的网关设置为router01openstack router set router01 --external-gateway ext_net
此时，在horizon控制台看到的网络拓扑如下：
授权网络默认情况下，所有项目都可以访问到外部网络，但对于内部网络，只有管理项目可以访问它。因此需要对其他项目进行授权，使项目中的用户可以使用内部网络。
1、查看rbac网络openstack network rbac list
2、查看rbac网络细节openstack network rbac show a5c4db79-f467-4b58-892b-b9cc56c3e317
3、查看网络openstack network list
4、查看项目openstack project list
5、授权int_net给siat项目，权限为access_as_shared
netID=$(openstack network list | grep int_net | awk '&#123; print $2 &#125;') prjID=$(openstack project list | grep siat | awk '&#123; print $2 &#125;') openstack network rbac create --target-project $prjID --type network --action access_as_shared $netID

使用vxlan网络1、切换到siat项目的voidking用户环境. voidkingrc
2、查看实例模板、镜像、网络
openstack flavor listopenstack image list openstack network list


3、安全组和密钥使用《Ubuntu16手动安装OpenStack——创建实例》一文中创建的secgroup01和vkkey。
4、创建实例
netID=$(openstack network list | grep int_net | awk '&#123; print $2 &#125;') openstack server create --flavor m1.tiny --image cirros --security-group secgroup01 --nic net-id=$netID --key-name vkkey cirros1

5、查看实例openstack server list
6、给实例添加浮动IP
openstack floating ip create ext_netopenstack server add floating ip cirros1 10.0.0.201

7、查看浮动IPopenstack floating ip show 10.0.0.201
8、再次查看实例openstack server list可以发现，cirros1已经有了两个IP地址。
9、测试连通
ping 10.0.0.201ssh cirros@10.0.0.201

顺利登录，nice。
PS：ping 192.168.100.6是不通的，因为那是openstack内部网络。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16安装OpenStack</title>
    <url>/dev-ubuntu16-openstack/</url>
    <content><![CDATA[前言在《VirtualBox中安装OpenStack》一文中，已经成功安装过openstack。如今，确定了研究方向就是OpenStack。第一步要做的，就是在实体机安装配置OpenStack。
由于版本更新，devstack目前只支持ubuntu16，而机房服务器使用的都是ubuntu14.04，很尴尬。尝试了旧的newton、mitaka、liberty，但是devstack依赖的keystone项目中没有了这三个分支，失败；尝试了新的pike、queens，但是ubuntu14中缺少相应的包，失败。
找到了DevStack 安装 grizzly-eol 版本 OpenStack一文，以为在local.conf中把分支改为tag就可以了。然而，报错接连不断，解决了N个小怪，随便出来个大BOSS就我拦住了。
最终，把系统换成了Ubuntu16，计划使用devstack安装最新版Queens，主要参考DevStack官方文档、《优雅安装OpenStack》和使用devstack安装OpenStack 双节点部署。


目标本文的目标是搭建一个 all-in-one OpenStack，所有核心服务都安装在ccrfox105节点上，节点IP为172.16.0.105。
核心服务包括：身份认证服务keystone，镜像服务glance，计算服务nova（默认使用KVM虚拟化），网络服务neutron，仪表板horizon。也需要包含一些支持服务，例如：SQL数据库，消息队列和NTP。
环境准备更换sources.list（可选）参考《Ubuntu更换源列表》。
1、备份源列表文件sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
2、编辑源列表文件sudo vim /etc/apt/sources.list
修改为：
deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse  deb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-proposed main restricted universe multiverse  deb-src http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverse

3、更新资源包sudo apt-get update
时间同步1、同步时区执行命令sudo dpkg-reconfigure tzdata，然后选择Asia，Shanghai。
2、安装时间同步工具
sudo apt-get install ntpdatesudo ntpdate cn.pool.ntp.orgdate

devstack下载1、安装gitsudo apt-get install git
2、下载devstack并切换到queens分支git clone https://git.openstack.org/openstack-dev/devstack -b stable/queens
创建stack用户方法一：1、执行创建用户脚本sudo devstack/tools/create-stack-user.sh
2、将devstack目录放到/opt/stack中并设置权限sudo mv devstack /opt/stack
sudo chown -R stack:stack /opt/stack
3、切换到stack用户sudo su - stack
方法二：1、添加stack用户sudo useradd -s /bin/bash -d /opt/stack -m stack
2、给stack用户添加sudo权限echo &quot;stack ALL=(ALL) NOPASSWD: ALL&quot; | sudo tee /etc/sudoers.d/stack
3、将devstack目录放到/opt/stack中并设置权限sudo mv devstack /opt/stack
sudo chown -R stack:stack /opt/stack
4、切换到stack用户sudo su - stack
更换pip源（可选）参考《python pip更换国内源》。
1、安装pythonsudo apt-get install python
2、创建pip.confmkdir ~/.pip &amp;&amp; vim ~/.pip/pip.conf
写入内容如下：
[global]index-url = http://mirrors.aliyun.com/pypi/simple/[install]trusted-host = http://mirrors.aliyun.com/pypi/simple/

编译安装1、拷贝local.confcd devstack &amp;&amp; cp samples/local.conf ./
2、修改local.conf密码配置为：
ADMIN_PASSWORD=secretDATABASE_PASSWORD=$ADMIN_PASSWORDRABBIT_PASSWORD=$ADMIN_PASSWORDSERVICE_PASSWORD=$ADMIN_PASSWORD

同时在最后添加：
GIT_BASE=http://git.trystack.cnNOVNC_REPO=http://git.trystack.cn/kanaka/noVNC.gitSPICE_REPO=http://git.trystack.cn/git/spice/spice-html5.git

3、拷贝local.shcp samples/local.sh ./
4、执行安装./stack.sh
安装报错：E: Unable to locate package libsystemd-dev。（1）安装libsystemd-dev，sudo apt install libsystemd-dev，没有找到libsystemd-dev这个包。
（2）查找libsystemd-dev，sudo apt search libsystemd-dev，果然没有找到libsystemd-dev。
（3）猜测是sources.list的锅，改成原sources.list，问题解决。
然后报错pip版本太低，升级却失败，删除.pip目录，问题解决。。。
接下来，顺利安装，最后报错：
2018-06-27 00:47:54.156 | More than one SecurityGroup exists with the name 'default'.2018-06-27 00:47:55.193 | More than one SecurityGroup exists with the name 'default'.2018-06-27 00:47:55.246 | ++./stack.sh:main:1390                   err_trap2018-06-27 00:47:55.254 | ++./stack.sh:err_trap:551                   local r=12018-06-27 00:47:55.261 | stack.sh failed: full log in /opt/stack/logs/stack.sh.log.2018-06-27-0828302018-06-27 00:47:55.264 | Error on exit

参考如何修改默认OpenStack安全组中的规则，查看securitygroup规则，openstack security group list
在多租户OpenStack环境中，存在多个名为“default”的安全组。在这种情况下，请使用安全组ID而不是安全组名称。云管理员可以使用OpenStack安全组列表来显示所有安全组及其当前分配的名称。
再次安装我觉得上面的安装好像失败了，打算重装。1、先在devstack目录中，执行卸载
./unstack.sh./clean.sh

2、再次安装./stack.sh
最后还是报同样的错误。不管了，测试下看看。
测试使用1、访问 http://172.16.0.105/dashboard ，用户名输入admin，密码输入secret，登录控制台。
2、项目，网络，创建网络和路由
3、项目，计算，创建实例
报错：
Error: Failed to perform requested operation on instance "vm1", the instance has an error status: Please try again later [Error: Host 'ccrfox105' is not mapped to any cell].

我们查看一下openstack的服务是否正常：
openstack service listopenstack endpoint listopenstack compute service list

提示：Missing value auth-url required for auth plugin password解决办法：进入devstack目录，执行
source openrc voidking projectsource openrc admin admin

虽然Missing value auth-url required for auth plugin password的问题解决了，但是还是无法创建实例。
参考OpenStack应用、报错，执行nova-manage cell_v2 discover_hosts，问题解决。
网络问题实例创建成功了，也分配了浮动IP为172.24.4.7，但是从ccrfox105上却ping不通实例。参考Openstack创建实例–horizon篇，进行如下设置：
1、项目，网络，安全组，创建安全组。
2、管理规则，添加出口入口icmp规则和tcp规则。
3、实例的安全组选择新建的规则。
然后，再次ping 172.24.4.7，网络就通了。
测试访问1、项目，计算，实例，实例名称，日志。即可看到cirros系统的用户名和密码。
2、然后在ccrfox105上，ssh登录cirros系统。
卸载devstack如果devstack安装失败或者不再需要，那么可以对它进行卸载。
执行./unstack.sh和./clean.sh，卸载openstack。然后删除stack用户，删除/opt/stack目录。
或者，干脆重装系统，因为卸载后会有很多遗留问题。
后记至此，完成了单节点OpenStack的安装，也进行了简单地创建实例和测试，nice。
接下来有两个计划，一个是尝试OpenStack更多的操作和设置，以便熟悉这个平台。另一个是使用devstack安装多节点OpenStack，或者手动安装多节点Openstack。计划搭建一个Controller节点和两个Compute节点。
在安装时，自作聪明地更换了sources.list和pip.conf，以为可以加速安装，没想到却给自己挖了坑，同学们引以为鉴啊。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
        <tag>devstack</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim进阶</title>
    <url>/dev-vim-advance/</url>
    <content><![CDATA[前言Vim是Linux和Unix上的编辑器，由Vi升级而来。
已经使用了Vim好多年，但是，水平仅仅停留在修改配置文件的水平。不会把它当做主要的编辑器，更不会用它进行编码开发。最近，童钢老师提醒了我，作为运维人员，Vim需要用得更加熟练一些，最好能把Vim作为默认编辑器使用。
所以，本文决定研究一下更高阶的Vim使用技巧，主要参考优雅玩转Vim。


VimrcVimrc指的是Vim的配置文件，rc=run command，Vim 的全局配置一般在/etc/vim/vimrc或者/etc/vimrc，对所有用户生效。用户个人的配置在~/.vimrc。
如果只对单次编辑启用某个配置项，可以在命令模式下，先输入一个冒号，再输入配置。举例来说，set number这个配置可以写在.vimrc里面，也可以在命令模式输入。
配置项一般都有”打开”和”关闭”两个设置。”关闭”就是在”打开”前面加上前缀”no”。
" 打开set number" 关闭set nonumber
上面代码中，双引号开始的行表示注释。
查询某个配置项是打开还是关闭，可以在命令模式下，输入该配置，并在后面加上问号。
:set number?
上面的命令会返回number或者nonumber。
如果想查看帮助，可以使用help命令。
:help number

更多内容参考Vim 配置入门。
有一些大神把Vim配置得非常炫酷，比如amix和humiaozuzu。
附上一份常用的vim配置：
" 语法高亮syntax on" 显示行号set number" 回车自动缩进set autoindent" 设置tab宽度set tabstop=4" shift缩进宽度set shiftwidth=4" tab自动转空格set expandtab" tab转空格宽度set softtabstop=4" 粘贴格式化set paste

如果cat查看文件可以正常看到中文，vim编辑文件出现乱码，那么可以指定编码方式为 utf8 来解决这个问题。
" 解决中文乱码问题set termencoding=utf-8set encoding=utf8set fileencodings=utf8,ucs-bom,gbk,cp936,gb2312,gb18030

四种模式普通模式进入vim后默认普通模式，可以进行移动、复制、粘贴、删除、修改等。其他模式点击Esc返回普通模式。
可视模式对一块区域进行操作，就像Windows中的鼠标选中。普通模式下点击v进入可视模式。
插入模式插入模式和普通文本编辑器相同，可以进行输入和删除。普通模式下点击i进入插入模式。
命令模式在命令模式中可以执行一些指令，就像在shell里一样。普通模式下点击Shift + :进入命令模式。
快捷键保存退出Shift + zz，退出或者保存退出。
移动跳转为了减少右手移动距离，h可代替左，j可代替下，k可代替上，l可代替右。
0移动到行首，Shift + 6也是移动到行首（不包含空格）。Shift + 4移动到行尾。
w光标正向移动到下一个单词，3w正向移动3个单词，b反向移动。e正向移动到下一个单词词尾，ge反向移动。W（Shift+w）表示忽略特殊字符，比如逗号句号等。
gg跳回第一行，10gg跳到第10行，Shift+g跳到最后一行。g、Ctrl+g显示文件信息。
f、空格，跳到下一个空格。
Shift+&gt;&gt;右缩进，Shift+&lt;&lt;左缩进。
多行缩进，进入命令模式，输入：
75,80&gt;75&gt;6

删除复制yy复制一行，内容存入无名寄存器和0号寄存器。
准确地来说，Vim中没有删除，只有剪切。dd剪切一行，内容存入无名寄存器和1号寄存器。
p粘贴到光标下一行，P粘贴到光标前一行。u撤销上一步的操作。ctrl+r重做。
命令模式下输入reg可以查看寄存器。
yw复制当前单词，y2w复制正向两个单词。yx复制当前字符。
dw删除当前单词，dj删除下一行，dk删除上一行，dh删除左边一个字符，dl删除当前字符。
d、Shift+6删除到行首，d、Shift+4删除到行尾。
3dd向下删除3行，5dw正向删除5个单词。
修改查找shift+i，跳到行首并进入插入模式；shift+a，跳到行尾并进入插入模式。
o进入下一行插入模式，O进入上一行插入模式。
3i进入插入模式，输入内容，Esc，输入的内容会被复制3次。
5o进入下一行插入模式，输入内容，Esc，输入的内容会插入5行。
~单个字符大小写转换，g~w整个单词大小写转换，g~$整行大小写转换，.对上一个操作重复。
fa在行内查找a，Fa在行内反向查找a。
/word查找word，n查找下一个，N查找上一个。在命令模式下设置set hlsearch可以高亮显示。
进入命令模式，进行替换：
# 替换当前行所有的oldword:s/oldword/newword/g# 替换文中所有的oldword:%s/oldword/newword/g

r替换单个字符，shift+r替换当前行，cw替换当前单词，c$修改光标后的内容。
多文件编辑假设有buffer1.txt、buffer2.txt、buffer3.txt三个文件，那么可以使用vim buffer*打开三个文件。当前显示buffer1.txt，进入命令行模式，查看缓冲区列表：
:files:buffers:ls

badd buffer4.txt打开一个缓冲区，bn切换下一个缓冲区，bp切换上一个缓冲区，bf切换到第一个缓冲区，bl切换到最后一个缓冲区，b3切换到第三个缓冲区，b buffer1.txt切换到buffer1.txt，ball编辑所有缓冲区，1,3bd删除1-3缓冲区列表，%bd删除所有缓冲区列表，qall退出所有。
bufdo set number所有缓冲区设置number。
多窗口与标签分组vim -o buffer*，分屏打开多个文件，垂直方向分屏。vim -O buffer*，分屏打开多个文件，竖直方向分屏。
ctrl+w、s垂直复制分屏，ctrl+w、v水平复制分屏，ctrl+w、q删除分屏。
sp buffer4.txt打开buffer4.txt并且上下分屏，vsp buffer4.txt打开buffer4.txt并且左右分屏。
ctrl+w、h向左移动，ctrl+w、j向下移动，ctrl+w、k向上移动，ctrl+w、l向右移动。ctrl+w、+增加高度，ctrl+w、-减少高度，ctrl+w、=设置高度相等。
标签里面可以包含多个窗口，使用类似于buffers。命令模式下，tabnew创建标签，tabfind查找并在新标签中打开文件，tabs查看打开的标签列表，tabclose关闭当前标签页，tabonly只保留当前标签页，tabn/p/first/last切换标签页，tabm 0将标签页放到第一个位置。普通模式下，gt/gT切换标签页。
文本对象和宏文本对象：w代表word，s代表sentence，p代表paragraph，此外还有textblock块对象。
操作：
&#123;operator&#125;&#123;i&#125;&#123;object&#125;&#123;operator&#125;&#123;a&#125;&#123;object&#125;daw = delete a word      ==a==n object: include the tail spaceciw = change inner word      ==i==nner object: not include the tail space

viw选中单词，v3iw选中三个单词，vis选中句子，vip选中段落，vi(选中圆括号中的内容，vi[选中中括号中的内容，vit选中标签中的内容。
使用宏输入1到99：普通模式下，o进入下一行插入，输入1，Esc返回普通模式，qa开始录制，yyp复制粘贴一行，ctrl+a当前数字加一，q完成录制，97@a执行97次。
Visual模式在可视模式下，可以对一个文本块的整体进行操作。可视模式有三种子模式，v激活面向字符的可视模式，V激活面向行的可视模式，ctrl+v激活面向列块的可视模式。
gv重选刚才选择的选区，o在选择区两端跳动。ctrl+v、3j垂直下拉三列，r进行替换。ctrl+v、3j垂直下拉三列，e选择单词直到词尾，c进行单词替换，输入完成，Esc。ctrl+v、3j垂直下拉三列，Shift+$选择到行尾，A进行插入，输入完成，Esc。
后记至此，已经系统学习了Vim的高阶知识点，包括Vim配置、四种模式、快捷键、多文本编辑、多窗口标签、文本对象和宏、可视模式等。接下来，就是在学习工作中多多使用Vim，最终熟能生巧。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
        <category>工具</category>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>编辑器</tag>
      </tags>
  </entry>
  <entry>
    <title>VirtualBox下CentOS7和Ubuntu16.04网络配置</title>
    <url>/dev-virtualbox-centos-ubuntu-network/</url>
    <content><![CDATA[前言开发中，经常需要用到虚拟机，虚拟中的网络配置，让郝同学头疼了很久。今天，以CentOS7和Ubuntu16.04为例，彻底解决这个问题。过程中，会穿插xshell和xftp的使用说明。


桥接VirtualBox设置选中CentOS，设置，网络，连接方式选择桥接网卡。
CentOS的ip设置1、启动CentOS，使用root用户登录。2、查看ip：ip add。3、编辑ifcfg-enp0s3，vi /etc/sysconfig/network-scripts/ifcfg-enp0s3，把ONBOOT=no改为ONBOOT=yes。4、重启网络服务，service network restart。5、再次查看ip：ip add。
CentOS的ssh设置1、启动CentOS，打开终端，切换到root用户。2、检查是否安装了ssh：rpm -qa | grep ssh如果没有安装ssh，则执行命令：yum install openssh-server
3、启动ssh：service sshd start如果提示:redirecting to /bin/systemctl start，那么改用命令：/bin/systemctl start sshd.service
4、检查是否已经成功启动：netstat -antp | grep sshd如果看到如下信息，则表示启动成功。
5、设置开机自启动：chkconfig sshd on
PS：利用右ctrl键来切换主机和虚拟机的鼠标，利用右ctrl+F来切换虚拟机全屏状态。
xshell设置1、文件，新建，主机填入192.168.1.114。2、选择用户身份验证，输入用户名和密码。3、点击确定，建立连接。
如果连接失败，请检查centos的防火墙是否关闭。关闭防火墙命令：systemctl stop firewalld.service
xftp配置1、文件，新建，主机填入192.168.1.114。2、协议选择SFTP。3、输入用户名和密码。4、点击确定，建立连接。
改进采用桥接方式，虚拟机中CentOS的IP地址是DHCP服务器动态分配的。所以每次使用前需要使用ip add命令，重新查询一下CentOS的IP地址，然后修改xshell和xftp中的主机地址。
当外部没有DHCP服务器时，虚拟机也需要拨号才能上网，很麻烦。于是，再次研究Virtualbox网络设置，盗图一张说明四种连接方式区别。

比较简单的设计，是添加两张网卡。一张选择仅主机（Host-Only）适配器，用于宿主机和虚拟机之间的通讯，使宿主机可以访问虚拟机的服务；一张选择网络地址转换（NAT），用于分享宿主机网络给虚拟机，使虚拟机可以访问外网。
下面详细说明一下四种连接方式的不同。
NATNAT：Network Address Translation，网络地址转换NAT模式是最简单的实现虚拟机上网的方式，你可以这样理解：

Guest访问网络的所有数据都是由主机提供的，Guest并不真实存在于网络中，主机与网络中的任何机器都不能查看和访问到Guest的存在。

Guest可以访问主机能访问到的所有网络，但是对于主机以及主机网络上的其他机器，Guest又是不可见的，甚至主机也访问不到Guest。
虚拟机与主机的关系：只能单向访问，虚拟机可以通过网络访问到主机，主机无法通过网络访问到虚拟机。
虚拟机与网络中其他主机的关系：只能单向访问，虚拟机可以访问到网络中其他主机，其他主机不能通过网络访问到虚拟机。
虚拟机与虚拟机的关系：相互不能访问，虚拟机与虚拟机各自完全独立，相互间无法通过网络访问彼此。
Bridged Adapter（网桥模式）网桥模式，你可以这样理解：

它是通过主机网卡，架设了一条桥，直接连入到网络中了。因此，它使得虚拟机能被分配到一个网络中独立的IP，所有网络功能完全和在网络中的真实机器一样。

网桥模式下的虚拟机，你把它认为是真实计算机就行了。
虚拟机与主机的关系：可以相互访问，因为虚拟机在真实网络段中有独立IP，主机与虚拟机处于同一网络段中，彼此可以通过各自IP相互访问。
虚拟机于网络中其他主机的关系：可以相互访问，同样因为虚拟机在真实网络段中有独立IP，虚拟机与所有网络其他主机处于同一网络段中，彼此可以通过各自IP相互访问。
虚拟机与虚拟机的关系：可以相互访问，原因同上。
Internal（内网模式）内网模式，顾名思义就是内部网络模式：

虚拟机与外网完全断开，只实现虚拟机于虚拟机之间的内部网络模式。

虚拟机与主机的关系：不能相互访问，彼此不属于同一个网络，无法相互访问。
虚拟机与网络中其他主机的关系：不能相互访问，理由同上。
虚拟机与虚拟机的关系：可以相互访问，前提是在设置网络时，两台虚拟机设置同一网络名称。如上配置图中，名称为intnet。
Host-only Adapter（主机模式）主机模式，这是一种比较复杂的模式，需要有比较扎实的网络基础知识才能玩转。可以说前面几种模式所实现的功能，在这种模式下，通过虚拟机及网卡的设置都可以被实现。
我们可以理解为Guest在主机中模拟出一张专供虚拟机使用的网卡，所有虚拟机都是连接到该网卡上的，我们可以通过设置这张网卡来实现上网及其他很多功能，比如（网卡共享、网卡桥接等）。
虚拟机与主机的关系：默认不能相互访问，双方不属于同一IP段，host-only网卡默认IP段为192.168.56.X 子网掩码为255.255.255.0，后面的虚拟机被分配到的也都是这个网段。通过网卡共享、网卡桥接等，可以实现虚拟机于主机相互访问。
虚拟机与网络主机的关系：默认不能相互访问，原因同上，通过设置，可以实现相互访问。
虚拟机与虚拟机的关系：默认可以相互访问，都是同处于一个网段。
修正采用主机模式，虚拟机与主机的关系，默认可以相互访问。因为，主机IP地址默认为192.168.56.1，虚拟机的IP地址为192.168.56.X。所以，理论上虚拟机和主机可以相互访问。亲测证明，虚拟机和主机确实可以互相访问。
CentOS7相关添加网络命令CentOS7没有netstat 和 ifconfig命令，yum install net-tools。CentOS7查看网络配置，ifconfig -a或者ip add，如果没有获取到IP地址，vi /etc/sysconfig/network-scripts/ifcfg-enp0s3，修改ONBOOT=no为ONBOOT=yes，然后service network restart。
修改时区CentOS7修改时区，cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime。
设置静态IP第一网卡设置为固定IP，ifcfg-enp0s3原配置：
TYPE=EthernetBOOTPROTO=dhcpDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noNAME=enp0s3UUID=459b17a4-fd16-4ea7-8a4b-9509b6e899e7DEVICE=enp0s3ONBOOT=yes

ifcfg-enp0s3修改为：
TYPE=EthernetBOOTPROTO=staticIPADDR=192.168.56.101NETMASK=255.255.255.0NM_CONTROLLED=noDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noNAME=enp0s3UUID=459b17a4-fd16-4ea7-8a4b-9509b6e899e7DEVICE=enp0s3ONBOOT=yes

Ubuntu相关修改root密码修改root密码，sudo passwd root。
安装ssh服务安装ssh服务，apt-get install openssh-server，如果提示找不到安装包，执行apt-get update。
允许以root用户通过ssh登录，vi /etc/ssh/sshd_config，找到：
# Authentication:LoginGraceTime 120PermitRootLogin prohibit-passwordStrictModes yes
修改为：
# Authentication:LoginGraceTime 120#PermitRootLogin prohibit-passwordPermitRootLogin yesStrictModes yes

然后重启ssh服务，service ssh restart。
设置静态IP查看网络配置，ifconfig -a，如果只显示一个网卡，执行vi /etc/network/interfaces。interfaces原配置为：
# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto enp0s3iface enp0s3 inet dhcp

添加如下内容：
# The second network interfaceauto enp0s8iface enp0s8 inet dhcp

然后重启网络服务，/etc/init.d/networking restart。
第一网卡设置为固定IP：
# The primary network interfaceauto enp0s3iface enp0s3 inet static  address 192.168.56.102 netmask 255.255.255.0

然后重启第一张网卡，sudo ifdown enp0s3，sudo ifup enp0s3。如果报错：RTNETLINK answers: File exists，那就先执行一下sudo ip addr flush dev enp0s3。
修改网卡名网卡名叫enp0s3这种名字，很不友好，不如ubuntu14中的eth0看起来舒服。
1、编辑grub文件sudo vim /etc/default/grub
找到：
GRUB_CMDLINE_LINUX=""

修改为：
GRUB_CMDLINE_LINUX="net.ifnames=0 biosdevname=0"

2、重新生成grub配置sudo grub-mkconfig -o /boot/grub/grub.cfg
3、修改/etc/network/interfaces中的enp0s3为eth0，enp0s8修改为eth1。
4、重启sudo reboot
修改主机名1、编辑/etc/hostnamesudo vim /etc/hostname
修改为想要的主机名，比如controller。
2、编辑/etc/hostssudo vim /etc/hosts
添加或编辑：
127.0.0.1  controller

3、重启sudo reboot
后记以后不玩图形界面的linux了，专注于服务器配置。
书签如何开启Centos6.4系统的SSH服务http://jingyan.baidu.com/article/3ea51489f9efbf52e61bba05.html
通过SSH连接VirtualBox中的CentOShttp://www.2cto.com/os/201212/172712.html
VirtualBox + CentOS 虚拟机网卡配置http://my.oschina.net/duangr/blog/182541
CentOS 7 网络配置http://simonhu.blog.51cto.com/196416/1588971
centOS7在VirtualBox中装好后的网络连接问题http://jingyan.baidu.com/article/456c463b4a98460a5931444c.html
快速理解VirtualBox的四种网络连接方式http://www.cnblogs.com/york-hust/archive/2422911.html
CentOS 7 修改时区http://blog.csdn.net/robertsong2004/article/details/42268701
centOS7在VirtualBox中装好后的网络连接问题http://jingyan.baidu.com/article/456c463b4a98460a5931444c.html
virtualBox下Centos系统扩展磁盘空间详细教程http://blog.csdn.net/timecolor/article/details/48468377
virtualbox中ubuntu硬盘扩展，Gparted无法进入图形界面http://blog.sina.com.cn/s/blog_7149fc900102wvxh.html
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>网络</category>
        <category>centos</category>
        <category>ubuntu</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>centos</tag>
        <tag>ubuntu</tag>
        <tag>ssh</tag>
        <tag>xshell</tag>
        <tag>xftp</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始打造自己的JavaScript框架——第0章</title>
    <url>/dev-vkjs-0/</url>
    <content><![CDATA[概念简析库、插件、框架、加载项、扩展和控件都是组件。
组件（Component）是一个含义很大的概念，一般是指软件系统的一部分，承担了特定的职责，可以独立于整个系统进行开发和测试，一个良好设计的组件应该可以在不同的软件系统中被使用（可复用）。例如V8引擎是Chrome浏览器的一部分，负责运行javascript代码，这里V8引擎就可以视为一个组件。V8引擎同时也是node.js的javascript解释器，这体现了组件的可复用性。
库（Library）是一系列预先定义好的数据结构和函数（对于面向对象语言来说，是类）的集合，程序员通过使用这些数据结构和函数实现功能。例如Moment.js是一个javascript库，提供了处理时间的一些函数。在js中，插件和库的含义相同，我们也可以说Moment.js是一个插件。
框架（Framework）也是一系列预先定义好的数据结构和函数，一般用于作为一个软件的骨架，但程序真正的功能还需要由开发者实现。框架和库的最大区别在于“控制反转”，当你使用一个库，你会调用库中的代码，而当你使用一个框架，框架会调用你的代码。框架和库是一个有交叉的概念，很多框架都是以库的形式发布的，例如Java的Spring MVC框架，其发布的jar包本身就是一个库。下图来自Library vs. Framework? ，从调用的角度说明了框架和库的关系：
来自知乎龚世伟的回答


目标说到js框架和插件，我们可以想到jquery、zepto、requirejs、seajs、art-template、page.js、angularjs、vue等等。这些框架和插件有什么区别？来个表格比较。

    js框架和插件比较
    
        框架名称
        选择器
        DOM操作
        事件处理
        AJAX
        异步处理
        动画模块
        模块化管理依赖
        模板引擎
        路由管理
    

&lt;tr&gt;
    &lt;th&gt;jquery&lt;/th&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;th&gt;zepto&lt;/th&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;th&gt;requirejs&lt;/th&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;th&gt;seajs&lt;/th&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;th&gt;art-template&lt;/th&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;th&gt;page.js&lt;/th&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;×&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;th&gt;angularjs&lt;/th&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
    &lt;th&gt;vue&lt;/th&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
    &lt;td&gt;√&lt;/td&gt;
&lt;/tr&gt;

接下来，我们要开发一个js框架，类似于requirejs和seajs，实现模块化管理依赖的功能。
最早的时候，所有Javascript代码都写在一个文件里面，只要加载这一个文件就够了。后来，代码越来越多，一个文件不够了，必须分成多个文件，依次加载。下面的网页代码，相信很多人都见过。
&lt;script src="1.js"&gt;&lt;/script&gt;&lt;script src="2.js"&gt;&lt;/script&gt;&lt;script src="3.js"&gt;&lt;/script&gt;&lt;script src="4.js"&gt;&lt;/script&gt;&lt;script src="5.js"&gt;&lt;/script&gt;&lt;script src="6.js"&gt;&lt;/script&gt;

这段代码依次加载多个js文件，这样的写法有很大的缺点。首先，加载的时候，浏览器会停止网页渲染，加载文件越多，网页失去响应的时间就会越长；其次，由于js文件之间存在依赖关系，因此必须严格保证加载顺序（比如上例的1.js要在2.js的前面），依赖性最大的模块一定要放到最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。
详情请参考Javascript模块化编程（三）：require.js的用法。
我们要编写的vkjs，就是为了解决这两个问题：（1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。
环境准备1、安装node，参考nvm项目。2、安装puer，参考超简单工具puer。
异步加载首先，我们来看怎样实现异步加载。js的异步很容易实现，使用回调函数即可。
引入jsjs的引入，不是写在页面中，那么，肯定是写在js中。参考JAVASCRIPT 装载和执行和Preload Javascript，我们可以写出如下代码：
;(function () &#123;    var vk_config = &#123;        root: '/',        path: &#123;            'jquery': 'lib/jquery/jquery.min.js'        &#125;    &#125;;    var vk = &#123;        loadjs: function(script_filename,callback) &#123;            script_doc = document.getElementById(script_filename);            if(script_doc)&#123;                return;            &#125;            var script = document.createElement('script');            script.setAttribute('id', script_filename);            script.setAttribute('type', 'text/javascript');            script.setAttribute('src', vk_config.root + vk_config.path[script_filename]);            document.getElementsByTagName('body')[0].appendChild(script);            console.log('loading:'+script_filename);            script.onload = script.onreadystatechange = function()&#123;                console.log('loaded:'+script_filename);                callback();            &#125;        &#125;    &#125;;    window.vk = vk;&#125;)();

在页面中使用的时候，调用loadjs方法即可。
&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;vkjs&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;vkjs测试页面&lt;/h2&gt;&lt;script src="../src/vk.js"&gt;&lt;/script&gt;&lt;script&gt;    vk.loadjs('jquery',function()&#123;        console.log($('h2').html());    &#125;);     console.log('页面加载完毕');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

查看控制台，我们可以看到执行顺序：
loading:jquery页面加载完毕loaded:jqueryvkjs测试页面

引入jquery的时候，该script是插入到页面最底部的，但是我们在回调函数中依然可以使用$，因为jquery加载完毕后我们才调用回调函数，这时就和页面位置无关了。
引入多个js引入单个js，是比较容易的。而在开发时，常常需要引入多个js，如果多次调用loadjs方法的话，非常不友好。那么，怎样引入多个js文件？同样的，我们需要先加载js文件，等到所有js文件加载完成，调用回调函数即可。
;(function () &#123;    var vk_config = &#123;        root: '/',        path: &#123;            'jquery': 'lib/jquery/jquery.min.js',            'layer': 'lib/layer/layer.js',            'template': 'lib/art-template/dist/template.js'        &#125;    &#125;;    var vk = &#123;        loadjs: function(script_filename,callback) &#123;            script_doc = document.getElementById(script_filename);            if(script_doc)&#123;                return;            &#125;            var script = document.createElement('script');            script.setAttribute('id', script_filename);            script.setAttribute('type', 'text/javascript');            script.setAttribute('src', vk_config.root + vk_config.path[script_filename]);            document.getElementsByTagName('body')[0].appendChild(script);            console.log('loading:'+script_filename);            script.onload = script.onreadystatechange = function()&#123;                console.log('loaded:'+script_filename);                callback();            &#125;        &#125;,        count_js: 0,        use: function(ids,callback)&#123;            var that = this;            if (!Array.isArray(ids)) &#123;                ids = [ids];            &#125;            that.count_js = ids.length;            for(var i=0;i&lt;ids.length;i++)&#123;                (function(i)&#123;                    script_doc = document.getElementById(ids[i]);                    if(script_doc)&#123;                        return;                    &#125;                    script = document.createElement('script');                    script.setAttribute('id', ids[i]);                    script.setAttribute('type', 'text/javascript');                    script.setAttribute('src', vk_config.root + vk_config.path[ids[i]]);                    document.getElementsByTagName('body')[0].appendChild(script);                    console.log('loading:'+ids[i]);                    script.onload = script.onreadystatechange = function()&#123;                        console.log('loaded:'+ids[i]);                         that.count_js--;                        if(that.count_js == 0)&#123;                            callback();                        &#125;                    &#125;                &#125;)(i);            &#125;        &#125;    &#125;;    window.vk = vk;&#125;)();

在页面使用的时候，调用use方法：
&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;vkjs&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;vkjs测试页面&lt;/h2&gt;&lt;script src="../src/vk.js"&gt;&lt;/script&gt;&lt;script&gt;    vk.use(['jquery','template'],function()&#123;        console.log($('h2').html());    &#125;);     console.log('页面加载完毕');&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

查看控制台，我们可以看到执行顺序：
loading:jqueryloading:template页面加载完毕loaded:templateloaded:jqueryvkjs测试页面

有序引入js很多时候，我们不止要引入多个js，而且要有顺序地引入js。为了实现有序加载js，又不想使用js回调重重嵌套，所以郝同学选择使用Promise。具体用法参考Javascript异步编程的4种方法、JavaScript Promise 告别异步乱嵌套、大白话讲解Promise（一）。
未完待续。。。
管理依赖源码分享https://github.com/voidking/vkjs.git
书签从零开始编写自己的JavaScript框架（一）
从零开始编写自己的JavaScript框架（二）
jQuery源码解析（架构与依赖模块）
Query源码解析（架构与依赖模块）对应源码
Sea.js是如何工作的？
sea.js源码（Module.js核心代码）
JS模块加载器加载原理是怎么样的？
如何构建一个微型的CMD模块化加载器
如何实现一个 CMD 模块加载器
Grunt 实例之构建seajs项目
漫谈js自定义事件、DOM/伪DOM自定义事件
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>框架</tag>
        <tag>js</tag>
        <tag>puer</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始打造自己的PHP框架——第1章</title>
    <url>/dev-vkphp-1/</url>
    <content><![CDATA[目标本篇，我们来实现类库自动加载，以及路由解析。


类库自动加载常规加载常规加载一般使用include或者require，它们最根本的区别在于错误处理的方式不一样。 
include包括并运行指定文件。include一个文件存在错误的话，那么程序不会中断，而是继续执行，并显示一个警告错误。
include_once的作用和include几乎相同，唯一的差别在于导入之前会检查要导入的文件是否已经被导入过了，如果有的话就不会再次重复导入。
require会将目标文件的内容读入，并且把本身替换成这些读入的内容。require一个文件存在错误的话，那么程序就会中断执行了，并显示致命错误。
require_once的作用和require几乎相同，唯一的差别在于导入之前会检查要导入的文件是否已经被导入过了，如果有的话就不会再次重复导入。
在使用一个文件（类库）的函数之前，我们需要先使用include或者require，把该文件引入进当前文件，然后才能使用文件中的函数。
例如我们要新建一个route对象。1、core目录中，新建route.php：
&lt;?php/** * 路由控制 */namespace core;class route&#123;    public function __construct()&#123;        echo 'route is ready!';    &#125;&#125;

2、根目录下index.php中，添加：
$route = new \core\route();

会报错Fatal error: Class ‘core\route’ not found in…
需要改成：
include '\core\route.php';$route = new \core\route();

或者：
require '\core\route.php';$route = new \core\route();

自动加载bool spl_autoload_register ([ callable $autoload_function [, bool $throw = true [, bool $prepend = false ]]] )

将函数注册到SPL __autoload函数队列中。如果该队列中的函数尚未激活，则激活它们。成功时返回 TRUE，失败时返回 FALSE。
spl_autoload_register的一般用法：
spl_autoload_register(function ($class_name) &#123;    require_once $class_name . '.php';&#125;);$route = new \core\route();

在新建route对象时，class_name也就是\core\route会传入到spl_autoload_register函数中，该函数的参数是一个回调函数。回调函数拿到class_name，然后进行文件的引入。
也就是说，和常规加载相比，使用自动加载，我们不必对每一个类库单独进行引入。
自动加载进阶上例中，spl_autoload_register的回调函数是一个匿名函数，而且比较简单。下面，我们来写一个更高级的回调函数。新建aotuload.php，内容如下：
&lt;?php/** * 自动加载类库 */namespace core;class autoload&#123;    public static function load($class_name)&#123;        if(file_exists($class_name.'.php'))&#123;            require_once $class_name.'.php';            return true;        &#125;else&#123;            echo 'error: unable to load '.$class_name.'.php';            return false;        &#125;    &#125;&#125;

使用的时候，改成：
include CORE.'/autoload.php';spl_autoload_register('\core\autoload::load');$route = new \core\route();

加载机制简析在使用include的时候，会用到php文件系统。在文件系统中访问一个文件有三种方式：
1、相对文件名形式如route.php。它会被解析为 include_path/route.php，其中 include_path 表示.;C:/laragon/bin/php/php-5.6.16/PEAR 。假设当前目录是C:/laragon/www/vkphp，则该文件名依次被解析为：

C:/laragon/www/vkphp/route.php
C:/laragon/bin/php/php-5.6.16/PEAR/route.php

2、相对路径名形式如core/route.php，它会被解析为 include_path/core/route.php。假设当前目录是C:/laragon/www/vkphp，则该文件名依次被解析为：

C:/laragon/www/vkphp/core/route.php
C:/laragon/bin/php/php-5.6.16/PEAR/core/route.php

3、绝对路径名形式如/core/route.php，在linux系统中，它会被解析为/core/route.php；在windows系统中，它会被解析为 include_path/core/route.php，和相对路径一样。
绝对路径名形如C:/laragon/www/vkphp/core/route.php 或者C:\laragon\www\vkphp\core\route.php 或者 C:\\laragon\\www\\vkphp\\core\\route.php ，在windows系统中，会被解析为C:/laragon/www/vkphp/core/route.php。也就是说，windows中斜线和反斜线和双反斜线效果相同。
获取include_path和设置include_path的栗子：
echo get_include_path();ini_set('include_path', ini_get('include_path').PATH_SEPARATOR.'lib_path/libs');echo get_include_path();

路由控制隐藏index.php1、访问地址 http://vkphp.dev/index.php ，此时，我们看到“helloworld”和“route is ready!”。
2、访问地址 http://vkphp.dev/index.php/index/index ，可以看到同样的信息。
3、访问地址 http://vkphp.dev/index/index ，则会报404错误。那么，我们怎样隐藏掉index.php呢？答案是添加.htaccess。
在项目根目录下，添加.htaccess，内容如下：
Options +FollowSymLinks  IndexIgnore */*  RewriteEngine on  # if a directory or a file exists, use it directly  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d# otherwise forward it to index.php  RewriteRule . index.php

4、访问地址 http://vkphp.dev/index/index ，可以看到和1、2中相同的信息。
获取URL中的控制器和方法&lt;?php/** * 路由控制 */namespace core;class route&#123;    public $ctrl;    public $action;    public function __construct()&#123;        //echo 'route is ready!';        /**         * 1、隐藏index.php         * 2、获取URL中的控制器和方法         */        if(isset($_SERVER['REQUEST_URI']) &amp;&amp; $_SERVER['REQUEST_URI'] != '/')&#123;            $path = $_SERVER['REQUEST_URI'];            $patharr = explode('/',trim($path, '/'));            p($patharr);            if(isset($patharr[0]))&#123;                if($patharr[0] != 'index.php')&#123;                    // 省略了index.php                    $this-&gt;ctrl = $patharr[0];                    if(isset($patharr[1]))&#123;                        $this-&gt;action = $patharr[1];                    &#125; else&#123;                        $this-&gt;action = 'index';                    &#125;                &#125;else&#123;                    // 没省略index.php                    if(isset($patharr[1]))&#123;                        $this-&gt;ctrl = $patharr[1];                    &#125;                    if(isset($patharr[2]))&#123;                        $this-&gt;action = $patharr[2];                    &#125; else&#123;                        $this-&gt;action = 'index';                    &#125;                &#125;            &#125;else&#123;                $this-&gt;ctrl = 'index';                $this-&gt;action = 'index';            &#125;        &#125;else&#123;            $this-&gt;ctrl = 'index';            $this-&gt;action = 'index';        &#125;    &#125;&#125;

访问地址 http://vkphp.dev/index/index 或者 http://vkphp.dev/index.php/index/index ，即可看到打印出的patharr信息。
获取URL中的参数&lt;?php/** * 路由控制 */namespace core;class route&#123;    public $ctrl;    public $action;    public $params=array();    public function __construct()&#123;        //echo 'route is ready!';        /**         * 1、隐藏index.php         * 2、获取URL中的控制器和方法         * 3、获取URL中的参数         */        if(isset($_SERVER['REQUEST_URI']) &amp;&amp; $_SERVER['REQUEST_URI'] != '/')&#123;            $path = $_SERVER['REQUEST_URI'];            $patharr = explode('/',trim($path, '/'));            //p($patharr);            if(isset($patharr[0]))&#123;                if($patharr[0] != 'index.php')&#123;                    // 省略了index.php                    $this-&gt;ctrl = $patharr[0];                    if(isset($patharr[1]))&#123;                        $this-&gt;action = $patharr[1];                    &#125; else&#123;                        $this-&gt;action = 'index';                    &#125;                    $count = count($patharr);                    $i=2;                    while($i &lt; $count)&#123;                        $this-&gt;params[$patharr[$i]] = $patharr[$i+1];                        $i = $i + 2;                    &#125;                &#125;else&#123;                    // 没省略index.php                    if(isset($patharr[1]))&#123;                        $this-&gt;ctrl = $patharr[1];                    &#125;                    if(isset($patharr[2]))&#123;                        $this-&gt;action = $patharr[2];                    &#125; else&#123;                        $this-&gt;action = 'index';                    &#125;                    $count = count($patharr);                    $i=3;                    while($i &lt; $count)&#123;                        $this-&gt;params[$patharr[$i]] = $patharr[$i+1];                        $i = $i + 2;                    &#125;                &#125;            &#125;else&#123;                $this-&gt;ctrl = 'index';                $this-&gt;action = 'index';            &#125;        &#125;else &#123;            $this-&gt;ctrl = 'index';            $this-&gt;action = 'index';        &#125;        p($this-&gt;params);    &#125;&#125;

访问地址 http://vkphp.dev/index/index/id/3/name/voidking 或者 http://vkphp.dev/index.php/index/index/id/3/name/voidking ，即可看到打印出的params信息。
支持localhost访问地址 http://localhost/vkphp/index.php/index/index/id/3/name/voidking ，无法正常获取控制器、方法和参数，修改如下：
&lt;?php/** * 路由控制 */namespace core;class route&#123;    public $ctrl='index';    public $action='index';    public $params=array();    public function __construct()&#123;        //echo 'route is ready!';        /**         * 1、隐藏index.php         * 2、获取URL中的控制器和方法         * 3、获取URL中的参数         */        if(isset($_SERVER['REQUEST_URI']) &amp;&amp; $_SERVER['REQUEST_URI'] != '/' )&#123;            $path = $_SERVER['REQUEST_URI'];            $patharr = explode('/',trim($path, '/'));        &#125;else&#123;            $patharr = array();        &#125;                if(isset($_SERVER['HTTP_HOST']) &amp;&amp; ($_SERVER['HTTP_HOST'] == 'localhost' || $_SERVER['HTTP_HOST'] == '127.0.0.1') )&#123;            // 去掉项目名称            $patharr = array_slice($patharr,1,count($patharr)-1);        &#125;        if(isset($patharr[0]))&#123;            if($patharr[0] == 'index.php')&#123;                // 去掉index.php                $patharr = array_slice($patharr,1,count($patharr)-1);            &#125;            if(isset($patharr[0]))&#123;                $this-&gt;ctrl = $patharr[0];            &#125;            if(isset($patharr[1]))&#123;                $this-&gt;action = $patharr[1];            &#125;                         $count = count($patharr);            $i=2;            while($i &lt; $count)&#123;                if(isset($patharr[$i+1]))&#123;                    $this-&gt;params[$patharr[$i]] = $patharr[$i+1];                &#125;                $i = $i + 2;            &#125;        &#125;                p($this-&gt;ctrl);        p($this-&gt;action);        p($this-&gt;params);    &#125;&#125;

源码分享https://github.com/voidking/vkphp/releases/tag/v1.1.0
书签从零开始打造自己的PHP框架
PHP 檔案引入路徑問題
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>微擎系统搭建</title>
    <url>/dev-we7-start/</url>
    <content><![CDATA[前言时隔一年半，再次接触微信公众平台开发。相比于掌上大学、圈里、微站ABC、图灵机器人、小i机器人、FAQ免费智能问答机器人、V5KF、赛科智能机器人，个人更喜欢模块定制的微擎和捷微，源码在自己手里，想怎么搞怎么搞。本篇短文，就记录下微擎系统搭建的具体步骤。


准备条件首先，你要有一个公网服务器，服务器上有PHP和MySQL的环境，官方推荐linux(centOS)+ nginx + php5.3，mysql5.6。其次，你要有远程操作服务器的工具，推荐使用xshell和xftp。最后，你需要从微擎官网下载微擎的源码。
服务器云擎先说国内的，BAE、CAE、JAE、SAE等，上次做微信开发时，它们还是免费的，现在有些开始收费了。
再说国外的，GAE、OpenShift、heroku、appfog、mongolab等，但是国内的访问速度一般，要么直接被墙。其中，OpenShift是我最喜欢的，以前使用WordPress在上面搭建了一个博客。
云擎的用法简单，基本都是建立某个类型的应用，然后把代码部署上去。因为云擎有各种限制，比如PHP版本限制、文件大小限制、访问流量限制等，所以不建议使用。但是，云擎的重点在于免费，或者免费一段时间。做做测试还是可以的，对于我等穷屌丝而言，不失为一种福利。
主流服务器阿里云、腾讯云、亚马逊、西部数据、美团云等，按配置收费，可以根据实际需要和经济能力选择。这种服务器，就可以像本地主机一样随意安装配置了。本次的微擎环境，我们就使用阿里云。
PHP+MySQL在linux下配置PHP+MySQL的环境，具体步骤请自行百度。如果觉得麻烦，可以在阿里云购买一个配置好的镜像系统，10元左右。
远程工具xshell，用来远程登录服务器系统（一般是Linux），进行一些配置。xftp，用来管理服务器上的文件。
源码微擎官网：http://www.we7.cc/以前使用微擎，需要把整个微擎系统的源码下载下来，然后部署到服务器上。现在，只需要下载一个名叫“install.php”的文件就可以了。
流程连接服务器1、打开xshell，文件，新建，输入服务器的ip地址，确定，然后输入用户名和密码，便可以连接到服务器。哇咔咔，看到了黑黝黝的shell界面，congratulations！2、打开xftp，文件，新建，输入服务器的ip地址、用户名、密码，便可以连接到服务器。
查看帮助通过xftp，下载帮助文件，就可以大致知道自己的服务器的配置。可以看到，郝同学的web主目录为/alidata/www，OK，我们进入到/alidata/www目录下，里面有一个default目录。没错，这就是默认的web网站了，虽然里面只有一个index.html。而我们在浏览器地址栏输入主机ip地址，看到的就是这个index.html。
配置虚拟主机如果决定直接在default目录下搭建微擎，这个步骤可以忽略。很多情况下，我们希望在一个服务器上面搭建多个网站。以Apache为例，我们需要配置/etc/httpd/conf/httpd.conf，然后执行命令service httpd restart，具体步骤可以借鉴参考文档。最终结果是，我们配置了一个域名为http://test.voidking.com，对应服务器主机目录为/alidata/www/test。
上传源码通过xftp，把从微擎官网下载的“install.php”上传到default目录下。（配置过虚拟主机的话，就上传到test目录下）在浏览器访问地址：ServerName/install.php，其中，ServerName为ip地址或者自己配置的域名。没有意外的话，可以看到微擎的安装引导页面。至此，成功了一半。
环境检查微擎安装引导，会自动检测你的服务器环境是否符合系统安装的要求，很人性化。我们看到，目录权限有问题。打开xshell，进入到/alidata/www目录下，chmod -R 777 test，给test目录和test目录下所有文件增加读写执行权限。然后，再次检测，已经没有问题了。
系统配置数据库选项，输入正确的用户名和密码即可，其他无需修改。管理选项，创建一个管理员账号，微擎安装完成后用来登录。
下载文件系统配置完成后，单击“继续”，微擎系统就会下载需要的文件到test文件夹，并且创建一个名为“we7”的数据库。喝杯咖啡的时间，就可以完成下载。
更新系统用刚才配置的管理员账号登录微擎系统，看上去，一切正常。现在就可以使用了吗？不，在线安装的系统是精简版，必须更新，注意，是必须！一般来说，登录后会有更新提示，点过去即可。
测试微信公众号微信公众号分两种，服务号和订阅号。什么差别呢？1、服务号只有企业或者团体才能申请，而订阅号申请要求较低；2、服务号显示在聊天列表页，而订阅号都在聊天列表页的订阅号里面；3、服务号初始就可以使用自定义菜单，而订阅号需要微博认证同时500人订阅才可以使用自定义菜单（2015年8月起，菜单也开放给订阅号了，但是不能在开发者模式使用，仍需认证）；4、服务号每月可以推送4条消息，而订阅号可以推送30条。
交互原理被动处理用户的请求。图中的个人/企业服务器，指的就是微擎所在的服务器。
设置微信服务器，或者主动给用户发推送数据。
双向绑定1、在微擎系统，添加公众号，输入自己的公众号和密码一键获取公众号信息，或者自己填入公众号信息。最终生成我们需要的URL、Token、EncodingAESKey。
2、在微信公众平台，登录自己的公众号。左边导航栏，开发，基本配置。其中，URL、Token、EncodingAESKey要和微擎中一致。
helloworld在微擎系统中，管理公众号，文字回复，添加基本文字回复。输入规则名称、触发规则、回复内容，保存，提交。手机关注自己的公众号，在聊天界面输入“helloworld”，看看返回了什么？“恭喜你进入了一个新的世界！”微擎系统，至此基本搭建完成，更多好玩的功能，等着你去发掘。
后记在搭建微擎系统的过程中，会遇到各种各样意想不到的错误。卧槽，逗我吗？为什么写教程的家伙没有遇到这种错误！莫方，郝同学也遇到过各种不懂，各种错误。百度、官网、博客、论坛、QQ群、前辈，总能找到你想要的答案。
参考文档微擎开发文档http://www.we7.cc/docs/#introduce
阿里云一键安装web攻略https://bbs.aliyun.com/read/153209.html
公钥和私钥http://blog.csdn.net/tanyujing/article/details/17348321
在一台服务器上搭建多个网站的方法（Apache版）https://help.aliyun.com/knowledge_detail/6701386.html
Apache 虚拟主机 VirtualHost 配置http://www.neoease.com/apache-virtual-host/
DocumentRoot does not exist解决方法http://blog.csdn.net/zhuoyr/article/details/8393854
微信公众号提交开发者提示token验证失败http://www.68ecshop.com/article-1656.html
Xshell 启动报缺少msvcp110.dll文件http://blog.csdn.net/z1154505909/article/details/50474104
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序基础</title>
    <url>/dev-weapp-base/</url>
    <content><![CDATA[前言
张小龙在朋友圈里这样解释到：小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用，也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。



老师帮助申请了一个小程序，接下来，郝同学决定利用小程序做一个应用。有以下五个想法：1、公交查询系统2、餐厅排号系统3、餐厅点餐系统4、书籍借阅交易系统5、小范围问答系统
无论做哪个，都需要对腾讯提供的小程序API进行一个较全面的了解，本文就记录一下学习过程中的重点。
项目结构使用微信开发者工具，新建小程序项目，生成一些初始文件，结构如下。



文件
必填
作用



app.js
是
小程序逻辑


app.json
是
小程序公共设置


app.wxss
否
小程序公共样式表


| 文件类型 | 必填 | 作用 || js | 是 | 页面逻辑 || wxml | 是 | 页面结构 || wxss | 否 | 页面样式表 || json | 否 | 页面配置 |
app.json文件来对微信小程序进行全局配置，决定页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。
以下是一个包含了所有配置选项的简单配置app.json ：
&#123;  "pages": [    "pages/index/index",    "pages/logs/index"  ],  "window": &#123;    "navigationBarTitleText": "Demo"  &#125;,  "tabBar": &#123;    "list": [&#123;      "pagePath": "pages/index/index",      "text": "首页"    &#125;, &#123;      "pagePath": "pages/logs/logs",      "text": "日志"    &#125;]  &#125;,  "networkTimeout": &#123;    "request": 10000,    "downloadFile": 10000  &#125;,  "debug": true&#125;

加载过程由上图可以看出，加载过程为：1、app.js中的onLaunch和onShow函数被调用。2、按照app.json中的配置，注册pages参数中的页面。3、按照app.json中的配置，跳转到pages参数中的第一个页面（index页面）。4、index.js中的onLoad和onShow函数被调用。5、使用index.js的data初始化页面。6、index.js中onReady函数被调用。
逻辑层注册程序App() 函数用来注册一个小程序。接受一个 object 参数，其指定小程序的生命周期函数等。
object参数说明：



属性
类型
描述
触发时机



onLaunch
Function
生命周期函数–监听小程序初始化
当小程序初始化完成时，会触发 onLaunch（全局只触发一次）


onShow
Function
生命周期函数–监听小程序显示
当小程序启动，或从后台进入前台显示，会触发onShow


onHide
Function
生命周期函数–监听小程序隐藏
当小程序从前台进入后台，会触发 onHide


其他
Any
开发者可以添加任意的函数或数据到 Object 参数中，用 this 可以访问



注册页面Page() 函数用来注册一个页面。接受一个 object 参数，其指定页面的初始数据、生命周期函数、事件处理函数等。
object 参数说明：



属性
类型
描述



data
Object
页面的初始数据


onLoad
Function
生命周期函数–监听页面加载


onReady
Function
生命周期函数–监听页面初次渲染完成


onShow
Function
生命周期函数–监听页面显示


onHide
Function
生命周期函数–监听页面隐藏


onUnload
Function
生命周期函数–监听页面卸载


onPullDownRefresh
Function
页面相关事件处理函数–监听用户下拉动作


onReachBottom
Function
页面上拉触底事件的处理函数


其他
Any
开发者可以添加任意的函数或数据到 object 参数中，在页面的函数中用 this 可以访问


详见小程序文档
模块化我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 或者 exports 才能对外暴露接口。
需要注意的是：

exports 是 module.exports 的一个引用，因此在模块里边随意更改 exports 的指向会造成未知的错误。所以我们更推荐开发者采用 module.exports 来暴露模块接口，除非你已经清晰知道这两者的关系。
小程序目前不支持直接引入 node_modules , 开发者需要使用到 node_modules 时候建议拷贝出相关的代码到小程序的目录中。

// common.jsvar common = &#123;    sayHello: function()&#123;        console.log('hello');    &#125;,    sayGoodbye: function()&#123;        console.log('goodbye');    &#125;&#125;;module.exports = common;

在需要使用这些模块的文件中，使用 require(path) 将公共代码引入。
var common = require('../../modules/common/common.js');Page(&#123;  say: function() &#123;    common.sayHello();    common.sayGoodbye();  &#125;&#125;)

API小程序开发框架提供丰富的微信原生 API，可以方便的调起微信提供的能力，如获取用户信息，本地存储，支付功能等。详细介绍请参考API 文档
视图层WXML&lt;!-- item.wxml --&gt;&lt;template name="item"&gt;  &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt;

&lt;!--home.wxml--&gt;&lt;view class="container"&gt;  &lt;view  bindtap="bindViewTap" class="userinfo"&gt;    &lt;image class="userinfo-avatar" src="&#123;&#123;userInfo.avatarUrl&#125;&#125;" background-size="cover"&gt;&lt;/image&gt;    &lt;text class="userinfo-nickname"&gt;&#123;&#123;userInfo.nickName&#125;&#125;&lt;/text&gt;  &lt;/view&gt;  &lt;button bindtap="toIndex"&gt;跳转index&lt;/button&gt;  &lt;view wx:if="&#123;&#123;id==1&#125;&#125;"&gt;第一条&lt;/view&gt;  &lt;view wx:elif="&#123;&#123;id==2&#125;&#125;"&gt;第二条&lt;/view&gt;  &lt;view wx:else&gt;其他&lt;/view&gt;  &lt;!--hidden只用于text--&gt;  &lt;div hidden="&#123;&#123;true&#125;&#125;"&gt;    这是个div  &lt;/div&gt;  &lt;text hidden="&#123;&#123;true&#125;&#125;"&gt;这是个text&lt;/text&gt;  &lt;view wx:for="&#123;&#123;array&#125;&#125;"&gt;    &#123;&#123;index&#125;&#125;:&#123;&#123;item.message&#125;&#125;  &lt;/view&gt;  &lt;!--定义模板--&gt;  &lt;template name="myTemplate"&gt;    &lt;view&gt;      &lt;text&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;msg&#125;&#125; &lt;/text&gt;      &lt;text&gt; Time: &#123;&#123;time&#125;&#125; &lt;/text&gt;    &lt;/view&gt;  &lt;/template&gt;  &lt;!--使用模板--&gt;  &lt;template is="myTemplate" data="&#123;&#123;...myData&#125;&#125;"/&gt;  &lt;template name="odd"&gt;    &lt;view&gt; odd &lt;/view&gt;  &lt;/template&gt;  &lt;template name="even"&gt;    &lt;view&gt; even &lt;/view&gt;  &lt;/template&gt;  &lt;block wx:for="&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;"&gt;    &lt;template is="&#123;&#123;item % 2 == 0 ? 'even' : 'odd'&#125;&#125;"/&gt;    &lt;template is="&#123;&#123;index % 2 == 0 ? 'even' : 'odd'&#125;&#125;"/&gt;  &lt;/block&gt;  &lt;block wx:for="&#123;&#123;[1, 2, 3, 4, 5]&#125;&#125;" wx:for-index="itemIndex" wx:for-item="itemData"&gt;    索引&#123;&#123;itemIndex&#125;&#125;，数值&#123;&#123;itemData&#125;&#125;  &lt;/block&gt;  &lt;view id="tapTest" data-hi="WeChat" bindtap="tapName"&gt; Click me! &lt;/view&gt;  &lt;import src="item.wxml"/&gt;  &lt;template is="item" data="&#123;&#123;text: 'forbar'&#125;&#125;"/&gt;&lt;/view&gt;

/*home.js*/// 获取应用实例var app = getApp();var common = require('../../modules/common/common.js');Page(&#123;  data:&#123;    id: 4,    userInfo: &#123;&#125;,    array: [&#123;      message: 'foo',    &#125;, &#123;      message: 'bar'    &#125;],    myData: &#123;      index: 1000,      msg: '模板',      time: '16:08'    &#125;  &#125;,  onLoad:function(options)&#123;    // 页面初始化 options为页面跳转所带来的参数    var that = this;    //调用应用实例的方法获取全局数据    app.getUserInfo(function(userInfo)&#123;      //更新数据      that.setData(&#123;        userInfo:userInfo      &#125;)    &#125;);    common.sayHello();  &#125;,  onReady:function()&#123;    // 页面渲染完成  &#125;,  onShow:function()&#123;    // 页面显示    console.log('这是home页的onShow方法');  &#125;,  onHide:function()&#123;    // 页面隐藏  &#125;,  onUnload:function()&#123;    // 页面关闭  &#125;,  toIndex: function()&#123;    wx.navigateTo(&#123;      url: '../index/index'    &#125;);  &#125;,  tapName: function(event) &#123;    console.log(event)  &#125;&#125;)


WXSS当成css使用就好。
组件组件文档
后记小程序利弊各半，是否使用还是要看需求。
利：

不用安装，即开即用，用完就走。
省流量，省安装时间。
相较于原生应用，开发成本更低。
推广更容易更简单，更省成本。

弊：

寄生于微信，网页没有可移植性。
无法取代休闲娱乐办公类原生应用。

最后，引用iH5互动大师创始人孟智平的一段话：

真正的小程序的形式只能是H5。最轻（不用下载安装，用了就走）、最灵活（开发难度小，投放周期短，调整更容易）、最通用（标准的Web形态，有浏览器就能打开）。

书签简易教程-小程序https://mp.weixin.qq.com/debug/wxadoc/dev/index.html
微信小程序全方位深度解析-课程学习-百度传课http://www.chuanke.com/v4702151-193232-1107660.html
为什么我反对微信小程序？https://www.huxiu.com/article/171880/1.html?f=myzakercom
我们真的需要网页版App吗？Google PWA的困局http://www.leiphone.com/news/201606/UEiart497WUzS62u.html
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>微信</tag>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>Web安全学习（一）</title>
    <url>/dev-web-safety-learning-01/</url>
    <content><![CDATA[前言最近在研读《Web安全深度剖析》，其中的一些实践很有意思，做下记录。


非常规HTTP请求发起HTTP请求借助浏览器可以快速发起一次HTTP请求，如果不借助浏览器，该怎样发起HTTP请求呢？可以借助一些工具，比如curl，这个工具在Linux下是集成的，在Windows下，需要安装。下载地址：https://curl.haxx.se/download.html 。
下载成功后，我们发起一个HTTP请求：curl www.baidu.com，然而，返回的却是乱码。是Windows的问题？换成Linux，依然是乱码。后来查到，从百度获取到的文件，实际上是经过压缩的，需要解压缩，换成命令：curl www.baidu.com | gunzip，乱码问题解决，但是中文依然是乱码。
CentOS7解决中文乱码1、查看当前系统语言：echo $LANG2、查看安装的语言包：locale3、下载安装中文语言包：yum groupinstall chinese-support4、cp /etc/locale.conf /etc/locale.conf_bak5、vi /etc/locale.conf修改内容如下：
LANG="zh_CN.GB18030"LANGUAGE="zh_CN.GB18030:zh_CN.GB2312:zh_CN"SUPPORTED="zh_CN.UTF-8:zh_CN:zh:en_US.UTF-8:en_US:en"SYSFONT="lat0-sun16"
以上是理想情况，然而问题并没有解决。
换源在下载中文安装包时，报错group chinese-support does not exist。我的第一个想法是，换源！下面是换源的步骤：1、备份源：cp /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo_bak2、转到源目录：cd /etc/yum.repos.d/3、下载源：wget http://mirrors.163.com/.help/CentOS7-Base-163.repo4、生成缓存：yum clean all，yum makecache5、更新系统：yum -y update
PS：安装vim：yum -y install vim*
然而，换源之后，错误依旧，备受打击。
手动安装无奈手动安装，需要的安装包去这个网站找： http://rpmfind.net/linux/RPM/index.html ，找到后使用wget命令下载。其中，红色的就是用到的安装包，这里提供一个下载：链接：http://pan.baidu.com/s/1o8LHKmA 密码：md3i
安装命令：
rpm -ivh xorg-x11-xfs-1.0.2-5.el5_6.1.x86_64.rpm chkfontpath-1.10.1-1.1.x86_64.rpm libFS-1.0.0-3.1.x86_64.rpmrpm -ivh fonts-chinese-3.02-12.el5.noarch.rpm fonts-ISO8859-2-75dpi-1.0-17.1.noarch.rpm
过程中可能还会缺少其他包，yum install即可。
安装后修改/etc/locale.conf，中文依旧。但是，在命令行中输入locale，可以看到，确实安装好了中文。莫非locale.conf配置不对？LANG=&quot;zh_CN.GB18030&quot;怎么看怎么不顺眼，于是改成LANG=&quot;zh_CN.UTF-8&quot;。
重新登录，依旧乱码，这是要闹哪样？不甘心失败，用xshell测试了一下，成功显示中文！
模拟HTTP请求1、win+R，输入appwiz.cpl，回车，打开或关闭Windows功能，勾选Telnet客户端，确定。2、打开CMD运行框，输入telnet www.baidu.com 80，然后利用快捷键“ctrl+]”来打开telnet回显。3、按回车键，进入编辑状态。4、输入GET /index.html HTTP/1.1，按回车键，接着输入HOST:www.baidu.com，再连续两次按回车键。没错，Windows下中文依然是乱码，在CentOS7下试试：
截取HTTP请求Burp Suite Proxy初体验Burp Suite是用于Web应用安全测试工具的集成平台，下载地址：https://portswigger.net/burp/download.html
1、配置网络代理。双击BurpLoader.jar，选择“Proxy”选项卡，然后选择“Options”选项卡，点击Add按钮，在“Bind to port”框中输入端口号6666，“Bind to address”选择“Loopback only”，然后单击“OK”按钮。
打开火狐浏览器，选项，高级，网络，设置，手动配置代理。在HTTP代理框中输入127.0.0.1，端口号为6666，其他不用配置，单击“确定”。
2、查看拦截信息。在火狐浏览器中，输入www.baidu.com，回车后发现服务器很久没有回应信息，原因是Burp把HTTP请求拦截了，此时浏览器会处于阻塞状态。查看Burp的Intercept选项卡，可以看到请求信息。
3、绕过前端验证。启动wamp服务器，在火狐浏览器访问我们自己写的登录页面。发现请求页面并没有被拦截，修改火狐代理配置。再次访问登录页面，页面被拦截，在Burp中点击“Forword”，跳转到下一步。当我们输入的用户名或密码为空时，前端会出现提示。当我们正常输入用户名和密码时，在Burp中拦截信息。然后修改信息为：点击“Forward”，前端出现登录结果。这个请求，就绕过了前端验证，发送了空的用户名和密码给后端。
4、拦截响应如果我们想要拦截服务器的响应信息，那么，在Proxy，Options选项卡中，勾选Intercept response based on the following rules即可。
FiddlerFiddler是一款优秀的Web调试工具，它可以记录所有的浏览器与服务器之间的通信信息（HTTP和HTTPS），并且允许你设置断点，修改输入/输出数据。官方下载地址：http://www.telerik.com/fiddler
1、监听HTTP请求安装完成后，无需任何设置，Fiddler就可以监听所有浏览器和其他应用（比如360、QQ）发出的HTTP请求和响应。
2、监听HTTPS请求Fiddler默认不记录HTTPS请求，选择Tools，Fiddler Options，HTTPS，勾选Decrypt HTTPS traffic复选框，单击OK。
3、设置断点方法一：通过Rules，Automatic Breakpoints，选择断点的插入点，三个选项分别是请求之前、响应之后和不拦截。插入断点之后，会应用到所有的请求和响应。
方法二：通过命令进行断点设置。例如，bpu www.baidu.com，会拦截所有发往www.baidu.com的请求；bpafter www.baidu.com，会拦截所有来自www.baidu.com的响应；bpu和bpa，会清除断点。
设置完断点后，我们就可以和使用Burp一样，来拦截HTTP请求并且修改请求信息了。
4、不要误滑滚轮我们可以利用Fiddler自己定义返回给浏览器的内容，非常方便。但是，只要点击“Break on Response”，并且滑动滚轮，自定义内容就默认设置为一张图片，你可以选择其他自定义返回的内容，但是，无法再正常返回。所以，切记不要误滑滚轮！！！
5、中文乱码在response信息中，经常可以看到乱码。因为Fiddler是默认按照UTF-8编码解码的，但是很多网站采用的是GB2312/GBK/GB18030编码，却没有在HEADER中指明编码方式。
解决办法：打开注册表编辑器，找到HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Fiddler2\，添加字符串值HeaderEncoding，value为GB18030，然后重启Fiddler。但是这样一来，UTF-8编码并且没有指明编码方式的文件，不就变成了乱码了么？所以，建议不要修改。
6、发起HTTP请求Fiddler，可以代替HttpRequester，用来测试接口。
WinSock ExpertWinsock Expert是一个用来监视和修改网络发送和接收数据的程序，可以用来帮助渗透测试人员调试网络应用程序。然而，WSE在Win8下的兼容性并不是很好，所以，建议换用WireShark。推荐另外几款抓包工具：MiniSinffer、Iptool和Sniffer。
搜索引擎劫持症状1：直接输入域名可以访问自己的网站，但是通过百度、谷歌等搜索引擎搜索关键字看到自己的网站后，再打开却跳转到其他的网站。原理：攻击目标服务器，获取到网站源代码。然后修改后端代码，当HTTP请求头的Referer含有baidu、google等关键字时，控制跳转到其他网站。
症状2：无论通过哪种方式访问自己的网站，都会跳转到其他网站。原理：攻击目标服务器，获取到网站源代码。然后修改后端代码，控制跳转到其他网站；或者修改前端代码，控制跳转到其他网站。
参考书籍《Web安全深度剖析》，张炳帅
书签Linux中文显示乱码？如何设置centos显示中文http://jingyan.baidu.com/article/ab69b270de8b4f2ca7189f1d.html
解决centos7命令行中文乱码http://www.centoscn.com/CentosBug/osbug/2015/0313/4873.html
centos/redhat中文支持安装http://jingyan.baidu.com/article/8275fc86b7b36446a13cf648.html
CentOS更改yum源与更新系统http://www.cnblogs.com/lightnear/archive/2710952.html
CentOS 7 使用阿里云的yum源http://blog.csdn.net/skykingf/article/details/51953700
FreeBuf.COM | 关注黑客与极客http://www.freebuf.com/
漏洞盒子 | 互联网安全测试平台https://www.vulbox.com/
Fiddler 高级用法：Fiddler Script 与 HTTP 断点调试http://www.open-open.com/lib/view/open1429059806736.html
Fiddler工具使用http://www.imooc.com/learn/37
web debugger fiddler 使用小结http://www.cnblogs.com/forcertain/archive/2795139.html
《Wireshark协议分析从入门到精通》http://edu.51cto.com/lesson/id-62643.html
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>centos</tag>
        <tag>yum源</tag>
        <tag>安全</tag>
        <tag>黑客</tag>
      </tags>
  </entry>
  <entry>
    <title>微信自定义分享中node处理url</title>
    <url>/dev-weixin-node-handle-url/</url>
    <content><![CDATA[前言程序员的工作就是填坑，有时是填别人挖的坑，有时是填自己挖的坑。


微信自定义分享在使用node开发的时候，经常会用到微信自定义分享。自定义分享的步骤，大致如下：
微信配置登录微信公众平台，进入“公众号设置”的“功能设置”里填写“JS接口安全域名”。
node端1、设置分享数据（TKD）。2、获取权限验证配置数据。3、获取用户信息（非必要），因为需要在分享页面显示分享用户的昵称。
var config = require('../config');var urlencode = require('urlencode');var eventproxy = require('eventproxy');var request = require('request');var WechatAPI = require('wechat-api');var WXapi = new WechatAPI(config.weixin.appid, config.weixin.appsecret);// 微信exports.home = function(req, res)&#123;    // 获取code    var subscribe = 1;    if(!req.query.code)&#123;        var r_url = config.host+'/weixin/home';        var url = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid='+config.weixin.appid+'&amp;redirect_uri='+urlencode(r_url)+'&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=111#wechat_redirect';        res.redirect(url);    &#125;else&#123;        var code = req.query.code;        var state = req.query.state;                var ep = new eventproxy();        ep.all('shareConfig','userInfo',function(shareConfigData,userInfoData)&#123;            console.log(shareConfigData);            console.log(userInfoData);            // 设置分享数据（TKD）            var shareData = &#123;                enable: true,                title: '分享',                icon: 'http://cdn.voidking.com//imgs/head.jpg',                desc: '没见过这么拉风的分享描述吧！',                mUrl: config.host+'/weixin/userinfo?openid=000&amp;nickname=voidking&amp;num=10'            &#125;;            res.render('./weixin/home',&#123;                title: '微信',                host: config.host,                shareConfigData: shareConfigData,                shareData: shareData,                userInfoData: JSON.parse(userInfoData)            &#125;);        &#125;);        var param = &#123;            debug: false,            jsApiList: ['onMenuShareTimeline', 'onMenuShareAppMessage'],            url: req.protocol+"://"+req.hostname+req.originalUrl        &#125;;             WXapi.getJsConfig(param, function(err,result)&#123;            // result就是权限配置验证配置数据            ep.emit('shareConfig',result);            &#125;);        // 通过code换取网页授权access_token        var params = &#123;            appid:config.weixin.appid,            secret:config.weixin.appsecret,            code:code,            grant_type:'authorization_code'        &#125;;        var getAccessTokenUrl = 'https://api.weixin.qq.com/sns/oauth2/access_token?appid='+params.appid+'&amp;secret='+params.secret+'&amp;code='+params.code+'&amp;grant_type='+params.grant_type;        request.get(getAccessTokenUrl,function(error, response, body)&#123;            if (!error &amp;&amp; response.statusCode == 200) &#123;                var re = JSON.parse(response.body);                console.log(re);                var getuserinfo = 'https://api.weixin.qq.com/sns/userinfo?access_token='+re.access_token+'&amp;openid='+re.openid+'&amp;lang=zh_CN';                request.get(getuserinfo,function(error2, response2, body2)&#123;                    if (!error2 &amp;&amp; response2.statusCode == 200) &#123;                        ep.emit('userInfo',response2.body);                    &#125;                &#125;);            &#125;        &#125;);    &#125;&#125;

前端1、前端页面中引入微信的js文件http://res.wx.qq.com/open/js/jweixin-1.0.0.js。2、微信权限验证数据配置。3、分享数据配置。
&lt;script type="text/javascript"&gt;    wx.config(&#123;       debug:  false,  //调式模式，设置为ture后会直接在网页上弹出调试信息，用于排查问题       appId: '&lt;%= shareConfigData.appId%&gt;',       timestamp: '&lt;%= shareConfigData.timestamp%&gt;',       nonceStr: '&lt;%= shareConfigData.nonceStr%&gt;',       signature: '&lt;%= shareConfigData.signature%&gt;',       jsApiList: [  //需要使用的网页服务接口           'checkJsApi',  //判断当前客户端版本是否支持指定JS接口           'onMenuShareTimeline', //分享给好友           'onMenuShareAppMessage', //分享到朋友圈           'onMenuShareQQ',  //分享到QQ           'onMenuShareWeibo' //分享到微博       ]     &#125;);     wx.ready(function () &#123;   //ready函数用于调用API，如果你的网页在加载后就需要自定义分享和回调功能，需要在此调用分享函数。//如果是微信游戏结束后，需要点击按钮触发得到分值后分享，这里就不需要调用API了，可以在按钮上绑定事件直接调用。因此，微信游戏由于大多需要用户先触发获取分值，此处请不要填写如下所示的分享API        wx.onMenuShareTimeline(&#123;  //例如分享到朋友圈的API             title: '&lt;%= shareData.title%&gt;', // 分享标题           link: '&lt;%= shareData.mUrl%&gt;', // 分享链接           imgUrl: '&lt;%= shareData.icon%&gt;', // 分享图标           desc:'&lt;%= shareData.desc%&gt;',           success: function () &#123;               // 用户确认分享后执行的回调函数           &#125;,           cancel: function () &#123;               // 用户取消分享后执行的回调函数           &#125;        &#125;);        wx.onMenuShareAppMessage(&#123;  //例如分享到朋友圈的API             title: '&lt;%= shareData.title%&gt;', // 分享标题           link: '&lt;%= shareData.mUrl%&gt;', // 分享链接           imgUrl: '&lt;%= shareData.icon%&gt;', // 分享图标           desc:'&lt;%= shareData.desc%&gt;',           success: function () &#123;               // 用户确认分享后执行的回调函数           &#125;,           cancel: function () &#123;               // 用户取消分享后执行的回调函数           &#125;        &#125;);        wx.onMenuShareQQ(&#123;  //例如分享到朋友圈的API             title: '&lt;%= shareData.title%&gt;', // 分享标题           link: '&lt;%= shareData.mUrl%&gt;', // 分享链接           imgUrl: '&lt;%= shareData.icon%&gt;', // 分享图标           desc:'&lt;%= shareData.desc%&gt;',           success: function () &#123;               // 用户确认分享后执行的回调函数           &#125;,           cancel: function () &#123;               // 用户取消分享后执行的回调函数           &#125;        &#125;);        wx.onMenuShareWeibo(&#123;  //例如分享到朋友圈的API             title: '&lt;%= shareData.title%&gt;', // 分享标题           link: '&lt;%= shareData.mUrl%&gt;', // 分享链接           imgUrl: '&lt;%= shareData.icon%&gt;', // 分享图标           desc:'&lt;%= shareData.desc%&gt;',           success: function () &#123;               // 用户确认分享后执行的回调函数           &#125;,           cancel: function () &#123;               // 用户取消分享后执行的回调函数           &#125;        &#125;);    &#125;);     wx.error(function (res) &#123;        // alert(res.errMsg);  //打印错误消息。及把 debug:false,设置为debug:ture就可以直接在网页上看到弹出的错误提示    &#125;);&lt;/script&gt;

源码https://github.com/voidking/nodebase/blob/master/controllers/weixin.jshttps://github.com/voidking/nodebase/blob/master/views/weixin/home.html
&amp;转&amp;amp;以上，已经完成了微信自定义分享的工作。然而，还存在一些坑！！！
如上，我们的分享页面url为http://wx.voidking.com/weixin/userinfo?openid=000&amp;nickname=voidking&amp;num=10，参数是写死的，实际生产环境中需要使用真实数据拼接出来。
该分享页面的url，如果输出到页面上，就显示正常，比如使用隐藏的input接收。
&lt;input type="hidden" id="url" value="&lt;%= shareData.url%&gt;"&gt;
显示结果为
&lt;input type="hidden" id="url" value="http://wx.voidking.com/weixin/userinfo?openid=000&amp;nickname=voidking&amp;num=10"&gt;

但是，如果输出到微信分享的js中，url中的&amp;就会变成&amp;amp;。
wx.onMenuShareTimeline(&#123;  //例如分享到朋友圈的API      link: '&lt;%= shareData.mUrl%&gt;', // 分享链接    // 其他分享信息省略&#125;);
显示结果为
wx.onMenuShareTimeline(&#123;  //例如分享到朋友圈的API      link: 'http://wx.voidking.com/weixin/userinfo?openid=000&amp;amp;nickname=voidking&amp;amp;num=10', // 分享链接    // 其他分享信息省略&#125;);

啊嘞，&amp;转义成了&amp;amp;！！！没错，这就是第一个坑。因为分享出去的url参数不是以常规&amp;间隔，而是&amp;amp;，所以增加了我们截取参数的难度。
有两种解决方案：1、前端解决。输入内容到隐藏的input，然后获取值，添加到微信分享的js中。经测试，行不通。2、node端解决。在跳转分享页面时，改变获取参数的方式，代码如下。
exports.userinfo = function(req, res)&#123;        function getArg(str,arg) &#123;        var reg = new RegExp('(^|&amp;)' + arg + '=([^&amp;]*)(&amp;|$)', 'i');        var r = str.match(reg);        if (r != null) &#123;            return unescape(r[2]);        &#125;        return null;    &#125;    String.prototype.replaceAll  = function(s1,s2)&#123;             return this.replace(new RegExp(s1,"gm"),s2);         &#125;     var str = decodeURI(req.url.split('?')[1]);    console.log(str);    str = str.replaceAll('&amp;amp%3B','&amp;');     str = str.replaceAll('&amp;amp;','&amp;');    console.log(str);    var name = getArg(str,'name');    console.log(name);    res.render('weixin/userinfo',&#123;        title: '用户信息',        host: config.host    &#125;);&#125;

;转%3B以上，我们解决了微信分享中&amp;转义的问题，在电脑端或者安卓端查看分享都是正常的。然而，在IOS端查看会出现错误！！！
因为链接http://wx.voidking.com/weixin/userinfo?openid=000&amp;amp;nickname=voidking&amp;amp;num=10在使用IOS访问的时候，变成了http://wx.voidking.com/weixin/userinfo?openid=000&amp;amp%3Bnickname=voidking&amp;amp%3Bnum=10，;转义成了%3B！！！
解决办法，参考&amp;转&amp;amp;一节node端代码，替换字符串即可。
从url中截取中文参数以上，url属性中name的值是voidking，没有什么问题。然而，当我把name的值换为“帅哥”时，控制台打印出了乱码。啊哈，这就对了，中文肯定要处理一下嘛！
解决办法，使用decodeURI函数解码编码过的uri，参考&amp;转&amp;amp;一节node端代码。
书签微信公众平台开发者文档——微信JS-SDK说明文档http://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html
微信公共平台Node库 APIhttp://doxmate.cool/node-webot/wechat-api/api.html
wechat-api Documentationhttp://doxmate.cool/node-webot/wechat-api/api.html#api_js_exports_getJsConfig
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>微信</tag>
        <tag>url</tag>
      </tags>
  </entry>
  <entry>
    <title>微信公众号支付流程</title>
    <url>/dev-weixinpay-process/</url>
    <content><![CDATA[前言花费了一天时间，调通了微信公众号支付。作下记录，方便以后再次填坑。先声明，微信公众号支付，不同于微信H5支付，这点在本文结束时再详细说明。


微信配置设置测试目录在微信公众平台设置，栏目见下图。支付测试状态下，设置测试目录，测试人的微信号添加到白名单，发起支付的页面目录必须与设置的精确匹配。并将支付链接发到对应的公众号会话窗口中才能正常发起支付测试。注意正式目录一定不能与测试目录设置成一样，否则支付会出错。
设置正式支付目录根据图中栏目顺序进入修改栏目，勾选JSAPI网页支付开通该权限，并配置好支付授权目录，该目录必须是发起支付的页面的精确目录，子目录下无法正常调用支付。具体界面如图所示：
交互流程业务流程时序图首先看下微信官方给出的交互流程：
服务器交互微信公众号支付的流程，简而言之只有两步。第一步，下单，拿到prepay_id等信息；第二步，利用第一步拿到的prepay_id等信息进行支付。
代码Node端// 微信支付exports.weixinpay = function(req, res)&#123;  var orderId = req.params.orderId;  var selectSum = req.params.selectSum;  var token = req.params.token;  // 获取code  if(!req.query.code)&#123;    var r_url = 'http://' +config.host+'/artist/weixinpay/'+orderId+'/'+selectSum+'/'+token;    var url = 'https://open.weixin.qq.com/connect/oauth2/authorize?appid='+config.weixin.appid+'&amp;redirect_uri='+urlencode(r_url)+'&amp;response_type=code&amp;scope=snsapi_userinfo&amp;state=111#wechat_redirect';    res.redirect(url);  &#125;else&#123;    var code = req.query.code;    var state = req.query.state;    var ep = new eventproxy();    ep.all('userInfo',function(userInfoData)&#123;      var userInfoData = JSON.parse(userInfoData);      res.render('artist/weixinpay',&#123;        // 其他数据        openid: userInfoData.openid,        orderId: orderId,        selectSum: selectSum,        token: token      &#125;);    &#125;);    // 获取用户信息userInfo  &#125;&#125;exports.weixinpay2 = function(req, res)&#123;  var wxParamUrl = config.apihost + '/order/getH5SubOrderforWechat';  var param = &#123;    orderId: req.query.orderId,    selectSum: req.query.selectSum,    accessToken: req.query.token,    openId: req.query.openid  &#125;;  request.post(&#123;url: wxParamUrl,form: JSON.stringify(param)&#125;,function(error, response, body)&#123;        res.render('artist/weixinpay2',&#123;      // 其他数据      wxParam: JSON.parse(response.body)    &#125;);  &#125;);&#125;

上面的代码看起来很奇怪，为什么需要一个weixinpay2函数？代码全部放在weixinpay函数里面，然后在weixinpay.html里调用微信支付接口，不是很好么？这个，就涉及到支付目录的问题了。weixinpay函数中，微信授权获取用户信息后的回调url，目录太深，而且不确定，因为我们是通过目录来传递参数的。这样，就无法在微信公众号上面设置支付授权目录。所以，我们不能在weixinpay.html这个页面发起支付请求，只能把参数转发给下一个weixinpay2.html页面，在weixinpap2.html中发起支付请求。
那么，为什么获取用户信息后的回调url目录太深？直接把orderId等信息当做参数放在回调url后面不就可以了吗？很遗憾，回调url无法带入你的自定义参数。因此，只能把参数当做回调url的一部分，也就是目录的一部分。
综上，weixinpay函数负责获取用户的openid，weixinpay.html负责跳转weixinpay2.html；weixinpay2函数负责获取调用微信JSAPI的参数，weixinpay2.html负责调用微信JSAPI。
html&lt;!--weixinpay.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;微信支付&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;a id="weixin-link" href="/artist/weixinpay2?orderId=&lt;%= orderId%&gt;&amp;selectSum=&lt;%= selectSum%&gt;&amp;token=&lt;%= token%&gt;&amp;openid=&lt;%= openid%&gt;" style="display: none"&gt;微信支付&lt;/a&gt;&lt;script&gt;    var link = document.getElementById('weixin-link');    link.click();&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

&lt;!--weixinpay2.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;微信支付&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;input id="appId" type="hidden" value="&lt;%= wxParam.obj.appid%&gt;"&gt;    &lt;input id="timeStamp" type="hidden" value="&lt;%= wxParam.obj.timestamp%&gt;"&gt;    &lt;input id="nonceStr" type="hidden" value="&lt;%= wxParam.obj.noncestr%&gt;"&gt;    &lt;input id="package" type="hidden" value="&lt;%= wxParam.obj.packagestr%&gt;"&gt;    &lt;input id="signType" type="hidden" value="MD5"&gt;    &lt;input id="paySign" type="hidden" value="&lt;%= wxParam.obj.sign%&gt;"&gt;&lt;script&gt;function onBridgeReady()&#123;    var appId = document.getElementById('appId').value;    var timeStamp = document.getElementById('timeStamp').value;    var nonceStr = document.getElementById('nonceStr').value;    var package = document.getElementById('package').value;    var signType = document.getElementById('signType').value;    var paySign = document.getElementById('paySign').value;    WeixinJSBridge.invoke(        'getBrandWCPayRequest', &#123;            "appId": appId,     //公众号名称，由商户传入                 "timeStamp":timeStamp,         //时间戳，自1970年以来的秒数                 "nonceStr": nonceStr, //随机串                 "package": package,                 "signType": signType,         //微信签名方式：                 "paySign": paySign //微信签名         &#125;,        function(res)&#123;            WeixinJSBridge.log(res.err_msg);            //alert(res.err_code + res.err_desc + res.err_msg);            if (res.err_msg == "get_brand_wcpay_request:ok") &#123;                  window.location.href = '/artist/alipayresult?trade_status=TRADE_SUCCESS';                // 执行跳转页面....              &#125; else if (res.err_msg == "get_brand_wcpay_request:cancel") &#123;                  alert ("用户取消支付!");              &#125; else &#123;                  alert ("支付失败!");              &#125;                      &#125;    ); &#125;if (typeof WeixinJSBridge == "undefined")&#123;    if( document.addEventListener )&#123;        document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false);    &#125;else if (document.attachEvent)&#123;        document.attachEvent('WeixinJSBridgeReady', onBridgeReady);         document.attachEvent('onWeixinJSBridgeReady', onBridgeReady);    &#125;&#125;else&#123;    onBridgeReady();&#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

为了加快执行速度，这里的两个页面中，都使用原生的js来实现页面逻辑。
错误支付验证签名失败很明显，支付验证签名失败。怎么判断算出的签名是否正确？使用微信支付接口签名校验工具。校验方式选择自定义参数，把需要签名的参数名称和参数值输入页面，点击生成签名即可。
当前页面的URL未注册不好意思，这个错误忘记截图了。借来了一张图，凑合着看。这个问题，是由于调用支付接口的url不对！那么，怎样是对的呢？举个栗子：如果调用支付接口的url为http://wx.voidking.com/pay/weixinpay，那么微信公众平台上的支付授权目录应该设置为http://wx.voidking.com/pay/。也就是说，支付授权目录应该设置为调用支付接口的url的上一级目录。
支付成功
后记微信公众号支付，两个缺点，一是必须在微信浏览器使用，二是必须有一个拉取用户信息的步骤。但是我们发现，很多网站，在其他浏览器也可以使用微信支付，也不需要拉取用户信息，这是怎么回事？
因为，这是两种不同的支付方式！今天我们讨论的，叫做微信公众号支付；而在其他浏览器中调用微信支付，叫做微信H5支付！
更多关于微信H5支付的内容，请参考微信H5支付官方文档。
书签微信支付开发文档——公众号支付https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1
微信支付接口签名校验工具https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=20_1
非微信内置浏览器中的网页调起微信支付的方案研究http://blog.csdn.net/ahence/article/details/51317814
微信支付|商户平台开发者文档https://pay.weixin.qq.com/wiki/doc/api/wap.php?chapter=15_1
【微信支付V2.0】H5支付实例http://wxpay.weixin.qq.com/pub_v2/pay/wap.v2.php
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>微信</tag>
      </tags>
  </entry>
  <entry>
    <title>XMPP学习笔记——调试控制台</title>
    <url>/dev-xmpp-note-debug-console/</url>
    <content><![CDATA[前言开发人员总是喜欢不断地加工并完善自己的工具，在开发XMPP应用程序的过程中，我们将需要一款工具来辅助研究和查看协议流量。要是不使用查看源代码命令，或者不能轻易加工URL来测试远程站点的功能，那么很少有Web开发人员能够轻松工作。
对于XMPP节，这样的工具可用来查看协议流量并轻易地创建要发送的节。现在，我们就来做一个这样的工具。
Peek可用来帮助我们研究XMPP扩展如何运转以及为何有些扩展并不能按照预期执行操作。我们可以从应用程序中剪切并粘贴XMPP节构建代码，看看服务器响应究竟是什么。如果不熟悉特定的协议扩展，那么可以输入实例，看看服务器如何响应不同的输入。

操作步骤其实这个程序和之前的Hello很像，步骤类似。
peek.html新建peek.html，内容如下：
&lt;!DOCTYPE HTML&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv="Content-type" content="text/html;charset=UTF-8"&gt;    &lt;title&gt;Peek&lt;/title&gt;    &lt;link rel="stylesheet" type="text/css" href="./style/jquery-ui.css" &gt;	&lt;link rel="stylesheet" type="text/css" href="./style/jquery-ui.theme.css" &gt;		&lt;script type="text/javascript" src="./js/jquery.js"&gt;&lt;/script&gt;	&lt;script type="text/javascript" src="./js/jquery-ui.js"&gt;&lt;/script&gt;	    &lt;script type="text/javascript" src="./js/strophe.js"&gt;&lt;/script&gt;       &lt;script type="text/javascript" src='./js/strophe.flxhr.js'&gt;&lt;/script&gt;	&lt;script type="text/javascript" src='./js/flXHR.js'&gt;&lt;/script&gt;    &lt;link rel='stylesheet' type='text/css' href='./style/peek.css'&gt;    &lt;script src='./js/peek.js'&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;Peek&lt;/h1&gt;    &lt;div id='console'&gt;&lt;/div&gt;    &lt;textarea id='input' class='disabled'              disabled='disabled'&gt;	&lt;/textarea&gt;    &lt;div id='buttonbar'&gt;      &lt;input id='send_button' type='button' value='Send Data'             disabled='disabled' class='button'&gt;      &lt;input id='disconnect_button' type='button' value='Disconnect'             disabled='disabled' class='button'&gt;    &lt;/div&gt;    &lt;!-- login dialog --&gt;    &lt;div id='login_dialog' class='hidden'&gt;      &lt;label&gt;JID:&lt;/label&gt;&lt;input type='text' id='jid'&gt;      &lt;label&gt;Password:&lt;/label&gt;&lt;input type='password' id='password'&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;

peek.css新建peek.css，内容如下：
body &#123;    font-family: Helvetica;&#125;h1 &#123;    text-align: center;&#125;#console &#123;    padding: 10px;    height: 300px;    border: solid 1px #aaa;    background-color: #000;    color: #eee;    font-family: monospace;    overflow: auto;&#125;#input &#123;    width: 100%;    height: 100px;    font-family: monospace;&#125;.incoming &#123;    background-color: #111;&#125;textarea.disabled &#123;    background-color: #bbb;&#125;#buttonbar &#123;    margin: 10px;&#125;#disconnect_button &#123;    float: left;    width: 100px;&#125;#send_button &#123;    float: right;    width: 100px;&#125;/* xml styles */.xml_punc &#123; color: #888; &#125;.xml_tag &#123; color: #e77; &#125;.xml_aname &#123; color: #55d; &#125;.xml_avalue &#123; color: #77f; &#125;.xml_text &#123; color: #aaa &#125;.xml_level0 &#123; padding-left: 0; &#125;.xml_level1 &#123; padding-left: 1em; &#125;.xml_level2 &#123; padding-left: 2em; &#125;.xml_level3 &#123; padding-left: 3em; &#125;.xml_level4 &#123; padding-left: 4em; &#125;.xml_level5 &#123; padding-left: 5em; &#125;.xml_level6 &#123; padding-left: 6em; &#125;.xml_level7 &#123; padding-left: 7em; &#125;.xml_level8 &#123; padding-left: 8em; &#125;.xml_level9 &#123; padding-left: 9em; &#125;

peek.js新建peek.js，内容如下：
var Peek = &#123;    connection: null,    show_traffic: function (body, type) &#123;        if (body.childNodes.length &gt; 0) &#123;            var console = $('#console').get(0);            var at_bottom = console.scrollTop &gt;= console.scrollHeight -                 console.clientHeight;;            $.each(body.childNodes, function () &#123;                $('#console').append("&lt;div class='" + type + "'&gt;" +                                      Peek.pretty_xml(this) +                                     "&lt;/div&gt;");            &#125;);            if (at_bottom) &#123;                console.scrollTop = console.scrollHeight;            &#125;        &#125;    &#125;,    pretty_xml: function (xml, level) &#123;        var i, j;        var result = [];        if (!level) &#123;             level = 0;        &#125;        result.push("&lt;div class='xml_level" + level + "'&gt;");        result.push("&lt;span class='xml_punc'&gt;&amp;lt;&lt;/span&gt;");        result.push("&lt;span class='xml_tag'&gt;");        result.push(xml.tagName);        result.push("&lt;/span&gt;");        // attributes        var attrs = xml.attributes;        var attr_lead = []        for (i = 0; i &lt; xml.tagName.length + 1; i++) &#123;            attr_lead.push("&amp;nbsp;");        &#125;        attr_lead = attr_lead.join("");        for (i = 0; i &lt; attrs.length; i++) &#123;            result.push(" &lt;span class='xml_aname'&gt;");            result.push(attrs[i].nodeName);            result.push("&lt;/span&gt;&lt;span class='xml_punc'&gt;='&lt;/span&gt;");            result.push("&lt;span class='xml_avalue'&gt;");            result.push(attrs[i].nodeValue);            result.push("&lt;/span&gt;&lt;span class='xml_punc'&gt;'&lt;/span&gt;");            if (i !== attrs.length - 1) &#123;                result.push("&lt;/div&gt;&lt;div class='xml_level" + level + "'&gt;");                result.push(attr_lead);            &#125;        &#125;        if (xml.childNodes.length === 0) &#123;            result.push("&lt;span class='xml_punc'&gt;/&amp;gt;&lt;/span&gt;&lt;/div&gt;");        &#125; else &#123;            result.push("&lt;span class='xml_punc'&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;");            // children            $.each(xml.childNodes, function () &#123;                if (this.nodeType === 1) &#123;                    result.push(Peek.pretty_xml(this, level + 1));                &#125; else if (this.nodeType === 3) &#123;                    result.push("&lt;div class='xml_text xml_level" +                                 (level + 1) + "'&gt;");                    result.push(this.nodeValue);                    result.push("&lt;/div&gt;");                &#125;            &#125;);                        result.push("&lt;div class='xml xml_level" + level + "'&gt;");            result.push("&lt;span class='xml_punc'&gt;&amp;lt;/&lt;/span&gt;");            result.push("&lt;span class='xml_tag'&gt;");            result.push(xml.tagName);            result.push("&lt;/span&gt;");            result.push("&lt;span class='xml_punc'&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;");        &#125;                return result.join("");    &#125;,    text_to_xml: function (text) &#123;        var doc = null;        if (window['DOMParser']) &#123;            var parser = new DOMParser();            doc = parser.parseFromString(text, 'text/xml');        &#125; else if (window['ActiveXObject']) &#123;            var doc = new ActiveXObject("MSXML2.DOMDocument");            doc.async = false;            doc.loadXML(text);        &#125; else &#123;            throw &#123;                type: 'PeekError',                message: 'No DOMParser object found.'            &#125;;        &#125;        var elem = doc.documentElement;        if ($(elem).filter('parsererror').length &gt; 0) &#123;            return null;        &#125;        return elem;    &#125;&#125;;$(document).ready(function () &#123;    $('#login_dialog').dialog(&#123;        autoOpen: true,        draggable: false,        modal: true,        title: 'Connect to XMPP',        buttons: &#123;            "Connect": function () &#123;                $(document).trigger('connect', &#123;                    jid: $('#jid').val(),                    password: $('#password').val()                &#125;);                                $('#password').val('');                $(this).dialog('close');            &#125;        &#125;    &#125;);    $('#disconnect_button').click(function () &#123;        Peek.connection.disconnect();    &#125;);    $('#send_button').click(function () &#123;        var input = $('#input').val();        var error = false;        if (input.length &gt; 0) &#123;            if (input[0] === '&lt;') &#123;                var xml = Peek.text_to_xml(input);                if (xml) &#123;                    Peek.connection.send(xml);                    $('#input').val('');                &#125; else &#123;                    error = true;                &#125;            &#125; else if (input[0] === '$') &#123;                try &#123;                    var builder = eval(input);                    Peek.connection.send(builder);                    $('#input').val('');                &#125; catch (e) &#123;                    console.log(e);                    error = true;                &#125;            &#125; else &#123;                error = true;            &#125;        &#125;        if (error) &#123;            $('#input').animate(&#123;backgroundColor: "#faa"&#125;);        &#125;    &#125;);    $('#input').keypress(function () &#123;        $(this).css(&#123;backgroundColor: '#fff'&#125;);    &#125;);&#125;);$(document).bind('connect', function (ev, data) &#123;    var conn = new Strophe.Connection(        "http://bosh.metajack.im:5280/xmpp-httpbind");    conn.xmlInput = function (body) &#123;        Peek.show_traffic(body, 'incoming');    &#125;;    conn.xmlOutput = function (body) &#123;        Peek.show_traffic(body, 'outgoing');    &#125;;    conn.connect(data.jid, data.password, function (status) &#123;        if (status === Strophe.Status.CONNECTED) &#123;            $(document).trigger('connected');        &#125; else if (status === Strophe.Status.DISCONNECTED) &#123;            $(document).trigger('disconnected');        &#125;    &#125;);    Peek.connection = conn;&#125;);$(document).bind('connected', function () &#123;    $('.button').removeAttr('disabled');    $('#input').removeClass('disabled').removeAttr('disabled');&#125;);$(document).bind('disconnected', function () &#123;    $('.button').attr('disabled', 'disabled');    $('#input').addClass('disabled').attr('disabled', 'disabled');&#125;);

输入测试及运行结果
控制出席打开Peek应用程序，登陆到XMPP服务器，输入&lt;presence/&gt;，然后点击Send按钮。
设置状态为已离开$pres().c('show').t("away").up().c('status').t("reading");

探测版本$iq(&#123;type:"get",id:"version",to:"jabber.org"&#125;).c("query",&#123;xmlns:"jabber:iq:version"&#125;);
或者
&lt;iq type='get' id='version1' to='jabber.org'&gt;&lt;query xmlns='jabber:iq:version'/&gt;&lt;/iq&gt;

没有反应，不知道为什么。
iq节错误$iq(&#123;type:"get",id:"version2",to:"gmail.com"&#125;).c("query",&#123;xmlns:"jabber:iq:version"&#125;);

&lt;iq type='get' id='info1' to='bad-room-123@conference.jabber.org'&gt;	&lt;query xmlns='http://jabber.org/protocol/disco#info' /&gt;&lt;/iq&gt;

message节错误$msg(&#123;to:'voidking@voidking.lit',type:'chat'&#125;).c('body').t('What think you of books ?');

presence节错误不知道怎么发送presence节错误信息，省略先。
结束语这篇文章也是摘自《XMPP高级编程》，void也不详细解释代码了，看不懂的地方，请小伙伴参考这本书。
参考文档《XMPP高级编程（作者Jack Moffitt）》《XMPP The Definitive Guide（作者Peter Saint-Andre, Kevin Smith, and Remko Tron?on）》前辈们的技术博客……
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>xmpp</tag>
      </tags>
  </entry>
  <entry>
    <title>XMPP学习笔记——Hello</title>
    <url>/dev-xmpp-note-hello/</url>
    <content><![CDATA[前言首先声明，我们将要写的这个小程序，是属于XMPP客户端的。以后要写的程序，也都是XMPP客户端的。
马上开始第一个XMPP程序了，真有点小激动呢！接下来，各位同学和void一起试试手吧！
准备编程之前，我们需要准备好环境和依赖的工具。
这个程序，我们需要Tomcat服务器、jquery.js、jquery-ui.js、jquery-ui.css、jquery-ui.theme.css、strophe.js、strophe.flxhr.js、flXHR.js以及依赖的文件。哦，还有一个XMPP账号。
下面简单介绍一下环境的准备和依赖工具的下载，最后提供打包好的工具。

本地服务器因为Hello程序是一个仅由HTML、CSS和JavaScript代码组成的Web应用程序，所以运行和测试它是非常简单的。
尽管flXHR库可用来执行跨域请求而无需任何服务器设置，但它并不允许我们在file://这样的URL下面运行，却请求http://URL 的应用程序。这意味着我们要使用Web服务器通过HTTP来访问Hello程序。
这里，void使用的是tomcat，任何其他Web服务器也可以胜任。或者，你也可以直接将代码上传到你的公网服务器。
jQueryjQuery库使得HTML和CSS的处理变得异常简单，它在XML（XMPP节）的操作方面也非常方便。
最新版本请到jQuery官网下载。
jQuery UIjQuery UI库提供了我们所需要的一些常见的用户界面构造块，包括对话框和标签页。
最新版本请到jQuery UI官网下载。
PS：最新的jquery.js和最新的jquery-ui.js可能会有兼容性问题，保险起见，最好使用jQuery UI官网提供的jquery.js。
StropheStrophe库使得编写XMPP客户端应用程序变得极其简单，而且它已有多种编程语言版本。当然，我们将使用Javascript版本。
最新版本请到Strophe官网下载。
flXHRStrophe能够使用flXHR（标准 XMLHttpRequest API的Flash替代技术）来简化Javascript同源策略的处理。通常，Javascript应用程序不能与外部服务器通信，但借助Flash和flXHR，Strophe能够克服这个限制。
最新版本请到flXHR官网下载。但是，void登不上去这个网站，也ping不到它的服务器，不知道是被屏蔽了还是下线了。
这里提供flXHR开源项目下载地址，很古老，三年前的，莫非这个项目有了更好的替代品？不再更新了？不管了，我们先用着。经过测试，这个项目还是可以使用的。
国内github的下载速度真的让人绝望，尤其下载稍大的项目，看着几K的下载速度，哭的心都有了：大哥，你是要我等到天荒地老吗？
void通过网盘离线下载成功，需要的同学自己取吧，下载地址http://yunpan.cn/cAtFDZVWCJ6QX （提取码：1429）。
flXHR.js依赖的文件较多，这个程序中具体用到的有flensed.js、checkplayer.js、flXHR.swf、flXHR.vbs、swfobject.js、updateplayer.swf。
XMPP账号假设，qq开源，你要写一个qq客户端，想要测试能否连接到qq的服务器，首先要有个qq号吧？一个道理，做测试之前，我们要先有一个XMPP账号。
虽然http://register.jabber.org 已经下线，但是我们可以找到很多其他免费的公共XMPP服务器，这里给出一个列表https://xmpp.net/directory.php 。
这里绝大部分服务器是国外的，速度比较慢，于是void在自己的阿里云上搭建了一个openfire服务器。当然，你也可以本地搭建服务器，然后通过局域网访问。
找到或者搭建好XMPP服务器，然后，下载安装spark，看看能否注册和登陆，测试是否可用。
至此，假设我们已经拥有了一个XMPP账号。没有搞定的小伙伴请留言。
工具打包下载上面提到的工具，以及Hello程序的代码，打包到360网盘了，需要的小伙伴自取http://yunpan.cn/cAnXNmvewvGme  （提取码 baaf）
具体步骤这个程序的功能是：向XMPP服务器发送一条信息并将响应显示出来。下面我们来一步一步完成它！
目录结构接下来的文件放置位置，请下载“工具打包下载”一节的压缩文件，用作参考。文件位置不对的话，需要修改代码，相信你们都懂得。
hello.html新建文件hello.html，内容如下：
&lt;!DOCTYPE HTML&gt;&lt;html&gt;  &lt;head&gt;    &lt;title&gt;Hello&lt;/title&gt;        &lt;link rel="stylesheet" type="text/css" href="./style/jquery-ui.css" &gt;	&lt;link rel="stylesheet" type="text/css" href="./style/jquery-ui.theme.css" &gt;		&lt;script type="text/javascript" src="./js/jquery.js"&gt;&lt;/script&gt;	&lt;script type="text/javascript" src="./js/jquery-ui.js"&gt;&lt;/script&gt;	    &lt;script type="text/javascript" src="./js/strophe.js"&gt;&lt;/script&gt;       &lt;script type="text/javascript" src='./js/strophe.flxhr.js'&gt;&lt;/script&gt;	&lt;script type="text/javascript" src='./js/flXHR.js'&gt;&lt;/script&gt;    &lt;link rel='stylesheet' type="text/css" href='./style/hello.css'&gt;    &lt;script type="text/javascript" src='./js/hello.js'&gt;&lt;/script&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;h1&gt;Hello&lt;/h1&gt;    &lt;div id='log'&gt;    &lt;/div&gt;    &lt;!-- login dialog --&gt;    &lt;div id='login_dialog' class='hidden'&gt;      &lt;label&gt;JID:&lt;/label&gt;&lt;input type='text' id='jid'&gt;      &lt;label&gt;Password:&lt;/label&gt;&lt;input type='password' id='password'&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;

hello.css新建hello.css文件，内容如下：
body &#123;    font-family: Helvetica;&#125;h1 &#123;    text-align: center;&#125;.hidden &#123;    display: none;&#125;#log &#123;    padding: 10px;&#125;

hello.js新建hello.js文件，内容如下：
var Hello = &#123;    connection: null,    start_time: null,    log: function (msg) &#123;        $('#log').append("&lt;p&gt;" + msg + "&lt;/p&gt;");    &#125;,    send_ping: function (to) &#123;        var ping = $iq(&#123;            to: to,            type: "get",            id: "ping1"&#125;).c("ping", &#123;xmlns: "urn:xmpp:ping"&#125;);        Hello.log("Sending ping to " + to + ".");        Hello.start_time = (new Date()).getTime();        Hello.connection.send(ping);    &#125;,    handle_pong: function (iq) &#123;        var elapsed = (new Date()).getTime() - Hello.start_time;        Hello.log("Received pong from server in " + elapsed + "ms.");        Hello.connection.disconnect();                return false;    &#125;&#125;;$(document).ready(function () &#123;    $('#login_dialog').dialog(&#123;        autoOpen: true,        draggable: false,        modal: true,        title: 'Connect to XMPP',        buttons: &#123;            "Connect": function () &#123;                $(document).trigger('connect', &#123;                    jid: $('#jid').val(),                    password: $('#password').val()                &#125;);                                $('#password').val('');                $(this).dialog('close');            &#125;        &#125;    &#125;);&#125;);$(document).bind('connect', function (ev, data) &#123;    var conn = new Strophe.Connection(        "http://bosh.metajack.im:5280/xmpp-httpbind");    conn.connect(data.jid, data.password, function (status) &#123;        if (status === Strophe.Status.CONNECTED) &#123;            $(document).trigger('connected');        &#125; else if (status === Strophe.Status.DISCONNECTED) &#123;            $(document).trigger('disconnected');        &#125;    &#125;);    Hello.connection = conn;&#125;);$(document).bind('connected', function () &#123;    // inform the user    Hello.log("Connection established.");    Hello.connection.addHandler(Hello.handle_pong, null, "iq", null, "ping1");    var domain = Strophe.getDomainFromJid(Hello.connection.jid);        Hello.send_ping(domain);&#125;);$(document).bind('disconnected', function () &#123;    Hello.log("Connection terminated.");    // remove dead connection object    Hello.connection = null;&#125;);
上面Javascript的代码由三个基本部分组成。首先是应用程序的命名空间对象，应用程序的状态和函数都在此定义。位于命名空间对象之后的是文档准备就绪事件处理程序，一旦浏览器准备就绪它就会初始化应用程序。最后是自定义事件处理程序，它负责处理那些不是由元素或用户交互触发的程序。
命名空间对象我们使用命名空间对象，尽可能避免使用全局变量，这样可以将问题降到最少。上面代码中的Hello对象就是一个例子。
文档就绪事件处理程序一旦DOM可供JavaScript代码使用，就会立即引发文档准备就绪事件。一般而言，最好将初始化代码放在这里。
自定义事件处理程序jQuery库是的创建和使用自定义事件变得非常容易，这些自定义事件通常用来提高代码的可读性并减少组件之间的耦合度。
发布上面三个文件，详解请读书《XMPP高级编程》（提取码 20fb），内容太多，不码字了。
完成之后，把整个工程文件夹拷贝到tomcat的webapp文件夹下。然后，启动tomcat，就可以访问了。
最终效果
结束语如果最终效果是你期望的，恭喜你，至少你已经知其然了！
参考文档《XMPP高级编程（作者Jack Moffitt）》《XMPP The Definitive Guide（作者Peter Saint-Andre, Kevin Smith, and Remko Tron?on）》前辈们的技术博客……
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>xmpp</tag>
      </tags>
  </entry>
  <entry>
    <title>XMPP学习笔记——概述篇</title>
    <url>/dev-xmpp-note-start/</url>
    <content><![CDATA[XMPP是什么？XMPP，可扩展消息和出席（存在）协议（eXtensible Messageing and Presence Protocol）。顾名思义，这是一个关于收发消息的规范。
最初研发IMPP（即时信息和出席协议，Instant Messaging and Presence Protocol）是为了创建一种标准化的协议，但是今天，IMPP已经发展成为基本协议单元，定义所有即时通信协议应该支持的核心功能集。
XMPP和SIMPLE（针对即时信息和出席扩展的会话发起协议，Session Initiation Protocol for Instant Messaging and Presence Leveraging Extensions）两种协议是架构，有助于实现IMPP协议所描述的规范。
PRIM（出席和即时信息协议，Presence and Instant Messaging Protocol）最初是基于即时通信的协议，与XMPP 和SIMPLE 类似，但是已经不再使用。

XMPP简史1996年之后，Mirabilis、AOL、Yahoo、微软等互联网公司陆续推出了个人通信产品。但是，这些产品各自绑定到各自专用的协议和网络。也就是说，ICQ的用户不能和MSN的用户交谈。
很多开发人员希望整合客户端，但是屡屡受挫。开放的、去中心化的IM网络和协议思想在这个时候就诞生了，经过发展，后来便有了XMPP。
XMPP网络任何XMPP网络都是由若干角色组成的，这些角色可以分为服务器、客户端、组件和服务器插件。
服务器XMPP服务器是XMPP网络的交通系统，它的任务就是为XMPP节提供路由。
常见的XMPP服务器有Openfire、Ejabberd、Tigase、M-Link、Jabber-XCP等。
客户端大多数的XMPP实体是客户端，它们通过客户端-服务器协议连接到XMPP服务器。
组件并不只是客户端能连接到XMPP服务器，大多数服务器还支持外部服务器组件，这些组件通过添加某种新服务来增强服务器的行为。在外界看来，组件就像一个子服务器。

插件许多XMPP服务器支持插件扩展，这些插件通常使用与服务器自身相同的语言编写，并在服务器的进程内运行。他们的作用很大程度上与外部组件重叠，但插件还能够访问内部服务器数据结构并改变核心服务器行为。
XMPP寻址XMPP网络上每个实体都有一个或多个地址（JID，jabber identifier）。JID有多种不同形式，但它们通常看上去就像是电子邮件。
JID有两种类型，裸JID和完整JID，而裸JID是完整JID去除资源部分后的地址。例如，某个客户端的完整JID是voidking@voidking.lit/library，那么它的裸JID就是voidking@voidking.lit。
节在XMPP中，各项工作都是通过在一个XMPP流上发送和接收XMPP节来完成的。核心XMPP工具集由三种基本节组成，这三种节分别为&lt;presence&gt;、&lt;message&gt;、&lt;iq&gt;。
XMPP流由两份XML文档组成，通信的每个方向均有一份文档。这份文档有一个根元素&lt;stream:stream&gt;，这个根元素的子元素由可路由的节以及与流相关的顶级子元素构成。下面给出一段简短的XMPP会话：
&lt;stream:stream&gt;	&lt;iq type='get'&gt;		&lt;query xmlns='jabber:iq:roster'/&gt;	&lt;/iq&gt;		&lt;presence/&gt;		&lt;message to='voidking@voidking.lit' from='haojin@gmail.com/ballroom' type='chat'&gt;		&lt;body&gt;I cannot talk of books in a ball-room; my head is always full of something else.&lt;/body&gt;	&lt;/message&gt;		&lt;presence type='unavailable'/&gt;&lt;/stream:stream&gt;
简单解释下：（1）haojin登陆后，将自己的第一节（一个&lt;iq&gt;元素）发送出去，这个&lt;iq&gt;元素请求haojin的联系人列表。（2）接下来，他使用&lt;presence&gt;节通知服务器他在线并且可以访问。（3）当haojin注意到voidking也在线时，他发送了一条&lt;message&gt;节给voidking。（4）最后，haojin发送了一个&lt;presence&gt;节告诉服务器自己不可访问并关闭&lt;stream:stream&gt;元素，然后结束会话。
通用属性所有三种节都支持一组通用的属性：（1）from（2）to（3）type（4）id
presence节&lt;presence&gt;节控制并报告实体的可访问性，“在线”、“离线”、“离开”、“请勿打扰”。此外，这个节还用来建立和终止向其他实体发布出席订阅。
普通presence节普通&lt;presence&gt;节不含type属性，或者type属性值为unavailable或error。type属性没有available值，因为可以通过缺少type属性来指出这种情况。
用户通过发送不带to属性，直接发往服务器的&lt;presence&gt;节来操纵自己的出席状态。
&lt;presence/&gt;&lt;presence type='unavailable'/&gt;&lt;presence&gt;	&lt;show&gt;away&lt;/show&gt;	&lt;status&gt;at the ball&lt;/status&gt;&lt;presence/&gt;&lt;presence&gt;	&lt;status&gt;touring the countryside&lt;/status&gt;	&lt;priority&gt;10&lt;/priority&gt;&lt;/presence&gt;&lt;presence&gt;	&lt;priority&gt;10&lt;/priority&gt;&lt;/presence&gt;
简单解释：（1）&lt;show&gt;元素用来传达用户的可访问性，只能出现在&lt;presence&gt;节中。该元素的值可以为：away、chat、dnd和xa，分别表示离开、有意聊天、不希望被打扰和长期离开。（2）&lt;status&gt;元素时一个人类可读的字符串，在接收者的聊天客户端中，这个字符串一般会紧挨着联系人名字显示。（3）&lt;priority&gt;元素用来指明连接资源的优先级，介于-128~127，默认值为0。
扩展presence节开发人员希望能够扩展&lt;presence&gt;节以包含更详细的信息，比如用户当前听的歌或个人的情绪。因为&lt;presence&gt;节会广播给所有联系人，并且在XMPP网络流量中占据了很大的份额，所以不鼓励这种做法。这类扩展应该交给额外信息传送协议来处理。
出席订阅用户的服务器会自动地将出席信息广播给那些订阅该用户出席信息的联系人。类似的，用户从所有他已经出席订阅的联系人那里接收到出席更新信息。与一些社交网络和IM系统不同，在XMPP中，出席订阅是有方向的。我订阅了你的出席信息，但是你并不一定订阅了我的出席信息。可以通过设置type的值来识别出席订阅节：subscribe、unsubscribe、subscribed、unsubscribed。
定向出席定向出席是一种直接发给另一个用户或其他实体的普通&lt;presence&gt;节，这种节用来向那些没有进行出席订阅（通常因为只是临时需要出席信息）的实体传达出席状态信息。
message节&lt;message&gt;节用来从一个实体向另一个实体发送消息。这些可以是简单的聊天信息，也可以是任何结构化信息。例如，绘制指令、游戏状态和新游戏变动状况。
&lt;message&gt;属于发送后不管的类型，没有内在的可靠性，就像电子邮件一样。在有些情况下（比如向不存在的服务器发送信息），发送者可能会收到一个错误提示节，从中了解出现的问题。可以通过在应用程序协议中增加确认机制来实现可靠传送。
消息类型&lt;message&gt;节有几种不同的类型，这些类型由type属性指出，可取的值有：chat、error、normal、groupchat和headline。该属性是可选的，如果没有指定type值，默认为normal。
消息内容尽管&lt;message&gt;节可以包含任意扩展元素，但&lt;body&gt;和&lt;thread&gt;元素是为向消息中添加内容提供的正常机制。这两种子元素均是可选的。
IQ节&lt;iq&gt;节表示的是Info/Query，它为XMPP通信提供请求和响应机制。它与HTTP协议的基本工作原理非常相似，允许获取和设置查询，与HTTP的GET和POST动作类似。&lt;iq&gt;节有四种，通过type属性区分，其中两种请求get和set，两种响应result和error。每一个IQ-get或IQ-set节均必须接收响应的IQ-result和IQ-error节。此外，每一对&lt;iq&gt;必须匹配id属性。
error节所有三种XMPP节都有一个error类型，而且错误提示节的每种类型的内容都是按照同一模式排列。错误提示节具有定义明确的的结构，通常包含原节（肇事节）的内容、通用错误信息以及应用程序特有的错误条件和信息（可选）。
连接生命周期通过三种基本节，实际上可以完成XMPP中任何任务，但发送XMPP节通常需要建立一个经过身份验证的XMPP会话。
连接在发送任何节之前，需要建立XMPP流。在XMPP流存在之前，必须建立通往XMPP服务器的连接。
流的建立一旦建立通往XMPP服务器的连接，XMPP流就启动了。通过向服务器发送起始元素&lt;stream:stream&gt;，就可打开XMPP流。服务器通过发送响应流起始标记&lt;stream:stream&gt;进行相应。一旦双向建立XMPP流，就可以来回发送各种元素。
身份验证XMPP允许进行TLS（Transport Layer Security，传输层安全）加密，而且大多数客户端默认使用该功能。一旦服务器通告TLS支持后，客户端就启动TLS连接并将当前套接字升级为一个加密套接字而不断开连接。一旦TLS加密确立，就会创建一对新的XMPP流。
连接断开当用户结束XMPP会话时，会终止会话并断开连接。一般终止会话方式是，首先发送无效出席信息，然后关闭&lt;stream:stream&gt;元素。
XMPP通信流程(1)节点连接到服务器；(2)服务器利用本地目录系统中的证书对其认证；(3)节点指定目标地址，让服务器告知目标状态；(4)服务器查找、连接并进行相互认证；(5)节点之间进行交互．
XMPP优势与HTTP相比，XMPP具有如下的优势：（1）能够“推送”数据，而不是“拉”。（2）防火墙友好（3）牢固的身份验证和安全机制（4）为许多不同的问题提供大量即开即用的工具
XMPP不足每种协议都有各自的优缺点，在许多场合中XMPP并不是完成任务的最佳工具或受到某种限制。（1）有状态协议（2）社区和部署不及HTTP广泛（3）对于简单的请求，其开销比HTTP大（4）仍然需要专门的实现
桥接XMPP和Web虽然有几款浏览器正在试验一些功能以利用XMPP，但主流浏览器目前还没有内置XMPP协议支持。但通过某种巧妙的编程和一些服务器端的帮助，我们可以在HTTP连接之上建立高效的XMPP会话通道。
是这种高效通道成为可能的是一项名为HTTP长轮询的技术。通过联合使用一个简单的基于HTTP的管理协议以及XMPP连接管理器，我们可以将XMPP（以及它的所有功能）带入到HTTP应用程序中。
长轮询如果读者曾在一个专横的老板下面工作，他会不停地问：“软件还没有写完吗？”这其实就是轮询。
尽管服务器不会被激怒，但是如果太多客户端过快地轮询，服务器也可能变得缓慢。如果不停地被打扰，那么完成的工作量就会减少。但是为了获取快速更新，轮询的间隔必须相当短，最低的延迟就是轮询间隔的长度。
轮询的另一个问题是大多数轮询请求并没有接收到新数据，就像给专横雇主的答复一样，服务器对“软件还没有写完吗？”问题的答案总是“还没有”。
一些聪明的家伙，发明了一种巧妙的技术来解决这个问题。它们并不立即响应该请求，而是在新数据没有准备好时将其挂起一段时间。
例如，如果服务器上新数据已经准备就绪，那么服务器会立即应答。如果尚无新数据，那么服务器将保持连接的打开状态，并持有所有应答。一旦新数据到达，它最终会响应该请求。如果在一定时间内没有新数据到达，服务器可以发回一个空的响应，这样就不会一次性锁住过多打开的连接。一旦一个请求返回，客户端就会立即发送一个新的请求，整个过程重新开始。
因为每个轮询请求都可能打开较长的时间，所以这种技术被称为长轮询。
轮询和长轮询的唯一真正改变之处是，不让客户端等待重新发送请求，而是让服务器等待直到其有新数据需要通告才响应请求。
该技术的一个缺点是服务器需要更聪明才可以处理这些长轮询请求，而这正是连接管理器的作用所在。
管理连接XMPP连接可以持续任意长的时间，但HTTP请求却相当短命。连接管理器负责维护第三方的XMPP连接并通过HTTP长轮询技术来提供对连接的访问。
浏览器和连接管理器使用一种名为BOSH的简单协议通过HTTP进行通信。实际上，BOSH帮助HTTP客户端建立一个新的XMPP会话，然后将XMPP节包装到一个特殊的&lt;body&gt;元素中通过HTTP来回传送。它还提供了一些安全功能以确保XMPP会话不会轻易地被劫持。连接管理器和XMPP服务器通信就像它是一个普通的客户端一样。
这样一来，HTTP应用程序就能够控制一个真正的XMPP会话。由于长轮询及时提供的高效率和低延迟，因此它的性能相当好，足矣匹敌原生连接。
让Javascript理解XMPP协议利用HTTP长轮询，我们就拥有了从服务器获取低延迟数据更新的技术。将该技术与连接管理器组合起来，我们就能够通过一系列HTTP请求来发送和接受XMPP数据。最后，我们还需要简化该技术在Web的原生编程语言Javascript中的实现。
Strophe库的创建宗旨，就是为了让使用Javascript编写XMPP应用程序，能够想采用任何其他语言一样简单，将托管连接的底层细节全部隐藏起来。就Strophe的用户而言，它看上去就跟在任何其他环境中所使用的原生XMPP连接一样。
构建XMPP应用程序浏览器平台Web浏览器可能是有史以来部署最广泛、使用最多的应用程序平台。XMPP为Web应用程序带来了一套新技术和抽象概念，同时带来的是实时、交互式和协作式应用程序的巨大潜力。
对于XMPP开发人员来说，将Web浏览器定位为目标平台有着巨大的意义。Web应用程序跨平台、易于部署，而且有着巨大的用户基础。此外，Web技术大量使用HTML，而用于HTML的工具通常也都能很好地用于XML，因而也能用于XMPP。
基础设施就像Web通常需要一个Web服务器和应用程序服务器或框架，XMPP应用程序也需要一些基础设施。
XMPP连接要求有一台XMPP服务器，而且通常在该服务器上会有一个账户。XMPP应用程序还需要与连接管理器进行通信，这是因为浏览器目前还无法原生地理解XMPP协议。最后，应用程序使用的任何服务也必须由XMPP服务器提供。
协议设计如果不是在创建现有XMPP服务（比如多人聊天或传统IM功能），那么用户可能在进行某种协议涉及来实现自己的梦想。XMPP提供了大量的工具可作为工作基础，而且通常，将这些工具进行简单组合，就足够满足大多数应用程序的需要。下面有几条指南：（1）组合现有协议。（2）保持简洁。（3）避免扩展出席。（4）参与社区。
参考文档《XMPP高级编程（作者Jack Moffitt）》《XMPP The Definitive Guide（作者Peter Saint-Andre, Kevin Smith, and Remko Tron?on）》前辈们的技术博客……
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>jquery</tag>
        <tag>xmpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Yii框架实战</title>
    <url>/dev-yii-in-action/</url>
    <content><![CDATA[前言新入手的项目需要使用Yii框架开发，那就仿照之前写的《ThinkPHP实战》，整理一下必须掌握的三个部分：路由控制、模板渲染、增删改查。


环境准备参照《ThinkPHP开发环境搭建》。
下载安装1、下载Yii2的基本应用程序模板。
2、解压出basic目录。
3、移动basic目录到wampserver的www目录下。
4、修改 basic/config/web.php 文件，给 cookieValidationKey 配置项 添加一个密钥：
'cookieValidationKey' =&gt; 'voidking',

5、启动wampserver，浏览器访问：http://localhost/basic/web/index.php 。如果安装成功，就会看到“Congratulations! You have successfully created your Yii-powered application.”。
项目结构basic/                  应用根目录    composer.json       Composer 配置文件, 描述包信息    config/             包含应用配置及其它配置        console.php     控制台应用配置信息        web.php         Web 应用配置信息    commands/           包含控制台命令类    controllers/        包含控制器类    models/             包含模型类    runtime/            包含 Yii 在运行时生成的文件，例如日志和缓存文件    vendor/             包含已经安装的 Composer 包，包括 Yii 框架自身    views/              包含视图文件    web/                Web 应用根目录，包含 Web 入口文件        assets/         包含 Yii 发布的资源文件（javascript 和 css）        index.php       应用入口文件    yii                 Yii 控制台命令执行脚本

一般来说，应用中的文件可被分为两类：在 basic/web 下的和在其它目录下的。 前者可以直接通过 HTTP 访问，后者不能也不应该被直接访问。
helloworld创建动作对于“Hello”任务，需要创建一个 say 动作， 从请求中接收 message 参数并显示给最终用户。如果请求没有提供 message 参数， 动作将显示默认参数 “Hello”。

 动作是最终用户可以直接访问并执行的对象。 动作被组织在控制器中。 一个动作的执行结果就是最终用户收到的响应内容。

动作必须声明在控制器中。为了简单起见， 你可以在现存的 SiteController 控制器里声明 say 动作。这个控制器定义在 controllers/SiteController.php 类文件中。 以下是一个动作的声明：
&lt;?phpnamespace app\controllers;use yii\web\Controller;class SiteController extends Controller&#123;    // ...现存的代码...    public function actionSay($message = 'Hello')    &#123;        return $this-&gt;render('say', ['message' =&gt; $message]);    &#125;&#125;

在上述 SiteController 代码中，say 动作被定义为 actionSay 方法。 Yii 使用 action 前缀区分普通方法和动作。 action 前缀后面的名称被映射为动作的 ID。
动作 ID 总是被以小写处理，如果一个操作 ID 由多个单词组成， 单词之间将由破折号连接（如 create-comment）。动作 ID 映射为方法名时移除了破折号， 将每个单词首字母大写，并加上 action 前缀。 比如：动作 ID create-comment 对应方法名 actionCreateComment。
上述代码中的动作方法接受一个参数 message，它的默认值是 “Hello”。 
在动作方法中，yii\web\Controller::render() 被用来渲染一个名为 say 的视图文件。 message 参数也被传入视图，这样就可以在里面使用。动作方法会返回渲染结果。 结果会被应用接收并显示给最终用户的浏览器（作为整页 HTML 的一部分）。
创建视图视图是你用来生成响应内容的脚本。为了说 “Hello”， 你需要创建一个 say 视图，以便显示从动作方法中传来的 message 参数。
&lt;?phpuse yii\helpers\Html;?&gt;&lt;?= Html::encode($message) ?&gt;

say 视图应该存为 views/site/say.php 文件。当一个动作中调用了 yii\web\Controller::render() 方法时， 它将会寻找名为 views/控制器 ID/视图名.php 的PHP文件。。
当然了，你大概会在 say 视图里放入更多内容。内容可以由 HTML 标签，纯文本， 甚至 PHP 语句组成。实际上 say 视图就是一个由 yii\web\Controller::render() 执行的 PHP 脚本。 视图脚本输出的内容将会作为响应结果返回给应用。应用将依次输出结果给最终用户。
试运行创建完动作和视图后，你就可以通过下面的 URL 访问新页面了：http://localhost/basic/web/index.php?r=site/say&amp;message=helloworld
路由控制URL美化从上面的helloworld例子中，我们看出，访问的URL分成几个部分：

表示主机信息的 http://localhost/basic/web/
表示入口脚本的 index.php
表示路由的 r=site/say
表示普通参数的 message=helloworld

该URL，如果变形成 http://localhost/basic/web/index.php/site/say?message=helloworld ，是不是好看很多？
该URL，如果变形成 http://localhost/basic/web/site/say?message=helloworld ，是不是更好看？
该URL，如果变形成 http://localhost/basic/web/say?message=helloworld ，是不是更好看？
该URL，如果变形成 http://localhost/basic/web/say/helloworld ，是不是更好看？
Yii有专门的 yii\web\UrlManager 来进行处理，其中：

隐藏入口脚本可以通过 yii\web\UrlManager::showScriptName = false 来实现
路由的路径化可以通过 yii\web\UrlManager::enablePrettyUrl = true 来实现
参数的路径化可以通过路由规则来实现
加入假后缀(fake suffix) .html 可以通过 yii\web\UrlManager::suffix = &#39;.html&#39; 来实现

路由规则路由规则是指 urlManager 用于解析请求或生成URL的规则。
1、打开basic/config/web.php，找到urlManager，取消注释。
'urlManager' =&gt; [    'enablePrettyUrl' =&gt; true,    'showScriptName' =&gt; false,    'rules' =&gt; [    ],],

这时，http://localhost/basic/web/index.php/site/say?message=helloworld 就可以使用了。
2、找到apache的配置文件httpd.conf，去掉去掉rewrite前的#。
LoadModule rewrite_module modules/mod_rewrite.so

3、在index.php所在目录，添加.htaccess文件（不添加该文件也可以）。
Options +FollowSymLinks  IndexIgnore */*  RewriteEngine on  # if a directory or a file exists, use it directly  RewriteCond %&#123;REQUEST_FILENAME&#125; !-f  RewriteCond %&#123;REQUEST_FILENAME&#125; !-d# otherwise forward it to index.php  RewriteRule . index.php

这时，http://localhost/basic/web/site/say?message=helloworld 就可以使用了。
4、打开basic/config/web.php，修改rules。
'urlManager' =&gt; [    'enablePrettyUrl' =&gt; true,    'showScriptName' =&gt; false,    'rules' =&gt; [        'say' =&gt; 'site/say'    ],],

这时，http://localhost/basic/web/say?message=helloworld 就可以使用了。
5、继续修改rules。
'urlManager' =&gt; [    'enablePrettyUrl' =&gt; true,    'showScriptName' =&gt; false,    'rules' =&gt; [        'say' =&gt; 'site/say',        'say/&lt;message:\w+&gt;'=&gt;'site/say'    ],],

这时， http://localhost/basic/web/say/helloworld 就可以使用了。
模板渲染默认模板引擎1、在controllers/SiteController.php中添加函数：
public function actionTemplate()&#123;    $data = '测试数据';    $dataArr = array(        array('name'=&gt;'郝锦','age'=&gt;'24'),        array('name'=&gt;'小帅','age'=&gt;'22'),        array('name'=&gt;'小飞','age'=&gt;'22')    );    $dataObj = new userInfo();    return $this-&gt;render('template',         ['data' =&gt; $data,        'dataArr' =&gt; $dataArr,        'dataObj' =&gt; $dataObj        ]);&#125;

2、同时，在文件最后添加一个userInfo类：
class userInfo&#123;    public $name = '郝锦';    public $age = '24';    function show()&#123;        echo '一个函数';    &#125;&#125;

3、在views/site中添加template.php：
&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Template&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;模板&lt;/h1&gt;    &lt;p&gt;&lt;?php echo $data; ?&gt;&lt;/p&gt;    &lt;p&gt;&lt;?php echo $dataObj-&gt;name; ?&gt;&lt;/p&gt;    &lt;p&gt;&lt;?php echo $dataObj-&gt;age; ?&gt;&lt;/p&gt;    &lt;p&gt;        &lt;?php             foreach ($dataArr as $value) &#123;                echo $value['name'];                echo $value['age'];            &#125;        ?&gt;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

4、测试访问url： http://localhost/basic/web/site/template
smarty上面的渲染中，我们发现，template.php中的写法不友好。因为默认情况下，Yii 使用 PHP 作为其默认的模板引擎语言。但是，我们可以配置 Yii 以扩展的方式支持其他的渲染引擎， 比如 Twig 或 Smarty等。下面我们把模板引擎换成smarty。
1、下载安装Composer。
2、在basic目录，执行命令composer require --prefer-dist yiisoft/yii2-smarty，安装smarty插件。
如果提示输入token，解决办法为：进入 https://github.com/settings/tokens 点击 「Generate new token」 新建一个 Token，选择默认新建就行，然后就会得到一个 Token，然后输入这个值就 OK 了。
3、打开basic/config/web.php，找到components，添加使用smarty：
'components' =&gt; [    // other settings    'view' =&gt; [        'renderers' =&gt; [            'tpl' =&gt; [                'class' =&gt; 'yii\smarty\ViewRenderer',                //'cachePath' =&gt; '@runtime/Smarty/cache',            ],        ],    ],],

4、修改actionTemplate为：
public function actionTemplate()&#123;    $data = '测试数据';    $dataArr = array(        array('name'=&gt;'郝锦','age'=&gt;'24'),        array('name'=&gt;'小帅','age'=&gt;'22'),        array('name'=&gt;'小飞','age'=&gt;'22')    );    $dataObj = new userInfo();    return $this-&gt;render('template.tpl',         ['data' =&gt; $data,        'dataArr' =&gt; $dataArr,        'dataObj' =&gt; $dataObj        ]);&#125;

5、在views/site中添加template.tpl：
&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Template&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;模板&lt;/h1&gt;    &lt;p&gt;&#123;$data&#125;&lt;/p&gt;    &lt;p&gt;&#123;$dataObj-&gt;name&#125;&lt;/p&gt;    &lt;p&gt;&#123;$dataObj-&gt;age&#125;&lt;/p&gt;    &lt;p&gt;        &#123;foreach from=$dataArr key=mykey item=$value&#125;            &#123;$value.name&#125;&amp;nbsp;&#123;$value.age&#125;        &#123;/foreach&#125;    &lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

6、测试访问url： http://localhost/basic/web/site/template
增删改查数据库配置利用navicat等工具连接到本地mysql数据库，创建数据库basic，在数据库中创建表bas_project(int id, varchar title, varchar content)。注意，编码格式选择utf8。
连接配置打开basic/config/db.php，修改内容如下：
&lt;?phpreturn [    'class' =&gt; 'yii\db\Connection',    'dsn' =&gt; 'mysql:host=localhost;dbname=basic',    'username' =&gt; 'root',    'password' =&gt; '',    'charset' =&gt; 'utf8',    'tablePrefix' =&gt; 'bas_',];

新建model在basic/models下，新建Project.php，内容如下：
&lt;?phpnamespace app\models;use yii\db\ActiveRecord;/** * Project model */class Project extends ActiveRecord&#123;    public static function model($className=__CLASS__)    &#123;        return parent::model($className);    &#125;&#125;

新建Controller在basic/controllers下，新建ProjectController.php，内容如下：
&lt;?phpnamespace app\controllers;use Yii;use yii\filters\AccessControl;use yii\web\Controller;use yii\filters\VerbFilter;use app\models\LoginForm;use app\models\ContactForm;use app\models\Project;class ProjectController extends Controller&#123;    public function actionAdd($title, $content)&#123;        $project = new Project();        $project-&gt;title = $title;        $project-&gt;content = $content;         $success = $project-&gt;save();        if($success)&#123;            $result = array(                'code' =&gt; '0',                'ext' =&gt; 'success'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);        &#125;    &#125;    public function actionEdit($id, $title, $content)&#123;        $project = Project::find()-&gt;where(['id'=&gt;$id])-&gt;one();        $project-&gt;title = $title;        $project-&gt;content = $content;        $success = $project-&gt;save();        if($success)&#123;            $result = array(                'code'=&gt; '0',                'ext'=&gt; 'success'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);        &#125;else &#123;            $result = array(                'code'=&gt; '1',                'ext'=&gt; 'fail'            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);        &#125;    &#125;    public function actionDelete($id)&#123;        $project = Project::find()-&gt;where(['id'=&gt;$id])-&gt;one();        $success = $project-&gt;delete();        if($success)&#123;            $result = array(                'code'=&gt; '0',                'ext'=&gt; 'success'            );            echo json_encode($result);        &#125;else &#123;            $result = array(                'code'=&gt; '1',                'ext'=&gt; 'fail'            );            echo json_encode($result);        &#125;    &#125;    public function actionList()&#123;        $projectList = Project::find()-&gt;asArray()-&gt;all();        $result = array(                'code'=&gt; '0',                'ext'=&gt; 'success',                'projectList' =&gt; $projectList        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;    public function actionPage($pageSize,$pageNum)&#123;        $project = new Project();        $total = $project-&gt;find()-&gt;count();        $totalPage = $total%$pageSize ? (int)($total/$pageSize)+1 : (int)($total/$pageSize);        $projectList = $project-&gt;find()-&gt;offset(($pageNum-1)*$pageSize)-&gt;limit($pageSize)-&gt;asArray()-&gt;all();                if($projectList)&#123;            $resultArr = array(                'totalPage'=&gt; $totalPage,                'pageNum'=&gt; $pageNum,                'projectList'=&gt; $projectList            );            $result = array(                'code'=&gt; '0',                'ext'=&gt; 'success',                'obj'=&gt; $resultArr            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);        &#125;    &#125;    public function actionFind($id)&#123;        $project = new Project();        $item = $project-&gt;find()-&gt;where(['id'=&gt;$id])-&gt;asArray()-&gt;one();        $result = array(            'code'=&gt; '0',            'ext'=&gt; 'success',            'obj'=&gt; $item        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;&#125;

测试接口1、添加：http://localhost/basic/web/project/add?title=voidking-title&amp;content=voidking-content
2、修改：http://localhost/basic/web/project/edit?id=1&amp;title=voidking-title&amp;content=voidking-content
3、查找全部：http://localhost/basic/web/project/list
4、查找一页：http://localhost/basic/web/project/page?pageSize=10&amp;pageNum=1
5、查找一条：http://localhost/basic/web/project/find?id=1
6、删除：http://localhost/basic/web/project/delete?id=1
路由控制、模板渲染、增删改查，至此全部跑通，可以进行简单的开发了。至于yii框架提供的其他更加强大的功能，在需要时查查文档就好。
源码分享1、下载安装：git clone https://github.com/voidking/yii-basic.git basic
2、利用navicat等工具连接到本地mysql数据库，创建数据库basic，在数据库中创建表bas_project(int id, varchar title, varchar content)。注意，编码格式选择utf8。
书签Yii Framework中文社区
下载安装Yii
Yii 2.0 权威指南 
URL Management(网址管理)
Yii2.0数据库操作增删改查详解
ActiveRecord
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>yii</tag>
      </tags>
  </entry>
  <entry>
    <title>B533史记</title>
    <url>/essay-b533-history/</url>
    <content><![CDATA[一天晚上，小胖发了个说说：我要改掉坏习惯！第二天，他果然改掉了上课睡觉和玩手机的坏习惯。因为他没去上课……
——“郝哥哥，你真帅！”——“低调低调！”——“你不赞我一下？”——“你这求互赞呢！好吧，小黑你真帅！”……
高富帅的由来：刚开学，收到很多理发店传单，邓俊鹏和丁凯俩人一看很便宜，理发一次只要两元，就屁颠屁颠地去了。结果人家给理发到一半停下了，不断蛊惑让他们办会员卡。结果，丁凯办了一张黄金VIP卡，500；邓俊鹏办了一张钻石VIP卡，1000！从此以后，高富帅就诞生了……
突然有一天，高富帅做了个头发，300多，然后又买了5瓶化妆品，400多。我靠，奢侈的一比啊！然后我们看到兄弟宿舍的宋金峰发了个说说，大致内容是说邱浩买了一瓶化妆品，像是要相亲一样！看到这个说说，我们沉默了……富帅啊，你这是想勾搭多少妹子啊……
老胡，一朵奇葩，刚开学的时候特别开朗，各个宿舍跑着找人交流。后来……………………………………………………………………………………………………………………请问我们班还有比他更沉默的帅哥吗？唉，变身失败的孩纸伤不起啊…………
“介个，我跟你讲……”“我要睡觉了！”
“我要激活码！”“美女耶！”
“哔哔砰砰……”“我眺望远方的山峰……”
“bingo！”“当当当当！”“我靠，又吃到蒜了！”“哈喽，帅哥！”
“我决定了……”“我觉得吧，明天不上课了！”
“这不科学！”“关我毛事！”
老胡：“我决定了，下午好好学习，再也不lol了，玩腻了都！”吃完午饭，老胡继续lol……小杰：“老胡，你不是说下午好好学习吗？”老胡：“我说过吗？”小杰：“……”

一天晚上，又一天晚上，还是一天晚上……下载……然后上厕所……少儿不宜，你们懂得……
一晚卧谈会，高富帅：“当年我和小黄狗聊天，她说她表弟小小年纪就特别好色，老喜欢抱她，晚上还要和她一起睡！我叹息了一声，小黄狗说怎么了，你也抱过啊，然后我说：‘但是我没睡过啊！’”
有段时间学生会比较忙，每天很晚才回到宿舍，小黑：“郝哥哥每天都出去鬼混！四处勾搭妹子！”我：“哥是去工作好不好？”小黑：“解释就是掩饰，掩饰就是事实！”我：“……”
在空间发了一张我们宿舍六人的合影：标题是B533最帅的六个人！（每次安慰富帅，我都会告诉他：你好歹也是B533最帅的六个人之一啊）
如果你的女朋友是南工程的，请珍惜，因为她身边有那么多优秀男生，却选择了你；如果你的男朋友是南工程的，请更加珍惜，因为他身边有那么多优秀男生，却依然喜欢女生！
为什么我的眼中常含泪水，因为我的室友老给我丢人！
我：“好，今天我高兴，小杰请我吃饭！”
——“昨天，我总结了一下！”安静……——“昨天，我总结了一下！”安静……——“昨天，我总结了一下！”安静……——“昨天……”——“你TMD到底说不说啊！”
——“其实我有生理问题，希望你们不要歧视我！”——“怎么了？废了？”——“不是！”——“那是怎么了？”——“我不好意思说……”——“没关系，大不了一死嘛！”——-_-|||“我只是想说，我有蛀牙……”
有天卧谈会，谈到强奸这个问题，小胖说了一句话：“万一_____（此处填空，两个字）肿么办？”瞬间就亮了！
以前，高富帅经常讲和他前女友小黄狗的故事。后来有一天，高富帅神经出了点问题，死活不承认小黄狗以前是他女朋友。于是，小杰说了一句话：“行行行，小黄狗不是你女朋友，她是你好基友行了吧？！”
还记得某天晚上，小胖念了一遍lol人物台词，我们顿时有了新的理解！读的方法是：某某某脱下裤子+原台词！例如“Ashe脱下裤子，我射的很准！”Ashe: 我射的很准！安妮：你也要来玩吗?很好玩的哦炼金：摇还是不摇，这是一个问题ez：是时候表演真正的技术了！亡灵：不要再2了野兽：我们的狂怒你驾驭不住提莫：提莫队长正在待命小炮：我好想射点什么皮女：好戏开场了 
老胡创造了这么一句话：“风吹裤裆JB凉！”
老胡：“那个女生不好！”我们：“为什么？”老胡：“她性冷淡！”后来我们一直想知道老胡怎么知道的……
——“用个成语形容自己！”——“帅的一比！”
小杰发了一个说说，后来怕没人赞，于是又加了一个说说：请大家赞我上一个说说！
小黑躺在床上玩手机，突然说：“哎呀，没电了！”我不假思索地接了一句：“没电了玩手机啊！”……
时间不早了，大家安息吧！
二货室友们，我想死你们了!
以前一直不知道什么是2B青年，后来见到了小杰，我一下子明白了！
小杰每天晚上睡前都B-BOX，打扰大家睡觉。后来有一天，小杰发现得了肾结石，很难过，不B-BOX了，然后晚上12点半左右开始放视频，外音……
小北门门口每天都停满了网吧车，大家习以为常。有一天来了辆林肯加长和一辆宝马，也是网吧车，当天就登上了网易头条……
小杰去打水，经常做的事是：5分钟之后回来，告诉我们忘记带水瓶了……忘带水瓶……打水……-_-|||
有一天我去打水，到了打水的机子前，掏出了公交卡，掏出了银行卡，连身份证都掏出来了，但是，饭卡没带……
小杰说喜欢王梦娇，但是他和顾俐慧关系非常暧昧，每天都聊啊聊，我们都认为其实小杰是喜欢顾俐慧的。于是有一天，我就帮小杰表白了，顾俐慧打电话给小杰，小杰死活不承认。后来又一天，小杰发现自己真的喜欢的是顾俐慧，于是再次表白，结果得知顾俐慧在前一天结束了单身……小杰啊，我已经不想再说你什么了……
网球课，老师让同学做一遍挥拍动作。先是吉旭峰，做了一次，完全跑偏，老师很无奈。又叫了赵佳袁，再次跑偏，还耍了耍帅。我明明看到老师脸上瞬间挂上了三根黑线，“这两个人哪儿冒出来的？”
缪，miu还是miao？
开学第一天点名，点到王郑的时候，他室友邱浩回答：老师，他家里有事，还没来到学校。老师淡定地指了指，“他那不是来了吗，你看，正举手呢！”只见王郑果然来了……邱浩满脸的黑线啊……这时老师补充了一句：好基友，一辈子！
蔡老师问：你们学过java吧？谁教的？我们：叶和亚！他恍然大悟状：奥~我们叶老师可以出了名的……（一副你懂得的表情）我们：嗯嗯！（我们懂得）蔡老师：你们想哪去了，我是说我们叶老师出了名的水平高！
我们只点名五次，小于等于五次。你们好好数着，等到了四次，基本上你们就不用来了，因为我可能就不点了。
等到人品爆发的时候，怎么说也有30k吧！
那时候我们回到宿舍，第一件事肯定是在楼道里大喊：C不C？这时有人回：C!C!C!!!这时会有人问：谁贱？谁贱？下面就会有人抢着：我建！我建！谁建谁是有好处的，看谁打得好，直接踢掉！呀，不好意思，手误手误！再加再加！
再后来，我们不止C的水平很高，杀毒水平也很高，为什么？因为如果你的电脑中毒，人家不带你C！你可以不让我吃饭，你可以不让我上课，但是，你怎么能不让我C呢？这怎么能忍受？所以，为了不中毒，我们就开始研究各种杀毒杀木马的方法。后来网上出现的各种病毒，说杀伤力怎样怎样，很多大网站都中招了，但是对我们来说，都是小case！比如当年出现的冲击波病毒，特别恶心，它不删你文件，也不复制出乱七八糟的东西，但是，它关你电脑！你正C的开心，旁边弹出一个对话框：60,59，……而你唯一能做的，就是跟着它一起数，然后，关机了！这谁受得了对吧？结果这个病毒刚一出现，就有同学到了网吧，一天就找到了解决办法，然后写一个文档，第一步第二步列的清清楚楚，只要照着做就能解决。但是，我们解决了，女生那边还没有解决啊！阿姨，你不知道，现在出了一个冲击波病毒，危害非常严重，我们班女生都没法学习了！然后给阿姨看那个文档！阿姨：快去快去！谢谢阿姨！你们知道吗？好名声是会传播的，我们系女生的问题解决了，其他系女生的问题没解决啊！不要担心，其他系的女生打电话给你：请问是某某某同学吗？下午有时间吗？再找到阿姨，阿姨，我就是上次来的那个男生，这次来帮其他系女生修电脑！奥，是你啊，小伙子不错，快去吧！谢谢阿姨！
一件帅气的格子衬衫，领口张开，下面穿一件纯黑短裤，还洒满了白点子，配上一双耐克运动鞋，再加上一副优雅的黑框眼镜，哎呀！让我瞬间忽略了他的代码！
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>笑话</tag>
      </tags>
  </entry>
  <entry>
    <title>域名被clienthold解封方法</title>
    <url>/essay-clienthold/</url>
    <content><![CDATA[前言2017年10月13日，突然收到来自阿里云的短信和邮件：

尊敬的用户：您的网站voidking.com涉及违法不良信息，违反了《互联网信息服务管理办法》第十五条规定，目前阿里云已经对您域名hold处理。如果您对本通知的内容存有疑问，请及时工单或者电话联系我们。 谢谢您对阿里云的支持。阿里云计算有限公司

收到这条信息时，郝同学一脸懵逼，马上就致电了阿里云客服，表示不服。客服告诉我需要实名认证，我说认证过了。最终客服解决不了，让我提交工单。


工单第二天，果断提交了工单。以下是工单截图。
从折腾到放弃工单说，必须到公安局网警办公室做申报，听起来就好麻烦。但是，为了我的域名，决心麻烦一把。因为 voidking.com 这个域名用了很多年，和郝同学感情深厚。
当时身在长春，打电话给110，问到了网警中心的电话，想咨询下具体怎么处理，需要准备什么材料，然而，打电话无人接听。连续几天，打了几十个电话，依旧无人接听。
不甘心的我，想要在网上找到网警中心的其他联系方式。意外发现了全国公安机关互联网站安全服务平台，莫非，所谓的申报就是公安备案？于是，花了一周左右完成了公安备案。但是，并没有什么用，申报和公安备案并没有任何关系。惊喜的是，公安备案成功后，给我的通知中附带了长春的网警中心联系方式。果断打电话过去，接听了，有戏！但是，接听电话的人员告诉我，网警中心搬到另外一个办公室了，给了我另外一个号码。然后，再也没有打通过。。。在微博上咨询长春网警，也没有得到回复，遂放弃。
PS：公安备案成功后拿到了备案号，但是现在查询，居然没有备案信息，也是一头雾水，不明所以。
从折腾到放弃2.0一直想着，很快就要去北京实习了，到时候去北京网警中心处理。这一等，就是近五个月。没有去北京，而是来到了深圳。深圳也是大城市，网警中心的服务应该很周到，我这么想着。
给110打电话，询问网警中心的电话，警察说让我打114查询。114查询到网警中心电话后，致电网警中心，网警中心说他们只处理网络诈骗类案件，我这种网站方面的要找通信管理局。然后，从114那里拿到了深圳通信管理局的电话，致电通信管理局，空号。然后，从114那里拿到了广东省通信管理局的电话，一直忙线中，十几个电话没有打通。
决定还是再咨询一下网警，毕竟是公安部下发的hold要求。微博关注了深圳网警，咨询域名被hold怎么处理，没收到回复。了解到他们周末不上班，决定哪天请假去一趟网警中心。
不知道准备什么材料，因为网上的案例极少。比较靠谱的，有以下两篇文章。域名被clientHold的解封办法 和 域名被停止解析该如何恢复正常 中都提到了标准解封流程：
1、写好整顿报告提交本地公安局
2、公安局提交整顿报告到负责网络信息的公安部相关部门
3、公安部相关部门经过对整顿报告的批复把解除域名锁定的通知下达给工信部。
4、工信部接到公安部相关部门的通知把解除域名锁定的通知下达给通信管理局。
5、通信管理局在把通知下达给新网，此时域名才可以正常。
复杂，好复杂，但是郝同学还是决定搞一下。于是从网上找了网站整顿报告的模板，写了一份整顿报告。但是，该提交到哪里呢？这份报告模板是否标准，需不需要重新写？
工单2.0带着这些疑问，郝同学提交了第二份工单，希望阿里云能够提供一些帮助，实在是不知道该找谁了。
解决办法阿里云并没有提供什么有用的信息，几乎走投无路的郝同学，继续寻找希望。在重读域名被停止解析该如何恢复正常 这篇文章时，“域名转移”让我眼前一亮！clienthold是因为注册商hold了域名，但是在国外，注册商是没有权力hold域名的！那我能不能把域名转移到国外呢？查看了一下域名转出阿里云的条件：

必须是在阿里云申请的域名。
域名转出时距离域名申请日（域名注册日期） 60 天以上。
域名转出时距离域名最后一次成功转移日大于 60 天。
域名转出时距该域名到期日大于 15 天。
域名转出时状态正常（不能是禁止转出状态），不欠费、不处于任何仲裁及法律程序中、不存在该域名持有者的身份不清楚或者存在争议。
域名过期后完成续费/域名赎回已超过 45 天。

对比了这些，发现自己符合条件，激动！于是，开始了域名转移，从阿里云到godaddy。
具体流程百度即可，很简单，比较坑的是，在开始转移前，要先等五天！

尊敬的用户：我方注册商（见下表“转出注册商”列）于北京时间2018-03-05 16:27:22收到有关您希望将域名转到其他注册商的通知。通知转出的域名列表如下：（表略）重要提示：1、如果您希望继续该转出，您不需要做任何操作，根据上述域名相关注册局的规定，域名将在5-7天后自动转出。2、如果您希望取消此次转出，请您务必在北京时间2018-03-10 15:27:22前按如下方法操作取消：登录“阿里云管理控制台” —“域名与网站—域名—域名列表”，选择域名进行“管理”，进入“域名转出万网” —“取消转出”按钮。如果登录后没有“取消转出”按钮，则意味着此域名已经转出成功，将无法取消转出。3、如果我方注册商在北京时间2018-03-10 15:27:22前未收到您的取消转出请求，该转移将继续。

五天中，我很焦躁忐忑，在想会不会等了五天最后提示我转移失败。看了很多相关文章帖子，后来域名被注册商强制停止解析，域名状态 clientHold ~~怎么办？这篇帖子中找到了信心。首先，只要不是cn的域名，都可以向APNIC申请强制转出，这样转出就没问题了。其次，转移到国外，因为没有clienthold一说，也就相当于自动解封。
就这样，等到了3月10日的15:27，没有消息。继续等待，直到3月11日13:23，终于收到了godaddy的域名转入确认邮件，感动到哭。
赶紧设置了解析，测试能不能使用。几分钟后，www.voidking.com终于可以正常访问了！本次历时近五个月的clienthold事件，终于圆满解决。
晚上，更换了dnspod作为dns服务器。解析正常，联通4g可以正常访问，但是中科院的网络却不可以访问。很奇怪，后来在网站域名解析之后为什么有些地方还是不能访问？这篇短文中找到了答案：有些站长在做网站域名解析的时候，会遇见这样的问题，网站域名解析之后为什么有些地方还是不能访问？这个是由于各地电信或网络提供部门的DNS刷新频率不一样，因此，全球域名刷新有8-72小时的误差，如果您刚做完解析，那么就有可能出现某些地方暂时还不能访问的情况，这是正常的。
后记原本，在百度搜索“voidking”，基本都是郝同学网站上的文章。而现在，都是郝同学在各大博客网站上的文章，排名下降了太多，从头再来吧。早知道域名转移可以解决clienthold，就不用这么多折腾了。早知道，多好。写下本篇博客，希望能给遇到同样问题的同学提供一些帮助，少走一些弯路。
书签域名被锁定冻结（域名被 hold）的原因及解锁
违法违规信息处理方案
违法信息处置FAQ
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>科目二</title>
    <url>/essay-driving-license-subject-two/</url>
    <content><![CDATA[前言同学们都说：“考过科目二，驾照就算到手了。”可见科目二的重要性以及难度。3月4日开始学科目二，近一周了，收获非常多，在此总结一下，方便自己和后来的小伙伴。本文会在学车的过程中不断更新，更新时间请看后记。
吐槽学车有风险，笨蛋需谨慎。
第一天（3月4日，周三），学了曲线行驶（也就是我们常说的S弯）和直角转弯。第一次，开进了草地，被骂的没有人样；第二次，又开进了草地，没有被骂，直接被踹了下去。咳咳，真的是被“踹”了下去。。。这一天，印象最深的一句话是：“你是我见过最笨的学员！”还有什么!@#$%^&amp;*另外两个学员安慰我：“别放在心上，他就随口一说，第一天我们都被骂哭了！”
第二天（3月5日，周四），学了倒车入库（只学了右倒库。左倒库考前学，据说比较简单）。奇迹般的，我居然倒车倒得不错！啊勒，我都佩服我自己了！依然被骂，但比第一天好了太多太多！确实，表现的好坏，会影响教练对你的态度。和一个学员聊天，他向我倾诉：“唉，今天可惨了，教练说没见过我这么笨的学员！还有!@#$%^&amp;*”我紧紧地握住了他的手：“教练昨天也是和我这么说的！！！”从这一天开始，融入了同学们当中，开始和大家嘻嘻哈哈，互相帮助。

第三天（3月7日，周六），学了侧方停车。表现依然不错！而且，我们教练有两辆车，今天他在另一辆车上教新学员。我们自由练习，无人看管，开森的不得了！和同学们吧啦吧啦吧啦。。。
第四天（3月8日，周日），学了坡道定点。表现依旧惊艳！也开了几圈S弯，虽然不够完美，但是，不会开进草地了！进步是巨大的！自我感觉，学完倒车入库，其他几项都有进步！开始打卡了，4个小时。当然，和同学们在一起吐槽吹牛也是必须的。
第五天（3月9日，周一），五项，练习。进步中，可以感觉到。今天我们聊得最多的是：甲：“诶？教练今天怎么没有骂我？”乙：“他昨天就没有骂我！”甲：“对对对，从昨天就不对劲了！”丙：“其实，从前天开始，教练心情就不错！”丁：“我也发现了！”戊：“还真有点不习惯！”。。。
后视镜调整倒车入库右边：后门把手看到后端左边：后门把手看到后端
侧方停车右边：前门把手中间偏左，后门把手看到前端左边：看到前门把手
重点速度控制好速度，科目二你就学好了一半！最重要的在于踩离合：向下压减速，向上抬加速；左右打方向盘减速，回正方向盘加速。目标是：无论怎样打方向盘，我们通过压和抬方向盘，使速度始终保持（慢）匀速。
方向盘打方向，值得花时间练习！为什么？打方向盘也可以很帅很拉风！不不，主要原因是，方向盘的控制，直接决定各个点是否打的好！
倒车入库多练倒车入库！感觉用倒车入库来打基础非常好！练出手感，完虐其他四项！
勤奋早上7点半到驾校，我觉得已经很早了。但是，那些勤奋的同学，每天早上6点半左右就到了！早去，没有人，就可以多学一小时甚至一个半小时。多学一小时有什么用？我能说的只是，一整天（上午8点到下午5点），你能练习的时间，满打满算一小时就不错了！
五项要点Tips：以下要点，不是硬性规定。具体操作的时候，根据当时情况自己调整。
曲线行驶口诀：提前转，先少转，追着弯道转；早点回，先少回，追着弯道回。
详解：入弯时，靠右行驶；当右边线与车头相交，交点移动到车头左侧三分之一处时，方向盘向左打一圈，然后在左右90度之内调整方向盘，使左车头和右边线始终重合；当左车头快要碰到左边线时，回正方向盘；当左边线与车头相交，交点移动到车头右侧三分之一处时，方向盘向右打一圈，然后在左右90度之内调整方向盘，使右车头和左边线始终重合。
直角转弯详解：入弯时，靠右行驶；当车头完全盖住前方边线（或水管）时，向左打死方向盘；当方向快要回正时，回正方向盘。
倒车入库详解：正手入库时，当右后车门上的竖直杠和车库的右角重合时，向右打死方向盘；看右后视镜，当车身与白线的夹角大概到30度的时候，方向盘回一圈；当右后视镜盖过车身与白线的夹角时，向右打死方向盘；当右后视镜中车身与车库右边线马上就要平行时，回正方向盘；看左后视镜，找停车点，踩下刹车；
反手出库时，方向盘向左打90度，前进，数2或3或6秒（视左边距离而定），回正方向盘；当车头盖住车库前方黄线时，向左打死方向盘；当车身与车库前方黄线呈45度角时，踩下刹车；
反手入库时，看左后视镜或者右后视镜，当车身与车库左右边线将要平行时，回正方向盘，找停车点，踩下刹车；
正手出库时，当车头盖过车库前方黄线时，向右打死方向盘；当车身与车库前方黄线平行时，回正方向盘。
侧方停车详解：前进时，控制车头与车库左边线的交点在车头右侧三分之一处；看右后视镜，当右后视镜中可以看到车库前边线时，再前进两秒；
入库时，看右后视镜，当右后视镜盖过车库前边线时，向右打死方向盘；看左后视镜，左车身后保险杠与车库左边线有一个交点，当这个交点移动到保险杠中点时，回正方向盘；继续看左后视镜，当左后车轮压到车库左边线时，向左打死方向盘；继续看左后视镜，当车身与车库左边线平行时，踩下刹车；
出库时，当车头与道路左边线的交点位于车头中点时，向右打死方向盘；当车身与道路平行时，回正方向盘。
坡道定点详解：上坡时，调整车头，使车头中点偏右处与内侧黄线相交；当车头右角小后视镜与桩杆快要平行时，踩下刹车；慢慢松开离合，当车身抖动时，松开刹车；当车子行驶过坡道最高点，开始下坡时，可以松开离合。
考试科目二和科目三各有五次预约机会，每次预约间隔十天。每次预约考试，不过的话，当天可以补考一次。也就是说，科目二和科目三各有十次考试机会。
科目二考试时，曲线行驶、直角转弯、侧方停车、坡道定点，这四项一起考，被称为电子路；倒车入库单独考，教练习惯说正反手。
电子路和倒车入库，全部通过，则通过。有一个不通过，则需要补考电子路和倒车入库。
等待时间学车，绝大部分情况下，都不只有你一个人，是大家一起学。这个时候，就要排队，每人开几次。那么，等待时间干啥呢？吹牛啊！哈哈，开个玩笑，聊天啊！可好玩了，特别有意思！大家一起吐槽教练，怎一个暗爽了得！还有，大家交流一下经验，讨论一下不明白的地方。牛逼的学员也会传授一些经验，不止是关于打方向的各个点，还有关于考试的注意事项、关于考场的选择（比如11号考场是死亡考场）、关于打卡、关于送礼、关于驾校的内幕。。。
再不济，还可以玩手机啊。注意，要趁教练不在的时候看，否则，准备迎接教练的怒吼吧！如果带本托福雅思啥的，应该没事吧。。。
后记3月31日，模拟考试。倒车入库三次（3号库），挂两次；电子路六条线（7号到12号），挂两条线；加模倒车入库两次，全过。
4月1日，正式考试。10号线，完美通过；倒车入库（6号库），反手忘带90度，险险通过。
哈哈，终于考完了科目二，今天约了科目三的练习时间，驾照指日可待！吼吼~
最后一次更新时间：2015-04-02
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>怎样做出可口的食物？</title>
    <url>/essay-how-to-cook-good-food/</url>
    <content><![CDATA[前言记不得新冠疫情开始的具体时间，只知道今年的春节（2020年1月25日），没有出去拜年，春节期间也没有出去聚餐。然后，疫情日益严重，继湖北武汉之后，各市也开始封城。复工日期一推再推，2月15日经历了两次信息登记，三次体温检测，顺利返回北京。先去社区办理观察证，小区内隔离两周，拿到出入证，还要录入人脸识别，以便进出小区。3月9日年后第一次上班，需要查询近期行程，测量体温，才能进入达美中心。复工后三周休两周，直到最近，才每周上班。但是，仍然不敢在外面吃饭，因为多人用餐是最容易传播新冠的途径。
因此，厨道大兴！而郝同学不才也加入了自己做饭的行列，毕竟自己做才最放心。做的多了，自然不能只满足于能吃，而要追求好吃。


秘诀用最少的调料，最简单的烹饪方法，最大程度发挥出食物本来的味道。
1、糖，是万能的，别怕，不管是任何菜式，出锅前放一丢丢，总会遇到你想要的味道。糖，不是为了让菜变得甜腻，而是作为味引，激发出足以挑拨你味蕾的口感。
2、豆瓣酱在肉类处理上，是不会犯错的存在，最简单的，放油，放豆瓣酱和肉沫，加一点点料酒去腥，就可以得到满满一碗辣肉面的肉酱，放在冰箱里吧，什么时候饿了，下碗面条浇一点这个肉酱上去，端在面前，是一碗面条吗？不，是一碗准备时间只需要5分钟的幸福。
3、蚝油在好多素菜的处理上，完全可以替代盐，而且有着盐没有的那股“鲜”味，最直接的就是花菜，尤其是干锅花菜。洗干净沥干，然后下油，放一点点花椒或者辣椒，吧花菜放进去，一滴水也不要加，感觉差不多了，放耗油+生抽，别放盐，出锅，有追求的就再放些五花肉片进去，尝尝，是不是觉得外面的干锅简直是垃圾？
4、初学者，不要想着一气呵成，很多东西是可以在烹饪过程中不断调整的，容错性巨高，特别是烹饪时间较长的菜式，例如蒸菜。大个比方：梅干菜扣肉，前面不罗嗦，就说上蒸锅开蒸之后，每隔半小时用筷子舔一下，觉得咸了赶紧吧里面的汁水逼出来一点，觉得淡了就加一勺老抽进去，觉得不够甜就放一小粒冰糖在边边，容错性巨高。
5、洋葱没有什么味道，它的全部价值在于增香。举个例子：最最最最简单的，炒鸡蛋，加一两片洋葱进去，感觉是两个菜。
6、刀工没有那么重要，现在的厨房懒人工具太多了，不要把时间浪费在练习刀工上，至少我是这么认为的，还容易受伤。
7、外面的菜口感总觉得和家里不一样，是因为外面的火，远远比家里的要旺，这个是煤气灶的硬伤，解决不了的，但也并不是没有一点办法，我个人的解决方案是，尤其在所谓的“爆炒”菜式中，会将火开至最大，然后将锅倾斜至很夸张的角度，目的是让火舌舔到锅里的油，这样就会有锅里起火的效果，温度非常之高，然后上盖子压灭，出锅。这招是我自己捣鼓出来的，有的时候实在是少油，火舌舔不到，我就在锅边边刷一点油。
8、汤类中的“鲜”，我指的是的寻常汤类，不外乎来自这四种东西——笋、肉、味精、白胡椒粉（评论提醒，还有一种，但我不经常做，就是菇类）。这也是我经常做的几道，极其方便。比如，上海菜中有一道“腌笃鲜”，冬笋、精肉、咸肉，一比一比一入锅，一大锅，熬着吧，啥也不用放，真的其他啥也不用放（姜片和料酒去腥还是必需的），1个小时后出锅，撒点葱花，冬天里简直是。。。王菲有首歌叫什么来着？天上人间是吧，诶。
再比如，我这边有个卖臭豆腐的，炸完后浸入一种汤里，巨好喝，问他怎么弄的，他摆摆手说是秘方，不外传。回家自己细细一品，转身进厨房，不说一模一样，但可以乱真——牛肉汤，味精、五香粉，酸豆角，白胡椒粉，香菜。就这么简单，还秘方不外传，啊我呸。
9、用猪油，比其他任何的大豆油或色拉油炒出来的菜，都要香，我用过一次就上瘾，唯一的缺点就是凝固点太高了（很多人评论纠正我是低？我也搞不明白了，如果普通油凝固需要零下1度，而猪油凝固零上5度，到底是谁高谁低呢？），很容易就变成膏体，冬天是需要用勺子挖的。
10、最后给个心得，其实厨艺这东西没有什么玄妙的，无非是经验而已，我一个人搁那捣鼓五六十年，出来绝对也是一等一的大师，总有个阴差阳错能让我悟到一些原本没人点拨到的TIPS，那为什么不去寻求身边的高手呢？比方，我吃番茄炒蛋，永远是淡而无味，加再多调味品都没办法拯救的哪种，结果我一朋友对我说，你说说你怎么弄的呢？说完，所有的步骤和路数都是OK的，唯一一点，出错了，炒番茄的时候没有用勺子用力压番茄，这样番茄里的酱汁就不会被压出来，也就没有办法裹在蛋上形成独特的口感了。我一听，大惊，对啊，就是这个道理。
再比方，那个薯条，我随便怎么都弄不出那种麦当劳的风味，口感一模一样，就是没有那种风味，最后问题出在，土豆切条之后需要用牛奶浸泡一晚上，没有牛奶用奶粉也可以，这样会有若有若无的奶香味道，味蕾再发达的人，别人不说，这种味道你要能领悟原材料估计得靠缘分。
你看，是不是一个很小的点拨？小到你压根不会去注意。
多问多讨教就对了。
11、最后的最后，大家都是一双手，厨艺这东西练练总会上去的，但巧妇难为无米之炊，家里的调料一定要齐全，不然就会变成我，经常戴着口罩围着围裙坐电梯到小区门口超市买缺的调料（那回头率老高了）。郫县豆瓣酱、料酒、老姜、蒜瓣、老抽（酱油）、生抽（鲜酱油）、香醋、白醋、白砂糖、老冰糖、白芝麻、小磨麻油、甜面酱、蚝油、辣椒面、五香粉、八角、桂皮、香叶、咖哩粉、白胡椒粉、鲜辣粉、花椒粉、椒盐、孜然粉、番茄酱、浓汤宝（牛肉、猪肉和老母鸡）、蜂蜜、老干妈豆豉酱。
这些调味品有共同的特征——1、保质期较长，常备着，不容易坏。2、使用频率极其频繁。3、要么不用，一旦那道菜式需要用到，而你恰恰缺少，那这道菜基本就属于做不了了，非要不可的那种。
调味品
油：大豆油即可，菜籽油更好。
盐：海盐、湖盐、井盐、岩盐，任选即可。
酱油：生抽，老抽。生抽一般用来蘸料，拌凉菜，或者是炒菜时提个鲜；老抽一般在红烧时做上色用。简单来说，拌菜炒菜用生抽，红烧用老抽。
醋：陈醋，白醋，米醋。陈醋用途最广，可以炒菜，可以凉拌，可以蘸酱，还能上色；白醋最大的用处体现在它的功能性，比如除臭除味、美肤养颜、洗涤除垢等等；米醋因为口味柔和，有着非常浓厚的香气，所以多用来凉拌。
糖：绵糖。
其他：十三香、干辣椒（小米椒）/辣椒粉、大茴香（孜然）/孜然粉、八角、花椒/花椒粉、桂皮、香叶、小茴香、芝麻、烧烤料。

烹饪万能流程：1、放油，放肉，放料酒，翻炒。2、放菜，翻炒。3、放入调味料（最后放盐），翻炒。4、根据经验，观察色泽，尝一尝，出锅。
小技巧
APP：下厨房
保存土豆：纸箱+不透光
存肉：买来肉之后按一顿的份量切块，每块分别放入保鲜膜，冷冻。
化肉：盐+白醋
磨刀：碗底，同一个方向

书签你是明白了哪几个基本原理之后而厨艺大增的？
来自专业厨师的36个无价的烹饪技巧
20个你不知道的聪明的烹饪技巧
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>使用aria2离线下载</title>
    <url>/hobby-aria2-download/</url>
    <content><![CDATA[前言迅雷、旋风、百度云盘等下载工具，非VIP有限速，VIP有资源下载限制。在线云播，广告繁多，缓存慢，如今更是被封了99%。
郝同学在知乎找到了一个很好的解决方案：aria2。aria2 + aria2webui完成下载，emby或plex完成下载后播放功能。
本文，就来研究一下aria2的安装部署。


aria2简介
aria2 is a lightweight multi-protocol &amp; multi-source command-line download utility. It supports HTTP/HTTPS, FTP, SFTP, BitTorrent and Metalink. aria2 can be manipulated via built-in JSON-RPC and XML-RPC interfaces.


aria2官网
aria2源码
aria2下载地址

webui简介aria2webui包括yaaw、webui-aria2、AriaNg等。
yaaw
YAAW: Yet Another Aria2 Web Frontend in pure HTML/CSS/Javascirpt.No HTTP server, backend or server-side program. All you need is just a browser.


yaaw源码地址
Aria2 &amp; YAAW 官方使用说明
yaaw管理页面
yaaw管理页面2
yaaw管理页面3

webui-aria2
The aim for this project is to create the worlds best and hottest interface to interact with aria2. aria2 is the worlds best file downloader, but sometimes the command line brings more power than necessary. The project was initially created as part of the GSOC scheme, however it has rapidly grown and changed with tremendous support and feedback from the aria2 community.


webui-aria2源码
webui-aria2管理页面
webui-aria2管理页面2

AriaNg
AriaNg is a web frontend making aria2 better. AriaNg is written in pure html &amp; javascript, thus it does not need any compilers or runtime environment. You can just put AriaNg in your web server and open it in your browser. AriaNg uses responsive layout, and supports any desktop or mobile devices.


AriaNg源码地址
AriaNg管理页面

aria2命令行aria2命令行在windows和linux中通用。
1、Download from WEBaria2c -c -s 5 http://example.org/mylinux.iso
其中-c代表断点续传，-s代表线程数。
2、Download from 2 sourcesaria2c http://a/f.iso   ftp://b/f.iso
3、Download using 2 connections per hostaria2c -x2 http://a/f.iso
4、BitTorrent Magnet URIaria2c &#39;magnet:?xt=urn:btih:248D0A1CD08284299DE78D5C1ED359BB46717D8C&#39;
5、Metalinkaria2c http://example.org/mylinux.metalink
6、Download URIs found in text filearia2c -i uris.txt
7、BTaria2c /tmp/CentOS-6.3-i386-bin-DVD1to2.torrent
aria2c http://mirrors.163.com/centos/6.6/isos/x86_64/CentOS-6.6-x86_64-minimal.torrent
注意：当源地址存在诸如 &amp;, * 等 shell 的特殊字符，请使用单引号或双引号把 URI 包含起来。
windows安装使用aria2安装aria21、访问aria2项目，下载最新的aria2，这里我们下载aria2-1.34.0-win-64bit-build1.zip。
2、解压aria2-1.34.0-win-64bit-build1.zip，并且重命名为aria2，最终路径为D:\develop\aria2。
配置aria2参考aria2 Online Manual和Windows配置Aria2及Web管理面板教程，配置aria2。
1、下载配置文件git clone https://github.com/voidking/aria2-conf.git
项目包含两个目录，一个是windows，一个是centos。windows目录下包含如下文件：

aria2.conf，配置文件
aria2.log，日志文件
aria2.session，下载历史
Start.bat，启动aria2
Stop.bat，停止aria2
Restart.bat，重启aria2
Start.vbs，隐藏cmd窗口启动aria2
Status.bat，查看aria2状态
Boot.bat，开启或取消aria2开机启动

2、aria2-conf/windows中的全部文件复制到D:\develop\aria2中。
3、根据需要，修改aria2.conf文件。
4、双击Start.bat，启动aria2服务。
AriaNg安装配置1、访问ariang项目，下载最新版的ariang，这里我们下载aria-ng-0.4.0.zip。
2、解压aria-ng-0.4.0.zip，并且重命名为ariang，最终路径为D:\develop\ariang。
3、下载EasyWebSvr.exe，这里提供一个下载地址，密码为1ey1。
4、双击EasyWebSvr.exe，点击底部的锤子图标，选择设置，选择主目录为D:\develop\ariang目录，确定，点击底部的锤子图标，选择启动服务器。
如果不想搭建Web服务器的话，可以访问别人搭建的AriaNg管理页面。
PS：除了easywebsvr，还可以把airang扔到nginx、apache或tomcat等服务器的web目录下，效果是一样的。
5、访问 http://localhost ，进入Aria2 Web管理页面。
6、在Aria2 Web管理页面点击新建，可以添加HTTP、FTP、BT任务等，同时添加多个任务每行一个URL，添加镜像URL用空格分割，点击文件夹图标可以打开种子文件等。
文件默认下载到D:\develop\aria2\download文件夹，这是在aria2.conf中配置的。
注意：

在Web管理面板删除下载任务后，Aria2并不会删除下载文件或者缓存，需要自己去下载文件夹删除掉。
在同一个局域网内，其他设备输入当前设备IP地址，也可以访问Web管理界面，如：192.168.1.2 。
由于Web管理界面只是一个调用的作用，所以即使浏览器关闭也不影响Aria2进行下载。

centos安装配置aria2yum安装aria21、手动安装EPEL源
wget http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpmrpm -ivh epel-release-latest-7.noarch.rpmyum repolist //查看是否成功安装epel

2、自动安装EPEL源
yum install epel-releaseyum repolist

3、安装aria2yum install aria2
4、查看安装情况aria2c -v
编译安装aria21、访问aria2项目，下载最新的aria2，这里我们下载aria2-1.34.0.tar.gz。
wget --no-check-certificate --content-disposition https://github.com/aria2/aria2/releases/download/release-1.34.0/aria2-1.34.0.tar.gz
或者：curl -LJO https://github.com/aria2/aria2/releases/download/release-1.34.0/aria2-1.34.0.tar.gz
2、解压aria2-1.34.0.tar.gz并编译安装。
mv aria2-1.34.0.tar.gz /optcd /opt/tar -zxvf aria2-1.34.0.tar.gzcd aria2-1.34.0/./configure --enable-bittorrent --enable-metalink  makemake install
默认情况下，会在/usr/local/bin 目录创建 aria2c 可执行程序。
3、查看安装情况。aria2c -v
配置aria21、下载配置文件git clone https://github.com/voidking/aria2-conf.git
项目包含两个目录，一个是windows，一个是centos。centos目录下包含如下文件：

aria2.conf，配置文件
aria2.log，日志文件
aria2.session，下载历史

2、移动文件mkdir -p /data/aria2
cd aria2-conf/centos &amp;&amp; mv ./* /data/aria2/
3、启动测试aria2c --conf-path=/data/aria2/aria2.conf
4、后台启动aria2c --conf-path=/data/aria2/aria2.conf -D
AriaNg安装使用1、访问ariang项目，下载最新版的ariang，这里我们下载aria-ng-0.4.0.zip。curl -LJO https://github.com/mayswind/AriaNg/releases/download/0.4.0/aria-ng-0.4.0.zip
2、参考Hexo加速访问，在/opt/www目录下创建aria2目录。
mkdir -p /opt/www/aria2
3、移动文件并解压mv aria-ng-0.4.0.zip /opt/www/aria2
cd /opt/www/aria2 &amp;&amp; unzip aria-ng-0.4.0.zip
rm aria-ng-0.4.0.zip
4、配置nginxcd /etc/nginx/conf.d/
vim www.voidking.com.conf，内容为：
server &#123;    listen 80;    server_name aria2.voidking.com;    location / &#123;        root /opt/www/aria2/;        index index.html;    &#125;&#125;

5、重启nginx/usr/sbin/nginx -s reload
6、在dns服务器上添加aria2，解析到centos服务器ip。
7、测试访问访问地址：http://aria2.voidking.com
无法连接问题在ariang页面，如果发现无法连接到aria2，那么参照如下方法解决：
方法一：开放端口（推荐）1、查询6800端口是否开放firewall-cmd --query-port=6800/tcp
2、打开6800端口firewall-cmd --add-port=6800/tcp
方法二：关闭防火墙（不推荐）systemctl stop firewalld.service
bt下载问题有些bt文件，在aria2上进行下载，却没有速度。参考更新Tracker，解决Aria2 BT下载无速度和Aria2 bt 没速度? 试试自动更新BT Tracker服务器列表的方法，进行配置。
1、新建addtrackers.sh脚本，内容为
#!/bin/bashlist=`wget -qO- https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_all.txt|awk NF|sed ":a;N;s/\n/,/g;ta"`if [ -z "`grep "bt-tracker" /data/aria2/aria2.conf`" ]; then    sed -i '$a bt-tracker='$&#123;list&#125; /data/aria2/aria2.conf    echo add......else    sed -i "s@bt-tracker.*@bt-tracker=$list@g" /data/aria2/aria2.conf    echo update......fi

2、执行脚本chmod +x addtrackers.sh
./addtrackers.sh
3、重启aria2进行测试aria2c --conf-path=/data/aria2/aria2.conf
PS：或者，直接访问trackerslist项目，复制list，然后添加到aria2.conf文件中。
磁力链下载问题所有磁力链在aria2上进行下载，没有速度。
后记关于emby和plex，暂时没有研究。
书签CentOS 下搭建 aria2 远程下载环境
CentOS7安装Aria2
在线磁力播放引擎
DIY一套NAS+私有云盘+下载机
Ubuntu16 下载软件Aria2 全局配置方法(最全组合)
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>爱好</category>
        <category>电脑</category>
        <category>centos</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>《1368个单词就够了》单词表</title>
    <url>/en-1368-words/</url>
    <content><![CDATA[前言《1368个单词就够了》一书中，把单词分为五大类：名词、动词、形容词、介词、其他词。
在单词的使用选择时，遵循四个原则：

挑个大的
挑实心的
挑软乎的
自产自用



名词名词除了专用名词外，可以分为具体名词、抽象名词、构成类名词和属性类名词。
具体名词具体名词：背下来就可以。总单词量：355个类别：38个具体名词主要是指那些看得见、摸得着，或者能感受得到的具体事物。
有关物时间类time morning afternoon noon evening night tonight today tomorrow yesterday weekend year season spring autumn winter day date moment period history future birthday holiday festival schedule age  
气候类weather rain snow wind cloud  
自然类nature mountain air light water fire ice smoke heat ground sky river field forest sea stone star
植物类plant grass tree crop
动物类animal bird cat dog horse rabbit elephant bear tiger lion bull cow pig chicken fish sheep monkey snake reptile  
昆虫类insect bee butterfly spider  
其他生物bacteria
地点类place hospital restaurant hotel university factory jail zoo park school store club bar court market town village city
机构类organization company charity
声音类sound voice noise music  
食品类food egg meat steak bread cake dessert soup sandwich noodle pie chocolate sauce 
餐饮类meal breakfast lunch dinner 
蔬菜类vegetable potato tomato carrot lettuce bean  
水果类fruit apple orange banana 
食材类ingredient oil sugar salt butter cream 
饮料类drink coffee milk tea juice beer wine alcohol  
营养类nutrient mineral vitamin protein
疾病类disease fever flu cancer  
房屋类house office room floor wall window door roof kitchen
家具类furniture bed chair desk table seat couch 
服装类clothes shirt shoes cap hat coat dress pants uniform suits underwear pocket jeans button zip sock
首饰类jewelry diamond ring 
化妆品cosmetics perfume lipstick powder 
交通类transport traffic bicycle ship boat plane train 
车辆类vehicle motorcycle bus car truck brake engine gear tire wheel
路桥类road street bridge station 
装置类device lock key bell scale tap 
设备类equipment shower radio telephone camera computer TV fridge video
容器类container box cup dish plate bowl basket tub sink pot pan
材料类material cloth paper glass plastic gold paint chemical 
日常用品类toy brush mirror chain board handle cartoon bottle wood clock knifepen book album menu card envelope ticket pipe tube wire belt web filmscreen gift channel alarm electricity towel carpet tool junk fork spoonmedicine drug pill
数量couple double load pack lot
单位unit meter inch pound gram piece
事情thing issue matter stuff object event
有关人家庭角色类parent daughter son father mother brother sister husband wife uncleaunt grandfather grandmother role
社会角色类kid child baby boy girl man woman friend lady gentleman bosscustomer student neighbor person volunteer fool sir madam
职业类job doctor nurse professor lawyer engineer teacher coach guard judge
群体类group people class team human staff society generation armygovernment family
抽象名词抽象名词：光背下来还不行。总单词量：166个类别：9个因为抽象名词主要说的是“事”，而“事”都是“人”做的，所以，这个类别的词基本可以按照人“说的”“做的”“想的”来分类。
话语类words topic subject joke question suggestion instruction permission
文字类document story report note text letter email list menu novel blogrule：law grammar principle
信息类information message fact detail evidence clue background data signknowledge news update notice
状态类state condition environmentsituation：mess balance peace emergency chance opportunity
行为类act practice test experiment lesson attention focus step educationadvertisement trick habit business exercise bath security treatmentservice homeworkjob：task project challengeduty：responsibility faultperformance：concert drama operastudy：math art science psychology philosophyarrangement：deal insurance account engagementoccasion：party wedding funeral picnic barbecue ceremony meetinginterviewmoney：profit income salary loan cash cost credit deposit price taxbill budget
活动类activity game discipline crime trade economy politics war trip fashionindustrysports：soccer football golf basketball race
思想类thought idea view theory religionplan：strategy policy program
整体类network internet series careersystem：language transport
其他类favor privilege mistake risk advantage benefit problem troublesurprise secret award prize diet property option case example samplescore limit experience effort energy figure
构成类名词构成类名词：你的外在与内在总单词量：65个类别：8个我们在描述一个事物的时候既要知道它们是什么，也要知道它们都是由什么东西构成的。这就是构成类名词的作用。
核心词part
部位side edge base core
身体head eye ear face nose foot mouth tooth tongue neck shoulder breastchest stomach arm hand finger nail leg knee throat brain heart lung musclebone nerve hair skin blood sweat
精神mind spirit soul emotionfeeling：shame stress respect desire pain sense
力量strength forcepower：authorityability：sight intelligence memory skill
动物tail wing
植物flower leaf root branch
其他whole rest half
属性类名词属性类名词：你的状态总单词量：70个类别：12个想要了解一个事物光知道它是什么类别、由啥组成的还不够，还得知道它都有些什么特点，也就是它的属性。
属性也要从两方面来看，一是“人”和“物”的属性，因为这两者是静态的，所以我们叫它静态属性；二是“事”的属性，因为“事”是发展变化的，有原因有结果，所以我们叫它动态属性。
静态属性形状shape appearance
尺寸size space
位置positionpoint line endbottom middle top front back center corner left right direction：eastwest north south
品质quality feature character personality
其他属性colorweighttonematerialstructure
数量amount number measurement distance volume angle temperaturelevel：degree grade rank standard rate：speed percentage
类别kind type
动态属性方式formway：behavior mood logic tradition culture style pattern relationmanner
原因cause reason source excuse factor
目的purpose goal
结果effect result
过程course process
动词一个意思往往会有两种表达方式，一种是比较直接的，用一个词就可以解决，就是指“世故型”的动词；另一种是用解释的方式，用的词虽然多一些，但更加具体，就是指这种“单纯型”的动词。
单纯型动词单纯型动词：广交天下朋友总单词量：114个类别：15个
本源词be go come make
归属拥有某物 have得到某物 get给出某物 give拿到某物 take
终点位置使到达某一位置 put使轻轻到达某一位置 lay place使从其他位置到达说话者位置 bring使从说话者位置到达其他位置 send使位置暂停改变 hold使位置保持不变 keep位置保持不变 stay hang settle
相互位置一事物到另一事物上面 cover一事物到另一事物下面 support两事物混合 mix两事物互换 switch两事物相连 link join connect stick tie两事物相遇 meet两事物交叉 cross
运动轨迹从一个点到另一个点 move shift经过某个点 pass低点往高点 raise lift rise高点往低点 drop fall一事物在另一事物后面 follow一事物在另一事物前面 lead一物载另一物 carry往复运动 bounce roll shake screw
速度快速运动 run rush hurry
力量轻轻接触 touch用力接触 hit knock crash使快速运动 throw用力接触并来回移动 rub用力使事物脱离原来的位置 pull对事物朝某一方向用力 push draw press
空间空间开放或关闭 open close shut一事物进入某一空间 fit enter一事物进入某一空间（气体或液体） fill pump spill spray事物离开某一空间 clean clear wipe事物离开某一地点 leave quit一事物到达某一地点 arrive reach一事物固定在某一个空间 fix set
时间某事发生 begin start happen某事结束 finish某事停止 stop
方向一个方向到另一个方向 turn整体与部分从大到小（用力） break crack split tear从大到小 divide从多到少 cut
形状bend fold twist stretch spread
尺寸grow
行为look see listen hear say speak talk tell ask think believe know likelove do
系动词become seem feel sound smell taste
世故型动词世故型动词：朋友少，但效率高总单词量：219个类别：14个
看find watch observe ignore search show
说意见：agree cancel let allow告诉：claim warn introduce explain express confirm要求：beg charge order带有情感地说：argue blame praise encourage complain promise insistshout threat其他：answer call count pronounce
想consider guess deserve offerdoubt suspect trust forget remember imagine meanlearn understand wonderdecide try want hope wish expectwill shall should may might can must dare needimpress attract
感觉enjoy suffer appreciate care hate worry thank welcome bless thrillfreak shock bother annoy disturb
自然现象die live burn boil
人体行为肢体：dance ride lie climb beat上肢：hug下肢：sit stand walk kick jump skip面部：smile laugh cry嘴巴：eat kiss suck lick blow cough sing鼻子：breathe皮肤：bleed精神：sleep wake relax健康：hurt injure cure inject
生活行为cook bake fry drive measure wear wash tape record post travel screwdig hide pack mark
社会行为buy sell shop pay spend waste invite rent fight kill steal cheat investrob wait marry divorce borrow lend owe vote bet celebrateplay pretendhelp direct entertain interrupt distractdesign build invent copyprepare organize manage handle treat controluse apply save choose accept pick collect win fail miss losecheck examine compare solve analyze
运动skate swim fly shoot
工作work interview hire fire compete retire
学习read write spell translate
事物之间的关系match qualify equal share include separate belong depend involve
事物的发展变化change develop improve reduce add promote
事物相互作用damage spoil ruin affect attack
形容词总单词量：208个类别：47个根据牛津词典的统计，形容词的数量仅次于名词，约占词汇总数的四分之一，比动词多出将近一倍。但在我们的R词汇表里，形容词不但没有动词多，甚至比它还要少三分之一。因为我们根本不需要掌握那么多，只要把形容词里面最基础、最不可或缺的学到就可以了。
物的属性与构成大小big huge little small medium
高低high low
长短long short tall
深浅deep shallow
粗细thick thin fat slim
宽窄narrow wide
重量heavy light
正斜straight curved flat
形状round square
距离near far
事物与空间full empty blank bare dirty
时间new fresh
数量extra only single poor rich slight total
质地hard soft tough tender smooth rough sharp blunt fresh raw pure plaineven
力量strong weak tight loose firm tense
状态liquid gas solid
温度hot warm cold cool
湿度dry wet
亮度bright dark dull
味道sweet bitter delicious sour spicy
声音loud quiet
人的属性与构成时间young old
身体hungry ill sick tired blind sore born pregnant alive
行为busy violent wild
外表beautiful ugly sexy
心智smart clever stupid confused awake asleep familiar patient
态度polite lazy honest rude brave aggressive
情感interested curious proud sure confident
心情happy glad sad upset sorry guilty calm afraid angry crazy mad excitedbored disappointed jealous lonely
事的属性与构成难度easy hard difficult
时间late due urgent efficient
可能性possible available
安全性dangerous safe
其他wrong strict correct proper lucky fair successful
综合属性品质（好）good nice fine great perfect wonderful amazing excellent
品质（坏）bad terrible awful
真实性real true false fake
完整性complete
精确性exact specific
复杂性complicated simple
其他fun horrible weird strange comfortable incredible gross
事物关系特殊性special regular
一致性same different
普遍性typical normal common general popular average particular own
重要性serious causal important main formal professional
必要性necessary
关联性free relative legal physical mental local native international cheapexpensive separate public worth
介词总单词量：48个类别：14个介词主要是按照它们的功能进行分类的。我们需要重点学习的是前两大类：表示动态位置的介词和静态位置的介词。
动态位置轨迹across along past over up down through on off in out against
起点from
终点to toward for about
静态位置点at
点与点by beside before after behind between around
点与平面beyond under above below
点与空间outside inside within
从属of with without
时间during since till
替代instead of
比较than as
整体与部分besides among except including
因果according to
其他despite per
其他词总单词量：123个类别：9个
副词时间now early just then recently ago already yet ever never forever
位置here there
方向away forth apart together aside
数量extra alone
程度quite much very well extremely almost enough
强调actually especially absolutely certainly
速度fast slow soon suddenly immediately gradually
频率again often usually always
顺序finally eventually
转折otherwise
可能性probably perhaps maybe
递进also too either neither else
引导when where how why what
连词因果because
转折but though
并列and
条件if unless except
时间while
选择or whether
限定词顺序last next
数量all any some both each either neither every few many much
指代this that these those another such
代词I you he she we they it
疑问代词which who
冠词a an the
感叹词bye hello no yes pardon please wow damn
缩略词Mr. Ms.
数词zero one two three four five six seven eight nine ten hundred thousandmillion billion
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>金钱能买来幸福吗</title>
    <url>/hobby-can-money-buy-happiness/</url>
    <content><![CDATA[译者：裘霜
金钱能买来幸福吗？这是一个古老的问题。　　在过去几年中，新的研究让我们对获得和感受之间的关系有了更深入的了解。在许多国家，经济学家一直在审视收入和幸福的关系；心理学家对人类个体的研究发现了在涉及现金时，是什么真正令我们怦然心动。　　乍看起来，结果似乎有点显而易见：是的，从广义上说，高收入者比勉强摆脱贫困的人更快乐。　　不过，对发现进行更深入的探究之后，他们得到了大量更令人惊讶、也更加有用的结论。　　简而言之，最新研究表明，财富本身并不能为美好生活提供任何保证。比高收入更为重要的，是人们如何花钱。举例来说，与为自己花钱相比，为别人花钱更令人愉快。而且，当人们把钱花在自己身上时，花钱旅游、增长见识，比购买物质产品更让人感到持久的幸福。

　让我们看看对于指导人们更明智地使用金钱、最大限度地提升幸福感方面，最新研究有哪些高见。　　经历的价值超出想象　　最近，瑞安·豪威尔被一个难题所困扰。过去10年间进行的大量研究表明，相对于物质商品，生活经历赋予我们的快乐明明更持久，可为什么人们在考虑如何花钱时，还是常常否定经历的价值，优先购买物质产品？　　作为旧金山州立大学心理学副教授，瑞安·豪威尔决定一探究竟。他发现，人们之所以认为买东西能够更好地体现金钱的价值，是因为经历总是转瞬即逝，但物质产品却一直在那里，看得见、摸得着，可以反复使用。所以，尽管人们偶尔会花一大笔钱去度假或购买演唱会门票，但在手头不甚宽裕的情况下，他们坚持把有限的金钱用来购买物质产品。豪威尔说：“人们认为经历只能提供短暂的快乐，但实际上，它能提供更多的快乐和更持久的价值。”　　美国康奈尔大学心理学教授托马斯·季洛维奇也得出了类似的结论。“人们常常进行理性的计算：我的钱有限，要么出去玩，要么买东西。如果我出去玩，会很不错，但很快就结束了；如果我买东西，至少可以永远拥有它。这在事实上是正确的，但在心理层面上却未必，因为一旦买到手，我们很快会对自己物质财富习以为常。”这种过程叫做“享乐适应”，它使得人们难以通过购买物质感受到长久的幸福。新衣服或时髦汽车可以让人获得短暂的快感，但我们很快就认为它们理所当然了。　　另一方面，季洛维奇教授认为，经历往往能够满足我们更多潜在的心理需求。旅行虽然很快结束，但我们可以经常与其他人共享自己的经历，不但能与他人有更广泛的联系，还有利于形成更高的认同感。如果您攀登过喜马拉雅山，那么，即使很久以后所有钟爱的小玩意儿都被抛在脑后，您还可以常常回忆和谈论这段经历。　　更重要的是，我们往往不会拿自己的经历跟他人攀比，而物质方面的攀比要突出得多。季洛维奇教授说：“想象一下您刚刚买了一台新电脑，非常喜欢、满足，接着您的一位朋友出现了，说他也刚买了一台电脑，显示屏比您那台更亮、处理器更快。您该觉得多不爽啊！但是，如果您和您的朋友同时去度假，哪怕朋友去的地儿比您去的地儿更酷炫，您仍然拥有自己的经历和回忆，便不会那么闹心了。”　　季洛维奇教授和他的同事们还发现，期待一段美妙的经历，要比等着购买实际有形的商品更能带来快感。等待一个事件的发生一般会令人兴奋，而期待物质性的东西则“似乎让人不耐烦”。　　不要对所购物品习以为常　　拥有更多物质并不总让我们欣喜，其中一个主要原因是我们习以为常了。“人类极其擅于习惯生活中的变化，尤其是积极的变化。”加州河滨大学心理学教授索尼娅·吕波密斯基说，“如果您的收入增加了，会给您带来快乐，但您的愿望也会跟着水涨船高。增加的收入也许能让您在更好的小区买更大的房子，结果那里的邻居们也更有钱，您想要的反而更多了。您已经踩上了‘享乐跑步机’，试图让它停下来或减慢速度，确实是一种挑战。”　　吕波密斯基教授说，一种可行的方法是尽量有意识地欣赏和感谢您所拥有的，时常提醒自己敝帚自珍，将“享乐跑步机”的速度减缓下来。具体做法很简单，比如每天安排固定的时间，数数自己的幸福，又或者您可能想记日记，或者向他人表达感激之情。关键是要找到一种方法，对自己所拥有的一切保持清醒的认识，避免简单地把它们摆在四周。　　吕波密斯基教授坦承，因为您是在与自己的自然倾向作斗争，所以，感激和赞赏很难持久。如果您的日记或每日感谢变成了乏味的例行公事，就不再有什么作用了。您可能需要变换使用其他技巧。　　增加多样性、新颖性或惊喜，也可以帮助您更珍惜自己的所有。比方说，如果把一幅画挂在同一面墙的同一个位置，除了刚买回家的那段日子，您不会再多看它一眼。但是，如果把它与另一个房间的另一幅画对调，您就会用新鲜的眼光观看两幅画，而且会更欣赏它们。　　吕波密斯基教授还建议，应尝试与他人分享您的所有，并敞开心扉，迎接新体验。这意味着您可以把自己的东西借给别人，或者与他人分享。吕波密斯基教授做了一个实验，给实验对象每人家里寄去一大包巧克力，告诉其中一些人尽可能多吃，告诉另一些人不准吃，第三组人可以自行选择吃多少。　　结果如何呢？现在再面对巧克力，与可以敞怀吃、或按照通常食量吃的人相比，被禁止吃巧克力的人吃得更有滋有味。“暂时放弃一些东西确实有助于我们保持乐在其中的能力。”吕波密斯基教授说。　　试着给别人钱　　说到钱，一种自相矛盾的现象是，虽然赚更多的钱可能会提升我们的幸福感，但是，给别人钱却比为自己花钱更令人快乐。　　这一结果是从吕波密斯基教授的一系列研究中发现的。一开始她在校园里向学生随意派发现金，并告诉一些人要把钱花在自己身上，告诉另一些人把钱花在别人身上。结果显示，后者比前者更开心。　　此后，吕波密斯基教授反复在世界各地的不同国家重复这一实验，并将实验方式拓展为让人们送出自己的钱，而不是从教授那里白得的现金，以观察人们是否依然高兴。她发现，在加拿大、南非和乌干达等不同国家，施舍金钱都让人们更快乐，无一例外。即使在那些贫困国家，当人们囊中羞涩时，送出自己的钱仍然令人快乐不已。　　吕波密斯基教授还与来自100个国家的经济学家分析了盖洛普世界民意调查数据，结果发现，向慈善机构捐款的人更加快乐，在穷国和富国皆是如此。“我们能够在加拿大观察到与南非和乌干达等地一模一样的效果，在我的从业生涯中，这无疑是最大的惊喜。”她说，“很多人的想法是，等我有钱了，就向慈善机构捐款，但实际上我们看到的乐于奉献的人，往往是正在贫困线上挣扎、努力满足自身基本需要的人。”　　就幸福而言，指针的移动与您拥有的金钱数额关系不大，但与您的捐款所产生的效应密切相关。如果您看到自己的钱让别人的生活有所不同，就会使您快乐，即使您出资的数额微不足道。　　还要确保花钱买时间　　同样重要的一点是，您买回来的东西会怎样影响您安排自己的时间。在郊区购置大宅似乎是一个不错的主意，但研究人员发现，在其他条件不变的前提下，长时间通勤时间会降低总体生活满意度。据计算，您需要加薪40%，才能抵消1小时通勤所增加的痛苦。　　“花钱买时间更划算，”吕波密斯基教授说，“不要购买一辆更花哨的汽车，除了每天上下班的时候坐在车里，您不会在其他时间需要它。与其在郊区买别墅，每天长时间通勤，不如在市区购买一处离工作地点很近的小房子，如此一来，您就可以利用日落前1小时与您的孩子在公园里踢踢球。”　　另一种为自己购买时间的方式是把不喜欢的工作外包出去。聘请私人助理曾经是富人的专利，但现在人们可以更方便、更实惠地雇佣自由职业者，或在网络上找专业人士，帮自己完成日常管理，或单个任务。　　目前，吕波密斯基教授正在做的研究涉及到人们外包任务后如何安排因此所节省的时间，以及这样做是否使他们更快乐。初步调查结果表明，通过为自己购买时间，大多数人确实变得更加快乐，但前提是他们使用时间的方法正确无误。如果人们将它视为是“意外得到的时间”，并真的用它做点计划之外、让我们更加快乐的事，我们才能在情感上受益。　　不过，虽然购买时间不失为一个好主意，但总是用金钱来衡量时间的价值却未必可行。一旦人们把自己的时间当做金钱，便不太可能花时间去做没有经济收益的事，即使是少量时间也不行。因此，将时间当做金钱也会造成一些破坏性后果。　　钱只会在一定程度上带来幸福　　幸福的第一个衡量指标是“可评估性”，吕波密斯基教授将其定义为：“从某种意义上说，您的生活是美好的——您对自己的生活满意，正在朝着人生目标迈进。”经济学家们对世界各地的经济数据和幸福调查进行了广泛的研究比对，非常明显的证据表明，在世界各地几乎每一个国家，富人都比穷人更幸福，富裕国家的人比贫穷国家的人更幸福。　　幸福的另一个要素是“情感性”，吕波密斯基教授解释说，这是指一个人经历愉悦、喜欢和安宁等正面情绪和与此相对的负面情绪的频率。“您也许整体上对自己的生活感到满意，但其实真正开心的时候不多。”她说，“当然了，快乐的人也会体验到负面情绪，只是没那么频繁。所以幸福其实是由‘可评估性’和‘情感性’两个部分组成。”　　当研究者审视情感性指标时，一户家庭的年收入一旦达到7.5万美元，他们的幸福感便不再随着钱的增多而递增。总之，当您钱不多的时候，额外一点点钱就会让您开心很久，因为您有能力满足更多基本需求了。然而，一旦您积累了一定财富，再想“买到”更多幸福就变得难上加难。　　切忌入不敷出　　最后，虽然关于金钱与幸福的许多研究都侧重于如何花钱而不是如何省钱，研究者认为，入不敷出将招致灾难。关照好您的基本需求，确保一定程度上的金融安全，是非常重要的。　　季洛维奇教授认为，虽然他的研究表明，相对于物质产品而言，生活经历能够给予人们更多幸福，但人们首先当然应该购买必需品。尽管他的研究结果可以涵盖各个收入水平的人群，但却不适用于收入非常低的人群。他说：“那些人真的无法自由支配收入，手里的钱几乎全部用于购买必需品了。”　　研究还表明，债务对幸福感产生不利影响，而储蓄和金融安全往往会提升幸福感。一项关于英国家庭的调查发现，那些债务水平较高的人群拥有较低的幸福感，而一项针对已婚夫妇的研究则显示，更多债务意味着更多婚姻冲突。“储蓄有利于促进幸福;债务不利于幸福。但是，债务的弊端大于储蓄所带来的好处。”吕波密斯基教授说，“从幸福的角度来看，更重要的是摆脱债务，而不是增加储蓄。”　　所以，在您走出去、花大钱享受梦想假期之前，请确保您已经照顾好自己的基本需要，还清了债务，并有足够的钱防范生活中最糟糕的事情从天而降。如果您为了获得一流的人生经历而举债度日，那么，当信用卡账单到来时，一流的人生经历所带来的快乐将被还款压力一笔勾销。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>2012浙大考研经验</title>
    <url>/hobby-kaoyan-2012-zheda/</url>
    <content><![CDATA[本文转载自：http://www.cskaoyan.com/thread-88458-1-1.html
考研结束以来,一直被学弟学妹骚扰各种考研相关问题,遂将其整理,眼看明日就省赛了,为赚人品,特发此文.不敢高谈阔论,但求抛砖引玉.
特别声明:该贴所有内容,全部来自个人考研过程中的所闻所见所知所感,报考单位特指浙江大学计算机学院,如有不便尽情谅解.
先晒我的考研成绩,以免造成妖言惑众之嫌.初试:政治71,英语75,数学126,专业课121.总分393.复试:机试100,总分94.68.浙江大学 计算机应用与技术专业 录取.作为电子的小跨,最后能如愿以偿,一定程度上是神灵庇佑了.

写在最前.当很多人听说我要考研的时候，都诧异的问原因？是啊，身边有很多实力相当的朋友都找到了非常好的工作，所以便有好多人质疑我的决定,”你没必要啊”。我想说。我想去看更广阔的世界。当渐渐的觉得周围的绝大数人都已经有点不如你的时候，你是否想过，是不是你的世界太狭隘了。
以下为开始之前
[0]明确一个目标.其实很轻易的就可以找到一百个理由,来说服自己投入到浩浩荡荡的考研大军当中.但有包括但不限于以下动机的同学请深思:1.别人都考研了,我不考好丢人哦~2.反正我找不到工作的,还是考研吧3.我是党员,我带头考研4.我们亚美克星人都是要考研的.倒不是说考研有多么神圣,只是,这些不够坚定的理由很容易成为中途放弃的借口.我周围有好多这样的同学:十一月之前:还有好久呢,先玩了再说.十一月之后:反正也来不及了,裸考吧.结果可想而知.所以,请尽量的把考上心仪大学的研究生当成自己的梦想,只有梦想才能成为一直激励你前进的不竭动力.另外,假如你在考与不考中纠结,错过的不仅是考研的复习时间,还有就是就业的黄金时间,等到来年的三四月份.好的工作,可就剩的不多了.所以,莫要患得患失.做,就要做绝!
[1]什么时候开始一句话.越早越好.我是从暑假.也就是六月末开始复习的.其中在&lt;数学全书&gt;上耗费了大量的时间,所以到后期一度觉得时间不够用.所以有条件的话,请尽早的开始准备.所谓有备无患.如若不然,到后期,发现知识点掌握的不完全并且伴随着考试将近独有的焦躁,很容易产生失落感,这,很有可能羁绊你最后一个月的冲刺之旅.至于有人说,假如全身心投入,九月份开始也来得及.我完全同意,并想补充一句,假如你是天才的话,12月也来得及.
[2]辅导班的问题我没有参加过任何辅导班,所以不好妄下决断.但是我有许多上过辅导班的同伴,反馈意见是:1.别以为有超神级内部资料,其实都差不多.2.政治只有上辅导班才有好的资料吧,但其实铺天盖地到处都是.3.辅导班老师实力确实不错,当然能受益多少,完全靠个人. 所以总的来说.报一个三科全程挺不错的,至于vip.钻石卡等性价比不一定高的.各位请各自衡量吧.
[3]各科之间的关系我倒是觉得,宁愿没有一门课很拿手,也不能有一门课非常的不给力.毕竟,每年被单科受限刷掉的考生还是为数不少的.所以,请特别注意英语,即使考不到70分,也要有考过55分的把握.数学则为得分的重点,数学的好坏将会直接影响到总分的高低.有些人数学140,有些却只有90这50分的差距便立刻,高下立断了.专业课因为难度的因素,想得绝对的高分确实存在一些困难,但假如分数不错也将会有一定的优势.倒是政治,分差不容易拉开,变的有些鸡肋了.
[4]每天复习时间安排的问题其实蛮因人而异的,你愿意看一整天数学就看一整天数学,你想穿插进行也无所谓,都是些无伤大雅的习惯.所以尽管轻松的自己计划吧.一切还是以效率为第一出发点的.
[5]报考流程九月末网上预报名(研招网) -&gt; 报考单位现场确认(报考单位,拍照,缴费)-&gt;初试-&gt;复试资格审核(报考学校)-&gt;体检-&gt;复试
以下为初试复习:
[6]数学资料推荐:(0)教科书:&lt;高等数学 第六版&gt;上下,同济大学数学系,高等教育出版社.&lt;工程数学 线性代数 第五版&gt;,同济大学数学系,高等教育出版社.&lt;概率论与数理统计 第四版&gt;,浙江大学,高等教育出版社.(1)辅导书:&lt;数学复习全书&gt; 李永乐,国家行政学院出版社.&lt;历年真题解析&gt;,各种版本都有,挑一本看上去比较炫酷的吧.
我的数学复习过程.书本+课后习题(一个月).李永乐复习全书两遍(一遍全看+课后练习,另一遍注重整理题型)(三个月).真题限时训练(一个月).
数学复习始于课本,看课本的时候,务必参照去年的考纲(当年的估计不会那么快出,反正大同小异).看看哪些小节是不在范围内,以免浪费时间.课后习题也可以有选择性的做一做,并且一两道做不出也不必太纠结.因为,课本上的重点不一定是考研的重点.当然,做到处处搞懂必然是在好不过的了.当课本看完后,便可开始着重研究复习全书,复习全书对于考点和考点对应题型的整理做的还是很到位的,可着重研究之.在基础掌握的前提下,对于一些难度较大的题,可以选择性的做一做,毕竟试卷上的还是挺简单的,避免因为做难题顾此失彼,得不偿失(我就经常纠结在难题上，不能自已，后来做了真题才发现，真题都是相对简单的题).其中，特别要注意对计算能力的培养,现在的趋势开始变得趋向于弱化高技巧要求,而着重于基本功的考察,所以计算能力将变的尤为重要.这一阶段可能要花很大一段时间.当然,经过这一阶段,你的数学能力必将有一个质的提高.最后一个阶段,也就是真题的限时训练,给自己约定一个时间做一套历年真题,享受一下,克敌制胜,杀敌得分的快感.但同时吐血推荐以下过程,试着自己整理一下,复习全书上所有的考点和技巧,用空白草稿纸写下所有你对该知识点的理解.比如,当提到求极限,你能想到多少东西联想到多少技巧,请全部写下来.在日后的真题训练当中,再对照该纸,便可知道,究竟是没掌握好,还是根本就没注意到.我当时整理了10页左右A4纸,受益匪浅.考前的晚上,我就重点看了一下,我整理各个知识点.另外,整理过知识点以后,你就会惊奇的发现,原本,看似虚无缥缈的数学,原来就这么一些内容.另外,你还会惊奇的发现,有一些知识点是超级大冷,十年才考两题,这看与不看就看你自己把握了.
[7]英语资料推荐:(0)教科书:无.(1)辅导书:&lt;考研英语词汇 乱序版&gt;,俞敏洪,北京语言大学出版社.&lt;新编考研英语阅读理解150篇&gt; 世纪高教编辑部,世界图书出版社.&lt;历年真题&gt;各种版本都有.
我的英语复习过程:新东方考研单词乱序版(一个月).张剑英语黄皮书上(二个月).真题限时训练(一个月).考研英语试卷,分为阅读理解20x2.完型填空20x0.5.新题型5x2.翻译5x2.小作文10大作文20.
我的看法如下,千万不要忽略对单词的重要性的认识,假如阅读理解中,一句话三个以上单词不认识,试问怎样才能做对.所以,考研英语请从单词做起.至少将所谓的一千五百个核心单词都熟记以后,在进入下一个阶段.否则,单词能力将会大大阻碍你前进的步伐.单词搞定后,便可以重点对付阅读.考研英语试题4篇阅读共40分.几乎是必争之题.阅读若能得高分,其它题型的要求便可轻松许多.俗话说,阅读是基础,新题型上档次,作文写及格,其它打酱油.翻译和完型在我的复习当中是放弃掉的.分值太小,零碎的东西太多,不易准备,性价比略低.战略性的放弃.作文,也就背背模板,争取得个及格分.我的英语能力必不突出,所以放弃几个题型的技巧,必定不适合所有人,但那些和我一样,英语过线都有问题的人,可参考之.但若,英语实力强劲,想得高分,秒神题的,千万莫听我一派胡言.所以我的经验是,熟记所有的考研单词,做大量的英语阅读,记忆少量的作文模板,尝试所有的英语真题.
[8]专业课资料推荐:(0)教科书:&lt;数据结构(C语言版)&gt;,严蔚敏,清华大学出版社.&lt;计算机组成原理第2版 &gt;,唐朔飞,高等教育出版社.&lt;计算机操作系统（第三版）&gt;汤子瀛,西安电子科技大学出版社.&lt;计算机网络 第5版&gt;,谢希仁,电子工业出版社(1).辅导书:&lt;王道论坛专业课辅导书&gt;.&lt;王道论坛 真题精析&gt;.
我的专业课复习过程:.看课本(一个月),王道单科辅导书(一个半月),王道真题精析(一个月)
计算机专业课,历来被认为难度大,变化多,不易得高分.所以我的理解是,必须从课本做起,从最基础的知识点理解起,并没有任何的捷径可寻.只有自己真正的理解,每一处考点的原理,才能以不变应万变.所以,必须从教科书出发,毕竟教科书在知识点的阐述,和理解方面是有目共睹的.另外,大量的练习也是必不可少的.王道的辅导书,这一点做的很不错.知识点归类的非常科学,配以适量的练习,实乃居家旅行必备之选.特表要注意,专业课课本的每一页都能出一个题,甚至出一个综合题,所以请务必注意课本的重要性.没有对课本上知识的融会贯通,何来对题目的综合考虑.所以,切记勿只见树木不见树林.至于具体的重点,和复习方法.王道辅导书说的很明白,一群初试状元变态的实力,必然在我之上,所以我也就不再赘述了.还有,王道辅导书对历年统考真题是超级剧透的,所以做过之后便不必特意去练习历年真题,推荐大家使用王道的&lt;真题精析&gt;,以知识点为纲,细细整理不限于统考真题的一切考研真题(比如之前各个学校自主命题),实乃精品.一些,实在是需要记忆的方法,也可以整理在A4纸上,常常记忆之.以防纰漏.
[9]政治资料推荐:(0)教科书:无(1)辅导书:&lt;全国硕士研究生入学统一考试:思想政治理论考试大纲解析&gt;.&lt;风中劲草核心考点考题&gt;.各种押题试卷.有多少买多少.
我的政治复习过程:近代史课本(二个月),大纲解析做风中劲草核心考题(十天),做各种练习押题密卷的选择题部分(最后一个月每天几十分钟),背大题(最后二十天).那前两个月看的近代史,只为博君一笑.各位看官请忽略我这变态的心理.政治还是以记忆为主,若干知识点加以少许理解.便可轻松搞定.难度不大,规律易寻.分数差距也不太大.可以相对轻松的对待.政治的抢分点在选这题,所以请务必重视对选这题的把握.我的做法是,凡是能见到的选择题,我通通做掉.不得有一只漏网之鱼.慢慢的你便会发现选择题似乎也就那么一些招数,不足为惧了.大题,还是以记忆基础上的瞎掰为主.押题卷,确实能压中一些知识点,想要一模一样的被压中,确实不大容易了.你以为每一本都是王道辅导书?所以,政治就尽管放松吧.
以下为假如你一个不错的初试成绩
[10]导师成绩出来后,就可以试着联系导师,各个实验室各个导师的资料满大街的都是,假如有非常明确的方向的话会比较好,有的放矢,导师也会乐意接受之前有基础的考生.假如像我一样没有,就随便发吧.看着哪个炫酷就发哪个.现在比较大的实验室都是统一招生了,所以一个实验室发一封申请就好,一般会被转发到负责招生的老师那里,之后假如实验室对你有兴趣会安排面试.之后就看你的表现了.
[11]复试所占比例(初试成绩/ 5.0) 0.65+(机试成绩0.3+面试成绩0.7)0.35 = 最后得分.
[12]机试我之前训练了两年的ACM/ICPC,于是几乎没有特别准备,于是以下建议仅供参考.勤加练习,倒是可以在初试复习的时候,就特地找一些时间来做一些基础题.一来它本身就想一个游戏可以缓解复习压力.二来也可以提前接触机试是个什么玩意儿?近些年的考题还是以数据结构题以及模拟题为主.难度不太大,但是对编码能力还是有一定的要求.只要训练量到一定程度.相信至少不拉后腿.
[13]面试虽然有很多历年面试题,但是总会出现一些变化.我的感觉是,该记忆的历年真题还是得记忆.实在记不住就说不知道,或者知道多少就说多少.切记保持冷静和自信.另外,有一份好的机试成绩,保证为你加分不少.
[14]未尽事宜有任何,问题欢迎更贴询问,我会抽空回答的.请尽量的不要和我私下联系,可能你的问题也是其它人的问题,把这一问一答分享出来,岂不也是赚人品的一个过程?当然,漂亮MM可以例外,所以自认为漂亮的MM尽管私下联系我吧~
最后用一句话结束此文切记脚踏实地,切忌好高骛远,愿与君共勉.
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>2014CS学硕回忆经验</title>
    <url>/hobby-kaoyan-2014-cs-recall/</url>
    <content><![CDATA[本文转载自：http://www.cskaoyan.com/thread-241687-1-1.html
2014年CS学硕回忆经验纪 二本圆梦南大
首先说一下自己的情况。普通二本院校，没拿过奖学金，不是党员，不是班干部，四级三次才考过（考研准备的时候把四六级都过了），我的大学经历平凡甚至平庸，我一度以为可以就这样一直下去了，不过一年的考研经历让我成长了太多。跟大家说一点，不要害怕自己出身不好，就是出身不好才要考，考研不就是给自己一次重新开始的机会吗。我很喜欢的一句话：被人嘲笑的梦想，即使跌倒的姿势也会很豪迈。年轻人有梦想，老人有回忆。敢想。然后敢做。这很关键。我一直认为成功是由无数个因素构成的。就像九连环一样，环环相扣。只要把每个环节做好，天时地利人和，方能成功。实事上也是这样。

其中可能会有很多嘲笑，很多背后议论，不要在意，既然选择了远方，便只顾风雨兼程。那些告诉你不会成功的人，只因为他打心里认为自己不会成功，记住不要让别人偷走你的梦想。就像电影当幸福来敲门里那句：You got a dream, you got to protect it，People can’t do something by themselves; they wanna tell you you can not do it。
就像电影阿甘正传里那句：Life was like a box of chocolates, you never know what you’re going to get. 或许你就可以创造奇迹。
说一下我流水账式的回忆，大家凑合看吧
————————————- 初试：—————————————————–
2月18日，寒假放假的第一天开始了自己的复习历程。整个暑假每天早上起来晨跑，回来开始背那本《新东方考研英语乱序版》，下午晚上看《高教版高等数学上下册》。整个寒假背三遍整本绿皮书，看完了两本高数数学书，做完了所有的课后习题。记得当时老爸说我 这才有点学习的样子。毫无基础的看着书还真够慢的。
所用书籍：《新东方考研英语乱序版》《高教版数学上下册》《高教版数学对应习题解答》
3月-6月份，大三下学期，英语有了基础后我开始上午做《张剑阅读150》并仔细分析挑出生词，我英语不好，就自己在网上打印了了一些经济学人的英语文章看，http://www.ecocn.org/portal.php   几个月下来看了上百篇英语文章，慢慢发现自己的阅读能力不算这么差了，在六月份买了一本语法书看，英语语法书效果不大，最后我在网上搜了个屠浩民的语法视频，看过之后效果挺好。这个时间还是主要时间放在英语和数学上。数学方面的复习，重点学《线代》《概率》（大概五月份看完了两本书，做完了书上了课后题），。六月的时候买了《李永乐的数学全书》，开始上午看语法下午晚上做数学全书，第一遍全书的时候发现自己很多不会的地方，又回到课本对应的地方找知识点，并在全书上将不会的标注出来。（强调一下全书一定要在纸上做，千万不要光用眼睛扫答案，最好先把答案盖住，自己做，实在不会了再看答案，然后再吧题目重新解一遍）。所用书籍：《高教版线性代数》《高教版概率论》《李永乐数学全书》《语法书》（忘了名字了）及屠浩民老师的语法视频《 经济学人》杂志  很多真题选自上面
6月-8月份，暑假选择了留在学校，继续上午啃英语，下午啃全书，晚上开始啃专业课，这个才是最让人心酸的。英语这个时候开始做真题，最初只做了1986-2004年的真题用于练手，2004年到2014年做真题的模式大概是这样的，先把试卷做一遍，然后讲试卷翻译一遍，即练了阅读能力也练了翻译能力，作文可以先放一下，然后每篇阅读要把所有选择题每个选项选与不选的原因，一定要认真分析，不要看参考书 全部都写到纸上，大概一个年份的真题做上四五天的样子。数学的话，就是依然按照上面的模式做数学全书，不会的知识点标记上，经常翻看，大概到九月中旬我完成了第二遍数学全书。由于大学的时候完的太疯，四本书专业课科目都没怎么学过，自己开始了艰苦的自学，整个暑假看了操作系统和数据结构两本书，算是基本把这两门的框架建立了起来。然后开始做操作系统和数据结构看完了书就开始看王道的单科书，看完一章做一章的联系的题，整个暑假自己一个人默默的上自习，还是挺熬人的，中间去了次南大钟鼓楼校区，更加坚定了我的信念增加了我的动力，并且在暑假复习的时候邂逅了我美丽的女友。
所有书籍：《1986-2004年英语真题》（只做了阅读部分）《2004-2013年英语真题》（按上面的步骤分析）《数学全书》《操作系统 汤晓丹汤子瀛》《操作系统王道单科书》《数据结构 严蔚敏C版》《操作系统王道单科书》
9月-10月阶段，开始出现了一些浮躁，英语继续做着真题第二遍，数学全书第二遍结束后开始做《660题》。专业课组成原理和计算机网络，买了南京大学袁春风老师编写的组成原理及课后题，以及南大最坑的网络砖头书。组成原理袁春风老师的那本书写的特别好，给我的组成原理学习很大帮助。整个阶段主要是过渡期吧，因为马上就要报名了，在这个时间段自己的宿舍被盗了，电脑背包手机什么的全被偷走了，一直到现在警察都没把失物追回，自己存在电脑里的复习资料没有了，好几百个G呢。。。还有身份证也没了，当时家里的派出所电脑出了问题，补身份证只能三个月才能补，差点就以为自己没法报名了。
所有书籍：《660题》《组成原理 袁春风》《课后题解析》《南大制定网络砖头书》《组原和网络王道单科书》
10月-12月阶段，大概国庆的时候出了那本政治大纲，忘了叫什么名字了，红皮的，然后买了《政治1000题》作者名字让我忘了，先说一说政治我的复习策略吧。基本不占用白天的复习时间，以前下了晚自习会回去背单词看外文阅读，现在缩短英语时间，增加了政治复习时间，睡觉时间也晚了，政治的复习模式大概是看一章政治大纲，做一章肖秀荣的1000题。这个阶段英语刷第二遍真题，这次主要是专项练习，像阅读，新题型，翻译，分别专项练习并分析。下午数学开始做真题，和做英语真题差不多都是，先把真题做一遍然后再看答案打分，将其中的知识点列出来，每个题目分析一下，并将容易错的地方抄到习题册上，对不熟的知识点回到全书做题练习。晚上的时候看两下的两本专业课，看完专业课和四本王道单科书，开始做历年统考真题，然后我在王道上下载了历年南大的真题做，最后做了王道统考模拟题。12月份的时候，基本都是开始做模拟题，然后回顾遗忘的知识点，不断循环。而且12月份开始模拟英语作文，不过我最后还是模拟晚了，考场上依然写跑题了，不过最后英语70分还是让我挺意外的。
我没用什么英语模拟题，完全是靠真题，对真题有了解人，都知道 那些模拟题和真题的出题思路真的差距很大。数学模拟题用了合工大五套题，这个出的比较晚，而且没有完整版的答案，还有什么6+2模拟题，一定不要停止数学，即使再忙也要锻炼自己的数学能力。专业课用的王道统考八套题吧，还有在王道上找的历年南大真题回忆帮，这个帮助真心很大。
所有书籍比较多比较杂我自己都记不清了，就不列举了。需要我推荐书籍的可以联系我。
总结：
数学：贵在在于对知识点的梳理和建立知识点框架联系知识点，时常回顾常用的公式。做全书的时候一定要动手，这个非常重要的。另外，整理好笔记，对最后的冲刺阶段非常的有用。模拟题适当做，主要是为了保持手感，像四百题难度较大可以适当选择，真题一定要搞透知识点，每种题型能总结出自己的方法。
英语：一切以真题为主，单词必须记，每天回顾，可以用什么艾斯好客期限？好像有些不对。。。不一定要用单词书，找到适合自己的记单词的方法，我感觉比较好的方法是在做真题的时候把真题里的单词专门找个小本子列起来，每天看。阅读非常重要，常言得阅读者得天下，一定要认真分析，很多正确选项都是原文的同义转换。作文要重视，不要重蹈我的覆辙，早作联系。新题型每一种都要专门练一下，完形填空我就不说了，大家都懂的。还有我想说一点，阅读真心没有太多技巧，任何技巧在考场上那么紧张的地方你都不一定能想到，只要能把题做出来就行。
政治：我基本把政治的时候都放在晚上下晚自习之后，所以基本不会占用白天的时间。做题的方法就是看一章红宝书，做一章肖秀荣1000题，我大概做了两遍，然后最后被一下肖秀荣的最后五套冲刺题就足够了，政治想考60以下真的不容易。
专业课：这个是重头戏，最好四门专业课都看一下指定教材，我只看了组成原理和网络的指定教材。组成原理那本一定要看，强调推荐袁老师的书。网络就自己看着办吧，看了不一定考，不看可能没见过专有名字，这个还是自己掂量吧，我网络搞的不太好。数据结构如果基本不好就看一下严奶奶的视频，其中算法要重视，二叉树图等的算法，这不是统考，所有的算法最好都能自己实现一下。操作系统这大概是形式比较固定的一种，题型就那几种，PV操作，进程调度，银行家（这个太简单），磁盘调度，段 页管理等一些吧，难度不是很大。写到这里大概初试的经验才结束，感觉我怎么这么啰嗦。再扯一句，我所写的经验都是比较适合我自己的学习习惯的，没有必然适合的学习方法，因人而异，一定要找到适合自己的学习方法。初试的时候数学发挥失常，英语作文写跑题，这些都希望大家别像我学习，平时的时候多模拟一下考试环境，考试的时候真的什么意外都可能发生，以平常心考试才是最好的。本来我以为这次和南大式失之交臂，因为当时出考场就感觉数学考的太差了，还好最后成绩还可以说的过去。
———————————————–  复试——————————————————
南大有规定的两本笔试教材。不过我没怎么看，我看的是高教版的离散数学，今年离散数学没有考群，简单了很多。离散数学概念比较多，是那种看了不一定会，不看一定不会的书，前面几个章节还比较简单，后面的群和图难度较大，要多做练习总结思路。
编译原理我看的陈火旺的书，这个是我们本科教材，编写的不是很好，我强烈推荐推荐的那本龙书，讲的很不错。笔试科目认真研究南大历年的笔试真题，收获会很大。
上机的话 师哥已经推荐过了  用南大的那本C++的书，有几年上机题是课后题。
面试的内容我也写在回忆贴里了，这个还是比较考验综合素质的，重在于平时的积累。
2014 CS复试全面回忆 上机真题 面试血泪史
通关宝典就是两个字：坚持！坚持！再坚持！忍不住了，再忍一下就好了。因为我考研准备时间比较长，专业课基础很差，中间情绪波动较大，很多次都想要放弃了，不过最后我还是忍住了，毕竟南大是我的梦想。尤其是最后一个月是最难熬的，整个自习室里很压抑，每每看到许多题目自己都不会，那种心急搞的自己效率很低。我每天都会写一个考研日记记录自己的每天的计划，收获和做的不好的地方。每个周都会给自己一下午的休息时间，记得劳逸结合。
在考研期间一定要锻炼自己的身体，不然真的会腐朽掉的，我初试之前还发烧了，搞得自己初试的时候还在成天摸自己的额头，看看是不是还在发烧，现在想来还真是很滑稽。
考完之后，不要在意结果。付出了一定有收获。你在考研期间经历的、学到的，一生受用。会有一个时期觉得自己在突飞猛进的进步。
4月3号看到自己被录取的时候，心里的激动真的难以言表。每个人都有一段为了自己的梦想奋斗的日子，永远不要轻易放弃自己，力量来源于自信。送给学弟学妹一句话：不是因为有希望才努力，而是因为努力了才有希望。写到这里算是给我的考研画上了圆满的句号。就像导师说的，我将进入一段新的路程，还有更长的路要走，2015年的学弟学妹们，加油，愿你们圆梦南大。
PS：写一些需要注意的问题：
报班问题：我本人不推荐报班，完全是填鸭式教学（个人见解，勿喷），老师在上面讲学生下面记，报班的大部分都是买个心安吧，真正的强大来自于内心的自信。研友问题：研友很重要，可能给你带来激励，也可能让你堕落，所以你需要有一双伯乐的眼睛，找到能和自己一起奋斗的研友，会让你的考研路不寂寞，并能在出现心理问题学习问题的时候有个抒发讨论对象真的很不错。恋爱问题：这个怎么说呢，还是看自己吧，很多人说谈恋爱影响学习，这个我不好评价，重要的还是自制能力。如果和女友一起考研的话，最后不要再一起自习，两个人在一起貌似会产生一些影响学习的化学反应。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>人因梦想而伟大</title>
    <url>/hobby-man-is-great-for-dreams/</url>
    <content><![CDATA[作者：雷军
2014年11月21日晚，雷军在北大团中央主办的“活力中国说——一刻大型公益演讲”启动仪式上发表了演讲。北大国家发展研究院BiMBA对该活动提供了学术支持。部分MBA、EMBA校友有幸与小米科技创始人雷军先生展开了一场短暂而精彩的交流。以下为演讲实录。
每一个屌丝都渴望像马云一样逆袭
昨天我在乌镇参加了全球互联网峰会，在这个会议上有马云，也有苹果公司的高级副总裁。主持人抛出了一个问题，说：“雷军，你说你有一个目标，要用五到十年的时间，做成智能手机市场份额的全球第一”。我忙着点头，我的确说过。但是他没有问我，他去问苹果公司的高管，说：你怎么看？这个苹果公司的高管也很厉害，他说：“Easy to Say, Hard to Do”（说起来简单，做起来难）。在那一刻，我觉得很尴尬，主持人说：“雷军，你怎么想？”


我冷静了一下，我说：“马云在阿里巴巴上市的那一刻，说过一句话，‘梦想还是要有的，万一实现了呢’？”我的演说水平远远没办法跟马云相比，马云的号召力和演说水平，我是望尘莫及。除了我湖北普通话之外，我觉得我一个做技术和作为理工科的人来说，跟他的口才比不了，因为马云也是毕业于非常非常有名的名校，不亚于北京大学，叫杭州师范大学，专门培养老师的，真的比我能说，尤其是我听了马云在上市的时候还讲过说：像他这样的都能成功的话，80%的中国人都可以成功，这个听得我们每个人都热血沸腾。他说“我高考几次落榜，好不容易上了杭州师范大学还找不到工作”。当然马云今天有资格讲这个话，讲得也特别震撼，每个人，尤其每一个屌丝都渴望像马云一样逆袭。
创业时，“十来个人，七八条枪，要去做手机，有谁相信我们能赢呢？”
讲完马云这句名言以后，我又补了一段话。我说四年多前小米刚刚创业，在中关村，十来个人，七八条枪，要去做手机，有谁相信我们能赢呢？手机这个行业是刀山火海，前面有三星，有苹果，后面有联想，有华为。我们看到摩托罗拉不行了，诺基亚也不行了，黑莓也不行了，连HTC也不行了，最近索尼也不行了。这个市场竞争极为激烈，一个正常人讲到智能手机，就觉得这个市场竞争很激烈。
三年杀到全国第一，总该有点“全球第一”的梦想
三年前我们的产品刚刚发布。仅仅用了三年时间，谁又想过这十来个人的小公司，用了不到三年时间，有苹果、有三星、有华为、有联想，在这个市场里面杀到了全中国第一，全球第三。当我们今天有这样的业绩，有这样的起跑线，我觉得我们总应该有一点点梦想，用五到十年时间杀到全球第一吧。对吗？原来我们至少排在一百名开外。
功成名就后，人生四十再出发
所以梦想还是要有的，那四年前我梦想的动力来源于哪里呢？其实办小米对我来说是一个很难很难的事情，为什么呢？是因为我在办小米之前有幸参与了金山软件的创办，今天我依然是金山软件的董事长和大股东，而且我还有幸办过一个电子商务公司，叫卓越网，后来卖给了亚马逊，应该来说我的人生也足够了。所以在金山IPO之后我退休了，还干了三四年的投资，而且做天使投资，业绩还不错，绝对能排上中国天使投资界的第一排，肯定没问题。
那你说做投资总不能天天这么操心吧，是什么样的动力使我下定决心去干这么累的一件事情呢？这件事真的很累。我在那个阶段，在我做天使投资、从金山退休的那个阶段，我有一天晚上从梦中醒来，我问了自己一个问题：我40岁了，在别人眼里功成名就，已经退休了，还干着人人都很羡慕的投资，我还有没有勇气去追寻我小时候的梦想？
我觉得岁数越大，谈梦想越难。大家现在都是最有梦想的时候，你们到了40岁的时候还有梦想吗？面对残酷的现实，还有几个能笑对今天，笑对明天呢？我当时问我自己，我还有没有勇气去试一把，这么试下去风险很高，有可能身败名裂，有可能倾家荡产，而且更重要的是我在别人眼里已经是一个成功者，我需要冒这么大的风险去做这么艰难的一件事情吗？其实我真的犹豫了半年时间。最后我觉得这种梦想激励我自己一定要去赌一把，我说只有这样做，我的人生才是圆满的，至少当我老了的时候，我还可以很自豪地说：“我曾经有过梦想，我曾经去试过，哪怕输了”。所以我最后下定了决心办了小米。
当“雷布斯”遇见乔布斯，《硅谷之火》点燃梦想
办小米刚开始我认为我100%会输，我想的全部是我怎么死，我真的很庆幸，我们居然只用了三年，完成了一个连我自己都没法相信的结果。那么我的梦想是什么？我为什么会这样的梦想？
是因为我跟大家同样岁数的时候，在我18岁的那一年，曾经青春年少，无意之中在图书馆看了一本书，改变了我一生。那是我大学一年级第一学期，我上的是武汉大学，我在我们武大的图书馆看了一本书，这本书叫《硅谷之火》，那是1987年。这本书讲述的是七十年代末、八十年代初，那些硅谷的英雄创业的故事，其中主要的篇章就是讲乔布斯的故事。乔布斯在七十年代末、八十年代初就代表着美国创业。
我记得九十年代的时候，比尔·盖茨很成功的时候，比尔·盖茨讲“我不过是乔布斯第二”，乔布斯在八十年代就已经如日中天。当时看了这本书，激动的我自己心情久久难以平静。我清晰的记得看了这本书以后，我在武汉大学的那个操场上，沿着那个400米的跑道走了一圈又一圈，走了好几个通宵，我怎么能塑造与众不同的人生？
我想的更多的是说在我们中国这个土壤上，我们能不能像乔布斯一样办一家世界一流的公司？我觉得只有这样，你才无愧于你的人生，才会使你自己觉得人生是有价值、有意义、有追求的。当然，在二十六七年前的中国，条件比今天差很多，要做点事情远没有今天容易。
当我有这样的梦想以后，我认为说起来容易，做起来难——放到口头上是没有用的，怎么能够落实到实际学习和工作中？我当时给我的第一个计划，在二十六七年前，就是两年修完大学所有的课程。我真的是武汉大学在八十年代不多的两个双学位，而且我绝大部分的成绩应该都是优秀，几乎所有的课。我记得我的成绩在我们同学里面排到全年级第六，我们全年级一百多人。
所以怎么能够落实到第一个梦想？就是我能够在一个赛道上把学习学完，因为我认为你还是要有基本功的沉淀，有了第一个基本功的沉淀，我们又给出了第二个目标。大家说你有没有本事在一级学报上发篇论文？我就用两年的时间在一级学报上发篇论文，我说我一定要完成第二个目标。为了琢磨这个我在图书馆里面读了很多一级学报，到底发什么文章呢，他们到底在做什么。
所以，有梦想是件简单的事情，关键是有了梦想以后，你能不能把这个东西付诸实践，你怎么去实践，你怎么给自己设定一个又一个可行的目标？当然，有了这样的目标还是不够的，因为要成功不是一件简单的事情，他需要你长时间的坚韧不拔，百折不挠。就像我自己，到了我40岁退休了以后，我还有没有勇气去试一把？
所以非常感谢我们组委会给了我这个机会，今天我可以很自豪的跟大家分享，我在40岁的时候没有忘记我18岁的梦想，我去试了。虽然我知道今天的小米说成功为时过早，说谈击败苹果为时过早，但是“梦想总是要有的吧，万一实现了呢”？
人因梦想而伟大
我比大家大概大两轮，大20多岁，我也跟很多年轻人经常交流梦想。我自己特别特别喜欢一句话，叫做“人因梦想而伟大”。在下午我们讨论的时候，还有人说这是美国哪个总统讲的，是，我说是我抄来的，我觉得我们在这里的每个人，只要你有了梦想，你就变得与众不同。周星驰也讲过一句名言，叫“人没有梦想，和咸鱼有什么差别”。所以你关键要有梦想，有了梦想是你迈向成功的第一步，有了第一步以后，你一定要为自己的梦想去准备各种坚实的基础。
成功需要勤奋和把握机遇
那么谈到梦想的实现，我最近还有一句话挺出名的，也是我抄来的。叫“台风来的时候，猪都会飞”，听说过吗？就是说你要成功了，要找台风口，当台风飞过来的时候，猪都可以飞，是猪你都可以飞。
当然了，我其实想表达两层的意思，尤其是给在座的同学们，我觉得第一个：没有坚实的基本功，没有勤奋是成功不了的：第二个，有了勤奋，有了坚实的基础也不一定能成功。
还需要什么呢？还需要台风口。还需要把握大的发展机遇，把这个机遇把握好，抓住这个机会，你才有机会成功。那么小米把握的是什么机会呢？为什么这个台风这么厉害呢？
其实小米精准的踏到了智能手机换机的时间，诺基亚不行了，苹果刚刚起来，小米应运而生，用了一套全新的模式，在短短三年时间里面成了中国第一。其实整个成长速度远超想象，小米三年做下来，今年大概有多大规模呢？今年大概销售6500万只手机，营业额大概会在700亿人民币到800亿人民币，这是一个三四年的创业公司。这个应该已经创造了全球的奇迹，这背后是什么呢？这背后是坚实的基本功和非常好的对时机的把握。
给北大学生的三条锦囊妙计
所以我自己工作了20多年，我对各位同学们的建议就是：
第一条，要有梦想。第二条，要设定Step by Step努力的目标，要制定阶段性的目标，不要着急。第三条，要重视机遇的重要性。我觉得很聪明的一些同学都觉得聪明加勤奋天下无敌，其实仅有聪明和勤奋是远远不够的，怎么把握时代的机遇，怎么在大方向上正确，我觉得这一点也非常关键。
所以今天只有短短的一刻钟，感谢两位老师给我省了这么多时间，我就简单的讲到这里，谢谢大家。
来源：北大国家发展研究院BiMBA
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>思维习惯</title>
    <url>/hobby-mind-habits/</url>
    <content><![CDATA[聪明人是如何思考问题的？近三四百年来，人们一直在反思更加有效的思考模式：我们究竟应当如何看世界,怎样思考问题。 从问题到答案，从原因到结果，从对称到不对称，从思辨到相对，从观察到实验，从期待到途径…… 
不管是黑格尔还是康德，再到尼采，海德格尔，弗洛伊德，似乎都未找到真正的出路。无数多的先贤曾下工夫去探索答案，期望能给迷茫的人们以答案。１、任何事情都有因果。　　因果构成世界，“因”决定“果”。任何的结果都有一个、几个甚至更多的因，我想，只要找到了“因”，就可以掌握“果”。理论上，是成立的，但由于世界是复杂的，任何一个“果”可能会有很多的“因”约束，比如命运，“命”不可控制，但“运”可以控制，控制“运”的方法，就是找到真正的“因”，找到真正的因的方法就是，设法减去次要的“因”。２、方式和角度决定结论。　　不同的思考方法，不同的观察角度，会决定不同的结果。在我们的习惯性思维控制下，我们经常顾此失彼。当我们观察和思考一个事物的时候，经常出现偏颇，不是我们没看到而是我们的感知不到，心中没有眼里就没有。　　所以，我们最好的选择是，调整和改变思考和观察的方法，直到一个自己觉得比较舒适的位置，总会有一个较为客观的世界，呈现在我们的面前。
 
３、任何事物的发展都是呈阶梯状的。比如，人往高处走，怎么走？拾“级”才能上。阶梯是规律，更是方法。在所有的规律中，该规律的独特价值是，将理论与实践结合在了一起。一切的成功都应归结为目标的达成。对目标进行细化、量化、具体化的过程，就是形成阶梯的过程!４、哲学不是处世技术，而是一种爱智慧，更是一种关怀世界的方式。　　不要寄希望于哲学能提供给你一套处世技术。　　哲学只是一种爱智，其核心是终极关怀，是对彼岸世界的一种信念，一种坚持。哲学对生活的启迪应当是文化意义上的启迪，而启迪的过程就是把人本身作为根本追求的过程。当然，哲学并不是枯燥的，反而是灵动的，是诗性的，是美丽的，是开心的。从某一个角度上看，每一个人都是哲学家，因为，我们每天都在感悟。感悟是哲学对人的最基本要求。　５、问题经常是在我们试图解决它的时候发生。　　很多心理学家认为，心理学上有些事情是因为我们去解决它们才构成问题。比如抑郁症，我们创造了抑郁症这个词，抑郁就开始流行。因为我们大脑里有了，生活中我们就真正找到了证据。再比如孤独，我们意识到自己的言行符合孤独的概念时，我们的孤独感随之袭来。　　概念和定义对人们的利益是显而易见的，但危害也是显而易见的。　　６、世界的很多东西，我们永远分不清楚，是混沌的。但我们可以调整自己的高度来解释自己。　　统一的身后一定隐藏着分裂，和谐的身后一定隐藏着冲突，爱的身后一定隐藏着恨。　　但，我们经常会发现，当我们站在一个层级看问题的时候，我们发现事物是对立的，当我们站在一定更高的高度看时，发现事物是和谐的，对立双方是并存的、互补的。我对如何形成自己的高度，曾经做过论述：　　一是处理好整体与局部之间的关系：　（1）整体大于各部分之和；　（2）任何一个整体都是另外一个整体的局部，而任何一个局部都是另外一个局部的整体。毛主席说：大道理管中道理，中道理管小道理。　　二是处理好三个思考层面之间的关系：　（1）感性层面；　（2）理性层面；　（3）悟性层面。　　人的高度从第一层面起步，到第二层面，然后到第三层面。最后返朴归真，融会贯通。　　三是处理好理论与实践之间的关系：　（1）任何“高度”都是来源于一线的实践，又抽象于一线的实践。没有务实的精神和抽象的方法，不可能有高度。我原来的同事、著名经济学家温铁军先生曾反复谈论过——怎样用脚做学问，现在想来更感难得。
（2）将思想系统化，形成理论，理论高于思想，但必须经过实践验证。
训练题(注:这12道题目主要训练的是人在分析问题时的思维韧性，一个人的思维就像人的韧带，越是训练，越是轻松自由。)　1、父子二人经过五星级饭店门口，看到一辆十分豪华的进口轿车。儿子不屑地对他的父亲说：「坐这种车的人，肚子里一定没有学问！」父亲则轻描淡写地回答：「说这种话的人，口袋里一定没有钱！」 （注：一个人对事情的看法，经常反映的是他的内心态度，态度决定一切，态度的核心是自主选择）　　2、晚饭后，母亲和女儿一块儿洗碗盘，父亲和儿子在客厅看电视。突然，厨房里传来打破盘子的响声，然后一片沉寂。是儿子望着他父亲，说道：「一定是妈妈打破的。」「你怎么知道？」「她没有骂人。」 （注：我们习惯以不同的标准来看人看己，以致往往是责人以严，待己以宽。）　　3、有两个台湾观光团到日本伊豆半岛旅游，路况很坏，到处都是坑洞。其中一位导游连声抱歉，说路面简直像麻子一样。说而另一个导游却诗意盎然地对游客说：诸位先生女士，我们现在走的这条道路，正是赫赫有名的伊豆迷人酒窝大道。」 （注：虽是同样的情况，然而不同的角度，就会产生不同的态度。思想是何等奇妙的事，如何去想，决定权在你。）　　4、同样是小学三年级的学生，在作文中说他们将来的志愿是当小丑。中国的老师斥之为：「胸无大志，孺子不可教也！」，外国的老师则会说：「愿你把欢笑带给全世界！」 （注：身为长辈的我们，不但容易要求多于鼓励，更狭窄的界定了成功的定义。）　　5、在故宫博物院中，有一个太太不耐烦地对她先生说：「我说你为甚么走得这么慢。原来你老是停下来看这些东西。」（注：有人只知道在人生的道路上狂奔，结果失去了观看两旁美丽花朵的机会。）　　6、妻子正在厨房炒菜。丈夫在她旁边一直唠叨不停：慢些。小心！火太大了。赶快把鱼翻过来。快铲起来，油放太多了！把豆腐整平一下！「哎？」妻子脱口而出，「我懂得怎样炒菜。」「你当然懂，太太，」丈夫平静地答道：「我只是要让你知道，我在开车时，你在旁边喋喋不休，我的感觉如何。」 （注：学会体谅他人并不困难，只要你愿意认真地站在对方的角度和立场看问题。）　　　7、一辆载满乘客的公共汽车沿着下坡路快速前进着，有一个人后面紧紧地追赶着这辆车子。一个乘客从车窗中伸出头来对追车子的人说：“老兄！算啦，你追不上的！”“我必须追上它，”这人气喘吁吁地说：“我是这辆车的司机！” （注：有些人必须非常认真努力，因为不这样的话，后果就十分悲惨了！然而也正因为必须全力以赴，潜在的本能和不为人知的特质终将充份展现出来。）　　8、甲：「新搬来的邻居好可恶，昨天晚上三更半夜、夜深人静之时然跑来猛按我家的门铃。」 乙：「的确可恶！你有没有马上报警？」 甲：「没有。我当他们是疯子，继续吹我的小喇叭。」 （事出必有因，如果能先看到自己的不是，答案就会不一样在你面对冲突和争执时，先想一想是否心中有亏，或许很快就能释怀了）　　9、某日，张三在山间小路开车，正当他悠哉地欣赏美丽风景时，突然迎面开来一辆货车，而且满囗黑牙的司机还摇下窗户对他大骂一声：“猪！”张三越想越纳闷，也越想越气，於是他也摇下车窗回头大骂：“你才是猪”才刚骂完，他便迎头撞上一群过马路的猪。 （不要错误的诠释别人的好意，那只会让自己吃亏，并且使别人受辱。在不明所以之前，先学会按捺情绪，耐心观察，以免事后生发悔意。）　　10、小男孩问爸爸：“是不是做父亲的总比做儿子的知道得多？” 爸爸回答：“当然啦！” 小男孩问：“电灯是谁发明的？” 爸爸：“是爱迪生。” 小男孩又问：“那爱迪生的爸爸怎麽没有发明电灯？”（很奇怪，喜欢倚老卖老的人，特别容易栽跟斗。权威往往只是一个经不起考验的空壳子，尤其在现今这个多元开放的时代。）　　11．小明洗澡时不小心吞下一小块肥皂，他的妈妈慌慌张张地打电话向家庭医生求助。医生说：“我现在还有几个病人在，可能要半小时后才能赶过去。”小明妈妈说：“在你来之前，我该做甚麽？” 医生说：“给小明喝一杯白开水，然后用力跳一跳，你就可以让小明用嘴巴吹泡泡消磨时间了。”（take it easy，放轻松放轻松些，生活何必太紧张？事情既然已经发生了，何不坦然自在的面对。担心不如宽心，穷紧张不如穷开心。）　　12、一把坚实的大锁挂在大门上，一根铁杆费了九牛二虎之力，还是无法将它撬开。钥匙来了，他瘦小的身子钻进锁孔，只轻轻一转，大锁就“啪”地一声打开了。 铁杆奇怪地问：“为什麽我费了那麽大力气也打不开，而你却轻而易举地就把它打开了呢？”钥匙说：“因为我最了解他的心。” （每个人的心，都像上了锁的大门，任你再粗的铁棒也撬不开。唯有关怀，才能把自己变成一只细腻的钥匙，进入别人的内心，了解别人。）
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>心动时刻</title>
    <url>/hobby-palpitation-moment/</url>
    <content><![CDATA[译者：风筝飘带
每一对恋人的爱情故事中都有很多个第一次：第一次约会，第一次亲吻，第一次吵架，当然还有第一次坠入爱河。但是恋人之间是怎样从相爱发展成愿意厮守终身的呢？
Reddit网站周一发表了一个帖子，让许多已婚男性描述他们是在什么时刻认定妻子就是自己的终身伴侣的。下面23个小故事读来让人格外温暖。读完之后别忘了在评论中留下你的故事哦。
1.当发现两人很匹配–简直是一模一样
“当我们第一次搬到一起住时，在各自把自己的藏书从行李箱搬出来之后，我发现我们最爱的小说全都是一样的，也就是说每一本书现在都变成两本了。我记得当时对自己说，‘对，她就是我的另一半了’。”

2.当她成为了他的依靠
“我父亲刚刚去世，我去一个附近距离五小时车程的州参加了他的葬礼。晚上我一个人孤单单地呆在旅馆，这时我的女朋友打电话给我问我感觉怎么样。我说还行，但是实际上我悲伤欲绝。半夜我睡不着觉，没想到在凌晨四点的时候，发现有人在敲房门。。。我从窗口一看，立马就哭了。我的女朋友大半夜开车五个小时过来了，只为了在我最艰难的时刻陪着我。”
3.当他意识到她无条件地支持他
“我们刚认识的那天晚上，我正在失业中，相比之下，她的各方面条件实在是太好了。当我勉强告诉她我失业了的时候，她很淡定地说‘看来今晚的酒水饮料要我买单了！’我当即觉得她很特别。一年后我向她求婚了。我们现在在一起已经十年，有两个孩子，她在家当全职太太，而现在当然是我为酒水饮料买单了。”
4.他们会为同一个笑话大笑，即使别人都觉得这个笑话不好笑
“我们和一群朋友一起去看电影。电影本身很傻，但我发现我在笑的时候还有另一个人总是和我一起笑。我找到了这个人，并且把她约了出去。我们继续在没有别人笑的场合放声大笑。我们现在已经结婚近25年了，仍然如此。”
5.当他发现两个人已经合二为一
“某一个时刻，我发现我不再想‘我’怎样怎样，而是总想着‘我们’怎样怎样。”
6.当他可以毫无顾忌地表现自己的童真，而她从不介意
“当时我们已经约会了三四个月。有一天我们手拉手走出一家商店，到了人行道边的台阶，我俩毫不犹豫地一起跳了下去，就像小孩子一样。现在我还经常和女儿一起跳台阶。如果你有一颗童心，那么找一个同样有童心的另一半吧。”
7.当她比世界上任何人都更了解他
“有那么一次记忆，是在我的18岁生日时。当时我每天从早上八点到晚上四点都在做一个重体力的工作，每天回到家只想洗个澡，打个瞌睡。不过我妈妈有时会折腾些别的。。。那天她找了我的一些朋友和亲戚，要给我办一个惊喜生日派对。任何一个了解我的人都知道我并不想要这种惊喜。但是在所有朋友和亲戚当中，只有我现在的妻子提前告知了我派对的事情。那年夏天我就给她买了订婚戒指。”
8.突然间，他的女朋友同时成了他最好的朋友
“我是在她凌晨五点喊我起床去酒吧看球赛时认定她的。”
9.当他发现女朋友爱他所爱的一切
“有一天我正在卧室穿衣准备出门时，听到我老婆（当时的女友）在客厅大喊‘混蛋，这就是你阻挠印第安纳琼斯的下场！’随后不久我就向她求婚了。我知道她当时在看一部我爱看的电影《最后远征》（《夺宝奇兵》的续集）。”
10.当他在想骂街的时候不需要克制，因为她也不会克制。
“我开车的时候，如果有其他司机做了让我不爽的事，我之前的女朋友们一般会劝我不要骂街，要冷静下来。我不是个疯子，只是个意大利人而已。我只是朝那些司机吼几句，然后就继续开自己的车。当我第一次和我现任老婆同坐一车时，她开着车，突然有另外一个车强行插到了前面。我还没反应过来，她就大骂：‘你XX这是耍我呢？’ 当时我就认定了她。”
11.当他的女朋友与他分享同一个梦想时
“我特别喜欢澳大利亚，希望有一天能去旅游。我和她开始约会后不久，我的生日就到了，她不知从哪里找来一张二十澳元的纸币，送给我作为生日礼物（当然还有其他礼物）。我一直藏着这张纸币。直到有一天，我们终于到了南半球，去澳大利亚旅游了。我把这张钱花了，给她买了东西。”
12.当他觉得“和她永远在一起”是一个不错的选择
“记得在我们第一次约会后，我心里想：‘我想一直和这个女孩子呆在一起。’ 四个月后我们结婚了，现在已经结婚十年。”
13.当她在他生病时不离不弃
“我因为臀部骨折住院，她整整在医院病床前陪了我四天，不愿意离开。那年早些时候我母亲刚刚去世。就在那一时刻，我认定她就是我的另一半，我们从此之后一直相伴。”
14.当他发现她比他还要书呆子气（当然指从好的方面说）
“当我把甘道夫（电影《指环王》人物）宝剑的名字念错了时，她纠正了我。哦老天，我好爱这个女人。”
15.当他的女朋友愿意为了他而克服自己的恐惧
“在我和老婆刚刚开始交往三天的时候，她在我嫂子的沙发上为我弹唱‘Hey Jude’这首歌。她很害怕上台表演，所以看到她为我表演的时候我知道她就是我的另一半。六年后的今天，我们有一个可爱的儿子，取名为Jude（裘德）。现在世上任何的恐惧我都会陪她一起面对。”
16.当他真正有了被爱的感觉
“有一阵我负责看管她的车。有一天车在停车场被撞了（非我的责任），她得知后第一时间关心的是我有没有受伤，而不是车的损坏。当你发现你的恋人更关心你，而不是更关心一件昂贵的物品时，你就知道她是你的另一半。”
17.当他发觉，如果和她共度一生，那么生活会是一场有趣的冒险
“在我们刚开始交往不久，我们准备去意大利旅游，还在机场候机时被告知由于爱尔兰火山爆发，航班被取消了。有一位女士过来问我们‘现在你们想去哪儿？’我女朋友（现在是老婆了）转身对我说‘天哪，我们去秘鲁看马丘比丘遗址怎么样？’当时我们只交往了几个月，但是我在秘鲁首都利马向她表白了。现在我们结婚了，上个月刚刚庆祝过两周年结婚纪念日！”
18.当他的女朋友为了帮助他愿意牺牲一切
“我们当时正在出去吃晚饭的路上。我停下来给车胎打气，突然开始下大雨。虽然出门前她花了三个小时梳洗打扮，但是她当时毫不犹豫地穿上一件外套走下车，在雨中为我打着手电。”
19.他记得他们无时无刻不相爱
“我实在是不记得我有哪一个时刻是不想娶她的。”
20.当他的女朋友成了他力量的源泉
“我们已经三十六个小时没有睡觉了，当时我们正在从芝加哥六旗公园开车回家。我们迷路了，一般迷路的时候我都会很郁闷或者慌乱，但有她在身边指路我就格外镇定。我觉得她仅仅是坐在我身边就能让我镇定下来这一点非常重要，让我感到我们的恋爱关系不同一般。”
21.当他觉得没有理由不去爱她
“我有一个好朋友曾经问我‘你为什么不娶她？’我想了想，确实没有理由不娶她。今天我们刚刚度过结婚七周年纪念日。”
22.当那些“糟糕”的往事也变成了美好的回忆
“有一次我们在超市购物后，在门口等着外面雨停。我突然觉得在这样的倾盆大雨中跑几步挺有趣的。我转身正准备问我女朋友是否愿意，结果她抢先问我想不想跑到雨中去。于是我们冒着雨走向我们的车，一路淋成了落汤鸡，却大笑不止。”
23.当很多琐碎的细节聚少成多
“我倒说不出哪一个时刻认定了她，我认为是生活中许多的小事聚少成多，最终让我做出了决定。她是我在世上最好的朋友，也是我看来最美的女人。有一天我决定娶她，让自己下半辈子都有她陪伴。当时我还认为这会不会是三分钟热度，担心一两年后我会不会变心。但这并没有发生。我现在还像第一天认识她那样爱她。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>捡贝壳的人</title>
    <url>/hobby-people-who-pick-up-shells/</url>
    <content><![CDATA[作者：张文亮
爱因斯坦说：“在人类的历史上，能够将物理实验、数学理论、机械发明结合为科学艺术的人只有一位，那就是牛顿。”
牛顿发现万有引力定律，发明微积分，首先提出可见光是由红、橙、黄、绿、蓝、靛、紫七个分光组成的。他将数学导入科学，使物理、化学成为更精确的学问。在牛顿的动力学三定律中，数学成为描述宇宙运动的语言。种种杰出成就，为他赢得“历史上最杰出的科学家”与“近代物理学之父”的尊称。
一
牛顿生于1642年12月25日（据当时英国使用的儒略历）午夜，是一个早产儿。父母亲都是信仰坚定的基督徒。在牛顿出生前三个月，他的父亲病逝。家徒四壁，母亲哈拿绝望地抱着奄奄一息的早产儿牛顿，向上帝发出了这样的祷告：“你若垂顾婢女的苦情，眷念不忘婢女，赐我一个儿子，我必使他终身归于你。”

在牛顿的一生中，母亲的这个祷告对于他的个性与信仰有很深刻的影响。他经常思索母亲当年的祷告——上帝让他活下来，一定有些事是要他去完成的。
1661年6月，牛顿进入剑桥大学。牛顿是个穷学生，母亲存的钱只够付学费，他必须为老师做实验助手，才能赚取生活费。如此无意中，牛顿接近了当时剑桥的优秀教授，承袭了这些教授一生的研究精华，成就了他后来的名言：“如果我看得比别人更远些，那是因为我站在巨人的肩膀上。”
好学的牛顿在剑桥大学不但不浪费任何资源，还遇到了影响他一生的好老师。亨利·摩尔是影响牛顿科学与信仰最深的老师。摩尔教授是数学家，也是位虔诚的基督徒。摩尔以一个老师对学生的敏锐直觉，一下子就发现牛顿的不同。他发现牛顿在每学期开学以前，先利用假期，将上课要学的所有课本都看完，等到上课时，牛顿已经在看比那门课更进阶的研究报告了。牛顿自己也写道：“当我走进教室上课时，常发现对上课内容的了解深度，已经超过了我的老师。”这种读书法会令一般老师倍感压力，摩尔却把牛顿找来，给他程度更深的书，并且让自己的1800本藏书成为“随时向牛顿开放的图书馆”。同时，摩尔长期为牛顿支付生活费。
1664年，牛顿开始利用课余时间进行自己的研究。他首先用三棱镜研究光的结构，发现光的分光有不同的折射率。1665年至1667年，英国发生可怕的黑死病，死了许多人。大学宣布停课，政府下令所有人不准离家远行，以免感染或传播黑死病。在这段时间，牛顿由无穷等比级数的解法里创立了微积分。
事后有人问牛顿，为什么他能够有这么伟大的发现，牛顿答道：“我始终把思考的主题像一幅画般摆在面前，再一点一线地去勾勒，直到整幅画慢慢地凸显出来。这需要长时间的安静与默想。”
牛顿对科学的思索与他的信仰有密不可分的关系。他常在信仰的思索里想到科学，在科学的思索里想到信仰。1666年，他开始思索地球在轨道上的运转，并且计算运转时的重力与离心力的关系。1669年，他在笔记上写下他的发现——万有引力定律。
牛顿是在什么情况下发现万有引力定律的呢？他的好友史塔克利说：“牛顿经常在花园散步，有一天中午他回来了，对我说他看到一个苹果掉到地上，想到了万有引力。”这个苹果后来成为牛顿发现万有引力的标志，其实更重要的是，牛顿有独自来到花园祷告与默想的习惯。因此后人说：“近代科学源自牛顿对上帝的默想。”
二
当时许多科学家、教授都看不出牛顿的杰出，甚至讥讽他的理论“又是解释天体论的陈腔滥调”。幸好这时有贝若的支持。
贝若是当时欧洲的光学泰斗，剑桥大学首屈一指的数学与天文学教授，是少数能仔细验证牛顿数学与物理学观念的人，也是一名基督徒。他私下找到牛顿，对这个最优秀的学生提出最严格的要求。贝若要求牛顿：“回到物理学最基本的假设上，精密地验证每个假设，一次又一次，几乎无止境地反复验证，并投入所有的精力，以免将其浪费在无用的芝麻小事上。”然后贝若申请退休，让27岁的牛顿接替他的职位，成为剑桥大学的教授。然而，剑桥大学的教职并未将牛顿带入桃花源。当时贝若的职位有很多人在背后垂涎，牛顿一接任，立刻感受到号称学术自由、独立的大学里面众多的派系纷争、人事倾轧。喜欢安静思考、不爱交际的牛顿被排挤，成为权力圈外的边缘人。
牛顿的老友魏克金斯写下：“牛顿看起来更孤独、沉默，30岁不到，头发已经半白。”牛顿下定决心不涉入这些纠纷，不管人家怎么中伤他，他只把努力放在科学研究与对基督的信仰上。
慢慢地，他将更深的思索与实验结果写成旷世名作《原理》一书。这本书不只记载了牛顿的科学发现，也反复提到他的“机械论”与神的关系。
1672年，牛顿加入英国皇家学会——英国最高级别的科学研究学会。《原理》的出版，对全欧洲的科学界是一大震撼，引来称赞也招来攻击。牛顿说：“一个人如果控制不了自己的脾气，脾气将控制你。”引导牛顿一生的，是信仰而非起伏不定的脾气。
三
牛顿并非科学研究上的常胜将军。他从1669年至1691年长期研究实验化学，并没有取得什么突破，不过因此结识了有“近代化学之父”之称的波义耳，两人通信长达16年。年长的波义耳不仅在研究工作上帮助牛顿，更重要的是在牛顿遭受猛烈抨击的时候，他的榜样力量坚固了牛顿的信仰。牛顿身为一个杰出的科学家，喜欢公开表达自己的信仰，又具有不擅与人交际、喜爱独自安静工作的个性，现实社会对他这样的人有时是非常残酷的。
当时宗教分子攻击他有一流的科学，却有三流的神学;科学分子攻击他有一流的神学，却有三流的科学;政治分子攻击他的科学、神学、人际关系都属三流;有人看他孝顺母亲又终身未婚，就中伤他心理不健康，现今还有人说牛顿有恋母情结;有人看他对学生好，就说他有同性恋倾向……这种种无情的攻击搞得牛顿几乎发疯。
1692年，日内瓦来的拜特教授大力抨击牛顿，称他是“伦敦先知”，说：“牛顿的万有引力定律来自对宗教的默想，而非科学的发现……他必须撇清——如果这是科学，就不要说上帝如何如何;如果是与上帝有关的，就不要放入科学范畴。”
拜特一开炮，许多人就群起围攻牛顿。丝毫没有防备的牛顿几乎赤裸裸地站在科学的刑场上，接受无情的攻击。
1693年9月30日，牛顿写下：“我陷入极端的难过中。过去的12个月，我无心进食，也无法安稳地入睡，我心动摇，无法思考。”无情的攻击持续下去，1694年，有人中伤牛顿与女人搞不正当关系。1695年，牛顿几乎精神失常，各地都传言牛顿死了。牛顿百口莫辩，只有退出人群，他写道：“斯宾塞的《希伯来律法》一书成为我困难中的安慰。”
在英国国王出面，任命他为“英国皇家学会会长”后，这些攻击突然就消失了。
牛顿在此后数十年，根据过去两年半受中伤的经验，坚持给科学界建立“诚实的体系”，而他本身就是最好的模范。
四牛顿晚年名满欧洲，步入老年后，他最大的乐趣就是跟小孩一起玩。一天，他对他的小侄儿讲：“我不知这个世界将来怎么看我，对我而言，我就像一个在海滩玩耍的男孩，偶然间发现了一块比较圆的石头和一枚比较漂亮的贝壳，觉得很愉快，但是在我面前，尚未被发现的石头、贝壳仍然不计其数。”
牛顿逝于1727年，晚年他写下：“在任何环境下，都要守住耶稣基督救赎的真理与最大的诫命——爱人如己。”
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>StackOverflow程序员推荐：每个程序员都应读的30本书</title>
    <url>/hobby-stackoverflow-recommend-30-books/</url>
    <content><![CDATA[前言“如果能时光倒流，回到过去，作为一个开发人员，你可以告诉自己在职业生涯初期应该读一本，你会选择哪本书呢？我希望这个书单列表内容丰富，可以涵盖很多东西。”
很多程序员响应，他们在推荐时也写下自己的评语。以前就有国内网友介绍这个程序员书单，不过都是推荐数 Top 10的书。其实除了前10本之外，推荐数前30左右的书籍都算经典，伯乐在线整理编译这个问答贴，同时摘译部分推荐人的评语。下面就按照各本书的推荐数排列。


###《代码大全》史蒂夫·迈克康奈尔
推荐数：1684
“优秀的编程实践的百科全书，《代码大全》注重个人技术，其中所有东西加起来，就是我们本能所说的“编写整洁的代码”。这本书有50页在谈论代码布局。” —— Joel Spolsky
对于新手来说，这本书中的观念有点高阶了。到你准备阅读此书时，你应该已经知道并实践过书中99%的观念。– esac
###《程序员修炼之道》
推荐数：1504
对于那些已经学习过编程机制的程序员来说，这是一本卓越的书。或许他们还是在校生，但对要自己做什么，还感觉不是很安全。就像草图和架构之间的差别。虽然你在学校课堂上学到的是画图，你也可以画的很漂亮，但如果你觉得你不太知道从哪儿下手，如果某人要你独自画一个P2P的音乐交换网络图，那这本书就适合你了。—— Joel
###《计算机程序的构造和解释》推荐数：916
就个人而言，这本书目前为止对我影响最大的一本编程书。
《代码大全》、《重构》和《设计模式》这些经典书会教给你高效的工作习惯和交易细节。其他像《人件集》、《计算机编程心理学》和《人月神话》这些书会深入软件开发的心理层面。其他书籍则处理算法。这些书都有自己所属的位置。
然而《计算机程序的构造和解释》与这些不同。这是一本会启发你的书，它会燃起你编写出色程序的热情；它还将教会你认识并欣赏美；它会让你有种敬畏，让你难以抑制地渴望学习更多的东西。其他书或许会让你成为一位更出色的程序员，但此书将一定会让你成为一名程序员。
同时，你将会学到其他东西，函数式编程（第三章）、惰性计算、元编程、虚拟机、解释器和编译器。
一些人认为此书不适合新手。个人认为，虽然我并不完全认同要有一些编程经验才能读此书，但我还是一定推荐给初学者。毕竟这本书是写给著名的6.001，是麻省理工学院的入门编程课程。此书或许需要多做努力（尤其你在做练习的时候，你也应当如此），但这个价是对得起这本书的。
你还不确信么？那就读读第一版的前言或序言。网上有免费的电子版。-Antti Sykäri

###《C程序设计语言》推荐数：774
这本书简洁易读，会教给你三件事：C编程语言；如何像程序员一样思考；底层计算模型。（这对理解“底层”非常重要）—— Nathan
《算法导论》推荐数：671
《代码大全》教你如何正确编程；《人月神话》教你如何正确管理；《设计模式》教你如何正确设计……
在我看来，代码只是一个工具，并非精髓。开发软件的主要部分是创建新算法或重新实现现有算法。其他部分则像重新组装乐高砖块或创建“管理”层。我依然梦想这样的工作，我的大部分时间（&gt;50%）是在写算法，其他“管理”细节则留给其他人…… —— Ran Biron
《重构：改善既有代码的设计》推荐数：617
我想我不得不推荐《重构》：改进现有代码的设计。—— Martin
我必须承认，我最喜欢的编程语录是出自这本书：任何一个傻瓜都能写出计算机能理解的程序，而优秀的程序员却能写出别人能读得懂的程序。—— Martin Fowler
###《设计模式》推荐数：617
就我而言，我认为四人帮编著的《设计模式》是一本极为有用的书。虽然此书并不像其他建议一样有关“元”编程，但它强调封装诸如模式一类的优秀编程技术，因而鼓励其他人提出新模式和反模式（antipatterns），并运用于编程对话中。—— Chris Jester-Young
###《人月神话》推荐数：588
###《计算机程序设计艺术》推荐数：542
这是高德纳倾注心血写的一本书。—— Peter Coulton
《编译原理》（龙书）推荐数：462
我很奇怪，居然没人提到龙书。（或许已有推荐，我没有看到）。我从没忘过此书的第一版封面。此书让我知道了编译器是多么地神奇绝妙。- DB
《深入浅出设计模式》推荐数：445
我知道四人帮的《设计模式》是一本标准书，但倒不如先看看这部大部头，此书更为简易。一旦你了解了解了基本原则，可以去看四人帮的那本圣经了。- Calanus
《哥德尔、艾舍尔、巴赫书：集异璧之大成》推荐数：437
如果下昂真正深入阅读，我推荐道格拉斯·侯世达（Douglas Hofstadter）的《哥德尔、艾舍尔、巴赫书》。他极为深入研究了程序员每日都要面对的问题：递归、验证、证明和布尔代数。这是一本很出色的读物，难度不大，偶尔有挑战，一旦你要鏖战到底，将是非常值得的。 – Jonik
《代码整洁之道》推荐数：329
虽然《代码整洁之道》和《代码大全》有很多共同之处，但它有更为简洁更为实际的清晰例子。 – Craig P. Motlin
《Effective C++》和《More Effective C++》推荐数：297
在我职业生涯早期，Scott Meyer的《Effective C++》和后续的《More Effective C++》都对我的编程能力有着直接影响。正如当时的一位朋友所说，这些书缩短你培养编程技能的过程，而其他人可能要花费数年。
去年对我影响最大的一本书是《大教堂与市集》，该书教会我很有关开源开发过程如何运作，和如何处理我代码中的Bug。 – John Channing
《编程珠玑》推荐数：282
尽管我不得不羞愧地承认，书中一半的东西我都没有理解，但我真的推荐《编程珠玑》，书中有些令人惊奇的东西。 – Matt Warren
《修改代码的艺术》by Michael Feathers我认为没有任何一本书能向这本书一样影响了我的编程观点。它明确地告诉你如何处理其他人的代码，含蓄地教会你避免哪些（以及为什么要避免）。- Wolfbyte
同意。很多开发人员讨论用干净的石板来编写软件。但我想几乎所有开发人员的某些时候是在吃其他开发人员的狗食。– Bernard Dy
《编码：隐匿在计算机软硬件背后的语言》我推荐Charles Petzold的《编码》。在这个充满工具和IDE的年代，很多复杂度已经从程序员那“抽取”走了，这本书一本开眼之作。 – hemil
《禅与摩托车维修艺术 / Zen and the Art of Motorcycle Maintenance》对我影响最大的那本书是 Robert Pirsig 的《禅与摩托车维修艺术》。不管你做什么事，总是要力求完美，彻底了解你手中的工具和任务，更为重要的是，要有乐趣（因为如果你做事有乐趣，一切将自发引向更好的结果）。 – akr
（编注：关于这本书，也可以看看阮一峰的读后感。）
《Peopleware / 人件集:人性化的软件开发》Demarco 和 Lister 表明，软件开发中的首要问题是人，并非技术。他们的答案并不简单，只是令人难以置信的成功。第二版新增加了八章内容。 – Eduardo Molteni
《Coders at Work / 编程人生》一本非常有影响力的书，可以从中学到一些业界顶级人士的经验，了解他们如何思考并工作。 – Jahanzeb Farooq
《Surely You’re Joking, Mr. Feynman! / 别闹了，费曼先生！》虽然这本书可能有点偏题，但不管你信不信，这本书曾在计算机科学专业课程的阅读列表之上。一个优秀的角色模型，一本有关好奇心的优秀书籍。 – mike511
《Effective Java 中文版》此书第二版教你如何编写漂亮并高效的代码，虽然这是一本Java书，但其中有很多跨语言的理念。 – Marcio Aguiar
《Patterns of Enterprise Application Architecture / 企业应用架构模式》很奇怪，还没人推荐 Martin Fowler 的《企业应用架构模式》- levi rosol
###《The Little Schemer》和《The Seasoned Schemer》 nmiranda
这两本是LISP的英文书，尚无中文版。美国东北大学网站上也有电子版。
《交互设计之路》英文名：《The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity》该书作者：Alan Cooper，人称Visual Basic之父，交互设计之父。
本书是基于众多商务案例，讲述如何创建更好的、高客户忠诚度的软件产品和基于软件的高科技产品的书。本书列举了很多真实可信的实际例子，说明目前在软件产品和基于软件的高科技产品中，普遍存在着“难用”的问题。作者认为，“难用”问题是由这些产品中存在着的高度“认知摩擦”引起的，而产生这个问题的根源在于现今软件开发过程中欠缺了一个为用户利益着想的前期“交互设计”阶段。“难用”的产品不仅损害了用户的利益，最终也将导致企业的失败。本书通过一些生动的实例，让人信服地讲述了由作者倡导的“目标导向”交互设计方法在解决“难用”问题方面的有效性，证实了只有改变现有观念，才能有效地在开发过程中引入交互设计，将产品的设计引向成功。
本书虽然是一本面向商务人员而编写的书，但也适合于所有参与软件产品和基于软件的高科技产品开发的专业人士，以及关心软件行业和高科技行业现状与发展的人士阅读。
他还有另一本中文版著作：《About Face 3 交互设计精髓》
《Why’s (Poignant) Guide to Ruby 》如果你不是程序员，阅读此书可能会很有趣，但如果你已经是个程序员，可能会有点乏味。
###《Unix编程艺术》
It is useful regardless operating system you use. – J.F. Sebastian 不管你使用什么操作系统，这本书都很有用。 – J.F. Sebastian
《Practices of an Agile Developer / 高效程序员的45个习惯：敏捷开发修炼之道》45个习惯，分为7个方面：工作态度、学习、软件交付、反馈、编码、调试和协作。
每一个具体的习惯里，一开始提出一个谬论，然后展开分析，之后有正队性地提出正确的做法，并设身处地地讲出了正确做法给你个人的“切身感受”，最后列出几条注意事项，帮助你修正自己的做法（“平衡的艺术”）。
《Test-Driven Development by Example. / 测试驱动开发》前面已经提到的很多书都启发了我，并影响了我，但这本书每位程序员都应该读。它向我展示了单元测试和TDD的重要性，并让我很快上手。 – Curro
我不关心你的代码有多好或优雅。如果你没有测试，你或许就如同没有编写代码。这本书得到的推荐数应该更高些。人们讨论编写用户喜欢的软件，或既设计出色并健壮的高效代码，但如果你的软件有一堆bug，谈论那些东西毫无意义。– Adam Gent
《Don’t Make Me Think / 点石成金:访客至上的网页设计秘笈》取决于你所追求的目标。我喜欢《代码大全》是因纯编程，《点石成金》是一本有关UI设计的卓越书籍。 – Justin Standard
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>思考</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>孙正义鲜为人知的早期创业史</title>
    <url>/hobby-sunzhengyi-entrepreneurial/</url>
    <content><![CDATA[作者:陈伟 来源:读者
　　引导语：这是一个被反复提及，几乎让人不耐烦的故事。1999年，马云在四处寻找投资人，他找到了日本软银集团的创始人孙正义。这个身材矮小、语速很快、充满激情的中年人，只花费了几分钟听马云讲他的构想，就答应为这家刚刚创立的公司投资2000万美元。十多年后，这笔在当时不算大的投资让孙正义获得了几千倍的回报。
　　新浪、阿里巴巴背后的巨人
　　孙正义的软银集团每年会收到700多个融资请求，公司会耐心地挑选出70个进行投资，为了获得巨大的回报，孙正义长期为阿里巴巴融资，并且等待了15年之久。
　　20世纪末，孙正义已经发现互联网是商业世界的下一个引爆点，他以此为出发点，积极寻找自己梦想的新载体。孙正义坚持认为，日本要想摆脱“失去的十年”的困扰，互联网、新经济是功效最强大的引擎。事实上也的确如此，技术的变革推动日本走向了有自己特色的新经济时代。很多人以为，日本没有出现苹果、Facebook那样的伟大的科技公司和互联网公司，其实不然，至少，软银就搭上了新经济的高速列车，在之后的几年里，中国人耳熟能详的互联网公司都跟软银有着千丝万缕的联系，比如阿里巴巴，比如新浪。

　　表面上看，孙正义不像一个传统的日本商人，他热衷冒险，他最常说的话是：“对于一个项目，只要有70%的成功概率，我就会出手，如果等到成功概率达到90%时，那可能就来不及了。”
　　但在骨子里，他还是一个传统的日本商人，血液里有武士道那种进取、敢于冒险、重信守义的基因。同时，他也敬畏禅意，热衷于茶道，试图在茶道中寻找平和与安静，他希望自己的事业不要像疾风骤雨一样倾泻奔流，而是要在快速发展和不断反省之间找到合理的边界。
　　武士与儒商，刀剑与茶道，《论语》和算盘兼备，这是日本商人延续千年不变的特质。
　　贫穷的意义
　　1957年8月11日，孙正义出生于日本佐贺县鸟栖市，在家中四兄弟中排行老二。在他的出生地，有很多韩国人、朝鲜人临时搭建的木板房，这些简易房甚至没有门牌号。鸟栖市没有知名的产业，是一个以农业为主的安静小镇。孙正义是第三代韩裔日本人。孙家祖先原来从中国迁移到韩国，到孙正义祖父一代，又从韩国的大邱迁徙至日本九州。
　　孙正义年少早慧，很早的时候就知道贫穷的意义。少年时代，孙正义的奶奶这样向他描述贫穷：“真正的贫穷不是生活不舒适，而是从来没有想过贫穷这件事。”
　　孙正义自此开始思考如何摆脱贫穷，在那个并不富裕的家庭里，改变命运的唯一方式，就是好好学习。孙正义认为自己并不聪慧，但足够努力，甚至全家人都出去旅行的时候，孙正义仍坚持留下来看书学习。
　　他最初对艺术感兴趣，希望成为一个画家。他像达·芬奇似的，画了上千朵樱花，然后发现自己不适合当画家。他于是决定认真读书，充实内心。
　　1974年，孙正义在美国游学。从他后来的情况来看，英语始终不是他的长项，谁让日语本身就和英语“相克”呢？马云曾回忆说：第一次见孙正义就被他蹩脚的英语击败了。
　　实际上，孙正义当时在美国只学习了一个月就返回日本了。但这一个月对他来说意义重大：那里不像日本，没有那么多礼节、秩序和规则。校园里汇集了世界各地的精英，他们见面都大声问好，热情拥抱，有的还亲你两口。这是一个所有人的个性都能得到释放，所有人的梦想都有机会实现的地方。
　　回国后，孙正义在家中对父母说：“我决定退学了。”这个情节也常常被媒体、传记作家反复提及，人们还热衷于拿孙正义的退学和比尔·盖茨的类比。事实上，孙正义跟比尔·盖茨退学的时间几乎重合，盖茨于1975年从哈佛退学，孙正义则在1974年放弃了日本的高中学业。
　　当时，孙正义面对着难以想象的巨大阻力。母亲坚持认为他应该在日本读完高中;父亲身患重病，吐血不止;老师也为他放弃学业而惋惜。
　　那一次，父亲把孙正义叫到床前问他：“放弃学业，你打算去做什么？”“去美国，读书，开眼看世界。”父亲沉默良久，给孙正义开出了两个条件：第一，必须每年回家一次，看望家人;第二，无论你在美国混得怎样，也得娶一个亚洲媳妇。(伤感日志文章 www.wenzhangba.com)
　　成交！
　　50岁时，要惊天动地
　　孙正义终于再次踏上了美国国土，他很快考入了塞拉蒙提高中。
　　在美国的高中，孙正义潜心读书，他很快就跳级，直接读三年级。更传奇的是，三天后他又跳级去读四年级（塞拉蒙提高中为四年制）。他用三个星期的时间修完全部的高中课程，然后顺利通过了美国“高考”，开始了大学生活。
　　几乎就在孙正义读大学的同时，比尔·盖茨说服了同是电脑天才的保罗·艾伦将Basic语言应用到微型计算机中。盖茨对艾伦说：“现在正是决定时代发展的关键时刻，分秒都不能疏忽。”
　　1975年，艾伦辞职，盖茨中途退学，两人一起创办了微软公司。同时代的史蒂夫·乔布斯和朋友们也开始在车库中创业，他们于1976年创立苹果电脑公司。毫无疑问，孙正义和盖茨、乔布斯是同时代的IT人物。他们是一群计算机与互联网时代的先驱者。
　　通过美国“高考”进入霍利大学之后，孙正义还是一如既往地认真读书，很快他又通过了伯克利大学的考试，转入这所世界着名的大学。这时候，他19岁，开始规划自己的一生：“30岁时，要成就自己的事业，光宗耀祖;40岁时，要拥有至少1000亿日元的资产;50岁时，要做出一番惊天动地的伟业;60岁时，功成名就;70岁时，把事业交给下一任接班人！”
　　伟大的友谊
　　除了学习，在伯克利求学的孙正义开始热衷于各种奇怪的发明。
　　孙正义的方法非常简单，他做了好多卡片，每一张卡片上写下一个事物，然后排列组合，由此发明出新玩意儿。比如，他在卡片上书写钉子、橘子、板凳等等，然后把它们组合起来，就有可能产生新的想法。例如，把钉子和避孕套结合起来，就是带凸点的避孕套……诸如此类。
　　很多人可能不知道，严格意义上来讲，人们使用的电子词典就是孙正义发明的。他把发音设备、辞典和液晶显示屏巧妙地结合起来，做成了那种能帮你纠正发音的电子词典，这项专利后来被夏普购买，并且完成了商品化。
　　这个过程给了孙正义很大的启发：他准备用发明专利费进行创业，寻找到第一桶金之后，再进行更伟大的财富创造计划。
　　为了完成目标，孙正义开始寻找合作伙伴，并且创办了自己的第一家公司。这家公司的名称是M Speech System Inc。参与公司创建的有宇宙物理学家、发音电子合成器领域的世界权威佛莱斯特博士和陆弘亮，公司成员的年龄都比孙正义大。
　　陆弘亮原本在大学附近开冰激凌店，一个偶然的机会认识了孙正义，俩人相谈甚欢，自此建立了一生的友谊。而他们之间的故事，比孙正义和马云之间的传闻更加让人动容。20世纪80年代初，孙正义被诊断患上了绝症，医生认为他命不久矣，于是，孙正义把他在美国的公司卖给了陆弘亮。没想到，孙正义福大命大，安然度过了此次危机。之后，他决定创办软银公司，是陆弘亮为他提供了资金支持。
　　陆弘亮自己的人生也光彩万千。他早年发明的卡片设计和打印软件Print Shop对DOS时代影响深远。那家享誉世界的UT斯达康也是他一手创办的。当然，孙正义也是他的投资人。
　　两个对技术无比迷恋的人创造了一个亚洲商业的传奇，累积了财富、改变了人们的生活。虽然他们生命的轨迹有时候交融在一起，有时候又分开，但两人之间的友谊始终不曾褪色。
　　当时，孙正义与人合作，研究出了语音合成设备，该设备会根据客人的进出情况，自动说出“欢迎光临”“多谢光临”等问候语，我们现在去便利店听到的那种自动问候装置基本上就是孙正义发明的。
　　接下来，陆弘亮开始四处兜售这一款产品。旧金山有一条日本人街，主要居住着日本移民。陆弘亮跑到日本人街上将这一款产品派发给一些日本企业。很快，孙正义便收到了无数日本公司的订单。他向学校请假，飞回日本签订合同，同时进一步开辟市场。
　　再次回到美国之后，孙正义和他的团队开始研发有声翻译器。
　　1978年9月23日中午，孙正义驾驶着爱车保时捷914向宇宙科学研究所飞驰而去。他此行是去拜访佛莱斯特博士。
　　那天是完成有声翻译器试用机制作的日子。
　　工作人员用手敲了敲贴在试用机黑色机箱上的字母键。
　　液晶画面上先出现了英语“Good Morning”。
　　工作人员接着敲击“翻译”键，画面马上从英语转换成了德语“Guten Morgen”。
　　成功了。
　　后来，孙正义开始把语音翻译技术专利向日本公司兜售。他和陆弘亮吃了好多次闭门羹，佳能、卡西欧、松下等等公司对这项技术先是评头论足，然后断然拒绝。最后，夏普公司的董事发现了这个技术的良好发展前景，并且购买了他们的专利。4000万日元的专利转让金成为孙正义继续扩大生意的资本。之后很多语种的翻译软件都被接连开发出来了。
　　除了技术发明，孙正义还把在日本流行，但美国人还没有使用的新奇物品引入美国，比如游戏机、超级玛丽游戏等等，这些敏感的商业嗅觉让他的财富与日俱增。
　　1980年，孙正义大学毕业，他选择回日本继续创业。当时，孙正义还没拿到毕业证，但创业的激情督促着他回国。孙正义下定决心即刻启程，陆弘亮劝他：“你要回去我理解，但多等几天拿到毕业证也好啊。”孙正义的回答是：“读大学不是为了拿毕业证，而是为了学习知识。”
　　八年以后，孙正义的女儿一次次问他：“爸爸，你真的读过大学吗？”这时候，他才回到伯克利大学，在一堆布满灰尘的文件中寻找自己的毕业证。
　　八年后重回伯克利大学的时候，孙正义已经名满天下，他创办的软银公司为他带来了财富和名声，也牵引着日本拥抱互联网时代。这就是孙正义早期创业的故事，很多人已经淡忘了，但依然值得我们回忆。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读者</tag>
      </tags>
  </entry>
  <entry>
    <title>《剑指Offer》摘录</title>
    <url>/hobby-target-offer/</url>
    <content><![CDATA[前言《剑指Offer》一书从面试官的角度，阐述了面试的流程、面试中的注意事项、简历的准备、常考的数据结构和算法等等面试相关内容。本文从一个应聘者的角度，摘录整理面试中需要准备的内容。
程序员面试，面试的形式有电话面试、共享桌面远程面试和现场面试。无论是哪一种形式，一般的面试流程都包括三个环节：行为面试、技术面试和应聘者提问。


行为面试行为面试，面试官参照简历了解应聘者的过往经验。面试官会注意应聘者的性格特点，深入地了解简历中列举的项目经历。不少面试官会让应聘者做一个简短的自我介绍，由于面试官拿着应聘者的简历，因此自我介绍不用花很多时间，用30秒到1分钟介绍自己的主要学习、工作经历即可。这一环节中，作为一个应聘者，最重要的是准备一份简历，一份经得起推敲的简历。其次就是准备一下自我介绍，突出重点和优势。还要想好一些常见问题的答复，增强信心，免得现场磕巴。
简历1、项目经验项目经验的描述建议使用STAR模型：Situation（简短的项目背景）–&gt;Task（自己完成的任务）–&gt;Action（为完成任务自己做了哪些工作，是怎么做的）–&gt;Result（自己的贡献）。
Situation：简短的项目背景。比如项日的规模，开发的软件的功能、日标用户等。
Task：自己完成的任务。这个要写详细，要让面试官对自己的工作一目了然。在用词上要注意区分“参与”和“负责”：如果只是加入某一个开发团队写了几行代码就用“负责”，那就很危险。面试官看到简历上应聘者“负责”了某个项日，他可能就会问项目的总体框架设计、核心算法、团队合作等问题。这些问题对于只是简单“参与”的人来说，是很难回答的，会让面试官认为你不诚实，印象分会减去很多。
Action：为了完成任务自己做了哪些工作，是怎么做的。这里可以详细介绍。做系统设计的，可以介绍系统架构的特点；做软件开发的，可以写基于什么工具在哪个平台卜应用了哪些技术；做软件测试的，可以写是手上测试还是自动化测试，是白盒测试还是黑盒侧试等。
Result：自己的贡献。这方面的信息可以写得具体些，最好能用数字加以说明。如果是参与功能开发，可以说按时完成了多少功能；如果做优化，可以说性能提高的百分比是多少；如果是维护，可以说修改了多少个Bug。
举个例子，笔者用下面一段话介绍白己在微软Winforms项目组的经历:Winforms是微软.NET中的一个成熟的Ul平台（Situation）。本人的工作是在添加少量新功能之外主要负责维护已有的功能（Task）。新的功能主要是让Winforms的控件的风格和Vista、Windows7的风格保持一致。在维护方面，对于较难的问题我用WinDbug等工具进行调试（Action）在过去两年中我总共修改了超过200个Bug（Result）。
对于每个项目经验，都应该考虑清楚下面的问题：

你在该项目中碰到的最大问题是什么，你是怎么解决的？
从这个项目中你学到了什么？
什么时候会和其他团队成员（包括开发人员、测试人员、设计人员、项目经理等）有什么样的冲突，你们是怎么解决冲突的？


在介绍项目经验时（包括简历上介绍和口头介绍），应聘者不必详述项目的背景，而要突出介绍自己完成的工作及取得的成绩。

2、掌握的技能除应聘者参与过的项目之外，面试官对应聘者掌握的技能也很感兴趣，他有可能针对简历上提到的技能提出问题。描述技能掌握程度时要注意“了解”、“熟悉”和“精通”的区别。
“了解”指对某项技术只是上过课或者看过书，但没有做过实际的项目。通常不建议在简历中列出只是肤浅了解一点的技能，除非这项技术应聘的职位的确需要。
简历中我们描述技能的掌握程度大部分应该是“熟悉”。如果我们在实际项目中使用某项技术已经有较长时间，通过查阅相关文档可以独立解决大部分问题，那么我们就熟悉它了。对应届毕业生而言，毕业设计所用到的技能可以用“熟悉”；对已经工作过的，在项目开发中用到的技能，也可以用“熟悉”。
如果我们对一项技术使用得得心应手，在项目开发过程中，当同学或同事向我们请教这个领域的问题时，我们都有信心也有能力解决，这个时候我们就可以说自己精通了这项技术。应聘者不要试图在简历中把自己修饰成“高人”而轻易使用“精通”，除非自己能够轻松地回答这个领域里的绝大多数问题，否则就会适得其反。通常如果应聘者在简历中说自己精通某项技术，面试官就会对他有很高的期望值，因此会挑一些比较难的问题来问。
3、修改对简历提问，一个问题扣一个问题，不断对简历进行修改和完善。
自我介绍未完待续。。。
常见问题为什么跳槽？P9避免以下四个原因：老板太苛刻，同时太难相处，加班太频繁，工资太低。理想答案：现在的工作已经做了一段时间，已经没有太多的激情了，因此希望寻找一份更有挑战的工作。然后具体论述为什么有些厌倦现在的职位，以及面试的职位我为什么会有兴趣。
最近在看什么专业书？从中学到了哪些新技术？P16
技术面试面试官在通过简历及行为面试大致了解应聘者的背景之后，接下来就要开始技术面试了。一轮一小时的面试，通常技术面试会占据40-50分钟时间，这是面试的重头戏，对面试的结果起决定性作用。虽然不同公司的不同面试官的背景、性格各不相同，但总体来说他们都会关注应聘者的5中素质：扎实的基础知识、能写高质量的代码、分析问题时思路清晰、能优化时间效率和空间效率、学习沟通和知识迁移等能力。
在这一环节中，作为一个应聘者，最重要的是学好数据结构和算法。为了做好这一点，建议先做完《剑指Offer》上的题目，因为上面的题目都是最具代表性的。然后刷leetcode，刷的越多越好。
数据结构和算法数据结构和算法，需要掌握：数组、字符串、链表、树（链表和树最常考）、栈、队列、哈希表、查找（尤其是二分查找）、排序（尤其是归并排序和快速排序）、分治法、动态规划、贪婪算法。
这些知识点，在大学时期已经学习过，考研也复习过，就不再研读大部头著作。在刷题的时候，顺便复习吧。
剑指Offer《剑指Offer》中的面试题都是用C++实现的，C++确实是准备面试的首选语言，但是，根据职位的不同应该有所侧重。比如，前端肯定js，安卓肯定java。而机器学习岗，肯定是python了。所以，《剑指Offer》中的题目，针对C++的，郝同学会直接略过，其他大部分题目，会用python实现。
刷题地址：https://www.nowcoder.com/ta/coding-interviews备注：这个刷题地址的题目比原书少了一些，但是刷着方便，支持各种编程语言。而且不差那几题，实在想刷全，之后补上就是了。
leetcodeleetcode，之前用java完成了几题，在此清零。在刷完《剑指Offer》后，使用python重新开刷。
刷题地址1：https://leetcode.com/problemset/algorithms/刷题地址2：https://www.nowcoder.com/ta/leetcode
白板1、理清思路：画图、举例、分解2、写出步骤3、考虑时间空间复杂度4、特殊情况：边界条件、特殊输入、错误处理5、优化

思考清楚再开始编码
良好的代码命名和缩进对齐习惯
单元测试（建议先写）
调试

应聘者提问
您觉得我还有哪些专业知识需要学习补充？
您所在的部门从事哪些研究？使用哪些技术？如果能进入贵公司，会不会提供培训？

模拟未完待续。。。
后记《剑指Offer》的主体内容，其实就是讲算法。我们听说过技术过时，却从来没有听说过算法过时。不仅没有过时，而且因为机器学习、大数据的要求，算法变得越来越重要了。任何时候学习算法都不晚，当你觉得为时已晚的时候，恰恰是最早的时候。接下来，参加kaggle、天池的同时，开启刷题模式。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>讲故事写小说</title>
    <url>/hobby-tell-stories-and-write-fiction/</url>
    <content><![CDATA[小说其实就是给读者讲故事，讲好一个故事，也就写好了一部小说。
　　对于新人来说，在讲故事以及编故事方面，都有一些生涩之处，今天这个帖子里，会单就编故事方面，写一些我总结出来的经验。一家之言，多有偏颇，抛砖引玉，欢迎讨论。
　　故事的概念，没必要用一些很虚无缥缈的解释来进行曲解，故事就是故事，只是多个人物共同演绎出来的一段有趣的事件而已。故事本身的定义是简单的，真正的难的是如何编好编故事。

　　在编故事写提纲方面，网文同道已经有许多人总结过一些经验，其中有两个方法最为简单实用，第一个方法是七要素，在设计故事的时候，全都围绕“奇遇、升级、寻宝、泡妞、发财、欺人、助人”这七个要素来展开设计；第二个方法是九线，这种方案是围绕“1、主角智慧性格2、配角炮灰3、技能4、伙伴5、装备6、冒险7、身世8、势力9、后宫”这九种要素来展开设计。
　　七要素跟九线的设计思路是一致的，只不过是考虑的要素不同而已，这两种技巧以前已经有人写过了，好奇的可以去百度，我就不赘述了。
　　除了网络写手总结的这两套经验之外，传统小说的一些编故事的技巧，实际上也是非常好用的，比如说语文课本上关于“起点，经过，结果”的记述。这正是一个故事完整的结构，由此为出发点，同样能编出有意思的故事。
　　在编故事方面，编剧也是此中的行家里手，也有许多关于编故事的技巧跟方法，我研究了一些编剧的指南，其中有位资深老编剧提供的一种方法也非常不错，这里也重点提一下。这位老编剧所推崇的方法是“人物构建法”，这种方法是先确立一整套人物关系，将每个人物之间的矛盾想好，然后让这些人物动起来，思考这些人物在面临各种情况下会如何处理，让这些人物进行碰撞，不断碰撞的过程中，故事自然也就出来了，当碰撞到极限，有了结果时，故事也就随之结束。
　　人物构建法在网文中是很少有人应用的，但是影视剧中很多人在用。在网络小说中，有许多路人甲角色，往往存在的意义就是领便当，出场极短。在影视剧当中，虽然也有路人甲，但数量要远远低于网络小说，每个人物都很重要。所以影视剧很重视人物关系以及人物的作用，会下大力气进行设计。
　　人物构建法是个颇为精深的技巧，没个几千字是交代不清楚的，我这里只详述其中一个关键性技巧，用好这一个技巧，就很厉害了。
　　在小说的人物关系之中，为了凸出矛盾，人物之间不是敌方就是我方，十分明显，但这种设定太过简单了，而且也无法摩擦出巧妙的故事，所以在设计的时候，可以多多考虑双重关系，让人物之间的关系变得复杂起来。
　　举例来讲，主角有个杀父仇人，但不知道这个仇人到底是谁，后来主角爱上了一个女人，结果这个女人正是主角的杀父仇人。这样的复杂关系，会让主角对女主角又爱又恨，进而演绎出一段相爱相杀的虐恋。
　　这个例子是比较虐的，但只要技巧在手，无论怎么运用都可以，将这个技巧用在爽上面是一样的。
　　举例二，主角有个敌人，实力不如对方，一直处于下风，直到某天主角学了一门医术，而这么医术正好能治这位敌人父亲的病，敌人为了求主角给父亲治病，只能各种讨好，以及甘愿当牛当马，受人驱使，甚至还得把宝宝妹妹介绍给主角……这个就是以爽快为出发点的例子了。
　　关系一旦对调并复杂化，马上就会产生许多乐趣，这便是设计人物关系的精髓所在。
　　以上，都是别人总结的技巧，接下来，才是我总结的一种技巧，这才是这个帖子的重点讲解对象。
　　七要素跟九线，固然是很实用的编故事技巧，不过局限性很大，全都围绕着一些固定的要素来写，就会产生固定思路，很难跳脱出去。
　　起点、经过、结果，固然是故事的正确结构，可是光知道结构，对于编故事方面的帮助却收效甚微。
　　人物构建法能创造出很棒的人物关系，但运用起来的难度较大，一来容易因为戏份分摊导致主角形象降低，二来会导致反派人物太深入人心不方便干掉，三来容易导致人物关系过于复杂，无法处理清楚，四来容易造成人物关系纠结成网，无法跳转新副本，导致滞留在一处，五来如果女人太聪明，就无法开后宫了……总而言之，我在运用以上几种技巧编故事的时候，全都遇到了各种难处，觉得不甚好用，所以自己苦思了一段时间，还真想出了一个新办法出来。
　　我给这个这个新办法取名为“事件组合法”。
　　顾名思义，这个办法就是利用大大小小的事件组成一个完整的提纲出来，大事件套着小事件，小事件连着小事件，众多小事件组成大事件。
　　事件的概念是什么？
　　事件……就是事件，并非什么深奥的东西。
　　在这点上还是举例来讲，一举例大家就全明白了。
　　逃课的男主角在街上闲逛时，遇到了请病假的女主角，两人恰好今天都没有去上课，感觉很有意思，在街上聊了几句，然后去看了场电影，吃了顿饭——这就是一个小事件。
　　男主角遭遇退婚，受到羞辱，经过一番修炼之后，杀上女方的家里找场子——这就是一个大事件，很长线的大事件。
　　大事件全都是由小事件组成的，一步步推演发展，铺垫渲染，最终达到整个事件的最高潮。
　　用这种方法来编写提纲的时候，就是思考许多个事件，然后将事件组合起来。在此过程中，还得结合人物关系，小说风格，题材分类，主角外挂，力量体系等元素进行思考，光拿事件进行拼凑是不行的。
　　比如要编写一个以重生为外挂的玄幻小说，风格定位为传统爽文，力量体系为斗气，在确立了这些东西之后，就可以展开思考了。
　　前期第一个大事件是门派被灭，主角重生后的目的是阻止这件事情的发生，以这个大事件为前期主线，开始对小事件进行设计。
　　第一个小事件是主角被同门欺负，导致昏迷，醒来后已经是重生者了，将此来做为开头，稳扎稳打。第二个事件是同门小师妹来问长问短，给主角送药。第三个事件是从门派隐秘处挖一根灵草，修复身体，提升功力……以此类推，逐步推进剧情。
　　之前提过了，用事件进行组合得结合多方面进行思考，不能生搬硬套，否则只会不伦不类。
　　在刚才那个例子当中，设定的是玄幻题材，玄幻题材经过这些年的发展，已经产生了许多常见的事件，用这些事件来编故事，才能编出带有玄幻风味的故事，如果采用跨题材事件来编故事，很容易导致故事走形。
　　玄幻的事件，修真的事件，都市的事件，历史的事件……全都各有其特色，彼此之间有一些可以通用，有一些不能通用，需要分清楚。
　　搞笑的事件，悲伤的事件，热血的事件，紧张的事件……在风格方面，事件也有其另一番面貌，也需要重点加以考虑，只有各方面完美结合，才能创造出一个合格的好故事。
　　编故事是一个浩大的工程，无论是再好的技巧，也无法让这变成一个轻松的活儿，我提供的这个事件组合法，也只是一个思考问题的出发点而已。
　　想要真正做到念头通达，挥洒自如，还是得多积累，多磨练。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么写博客？</title>
    <url>/hobby-why-write-blog/</url>
    <content><![CDATA[转载自 阮一峰：为什么写博客？。
2010年4月，我与百姓网CEO王建硕有过一次对话。我们谈到了为什么写博客。
阮：建硕，我知道你有两个博客，一个是英文的，另一个是中文的。但是，你更新英文博客的频率，远远高于中文博客，这是为什么？
王：这其实是一种机缘巧合。
2000 年，我在微软做工程师，习惯阅读一种叫做KB（知识库）的文章。我就模仿这样的格式和写法，写了一些关于浦东机场的英文介绍，结果排在Google搜索Pudong Airport的第一条结果，可见当时互联网上关于中国的英文内容非常少。
2002年，我开始用Movable Type架博客的时候，我觉得自己应该写一些能提供价值的东西。为来华的外国旅行者撰写英文介绍，就是一个很独特、而且我做得到的事情。
此后的8年，我在博客上记录的事情，不过只是一些日常生活。如果用中文写，本地的读者可能没兴趣，不觉得这样的文章有任何价值。比如，上海的公交车票2块钱一张，上海的火警电话是119、不是911等等，这种鸡毛蒜皮的话题，本地读者司空见惯，但对于英文读者，却是其他地方很难得到的信息。我的中文博客也在写，不过内容主要是IT评论，更新频率就慢一些。


阮：我觉得，你说出了写作博客的正确做法，那就是为读者创造价值。如果有人想要建立一个受欢迎的、有影响力的博客，那么这一点是他必须牢记的。只有你的文章对他人有价值，你才会有读者。我其实一直想建立一个英文博客，但就是因为找不到我能够写的、并且西方读者也会感兴趣的内容，所以迟迟没有动手。
当然，除了创造价值，博客还有另一个作用——沟通媒介。通过博客，别人能够知道我们在干什么，怎么想，每一篇博客都是一个与他人沟通的机会。所以，你较少写中文blog，我觉得挺遗憾的，因为这样一来，你与其他同业的沟通、你在国内业界的影响力就少了一个重要渠道，毕竟你的事业还是在国内。不过，我现在对这一点也不是很确定了，博客的沟通功能也许并不重要。上个月，Joel宣布不在网志上谈论软件了，因为他发现除了自己以外，没有人能够通过写博客获得成功。
所以，我就想问你第二个问题，写作Blog与个人职业之间，到底是一个怎样的关系？因为我发现，你很少在网志上谈到你的公司，尤其很少谈到公司的产品？
王：其实在微软的时候，我是有意避免谈论公司的。
两个原因。第一，我不太能区分哪些是公开信息，哪些不是，分起来很累。第二，也是更重要的原因，博客是我个人的表达，不是传播公司信息的渠道。微软是一家很了不起的公司，它的名声和光环是属于它自己的，不是属于我的，我只是一个微软的普通员工。
我觉得一定要分清楚，哪些是自己建立起来的，哪些是公司带给你的。你之所以拥有后者，很可能仅仅是因为运气好，是公司的成功，而不是你的成功。所以，我不太会写到公司。
后来在百姓网，我同样延续了这种方式，把公司和自己分开。自己就是有血有肉的一个人，在需要代表公司的时候，我会扮演那个角色，而在博客上，是自己。
阮：看来你把博客和公司分得很开。确实如你所说，个人博客不是宣传公司的窗口。事实上，很少人有动力，无偿为公司做宣传，这也是为什么商业公司的博客大多不成功的原因。但是，如果公司是你自己的，你会不会在博客上写自己的公司？我的问题其实是，创业者应不应该利用博客，作为宣传自己的工具？
王： 即使是自己的公司，我希望在博客上面分享的更多的是运行公司过程中的心得，尤其是失误和教训，来帮助其他的创业者。这部分是我作为一个活生生的人，与他人分享我的想法，不是在做宣传。
我更多地把读者当做自己的朋友，而不是我要发展的客户。我从来不想在家人和朋友面前炫耀公司，更多的是分享自己的心得。每个人写博客的原因千差万别，有人写博客是为了宣传自己的公司或者自己，这个动机无可厚非，只是这不是我写博客的目的。
阮：如果我创业的话，肯定会在博客上宣传，因为我需要更多的人帮我。所以，我还是挺看重网站流量的。你写作博客的立足点是分享心得，对流量大概就不是很重视了。你的博客流量目前是多少？
王：刚才看了下，远没有以前多，大概每个月25万（只是以前的1/4）。可见现在关于上海的英文信息越来越多，我的博客已经不是那么重要了，这是好事情。同时，越来越多的人订阅Feed来看博客，不再访问网站了。
阮：我的流量比你少，现在一个月的独立IP访问者，大概10多万。而且已经一年了，一直稳定在这个数量，没有明显增长。所以，我怀疑博客也不是一个很好的商业工具，到了一定程度，流量就上不去了。
当然，非商业性的个人博客，不用太在乎流量。但我也不觉得流量减少是好事情，因为读者反馈也会相应减少。如果长期没有足够的读者留言，对我写文章的积极性是有打击的。老实说，我确实希望每篇文章的读者留言能够多一点。
说到读者留言，那就引出了下面一个问题，写作博客的意义到底何在？有些人很不理解，认为写作博客无偿给他人阅读，是一种很傻的行为，既赚不到钱，又浪费时间。我当然不同意这种看法，但是我想先问问你，坚持不断写网志，你觉得最大的收获是什么？
王：促进思考。
每天写博客，帮助自己养成了更多观察、更多探究的习惯。看到地铁开通，或者其他有趣的事情，我总是习惯性地去关心，这就是多年博客写作让我养成的习惯。每天晚上，我都要问自己：今天有什么特别？我应该写点什么？……你知道一件事情，与你要表达一件事情，这是完全不同的。通过写作，你能帮助自己更清楚地理解问题。
另一方面，全世界读者的留言，是我从博客收获的最大财富。每天与不同的观点对话，会让自己更全面地看待这个世界。
阮：说得好！写作帮助我们整理自己的思想。博客其实是一种理性思维和表达能力的训练，很多时候我们写作博客，就是在做这种训练。我写作的时候，有时会尝试不同的表达方法，看看怎么写最容易看懂、最容易被他人接受。每当有读者留言批评我的观点，我就知道了我的思维和表达在什么地方还有欠缺。Joel说过，写作能力是区分领袖和普通程序员的标志。我们不一定要当领袖，但是能够说服他人认同你的观点，这绝对是不容忽视的能力，而博客就是获取这种能力的一种卓越训练方法。
此外，写作博客还有一个最大理由。我记得，你在网志中写过一件事，有人问：”你为什么写博客？”你反问道：”你为什么打电话？”我简直要为这个回答拍案叫绝。我们需要与人交流，渴望了解全部的世界，博客帮助我们遇到那些其他方式无法遇到的人。
不过，写作博客的代价，是要花费很多时间和精力。你每天要在博客上用掉多少时间？
王：平均每天半个小时。
阮：这就是我佩服你的地方。你用英语写，经常有1000词以上的长文，而且写得很清晰易读，却只需要半个小时。这意味着，你基本上没有把时间花在苦苦构思和反复修改上面，属于一次成文。我用汉语写，也做不到这一点。
我的每一篇文章，通常需要2小时~6小时的写作时间。有时候写完以后，觉得特别累，都不想干别的事情了。不过，我还是觉得这是值得的。回过头看，我幸亏把时间花在写作博客上面，否则那些时间就白白过去了，没有留下任何印记。
我现在怀疑的就是，我能不能把这种写作热情保持下去。你能保持吗？相比十年前，你对于博客是否还有同样的热情，或者说同等程度的通过文字、向他人表达自己的愿望？
王：我依然热情不减。我的博客最重要的读者，就是我自己。如果碰巧帮助了别人，那是额外的收获。即使没有人读，我觉得我也会继续，因为它帮助自己思考。
阮：这一点，我与你不同。博客就好像一个人在自说自话，但是随着年龄的增大，我想要说出自己见解的意愿不是那么强烈了，也不是那么在乎，能不能获得外界的承认了。如果有一天，我觉得自己想说的东西，都已经说完了，可能就不写博客了。冯友兰《中国哲学简史》的结束语，我印象很深。他说：”人必须先说很多话，然后保持静默。”不过，我的这一天，还要等很久才会到来。
你想过这个问题吗？觉得自己还会坚持博客多久？Forever？
王：我觉得只要这还是一种可以帮助自己思考、帮助自己记录的好办法，我就会继续。但是如果不是了，我并没有永远写作博客下去的预设的目标。
2010年4月15日
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>word排版高级进阶</title>
    <url>/hobby-word-senior/</url>
    <content><![CDATA[前言在公司实习的时候，写过需求分析文档、概要设计文档、详细设计文档。前些天，帮助小伙伴整理了一下毕业设计论文。而这些长篇文档，都需要用到一些高级的word技巧。下面，我们以毕业设计论文为例，一起来学习一下。郝同学使用的WPS，Office基本相同。本文为图文教程，加载会比较慢，请小伙伴稍等一会。
要求
目录的内容和编排目录只需编排到二级标题，三级标题及以下内容可不编入目录目录题头（格式：三号黑体居中，字间空一格）目录内容（格式：四号宋体，行距24磅）

摘要（1）中文题目：设计（论文）题目（格式：小二号黑体居中）副标题（格式：小三号黑体）题目可以分为1或2行居中打印（2）中文摘要和中文关键词：摘要题头（格式：三号黑体居中，字间空一格）摘要内容（格式：小四号楷体，1.5倍行距）关键词（格式：四号黑体）关键词内容（格式：小四号楷体）摘要题头与中文题目之间空一行，关键词与摘要内容之间空一行。（3）英文题目：设计（论文）英文题目（格式：小二号新罗马体（加粗）居中）副标题（格式：三号新罗马体加粗）题目可以分为1或2行居中打印。（4）英文摘要和英文关键词：英文摘要题头—“Abstract”（格式：三号新罗马体（加粗）居中）英文摘要内容（格式：小四号新罗马体， 1.5倍行距）英文关键词—“Key words”（格式：四号新罗马体加粗）英文关键词内容（格式：小四号新罗马体，1.5倍行距）英文摘要题头与英文题目之间空一行，英文关键词与英文摘要内容之间空一行。（5）中、英文摘要分为两页。

正文字体（1）正文：打印中文用宋体小四号字，英文用新罗马体12号字，行距为固定值20磅，首行缩进。版面上空2.5cm，下空2cm，左空2.5cm，右空2cm。（2）一级标题（章，如“1”，也可用“一”）（格式：三号黑体居中）（3）二级标题（节，如“1.1”，也可用“（一）”）（格式：小三号黑体居左）（4）三级标题（小节，如“1.1.1”，也可用“1”）（格式：四号黑体居左）（5）四级标题（节内小节，如“1.1.1.1”，也可用“（1）”）（注：小四号宋体居左）建议标题最好不要超过三级，否则适得其反，会引起格式混乱。

页眉和页脚（1）页眉页眉采用下列形式：


（2）页脚目录和摘要等内容的页脚为居中、连续的大写罗马数字页码（Ⅰ、Ⅱ、Ⅲ、Ⅳ ……）。正文及其以后部分，其页脚为居中、连续的阿拉伯数字页码（1、2、3 ……）。不宜采用分章的非连续页码。（3）分章节显示页眉页脚的方法，见《毕业设计（论文）撰写规范模板》。

图、表、公式、计量单位和数字用法的规定（1）图：每幅图应有“图序”和“图题”，“图序”和“图题”应放在图位下方居中处。插图一般按全文编排，如图1、图2……，插图较多时可按章排序，如图1.1、图1.2……。“图题”、“图号”字体用小五号黑体。（2）表格：每个表格应有自己的“表序”和“表题”，“表序”和“表题”应写在表格上方居中排放，表序后空一格书写“表题”。“表序”采用阿拉伯数字编排序号，如表1，表2等，表格较多时可按章排序，如表1.1，表2.3等。表格允许下页续写，续写表题可省略，但“表头”应重复写，并在右上方写“续表××”。表内同一栏的数字必须上下对齐。表内必须按规定的符号注明单位。“表序”、“表题”字体用小五号黑体。（3）公式：公式书写应在文中另起一行，居中书写，公式的编号用圆括号括起放在公式右边行末，按章顺序编排，公式与编号之间不加虚线。（4）计量单位和数字：毕业设计（论文 ）中的量和单位必须符合中华人民共和国的国家标准GB3100～GB3102-93。毕业设计（论文 ）中的测量、统计数据一律用阿拉伯数字；在叙述中，一般不宜用阿拉伯数字。

注释注释是对论著中某一特定内容所作的补充说明或进一步解释。注释一般用页末注即将注文放于加注页下端，不可用中注（夹在正文中注）。注释只限于写在注释符号出现的同页。注释格式见下例。例如：



参考文献参考文献应按文中引用的先后顺序，以阿拉伯数字连续编号，在正文引用的相应位置右上角，用[ ]加序号标出。参考文献的有关信息置于文末。参考文献文末著录格式为：专著: [序号]作者.书名[M].出版地:出版者，出版年.译著: [序号]国名或地区（加圆括弧）原作者.书名[M].译者.出版地:出版社,出版年.期刊文章: [序号]作者.篇名[J].期刊名,出版年,卷（期）.报纸文章: [序号]作者.篇名[N].报纸名,年-月-日（版次）.论文集: [序号]作者.篇名[A].编著者.论文集名[C].出版地:出版者,出版年.学位论文: [序号]作者.题名[D].保存地:保存单位,年份.国际、国家标准: [序号]标准编号-发布年,标准名称[S].电子文献：[序号]作者.电子文献名.[电子文献及载体类型标识[电子文献及载体类型说明：
电子文献类型及其标识：数据库—DB，计算机程序—CP，电子公告—EB
电子文献载体类型及其标识：磁带(magnetic tape)—MT，磁盘(disk)—DK，光盘(CD-ROM)—CD，联机网络(online)—OL
举例：[DB/OL]—联机网上数据库(database online)[DB/MT]—磁带数据库(database on magnetic tape)[M/CD]—光盘图书(monograph on CD-ROM)[CP/DK]—磁盘软件(computer program on disk)[J/OL]—网上期刊(serial online)[EB/OL]—网上电子公告(electronic bulletin board online)]].电子文献出处或可获得地址.

效果图有图有真相，先上几幅图，给大家看看最终的效果。
样式样式，其实就是模板。郝同学认为，样式是word排版最重要的一个技巧。学会样式，天下无敌！通过上面的几幅图，我们看到，文档中出现了三级标题，标题前面有编号。“1”、“1.1”、“1.1.1”等等，这些都是自己敲？别傻了！一个个敲，一个个设置，崩溃是早晚的。。。这时候，就需要样式出马了！而且，设置好了样式，待会我们可以直接生成目录。
步骤一：样式设置的位置打开word文档，开始，看右上角。如下图：
步骤二：编号设置1、右击“标题1”，单击“修改样式”2、单击“样式”，单击“编号”3、单击“多级编号”，发现，没有自己需要的编号样式。这时，选中一个接近目标样式的样式，单击“自定义”。4、初始样式如下。5、把编号设置后面的点去掉，编号之后接空格。设置好1级编号样式之后，我们选中2级编号样式，设置类似。之后设置3级编号样式。6、3级编号样式都设置好了，如图。
步骤三：格式设置什么黑体，居中啥的，修改样式即可。
步骤四：使用通过前三个步骤，我们已经设置好了样式。使用的时候，只需要把光标移动到需要设置样式的那一行，然后单击样式即可。
页眉页脚有了页眉页脚的文档，看起来上档次。
步骤一：插入页眉页脚章节，页眉和页脚，然后就可以给页面插入页眉和页脚了。
步骤二：插入分节符1、找到页眉或者页脚需要不同样式的页面，光标移动到页面尾部。2、章节，拆分章节，下一页分节符。（或者：插入，分隔符，下一页分节符）3、选择是否取消各节之间的关联，就可以按自己需要设置各节页眉和页脚以及页码等格式。双击页眉或者页脚，单击“页眉页脚选项”，去掉和前节相关联的勾。
步骤三：设置给不同的节分别设置页眉和页脚。在这个例子中，页眉输入文字，页脚插入页码。
目录没有目录的文档不是好文档！
步骤一：插入目录在封面页后面，插入一个空白页。引用，插入目录，根据需要设置目录选项。
步骤二：目录级别由步骤一，我们看出，目录是自动生成的。但是，我们发现，只有那些分级标题可以生成目录，像摘要、引言等并不会出现在目录中。怎么搞？
在引用页，插入目录的旁边，有一个目录级别选项。如果我们想把摘要添加到目录，只需要把光标移动到摘要这一行，然后单击“目录级别”，选中“1级目录（1）”，就可以了。
步骤三：更新目录步骤二完成后，目录不会变化。这时，我们点击“更新目录”，“更新整个目录”，“摘要”就出现在了目录里。虽然最理想的步骤是：步骤二、步骤一，不用步骤三。但是通常，我们都会用到步骤三。
小结不要问郝同学，黑体怎么设置？居中怎么设置？字体大小怎么设置？。。。这些简单的东西，默认大家已经掌握。加上上面三个技巧，相信你距离高手更近了一步。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
      <tags>
        <tag>word</tag>
      </tags>
  </entry>
  <entry>
    <title>《你的剧本逊毙了》</title>
    <url>/hobby-your-screenplay-sucks/</url>
    <content><![CDATA[写那些让你深深着迷欲罢不能的东西，那些让你血液沸腾，让你午夜难以入眠，让你在鸡尾酒会上不顾场合热烈争论，甚至不惜和老友闹翻的东西。
“ 写剧本将改变你的人生 ， 就算你不能卖掉它 ， 最起码你改变了你的人生 。 ”——约翰·特鲁比
你现所写的东西在深深吸引别人之前，是否深深吸引着你自己？可能已经深藏于表之下的十七层底，你笔下的故事是不是终究还是围绕某个吸引你的核心的？如果你有什么想说 ，那你的剧本就值得一读 。

写作不适合懦夫，它需要投入巨大的心力和精力，艰苦卓绝。从事这项工作段时日，你就会被痔疮、背痛缠身。如果你一心只想着挣钱，你绝对没法捱过漫长过程中深入骨髓的艰难困苦。所以，看在上帝的份上，你得确实有什么想写才行。你为什么想要写作？你为什么充满激情？对你来说什么东西重要？什么是能写的，你关心的，你所知的，读者有兴趣看的？什么故事你比其他任何作者更有资格说？如果因为之前七部冲浪惊悚片都赚了一笔，所以你也要写一部冲浪者的惊悚片，那从一开始你写作的目的就是错的。而敏锐的观众也能闻到这种从内而外散发出来的坏疽的腐臭味。你可以写这个世界上最愚蠢的电影 —— 如果其中确实有什么东西仿佛钩子勾着你的内脏 —— 你终于有机会写点与众不同的东西了。
制片人也跟观众一样。他们只有等你给他们的时候，才知道他们想要什么 。所以赶紧把你独特的东西展示给他们吧。
你的人生也许并不是上好的电影题材，所以一定要注意把它改编成戏剧，然后应深深挖掘你的内心，发掘出那种深埋的情绪。你可以就自己的感受写一部了不起的电影，强烈的情感是全宇宙通吃的，也会像流沙一样深深吸住你的读者，让他们沉溺其中不可自拔。
尽一切方法，利用一切手段，为你的影片找到一个好名字。
你的人物是个百分百的好人么？没人应该这样。他们得有一到两个缺点。
人物一定要是可见的 ，即使把声音关掉也一样 。眼见一个家伙把蔬菜罐头洗了再洗才放进储藏室，效果远胜于听他说： “ 我是个洁癖怪人 。”
你的人物有变化么？变化越大，就可能越好写。在114页的剧本里，如果托比是从A一路变成Z，想想其中有多少步你可以写。但是如果他只是从 A 到 F ，变化没那么大，写作难度也增加了。
没有所谓的“一个普通小镇”，没有所谓的“一个中等城市”，真实生活中也许没有，电影里是肯定没有。如果你在选择地点的时候不能做到真正的具体 ， 具体到乡村、城市或者别墅里的某个房间，你就没法发挥到最佳写作水平。
你的故事发生在哪一年最合适？哪个季节最合适？想象一下你的故事发生在罗马、发生在冬日里积雪三尺厚的死寂的阿拉斯加，或者发生在加利福尼亚的海滩上会多么巨大的不同？观众对同一个事件分别发生在内布拉斯加州、塞尔玛或阿拉巴马又会有怎样不同的反应？地点的选择不仅会影响整个故事，还会影响单个的场景。
他可以是全宇宙无敌的超级混蛋 ， 但只要他有趣 ， 我们照样会被他吸引 。 
我们希望你笔下的人物得到他想要的，但是我们不必喜欢他，我觉得最好的状态就是：“他是我们最讨厌的家伙，我们却偏偏仍希望他赢 。 ”
你必须为英雄找到一个人来对抗。如果你没有，赶紧找一个。
你的英雄是否有趣，取决于他的对手。
别把他弄成一个百分百的坏蛋。就像你的英雄也不是百分百的好人一样 ， 你的对手也不应该是一个彻底的混蛋 。
没有对手，你的英雄永远也不可能进化到他需要变成的那样。
是什么引起主人公发生变化？最好是他的对手。
人物和故事优先 ， 先于任何事情 。把结构扔到一旁，先享受故事的乐趣。
那是我最富有创造力的时刻之一，曾经，在一个午后，我躺在床上，胸前口袋里揣着一个录音机。在我渐渐进入梦乡之前 ，我一直听着音乐构思故事。真正进入睡眠之前我仿佛遁入了一个奇妙的空间——我依然可以思考可以说话，我的思维和音乐互动不受约束——那种自由的感觉简直难以置信。想法自己就飞旋着跑出来，而我只是把这些由音乐触发的想法口述出来。 我迫使自己一直醒着，坚持停留在这个不受正常思维拘束的区间，就在半梦半醒之际对着录音机讲述——直到最后渐渐睡去。当我从小憩中醒来，就开始誊写自己的笔记。一些很垃圾，但是另一些非常有创造力。这是一种构思故事的非常方法，仅供参考。
作为一个编剧你追求的就是张力。
不要犯我很多学生都犯的错误，故事一开始的时候就缺乏张力——赌注不能一开始很低，到后面才提高；赌注要一开始就很高，然后越来越高，越来越高。一开始的时候，你的家伙已经在走钢丝了，然后在他走到半途的时候开始刮风，他的老婆远远地站在钢丝那头对他嚷嚷要离他而去。当他走到3/4的位置的时候，他的医生给他掷过来一只纸飞机，打开是张便条，为了告诉他得了癌症 ……不管怎样 ， 反正不能让你的家伙一开始的时候稳稳当当地站在地下 ， 故事必须一开始就张力十足。
你的时间期限压缩得越短 ， 就越容易得到令人满意的好故事 ， 因为你给你的人物增加了困难。
给读者提供一次情感经历，否则你就是在浪费时间。什么情感不要紧，但是一定要确保他或她确实感受到了,当然越强越好。
你的故事必须围绕某事——这就是你的主题。在电脑上把它打出来，一直盯着它。不管你的主题是什么，你的英雄需要从始至终都在解决这个问题 ， 他的性格成长也必须与主题紧密结合 —— 这是故事结构的基础。
“一个能引起共鸣（或引人注目）的主人公发现自己身处于某种麻烦之中，他做一些积极的努力试图摆脱这麻烦，然而他的每一次努力 ， 只能让他陷得更深 ，而且一路上他遭遇的阻碍也越来越大。最后，当事情看起来好像最黑暗无望的时候 ， 主人公好像就要玩完了的时候 ， 通过他自己的力量 、 智慧或者机灵 ， 他终于设法摆脱了麻烦 。 ”
这个麻烦也需要像主人公一样有趣。不仅仅只是对你有趣！它必须是一个有相当难度的大问题，而且很激烈。如果她不能解决，之后的人生就会一团糟。
永不言弃！这是你的英雄的颂歌，也是不解的魔咒！
阻碍必须越来越大，只有这样，通过跟它们的战斗，人物才能变得越来越聪明越来越强大，最终才能战胜坏蛋。更重要的一个原因是 ， 如果阻碍不是越来越大的话，读者就会觉得乏味失去兴趣。
不管你写什么怎么写 ， 反正你必须让他走到悬崖边上 ， 差点就摔得粉碎一命呜呼。
你必须知道你的人物一开始的时候在哪儿，你还必须知道你的人物最终要去哪儿，这就是她的弧光、她的转变、她的变化。有时你可以先想结尾：“当一切结束的时候，她会是什么样子？——强壮，友善，活跃？”然后反向进行——“那她开始的时候是怎样一个人？ —— 脆弱，烦躁，处境危险？ ”
如果你从头娓娓道来你的英雄是如何陷入困境 ，效果估计不会理想，一开场就该让他正身处困境之中。如果他没有麻烦 ， 你干吗要讲这个故事？给他一个够分量的、困难的、有趣的问题。
故事一开头人物没有意识到的东西，到故事结尾却是人物真正需要的东西。米克和基思所言极是——“你不是总能得到你想要的 ” ， 但是如果你努力 （ 真的很努力 ！ ） ， “ 你会得到你需要的 ” 。
在中间点（midpoint）也需要有一个大事件。或者人物大胜，或者人物惨败。或者让我们觉得美妙绝伦，或者让我们觉得糟糕透顶。总之有什么事发生 ，故事由此拐入新的方向。布置个作业，随便挑些电影，找出影片的中间点。瞧 ，它在那儿！
最低限度你需要知道你的主题、你的人物怎样转变，故事中主要的惊喜是什么。当然你还需要知道结尾，知道你要往哪儿去很重要 。 
“一句话大纲”是非常重要的写作工具！没有它根本不可能看到你的故事，比如看115页的剧本很难看清楚故事的情节设置。通过把每个场景里发生的事只用一句话做言简意赅的描述，你就可以将故事的全貌一览无遗。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>AngularJS入门篇</title>
    <url>/dev-angularjs-start/</url>
    <content><![CDATA[前言AngularJS是一个JavaScript框架，它通过指令扩展了HTML，且通过表达式绑定数据到 HTML。
顺便一提，什么是框架？比如struts2、spring、hibernate、thinkphp、wordpress等等。那么，什么是组件？比如jdbc、jquery、swiper、layer、arttemplate等等。一般来说，那些可复用的、用于简化开发工作的代码集合，大的叫框架，小的叫组件。有人说jquery是框架？当然可以，大小并没有明确边界。不要太纠结于概念，如无必要，勿增实体。
本文，主要学习归纳一下Angular的各种特性，包括双向数据绑定、定义应用和控制器、优化模板渲染延迟、自定义指令、作用域、HTTP请求获取数据、自定义服务、依赖注入、路由控制等。最后，会给出一个综合实例。



双向数据绑定单向数据绑定的原理：模板+数据=&gt;视图。目前大多数前端框架都是单向数据绑定，比如jQueryUI、BackBone、Flex。
双向数据绑定原理：模板+数据=&gt;视图，模板+视图=&gt;数据。
Angular采用的，就是双向数据绑定。
&lt;!--helloworld.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;双向数据绑定&lt;/title&gt;    &lt;script src="http://code.angularjs.org/angular-1.0.1.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    Hello &#123;&#123;'World'&#125;&#125;!&lt;br/&gt;    Your name: &lt;input type="text" ng-model="yourname" placeholder="World"&gt;    &lt;hr&gt;    Hello &#123;&#123;yourname || 'World'&#125;&#125;!&lt;/body&gt;&lt;/html&gt;

定义应用和控制器angular对象，是Angular的根对象。类似于express框架中的express对象，类似于seajs框架的seajs对象，类似于浏览器的window对象。如果说angular对象是Angular中的班主任，那么应用（或者叫模块，app）就是Angular中的班长！而班主任不常出没，管事的就是班长。控制器（controller），就是普通同学小明，负责控制Angular应用程序中的数据。
&lt;!--app.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app="myApp"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;定义应用和控制器&lt;/title&gt;    &lt;style&gt;        [ng\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak &#123;          display: none !important;        &#125;    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;div ng-controller="myCtrl"&gt;    名: &lt;input type="text" ng-model="firstName"&gt;&lt;br&gt;    姓: &lt;input type="text" ng-model="lastName"&gt;&lt;br&gt;    &lt;br&gt;    姓名: &lt;span&gt;&#123;&#123;firstName + " " + lastName&#125;&#125;&lt;/span&gt;&lt;br&gt;    姓名2: &lt;span class="ng-cloak"&gt;&#123;&#123;fullName()&#125;&#125;&lt;/span&gt;&lt;br&gt;    姓名3: &lt;span ng-bind="fullName()"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;script src="http://code.angularjs.org/angular-1.0.1.min.js"&gt;&lt;/script&gt;    &lt;script&gt;        var app = angular.module('myApp', []);        app.controller('myCtrl', function($scope) &#123;            $scope.firstName= "John";            $scope.lastName= "Doe";            $scope.fullName = function() &#123;                return $scope.firstName + " " + $scope.lastName;            &#125;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

优化模板渲染延迟在定义应用和控制器的例子中，我们看到，页面上先出现了表达式，之后才出现我们期望的结果。解决这个问题，常用的有两个办法。一个是使用ng-bind，另一个是添加ng-cloak样式。
自定义指令&lt;!--directive.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;自定义指令&lt;/title&gt;    &lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt; &lt;/head&gt;&lt;body ng-app="myApp"&gt;    &lt;runoob-directive&gt;&lt;/runoob-directive&gt;    &lt;div runoob-directive&gt;&lt;/div&gt;    &lt;div class="runoob-directive"&gt;&lt;/div&gt;    &lt;!-- 指令: runoob-directive --&gt;    &lt;script&gt;        var app = angular.module("myApp", []);        app.directive("runoobDirective", function() &#123;            return &#123;                //restrict : "A",                //restrict : "C",                //restrict : "M",                //replace : true,                template : "&lt;h1&gt;自定义指令!&lt;/h1&gt;"            &#125;;        &#125;);    &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

作用域&lt;!--scope.html--&gt;&lt;!DOCTYPE html&gt;&lt;html ng-app="myApp"&gt;&lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;作用域&lt;/title&gt;    &lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;    &lt;div ng-controller="myCtrl"&gt;        &lt;h1&gt;姓氏为 &#123;&#123;lastname&#125;&#125; 家族成员:&lt;/h1&gt;        &lt;ul&gt;            &lt;li ng-repeat="x in names"&gt;&#123;&#123;x&#125;&#125; &#123;&#123;lastname&#125;&#125;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;    &lt;script&gt;        var app = angular.module('myApp', []);        app.controller('myCtrl', function($scope, $rootScope) &#123;            $scope.names = ["Emil", "Tobias", "Linus"];            $rootScope.lastname = "Refsnes";        &#125;);    &lt;/script&gt;    &lt;p&gt;注意 $rootScope 在循环对象内外都可以访问。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

上面的例子中，$scope的作用域为myCtrl这个ng-controller的范围，$rootScope的作用域为myApp这个ng-app的范围。
HTTP请求获取数据获取本地数据&lt;!--http.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;HTTP请求&lt;/title&gt;    &lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp" &gt;    &lt;div ng-controller="myCtrl"&gt;         &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 "username" 中。&lt;/p&gt;&lt;script&gt;    var app = angular.module('myApp', []);    app.controller('myCtrl', function($scope, $http) &#123;      $http.get("http.json").then(function (response) &#123;          $scope.username = response.data.username;      &#125;);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

http.json中的内容为：
&#123;    "username":"voidking" &#125;

需要注意的是，本例需要在服务器中访问。因为Angular的HTTP请求封装了XMLHttpRequest，而XMLHttpRequest的使用需要服务器环境。
获取服务器数据&lt;!--http2.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;HTTP请求服务器数据&lt;/title&gt;    &lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp" &gt;    &lt;div ng-controller="myCtrl"&gt;     &lt;h1&gt;欢迎你！&#123;&#123;username&#125;&#125;&lt;/h1&gt;    &lt;/div&gt;    &lt;p&gt; $http 服务向服务器请求信息，返回的值放入变量 "username" 中。&lt;/p&gt;&lt;script&gt;    var app = angular.module('myApp', []);    app.controller('myCtrl', function($scope, $http, $httpParamSerializer) &#123;        $http(&#123;            method:'POST',            url:'/angulardemo/http.php',            headers:&#123;                'Content-Type':'application/x-www-form-urlencoded'            &#125;,            dataType: 'json',            data: $httpParamSerializer(&#123;username:'voidking'&#125;)        &#125;).then(function successCallback(response) &#123;            console.log(response.data);            $scope.username = response.data.username;        &#125;, function errorCallback(response) &#123;            console.log(response.data);        &#125;);;    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

新建http.php，内容如下：
&lt;?php     $username = $_POST['username'];    $result = array(        'code' =&gt; '0',        'ext' =&gt; 'success',        'username' =&gt; $username    );    echo json_encode($result);?&gt;


自定义服务&lt;!--service.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset="utf-8"&gt;    &lt;title&gt;自定义Service&lt;/title&gt;    &lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body ng-app="myApp" &gt;    &lt;div ng-controller="myCtrl"&gt;        &lt;p&gt;自定义服务，用于转换16进制数：&lt;/p&gt;        &lt;p&gt;255 的16进制是:&lt;/p&gt;        &lt;h1&gt;&#123;&#123;hex&#125;&#125;&lt;/h1&gt;        &lt;hr&gt;        &lt;p&gt;在获取数组 [255, 251, 200] 值时使用过滤器:&lt;/p&gt;        &lt;ul&gt;          &lt;li ng-repeat="x in counts"&gt;&#123;&#123;x | myFormat&#125;&#125;&lt;/li&gt;        &lt;/ul&gt;    &lt;/div&gt;&lt;script&gt;    var app = angular.module('myApp', []);    app.service('hexafy', function() &#123;        this.myFunc = function (x) &#123;            return x.toString(16);        &#125;    &#125;);    app.controller('myCtrl', function($scope, hexafy) &#123;        $scope.hex = hexafy.myFunc(255);        $scope.counts = [255, 251, 200];    &#125;);    app.filter('myFormat',['hexafy', function(hexafy) &#123;        return function(x) &#123;            return hexafy.myFunc(x);        &#125;;    &#125;]);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

当创建了自定义服务，并连接到应用上后，我们可以在控制器，指令，过滤器或其他服务中使用它。
依赖注入AngularJS 提供很好的依赖注入机制。什么是依赖注入？wiki 上的解释是：依赖注入（Dependency Injection，简称DI）是一种软件设计模式，在这种模式下，一个或更多的依赖（或服务）被注入（或者通过引用传递）到一个独立的对象（或客户端）中，然后成为了该客户端状态的一部分。该模式分离了客户端依赖本身行为的创建，这使得程序设计变得松耦合，并遵循了依赖反转和单一职责原则。与服务定位器模式形成直接对比的是，它允许客户端了解客户端如何使用该系统找到依赖。
&lt;!--di.html--&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;   &lt;meta charset="utf-8"&gt;   &lt;title&gt;AngularJS依赖注入&lt;/title&gt;&lt;/head&gt;   &lt;body ng-app="mainApp" &gt;   &lt;h2&gt;AngularJS 简单应用&lt;/h2&gt;   &lt;div ng-controller="CalcController"&gt;      &lt;p&gt;配置：&#123;&#123;constant&#125;&#125;&lt;/p&gt;      &lt;p&gt;输入一个数字: &lt;input type = "number" ng-model = "number" /&gt;&lt;/p&gt;      &lt;button ng-click = "square()"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt;      &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt;   &lt;/div&gt;   &lt;hr&gt;   &lt;div ng-controller="CalcController2"&gt;      &lt;p&gt;再输入一个数字: &lt;input type = "number" ng-model = "number" /&gt;&lt;/p&gt;      &lt;button ng-click = "square()"&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/button&gt;      &lt;p&gt;结果: &#123;&#123;result&#125;&#125;&lt;/p&gt;   &lt;/div&gt;   &lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;script&gt;   var mainApp = angular.module("mainApp", []);   mainApp.config(function($provide) &#123;      // 创建一个名叫MathService的provider      $provide.provider('MathService', function() &#123;         this.$get = function() &#123;            var factory = &#123;&#125;;                     factory.multiply = function(a, b) &#123;               return a * b;            &#125;            return factory;         &#125;;      &#125;);   &#125;);   // 创建一个名叫defaultInput的value   mainApp.value("defaultInput", 5);   // 创建一个名叫constant的constant value   mainApp.constant("constant", "constant value");   // 将MathService、defaultInput、constant注入到控制器   mainApp.controller('CalcController', function($scope, MathService, defaultInput, constant) &#123;      $scope.number = defaultInput;      $scope.constant = constant;      $scope.result = MathService.multiply($scope.number,$scope.number);      $scope.square = function() &#123;         $scope.result = MathService.multiply($scope.number,$scope.number);      &#125;   &#125;);   /*--------以下是CalcController2的内容--------*/   // 创建一个名叫MathService2的factory   mainApp.factory('MathService2', function() &#123;      var factory = &#123;&#125;;            factory.multiply = function(a, b) &#123;         return a * b;      &#125;      return factory;   &#125;);      // 创建一个名叫CalcService2的service，并且注入MathService2   mainApp.service('CalcService2', function(MathService2)&#123;      this.square = function(a) &#123;         return MathService2.multiply(a,a);      &#125;   &#125;);   // 将CalcService2注入到控制器   mainApp.controller('CalcController2',function($scope,CalcService2)&#123;      $scope.number = 6;      $scope.result = CalcService2.square($scope.number);      $scope.square = function() &#123;         $scope.result = CalcService2.square($scope.number,$scope.number);      &#125;   &#125;);    &lt;/script&gt;   &lt;/body&gt;&lt;/html&gt;

provider()函数是用来创建provider对象的标准方法。
实际上，value()、constant()、factory()、service()全都是用来创建一个provider对象的方法，它们提供了一种方式来定义一个provider，而无需输入所有的复杂的代码。
路由控制AngularJS 路由允许我们通过不同的 URL 访问不同的内容。通过 AngularJS 可以实现多视图的单页Web应用（single page web application，SPA）。通常我们的URL形式为http://runoob.com/first/page ，但在单页Web应用中AngularJS 通过 # + 标记 实现，例如：
http://runoob.com/#/firsthttp://runoob.com/#/secondhttp://runoob.com/#/third

当我们点击以上的任意一个链接时，向服务端请的地址都是一样的 (http://runoob.com/)。 因为 # 号之后的内容在向服务端请求时会被浏览器忽略掉。 所以我们就需要在客户端实现 # 号后面内容的功能实现。 AngularJS 路由 就通过 # + 标记 帮助我们区分不同的逻辑页面并将不同的页面绑定到对应的控制器上。

AngularJS 模块的 config 函数用于配置路由规则。通过使用 configAPI，我们请求把$routeProvider注入到我们的配置函数并且使用$routeProvider.whenAPI来定义我们的路由规则。$routeProvider 为我们提供了 when(path,object) &amp; otherwise(object) 函数按顺序定义所有路由，函数包含两个参数:第一个参数是 URL 或者 URL 正则规则。第二个参数是路由配置对象。
&lt;!--router.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;路由控制&lt;/title&gt;&lt;/head&gt;&lt;body ng-app="ngRouteExample" class="ng-scope"&gt;    &lt;div&gt;         &lt;div id="navigation"&gt;          &lt;a href="#/home"&gt;Home&lt;/a&gt;        &lt;a href="#/about"&gt;About&lt;/a&gt;    &lt;/div&gt;          &lt;div ng-view=""&gt;    &lt;/div&gt;&lt;script type="text/ng-template" id="embedded.home.html"&gt;    &lt;h1&gt; Home &lt;/h1&gt;&lt;/script&gt;&lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;script src="http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;    angular.module('ngRouteExample', ['ngRoute'])    .controller('HomeController', function ($scope, $route) &#123; $scope.$route = $route;&#125;)    .controller('AboutController', function ($scope, $route) &#123; $scope.$route = $route;&#125;)    .config(function ($routeProvider) &#123;        $routeProvider.        when('/home', &#123;            templateUrl: 'embedded.home.html',            controller: 'HomeController'        &#125;).        when('/about', &#123;            templateUrl: 'about.html',            controller: 'AboutController'        &#125;).        otherwise(&#123;            redirectTo: '/home'        &#125;);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

&lt;!--about.html--&gt;&lt;h1&gt; About &lt;/h1&gt;

综合&lt;!--complex.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;综合实例&lt;/title&gt;&lt;/head&gt;&lt;body ng-app="ngRouteExample" class="ng-scope"&gt;    &lt;div&gt;         &lt;div id="navigation"&gt;          &lt;a href="#/page1"&gt;Page1&lt;/a&gt;        &lt;a href="#/page2"&gt;Page2&lt;/a&gt;    &lt;/div&gt;         &lt;div ng-view=""&gt;    &lt;/div&gt;&lt;script src="http://cdn.static.runoob.com/libs/angular.js/1.4.6/angular.min.js"&gt;&lt;/script&gt;&lt;script src="http://apps.bdimg.com/libs/angular-route/1.3.13/angular-route.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt;        var myApp = angular.module('ngRouteExample', ['ngRoute']);    myApp.controller('Page1Controller', function ($scope, $route) &#123;         $scope.$route = $route;        $scope.content = '这是page1的内容';    &#125;);    myApp.controller('Page2Controller', function ($scope, $route) &#123;         $scope.$route = $route;        $scope.content = '这是page2的内容';    &#125;)    myApp.config(function ($routeProvider) &#123;        $routeProvider.        when('/page1', &#123;            templateUrl: 'complex-page1.html',            controller: 'Page1Controller'        &#125;).        when('/page2', &#123;            templateUrl: 'complex-page2.html',            controller: 'Page2Controller'        &#125;).        otherwise(&#123;            redirectTo: '/page1'        &#125;);    &#125;);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

&lt;!--complex-page1.html--&gt;&lt;div id="page1" ng-controller="Page1Controller"&gt;    &lt;h1&gt;Page1&lt;/h1&gt;    &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt;

&lt;!--complex-page2.html--&gt;&lt;div id="page2" ng-controller="Page2Controller"&gt;    &lt;h1&gt;Page2&lt;/h1&gt;    &lt;p&gt;&#123;&#123;content&#125;&#125;&lt;/p&gt;&lt;/div&gt;

后记至于输入验证、事件、动画、API等，本文不再讨论，用到时自行查阅文档。本文完整源码地址：https://github.com/voidking/angulardemo
记录一个hexo的坑：如果文中出现了双括号，而且双括号没有被代码块包含，那么解析会报错，无法生成页面。
查找到的解决办法：
&#123;% raw %&#125;内容&#123;% endraw %&#125;

经测试，无效，就用汉字代替好了。
书签AngularJS实战http://www.imooc.com/learn/156
AngularJS 教程 | 菜鸟教程http://www.runoob.com/angularjs/angularjs-tutorial.html
AngularJS中文网http://www.apjs.net/
AngularJS中文社区http://angularjs.cn/
图灵社区: 合集 : AngularJS入门教程http://www.ituring.com.cn/minibook/303
AngularJS: API: API Referencehttps://docs.angularjs.org/api
ngCloakhttps://docs.angularjs.org/api/ng/directive/ngCloak
AngularJS : Why ng-bind is better than 双括号 in angular?http://stackoverflow.com/questions/16125872/angularjs-why-ng-bind-is-better-than-in-angular
Metronic3.3网页模板在线演示http://metronic.kp7.cn/
框架到底是个什么东西？https://www.zhihu.com/question/32069908
理解AngularJS中的依赖注入http://sentsin.com/web/663.html
Hexo的一个小BUG(Template render error)http://www.jianshu.com/p/738ebe02029b
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>angularjs</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angularjs</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>图书管理系统之ui</title>
    <url>/dev-bookmanage-ui/</url>
    <content><![CDATA[前言这三篇博文，是一个整体，单独看也许艰涩难懂。但是，合起来看，很多疑问就可以迎刃而解。正如马哲所说，整体功能可以大于部分功能之和。
新建工程1、打开Eclipse，File，New，Maven Project，勾选Create a simple project，Next。
2、填写Group Id和Artifact Id，Packaging选择war。


相当于命令：
mvn archetype:create -DgroupId=com.voidking.book -DartifactId=book-ui-DarchetypeArtifactId=maven-archetype-webapp

pom.xml&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;parent&gt;		&lt;groupId&gt;com.voidking.book&lt;/groupId&gt;		&lt;artifactId&gt;book-parent&lt;/artifactId&gt;		&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;		&lt;relativePath&gt;../book-parent/pom.xml&lt;/relativePath&gt;	&lt;/parent&gt;  &lt;artifactId&gt;book-ui&lt;/artifactId&gt;    &lt;packaging&gt;war&lt;/packaging&gt;    &lt;dependencies&gt;		&lt;!-- struts2框架 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;			&lt;artifactId&gt;struts2-core&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;			&lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;			&lt;artifactId&gt;struts2-json-plugin&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;			&lt;artifactId&gt;struts2-convention-plugin&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- Spring 核心库 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-core&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-orm&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- Spring MVC 库 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.aspectj&lt;/groupId&gt;			&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- servlet api --&gt;		&lt;dependency&gt;			&lt;groupId&gt;javax.servlet&lt;/groupId&gt;			&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- 引用业务层的jar包 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;com.voidking.book&lt;/groupId&gt;			&lt;artifactId&gt;book-logic&lt;/artifactId&gt;			&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;			&lt;exclusions&gt;				&lt;exclusion&gt;					&lt;groupId&gt;org.hibernate&lt;/groupId&gt;					&lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;				&lt;/exclusion&gt;			&lt;/exclusions&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.hibernate&lt;/groupId&gt;			&lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-web&lt;/artifactId&gt;		&lt;/dependency&gt;	&lt;/dependencies&gt;	&lt;build&gt;		&lt;plugins&gt;			&lt;plugin&gt;				&lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt;				&lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt;				&lt;configuration&gt;					&lt;scanIntervalSeconds&gt;10&lt;/scanIntervalSeconds&gt;					&lt;connectors&gt;						&lt;connector implementation="org.mortbay.jetty.nio.SelectChannelConnector"&gt;							&lt;port&gt;8099&lt;/port&gt;							&lt;maxIdleTime&gt;60000&lt;/maxIdleTime&gt;						&lt;/connector&gt;					&lt;/connectors&gt;				&lt;/configuration&gt;			&lt;/plugin&gt;		&lt;/plugins&gt;	&lt;/build&gt;&lt;/project&gt;
值得一提的是，maven的web工程中，习惯用jetty而不是tomcat。jetty发布的工程，在当前工程下的target/相应版本号下。比如本工程，发布后在target/book-ui-0.0.1-SNAPSHOT下。
新建包新建包com.voidking.book.admin.action、com.voidking.book.bookbase.action、com.voidking.book.bookkind.action、com.voidking.book.readerbase.action、com.voidking.book.readerkind.action、com.voidking.book.borrowinfo.action、com.voidking.book.search.action、com.voidking.book.statistics.action。
admin.action包在admin.action包，新建LoginAction.java，内容如下。
package com.voidking.book.admin.action;import org.apache.struts2.convention.annotation.Action;import org.apache.struts2.convention.annotation.Namespace;import org.apache.struts2.convention.annotation.ParentPackage;import org.apache.struts2.convention.annotation.Result;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;import com.voidking.book.entity.Admin;import com.voidking.book.logic.AdminLogicService;@Controller@Namespace("/admin")@ParentPackage("custom-default")public class LoginAction extends ActionSupport &#123;	private static final long serialVersionUID = 2936224923889056993L;	@Autowired	private AdminLogicService adminLogicService;	private Admin admin;	private String info;	public Admin getAdmin() &#123;		return admin;	&#125;	public void setAdmin(Admin admin) &#123;		this.admin = admin;	&#125;	public String getInfo() &#123;		return info;	&#125;	public void setInfo(String info) &#123;		this.info = info;	&#125;	@Action(value = "login", results = &#123; @Result(name = "success", type = "json") &#125;)	public String login() throws Exception &#123;		this.info = this.adminLogicService.login(admin);		if (admin.getId() != null)// 登录成功		&#123;			ActionContext.getContext().getSession().put("admin", admin);		&#125;		return SUCCESS;	&#125;&#125;
1、@Controller，Spring的注解。在SpringMVC中提供了一个非常简便的定义Controller的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller标记一个类是Controller，然后使用@RequestMapping和@RequestParam等一些注解用以定义URL请求和Controller方法之间的映射，这样的Controller就能被外界访问到。此外Controller不会直接依赖于HttpServletRequest和HttpServletResponse等HttpServlet对象，它们可以通过Controller 的方法参数灵活的获取到。
2、我们知道通常情况下，Struts2是通过struts.xml配置的。但是随着系统规模的加大我们需要配置的文件会比较大，虽然我们可以根据不同的系统功能将不同模块的配置文件单独书写，然后通过include节点将不同的配置文件引入到最终的struts.xml文件中，但是毕竟还是要维护和管理这些文件，因此也会给维护工作带来很大的困扰。为了解决这个问题，可以考虑使用struts2的注解。实际上struts2中最主要的概念就是package、action以及Interceptor等等概念，所以只要明白这些注解就可以了。
3、@Namespace，Struts2的注解。命名空间，也就是xml文件中package的namespace属性。如果没有@Namespace(“/admin”)注解，按照Convention Plugin的约定，会将此包作为根包，对应Action URL的命名空间为“/”。
4、@ParentPackage，Struts2的注解。这个注解对应了xml文件中的package节点，它只有一个属性叫value，其实就是package的name属性；
5、@Action，Struts2的注解。这个注解对应action节点。这个注解可以应用于 action 类上，也可以应用于方法上。这个注解中有几个属性：

value，表示action的URL，也就是action节点中的name属性；
results，表示action的多个result，这个属性是一个数组属性，因此可以定义多个Result；
interceptorRefs，表示action的多个拦截器，这个属性也是一个数组属性，因此可以定义多个拦截器；
params，这是一个String类型的数组，它按照name/value的形式组织，是传给action的参数；
exceptionMappings，这是异常属性，它是一个ExceptionMapping的数组属性，表示action的异常，在使用时必须引用相应的拦截器；

6、@Result ，Struts2的注解。这个注解对应了result节点。这个注解只能应用于 action 类上。这个注解中也有几个属性：

name，表示action方法的返回值，也就是result节点的name属性，默认情况下是success；
location，表示view层文件的位置，可以是相对路径，也可以是绝对路径；
type，是action的类型，比如redirect；
params，是一个String数组。也是以name/value形式传送给result的参数；

struts.xml在src/main/resources文件下，新建struts.xml，内容如下。
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.1//EN" "http://struts.apache.org/dtds/struts-2.1.dtd"&gt;&lt;struts&gt;	&lt;constant name="struts.multipart.maxSize" value="99999999999" /&gt;	&lt;constant name="struts.allowed.action.names" value="[a-zA-Z0-9._!/\-]*"&gt;&lt;/constant&gt;	&lt;constant name="struts.multipart.saveDir" value="/tmp" /&gt;	&lt;constant name="struts.devMode" value="true" /&gt;	&lt;constant name="struts.i18n.encoding" value="UTF-8" /&gt;	&lt;package name="custom-default" extends="json-default"&gt;		&lt;interceptors&gt;			&lt;!--定义拦截器 name:拦截器名称 class:拦截器类路径--&gt;			&lt;!-- 定义拦截器栈 --&gt;			&lt;interceptor-stack name="myDefaultStack"&gt;				&lt;interceptor-ref name="json" /&gt;				&lt;interceptor-ref name="defaultStack" /&gt;			&lt;/interceptor-stack&gt;		&lt;/interceptors&gt;		&lt;default-interceptor-ref name="myDefaultStack" /&gt;	&lt;/package&gt;&lt;/struts&gt;
1、struts.properties文件的内容均可在struts.xml中以&lt;constant name=&quot;&quot; value=&quot;&quot;&gt;&lt;/constant&gt;加载。
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"    "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt;    &lt;!-- 把它设置为开发模式，发布时要设置为false --&gt;    &lt;constant name="struts.devMode" value="true" /&gt;    &lt;!-- 设置在class被修改时是否热加载，发布时要设置为false --&gt;    &lt;constant name="struts.convention.classes.reload" value="true"/&gt;    &lt;!-- 自动动态方法的调用，使用这个设置后可以这样调用：action!method --&gt;    &lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt;    &lt;!-- 指定jsp文件所在的目录地址 --&gt;    &lt;constant name="struts.convention.result.path" value="/WEB-INF/content/" /&gt;    &lt;!-- 使用struts-default默认的转换器，如果是rest的使用：rest-default，rest需要rest的jar插件 --&gt;    &lt;constant name="struts.convention.default.parent.package" value="struts-default"/&gt;    &lt;!-- 用于配置包名后缀。默认为action、actions、struts--&gt;    &lt;constant name="struts.convention.package.locators" value="actions" /&gt;    &lt;!-- 用于配置类名后缀，默认为Action，设置后，Struts2只会去找这种后缀名的类做映射 --&gt;    &lt;constant name="struts.convention.action.suffix" value="Action"/&gt;    &lt;!-- 设置即使没有@Action注释，依然创建Action映射。默认值是false。因为Convention-Plugin是约定优于配置的风格，        可以不通过注解根据预先的定义就能访问相应Action中的方法 --&gt;    &lt;constant name="struts.convention.action.mapAllMatches" value="true"/&gt;    &lt;!-- 自定义jsp文件命名的分隔符 --&gt;    &lt;constant name="struts.convention.action.name.separator" value="-" /&gt;    &lt;!-- 国际化资源文件名称 --&gt;    &lt;constant name="struts.custom.i18n.resources" value="i18n" /&gt;    &lt;!-- 是否自动加载国际化资源文件  --&gt;    &lt;constant name="struts.i18n.reload" value="true" /&gt;    &lt;!-- 浏览器是否缓存静态内容 --&gt;    &lt;constant name="struts.serve.static.browserCache" value="false" /&gt;     &lt;!-- 上传文件大小限制设置 --&gt;    &lt;constant name="struts.multipart.maxSize" value="-1" /&gt;    &lt;!-- 主题，将值设置为simple，即不使用UI模板。这将不会生成额外的html标签 --&gt;    &lt;constant name="struts.ui.theme" value="simple" /&gt;    &lt;!-- 编码格式 --&gt;    &lt;constant name="struts.i18n.encoding" value="UTF-8" /&gt;&lt;/struts&gt;

2、package有以下几个常用属性：

name：该属性是必选的，指定包的名字，这个名字将作为引用该包的键。注意，包的名字必须是唯一的，在一个struts.xml文件中不能出现两个同名的包。
extends：该属性是可选的，允许一个包继承一个或多个先前定义的包。
abstract：该属性是可选的，将其设置为true，可以把一个包定义为抽象的。抽象包不能有action定义，它只能作为“父”包，被其他包所继承。注意，以为Struts2的配置文件是从上到下处理的，所以父包应该在子包前面定义。
namespace：该属性是可选的，将保存的action配置为不同的名称空间。如果接收到一个请求为/space/main.action，框架将首先查找/space名称空间，如果找到了，则执行main.action；如果没有找到，则到默认的名称空间（name=”default”）中继续查找。如果接收到一个请求为/main.action，框架将首先查找“/”名称空间，如果找到了，则执行main.action；如果没有找到，则到默认的名称空间（name=”default”）中继续查找。

配置文件需要注意的是，在前两层中，我们的配置文件全部放到了src/test/resources中。但是，在这一层，我们的配置文件主要放在两个位置。一个是src/main/resources，另一个是src/main/webapp/WEB-INF。
1、在resources下，有struts.xml、database-conn.properties、log4j.properties。2、在WEB-INF下，有applicationContext.xml、spring-persist.xml、web.xml。
web.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"	xmlns="http://java.sun.com/xml/ns/javaee"	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"	version="2.5"&gt;	&lt;display-name&gt;voidking&lt;/display-name&gt;	&lt;filter&gt;		&lt;filter-name&gt;entityManagerFilter&lt;/filter-name&gt;		&lt;filter-class&gt;org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter&lt;/filter-class&gt;	&lt;/filter&gt;	&lt;filter-mapping&gt;		&lt;filter-name&gt;entityManagerFilter&lt;/filter-name&gt;		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;	&lt;/filter-mapping&gt;	&lt;filter&gt;		&lt;filter-name&gt;struts2&lt;/filter-name&gt;		&lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;	&lt;/filter&gt;	&lt;filter-mapping&gt;		&lt;filter-name&gt;struts2&lt;/filter-name&gt;		&lt;url-pattern&gt;/*&lt;/url-pattern&gt;	&lt;/filter-mapping&gt;	&lt;listener&gt;		&lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;	&lt;/listener&gt;&lt;/web-app&gt;
1、display-name，如果使用工具编辑部署描述符，display-name元素包含的就是XML编辑器显示的名称。
2、filter，用于指定Web容器中的过滤器。在请求和响应对象被servlet处理之前或之后，可以使用过滤器对这两个对象进行操作。配合filter-mapping，过滤器被映射到一个servlet或一个URL。这个过滤器的filter元素和filter-mapping元素必须具有相同的名称。
applicationContext.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"	xmlns="http://www.springframework.org/schema/beans"	xsi:schemaLocation="    http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;    &lt;import resource="spring-persist.xml"/&gt;    &lt;/beans&gt;

工作流程1、客户端提交一个HttpServletRequest请求。
2、请求被提交到一系列Filter过滤器，如ActionCleanUp和FilterDispatcher等。
3、FilterDispatcher是Struts2控制器的核心，它通常是过滤器链中的最后一个过滤器。
4、请求被发送到FilterDispatcher后，FilterDispatcher询问ActionMapper时候需要调用某个action来处理这个Request。
5、如果ActionMapper决定需要调用某个action，FilterDispatcher则把请求交给ActionProxy进行处理。
6.ActionProxy通过Configuration Manager询问框架的配置文件struts.xml（本项目实现struts2零配置，所以询问action文件），找到调用的action类。
7.ActionProxy创建一个ActionInvocation实例，通过代理模式调用Action。
8.action执行完毕后，返回一个result字符串，此时再按相反的顺序通过Intercepter拦截器。
9.最后ActionInvocation实例，负责根据struts.xml中配置result元素，找到与之相对应的result，决定进一步输出。
spring-persist.xml加载问题在persist层和logic层测试的时候，我们是手动加载spring-persist.xml文件。那么，在ui层，spring-perisist.xml文件的加载流程是怎样的呢？在web.xml中，可以通过&lt;context-param&gt;指定Spring配置文件，如果没有这个标签，则默认加载WEB-INF下的applicationContext.xml，也可以用它指定其他配置文件。
前端前端使用BootStrap+AngularJs，其中BootStrap负责界面显示，AngularJs则是沟通前后端的桥梁。
这个部分比较复杂，给个例子，讲的很好。http://www.runoob.com/angularjs/angularjs-application.html
效果演示
后记这个图书管理系统，使用的技术，很多郝同学也是一知半解。接下来，会有一篇文章，专门针对这个项目进行改进。全部代码自取https://github.com/voidking/bookmanage.git
参考文档spring的applicationContext.xml如何自动加载http://blog.csdn.net/fuqingtian/article/details/5545860
Spring controllerhttp://my.oschina.net/hcliu/blog/396887
Struts2注解配置之@Namespace(四)http://blog.csdn.net/spyjava/article/details/13764757
Struts2注解使用说明http://blog.csdn.net/wk313753744/article/details/19920195
Struts2的注解功能详解http://my.oschina.net/victorHomePage/blog/56732http://www.cnblogs.com/wayne_wang/archive/1942927.html
Struts2 - 常用的constant总结http://www.cnblogs.com/HD/p/3653930.html
Struts2 常用的常量配置http://www.cnblogs.com/yokoboy/archive/2877145.html
struts2.0中struts.xml配置文件详解http://www.cnblogs.com/kay/archive/976120.html
Web.xml详解http://www.cnblogs.com/konbluesky/articles/1925295.html
web.xml详细介绍http://mianhuaman.iteye.com/blog/1105522
struts2工作流程http://huaxia524151.iteye.com/blog/1430148
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>maven</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>Django开发简单Blog系统——上</title>
    <url>/dev-django-blog-0/</url>
    <content><![CDATA[前言承接《Django入门》，本文参照慕课网《django入门与实践》课程，开发一个简单的博客系统。按照国际惯例，我们先学习一下django的基础知识。


模板引擎Django默认使用DTL（Django Template Language）作为模板引擎，如果想要修改为其他模板引擎，直接在djsite/djsite/settings.py中修改TEMPLATES即可。详情可以参考The Django template language: for Python programmers。
first template1、在blog目录下创建templates目录。
2、在templates目录中创建index.html文件。
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    first template!&lt;/body&gt;&lt;/html&gt;

3、修改blog/urls.py为：
from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^$', views.index, name='index'),    url(r'helloworld', views.hello, name='hello')]

4、在views.py中添加方法：
def index(request):    return render(request, 'index.html')

5、测试访问启动django，访问 http://localhost:8000/blog/ ，即可看到渲染好的页面。
DTL1、修改index方法为：
def index(request):    return render(request, 'index.html',&#123;'title': 'DTL'&#125;)

2、修改index.html为：
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;Index&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;    &lt;p&gt;first template!&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;

3、测试访问启动django，访问 http://localhost:8000/blog/ ，即可看到渲染好的页面。

不同应用下的templates目录会发生冲突，django按照INSTALLED_APP中的顺序查找templates。为了解决这个问题，我们需要在templates目录中加一层目录，以应用名为名。而模板，都放到这一层目录中。

4、在templates目录下，新建blog文件夹，把index.html移动到blog文件夹中。同时，修改index函数为：
def index(request):    return render(request, 'blog/index.html',&#123;'title': 'DTL'&#125;)

增删查改django默认使用db.sqlite3数据库，我们暂时不进行修改。
Model1、在blog/models.py中添加一个类Article：
class Article(models.Model):    title = models.CharField(max_length=32, default='Title')    content = models.TextField(null=True)    # 参数 auto_now=True 表示自动添加隐藏的时间    pub_time = models.DateTimeField(null=True, auto_now=True)    def __str__(self):        return self.title

关于属性的配置，参考Model field reference。
2、生成数据表python manage.py makemigrations blog，创建model，生成的文件在blog/migrations目录下
python manage.py migrate，根据model生成数据库表
3、查看sql语句python manage.py sqlmigrate blog 0001
4、下载安装SQLite Expert Personal，双击db.sqlite3文件即可查看编辑数据库。
5、使用SQLiteExpert，在blog_article表中添加数据。
查找数据1、在blog/views.py中添加方法：
from . import modelsdef list(request):    articles = models.Article.objects.all()    article = models.Article.objects.get(pk=1)    return render(request, 'blog/list.html',&#123;'articles':articles,'article':article&#125;)

2、在migrations/blog中添加list.html文件
&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;title&gt;List&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;第一篇文章&lt;/h2&gt;    &lt;h3&gt;标题：&#123;&#123;article.title&#125;&#125;&lt;/h3&gt;    &lt;p&gt;内容&#123;&#123;article.content&#125;&#125;&lt;/p&gt;    &lt;hr&gt;    &lt;h2&gt;文章列表&lt;/h2&gt;    &lt;table&gt;        &lt;thead&gt;            &lt;th&gt;标题&lt;/th&gt;            &lt;th&gt;内容&lt;/th&gt;        &lt;/thead&gt;        &lt;tbody&gt;            &#123;% for article in articles %&#125;            &lt;tr&gt;                &lt;td&gt;&#123;&#123;article.title&#125;&#125;&lt;/td&gt;                &lt;td&gt;&#123;&#123;article.content&#125;&#125;&lt;/td&gt;            &lt;/tr&gt;            &#123;% endfor %&#125;        &lt;/tbody&gt;    &lt;/table&gt;&lt;/body&gt;&lt;/html&gt;

3、修改blog/urls.py为：
from django.conf.urls import urlfrom . import viewsurlpatterns = [    url(r'^$', views.index, name='index'),    url(r'^index$', views.index, name='index'),    url(r'^helloworld$', views.hello, name='hello'),    url(r'^list$',views.list, name='list')]

4、测试访问访问地址 http://localhost:8000/blog/list ，即可看到渲染后的效果。
增加数据1、在blog/urls.py中添加：
url(r'^add$',views.add, name='add'),

2、在blog/views.py中添加方法：
import jsondef add(request):    title = request.GET.get('title', 'defaultTitle')    content = request.GET.get('content', 'defaultContent')    article = models.Article.objects.create(title=title, content=content)    result = &#123;'code': 0, 'ext': 'success', 'article_id': article.id&#125;    return HttpResponse(json.dumps(result,ensure_ascii=False))

3、测试访问访问地址 http://localhost:8000/blog/add?title=test&amp;content=test ，即可看到添加成功的提示。
修改数据1、在blog/urls.py中添加：
url(r'^edit$',views.edit, name='edit'),

2、在blog/views.py中添加方法：
def edit(request):    article_id = request.GET.get('id', 0)    title = request.GET.get('title', 'defaultTitle')    content = request.GET.get('content', 'defaultContent')    article = models.Article.objects.get(pk=article_id)    article.title = title    article.content = content    article.save()    result = &#123;'code': 0, 'ext': 'success', 'article_id': article.id&#125;    return HttpResponse(json.dumps(result,ensure_ascii=False))

3、测试访问访问地址 http://localhost:8000/blog/edit?id=1&amp;title=test&amp;content=test222 ，即可看到修改成功的提示。
PS：修改数据和增加数据可以合成为一个接口，例如：
def edit(request):    article_id = request.GET.get('id', '0')    title = request.GET.get('title', 'defaultTitle')    content = request.GET.get('content', 'defaultContent')    if article_id == '0':        article = models.Article.objects.create(title=title, content=content)        result = &#123;'code': 0, 'ext': 'success', 'article_id': article.id&#125;        return HttpResponse(json.dumps(result,ensure_ascii=False))    article = models.Article.objects.get(pk=article_id)    article.title = title    article.content = content    article.save()    result = &#123;'code': 0, 'ext': 'success', 'article_id': article.id&#125;    return HttpResponse(json.dumps(result,ensure_ascii=False))

删除数据1、在blog/urls.py中添加：
url(r'^delete$',views.delete, name='delete'),

2、在blog/views.py中添加方法：
def delete(request):    article_id = request.GET.get('id', 0)    models.Article.objects.get(pk=article_id).delete()    result = &#123;'code': 0, 'ext': 'success'&#125;    return HttpResponse(json.dumps(result,ensure_ascii=False))

3、测试访问访问地址 http://localhost:8000/blog/delete?id=1 ，即可看到删除成功的提示。
Model转JSON
要想最终得到一个json数据，前提是我们要拥有一个dict，所以Model转JSON问题就归结为怎样组装出一个dict。

示例一：在add方法中，我们返回的结果是json格式。如果想要把article（Model）也放进结果中，该怎么处理？参考Python JSON和django的model对象转化成dict，修改代码如下：
from django.forms.models import model_to_dictdef add(request):    title = request.GET.get('title', 'defaultTitle')    content = request.GET.get('content', 'defaultContent')    article = models.Article.objects.create(title=title, content=content)    article = model_to_dict(article)    result = &#123;'code': 0, 'ext': 'success','article': article&#125;    return HttpResponse(json.dumps(result,ensure_ascii=False))

示例二：如果想要把articles（Models）也放进结果中，该怎么处理？参考django 返回json数据。首先，把Models序列化为json格式数据；然后，使用json.loads转换为dict格式数据；最后，把转换后的dict和其他dict格式数据组装到一起。
from django.core import serializersdef add(request):    title = request.GET.get('title', 'defaultTitle')    content = request.GET.get('content', 'defaultContent')    article = models.Article.objects.create(title=title, content=content)    article = model_to_dict(article)    articles = models.Article.objects.all()    json_data = serializers.serialize("json", articles)    dict_data = json.loads(json_data)    result = &#123;        'code': 0,        'ext': 'success',        'article': article,        'articles': dict_data&#125;    return HttpResponse(json.dumps(result, ensure_ascii=False))

sqlite清空表命令delete from &#39;blog_article&#39;;update sqlite_sequence set seq = 0 where name = &#39;blog_article&#39;;
POST问题修改add方法为：
def add(request):    title = request.POST.get('title', 'defaultTitle')    content = request.POST.get('content', 'defaultContent')    article = models.Article.objects.create(title=title, content=content)    article = model_to_dict(article)    articles = models.Article.objects.all()    json_data = serializers.serialize("json", articles)    dict_data = json.loads(json_data)    result = &#123;        'code': 0,        'ext': 'success',        'article': article,        'articles': dict_data&#125;    return HttpResponse(json.dumps(result, ensure_ascii=False))

使用postman发送post请求时遇到如下错误：
CSRF verification failed. Request aborted.

解决办法，使用csrf_exempt装饰器：
from django.views.decorators.csrf import csrf_exempt@csrf_exemptdef add(request):    title = request.POST.get('title', 'defaultTitle')    content = request.POST.get('content', 'defaultContent')    article = models.Article.objects.create(title=title, content=content)    article = model_to_dict(article)    articles = models.Article.objects.all()    json_data = serializers.serialize("json", articles)    dict_data = json.loads(json_data)    result = &#123;        'code': 0,        'ext': 'success',        'article': article,        'articles': dict_data&#125;    return HttpResponse(json.dumps(result, ensure_ascii=False))

时间处理修改时区查看db.sqlite3数据库，可以看到通过接口添加的数据时间不对。参考django时间的时区问题，修改settings.py：
USE_TZ = TrueTIME_ZONE = 'Asia/Shanghai'

设置了USE_TZ=True，则存储到数据库中的时间永远是UTC时间。设置了TIME_ZONE = ‘Asia/Shanghai’，能保证证模板时间的正确显示。
这时如果TIME_ZONE = ‘UTC’，用datetime.datetime.now()获取时间，django会把这个时间当成UTC时间存储到数据库中去。如果修改设置为TIME_ZONE = ‘Asia/Shanghai’，用datetime.datetime.now()获取时间，django会把这个时间当成Asia/Shanghai时间，即东八区时间，然后django会把这个时间转成带时区UTC时间存储到数据库中去，而读的时候直接按UTC时间读出来，这就是很多人遇到的存储到数据库中的时间比本地时间会小8个小时的原因。
如果要获取当前时区时间，则使用django.utils.timezone.now()。
Model参考django：DateTimeField如何自动设置为当前时间并且能被修改，我们来修改一下blog/models.py。
创建django的model时，有DateTimeField、DateField和TimeField三种类型可以用来创建日期字段，其值分别对应着datetime()、date()、time()三中对象。这三个field有着相同的参数auto_now和auto_now_add，表面上看起来很easy，但实际使用中很容易出错，下面是一些注意点。
DateTimeField.auto_now
这个参数的默认值为false，设置为true时，能够在保存该字段时，将其值设置为当前时间，并且每次修改model，都会自动更新。因此这个参数在需要存储“最后修改时间”的场景下，十分方便。需要注意的是，设置该参数为true时，并不简单地意味着字段的默认值为当前时间，而是指字段会被“强制”更新到当前时间，你无法程序中手动为字段赋值；如果使用django再带的admin管理器，那么该字段在admin中是只读的。
DateTimeField.auto_now_add
这个参数的默认值也为False，设置为True时，会在model对象第一次被创建时，将字段的值设置为创建时的时间，以后修改对象时，字段的值不会再更新。该属性通常被用在存储“创建时间”的场景下。与auto_now类似，auto_now_add也具有强制性，一旦被设置为True，就无法在程序中手动为字段赋值，在admin中字段也会成为只读的。
如何将创建时间设置为“默认当前”并且可修改
那么问题来了。实际场景中，往往既希望在对象的创建时间默认被设置为当前值，又希望能在日后修改它。怎么实现这种需求呢？
django中所有的model字段都拥有一个default参数，用来给字段设置默认值。可以用default=timezone.now来替换auto_now=True或auto_now_add=True。timezone.now对应着django.utils.timezone.now()，因此需要写成类似下面的形式：
from django.db import modelsimport django.utils.timezone as timezoneclass Article(models.Model):    title = models.CharField(max_length=32, default='Title')    content = models.TextField(null=True)    pub_time = models.DateTimeField('发布日期', default=timezone.now)    def __str__(self):        return self.title

DateEncoder经过上面的修改，时间是可以修改了，但是同时引入了另外一个问题，在add接口中，json.dumps()函数会报错：
TypeError: Object of type 'datetime' is not JSON serializable

这是因为json.dumps()函数无法解析datetime格式的数据。问题来了，auto_now=True时，json.dumps()却可以解析，莫非此时不是datetime格式？且不管它，我们先解决datetime转json问题。
import json  import datetimeclass DateEncoder(json.JSONEncoder):    def default(self, obj):        if isinstance(obj, datetime.datetime):            return obj.strftime('%Y-%m-%d %H:%M:%S')        elif isinstance(obj, date):            return obj.strftime('%Y-%m-%d')        else:            return json.JSONEncoder.default(self, obj)

在使用json.dumps()函数时，添加cls参数：
json.dumps(result, cls=DateEncoder, ensure_ascii=False)

页面渲染设置好时区后，在页面渲染时，会自动转化成当前时区时间，例如Nov. 29, 2017, 1:49 p.m.
但是，这种格式不符合我们的阅读习惯，我们可以在渲染时改成自己喜欢的格式：
&#123;&#123;article.pub_time|date:"Y-m-d H:i:s"&#125;&#125;

此时，输出到页面的格式就变成了2017-11-29 13:49:44
json UTC处理以add接口为例，从数据库中查询出的数据时间是UTC格式的，例如2017-11-29T05:49:44.092Z
思路一：直接返回UTC格式数据给前端，前端来完成格式化，参考js格式化json传来的UTC格式的时间，或者使用支持UTC格式化的模板引擎。
思路二：参考遍历QuerySet，给每一个pub_time转换格式：
import datetimeimport timedef utc2local(utc_st):    # UTC时间转本地时间（+8:00）    now_stamp = time.time()    local_time = datetime.datetime.fromtimestamp(now_stamp)    utc_time = datetime.datetime.utcfromtimestamp(now_stamp)    offset = local_time - utc_time    local_st = utc_st + offset    return local_st

for item in articles:    # print(item.pub_time)    local_time = utc2local(item.pub_time)    # UTC_FORMAT = "%Y-%m-%dT%H:%M:%S.%fZ"    LOCAL_FORMAT = "%Y-%m-%d %H:%M:%S"    # print(local_time.strftime(LOCAL_FORMAT))    local_time_str = local_time.strftime(LOCAL_FORMAT)    item.pub_time = datetime.datetime.strptime(local_time_str, LOCAL_FORMAT)

这种方法返回的时间，格式为2017-11-29T13:49:44，还是有问题，多了个T。我们为什么不把local_time_str赋值给item.pub_time呢？因为item.put_time限制数据类型为datetime。
思路三：存储时，直接存储字符串格式的时间。修改blog/models.py如下：
from django.db import models# Create your models here.class Article(models.Model):    title = models.CharField(max_length=32, default='Title')    content = models.TextField(null=True)    # pub_time = models.DateTimeField('发布日期', default=timezone.now)    pub_time = models.CharField(max_length=64, default='')    def __str__(self):        return self.title

修改add和edit接口为：
import jsonfrom django.forms.models import model_to_dictfrom django.views.decorators.csrf import csrf_exemptimport datetimeimport timefrom django.utils import timezone@csrf_exemptdef add(request):    title = request.POST.get('title', 'defaultTitle')    content = request.POST.get('content', 'defaultContent')        pub_time = utc2local(timezone.now())    LOCAL_FORMAT = "%Y-%m-%d %H:%M:%S"    pub_time = pub_time.strftime(LOCAL_FORMAT)    article = models.Article.objects.create(title=title, content=content, pub_time=pub_time)    article = model_to_dict(article)    result = &#123;        'code': 0,        'ext': 'success',        'article': article&#125;    return HttpResponse(json.dumps(result, ensure_ascii=False))@csrf_exemptdef edit(request):    article_id = request.POST.get('id', 0)    title = request.POST.get('title', 'defaultTitle')    content = request.POST.get('content', 'defaultContent')    pub_time = utc2local(timezone.now())    LOCAL_FORMAT = "%Y-%m-%d %H:%M:%S"    pub_time = pub_time.strftime(LOCAL_FORMAT)    article = models.Article.objects.get(pk=article_id)    article.title = title    article.content = content    article.pub_time = pub_time    article.save()    article = model_to_dict(article)    result = &#123;        'code': 0,        'ext': 'success',        'article': article&#125;    return HttpResponse(json.dumps(result, ensure_ascii=False))def utc2local(utc_st):    # UTC时间转本地时间（+8:00）    now_stamp = time.time()    local_time = datetime.datetime.fromtimestamp(now_stamp)    utc_time = datetime.datetime.utcfromtimestamp(now_stamp)    offset = local_time - utc_time    local_st = utc_st + offset    return local_st

源码分享https://github.com/voidking/djsite/releases/tag/v0.1.0
小结至此，涉猎了django开发blog所需要的基本知识。下文中，将会在实战中学习django更高级的用法。
书签django入门与实践
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
        <category>django</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>django</tag>
      </tags>
  </entry>
  <entry>
    <title>英中机器文本翻译-第1章</title>
    <url>/dev-en-to-zh-translation-1/</url>
    <content><![CDATA[UCloudUCloud是基础云计算服务提供商，与全球AI挑战赛合作，给参赛者提供免费使用GPU的时间。本以为和阿里云类似，新建个主机，搭建环境，然后跑代码。没想到平台限制不能创建主机，只能使用AI训练服务。很麻烦的样子，花点时间研究下。


环境准备
阿里云centos7.2
python2.7.5（默认安装版本）
ucloud实名认证通过

Uhub1、登录ucloud，左侧导航栏点击公共镜像库，进入uhub产品页面。
2、创建镜像库（Docker Registry），郝同学这里命名为vk_ucloud。
3、docker登录uhubdocker login uhub.ucloud.cn
UAI Train工具包UAI-Train为用户提供了镜像打包工具，用户只需将所需代码文件放在某一路径下，执行打包命令即可以生成UAI-Train所需的镜像。该打包工具将在本地docker中生成两个镜像以及运行镜像的指令说明文件uaitrain_cmd.txt。生成的镜像包括cpu和gpu两个版本，其中gpu版本的镜像会自动上传至用户的Uhub镜像仓库。两个版本的镜像均可以用于本地测试，测试命令可在uaitrain_cmd.txt中查询。
UIA Train基础镜像UCloud 提供了两个UAI Train系统使用的基础镜像（范例基于tensorflow-1.1.0版本，如果想要使用 tensorflow-1.2.0，可以直接将 1.1.0 替换成1.2.0）
1、下载gpu版本docker pull uhub.ucloud.cn/uaishare/gpu_uaitrain_ubuntu-14.04_python-2.7.6_tensorflow-1.1.0:v1.0
2、下载cpu版本docker pull uhub.ucloud.cn/uaishare/cpu_uaitrain_ubuntu-14.04_python-2.7.6_tensorflow-1.1.0:v1.0
UAI SDK安装最新版本的UAI SDK和docker支持，安装UAI SDK的方法如下：
git clone https://github.com/ucloud/uai-sdkcd uai-sdksudo python setup.py install
安装Docker的方法请参见：Docker使用指南
工具目录找到UAI-Train TensorFlow操作工具所在目录
$ls ~/uai-sdk/uaitrain_tool/tftf_tool.py

统一路径将AI训练任务所需的代码放在统一路径下，打包时将其相对路径作为参数code_path上传
例如，我们要将~/uai-sdk/examples/tensorflow/train/mnist_summary_1.1下面的训练代码进行打包，该文件路径结构如下：
$ cd ~/uai-sdk/examples/tensorflow/train/mnist_summary_1.1$ lsdata  code
我们需要做如下准备工作：
1、准备好训练的代码，案例中训练代码在mnist_summary_1.1/code下，名为mnist_summary.py
2、将tf_tool.py 工具放入和训练代码目录同级的目录下，即mnist_summary_1.1/ 目录下
cd uai-sdkcp ./uaitrain_tool/tf/tf_tool.py ./examples/tensorflow/train/mnist_summary_1.1/

3、Ready To Pack
打包1、进入mnist_summary_1.1目录
cd ~/uai-sdk/examples/tensorflow/train/mnist_summary_1.1/

2、打包命令
sudo python tf_tool.py pack [-h] --public_key PUBLIC_KEY                         --private_key PRIVATE_KEY                         [--project_id PROJECT_ID]                         --code_path CODE_PATH                         --mainfile_path MAINFILE_PATH                        --uhub_username UHUB_USERNAME                        --uhub_password UHUB_PASSWORD                         --uhub_registry UHUB_REGISTRY                        --uhub_imagename UHUB_IMAGENAME                        [--uhub_imagetag UHUB_IMAGETAG]                        [--internal_uhub False/True]                        --ai_arch_v AI_ARCH_V                        --test_data_path TEST_DATA_PATH                        --test_output_path TEST_OUTPUT_PATH                        --train_params TRAIN_PARAMS                        [--python_version PYTHON_VERSION]                        [--os OS_VERSION]

每个参数的具体解释，访问TensorFlow训练镜像打包查看。
3、打包样例使用mnist_summary_1.1中的训练程序为案例。test_data_path和test_data_path不要求一定在训练代码路径下，如我们可以在/data/test目录下创建了两个子目录：

/data/test/data 用于存放训练数据，此时test_data_path值为/data/test/data
/data/test/output 用于存放训练输出数据，此时test_output_path为/data/test/output

train_params为训练代码中使用到的任意训练参数，本例中为”–max_step=2000”使用命令时，需要使用sudo，保证docker镜像打包命令有足够权限。
注：我们可以将~/uai-sdk/examples/tensorflow/train/mnist_summary_1.1/data/下的测试数据放入/data/test/data/目录下。
sudo python tf_tool.py pack \                        --public_key=&lt;YOUR_PUBLIC_KEY&gt; \            --private_key=&lt;YOUR_PRIVATE_KEY&gt; \            --code_path=./code/ \            --mainfile_path=mnist_summary.py \            --uhub_username=&lt;YOUR_UHUB_USER_NAME&gt; \            --uhub_password=&lt;YOUR_UHUB_PASSWORD&gt; \            --uhub_registry=&lt;YOUR_UHUB_REFDISTRY&gt; \            --uhub_imagename=&lt;YOUR_UHUB_IMAGENAME&gt; \                        --internal_uhub=True \            --ai_arch_v=tensorflow-1.1.0 \            --test_data_path=/data/test/data \            --test_output_path=/data/test/output \            --train_params="--max_step=2000" \


UCloud API的公钥和私钥，可以在左上角“产品与服务”，“API密钥 UAPI”中找到。
uhub_username和uhub_password是UCloud的账号和密码。
uhub_registry填入vk_ucloud。
ubub_imagename填入mnist_test。

具体命令为：
mkdir -p /data/test/datacp -r ~/uai-sdk/examples/tensorflow/train/mnist_summary_1.1/data/ /data/test/cd ~/uai-sdk/examples/tensorflow/train/mnist_summary_1.1

sudo python tf_tool.py pack --public_key=****** --private_key=****** --code_path=./code/ --mainfile_path=mnist_summary.py --uhub_username=voidking@qq.com --uhub_password=****** --uhub_registry=vk_ucloud --uhub_imagename=mnist_test --internal_uhub=True --ai_arch_v=tensorflow-1.1.0 --test_data_path=/data/test/data --test_output_path=/data/test/output --train_params="--max_step=2000"

如果执行上诉命令时报错：
Docker login on uhub.service.ucloud.cnError response from daemon: Get https://uhub.service.ucloud.cn/v2/: x509: certificate has expired or is not yet valid

那么请删除掉--internal_uhub=True这一句，因为我们没有使用UCloud内网，而是使用的阿里云。切记，是删除，而不是改成--internal_uhub=False。这是解决错误失败，请教UCloud客服才得到的结论。在此感谢下客服小哥，很耐心帮忙排查问题。
输出说明成功执行后，界面显示样例如下，会给出部署时所需的CMD命令以及本地测试的cmd命令:
CMD Used for deploying: /data/mnist_summary.py --max_step=2000CMD for CPU local test: sudo docker run -it -v /data/test/data:/data/data -v /data/test/output:/data/output mnist_test-cpu:uaitrain /bin/bash -c "cd /data &amp;&amp; /usr/bin/python /data/mnist_summary.py --max_step=2000 --work_dir=/data --data_dir=/data/data --output_dir=/data/output --log_dir=/data/output"CMD for GPU local test: sudo nvidia-docker run -it -v /data/test/data:/data/data -v /data/test/output:/data/output uhub.ucloud.cn/vk_ucloud/mnist_test:uaitrain /bin/bash -c "cd /data &amp;&amp; /usr/bin/python /data/mnist_summary.py --max_step=2000 --num_gpus=1 --work_dir=/data --data_dir=/data/data --output_dir=/data/output --log_dir=/data/output"You can check these cmd later in file: uaitrain_cmd.txt


CMD Used for deploying: 该输出的内容为创建训练任务时，训练启动命令框中需要填写的内容(参见创建训练任务)。可以直接复制黏贴到命令框中。
CMD for CPU local test: 该输出的内容为本地通过CPU来测试训练能否正常执行。在本地没有GPU的情况下可以使用该命令测试训练代码能否正常执行。
CMD for GPU local test：该输出的内容为本地通过GPU来测试训练能否正常执行。在本地有GPU的情况下可以使用该命令测试训练代码能否正常执行。（注：在使用前请确认GPU驱动已经安装，并已经安装了nvidia-docker，详细安装方法请参见Docker使用指南）

本地文件夹下生成了uaitrain_cmd.txt、uaiservice.log、uaitrain-cpu.Dockerfile和uaitrain.Dockerfile，其中uaitrain_cmd.txt内容和标准输出的内容一致，防止用户丢失屏幕输出内容。
docker images，在本地镜像仓库可以看到生成了两个docker镜像，分别为cpu版本和gpu版本。如下：
uhub.ucloud.cn/vk_ucloud/mnist_testmnist_test-cpu

其中gpu版本，会自动上传的到ucloud的uhub。
自定义软件包安装如果训练代码依赖特殊的软件包，例如nltk 等，可以通过Docker 打包的形式将软件包和相关数据打包入训练的Docker镜像，详细方法参见TensorFlow 训练镜像自定义包安装。
UFile创建存储空间1、登录ucloud，左侧导航栏点击对象存储，进入ufile产品页面。
2、创建存储空间，郝同学这里存储空间域名为vk-ucloud，空间类型为公有空间。创建成功会提示：我们为您同步创建了CDN加速域名，稍后您可在列表查看域名信息并进行文件访问操作。接下来您可通过以下三种方式进行空间内容管理，包括文件上传下载等。API/SDK，详细使用说明；客户端管理工具，详细使用说明。
3、之后的文件上传等操作，可以直接在网页完成，也可以使用ucloud提供的空间管理器和文件管理器。
准备管理器1、下载空间管理器和文件管理器
mkdir -p /opt/ufilecd /opt/ufilewget http://tools.ufile.ucloud.com.cn/bucketmgr-linux64.tar.gzwget http://tools.ufile.ucloud.com.cn/filemgr-linux64.tar.gztar -xzvf bucketmgr-linux64.tar.gz tar -xzvf filemgr-linux64.tar.gzrm -rf bucketmgr-linux64.tar.gzrm -rf filemgr-linux64.tar.gzmv bucketmgr_linux64.elf/* ./ mv filemgr-linux64.elf/* ./rm -rf bucketmgr_linux64.elfrm -rf filemgr-linux64.elfmv bucketmgr-linux64 bucketmgrmv filemgr-linux64 filemgr

2、配置vim config.cfg
&#123;    "public_key" : "paste your public key here",    "private_key" : "paste your private key here",    "proxy_host" : "www.cn-bj.ufileos.com",    "api_host" : "api.spark.ucloud.cn"&#125;

其中，public_key和private_key可以在“API密钥”中获得。不同地域的proxy_host是不一样的，具体如下:
北京外网：www.cn-bj.ufileos.com B机房内网：www.ufile.cn-north-02.ucloud.cnC机房内网: www.ufile.cn-north-03.ucloud.cnD机房内网: www.ufile.cn-north-04.ucloud.cn上海二外网: www.cn-sh2.ufileos.com内网: www.internal-cn-sh2-01.ufileos.com香港外网：www.hk.ufileos.com内网：www.internal-hk-01.ufileos.com广东外网：www.cn-gd.ufileos.com内网：www.internal-cn-gd-02.ufileos.com美国外网：www.us-ca.ufileos.com内网：www.internal-us-ca-01.ufileos.com

空间管理命令创建存储空间创建存储空间建议使用控制台。./bucketmgr --action CreateBucket --bucket bucketname --type public
参数说明:–bucket: 需要创建的存储空间域名–type: 需要创建的空间类型，公开空间（public）或私有空间（private）
删除存储空间删除存储空间建议使用控制台。
./bucketmgr --action DeleteBucket --bucket bucketname
参数说明:–bucket: 需要删除的存储空间域名
获取空间信息./bucketmgr --action DescribeBucket参数说明:–bucket: 需要查询的存储空间域名
获取文件列表./bucketmgr --action GetFileList --bucket bucketname参数说明:–bucket: 需要拉取列表的存储空间域名–offset: 查询起始的文件编号（默认为0）–limit : 需要查询的记录数（默认为100）
文件管理器文件管理工具可帮助用户进行存储空间内文件的管理操作，包括：

上传单个文件：普通上传（PUT），秒传（UPLOAD-HIT），分片上传（MPUT），表单方式上传。

上传文件夹：普通上传（PUT），分片上传（MPUT），增量上传（SYNC）。

下载文件/文件夹

删除文件/文件夹


上传文件(单个文件)./filemgr --action put --bucket bucketname --key key --file filename
参数说明:–bucket: 需要上传至的存储空间–key : 上传至存储空间中的文件名–file : 需要上传的本地文件路径
示例:把一个本地文件 ucloud.jpg 上传至 bucket 名称为 pics 的存储空间中，并命名为 logo.jpg
./filemgr --action put --bucket pics --key logo.jpg --file /home/yours/pictures/ucloud.jpg
上传文件夹./filemgr --action put --bucket bucketname --dir dirname
参数说明:–bucket: 需要上传至的存储空间域名–dir : 需要上传的本地文件夹–prefix: 生成文件的Key时使用的前缀，指定该参数时生成的Key是 prefix+base（filename）

用文件夹方式上传的文件默认会使用文件夹内文件所在的绝对路径来命名Key，如果想指定特殊的前缀请使用–prefix参数。

示例1:
将 ~/files 这个文件夹下的所有文件上传至名为 demobucket 的存储空间中，并且 key 的名称使用 demo/ 作为前缀，如果该文件夹下有一个名为1.jpg 的文件并且空间属性为public，则上传完成后可以通过 http://demobucket.ufile.ucloud.com.cn/demo/1.jpg 访问该文件
./filemgr --action put --dir ~/files --bucket demobucket --prefix demo/
如果您不希望使用绝对路径来作为Key，可以使用–trimpath截掉部分路径名。
例如：./filemgr --action put --dir ~/files --bucket demobucket --prefix demo/ --trimpath /root/test
示例2:假设有个目录名为 /some/dir/cutoff/files/，下面有 a.jpg、b.txt两个文件，则以下的处理会使得保存在 UFILE 的文件名为 files/a.jpg、files/b.txt。./filemgr --action put --dir ~/files --bucket demobucket --trimpath /some/dir/cutoff/
分片上传分片上传允许在某个分片失败情况下进行续传，适合较大文件的场景。
./filemgr --action mput --bucket demobucket --key key --file filename
参数说明:–bucket : 需要上传至的 bucket 名称–key : 上传至 bucket 中的文件名称–file : 需要上传的本地文件路径–part : 需要进行重传的分片索引(注意重传的分片必须是之前上传失败的分片，已经成功的分片不能重传，否则最终 finish 会失败)–uploadid: 分片上传初始化返回的上传 ID–etags : 续传时需要把之前已经成功上传的分片的 ETag 以”,”分隔传递给服务端
示例:以分片上传方式上传一个本地文件 hello.avi 至名为 demobucket 的存储空间中并且命名为 world.avi
./filemgr --action mput --bucket demobucket --key world.avi --file /opt/video/hello.avi
上传失败的话，重新执行命令即可继续上传。
下载文件./filemgr --action download --bucket demobucket --key key --file filename参数说明:–bucket : 需要下载的文件所在的 bucket 名称–key : 需要下载的文件 key 名称–file : 需要保存在本地的文件路径–showurl: 仅获取下载 URL，不下载实际数据–expires: 获取下载 URL 时指定过期时间–queryauth: 在 URL 的 query 中携带签名信息
示例:获取一个名为 demobucket 的存储空间中一个名为 QQ.pkg 的文件在5分钟内的有效下载URL。
./filemgr --action download --showurl --queryauth --expires 300 --bucket demobucket --key QQ.pkg
获取一个名为 demobucket 的存储空间中一个名为 QQ.pkg 的文件并且保存为/opt/data/QQ.pkg./filemgr --action download --bucket demobucket --key QQ.pkg --file /opt/data/QQ.pkg
删除文件./filemgr --action delete --bucket demobucket --key key参数说明:–bucket: 需要删除的文件所在的 bucket 名称–key : 需要删除的文件在 bucket 中的名称
示例:删除一个名为 demobucket 的存储空间中名为 20140201.blog 的文件
./filemgr --action delete --bucket demobucket --key 20140201.blog
秒传文件./filemgr --action upload-hit --bucket demobucket --key key --file filename参数说明:–bucket: 需要上传至的 bucket 名称–key : 上传至 bucket 中的文件名称–file : 需要上传的本地文件路径
示例:尝试秒传本地文件 falcon.avi 至存储空间 nfl2014 命名为 2014-superbow.avi
./filemgr --action upload-hit --bucket demobucket --key 2014-superbow.avi --file falcon.avi
计算文件ETag该选项用于计算使用ufile特殊算法得到的文件哈希值
./filemgr --action etag --file filename参数说明:–file: 需要计算哈希的本地文件路径
示例:计算本地文件 sniff-the-rose.pdf 的 ETag./filemgr --action etag --file /opt/tiger/sniff-the-rose.pdf
增量上传增量上传仅上传新增或有发生修改的整个文件。
./filemgr --action sync --bucket demobucket --dir syncdir [--speedlimit speedlimit] [--prefix prefix] [--excludeptn]
参数说明:–bucket : 需要同步至远端的 bucket 名称–dir    : 需要同步的本地文件夹–speedlimit : 上传限速(byte/s)–prefix : 生成文件的 key 时使用的前缀–excludeptn: 需要排除上传的文件模式，支持 POSIX 正则表达式
示例:把本地文件夹~/go 同步到名为 demobucket 的存储空间中
./filemgr --action sync --bucket demobucket --dir ~/go
继续检查是否还有文件需要更新./filemgr --action sync --bucket demobucket --dir ~/go
上传mnist数据集1、上传mnist数据集./filemgr --action mput --dir /data/test/data --bucket vk-ucloud --prefix mnist/data --trimpath /data/test/data
2、查看上传的文件
./bucketmgr --action GetFileList --bucket vk-ucloud例如，看到的文件为：
&#123;    BucketName:   vk-ucloud    Key:          mnist/data/t10k-images-idx3-ubyte.gz    Hash:         AQAAAMOiWvH1La1_cmzOjKyxOGVLdg1I@session_0ade634b-8be9-4537-8f73-b900155aae20    MimeType:     application/x-gzip    Size:         1648877    Created:      1508560491    Modified:     1508560491&#125;

那么，CDN加速地址为：http://vk-ucloud.ufile.ucloud.com.cn/mnist/data/t10k-images-idx3-ubyte.gz ，源站地址为： http://vk-ucloud.cn-bj.ufileos.com/mnist/data/t10k-images-idx3-ubyte.gz
AI训练服务配置1、访问UCloud控制台，在左侧导航栏中找到AI训练服务，然后点击“创建AI训练任务”。
2、按照提示，填入需要的信息。UCloud API的公钥和私钥，可以在左上角“产品与服务”，“API密钥 UAPI”中找到。代码镜像库选择用户镜像库，镜像选择我们自己创建的mnist_test:uaitrain。数据输入路径为：http://vk-ucloud.cn-bj.ufileos.com/mnist/data/数据输出路径为：http://vk-ucloud.cn-bj.ufileos.com/mnist/output/训练时长为：6
3、点击右侧确定，创建任务完成。
4、选中任务，点击开始，即可开始训练。点击详情，可以查看到训练过程中的日志。点击tenserboard，看到训练过程中的精度变化等。
5、在tensorboard看到精度到达1后，即可停止训练。这时，http://vk-ucloud.cn-bj.ufileos.com/mnist/output/ 文件夹下，会出现训练结果。
可以使用命令行查看，也可以在web面板查看。
书签全球AI挑战赛-英中机器文本翻译
谷歌开放GNMT教程：如何使用TensorFlow构建自己的神经机器翻译系统
UCloud文档中心
全球AI挑战赛UCloud参考资料
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>机器学习</tag>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>JSP demo设计</title>
    <url>/dev-jsp-demo/</url>
    <content><![CDATA[需求分析既然是留言系统，肯定要有用户登录，所有需要一个用户表（user）。字段包括：id、username和password。其中id设为自动增长的int型，并设为主键。username和password都设为varchar型。登录成功后要有个主界面，显示别人和自己的留言信息，那就应该有个留言表（message）。字段包括：id、userid、date、title、content。其中id设为自动增长的int型，并设为主键。userid是user表中的id，表明该条留言是该用户留的。date表示发布留言的时间，datetime型。title表示发布留言的标题，varchar型。content表示发布的内容，varchar型。
创建数据库和表使用MySQL，scott用户。创建数据库“jsp”，创建表user、message。

user表结构


字段名称
数据类型
主键
自增
允许为空
描述



id
int
是
增1

ID号


username
varchar(20)



用户名


password
varchar(20)



密码


message表结构


字段名称
数据类型
主键
自增
允许为空
描述



id
int
是
增1

ID号


userid
int



用户ID号


date
datetime



发布时间


title
varchar(20)



标题


content
varchar(500)



留言内容


MySQL命令记录root用户登录
mysql -u root -pgrant all privileges on *.* to scott@'localhost';flush privileges;exit
scott用户登录
create database jsp;show databases;use jsp;create table user(id int,username varchar(20),password varchar(20));create table message(id int,userid int ,date datetime,title varchar(20),content varchar(500));alter table user modify int id primary key auto_increment;alter table message modify id int primary key auto_increment;alter table message add constraint fk_id foreign key(userid) references user(id);desc user;desc message;

创建项目使用eclipse，新建Dynamic Web Project，命名为“jsp”。
创建表对应的JavaBean新建包com.voidking.jsp.model，然后建立表对应的标准JavaBean：User和Message。
package com.voidking.jsp.model;public class User &#123;	//Fields	private Integer id;	private String username;	private String password;		//Property accessors	//属性 id 的 get/set 方法	public Integer getId()&#123;		return this.id;	&#125;	public void setId(Integer id)&#123;		this.id=id;	&#125;	//属性 username 的 get/set 方法	public String getUsername()&#123;		return this.username;	&#125;	public void setUsername(String username)&#123;		this.username=username;	&#125;	//属性 password 的 get/set 方法	public String getPassword()&#123;		return this.password;	&#125;	public void setPassword(String password)&#123;		this.password=password;	&#125;&#125;

package com.voidking.jsp.model;import java.sql.Date;public class Message &#123;	//Fields	private Integer id;	private Integer userid;	private Date date;	private String title;	private String content;		//Property accessors	//属性 id 的 get/set 方法	public Integer getId()&#123;		return this.id;			&#125;	public void setId(Integer id)&#123;		this.id=id;	&#125;	//属性 userId 的 get/set 方法	public Integer getUserid()&#123;		return this.userid;	&#125;	public void setUserid(Integer userid)&#123;		this.userid=userid;	&#125;	//属性 date 的 get/set 方法	public Date getDate()&#123;		return this.date;	&#125;	public void setDate(Date date)&#123;		this.date=date;	&#125;	//属性 title 的 get/set 方法	public String getTitle()&#123;		return this.title;	&#125;	public void setTitle(String title)&#123;		this.title=title;	&#125;	//属性 content 的 get/set 方法	public String getContent()&#123;		return this.content;	&#125;	public void setContent(String content)&#123;		this.content=content;	&#125;&#125;
创建登录页面在WebContent中新建login.jsp，代码如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;简易留言板&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="#E3E3E3"&gt;&lt;form action="mainServlet" method="post"&gt;&lt;table&gt;	&lt;caption&gt;用户登录&lt;/caption&gt;	&lt;tr&gt;		&lt;td&gt;			用户名：&lt;input type="text" name="username" size="20"/&gt;		&lt;/td&gt;	&lt;/tr&gt;	&lt;tr&gt;		&lt;td&gt;			密&amp;nbsp;&amp;nbsp;码：&lt;input type="password" name="password" size="21"/&gt;		&lt;/td&gt;	&lt;/tr&gt;	&lt;tr&gt;		&lt;td&gt;			&lt;input type="submit" value="登录"/&gt;			&lt;input type="reset" value="重置"/&gt;		&lt;/td&gt;	&lt;/tr&gt;&lt;/table&gt;&lt;/form&gt;如果没注册单击&lt;a href="register.jsp"&gt;这里&lt;/a&gt;注册！&lt;/body&gt;&lt;/html&gt;
创建DB类新建包com.voidking.jsp.db，新建类DB，代码如下：
package com.voidking.jsp.db;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.util.ArrayList;import com.voidking.jsp.model.Message;import com.voidking.jsp.model.User;public class DB &#123;	Connection ct;	PreparedStatement pstmt;		public DB()	&#123;		try &#123;			Class.forName("com.mysql.jdbc.Driver");			ct=DriverManager.getConnection("jdbc:mysql://localhost/jsp","scott","tiger");		&#125; catch (Exception e) &#123;			e.printStackTrace();		&#125;			&#125;		public User checkUser(String username,String password)	&#123;		try &#123;			pstmt = ct.prepareStatement("select * from user where username=? and password=?");			pstmt.setString(1, username);			pstmt.setString(2, password);						ResultSet rs=pstmt.executeQuery();			User user = new User();			while (rs.next()) &#123;				user.setId(rs.getInt(1));				user.setUsername(rs.getString(2));				user.setPassword(rs.getString(3));				return user;							&#125;		&#125; catch (Exception e) &#123;			e.printStackTrace();		&#125;		return null;		&#125;		public ArrayList findMessage()	&#123;				try &#123;			ArrayList al = new ArrayList();			pstmt= ct.prepareStatement("select * from message");			ResultSet rs = pstmt.executeQuery();			while(rs.next())			&#123;				Message message = new Message();				message.setId(rs.getInt(1));				message.setUserid(rs.getInt(2));				message.setDate(rs.getDate(3));				message.setTitle(rs.getString(4));				message.setContent(rs.getString(5));				al.add(message);							&#125;			return al;		&#125; catch (Exception e) &#123;			e.printStackTrace();		&#125;		return null;				&#125;		public String getUsername(int id)	&#123;		String username = null;		try &#123;			pstmt = ct.prepareStatement("select username from user where id=?");			pstmt.setInt(1,id);			ResultSet rs = pstmt.executeQuery();			while(rs.next())			&#123;				username = rs.getString(1);										&#125;			return username;		&#125; catch (Exception e) &#123;			e.printStackTrace();		&#125;		return username;			&#125;		public boolean addMessage(Message message)	&#123;		try &#123;			pstmt= ct.prepareStatement("insert into message(userid,date,title,content) values(?,?,?,?)");			pstmt.setInt(1, message.getUserid());			pstmt.setDate(2,message.getDate());			pstmt.setString(3, message.getTitle());			pstmt.setString(4, message.getContent());						pstmt.executeUpdate();			return true;		&#125; catch (Exception e) &#123;			e.printStackTrace();		&#125;				return false;				&#125;			public boolean insertUser(String username,String password)	&#123;		try &#123;			pstmt = ct.prepareStatement("insert into user(username,password) values(?,?)");			pstmt.setString(1, username);			pstmt.setString(2, password);			pstmt.executeUpdate();			return true;		&#125; catch (Exception e) &#123;			e.printStackTrace();		&#125;		return false;					&#125;&#125;
创建MainServlet类新建包com.voidking.jsp.servlet，新建类MainServlet，代码如下：
package com.voidking.jsp.servlet;import java.io.IOException;import java.util.ArrayList;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import com.voidking.jsp.db.DB;import com.voidking.jsp.model.Message;import com.voidking.jsp.model.User;public class MainServlet extends HttpServlet &#123;	public void doGet(HttpServletRequest request, HttpServletResponse response)			throws ServletException, IOException &#123;		request.setCharacterEncoding("utf8");		response.setContentType("utf8");		String username = request.getParameter("username");		String password = request.getParameter("password");		DB db = new DB();		HttpSession session = request.getSession();		User user = (User) session.getAttribute("user");		if (user == null) &#123;			user = db.checkUser(username, password);		&#125;		session.setAttribute("user", user);		if (user != null) &#123;			ArrayList al = db.findMessage();			session.setAttribute("al", al);			response.sendRedirect("main.jsp");		&#125; else &#123;			response.sendRedirect("login.jsp");		&#125;	&#125;	public void doPost(HttpServletRequest request, HttpServletResponse response)			throws ServletException, IOException &#123;		doGet(request, response);	&#125;&#125;

创建mian.jsp在WebContent中新建main.jsp，代码如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@ page import="com.voidking.jsp.model.Message" %&gt;&lt;%@ page import="com.voidking.jsp.model.User" %&gt;&lt;%@ page import="com.voidking.jsp.db.DB"%&gt;&lt;%@page import="java.util.Iterator"%&gt;&lt;%@page import="java.util.ArrayList"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;留言板信息&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="#E3E3E3"&gt;&lt;% User user = (User)session.getAttribute("user");	%&gt;	当前用户为：&lt;%=user.getUsername() %&gt;	&lt;form action="liuyan.jsp" method="post"&gt;		&lt;table border="1"&gt;			&lt;caption&gt;所有留言信息&lt;/caption&gt;			&lt;tr&gt;				&lt;th&gt;留言人姓名&lt;/th&gt;&lt;th&gt;留言时间&lt;/th&gt;&lt;th&gt;留言标题&lt;/th&gt;&lt;th&gt;留言内容&lt;/th&gt;			&lt;/tr&gt;		&lt;%			ArrayList al = (ArrayList)session.getAttribute("al");				if(al != null)			&#123;				Iterator iter = al.iterator();				while(iter.hasNext())				&#123;					Message message=(Message)iter.next();		%&gt;									&lt;tr&gt;				&lt;td&gt;&lt;%=new DB().getUsername(message.getUserid())%&gt;&lt;/td&gt;				&lt;td&gt;&lt;%=message.getDate().toString()%&gt;&lt;/td&gt;				&lt;td&gt;&lt;%=message.getTitle()%&gt;&lt;/td&gt;				&lt;td&gt;&lt;%=message.getContent()%&gt;&lt;/td&gt;			&lt;/tr&gt;		&lt;%				&#125;			&#125;		%&gt;		&lt;/table&gt;		&lt;input type="submit" value="留言"/&gt;	&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
创建liuyan.jsp在WebContent中新建liuyan.jsp，内容如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;留言板&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="#E3E3E3"&gt;	&lt;center&gt;		&lt;form action = "addServlet" method="post"&gt;			&lt;table border="1"&gt;				&lt;caption&gt;填写留言信息&lt;/caption&gt;				&lt;tr&gt;					&lt;td&gt;留言标题&lt;/td&gt;					&lt;td&gt;&lt;input type="text" name="title"/&gt;&lt;/td&gt;				&lt;/tr&gt;				&lt;tr&gt;					&lt;td&gt;留言内容&lt;/td&gt;					&lt;td&gt;&lt;textarea rows="5" cols="35" name="content"&gt;&lt;/textarea&gt;&lt;/td&gt;				&lt;/tr&gt;			&lt;/table&gt;			&lt;input type="submit" value="提交"/&gt;			&lt;input type="reset" value="重置" /&gt;		&lt;/form&gt;		&lt;/center&gt;&lt;/body&gt;&lt;/html&gt;
创建AddServlet类在包com.voidking.jsp.servlet中，新建类AddServlet，内容如下：
package com.voidking.jsp.servlet;import java.io.IOException;import java.sql.Date;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.voidking.jsp.db.DB;import com.voidking.jsp.model.Message;import com.voidking.jsp.model.User;public class AddServlet extends HttpServlet &#123;	public void doGet(HttpServletRequest request, HttpServletResponse response)			throws ServletException, IOException &#123;		request.setCharacterEncoding("utf8");		response.setCharacterEncoding("utf8");		String title = request.getParameter("title");		String content = request.getParameter("content");		User user = (User) request.getSession().getAttribute("user");		Message message = new Message();		message.setUserid(user.getId());		message.setDate(new Date(System.currentTimeMillis()));		message.setTitle(title);		message.setContent(content);		if (new DB().addMessage(message)) &#123;			response.sendRedirect("success.jsp");		&#125;	&#125;	public void doPost(HttpServletRequest request, HttpServletResponse response)			throws ServletException, IOException &#123;		doGet(request, response);	&#125;&#125;
创建成功页面在WebContent中新建success.jsp，内容如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;留言成功&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="#E3E3E3"&gt;	留言成功，单击&lt;a href="mainServlet"&gt;这里&lt;/a&gt;返回主界面。&lt;/body&gt;&lt;/html&gt;
配置web.xml在WebContent中新建web.xml，内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app version="2.5" 	xmlns="http://java.sun.com/xml/ns/javaee" 	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee 	http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"&gt;  &lt;display-name&gt;&lt;/display-name&gt;	  &lt;welcome-file-list&gt;    &lt;welcome-file&gt;login.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;    &lt;servlet&gt;  	&lt;servlet-name&gt;mainServlet&lt;/servlet-name&gt;  	&lt;servlet-class&gt;com.voidking.jsp.servlet.MainServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;  	&lt;servlet-name&gt;mainServlet&lt;/servlet-name&gt;  	&lt;url-pattern&gt;/mainServlet&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;    &lt;servlet&gt;  	&lt;servlet-name&gt;addServlet&lt;/servlet-name&gt;  	&lt;servlet-class&gt;com.voidking.jsp.servlet.AddServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;  	&lt;servlet-name&gt;addServlet&lt;/servlet-name&gt;  	&lt;url-pattern&gt;/addServlet&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;    &lt;servlet&gt;  	&lt;servlet-name&gt;registerServlet&lt;/servlet-name&gt;  	&lt;servlet-class&gt;com.voidking.jsp.servlet.RegisterServlet&lt;/servlet-class&gt;  &lt;/servlet&gt;    &lt;servlet-mapping&gt;  	&lt;servlet-name&gt;registerServlet&lt;/servlet-name&gt;  	&lt;url-pattern&gt;/registerServlet&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;&lt;/web-app&gt;

创建注册页面在WebContent中新建register.jsp，代码如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;用户注册&lt;/title&gt;&lt;/head&gt;&lt;body bgcolor="#E3E3E3"&gt;	&lt;form action="registerServlet" method="post"&gt;		&lt;table&gt;			&lt;caption&gt;用户注册&lt;/caption&gt;			&lt;tr&gt;				&lt;td&gt;登录名&lt;/td&gt;				&lt;td&gt;&lt;input type="text" name="username"/&gt;&lt;/td&gt;			&lt;/tr&gt;			&lt;tr&gt;				&lt;td&gt;密码：&lt;/td&gt;				&lt;td&gt;&lt;input type="password" name="password"/&gt;&lt;/td&gt;			&lt;/tr&gt;		&lt;/table&gt;		&lt;input type="submit" value="注册" /&gt;		&lt;input type="reset" value="重置"/&gt;	&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
创建RegisterServlet类在包com.voidking.jsp.servlet下，新建类RegisterServlet，内容如下：
package com.voidking.jsp.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.voidking.jsp.db.DB;public class RegisterServlet extends HttpServlet &#123;	public void doGet(HttpServletRequest request, HttpServletResponse response)			throws ServletException, IOException &#123;		request.setCharacterEncoding("utf8");		response.setCharacterEncoding("utf8");		String username = request.getParameter("username");		String password = request.getParameter("password");		if (new DB().insertUser(username, password)) &#123;			response.sendRedirect("login.jsp");		&#125;	&#125;	public void doPost(HttpServletRequest request, HttpServletResponse response)			throws ServletException, IOException &#123;		doGet(request, response);	&#125;&#125;
部署和运行拷贝mysql-connector-java-*-bin.jar到WebContent/WEB-INF/lib。发布工程，启动Tomcat服务器，访问地址：http://localhost:8080/jsp/login.jsp
编码问题经过调试修改，登录、注册、留言，功能正常。但是，查看留言时，中文留言在界面上显示问号。在数据库中查询，也显示问号，那么问题出在哪里呢？
查看MySQL默认编码status;show variables like 'character%';
发现结果如下：



Variable_name
Value



character_set_client
gbk


character_set_connection
gbk


character_set_database
latin1


character_set_filesystem
binary


character_set_results
gbk


character_set_server
latin1


character_set_system
utf8


character_sets_dir
d:\server\xampp\mysql\share\charsets\


推测是数据库编码问题，全部修改成utf8应该就可以了。



修改无效1、由于我的MySQL是XAMPP的一部分，比较精简，所以在bin文件夹下没有MySQLInstanceConfig.exe。没有办法利用这个工具重新配置。
2、修改配置文件。在my.ini中添加：
[mysqld]default-character-set=utf8character_set_server=utf8init_connect='SET NAMES utf8'
重启MySQL，完全没有效果，靠！
3、通过命令配置
//create database jsp character set utf8;alter database jsp character set utf8;//在没有table的情况下，此命令才有效。set names utf8;
经过测试，还是显示乱码。查看编码如下：



Variable_name
Value



character_set_client
utf8


character_set_connection
utf8


character_set_database
utf8


character_set_filesystem
binary


character_set_results
utf8


character_set_server
latin1


character_set_system
utf8


character_sets_dir
d:\server\xampp\mysql\share\charsets\


看来character_set_server的值是重点啊！



重装备份数据库。复制D:\Server\xampp\mysql\data路径下的数据库文件夹以及ibdata1文件，待会放到新的MySQL的data目录下。
卸载MySQL，使用绿色版安装，提示服务已存在，无法安装。最终，使用了windows安装版。注意，配置数据库的时候，一定要选择utf8编码。安装成功，拷贝数据库文件到新的data下，结果，MySQL无法启动。推测是因为新安装的32位，而原数据库是64位。
没办法，重新建立用户，重新建立数据库和表。经过测试，可以正常显示中文！重装治百病，很有道理！
源代码分享https://github.com/voidking/jsp.git
小结书上给的代码有几处错误，修改了之后，才最终跑起来。书本，确实只是用来参考就够了。编程能力是写出来的！在一行行敲代码的过程中，会遇到很多问题，而解决这些问题的过程，培养出来的，就是编程能力！
参考文档《Java EE基础实用教程》，郑阿奇主编mysql添加外键：http://www.cnblogs.com/xiangxiaodong/archive/3061049.html
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>jsp</tag>
      </tags>
  </entry>
  <entry>
    <title>Jupyter notebook</title>
    <url>/dev-jupyter-notebook/</url>
    <content><![CDATA[前言本文转载自优达学城《机器学习工程师》
Jupyter notebook 是 Web 文档，能让你将文本、图像和代码全部组合到一个文档中。它已经成为数据分析的标准环境。notebook 源自 2011 年的 IPython 项目，之后迅速流行起来。


Jupyter notebook 是什么？欢迎学习本课，即如何使用 Jupyter notebook。notebook 是一种 Web 应用，能让用户将说明文本、数学方程、代码和可视化内容全部组合到一个易于共享的文档中。例如，不久前我共享了我最爱的 notebook 之一，它分析了 LIGO 实验探测到的两个碰撞的黑洞所发出的引力波。你可以下载数据，运行 notebook 中的代码，重复整个分析，实际上等于你自己探测引力波！
Notebook 已迅速成为处理数据的必备工具。其已知用途包括数据清理和探索、可视化、机器学习和大数据分析。我为我的个人博客创建了一个 notebook 示例，它展示了 notebook 的许多特点。这项工作通常在终端中完成，也即使用普通的 Python shell 或 IPython 完成。可视化在单独的窗口中进行，而文字资料以及各种函数和类脚本包含在独立的文档中。但是，notebook 能将这一切集中到一处，让用户一目了然。
GitHub 上面也会自动提供 notebook。借助此出色的功能，你可以轻松共享工作。http://nbviewer.jupyter.org/ 也会提供 GitHub 代码库中的 notebook 或存储在其他地方的 notebook。
文学化编程notebook 是 Donald Knuth 在 1984 年提出的文学化编程的一种形式。在文学化编程中，直接在代码旁写出叙述性文档，而不是另外编写单独的文档。用 Donald Knuth 的话来说：

让我们集中精力向人们解释我们希望计算机做什么，而不是设想我们的主要任务是指示计算机做什么。

归根到底，代码是写给人而不是计算机看的。notebook 恰恰提供了这种能力。你能够直接在代码旁写出叙述性文档。这不仅对阅读 notebook 的人很有用，而且对你将来回头分析代码也很有用。
说点题外话：最近，文学化编程这个概念已经发展成为一门完整的编程语言，即 Eve。
notebook 如何工作Jupyter notebook 源自 Fernando Perez 发起的 IPython 项目。IPython 是一种交互式 shell，与普通的 Python shell 相似，但具有一些很好的功能（例如语法高亮显示和代码补全）。最初，notebook 的工作方式是，将来自 Web 应用（你在浏览器中看到的 notebook）的消息发送给 IPython 内核（在后台运行的 IPython 应用程序）。内核执行代码，然后将代码发送回 notebook。当前架构与之相似，具体见下图（摘自Jupyter文档）。中心点是 notebook 服务器。你通过浏览器连接到该服务器，而 notebook 呈现为 Web 应用。你在 Web 应用中编写的代码通过该服务器发送给内核。内核运行代码并将代码发送回该服务器，之后，任何输出都会返回到浏览器中。保存 notebook 时，它作为 JSON 文件（文件扩展名为 .ipynb）写入到该服务器中。
此架构的一个优点是，内核无需运行 Python。由于 notebook 和内核分开，因此可以在两者之间发送任何语言的代码。例如，早期的两个非 Python 内核分别用于 R 语言和 Julia 语言。使用 R 内核时，用 R 编写的代码将发送给执行该代码的 R 内核，这与在 Python 内核上运行 Python 代码完全一样。IPython notebook 已被改名，因为 notebook 变得与编程语言无关。新的名称 Jupyter 由 Julia、Python 和 R 组合而成。如果有兴趣，不妨看看可用内核的列表。
另一个优点是，可以在任何地方运行服务器，并且可通过互联网访问服务器。通常，你会在存储所有数据和 notebook 文件的自有计算机上运行服务器。但是，你也可以在远程计算机或云实例（如 Amazon 的 EC2）上设置服务器。之后，可以在全球任何地方通过浏览器访问 notebook。
安装 Jupyter notebook到目前为止，安装 Jupyter 的最简单方法是使用 Anaconda。该发行版自动附带了 Jupyter notebook。你能够在默认环境下使用 notebook。
要在 conda 环境中安装 Jupyter notebook，请使用 conda install jupyter notebook。
也可以通过 pip 使用 pip install jupyter notebook 来获得 Jupyter notebook。
安装多版本内核1、查看已安装内核jupyter kernelspec list
2、安装内核假设默认环境是python2.7，那么切换到python3.6环境下，然后安装内核
activate py3conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --set show_channel_urls yesconda install ipykernel

3、把内核添加到jupyter
activate py3python -m ipykernel install

可以添加命令 --name kernelname 为kernel指定名字。
4、删除内核jupyter kernelspec remove kernelname
启动 notebook 服务器要启动 notebook 服务器，请在终端或控制台中输入 jupyter notebook。服务器会在你运行此命令的目录中启动。这意味着任何 notebook 文件都会保存在该目录中。你通常希望在 notebook 所在的目录中启动服务器。不过，你可以在文件系统中导航到 notebook 所在的位置。
运行此命令时（请自己试一下！），服务器主页会在浏览器中打开。默认情况下，notebook 服务器的运行地址是 http://localhost:8888。如果你不熟悉该地址，其含义是：localhost 表示你的计算机，而 8888 是服务器的通信端口。只要服务器仍在运行，你随时都能通过在浏览器中输入 http://localhost:8888 返回到服务器。
如果启动其他服务器，新服务器会尝试使用端口 8888，但由于此端口已被占用，因此新服务器会在端口 8889 上运行。之后，可以通过 http://localhost:8889 连接到新服务器。每台额外的 notebook 服务器都会像这样增大端口号。
如果你尝试启动自己的服务器，它应类似以下所示：
你可能会看到上面列表中的一些文件和文件夹，具体取决于你在哪里启动服务器。
在右侧，你可以点击“New”（新建），创建新的 notebook、文本文件、文件夹或终端。“Notebooks”下的列表显示了你已安装的内核。由于我在 Python 3 环境中运行服务器，因此列出了 Python 3 内核。你在这里看到的可能是 Python 2。我还安装了用于 Scala 2.10 和 2.11 的内核，因此它们出现在列表中。
如果在 conda 环境中运行 Jupyter notebook 服务器，则你还能选择任何其他环境中的内核（见下图）。要创建新的 notebook，请点击你要使用的内核。
顶部的选项卡是 Files（文件）、Running（运行）和 Cluster（聚类）。Files（文件）显示当前目录中的所有文件和文件夹。点击 Running（运行）选项卡会列出所有正在运行的 notebook。可以在该选项卡中管理这些 notebook。
过去，在 Clusters（聚类）中创建多个用于并行计算的内核。现在，这项工作已经由 ipyparallel 接管，因此该选项卡如今用处不多。
如果在 conda 环境中运行 notebook 服务器，则你还能访问以下所示的“Conda”选项卡。可以通过该选项卡管理 Jupyter 中的环境。你可以执行多种操作，例如创建新的环境、安装包、更新包、导出环境。
快速启动 notebook启动jupyter notebook时，每次都要切换文件路径，需要输入相关的命令，相对来说比较麻烦，有一个可以快速启动的小技巧。
在想要打开的目录下，创建一个 ipy.bat 文件，用记事本打开这个文件，输入如下内容并保存。
jupyter notebookpause
双击这个 ipy.bat 文件，就可以快速启动jupyter notebook，把这个 ipy.bat文件以快捷方式发送到桌面，启动很方便。
关闭 Jupyter通过在服务器主页上选中 notebook 旁边的复选框，然后点击“Shutdown”（关闭），你可以关闭各个 notebook。但是，在这样做之前，请确保你保存了工作！否则，在你上次保存后所做的任何更改都会丢失。下次运行 notebook 时，你还需要重新运行代码。通过在终端中按两次 Ctrl + C，可以关闭整个服务器。再次提醒，这会立即关闭所有运行中的 notebook，因此，请确保你保存了工作！
notebook 界面创建新的 notebook 时，你会看到如下所示的界面：请随意尝试和四处浏览一下。
你会看到外框为绿色的一个小方框。它称为单元格。单元格是你编写和运行代码的地方。你也可以更改其类型，以呈现 Markdown（一种常用于编写 Web 内容的格式化语法）。我会在后面更详细地介绍 Markdown。在工具栏中点击“Code”，将其改为 Markdown，然后改回来。小型的播放按钮用于运行单元格，而向上和向下的箭头用于上下移动单元格。运行代码单元格时，单元格下方会显示输出。单元格还会被编号（左侧会显示 In [1]:）。这能让你知道运行的代码和运行顺序（如果运行了多个单元格的话）。在 Markdown 模式下运行单元格会将 Markdown 呈现为文本。
工具栏从左侧开始，工具栏上的其他控件是：

落伍的软盘符号，表示“保存”。请记得保存 notebook！

按钮用于创建新的单元格


然后是用于剪切、复制和粘贴单元格的按钮。
运行、停止、重新启动内核
单元格类型：代码、Markdown、原始文本和标题
命令面板（见下文）
单元格工具栏，提供不同的单元格选项（例如将单元格用作幻灯片）

命令面板小键盘符号代表命令面板。点击它会弹出一个带有搜索栏的面板，供你搜索不同的命令。这能切实帮助你加快工作速度，因为你无需使用鼠标翻查各个菜单。你只需打开命令面板，然后键入要执行的操作。例如，如果要合并两个单元格：
更多事项顶部显示了标题。点击它可以将 notebook 重命名。
右侧是内核类型（在我的例子中是 Python 3），旁边是一个小圆形。在内核运行单元格时，会填充这个小圆形。对于大多数快速运行的操作，并不会填充它。它是一个小型指示器，让你知道实际运行的代码会运行较长时间。
工具栏包含了保存按钮，此外，notebook 也会定期自动保存。标题右侧会注明最近一次的保存。可以使用保存按钮手动进行保存，也可以按键盘上的 Esc，然后按 s。按 Esc 键会变为命令模式，而 s 是“保存”的快捷键。我会在后面介绍命令模式和快捷键。
在“File”（文件）菜单中，可以下载多种格式的 notebook。通常，你会希望将它作为 HTML 文件下载，以便与不使用 Jupyter 的其他人共享。也可以将 notebook 作为普通的 Python 文件下载，此时所有代码都会像平常一样运行。要在博客或文档中使用 notebook，Markdown 和 reST 格式很合适。
代码单元格notebook 中的大部分工作均在代码单元格中完成。这是编写和执行代码的地方。在代码单元格中可以执行多种操作，例如编写任何代码、给变量赋值、定义函数和类、导入包。在一个单元格中执行的任何代码在所有其他单元格中均可用。
我创建了一个 notebook，你可以将它当作练习来完成。请在下面下载此 notebook (Working With Code Cells)，然后从你自己的 notebook 服务器运行它。（在你的终端中，转到包含此 notebook 文件的目录，然后输入 jupyter notebook）浏览器可能会尝试不下载就打开此 notebook 文件。如果是这样，请右击链接并选择“链接另存为…”。
辅助材料：Working With Code Cells
Markdown 单元格如前所述，单元格也可用于以 Markdown 编写的文本。Markdown 是格式化语法，可让你加入链接、将文本样式设为粗体或斜体和设置代码格式。像代码单元格一样，按 Shift + Enter 或 Ctrl + Enter 可运行 Markdown 单元格，这会将 Markdown 呈现为格式化文本。加入文本可让你直接在代码旁写出叙述性文档，以及为代码和代码中的思路编写文档。
你可以在此处查找文档，但我会提供简短的入门文档。
标题要编写标题，可在文本前放置井号，即 #（英文读作 pound、hash 或 octothorpe）。一个 # 呈现为 h1 标题，两个 # 是 h2 标题，依此类推。类似以下所示：
# Header 1## Header 2### Header 3

链接要在 Markdown 中添加链接，请在文本两侧加上方括号，并在 URL 两侧加上圆括号，例如：[Udacity&#39;s home page](https://www.udacity.com) 表示指向 Udacity’s home page的链接。
强调效果可以使用星号或下划线（* 或 _）来表示粗体或斜体，从而添加强调效果。对于斜体，在文本两侧加上一个星号或下划线，例如 _gelato_ 或 *gelato* 会呈现为 gelato。
粗体文本使用两个符号，例如 **aardvark** 或 __aardvark__ 会呈现为 aardvark。
只要在文本两侧使用相同的符号，星号和下划线的作用都一样。
代码可以通过两种不同的方式显示代码，一种是与文本内联，另一种是将代码块与文本分离。要将代码变为内联格式，请在文本两侧加上反撇号。例如，`string.punctuation` 会呈现为 string.punctuation。
要创建代码块，请另起一行并用三个反撇号将文本包起来：或者将代码块的每一行都缩进四个空格。
数学表达式在 Markdown 单元格中，可以使用 LaTeX 符号创建数学表达式。notebook 使用 MathJax 将 LaTeX 符号呈现为数学符号。要启动数学模式，请在 LaTeX 符号两侧加上美元符号（例如 $y = mx + b$），以创建内联的数学表达式。对于数学符号块，请使用两个美元符号：
$$y = \frac&#123;a&#125;&#123;b+c&#125;$$

此功能的确很有用，因此，如果你没有用过 LaTeX，请阅读这篇入门文档，它介绍了如何使用 LaTeX 来创建数学表达式。
小结在编写 Markdown 时，可以参考这个速查指南。我建议使用 Markdown 单元格，与使用一堆代码块相比，这使 notebook 变得更易于阅读。
快捷键notebook 自带一组快捷键，能让你使用键盘与单元格交互，而无需使用鼠标和工具栏。熟悉这些快捷键需要花费一点时间，但如果能熟练掌握，将大大加快你在 notebook 中的工作速度。要详细了解这些快捷键和练习它们的用法，请在下面下载 notebook Keyboard Shortcuts。再次提醒，浏览器可能会尝试打开它，但请将它保存到计算机中。请右击链接并选择“链接另存为…”。辅助材料：Keyboard Shortcuts
Magic 关键字Magic 关键字是可以在单元格中运行的特殊命令，能让你控制 notebook 本身或执行系统调用（例如更改目录）。例如，可以使用 %matplotlib 将 matplotlib 设置为以交互方式在 notebook 中工作。
Magic 命令的前面带有一个或两个百分号（% 或 %%），分别对应行 Magic 命令和单元格 Magic 命令。行 Magic 命令仅应用于编写 Magic 命令时所在的行，而单元格 Magic 命令应用于整个单元格。
注意：这些 Magic 关键字是特定于普通 Python 内核的关键字。如果使用其他内核，这些关键字很有可能无效。
代码计时有时候，你可能要花些精力优化代码，让代码运行得更快。在此优化过程中，必须对代码的运行速度进行计时。可以使用 Magic 命令 timeit 测算函数的运行时间，如下所示：
如果要测算整个单元格的运行时间，请使用 %%timeit，如下所示：

在 notebook 中嵌入可视化内容如前所述，notebook 允许你将图像与文本和代码一起嵌入。这在你使用 matplotlib 或其他绘图包创建可视化内容时最为有用。可以使用 %matplotlib 将 matplotlib 设置为以交互方式在 notebook 中工作。默认情况下，图形呈现在各自的窗口中。但是，可以向命令传递参数，以选择特定的“后端”（呈现图像的软件）。要直接在 notebook 中呈现图形，应将内联后端与命令 %matplotlib inline 一起使用。

提示：在分辨率较高的屏幕（例如 Retina 显示屏）上，notebook 中的默认图像可能会显得模糊。可以在 %matplotlib inline 之后使用 %config InlineBackend.figure_format = &#39;retina&#39; 来呈现分辨率较高的图像。


在 notebook 中进行调试对于 Python 内核，可以使用 Magic 命令 %pdb开启交互式调试器。出错时，你能检查当前命名空间中的变量。
在上图中，可以看到我尝试对字符串求和，这造成了错误。调试器指出了该错误，并提示你检查代码。
要详细了解 pdb，请阅读此文档。要退出调试器，在提示符中输入 q 即可。
补充读物Magic 命令还有很多，我只是介绍了你将会用得最多的一些命令。要了解更多信息，请查看此列表，它列出了所有可用的 Magic 命令。
转换 notebookNotebook 只是扩展名为 .ipynb 的大型 JSON 文件。
由于 notebook 是 JSON 文件，因此，可以轻松将其转换为其他格式。Jupyter 附带了一个名为 nbconvert 的实用程序，可将 notebook 转换为 HTML、Markdown、幻灯片等格式。
例如，要将 notebook 转换为 HTML 文件，请在终端中使用jupyter nbconvert --to html notebook.ipynb
要将 notebook 与不使用 notebook 的其他人共享，转换为 HTML 很有用。而要在博客和其他接受 Markdown 格式化的文本编辑器中加入 notebook，Markdown 很合适。
像平常一样，要详细了解 nbconvert，请阅读相关文档。
创建幻灯片通过 notebook 创建幻灯片是我最爱的功能之一。此处有一个幻灯片示例，它介绍了用于处理数据的 Pandas。
在 notebook 中创建幻灯片的过程像平常一样，但需要指定作为幻灯片的单元格和单元格的幻灯片类型。在菜单栏中，点击“View”（视图）&gt;“Cell Toolbar”（单元格工具栏）&gt;“Slideshow”（幻灯片），以便在每个单元格上弹出幻灯片单元格菜单。
这会在每个单元格上显示一个下拉菜单，让你选择单元格在幻灯片中的显示方式。

Slides（幻灯片）是你从左向右移动的完整幻灯片。按向上或向下的箭头时，Sub-slides（子幻灯片）会出现在幻灯片中。Fragments（片段）最初是隐藏的，在你按下按钮时会出现。选择 Skip（忽略）会忽略幻灯片中的单元格，而选择 Notes（备注）会将单元格保留为演讲者备注。
运行幻灯片要通过 notebook 文件创建幻灯片，需要使用 nbconvert：jupyter nbconvert notebook.ipynb --to slides
这只是将 notebook 转换为幻灯片必需的文件，你需要向其提供 HTTP 服务器才能真正看到演示文稿。
要转换它并立即看到它，请使用jupyter nbconvert notebook.ipynb --to slides --post serve这会在浏览器中打开幻灯片，让你可以演示它。
恭喜你！这个简短的课程到此结束，它主要介绍了 Python 数据科学工作流程中的工具。充分利用 Anaconda 和 Jupyter notebook 不仅能提升你的工作效率，还会让你心情更愉快。要想充分发挥它们的作用，你还要学习很多东西（例如 Markdown 和 LaTeX），但很快你就会想知道为何要以其他方式进行数据分析。
再次恭喜你！祝你好运！
书签Jupyter Notebook的27个秘诀，技巧和快捷键
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>jupyter</tag>
        <tag>anaconda</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode刷题记录-排序算法总结</title>
    <url>/dev-leetcode-sort/</url>
    <content><![CDATA[前言排序有内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。
内部排序大致分为五种：交换排序、插入排序、选择排序、归并排序和基数排序。其中交换排序包括冒泡排序和快速排序、插入排序包括直接插入排序和希尔排序，选择排序包括简单选择排序和堆排序。
当n较大时，应采用时间复杂度为O(nlog2n)的排序方法：快速排序、堆排序或归并排序。
快速排序目前是内部排序中最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短。


自拟题目使用冒泡排序、快速排序、直接插入排序、希尔排序、简单选择排序、堆排序、归并排序、基数排序共八种排序方法，给[8,7,4,2,1,3,5,9,0,6]按照升序和降序排序。示例输入：
[8,7,4,2,1,3,5,9,0,6]

示例输出：
[0,1,2,3,4,5,6,7,8,9][9,8,7,6,5,4,3,2,1,0]

冒泡排序冒泡排序重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小（或越大）的元素会经由交换慢慢“浮”到数列的顶端。
以左边为水面，升序冒泡排序算法描述如下：
1、从最后一对相邻的元素开始，比较相邻的元素，如果后一个比前一个小，则调换它们的位置（小的冒泡）。2、对每一对相邻元素作同样的工作，从最后一对到第一对。3、第一个元素固定为最小元素，不参与接下来的比较。4、对越来越少的元素（除了固定元素）重复上面的步骤，直到没有任何一对元素需要比较。

// 冒泡排序public int[] bubble(int[] arr)&#123;    int sum = arr.length;    int temp = 0;    // sum个数，需要sum次冒泡，每次冒泡一个数找到位置    for(int i=0;i&lt;sum;i++)&#123;        for(int j=sum-1;j&gt;i;j--)&#123;            if(arr[j] &lt; arr[j-1])&#123;                temp = arr[j-1];                arr[j-1] = arr[j];                arr[j] = temp;            &#125;        &#125;    &#125;    return arr;&#125;

快速排序快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序，它是对冒泡排序的改进。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。MoreWindows同学把它归结为：挖坑填数+分治法。
升序快速排序算法描述如下：
1、i = L; j = R; 将基准数挖出形成第一个坑a[i]。2、j–由后向前找比基准输小的数，找到后挖出此数填前一个坑a[i]中。3、i++由前向后找比基准数大的数，找到后也挖出此数填到前一个坑a[j]中。4、重复执行2，3步，直到i==j，将基准数填入a[i]中。5、以上，得到两个区，左边的区比基数小，右边的区比基数大。6、对于得到的两个区，分别重复1-4。

// 快速排序public int[] quick(int[] arr,int l,int r)&#123;    int temp = arr[l];    int i = l;    int j = r;    while(i &lt; j)&#123;        while(i &lt; j &amp;&amp; arr[j] &gt;= temp)               j--;         if(i &lt; j)&#123;            arr[i] = arr[j];            i++;        &#125;                while(i &lt; j &amp;&amp; arr[i] &lt; temp)&#123;            i++;        &#125;        if(i &lt; j)&#123;            arr[j] = arr[i];             j--;        &#125;    &#125;    arr[i] = temp;            if(l &lt; r)&#123;        quick(arr, l, i-1);        quick(arr, i+1, r);    &#125;    return arr;    &#125;


直接插入排序插入排序是一种简单直观的排序算法，它的工作原理非常类似于我们抓扑克牌。
升序插入算法描述如下：
1、从第一个元素开始，该元素可以认为已经被排序。2、取出下一个元素，在已排序的元素序列中从后向前扫描。3、如果新元素小于已排序的元素（老元素），将老元素移到下一位置。4、重复步骤3，直到找到新元素大于或等于老元素的位置，将新元素插入到该位置。5、重复步骤2~4。

// 直接插入排序public int[] insertion(int[] arr)&#123;    int sum = arr.length;    for(int i=1;i&lt;sum;i++)&#123;        int temp = arr[i];        int j = i-1;        while(j&gt;=0 &amp;&amp; temp&lt;arr[j])&#123;            arr[j+1] = arr[j];            j--;        &#125;        arr[j+1] = temp;    &#125;    return arr;&#125;


希尔排序希尔排序，也叫递减增量排序，是插入排序的一种更高效的改进版本。希尔排序是不稳定的排序算法。
希尔排序是基于插入排序的以下两点性质而提出改进方法的：

插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位

希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。
假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n^2)的排序（冒泡排序或直接插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。
升序希尔算法描述如下：1、选择增量gap=length/2，把元素分成gap组，每组取值为{i,i+gap,i+2gap,…}。2、分别对每一组中的数据进行从前到后扫描插入排序。3、缩小增量gap = gap/2，这种增量选择可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。4、重复步骤2~3，直到增量gap=1。

// 希尔排序public int[] shell(int[] arr)&#123;    int sum = arr.length;    int gap = sum/2;    while(gap &gt;= 1)&#123;        //分成gap组        for(int i=0;i&lt;gap;i++)&#123;            //组内排序            for(int j=i+gap;j&lt;sum;j += gap)&#123;                int temp = arr[j];                int k = j-gap;                while(k &gt;= 0 &amp;&amp; temp &lt; arr[k])&#123;                    arr[k+gap] = arr[k];                    k = k-gap;                &#125;                arr[k+gap] = temp;            &#125;        &#125;        gap = gap/2;            &#125;    return arr;&#125;


简单选择排序选择排序是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。
注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。
升序简单选择排序描述如下：1、未排序序列中，假设最小元素指针position指向第一个元素i。2、依次对比所有未排序元素，遇到更小的元素，则把position指向更小的元素。3、遍历未排序序列结束，交换position和i的元素，i位置排序完成。4、重复1到3，直到所有位置排序完成。
// 简单选择排序public int[] selection(int[] arr)&#123;    int sum = arr.length;    for(int i=0;i&lt;sum;i++)&#123;        int position = i;        for(int j=i+1;j&lt;sum;j++)&#123;            if(arr[j] &lt; arr[position])&#123;                position = j;            &#125;        &#125;        int tmp = arr[i];        arr[i] = arr[position];        arr[position] = tmp;    &#125;    return arr;&#125;

堆排序堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏、最好，平均时间复杂度均为O(nlogn)，它也是不稳定排序。
堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆；或者每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。
堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。
参照图解排序算法(三)之堆排序，升序堆排序描述如下：1、构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。2、从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点arr.length/2-1），从右至左，从下至上进行调整。3、交换位置后也许子根结构混乱，那么继续调整，直到构造完成大顶堆。4、将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，构造成大顶堆。再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。
// 堆排序public int[] heap(int[] arr)&#123;    int sum = arr.length;    //1.构建大顶堆    for(int i=arr.length/2-1;i&gt;=0;i--)&#123;        //从第一个非叶子结点从下至上，从右至左调整结构        adjustHeap(arr,i,arr.length);    &#125;    //2.调整堆结构+交换堆顶元素与末尾元素    for(int j=arr.length-1;j&gt;0;j--)&#123;        swap(arr,0,j);//将堆顶元素与末尾元素进行交换        adjustHeap(arr,0,j);//重新对堆进行调整    &#125;    return arr;&#125;//调整大顶堆（仅是调整过程，建立在大顶堆已构建的基础上）public void adjustHeap(int []arr,int i,int length)&#123;    int temp = arr[i];//先取出当前元素i    for(int k=i*2+1;k&lt;length;k=k*2+1)&#123;//从i结点的左子结点开始，也就是2i+1处开始        if(k+1&lt;length &amp;&amp; arr[k]&lt;arr[k+1])&#123;//如果左子结点小于右子结点，k指向右子结点            k++;        &#125;        if(arr[k] &gt;temp)&#123;//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）            arr[i] = arr[k];            i = k;        &#125;else&#123;            break;        &#125;    &#125;    arr[i] = temp;//将temp值放到最终的位置&#125;//交换元素public static void swap(int []arr,int a ,int b)&#123;    int temp=arr[a];    arr[a] = arr[b];    arr[b] = temp;&#125;

归并排序归并排序是创建在归并操作上的一种有效的排序算法，效率为O(nlogn)，1945年由冯·诺伊曼首次提出。
归并排序的实现分为递归实现与非递归(迭代)实现。递归实现的归并排序是算法设计中分治策略的典型应用，我们将一个大问题分割成小问题分别解决，然后用所有小问题的答案来解决整个大问题。非递归(迭代)实现的归并排序首先进行是两两归并，然后四四归并，然后是八八归并，一直下去直到归并了整个数组。
归并排序算法主要依赖归并(Merge)操作。归并操作指的是将两个已经排序的序列合并成一个序列的操作，归并操作步骤如下：
1、申请空间，该空间用来存放合并后的序列2、设定两个指针，最初位置分别为两个已经排序序列的起始位置3、比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置4、重复步骤3直到某一指针到达序列尾5、将另一序列剩下的所有元素直接复制到合并序列尾
参照图解排序算法(四)之归并排序，代码如下：
// 归并排序public int[] merge(int[] arr)&#123;    int []temp = new int[arr.length];//在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间    mergeSort(arr,0,arr.length-1,temp);    return arr;&#125;public void mergeSort(int[] arr,int left,int right,int []temp)&#123;    if(left&lt;right)&#123;        int mid = (left+right)/2;        mergeSort(arr,left,mid,temp);//左边归并排序，使得左子序列有序        mergeSort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序        mergeCore(arr,left,mid,right,temp);//将两个有序子数组合并操作    &#125;&#125;public void mergeCore(int[] arr,int left,int mid,int right,int[] temp)&#123;    int i = left;//左序列指针    int j = mid+1;//右序列指针    int t = 0;//临时数组指针    while (i&lt;=mid &amp;&amp; j&lt;=right)&#123;        if(arr[i]&lt;=arr[j])&#123;            temp[t++] = arr[i++];        &#125;else &#123;            temp[t++] = arr[j++];        &#125;    &#125;    while(i&lt;=mid)&#123;//将左边剩余元素填充进temp中        temp[t++] = arr[i++];    &#125;    while(j&lt;=right)&#123;//将右序列剩余元素填充进temp中        temp[t++] = arr[j++];    &#125;    t = 0;    //将temp中的元素全部拷贝到原数组中    while(left &lt;= right)&#123;        arr[left++] = temp[t++];    &#125;&#125;


基数排序基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机上的贡献。它是这样实现的：将所有待比较正整数统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始进行基数为10的计数排序，一直到最高位计数排序完后，数列就变成一个有序序列（利用了计数排序的稳定性）。
基数排序步骤如下：1、初始化：构造一个10*n的二维数组，一个长度为n的数组用于存储每次位排序时每个桶子里有多少个元素。2、循环操作：从低位开始（我们采用LSD的方式），将所有元素对应该位的数字存到相应的桶子里去（对应二维数组的那一列）。然后将所有桶子里的元素按照桶子标号从小到大取出，对于同一个桶子里的元素，先放进去的先取出，后放进去的后取出（保证排序稳定性）。这样原数组就按该位排序完毕了，继续下一位操作，直到最高位排序完成。
参考基数排序详解以及java实现，代码如下：
// 基数排序public int[] radix(int[] arr, int d)&#123;    int n=1;//代表位数对应的数：1,10,100...    int k=0;//保存每一位排序后的结果用于下一位的排序输入    int length=arr.length;    int[][] bucket=new int[10][length];//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里    int[] order=new int[length];//用于保存每个桶里有多少个数字    while(n&lt;d)    &#123;        for(int num:arr) //将数组array里的每个数字放在相应的桶里        &#123;            int digit=(num/n)%10;            bucket[digit][order[digit]]=num;            order[digit]++;        &#125;        for(int i=0;i&lt;length;i++)//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果        &#123;            if(order[i]!=0)//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中            &#123;                for(int j=0;j&lt;order[i];j++)                &#123;                    arr[k]=bucket[i][j];                    k++;                &#125;            &#125;            order[i]=0;//将桶里计数器置0，用于下一次位排序        &#125;        n*=10;        k=0;//将k置0，用于下一轮保存位排序结果    &#125;        return arr;&#125;


源码地址https://github.com/voidking/leetcode/tree/master/src/com/voidking/leetcode/sort
书签常用排序算法总结(一)
常用排序算法总结(二)
八大排序算法
图解排序算法(一)之3种简单排序(选择，冒泡，直接插入)
图解排序算法(二)之希尔排序
]]></content>
      <categories>
        <category>专业</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>算法</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令大全——ABCD</title>
    <url>/dev-linux-command-all-abcd/</url>
    <content><![CDATA[本文摘自《Linux/UNIX指令范例速查手册》。
Aadduser
adduser: add user，新建系统上的账号

adduser -D，显示新建账号时的默认值。
adduser -m jos，新建名为jos的账号（使用系统默认值）。
adduser位于/usr/sbin/之下，是/usr/sbin/useradd的连接。也就是说，adduser和useradd实际上是同一个命令。


alias
alias: alias，定义命令及参数的别名

alias，列出现有的别名设置。
alias ua=&#39;uname -a&#39;，将uname -a的别名设置为ua。
alias的优先级高于path（系统搜寻的路径）。
apachectl
apachectl: apache controller，管理Apache网页服务器

apachectl -l，列出编入apache的模块。
apachectl restart，重启apache。
apt-get
apt-get: advanced package tool get，APT软件包管理工具。

apt-get install mailx，安装mailx软件包。
apt-get是Linux发行商Debian与Ubuntu上的软件包管理工具，其他版本Linux无法使用。
ar
ar: archives，打包和解压缩文件

ar -rv afile a*，将以a开头的文件打包为afile文件。
ar -t afile，列出打包文件中的成员文件。
ar -p afile anaconda-ks.cfg，显示打包文件中某一文件的内容。
ar命令已被tar所取代，目前已很少使用。
arch
arch: architecture，列出处理器的类型

arch，列出处理器的类型。
arp
arp: address resolution protocol，网卡地址的对应

arp，列出arp的信息。
arp -s 10.1.1.10 00:0F:26:2A:BF:77，将10.1.1.10强制对应到网卡号00:0F:26:2A:BF:77。
arp -d 10.1.1.10，删除IP地址与网卡号的对应。
arping
arping: ARP ping，网卡地址的测试命令

arping 172.20.11.1，对172.20.11.1的IP地址进行网卡地址测试。
若不在同一个网络，arping不会有回应，这时需要用ping命令。
at
at: at，在指定的时间运行命令

at 5pm + 3 days /bin/ls，三天后的下午 5 点执行 /bin/ls。　　at 5pm + 3 weeks /bin/ls，三个星期后的下午 5 点执行 /bin/ls。　　at 17:20 tomorrow /bin/date，明天的 17:20 执行 /bin/date。　　at 23:59 12/31/1999 echo the end of world !，在1999年的最后一天的最后一分钟印出 the end of world !  
at -l，列出将要运行的工作。
at -c 1，显示工作编号为1的工作。
at -d 1，删除编号为1的工作。
awk
awk: Alfred Aho, Peter Weinberger, and Brian Kernighan(作者名)，文字数据的高级处理。

awk &#39;{print}&#39; /etc/passwd，显示/etc/passwd中内容，和cat命令结果相同。
awk -F&quot;:&quot; &#39;{print $1 $3 $6}&#39; /etc/passwd，将/etc/passwd中的内容以冒号分隔，并取出第1位、第3位和第6位。
awk -F&quot;:&quot; &#39;{print $1 &quot;\t&quot; $3 &quot;\t&quot; $6}&#39; /etc/passwd，将/etc/passwd中的内容以冒号分隔，并取出第1位、第3位和第6位，并用Tab作为字段间的分隔符。
awk -F&quot;:&quot; &#39;{print &quot;ID=&quot; $1 &quot;\t 家目录=&quot; $6}&#39; /etc/passwd，将/etc/passwd中的内容以冒号分隔，并取出第1位和第6位，并用Tab作为字段间的分隔符，在第1位前加上“ID=”，第6位前加上“家目录=”。

Bbadblocks
badblocks: bad blocks，检查硬盘中损坏的区块

badblocks -v /dev/sda1，检查损坏的区块，并显示详细信息。
适用于ext2和ext3文件系统。
batch
batch: batch，运行批次作业

batch -f com.txt，运行文件com.txt中的命令。
bc
bc: arbitrary precision calculator，文字型计算器

bc，进入计算器。可以做四则运算，也可以定义变量并做运算。
bg
bg: background，将进程放到后台运行

cat /var/log/messages | more，然后ctrl+z暂时中断程序。再运行bg 1，其中1为工作编号。
将正在运行的进程移到后台运行，其效果与运行命令后面加上&amp;效果相同。
bind
bind: bind，显示或设置键盘配置

bind -l | grep kill，列出与kill有关的所有功能名称。
bind -m vi -v，列出vi的按键配置与使用的变量名称。
blockdev
blockdev: block device，查询区块设备

blockdev -v --getss /dev/sda1，列出/dev/sda1的区块大小。
blockdev -v --getsize /dev/sda1，获取/dev/sda1的区块容量。
bunzip2
bunzip2: Burrows-Wheeler un-zip file，解压缩bz2格式的压缩文件。

bunzip2 -k afile.bz2，解压afile.bz2文件，不删除原来的压缩文件。
bunzip2 -s afile.bz2，用较少的内存解压afile.bz2文件。
bunzip2是bzip -d的功能连接。
bzgrep
bzgrep: Burrows-Wheeler zip file grep，查找bz2文件中特定的字符串

bzgrep router ip.txt.bz2，寻找ip.txt.bz2压缩文件中的router字符串。
bzip2
bzip2: Burrows-Wheeler zip file，将文件压缩为bz2文件

bzip2 afile，压缩文字文件afile为afile.bz2，压缩后afile文件消失。
bzip2 -l pic.png，压缩一般的png图像文件。
bzip2 -d pic.png.bz2，解压文件。
bzip2recover
bzip2recover: Burrows-Wheeler zip file recover，修复损坏的bz2文件

bzip2recover text.bz2，当bz2文件发生问题无法解压缩时，尝试此命令来还原文件。
bzless
bzless: Burrows-Wheeler zip file less，列出bz2文件的内容

bzless afile.bz2，列出压缩文件afile.bz2中的内容。

Ccal
cal: calendar，显示日历

cal，显示本月的月历。
cal 2000，显示2000年年历。
cal 5 2001，显示2000年5月月历。
cal -m，以星期一为每周的第一天方式，显示本月的月历。 
cal -jy，以一月一日起的天数显示今年的年历。
cat
cat: catenate，列出文件内容

cat -n textfile1 &gt; textfile2，把textfile1的内容加上行号后，转存为textfile2。
cat -b textfile1 textfile2 &gt;&gt; textfile3，把textfile1和textfile2的内容加上行号（空白行不加）之后，将内容附加到textfile3的最后。
cd
cd: change directory，切换目录

cd /usr/bin，进入/usr/bin/目录。
cd ~，回到home directory。
cd ../..，跳到目前目录的上上两层:
cfdisk
cfdisk: curses formatted disk，设置硬盘分区

cfdisk，进入分区界面。
cfdisk -P S /dev/sda，按照扇区排序，显示第一块硬盘的分割情况。
cfdisk是传统命令fdisk的进化版。
chage
change: change user password expiry info，改变密码的有效期

cat /etc/shadow | grep sherry，chage -E 2018-12-31 sherry，设置sherry账号的密码设置在2018年12月31日失效。
chage -M 5 sherry，要求账号sherry必须在5天内变更密码。
chage -l sherry，显示账号的密码设置。
chattr
chattr: change attributes，改变文件属性

chattr +a file1，lsattr file1，增加文件的属性，使之可以附加数据，而无法被修改。
chattr +i file1，改变文件属性，无法修改和删除。
chcon
chcon: change security context，修改SELinux标签

chcon -R -t httpd_sys_content_t www/，将www目录类型改为httpd_sys_content_t。
chgrp
chgrp: change group，改变文件或目录所属的组

chgrp users afile，修改afile的组为users。
chgrp -h users tt，修改符号连接tt的组为users。
可以使用chmod实现同样的效果，因此chgrp使用频率较低。
chkconfig
chkconfig: check configurate，设置系统在不同运行等级下的服务。

chkconfig --list sendmail，列出sendmail在不同运行等级下的状态。
chkconfig --level 35 named on，使DNS服务器在运行等级为3和5时启动。
chkconfig --level 0123456 vsftpd on，使FTP服务器在所有等级下启动。
chkconfig --lis | grep 3:启用，列出runlevel3中所有开启的服务。
chmod
chmod: change mode，改变文件或目录的权限

chmod ugo+r file1.txt，将file1.txt设为所有人可读取。
chmod a+r file1.txt，将file1.txt设为所有人可读取。　　chmod ug+w,o-w file1.txt file2.txt，将file1.txt与file2.txt设为文件拥有者和其所属同一个群体者可写入，但其他以外的人则不可写入。　　chmod u+x ex1.py，将ex1.py设定为只有该文件拥有者可以执行。　　chmod -R a+r *，将目前目录下的所有文件与子目录皆设为任何人可读取。
chmod 777 file，三个7，分别表示User、Group及Other的权限。r=4，w=2，x=1。若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=7。 
chmod a=rwx file和chmod 777 file效果相同。
chmod ug=rwx,o=x file和chmod 771 file效果相同。
chmod 4755 filename，可使此程序具有root的权限。
chown
chown: change owner，改变文件或目录的拥有者或组

chown jessie:users file1.txt，将文件file1.txt的拥有者设为users群体的用户jessie。　　chmod -R lamport:users *，将当前目录下的所有文件与子目录的拥有者皆设为users群体的用户lamport。
chroot
chroot: change root，切换根目录所在的路径

chroot /mnt/disk /bin/bash，将根目录切换到/mnt/disk，并将/bin/bash作为使用的shell。
chsh
chsh: change shell，改变账号登录系统时所使用的shell

chsh -l，列出所有可用的shell。
chsh，然后指定使用的shell。
chsh -s /bin/bash peter，指定peter账号的shell。
clear
clear: clear，清除画面

clear，清屏。 
clock
clock: clock，调整RTC（Real Time Clock）时间

clock，显示目前硬件时钟的时间。
clock --set --data=&quot;2/27/11 22:15&quot;，将目前硬件时钟的时间设置为2011年2月27日22:15。
clock --hctosys，让系统时间和硬件时钟一致。
clock --systohc，将系统时间写入硬件时钟。
cmp
cmp: compare，对比两个文件的差异

cmp test.txt text.txt，对比两个文件。
一般使用diff命令来进行文本内容比较，cmp使用较少。
col
col: column，过滤特殊字符

col -f &lt; testfile，过滤testfile中的RLF字符。
man kill | col -b &gt; kill.txt，过滤所有控制字符（RLF和HRLF）。
colrm
colrm: column remove，删除指定的列

cat file | colrm 7，删除第6列以后的字符。
cat file | colrm 2 5，删除第2~5列的字符。
compress
copress: compress

compress -f source.dat，将 source.dat 压缩成 source.dat.Z，若 source.dat.Z 已经存在，内容则会被压缩档覆盖。　　compress -vf source.dat，将 source.dat 压缩成 source.dat.Z ，并列印出压缩比例。
compress -c source.dat &gt; target.dat.Z，指定压缩档名。　　compress -b 12 source.dat，-b 的值越大，压缩比例就越大，范围是 9-16 ，预设值是 16 。 
　　
compress -d source.dat compress -d source.dat.Z
由于系统会自动加入 .Z 为延伸档名，所以 source.dat 会自动当作 source.dat.Z 处理。
将 source.dat.Z 解压成 source.dat ，若文件已经存在，用户按 y 以确定覆盖文件，若使用 -df 程序则会自动覆盖文件。
cp
cp: copy file，复制文件或目录

cp aaa bbb，将文件aaa复制命名为 bbb。
cp *.c finished，将所有的.c文件复制到finished目录中。
cpio
cpio: copy in, copy out，文件备份

ls | cpio -o -O ./backupfile，将目录下的所有文件（不包含子目录）备份到backupfile。
cpio -t -v -I backupfile，查看备份文件backupfile中的文件信息。
crontab
crontab: cron table，设置计划任务

crontab -l，列出自己的计划任务设置。
crontab -e，编辑自己的计划任务。若要在每周六运行/usr/bin/w &gt;&gt; /root/login.txt，可设置如下：
* * * * 6 /usr/bin/w &gt;&gt; /root/login.txt
若要改为每天23:55运行以上命令，可设置如下：
55 23 * * * /usr/bin/w &gt;&gt; /root/login.txt

crontab -u adm -r，删除adm账号的计划任务设置。
1、确认crontab是否安装crontab，如果报 command not found，就表明没有安装2、安装 crontabyum install -y vixie-cron3、确认是否安装成功:执行 crontab -l4、看是否设置了开机自动启动chkconfig --list crond5、启动crontabservice crond start
csplit
csplit: content split，分割文件

csplit -n 3 vsftpd.log 3000，以3000行为界分割为两个文件，并指定列出的文件名位数为3。
csplit -f file vsftpd.log 3000，以3000行为界分割为两个文件，且指定分割的文件名以file开头。
csplit vsftpdlog 1000 {7}，以1000行为界分割为7个文件。
ctrlaltdel
ctrlaltdel: control alt del，设置Ctrl+Alt+Del快捷键。

ctrlaltdel hard，设置为不保存数据立即重启。ctrlaltdel soft，设置为保存数据、停止服务、卸载文件后重启。
cut
cut: cut，截取文本内容的指定范围

cat log1，正常查看文件。
root    pts/0        2013-04-29 00:52(192.168.222.1)root    pts/0        2013-04-29 00:52(192.168.222.1)root    pts/0        2013-04-29 00:52(192.168.222.1)

cut -b 3,10 log1，只取出第3、10个字节。
opopop

cut -b -3 log1，取前3个字节。
roorooroo


Ddate
date: date，显示或修改日期时间

date，显示当前日期和时间。
date +%B%d，显示月份与日数。
dd
dd: standard input, standard output，转换并列出数据

dd if=file.txt of=/dev/fd0，将文件file.txt写入到软盘。
dd if=boot.img of=/dev/fd0 bs=1440k，制作启动盘，其中，boot.img为开机的镜像文件。
dd if=test.txt of=out.txt conv=ucase，将文件test.txt中的英文字母全部转换为大写后，存储为out.txt。
debugfs
debugfs: debug file system，ext2和ext3的文件系统改错工具

debugfs /dev/sda7，dump install.log /root/bkp.txt，将/dev/sda7下的install.log文件导出一份放到/root/bkp.txt中。
declare
declare: declare，声明环境变量

declare，显示当前的shell变量。
declare -x，显示所有的环境变量。
declare -i number=100+200，echo $number，如果不加-i，系统会以字符串方式来处理100+200。
declare命令与export命令相比，区别在于declare声明的是shell变量，export声明的是环境变量。shell变量只能给shell只用，环境变量可以给shell以及外部命令使用。declare加上-x参数，则与export的作用相同。
depmod
depmod: dependence of module，分析可加载模块的关联性

depmod -a，检测模块的关联性。
df
df: display file system，显示文件系统的使用情况

df，显示当前文件系统的使用状况。
df -m，以MB为单位来显示当前文件系统的使用状况。
df -a，显示所有文件系统的使用状况。
df -h，以较易读取的方式显示文件系统的使用状况。
df -i，显示系统inode的状态。
diff
diff: diffrence，比较并显示文件差异

diff file1 file2，对比file1和file2。
diff -c file1 file2，对比file1和file2，并列出文件的异同。
diff -y file1 file2，对比file1和file2，并以并列的方式显示对比结果。
diff -B file1 file2，对比file1和file2，不对比空白行。
diff /etc/mail/ mail/，比较两个目录的差异。
diffstat
diffstat: diffrence statistics，根据diff的比较结果显示统计数字

diff /etc/mail/ mail/ | diffstat，对比两个目录的差异，并通过diffstat命令列出。
dig
dig: dig，显示域名的高级信息

dig sina.com，查询域名sina.com。
dig 163.com -t MX，查询163.com的邮件名称记录（MX record）。
dir
dir: directory，列出目录或文件名

dir，列出当前目录的文件。
dir -l，以长列表列出当前的文件。
dir命令和ls命令的功能完全相同。
dirname
dirname: directory name，列出当前路径下的路径名称

dirname /opt/httpd，显示/opt/httpd下的路径名称。
dirname file.txt，显示file.txt文件的路径名称。
dpkg
dpkg: Debian package，Debian软件包管理工具

dpkg -L postfix，列出postfix安装的文件。
dpkg -i ./unzip_6.0-1_i386.deb，安装当前路径下的unzip_6.0-1_i386.deb。
dpkg是Debian和Ubuntu上的软件包安装指令，类似于RedHat与Fedora上的rpm，但一般较常使用apt-get。
du
du: display units，显示目录或文件的大小

du，显示当前目录的使用情况。
du -sk /var/*，显示/var目录下所有文件的容量，仅显示总和，默认以KB为单位。
du -sh /*，以可读性高的方式显示根目录下的目录容量。
du --max-depth=2 /var，显示/var目录下两层子目录所占用的空间。
du -b backupfile，显示文件占用的空间。
dump
dump: dump，文件系统的备份

dump -0 -f /opt/backup /boot，将/boot下的数据备份到/opt/backup中，并更新/etc/dumpdates中的记录。
cat /etc/dumpdates，查看更新后的记录。
restore -r -f /opt/backup，还原backup到备份的位置。
dump命令常用来备份ext2和ext3文件系统。
restore命令是dump命令的逆命令。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令大全——RSTUVWXYZ</title>
    <url>/dev-linux-command-all-rstuvwxyz/</url>
    <content><![CDATA[本文摘自《Linux/UNIX指令范例速查手册》。
Rraidstart
raidstart: RAID start，启动软件的硬盘阵列

raidstop
raidstop: RAID stop，关闭软件的硬盘阵列

rc-status
rc-status: runlevel command status，显示服务器的启动状态

rc-status，列出当前运行等级下的服务状态。
rc-status boot，列出运行等级为boot下的服务状态。
rc-update
rc-update: runlevel command update，显示与控制服务器的启动状态

rcp
rcp: remote copy，远程复制文件或目录

reboot
reboot: reboot，重新启动系统

reboot，重新启动系统。
renice
renice: renice，调整正在运行进程的优先级

renice -1 1772，将进程号码为1772的进程优先级改为-1。
repquota
repquota: report of quota，检查硬盘容量限制

resize2fs
resize2fs: resize file system，调整文件系统的大小

df -humount /dev/sda2e2fsck -f /dev/sda2resize2fs /dev/sda2 100Mmount /dev/sda2 /homedf -h
将文件系统/dev/sda2的大小调整为100MB。
restore
restore: restore，回存dump所产生的数据

restore -r -f dump.txt，将文件dump.txt还原到dump所备份的位置。
rlogin
rlogin: remote login，远程登录主机

rlogin 10.1.1.3，默认以当前root用户登录10.1.1.3主机。
rlogin 10.1.1.3 -l mark，使用mark身份登录10.1.1.3主机。
rm
rm: remove，删除文件或目录

rm -i *.c，删除所有.c文件，删除前逐一询问确认。　　rm -rf finished，将 finished 目录及子目录中所有文件删除，不再确认。
　　 
rmdir
rmdir: remove directory，删除目录

rmdir AAA，将当前目录下名为 AAA 的目录删除。　　rmdir -p BBB/Test，在当前目录下的 BBB 目录中，删除名为 Test 的子目录。若 Test 删除后，BBB 目录成为空目录，则 BBB 也删除。 
rmmod
rmmod: remove modules，删除加载的模块

route
route: route，显示或设置路由

route add -net 192.168.0.0 netmask 255.255.255.0 dev eth0，通过设备eth0在网段192.168.0.0中增加一个路由。
route del default gw 10.1.1.1route add default gw 10.1.1.2
将原网关地址10.1.1.1改为10.1.1.2。
rpm
rpm: Red Had package management，管理RPM软件包

rpm -ivh postfix-2.5.6-i386.rpm，使用rpm命令安装postfix。
rpm -qi wget，显示wget详细的安装信息。
rpm -e sendmail，移除sendmail。
rsh
rsh: remote shell，远程登录的shell

rsh matt@10.1.1.5 /bin/ls，使用matt账号登录10.1.1.5并运行/bin/ls。
runlevel
runlevel: run level，显示目前的运行等级

Sscp
scp: secure copy，使用加密连接复制文件

scp testfile john@10.1.1.2:/home/john/，将本机的testfile文件以john的身份复制到10.1.1.2（默认端口为22）上。
screen
screen: screen，多重窗口管理进程

screen，使用screen命令在同一个终端机下打开两个窗口，并运行不同的进程。
sed
sed: stream editor，文件内容修改

sed &#39;2,4d&#39; testfile，将testfile的第2~4行删除。
sed &#39;s/is/error/&#39; testfile，将testfile中的每行第一个is字符串换成error。
sed &#39;s/is/error/g&#39; testfile，将testfile中的所有is字符串换成error。
service
service: service，打开或关闭服务

service --status-all，显示服务器目前的状态。
service postfix start，启动postfix服务器。
sestatus
sestatus: SELinux status，显示SELinux的状态

sestatus，显示SELinux的当前状态。
sestatus -b，显示SELinux中布尔值的状态。
set
set: set，查看和设置环境变量

set，查看系统默认的环境变量。
set SHELL &quot;/bin/csh&quot;，将变量名称SHELL设为/bin/csh。
setenforce
setenforce: set enforce，启用或取消SELinux的限制

setenforce 0，取消SELinux的所有限制。
setenforce 1，打开SELinux的限制。
setsebool
setsebool: set SELinux boolean，设置SELinux的布尔值

setsebool samba_enable_home_dirs 1，允许samba共享账号的家目录。
setsebool ftp_home_dir 1，允许账号ftp进入自己的家目录。
showmount
showmount: show mount，显示NFS文件挂载的状态

showmount -e 172.20.11.1，显示172.20.11.1这台NFS服务器所共享的目录。
shutdown
shutdown: shut down，关闭系统

shutdown -h now，立即关机。
shutdown -h 0，立即关机。
shutdown 5 &quot;system will be off in 5 mins&quot;，5分钟后关机，并在每个终端机窗口提示。
sleep
sleep: sleep，暂停计时

date;sleep 10s;date，显示目前时间后延迟10秒，之后再次显示时间。
sln
sln: static link，新建文件间的软连接

sln /etc/hosts newhost，建立一个静态的连接。
slogin
slogin: SSH login，远程加密的连接

slocate
slocate: security enhanced locate，寻找文件或目录

smbpasswd
smbpasswd: samba password，改变samba账号的密码

smbpasswd -a devin，在samba服务器上新建一个devin账号。
smbpasswd -d devin，暂停账号devin对samba服务器的使用权限。
smbstatus
smbstatus: samba status，显示samba服务器的状态

sort
sort: sort，将文本文件的内容重新排序

sort -t: /etc/passwd，将passwd中的内容按照账户的字母顺序排序。
ps -ef | sort，对于进程依照运行的账户排序。
split
split: split，分割文件

split -b 1000 vsftpd.conf，将vsftpd.conf分割为小文件，每个文件最大为1000Byte。
split -l 30 -d vsftpd.conf，将vsftpd.conf分割为小文件，每个小文件的行数最多为30行，且小文件的文件名以数字来区别。
ssh
ssh: secure shell，远程加密的连接

ssh 10.1.1.2，通过ssh连接到主机10.1.1.2。
ssh 172.20.11.1 -p 12345 -l macro，连接到172.20.11.1，使用端口12345，并使用marco账户。
stat
stat: status，显示文件或文件系统的状态

stat vsftpd.conf，显示文件vsftpd.conf的状态。
stat -f /dev/sda1，显示文件系统/dev/sda1的状态。
su
su: substitute user，切换用户

su，默认切换root账号。
su voidking，切换为voidking账号。
sudo
sudo: substitute user to do something，使用指定的账号权限运行进程

sudo -u www vi /etc/httpd/conf/httpd.conf，使用身份www编辑/etc/httpd/conf/httpd.conf。
sum
sum: sum，计算并显示文件的标识符

sum squid.conf，显示文件的标识符。
suspend
suspend: suspend，暂停当前所使用的shell

suspend -f，停止目前的shell。
swapoff
swapoff: swap off，关闭交换区空间

swapoff /dev/sda2，关闭定义在/dev/sda2上的交换区空间。
swapoff -a，关闭所有定义在/dev/fstab上的交换区空间。
swapon
swapon: swap on，挂载交换区空间

swapon /dev/sda2，挂载/dev/sda2上的交换区空间。
swapon -a，挂载所有定义在/dev/fstab上的交换区空间。
sync
sync: synchronize，将内存中的数据存回硬盘

sync，将内存中的数据写回硬盘。
sysctl
sysctl: system control，设置内核参数

sysctl -a，列出正在使用的内核参数。
sysctl -w net.ipv4.ip_forward=1，将net.ipv4.ip_forward设为1。
Ttac
tac: 颠倒的cat，从文件内容从尾到头显示

tac file.txt，将文件从尾到头以反序显示。
tail
tail: tail，显示文件后面的部分

tail -n 10 file.txt，显示文件最后10行。
tail -f /var/log/maillog，持续监控文件/var/log/maillog，只要文件有新内容，就在屏幕输出。
tar
tar: tape archive，打包文件

tar -cvf mail.tar /var/spool/mail，将账号的邮件文件打包为mail.tar。
tar -xvf mail.tar，将一个打包文件解压缩到当前目录之下。
tar -xvf mail.tar -C ./tmp/，将打包文件解压缩到/tmp下。
tar -zcvf conf.tar.gz /etc/*.conf，使用tar打包文件，并只用gzip压缩该文件。
tar -zxvf conf.tar.gz -C ./tmp/，将打包文件解压缩到/tmp下。
tar -jcvf conf.tar.bz2 /etc/*.conf，使用tar打包文件，并使用bzip2压缩该文件。
tar -jxvf conf.tar.bz2 -C ./tmp/，将打包文件解压缩到/tmp下。
tcpdump
tcpdump: TCP dump，显示网络上TCP的状态

tcpdump -i eth0，显示网络设备eth0上的数据包状态。
tee
tee: tee，读取文件并输出

tee -a file，接着输入附加内容，ctrl+C跳出。
telinit
telinit: tell init，切换系统目前的运行等级

runleveltelinit 3runlevel
将目前的运行等级改为3。
telnet
telnet: tel net，远程连接程序

telnet 172.20.11.1，连接到172.20.11.1上的telnet服务。
telnet localhost 25，连接到本机的25端口（邮件服务器使用的端口）。
tftp
tftp: trivial FTP，文件传输

# tftp localhost&gt; help&gt; quit
连接到本机tftp服务器。
time
time: time，统计时间消耗

time ps -aux，获得执行ps -aux的结果和所花费的系统资源。
top
top: top，查看目前的进程状态

top，显示所有的进程与统计信息。
top -u smmsp，显示账号smmsp所运行的进程与统计信息。
touch
touch: touch，更改文件的时间标记

touch file，新建一个名为file的文件。
touch vsftpd.conf，更改已存在文件的时间标记。
touch -d "6:03pm" file touch -d "05/06/2000" file touch -d "6:03pm 05/06/2000" file
将 file 的时间记录改成 5 月 6 日 18 点 3 分，公元两千年。时间可以使用 am，pm 或是 24 小时的格式，日期可以使用其他格式如 6 May 2000。
tr
tr: translation，转换或更改文件中的字符

cat testfile | tr line abcd，将line字符串换成abcd（l换成a，i换成b，n换成c，e换成d）。
echo &quot;this is a test&quot; | tr a-z A-Z &gt; test.txt，转换“this is a test”为大写，并且存入test.txt文件。
cat test.txt | tr -d this，去掉字符串中的t、h、i、s四个字符。
tr -s &quot;this&quot; &quot;TEST&quot;，字符串中的t换成T、h换成E，i换成S，s换成T。
tracepath
tracepath: trace path，追踪网络连接的路径

tracepath 210.75.20.211，追踪连接到210.75.20.211的路径。
traceroute
traceroute: traceroute，追踪连接所经过的路由器

traceroute 210.75.20.211，显示连接到210.75.20.211所经过的路由器。
tune2fs
tune2fs: tune ext2 file system，调整文件系统的参数

tune2fs -l /dev/sda1，列出/dev/sda1的相关信息。
tune2fs -j /dev/sda1，将文件系统由ext2调整为ext3。
Uulimit
ulimit: user limit，控制系统资源

ulimit -a，显示当前的系统资源使用限制。
ulimit -l 102400，设置所有用户所能使用的内存为102400KB。
umask
umask: user file creation mode mask，设置新建文件的屏蔽权限

umask，显示默认的文件权限。
umask -S，用较易阅读的方式显示文件权限。
umount
umount: un-mount，卸载文件系统

umount /cdrom，卸载已挂载的的目录/cdrom。
umount -a，卸载所有定义在/etc/mtab中的文件系统。
unalias
unalias: un-alias，删除别名设置

unalias ll，将已定义的别名ll删除。
uname
uname: UNIX name，显示系统信息

uname -a，显示所有信息。
uname -i，显示硬件平台。
uncompress
uncompress: un-compress，解压缩Z格式的压缩文件

uncompress -v test.Z，解压缩test.Z文件并且显示详细信息。
uniq
uniq: unique，删除文件中重复的行

uniq testfile，将文件唯一化（重复的行显示一行）。
uniq -d testfile，显示文件中重复出现的行。
unset
unset: un-set，删除变量设置

unset color，将变量color的设置删除。
unzip
unzip: un-zip，解压缩zip文件

unzip -l file.zip，显示压缩文件file.zip中的文件列表。
unzip file.zip，解压缩file.zip。
uptime
uptime: up time，显示系统已经运行的时间

uptime，显示系统已运行的时间。
useradd
useradd: user add，新建账号

useradd -m max，新增一个用户max。
useradd -u 1001 -d /opt/jerry -m jerry，新增一个用户jerry，并指定该用户UID为1001，且家目录为/opt/jerry。
userdel
userdel: user del，删除账号

userdel peter，删除用户peter。不加任何参数，仅删除该用户，不会删除该用户的家目录。
usermod
usermod: user mode，修改账号设置

usermod -d /data/john john，将用户john的登录目录改为/data/john。
usermod -e 01/31/2018 alex，将用户alex的有效期限设为2018年1月31日。
usermod -l alex peter，将账号peter改为alex。
usermod -g users alex，将用户alex的群组改为users。
users
users: user status，显示登录账号

users，显示登录的用户名称。
Vvi
vi: view，文本编辑

vi install.log，编辑文件install.log。
vi/vim编辑器常用命令与用法总结
view
view: view，文本编辑

view是一个连接到vi的连接文件，与vi完全相同。
vim
vim: vi improved，文本编辑

vim是vi的升级版，用法参考vi。
vlock
vlock: virtual lock，锁定虚拟控制台的使用权

vlock，将目前的窗口锁定。
vmstat
vmstat: virtual memory status，显示虚拟内存的状态

vmstat，显示虚拟内存目前的使用状况。
vmstat -d，显示磁盘的使用状况。
vmstat -s，显示多样的数据与统计信息。
Ww
w: who，显示目前登录的账号信息

w，显示所有用户的数据。
wait
wait: wait，等待程序传回信息

wait 3305，等待进程为3305的程序传回值。
wall
wall: wall，广播信息

wall hi，传讯息”hi”给每一个用户。
watch
watch: watch，全屏输出命令的运行结果

watch -n 5 tail /var/log/messages，每个5s运行一次tail /var/log/messages。
wc
wc: word count，计算文件的字节数、字数或行数

wc -c install.log，显示install.log的字符数。
wc -l install.log，显示install.log的行数。
wget
wget: WWW get，从指定的网站下载文件

wget http://apache.mirror.com/httpd/httpd-2.2.8.tar.gz，下载httpd-2.2.8.tar.gz。
wget -t 5 http://apache.mirror.com/httpd/httpd-2.2.8.tar.gz，下载httpd-2.2.8.tar.gz，最多尝试5次。
whatis
whatis: what is，查找在线帮助的位置

whatis kill，寻找命令kill的在线帮助所在的位置。
whereis
whereis: where is，查找相关的文件

whereis kill，查找命令kill的相关文件。
whereis hosts.allow，查找host.allow的相关文件。
which
which: which，查找指定的文件

which cat，寻找文件cat。
who
who: who，显示目前登录的账号信息

who，显示当前登录系统的账户。
who -q，显示当前登录的用户名称及总人数。
who -r，显示当前的运行等级。
whoami
whoami: who am i，显示账号名称

whoami，显示自己的用户名称。
write
write: write，发送信息给其他账号

write Rollaend，传讯息给Rollaend，此时 Rollaend 只有一个连线。接下来就是将讯息打上去，结束按 ctrl+c。
write Rollaend pts/2，传讯息给 Rollaend，Rollaend 的连线有 pts/2，pts/3。注意：若对方设定 mesg n，则此时讯息将无法传给对方。
Xxauth
xauth: X-authentication，编辑X服务器的授权信息

xauth，进入命令行互动模式。
xhost
xhost: X-host，管理存取X服务器的权限

xhost，显示目前的xhost状态。
xhost +192.168.0.1，允许地址192.168.0.1对本机的X服务器有访问权限。
xset
xset: X-set，设置X-window的参数

xset s on，打开屏幕保护功能。
xset q，显示目前状态。
Yyes
yes: yes，响应相同的字符串

yes hello，利用yes命令重复响应字符串hello。
yum
yum: yellowdog updater modified，RPM软件包的高级管理

yum check-update，列出所有可升级的软件包。
yum install lynx，安装lynx软件包。
yum update webalizer，升级webalizer软件包。
# yum shell&gt; update vino&gt; run&gt; exit
使用shell升级vino软件包。
Zzcat
zcat: zip concatenate，列出压缩文件中的文件内容

zcat file.zip，查看压缩文件中的内容，只能列出压缩文件内的第一个文件的内容。
zgrep
zgrep: gz grep，查找gz或Z文件中特定的字符串

zgrep line3 file.Z，用zgrep命令查找压缩文件中包含line3的字符串。
zgrep line3 file.gz，用zgrep命令查找压缩文件中包含line3的字符串。
zip
zip: zip，将文件压缩为zip格式

zip file.Z file*，将文件名file开头的文件压缩为file.Z。
zip -d file.Z file1.zip，承接上例，移除压缩文件file.Z中的file1.zip。
zipgrep
zipgrep: zip grep，查找zip文件中特定的字符串

zipgrep Th file1.zip，寻找压缩文件file1.zip中包含字符串Th的文件，并列出该行。
zipinfo
zipinfo: zip information，显示zip压缩文件的信息

zipinfo file.Z，显示文件file.Z的压缩内容。
zless
zless: zip less，显示gz或Z文件的内容

zless file.gz，查看压缩文件的内容。
znew
znew: Z new compression，将Z文件重新压缩为gz文件

znew file.Z，将文件file.Z转换为file.gz。若Z文件中包含多个文件，将无法使用这个命令。
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux复习整理</title>
    <url>/dev-linux-review/</url>
    <content><![CDATA[题型1、填空（10*1’)2、选择（10*1’）3、简单操作题（写命令）(5*2’)4、简答题（6*5’）5、综合题（2*20’）（程序或者流程图）
考纲命令题定时任务如何设计小明是个网管，老板要求他每天早晨3点起来看看磁盘空间满不满，请问你如何用学过的知识为小明解决这一痛苦的问题。


编写脚本文件假设在/root目录下：vim diskfree.sh，内容如下：
#!/bin/bash#取得每个分区的使用百分比（不要百分号）percent=`df -h | grep -v Filesystem| awk '&#123;print int($5)&#125;'`#循环判断分区使用率是否超过90%for each_one in $percentdo		#判断使用率是否超过90%        if [ $each_one -ge 90 ];then				#如果超过90 则把使用情况发给mail_address                df | mail -s "Disk Critical" mail_address        fidone
稍微解释一下代码：df，检查文件系统的磁盘空间占用情况；-h，以方便阅读方式展示，这个参数可不加。|，管道命令，左侧命令的处理结果传递给右侧。grep -v，忽略含有Filesystem的这一行。awk ‘{print int($5)}’，逐行读入文件流，以空格或TAB为默认分隔符将每行切片，切开的部分再进行各种分析处理。这里实现的效果是，把第5个域（Use%）的数据转换为int类型。-ge，大于或等于，可以换成-gt，表示大于。mail -s，之后跟的是标题和收件人邮箱，管道之前的是内容。
添加执行权限chmod +x diskfree.sh
添加自动执行vim /etc/crontab，追加如下一句：
0 3 * * * root /root/diskfree.sh &gt; /dev/null 2&gt;&amp;1
上面的代码依次对应：
m（分）：1～59 每分钟用*或者 */1表示h（时）：1～23（0表示0点）dom（日）：1～31mon（月）：1～12dow（周）：0～6（0表示星期天）user（用户）：用户command（命令）：命令
下面是一些时间例子：1、每天早上6点10分2、每两个小时3、晚上11点到早上8点之间每两个小时，早上8点4、每个月的4号和每个礼拜的礼拜一到礼拜三的早上11点5、1月份日早上4点 
10 6 * * * 0 */2 * * * 0 23-7/2，8 * * * 0 11 4 * mon-wed 0 4 1 jan *


&gt; /dev/null 2&gt;&amp;1，这一句可以省略。如果不加这一句，当程序在你所指定的时间执行后，系统会发一份邮件到你的mail里面(/usr/spool/mail/用户名)，显示该程序执行的内容。

命令使用mv某领导要求小刚把bin目录下后缀名为“.tx.htm”的文件重命名为“.html”假设当前目录为bin，则：1、单个文件重命名mv test.tx.htm test.html2、批量重命名rename &#39;s/\.tx\.htm$/\.html/&#39; *.tx.htmPS：移动文件mv test.tx.htm ..，把test.tx.htm移动到上一层目录。
mount把/dev/sdb1挂载到/mnt/sdb1。mkdir /mnt/sdb1，新建文件夹sdb1。mount /dev/sdb1 /mnt/sdb1，挂载。umount /mnt/sdb1，卸载。
cp登录到电信机房，发现木有显示屏，请问如何把can目录底下所有后缀名为“txt”的文件拷贝到U盘中，假设U盘的目录是/udsk，当前所在目录为can。cp *.txt /udsk
passwd给新员工小明分配一个账户并设置默认密码“12345678”。useradd xiaomingpasswd xiaoming，之后两次输入密码12345678
ifconfig小明发现网络不通，他想看看第二块网卡是否分正常分配了IP地址，他如何为第二块网卡分配192.168.1.1。ifconfig eth1ifconfig eth1 192.168.1.1 netmask 255.255.255.0
netstat某web服务器部署在linux上，当远程登录时发现该应用不通。请问如何检查该应用是否起动，假设该应用的服务端口号是“8181”。netstat -anp | grep 8181

a ：all，表示列出所有的连接，服务监听，Socket资料
t ：tcp，列出tcp协议的服务
u ：udp，列出udp协议的服务
n ：port number， 用端口号来显示
l ：listening，列出当前监听服务
p ：program，列出服务程序的PID

pwd如何知道工作目录？pwd
-P：如果当前的工作路径是链接的话，显示链接的原始路径，也就是实际路径。
who当前终端登录的用户是谁？who am i
ls查看当前文件夹下所有文件，包含隐藏文件和属性ls -la
简答题Linux有哪些运行级别？Linux系统有7个运行级别(runlevel)。运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆运行级别2：多用户状态(没有NFS)运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式运行级别4：系统未使用，保留运行级别5：X11控制台，登陆后进入图形GUI模式运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动
PS：1、查看当前运行级别runlevel2、切换运行级别init N，N的值为0到6，其中，0为关机，6为重启。
如何创建一个用户？1、su，切换到root用户。2、useradd testuser，创建一个名为testuser的用户。

c： comment，指定一段注释性描述。
d：目录，指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
g：用户组，指定用户所属的用户组。

3、passwd testuser，之后回车，为testuser设置密码。
文件系统linux有哪些常见的文件系统？linux管理Windows下的文件系统？
linux常见的文件系统有ext、ext2、ext3、ext4、JFS、XFS、ReiserFS等。假设linux下有一个盘hda1的文件系统为fat32，那么：mkdir /mnt/win1mount -t vfat /dev/hda1 /mnt/win1假设linux下有一个盘hda2的文件系统为ntfs，如果内核支持ntfs，那么：mkdir /mnt/win2mount -t ntfs /dev/hda2 /mnt/win2假设linux下有一个盘hda2的文件系统为ntfs，如果内核不支持ntfs，那么：apt-get intall ntfs-3g，此命令适合Ubuntu系统mkdir /mnt/win2ntfs-3g /dev/hda2 /mnt/win2
gcc/g++gcc编译的步骤有哪些？会生成哪些文件？
gcc/g++在执行编译工作的时候，总共需要4步。1、预处理，生成.i的文件。（预处理器cpp）2、将预处理后的文件转换成汇编代码，生成文件.s。（编译器egcs）3、将汇编代码变为目标代码(机器代码)生成.o的文件。（汇编器as）4、连接目标代码，生成可执行程序。（链接器ld）
假设hello.c为最初的源代码：gcc -E hello.c -o hello.i，生成经过预处理的代码；gcc -S hello.i -o hello.s，生成汇编处理后的汇编代码；gcc -c hello.s -o hello.o，生成编译后的目标文件，含有最终编译出的机器码，但它里面所引用的其他文件中函数的内存位置尚未定义；gcc hello.o -o hello，可执行程序。上面的四个命令，可以合成一个gcc hello.c -o hello。
vi的使用vi有哪些使用方法有哪些模式？模式下有怎样的编辑？如何为vi当中增加行号？
三种模式：

命令行模式（command mode）：控制屏幕光标的移动，字符、字或行的删除，移动复制某区段等。按下“i”，进入插入模式；按下“:”，进入底行模式。

插入模式（Insert mode）：只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。

底行模式（last line mode）：将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。


增加行号：在底行模式中，输入set number
基本操作：1、进入vivi filename进入vi之后，是处于命令行模式。输入“i”，切换到插入模式。 
2、在插入模式编辑文件编辑文件，编辑完成点击「ESC」，回到命令行模式。
3、退出vi及保存文件在命令行模式下，按一下“:”进入底行模式： 

wq (存盘并退出vi) 
q! (不存盘强制退出vi) 

综合题shell编程接收用户从键盘输入的十个整数，然后求出其总和、最大值、最小值，从小到大排序。
#!/bin/shfor i in `seq 10`do  read  var  echo $var &gt;&gt; tempfile.tmpdone echo "min number is :"`sort -n  tempfile.tmp |head -n1 `echo "max number is :"`sort -rn  tempfile.tmp |head -n1 `echo "sum of all number:"`awk '&#123; a+=$0&#125;END&#123; print a&#125;' tempfile.tmp `echo "the order is:"`sort -n tempfile.tmp`rm tempfile.tmp

操作系统最后五个实验Liunx当中的ls，mao，pwd，硬盘引导，内核编译。重点关注内核引导，内核编译，pwd。
考纲升级版基本概念登陆提示符超级用户和普通用户的登录提示符是什么？超级用户root的提示符是#，普通用户的提示符是$。
桌面环境Linux系统下经常使用的两种桌面环境是什么？（1）GNOME，最常见（2）KDE
Linux系统如何标识硬盘Linux下硬盘分区的标识在Linux下用hda、hdb等来标识不同的硬盘；用hda1、hda2、hda5、hda6 来标识不同的分区。
前两个字母：hdx（x为a-d）代表IDE硬盘，sdx（x为a-z）代表SCSI、SATA、USB硬盘。第三个字母：a\b\c……代表的是1、2、3……的意思。hda代表第一块IDE硬盘，sdb代表第二块SCSI硬盘。
第四位数字：可以理解为Windows盘下的C\D\E盘符。hda1代表第一个IDE硬盘的第一个分区，sdb2代表第二个SCSI硬盘的第二个分区。
Linux在I386体系结构中的分页支持几级？i386采用二级分页，其线性地址的结构如下：Dir有10位，表示页表目录项的下标，指向一个页表；Page有10位，表示一个具体页表中的目录项的下标，指向一个物理页面；Offset有12位，表示在物理页面中的偏移量（单位为字节）。
什么时候需要编译内核？1、尝鲜，linux内核发行了新版本，想在第一时间使用新功能。
2、使用一些工具，需要使用包含debuginfo的内核，而一般的发行版本不包含debuginfo。
3、修改了内核代码，比如添加了系统调用。
4、做arm的嵌入式开发，将其烧制到主板上。
命令操作执行定时任务1、执行一次语法：
at [参数] [时间]at&gt; 执行的指令
退出at命令 ctrl+d。atq，查询当前的等待任务，被执行之后就不会显示。atrm 任务的工作号，删除系统中由at建立的正在等待被执行的任务。
at命令的参数：-m ：当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出-I ：atq的别名-d ：atrm的别名-v ：显示任务将被执行的时间-c ：打印任务的内容到标准输出-V ：显示版本信息-q ：后面加&lt;列队&gt; 使用指定的列队-f ：后面加&lt;文件&gt; 从指定文件读入任务而不是从标准输入读入-t ：后面&lt;时间参数&gt; 以时间参数的形式提交要运行的任务 
例子：明天17:20，输出时间到指定文件内
at 17:20 tomorrowat&gt; date &gt; /home/voidking/date.txtat&gt; &lt;EOT&gt;


2、定期执行详情请见：小明是个网管，老板要求他每天早晨3点起来看看磁盘空间满不满。。。
重命名文件1、单个文件重命名mv test.tx.htm test.html2、批量重命名rename &#39;s/\.tx\.htm$/\.html/&#39; *.tx.htm
加载光驱ls -l /dev | grep cdrom，假设看到光驱全名为cdrom1。mount /dev/cdrom1 /mnt/，把光盘挂载到/mnt目录下。
如何修改密码1、修改自己的密码passwd，输入当前密码，输入新密码。2、root用户修改其他用户的密码passwd username，输入新密码。
如何看本机网址1、查看本机IP地址ifconfig2、设置IP地址ifconfig eth1 192.168.1.1 netmask 255.255.255.0
PS：查看主机名hostname
如何合并文件cat file1.txt file2.txt &gt; file.txt，file1.txt和file2.txt合成file.txt。cat file1.txt &gt;&gt; file.txt，file1.txt中的内容添加到file.txt的最后。
如何创建用户1、su，切换到root用户。2、useradd testuser，创建一个名为testuser的用户。3、passwd testuser，之后回车，为testuser设置密码。
如何删除文件rm filename-f, –force    忽略不存在的文件，从不给出提示。-i, –interactive 进行交互式删除-r, -R, –recursive   指示rm将参数中列出的全部目录和子目录均递归地删除。-v, –verbose    详细显示进行的步骤
如何查看当前路径pwd-P：如果当前的工作路径是链接的话，显示链接的原始路径，也就是实际路径。
综合linux的运行级别Linux系统有7个运行级别(runlevel)。运行级别0：系统停机状态，系统默认运行级别不能设为0，否则不能正常启动运行级别1：单用户工作状态，root权限，用于系统维护，禁止远程登陆运行级别2：多用户状态(没有NFS)运行级别3：完全的多用户状态(有NFS)，登陆后进入控制台命令行模式运行级别4：系统未使用，保留运行级别5：X11控制台，登陆后进入图形GUI模式运行级别6：系统正常关闭并重启，默认运行级别不能设为6，否则不能正常启动
PS：1、查看当前运行级别runlevel2、切换运行级别init N，N的值为0到6，其中，0为关机，6为重启。
linux的文件权限如图，-rwxrwxr-x，这10位表示文件的权限，第2～10个字符中每3个为一组。
左边三个字符（rwx）表示所有者权限，中间3个字符（rwx）表示与所有者同一组的用户的权限，右边3个字符（r-x）是其他用户的权限。
r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权w(Write,写入)：对文件而言，具有新增、修改文件内容的权限；对目录来说，具有删除、移动目录内文件的权限。x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。
改变文件权限：chmod [options] [who][opcode]mode files
options：

-R，–recursive可递归遍历子目录，把修改应到目录下所有文件和子目录

who：

a，默认值，所有用户
u，拥有者
g，同组用户
o，其他用户。

opcode:

+，增加权限
-，删除权限
=，重新分配权限

mode：

r=4，读
w=2，写
x=1，执行

还可设置第四位，它位于三位权限序列的前面：

4，执行时设置用户ID，用于授权给基于文件属主的进程，而不是给创建此进程的用户。
2，执行时设置用户组ID，用于授权给基于文件所在组的进程，而不是基于创建此进程的用户。
1，设置粘贴位。

实例：
chmod u+x file	给属主增加执行权限chmod 751 file	给属主所有权限，给组分配读和执行权限，给其他用户执行权限chmod u=rwx,g=rx,o=x file	上例的另一种形式chmod =r file	为所有用户分配读权限chmod 444 file	同上例chmod a-wx,a+r file	同上例chmod -R u+r directory	directory目录下所有文件和子目录分配读的权限chmod 4755	设置用ID，给属主分配读、写和执行权限，给组和其他用户分配读、执行的权限。

如何创建文件系统假设新添加了一块硬盘sdb，想要把这块硬盘的所有空间分给第一个分区，而且该分区文件系统为ext4。1、cd /dev2、fdisk sdb3、命令p：查看当前新盘状态。4、命令n：创建一个新的分区。5、两个选项e（扩展分区）和p（主分区），选择p。6、连续两次回车，使用默认的起始和结束sector。7、创建了一个sdb1，大小为整块虚拟硬盘。8、命令w：保存退出。9、mkfs -t ext4 sdb1，格式化为ext4文件系统。
如何用GCC编译文件？gcc编译的步骤有哪些？会生成哪些文件？
gcc/g++在执行编译工作的时候，总共需要4步。1、预处理，生成.i的文件。（预处理器cpp）2、将预处理后的文件转换成汇编代码，生成文件.s。（编译器egcs）3、将汇编代码变为目标代码(机器代码)生成.o的文件。（汇编器as）4、连接目标代码，生成可执行程序。（链接器ld）
假设hello.c为最初的源代码：gcc -E hello.c -o hello.i，生成经过预处理的代码；gcc -S hello.i -o hello.s，生成汇编处理后的汇编代码；gcc -c hello.s -o hello.o，生成编译后的目标文件，含有最终编译出的机器码，但它里面所引用的其他文件中函数的内存位置尚未定义；gcc hello.o -o hello，可执行程序。上面的四个命令，可以合成一个gcc hello.c -o hello。
vi的3种模式三种模式：

命令行模式（command mode）：控制屏幕光标的移动，字符、字或行的删除，移动复制某区段等。按下“i”，进入插入模式；按下“:”，进入底行模式。

插入模式（Insert mode）：只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。

底行模式（last line mode）：将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。


增加行号：在底行模式中，输入set number
基本操作：1、进入vivi filename进入vi之后，是处于命令行模式。输入“i”，切换到插入模式。 
2、在插入模式编辑文件编辑文件，编辑完成点击「ESC」，回到命令行模式。
3、退出vi及保存文件在命令行模式下，按一下“:”进入底行模式： 

wq (存盘并退出vi) 
q! (不存盘强制退出vi) 

使用shell完成高斯求和所谓高斯求和，就是等差数列求和，这里分别输入开始值、结束值、等差：
#!/bin/shread -p "Input value of start: " startread -p "Input value of end: " endread -p "Input value of diff: " diffcount=$(($(($(($end-$start))/$diff))+1))sum=$(($(($end+$start))*$count/2))echo "SUM is $sum"


用汇编语言实现操作系统引导第一种思路CODES	SEGMENT		ORG 07C00H		; 将此段加载到内存0x0000:7C00处start:		MOV AX, CODES		MOV ES, AX		MOV AX, OFFSET msg		; 将字符串拷贝到ax		MOV BP, AX		; es:bp = 串地址		MOV CX, OFFSET strend              		MOV DX, OFFSET msg		SUB CX, DX		; cl= 串长度 		MOV len, CXnext:	INC color		AND color, 0FH		MOV AX, 1301H		; ah = 13 TELTYPE 显示字符串, al = 00h 		MOV BH, 00H		; 页号为0（bh = 0） 		MOV BL, color		;黑底红字（bl = 0ch，高亮）		MOV CX, len		MOV DX, 0815H	;第0h行15h列（dh = 0 dl = 15h）		INT 10H		; 10h号中断		JMP nextover:	RET				color	DB 00H		len		DW 0000H 		msg		DB "Hello World!"		strend	DB '$'		ORG 07C00H+200H-2H	;把结尾标志加载到(07c00h+200h-2h)处     		DW 0AA55H (07c00h+512d-2d)CODES	ENDS    		END	start
参考文档：简单OS开发前奏(三)http://blog.csdn.net/otishiono/article/details/5906119用汇编语言编写一个Boot Sectorhttp://blog.csdn.net/misskissc/article/details/8702337
感觉有点难，考试时还是画流程图吧！╮(╯▽╰)╭
第二种思路第一种思路有问题，虽然实现了题目要求，但是和Linux这门课没啥关系，提供第二种思路如下。
首先说一下操作系统启动过程：POST-&gt;BIOS-&gt;Bootloader-&gt;Linux kernel-&gt;init-&gt;system ready。
我们要完成的，就是Bootloader中的启动代码。Bootloader的工作有：
1) 初始化RAM2) 初始化串口3) 检测处理器类型4) 设置Linux启动参数5) 调用Linux内核映像
没有找到合适的参考代码，小伙伴们找到了记得在群里分享一下。
参考文档：linux bootloaderhttp://blog.chinaunix.net/uid-28440799-id-3484616.htmlBootloader分析http://blog.csdn.net/xiaomt_rush/article/details/6582337Boot Linuxhttp://www.almesberger.net/cv/papers/ols2k-9.pdfLinux 引导过程内幕http://www.ibm.com/developerworks/cn/linux/l-linuxboot/引导加载程序之争：了解 LILO 和 GRUBhttp://www.ibm.com/developerworks/cn/linux/l-bootload.htmlLinux系统引导过程（BIOS和Bootloader部分）http://blog.csdn.net/keminlau/article/details/4523973
老师赠言大题目都给大家了，小题目看上课的听讲情况了，尽量不要空着试卷，考试不会难为大家。 
后记不保证正确性，仅供参考。导出的pdf文档格式不友好，给出本文链接：http://www.voidking.com/dev-linux-review/
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux演讲</title>
    <url>/dev-linux-speech/</url>
    <content><![CDATA[前言教授Linux的丁宋涛老师，安排大家轮流讲课，6月4号就到我了，赶紧备课！我们组要讲的内容有：Linux第9题：

利用dumpe2fs把linux一个ext2(ext3也可)分区的信息dump出来，解释dump出来的信息。
结合课程的知识和ext2的目录结构，解析文件打开的过程。

课本第11章：

进程间通信。

本来想把这两部分内容都做一下，后来发现，内容实在太多，搞不定，还是大家均摊吧！题目我来，课本部分交给小伙伴们！PPT是我已经从百度文库Down好了，同志们，剩下的看你们的了！


Linux第9题第一小问利用dumpe2fs把linux一个ext2(ext3也可)分区的信息dump出来，解释dump出来的信息。
命令mount或者df -lhT，查看有哪些文件系统。dumpe2fs /dev/sda1 &gt; dump.txt，把分区信息写入dump.txt。由于郝同学在使用虚拟机安装Ubuntu的时候，选择了让系统自动分区，所以，没有文件系统使用ext2或者ext3。最终导出的，是一个ext4系统的分区信息。不再更改分区了，分区命令也忘得差不多了。。。
dump.txtFilesystem volume name:   &lt;none&gt;Last mounted on:          /Filesystem UUID:          56f9c6d7-9968-4c57-b2e5-c63d82738033Filesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isizeFilesystem flags:         signed_directory_hash Default mount options:    user_xattr aclFilesystem state:         cleanErrors behavior:          ContinueFilesystem OS type:       LinuxInode count:              458752Block count:              1834752Reserved block count:     91737Free blocks:              738375Free inodes:              287057First block:              0Block size:               4096Fragment size:            4096Reserved GDT blocks:      447Blocks per group:         32768Fragments per group:      32768Inodes per group:         8192Inode blocks per group:   512Flex block group size:    16Filesystem created:       Tue Jun  2 13:05:17 2015Last mount time:          Tue Jun  2 13:47:14 2015Last write time:          Tue Jun  2 13:47:14 2015Mount count:              3Maximum mount count:      -1Last checked:             Tue Jun  2 13:05:17 2015Check interval:           0 (&lt;none&gt;)Lifetime writes:          5791 MBReserved blocks uid:      0 (user root)Reserved blocks gid:      0 (group root)First inode:              11Inode size:	          256Required extra isize:     28Desired extra isize:      28Journal inode:            8First orphan inode:       7969Default directory hash:   half_md4Directory Hash Seed:      04a70c20-f9ac-430b-9b6b-4179feaa85c6Journal backup:           inode blocksJournal features:         journal_incompat_revokeJournal size:             128MJournal length:           32768Journal sequence:         0x00000a4fJournal start:            1Group 0: (Blocks 0-32767) [ITABLE_ZEROED]  Checksum 0xdf8b, unused inodes 0  Primary superblock at 0, Group descriptors at 1-1  Reserved GDT blocks at 2-448  Block bitmap at 449 (+449), Inode bitmap at 465 (+465)  Inode table at 481-992 (+481)  19210 free blocks, 56 free inodes, 1061 directories  Free blocks: 9640-9649, 9652-9661, 10382, 10388, 10499, 10669, 10755, 10786, 10892-10893, 10899, 13400, 13572-13573, 13579, 13591-32767  Free inodes: 7970-7975, 7977-8025, 8032Group 1: (Blocks 32768-65535) [ITABLE_ZEROED]  Checksum 0xd97d, unused inodes 0  Backup superblock at 32768, Group descriptors at 32769-32769  Reserved GDT blocks at 32770-33216  Block bitmap at 450 (bg #0 + 450), Inode bitmap at 466 (bg #0 + 466)  Inode table at 993-1504 (bg #0 + 993)  0 free blocks, 15 free inodes, 961 directories  Free blocks:   Free inodes: 9270, 9272, 9317, 11214, 11246, 15869, 15878, 15883, 15931, 15937, 16048, 16218, 16304, 16349-16350Group 2: (Blocks 65536-98303) [ITABLE_ZEROED]  Checksum 0x2380, unused inodes 0  Block bitmap at 451 (bg #0 + 451), Inode bitmap at 467 (bg #0 + 467)  Inode table at 1505-2016 (bg #0 + 1505)  0 free blocks, 33 free inodes, 58 directories  Free blocks:   Free inodes: 16416-16418, 16436-16441, 16627-16630, 16647-16651, 17142-17146, 17871-17872, 18189-18190, 18887, 18906, 18908, 19092-19094..................Group 55: (Blocks 1802240-1834751) [INODE_UNINIT, ITABLE_ZEROED]  Checksum 0x182b, unused inodes 8192  Block bitmap at 1572871 (bg #48 + 7), Inode bitmap at 1572887 (bg #48 + 23)  Inode table at 1576480-1576991 (bg #48 + 3616)  32512 free blocks, 8192 free inodes, 0 directories, 8192 unused inodes  Free blocks: 1802240-1834751  Free inodes: 450561-458752

ext2文件系统分区信息Filesystem volume name:   /                                 文件系统标签Last mounted on:          &lt;not available&gt;Filesystem UUID:          a5d248ed-850b-4392-929d-b86e2b4d65b8Filesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery sparse_super large_file        ext2文件系统可以包含的几种功能Default mount options:    user_xattr aclFilesystem state:         cleanErrors behavior.:          ContinueFilesystem OS type:       LinuxInode count:              2097152                            文件系统中inode节点的数目Block count:              2096474                            文件系统中块的数目Reserved block count:     104823Free blocks:              1910125Free inodes:              2091098First block:              0Block size:               4096                                       块大小Fragment size:            4096Reserved GDT blocks:      511Blocks per group:         32768Fragments per group:      32768Inodes per group:         32768Inode blocks per group:   1024Filesystem created:       Sat Nov 20 00:27:31 2010Last mount time:          Sat Nov 20 23:53:31 2010Last write time:          Sat Nov 20 23:53:31 2010Mount count:              10Maximum mount count:      -1Last checked:             Sat Nov 20 00:27:31 2010Check interval:           0 (&lt;none&gt;)Reserved blocks uid:      0 (user root)Reserved blocks gid:      0 (group root)First inode:              11Inode size:               128Journal inode:            8Default directory hash:   teaDirectory Hash Seed:      3302e23c-fc75-4a98-b9d1-9660c335988cJournal backup:           inode blocksJournal size:             128MGroup 0: (Blocks 0-32767)  Primary superblock at 0, Group descriptors at 1-1  Reserved GDT blocks at 2-512  Block bitmap at 513 (+513), Inode bitmap at 514 (+514)  Inode table at 515-1538 (+515)  0 free blocks, 32757 free inodes, 2 directories  Free blocks:   Free inodes: 12-32768Group 1: (Blocks 32768-65535)  Backup superblock at 32768, Group descriptors at 32769-32769  Reserved GDT blocks at 32770-33280  Block bitmap at 33281 (+513), Inode bitmap at 33282 (+514)  Inode table at 33283-34306 (+515)  26899 free blocks, 32592 free inodes, 44 directories  Free blocks: 35887-55295, 58045, 58047-65535  Free inodes: 32944, 32946-65536Group 2: (Blocks 65536-98303)  Block bitmap at 65536 (+0), Inode bitmap at 65537 (+1)  Inode table at 65538-66561 (+2)  31742 free blocks, 32768 free inodes, 0 directories  Free blocks: 66562-98303  Free inodes: 65537-98304..................Group 63: (Blocks 2064384-2096473)  Block bitmap at 2064384 (+0), Inode bitmap at 2064385 (+1)  Inode table at 2064386-2065409 (+2)  22114 free blocks, 32187 free inodes, 113 directories  Free blocks: 2065411-2086911, 2095861-2096473  Free inodes: 2064966-2097152

dump.txt详解Filesystem volume name:   &lt;none&gt;	文件系统 volume 名称Last mounted on:          /			上一次挂载文件系统的挂载点路径Filesystem UUID:          56f9c6d7-9968-4c57-b2e5-c63d82738033	由乱数产生的识别码，可以用来识别文件系统。Filesystem magic number:  0xEF53	用来识别此文档系统为 Ext2/Ext3/Ext4 的签名，位置在文档系统的 0x0438 - 0x0439 (Superblock 的 0x38-0x39)，必定是 0xEF53。Filesystem revision #:    1 (dynamic)	文件系统版本编号Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize开启了的文件系统的功能has_journal - 有日志 (journal)，亦代表此文件系统必为 Ext3 或 Ext4ext_attr - 支持 extended attributeresize_inode - resize2fs 可以改变文件系统大小dir_index - 支持目录索引，可以加快在大目录中搜索文件。filetype - 目录项目为否记录文件类型needs_recovery - e2fsck 检查 Ext3/Ext4 文件系统时用来决定是否需要完成日志记录中未完成的工作，快速自动修复文件系统extent - 支持 Ext4 extent 功能，可以加快文件系统效能和减少 external fragmentationflex_bgsparse_super - 只有少数 superblock 备份，而不是每个区块组都有 superblock 备份，节省空间。large_file - 支持大于 2G 的档案huge_fileuninit_bgdir_nlinkextra_isizeFilesystem flags:         signed_directory_hash 	文件系统旗号Default mount options:    user_xattr acl	默认挂载选项Filesystem state:         clean		文件系统状态，可以为 clean(文件系统已成功地被卸载)、not-clean(表示文件系统挂载成读写模式后，仍未被卸载)或 erroneous (文件系统被发现有问题)Errors behavior:          Continue		文件系统发生问题时的处理方案，可以为 continue (继续正常运作) 、remount-ro (重新挂载成只读模式) 或 panic (即时当掉系统)。可以使用 tune2fs -e 改变。Filesystem OS type:       Linux		建立文件系统的作业系统，可以为 Linux/Hurd/MASIX/FreeBSD/LitesInode count:              458752	文件系统的总inode 数目，亦是整个文件系统所可能拥有文件数目的上限Block count:              1834752	文件系统的总区块数目Reserved block count:     91737		保留给系统管理员工作之用的区块数目Free blocks:              738375	未使用区块数目Free inodes:              287057	未使用 inode 数目First block:              0			Superblock 或第一个区块组开始的区块编数。此值在 1 KiB 区块大小的文件系统为 1，大于1 KiB 区块大小的文件系统为 0。(Superblock/第一个区块组一般都在文件系统 0x0400 (1024) 开始)Block size:               4096		区块大小，可以为 1024, 2048 或 4096 字节 (Compaq Alpha 系统可以使用 8192 字节的区块)Fragment size:            4096		Fragment大小，实际上Ext2/Ext3/Ext4并不支持Fragment，所以此值一般和区块大小一样Reserved GDT blocks:      447	保留GDT区块数目，保留作在线改变文件系统大小的区块数目。若此值为0，只可以先卸载才可脱机改变文件系统大小Blocks per group:         32768		每个区块组的区块数目Fragments per group:      32768		每个区块组的片段数目，亦用来计算每个区块组中 block bitmap 的大小Inodes per group:         8192		每个区块组的inode数目Inode blocks per group:   512		每个区块组的inode区块数目Flex block group size:    16		Filesystem created:       Tue Jun  2 13:05:17 2015	文件系统建立时间Last mount time:          Tue Jun  2 13:47:14 2015	上一次挂载此文件系统的时间Last write time:          Tue Jun  2 13:47:14 2015	上一次改变此文件系统内容的时间Mount count:              3		挂载次数。距上一次作完整文件系统检查后文件系统被挂载的次数，让fsck决定是否应进行另一次完整文件系统检查Maximum mount count:      -1	最大挂载次数。文件系统进行另一次完整检查可以被挂载的次数，若挂载次数(Mount count)大于此值，fsck 会进行另一次完整文件系统检查Last checked:             Tue Jun  2 13:05:17 2015	上一次文件系统作完整检查的时间Check interval:           0 (&lt;none&gt;)	文件系统应该进行另一次完整检查的最大时间距Lifetime writes:          5791 MBReserved blocks uid:      0 (user root)		保留区块使用者识别码 Reserved blocks gid:      0 (group root)	保留区块群组识别码First inode:              11		第一个可以用作存放正常文件属性的inode编号，在原格式此值一定为11，V2格式可以改变此值Inode size:	          256	Inode 大小，传统为 128 字节，新系统会使用 256 字节的 inode 令扩充功能更方便Required extra isize:     28	必须的额外isizeDesired extra isize:      28	请求的额外isizeJournal inode:            8		日志文件的 inode 编号First orphan inode:       7969Default directory hash:   half_md4		缺省目录 hash 算法Directory Hash Seed:      04a70c20-f9ac-430b-9b6b-4179feaa85c6		目录 hash 种子Journal backup:           inode blocks		日志备份Journal features:         journal_incompat_revoke	日志特点Journal size:             128M		日志文件的大小Journal length:           32768		日志长度Journal sequence:         0x00000a4f	日志序列Journal start:            1		日志开始位置Group 0: (Blocks 0-32767) [ITABLE_ZEROED]  Checksum 0xdf8b, unused inodes 0  Primary superblock at 0, Group descriptors at 1-1  Reserved GDT blocks at 2-448  Block bitmap at 449 (+449), Inode bitmap at 465 (+465)  Inode table at 481-992 (+481)  19210 free blocks, 56 free inodes, 1061 directories  Free blocks: 9640-9649, 9652-9661, 10382, 10388, 10499, 10669, 10755, 10786, 10892-10893, 10899, 13400, 13572-13573, 13579, 13591-32767  Free inodes: 7970-7975, 7977-8025, 8032

第二小问结合课程的知识和ext2的目录结构，解析文件打开的过程。
ext2文件系统
文件系统中存储的最小单位是块（Block），一个块究竟多大是在格式化时确定的，例如mke2fs的-b选项可以设定块大小为1024、2048或4096字节。而上图中启动块（Boot Block）的大小是确定的，就是1KB，启动块是由PC标准规定的，用来存储磁盘分区信息和启动信息，任何文件系统都不能使用启动块。启动块之后才是ext2文件系统的开始，ext2文件系统将整个分区划成若干个同样大小的块组（Block Group），每个块组都由以下部分组成。
超级块（Super Block）描述整个分区的文件系统信息，例如块大小、文件系统版本号、上次mount的时间等等。超级块在每个块组的开头都有一份拷贝。
块组描述符表（GDT，Group Descriptor Table）由很多块组描述符组成，整个分区分成多少个块组就对应有多少个块组描述符。每个块组描述符（Group Descriptor）存储一个块组的描述信息，例如在这个块组中从哪里开始是inode表，从哪里开始是数据块，空闲的inode和数据块还有多少个等等。和超级块类似，块组描述符表在每个块组的开头也都有一份拷贝，这些信息是非常重要的，一旦超级块意外损坏就会丢失整个分区的数据，一旦块组描述符意外损坏就会丢失整个块组的数据，因此它们都有多份拷贝。通常内核只用到第0个块组中的拷贝，当执行e2fsck检查文件系统一致性时，第0个块组中的超级块和块组描述符表就会拷贝到其它块组，这样当第0个块组的开头意外损坏时就可以用其它拷贝来恢复，从而减少损失。
块位图（Block Bitmap）一个块组中的块是这样利用的：数据块（Data Block）存储所有文件的数据，比如某个分区的块大小是1024字节，某个文件是2049字节，那么就需要三个数据块来存，即使第三个块只存了一个字节也需要占用一个整块；超级块、块组描述符表、块位图、inode位图、inode表这几部分存储该块组的描述信息。那么如何知道哪些块已经用来存储文件数据或其它描述信息，哪些块仍然空闲可用呢？块位图就是用来描述整个块组中哪些块已用哪些块空闲的，它本身占一个块，其中的每个bit代表本块组中的一个块，这个bit为1表示该块已用，这个bit为0表示该块空闲可用。
为什么用df命令统计整个磁盘的已用空间非常快呢？因为只需要查看每个块组的块位图即可，而不需要搜遍整个分区。相反，用du命令查看一个较大目录的已用空间就非常慢，因为不可避免地要搜遍整个目录的所有文件。
与此相联系的另一个问题是：在格式化一个分区时究竟会划出多少个块组呢？主要的限制在于块位图本身必须只占一个块。用mke2fs格式化时默认块大小是1024字节，可以用-b参数指定块大小，现在设块大小指定为b字节，那么一个块可以有8b个bit，这样大小的一个块位图就可以表示8b个块的占用情况，因此一个块组最多可以有8b个块，如果整个分区有s个块，那么就可以有s/(8b)个块组。格式化时可以用-g参数指定一个块组有多少个块，但是通常不需要手动指定，mke2fs工具会计算出最优的数值。
inode位图（inode Bitmap）和块位图类似，本身占一个块，其中每个bit表示一个inode是否空闲可用。
inode表（inode Table）我们知道，一个文件除了数据需要存储之外，一些描述信息也需要存储，例如文件类型（常规、目录、符号链接等），权限，文件大小，创建/修改/访问时间等，也就是ls -l命令看到的那些信息，这些信息存在inode中而不是数据块中。每个文件都有一个inode，一个块组中的所有inode组成了inode表。
inode表占多少个块在格式化时就要决定并写入块组描述符中，mke2fs格式化工具的默认策略是一个块组有多少个8KB就分配多少个inode。由于数据块占了整个块组的绝大部分，也可以近似认为数据块有多少个8KB就分配多少个inode，换句话说，如果平均每个文件的大小是8KB，当分区存满的时候inode表会得到比较充分的利用，数据块也不浪费。如果这个分区存的都是很大的文件（比如电影），则数据块用完的时候inode会有一些浪费，如果这个分区存的都是很小的文件（比如源代码），则有可能数据块还没用完inode就已经用完了，数据块可能有很大的浪费。如果用户在格式化时能够对这个分区以后要存储的文件大小做一个预测，也可以用mke2fs的-i参数手动指定每多少个字节分配一个inode。
数据块根据不同的文件类型有以下几种情况
对于常规文件，文件的数据存储在数据块中。

对于目录，该目录下的所有文件名和目录名存储在数据块中，注意文件名保存在它所在目录的数据块中，除文件名之外，ls -l命令看到的其它信息都保存在该文件的inode中。注意这个概念：目录也是一种文件，是一种特殊类型的文件。

对于符号链接，如果目标路径名较短则直接保存在inode中以便更快地查找，如果目标路径名较长则分配一个数据块来保存。

设备文件、FIFO和socket等特殊文件没有数据块，设备文件的主设备号和次设备号保存在inode中。


inode tableinode记录的文件数据至少有：1、该文件的访问模式；（rwx）2、该文件的所有者与组（ower/group）；3、该文件的大小；4、该文件创建或状态改变的时间（ctime）；5、最近一次读的时间（atime）；6、最近修改的时间（mtime）；7、该文件的特性的标志（flag）；8、该文件真正内容的指向（pointer）；
而有这么强大功能的inode的大小均固定为每个128B。inode除了文件权限属性记录区域外，还有12个直接，1个间接，一个双间接与一个三间接记录区。12个直接指向号码的对照，这12个记录就能够直接取得block号码，至于所谓的间接就是再拿一个block来当作block号码的记录区，如果文件太大，就会使用间接的block来记录编号。同理，如果文件持续长大，那么就复用所谓的双间接，第一个仅再指出下一个记录编号的block在哪里，实际记录在第二个block当中。依此类推，三间接就是复用第三层block来记录编号。如下图所示：

打开/opt/file打开/opt/file，查找的顺序是：
1、读出inode表中第2项，也就是根目录的inode，从中找出根目录数据块的位置
2、从根目录的数据块中找出文件名为opt的记录，从记录中读出它的inode号
3、读出opt目录的inode，从中找出它的数据块的位置
4、从opt目录的数据块中找出文件名为file的记录，从记录中读出它的inode号
5、读出file文件的inode，找到它的数据块的位置
6、读出file文件的内容
ls、cp、mv等命令实现不会。
课件分享进程间通信PPT：http://yunpan.cn/cQTqJ2t3fPeCF  访问密码 a5c9
参考文档《UNIX/Linux程序设计教程》，赵克佳 沈志宇 编著，机械工业出版社

linux中使用dumpe2fs查看EXT2(或EXT3)文件系统信息http://blog.itpub.net/8183550/viewspace-678589/

初窥Linux 之 ext2/ext3文件系统http://blog.csdn.net/ljianhui/article/details/8604140

Linux进程间通信http://www.cnblogs.com/linshui91/archive/1838770.htmlhttp://blog.csdn.net/chen_shiyang/article/details/8011887

Linux下的进程间通信-详解http://www.cnblogs.com/skyofbitbit/p/3651750.html

ext4 笔记二（dumpe2fs）http://blog.csdn.net/lishuanglin131/article/details/8258447

ext2文件系统http://docs.linuxtone.org/ebooks/C&amp;CPP/c/ch29s02.html
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy和Pandas教程</title>
    <url>/dev-numpy-and-pandas/</url>
    <content><![CDATA[前言本文转载自优达学城《机器学习工程师》
既然目前为止，你已学会了一些基本的统计学概念，现在让我们探讨一些 Python 库，它们允许您研究数据和处理大型数据集。
具体而言，在本阶段的课程中，我们将探讨 numpy，它允许您处理大量数值数据以及 panda 序列和数据框（它们允许你存储大型数据集和提取其中的信息）。我们将学习 numpy 和 panda.DataFrames，前者能够帮助你处理大量数值数据，而后者可以帮助你存储大型数据集以及从数据集中提取出来的信息。
Numpy 库文档： https://docs.scipy.org/doc/numpy-dev/user/quickstart.html
Pandas 库文档： http://pandas.pydata.org/pandas-docs/version/0.17.0/


Numpyimport numpy as np'''The following code is to help you play with Numpy, which is a library that provides functions that are especially useful when you have towork with large arrays and matrices of numeric data, like doing matrix matrix multiplications. Also, Numpy is battle tested and optimized so that it runs fast, much faster than if you were workingwith Python lists directly.''''''The array object class is the foundation of Numpy, and Numpy arrays are likelists in Python, except that every thing inside an array must be of thesame type, like int or float.'''# Change False to True to see Numpy arrays in actionif False:    array = np.array([1, 4, 5, 8], float)    print array    print ""    array = np.array([[1, 2, 3], [4, 5, 6]], float)  # a 2D array/Matrix    print array'''You can index, slice, and manipulate a Numpy array much like you would with aa Python list.'''# Change False to True to see array indexing and slicing in actionif False:    array = np.array([1, 4, 5, 8], float)    print array    print ""    print array[1]    print ""    print array[:2]    print ""    array[1] = 5.0    print array[1]# Change False to True to see Matrix indexing and slicing in actionif False:    two_D_array = np.array([[1, 2, 3], [4, 5, 6]], float)    print two_D_array    print ""    print two_D_array[1][1]    print ""    print two_D_array[1, :]    print ""    print two_D_array[:, 2]'''Here are some arithmetic operations that you can do with Numpy arrays'''# Change False to True to see Array arithmetics in actionif False:    array_1 = np.array([1, 2, 3], float)    array_2 = np.array([5, 2, 6], float)    print array_1 + array_2    print ""    print array_1 - array_2    print ""    print array_1 * array_2# Change False to True to see Matrix arithmetics in actionif False:    array_1 = np.array([[1, 2], [3, 4]], float)    array_2 = np.array([[5, 6], [7, 8]], float)    print array_1 + array_2    print ""    print array_1 - array_2    print ""    print array_1 * array_2'''In addition to the standard arthimetic operations, Numpy also has a range ofother mathematical operations that you can apply to Numpy arrays, such asmean and dot product.Both of these functions will be useful in later programming quizzes.'''if False:    array_1 = np.array([1, 2, 3], float)    array_2 = np.array([[6], [7], [8]], float)    print np.mean(array_1)    print np.mean(array_2)    print ""    print np.dot(array_1, array_2)

Pandasimport pandas as pd'''The following code is to help you play with the concept of Series in Pandas.You can think of Series as an one-dimensional object that is similar toan array, list, or column in a database. By default, it will assign anindex label to each item in the Series ranging from 0 to N, where N isthe number of items in the Series minus one.Please feel free to play around with the concept of Series and see what it does*This playground is inspired by Greg Reda's post on Intro to Pandas Data Structures:http://www.gregreda.com/intro-to-pandas-data-structures/'''# Change False to True to create a Series objectif False:    series = pd.Series(['Dave', 'Cheng-Han', 'Udacity', 42, -1789710578])    print series'''You can also manually assign indices to the items in the Series whencreating the series'''# Change False to True to see custom index in actionif False:    series = pd.Series(['Dave', 'Cheng-Han', 359, 9001],                       index=['Instructor', 'Curriculum Manager',                              'Course Number', 'Power Level'])    print series'''You can use index to select specific items from the Series'''# Change False to True to see Series indexing in actionif False:    series = pd.Series(['Dave', 'Cheng-Han', 359, 9001],                       index=['Instructor', 'Curriculum Manager',                              'Course Number', 'Power Level'])    print series['Instructor']    print ""    print series[['Instructor', 'Curriculum Manager', 'Course Number']]'''You can also use boolean operators to select specific items from the Series'''# Change False to True to see boolean indexing in actionif False:    cuteness = pd.Series([1, 2, 3, 4, 5], index=['Cockroach', 'Fish', 'Mini Pig',                                                 'Puppy', 'Kitten'])    print cuteness &gt; 3    print ""    print cuteness[cuteness &gt; 3]

Pandas 数据框import numpy as npimport pandas as pd'''The following code is to help you play with the concept of Dataframe in Pandas.You can think of a Dataframe as something with rows and columns. It issimilar to a spreadsheet, a database table, or R's data.frame object.*This playground is inspired by Greg Reda's post on Intro to Pandas Data Structures:http://www.gregreda.com/intro-to-pandas-data-structures/''''''To create a dataframe, you can pass a dictionary of lists to the Dataframeconstructor:1) The key of the dictionary will be the column name2) The associating list will be the values within that column.'''# Change False to True to see Dataframes in actionif False:    data = &#123;'year': [2010, 2011, 2012, 2011, 2012, 2010, 2011, 2012],            'team': ['Bears', 'Bears', 'Bears', 'Packers', 'Packers', 'Lions',                     'Lions', 'Lions'],            'wins': [11, 8, 10, 15, 11, 6, 10, 4],            'losses': [5, 8, 6, 1, 5, 10, 6, 12]&#125;    football = pd.DataFrame(data)    print football'''Pandas also has various functions that will help you understand some basicinformation about your data frame. Some of these functions are:1) dtypes: to get the datatype for each column2) describe: useful for seeing basic statistics of the dataframe's numerical   columns3) head: displays the first five rows of the dataset4) tail: displays the last five rows of the dataset'''# Change False to True to see these functions in actionif False:    data = &#123;'year': [2010, 2011, 2012, 2011, 2012, 2010, 2011, 2012],            'team': ['Bears', 'Bears', 'Bears', 'Packers', 'Packers', 'Lions',                     'Lions', 'Lions'],            'wins': [11, 8, 10, 15, 11, 6, 10, 4],            'losses': [5, 8, 6, 1, 5, 10, 6, 12]&#125;    football = pd.DataFrame(data)    print football.dtypes    print ""    print football.describe()    print ""    print football.head()    print ""    print football.tail()


from pandas import DataFrame, Series################## Syntax Reminder:## The following code would create a two-column pandas DataFrame# named df with columns labeled 'name' and 'age':## people = ['Sarah', 'Mike', 'Chrisna']# ages  =  [28, 32, 25]# df = DataFrame(&#123;'name' : Series(people),#                 'age'  : Series(ages)&#125;)def create_dataframe():    '''    Create a pandas dataframe called 'olympic_medal_counts_df' containing    the data from the table of 2014 Sochi winter olympics medal counts.      The columns for this dataframe should be called     'country_name', 'gold', 'silver', and 'bronze'.      There is no need to  specify row indexes for this dataframe     (in this case, the rows will automatically be assigned numbered indexes).        You do not need to call the function in your code when running it in the    browser - the grader will do that automatically when you submit or test it.    '''    countries = ['Russian Fed.', 'Norway', 'Canada', 'United States',                 'Netherlands', 'Germany', 'Switzerland', 'Belarus',                 'Austria', 'France', 'Poland', 'China', 'Korea',                  'Sweden', 'Czech Republic', 'Slovenia', 'Japan',                 'Finland', 'Great Britain', 'Ukraine', 'Slovakia',                 'Italy', 'Latvia', 'Australia', 'Croatia', 'Kazakhstan']    gold = [13, 11, 10, 9, 8, 8, 6, 5, 4, 4, 4, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]    silver = [11, 5, 10, 7, 7, 6, 3, 0, 8, 4, 1, 4, 3, 7, 4, 2, 4, 3, 1, 0, 0, 2, 2, 2, 1, 0]    bronze = [9, 10, 5, 12, 9, 5, 2, 1, 5, 7, 1, 2, 2, 6, 2, 4, 3, 1, 2, 1, 0, 6, 2, 1, 0, 1]    # your code here    data = &#123;'country_name':Series(countries),'gold':Series(gold),'silver':Series(silver),'bronze':Series(bronze)&#125;    olympic_medal_counts_df = DataFrame(data,index=countries)    return olympic_medal_counts_df

索引数据框import pandas as pd'''You can think of a DataFrame as a group of Series that share an index.This makes it easy to select specific columns that you want from the DataFrame. Also a couple pointers:1) Selecting a single column from the DataFrame will return a Series2) Selecting multiple columns from the DataFrame will return a DataFrame*This playground is inspired by Greg Reda's post on Intro to Pandas Data Structures:http://www.gregreda.com/intro-to-pandas-data-structures/'''# Change False to True to see Series indexing in actionif True:    data = &#123;'year': [2010, 2011, 2012, 2011, 2012, 2010, 2011, 2012],            'team': ['Bears', 'Bears', 'Bears', 'Packers', 'Packers', 'Lions',                     'Lions', 'Lions'],            'wins': [11, 8, 10, 15, 11, 6, 10, 4],            'losses': [5, 8, 6, 1, 5, 10, 6, 12]&#125;    football = pd.DataFrame(data)    print football['year']    print ''    print football.year  # shorthand for football['year']    print ''    print football[['year', 'wins', 'losses']]'''Row selection can be done through multiple ways.Some of the basic and common methods are:   1) Slicing   2) An individual index (through the functions iloc or loc)   3) Boolean indexingYou can also combine multiple selection requirements through booleanoperators like &amp; (and) or | (or)'''# Change False to True to see boolean indexing in actionif True:    data = &#123;'year': [2010, 2011, 2012, 2011, 2012, 2010, 2011, 2012],            'team': ['Bears', 'Bears', 'Bears', 'Packers', 'Packers', 'Lions',                     'Lions', 'Lions'],            'wins': [11, 8, 10, 15, 11, 6, 10, 4],            'losses': [5, 8, 6, 1, 5, 10, 6, 12]&#125;    football = pd.DataFrame(data)    print football.iloc[[0]]    print ""    print football.loc[[0]]    print ""    print football[3:5]    print ""    print football[football.wins &gt; 10]    print ""    print football[(football.wins &gt; 10) &amp; (football.team == "Packers")]


向量化方法from pandas import DataFrame, Seriesimport numpydef avg_medal_count():    '''    Compute the average number of bronze medals earned by countries who     earned at least one gold medal.          Save this to a variable named avg_bronze_at_least_one_gold. You do not    need to call the function in your code when running it in the browser -    the grader will do that automatically when you submit or test it.        HINT-1:    You can retrieve all of the values of a Pandas column from a     data frame, "df", as follows:    df['column_name']        HINT-2:    The numpy.mean function can accept as an argument a single    Pandas column.         For example, numpy.mean(df["col_name"]) would return the     mean of the values located in "col_name" of a dataframe df.    '''    countries = ['Russian Fed.', 'Norway', 'Canada', 'United States',                 'Netherlands', 'Germany', 'Switzerland', 'Belarus',                 'Austria', 'France', 'Poland', 'China', 'Korea',                  'Sweden', 'Czech Republic', 'Slovenia', 'Japan',                 'Finland', 'Great Britain', 'Ukraine', 'Slovakia',                 'Italy', 'Latvia', 'Australia', 'Croatia', 'Kazakhstan']    gold = [13, 11, 10, 9, 8, 8, 6, 5, 4, 4, 4, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]    silver = [11, 5, 10, 7, 7, 6, 3, 0, 8, 4, 1, 4, 3, 7, 4, 2, 4, 3, 1, 0, 0, 2, 2, 2, 1, 0]    bronze = [9, 10, 5, 12, 9, 5, 2, 1, 5, 7, 1, 2, 2, 6, 2, 4, 3, 1, 2, 1, 0, 6, 2, 1, 0, 1]        olympic_medal_counts = &#123;'country_name':Series(countries),                            'gold': Series(gold),                            'silver': Series(silver),                            'bronze': Series(bronze)&#125;    df = DataFrame(olympic_medal_counts)        # YOUR CODE HERE    broze_at_least_one_gold = df['bronze'][df['gold'] &gt;= 1]    avg_bronze_at_least_one_gold = numpy.mean(broze_at_least_one_gold)    return avg_bronze_at_least_one_gold

import numpyfrom pandas import DataFrame, Seriesdef avg_medal_count():    '''    Using the dataframe's apply method, create a new Series called     avg_medal_count that indicates the average number of gold, silver,    and bronze medals earned amongst countries who earned at     least one medal of any kind at the 2014 Sochi olympics.  Note that    the countries list already only includes countries that have earned    at least one medal. No additional filtering is necessary.        You do not need to call the function in your code when running it in the    browser - the grader will do that automatically when you submit or test it.    '''    countries = ['Russian Fed.', 'Norway', 'Canada', 'United States',                 'Netherlands', 'Germany', 'Switzerland', 'Belarus',                 'Austria', 'France', 'Poland', 'China', 'Korea',                  'Sweden', 'Czech Republic', 'Slovenia', 'Japan',                 'Finland', 'Great Britain', 'Ukraine', 'Slovakia',                 'Italy', 'Latvia', 'Australia', 'Croatia', 'Kazakhstan']    gold = [13, 11, 10, 9, 8, 8, 6, 5, 4, 4, 4, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]    silver = [11, 5, 10, 7, 7, 6, 3, 0, 8, 4, 1, 4, 3, 7, 4, 2, 4, 3, 1, 0, 0, 2, 2, 2, 1, 0]    bronze = [9, 10, 5, 12, 9, 5, 2, 1, 5, 7, 1, 2, 2, 6, 2, 4, 3, 1, 2, 1, 0, 6, 2, 1, 0, 1]        olympic_medal_counts = &#123;'country_name':countries,                            'gold': Series(gold),                            'silver': Series(silver),                            'bronze': Series(bronze)&#125;        df = DataFrame(olympic_medal_counts)        # YOUR CODE HERE    avg_medal_count = df[['gold','silver','bronze']].apply(numpy.mean)        return avg_medal_count


矩阵乘法和Numpy Dotimport numpyfrom pandas import DataFrame, Seriesdef numpy_dot():    '''    Imagine a point system in which each country is awarded 4 points for each    gold medal,  2 points for each silver medal, and one point for each     bronze medal.      Using the numpy.dot function, create a new dataframe called     'olympic_points_df' that includes:        a) a column called 'country_name' with the country name        b) a column called 'points' with the total number of points the country           earned at the Sochi olympics.               You do not need to call the function in your code when running it in the    browser - the grader will do that automatically when you submit or test it.    '''    countries = ['Russian Fed.', 'Norway', 'Canada', 'United States',                 'Netherlands', 'Germany', 'Switzerland', 'Belarus',                 'Austria', 'France', 'Poland', 'China', 'Korea',                  'Sweden', 'Czech Republic', 'Slovenia', 'Japan',                 'Finland', 'Great Britain', 'Ukraine', 'Slovakia',                 'Italy', 'Latvia', 'Australia', 'Croatia', 'Kazakhstan']    gold = [13, 11, 10, 9, 8, 8, 6, 5, 4, 4, 4, 3, 3, 2, 2, 2, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]    silver = [11, 5, 10, 7, 7, 6, 3, 0, 8, 4, 1, 4, 3, 7, 4, 2, 4, 3, 1, 0, 0, 2, 2, 2, 1, 0]    bronze = [9, 10, 5, 12, 9, 5, 2, 1, 5, 7, 1, 2, 2, 6, 2, 4, 3, 1, 2, 1, 0, 6, 2, 1, 0, 1]     # YOUR CODE HERE    data = &#123;'country_name':Series(countries),'gold':Series(gold),'silver':Series(silver),'bronze':Series(bronze)&#125;    df = DataFrame(data)    medal_counts = df[['gold','silver','bronze']]    points = numpy.dot(medal_counts,[4,2,1])    olympic_points = &#123;'country_name': Series(countries),'points':Series(points)&#125;    olympic_points_df = DataFrame(olympic_points)        return olympic_points_df

书签Pandas文档http://pandas.pydata.org/pandas-docs/stable/
Pandas IPython Notebook 教程https://bitbucket.org/hrojas/learn-pandas
numpy.dot — NumPy v1.12 Manualhttps://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>转载</tag>
        <tag>机器学习</tag>
        <tag>numpy</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy和Matplotlib</title>
    <url>/dev-numpy-matplotlib/</url>
    <content><![CDATA[前言在进行机器学习时，经常用到两个库，numpy和matplotlib。
numpy(Numerical Python extensions)是一个第三方的Python包，用于科学计算。这个库的前身是1995年就开始开发的一个用于数组运算的库。经过了长时间的发展，基本上成了绝大部分Python科学计算的基础包，当然也包括所有提供Python接口的深度学习框架。
Matplotlib是Python中最常用的可视化工具之一，可以非常方便地创建海量类型地2D图表和一些基本的3D图表。Matplotlib最早是为了可视化癫痫病人的脑皮层电图相关的信号而研发，因为在函数的设计上参考了MATLAB，所以叫做Matplotlib。


准备pip install numpypip install matplotlib

numpy基本类型（array）import numpy as npa = [1, 2, 5, 3, 4]b = np.array(a)print('a=',a)print('b=',b)print('type(a):',type(a))print('type(b)',type(b))  print('b.dtype',b.dtype)b2 = b.astype(np.float32)print('b2.dtype',b2.dtype)                   print('b.shape:', b.shape)                    print('b.argmax():',b.argmax())                  print('b.max():',b.max())                     print('b.mean():',b.mean())            c = [[1, 2], [3, 4]]    d = np.array(c)print('c=',c)print('d=',d)print('d.shape:',d.shape) print('d.size:',d.size)print('d.max(axis=0):',d.max(axis=0)) # 找列最大值print('d.max(axis=1):',d.max(axis=1)) # 找行最大值print('d.mean(axis=0):',d.mean(axis=0))  # 求列平均数      print('d.flatten():',d.flatten()) # 展开为一维数组print('np.ravel(c)',np.ravel(c)) # 展开为一维数组# 3x3的浮点型2维数组，并且初始化所有元素值为1e = np.ones((3, 3), dtype=np.float32)print('e=',e)# 创建一个一维数组，元素值是把3重复4次，array([3, 3, 3, 3])f = np.repeat(3, 4)print('f=',f)# 2x2x3的无符号8位整型3维数组，并且初始化所有元素值为0g = np.zeros((2, 2, 3), dtype=np.uint8)print('g=',g)print('g.shape',g.shape)h = g.astype(np.float)  # 用另一种类型表示print('h=',h)l = np.arange(10)       # 类似range，array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])print('l=',l)m = np.linspace(0, 6, 5)# 等差数列，0到6之间5个取值，array([ 0., 1.5, 3., 4.5, 6.])print('m',m)p = np.array(    [[1, 2, 3, 4],     [5, 6, 7, 8]])np.save('p.npy', p)     # 保存到文件q = np.load('p.npy')    # 从文件读取

array相关操作import numpy as np'''array([[[ 0,  1,  2,  3],        [ 4,  5,  6,  7],        [ 8,  9, 10, 11]],       [[12, 13, 14, 15],        [16, 17, 18, 19],        [20, 21, 22, 23]]])'''a = np.arange(24).reshape((2, 3, 4))print('a=',a)b = a[1][1][1]print('a[1][1][1]=',b)'''array([[ 8,  9, 10, 11],       [20, 21, 22, 23]])'''c = a[:, 2, :]print('a[:, 2, :]=',c)''' 用:表示当前维度上所有下标array([[ 1,  5,  9],       [13, 17, 21]])'''d = a[:, :, 1]print('a[:, :, 1]=',d)''' 用...表示没有明确指出的维度array([[ 1,  5,  9],       [13, 17, 21]])'''e = a[..., 1]print('a[..., 1]=',e)'''array([[[ 5,  6],        [ 9, 10]],       [[17, 18],        [21, 22]]])'''f = a[:, 1:, 1:-1]print('a[:, 1:, 1:-1]=',f)'''平均分成3份[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]'''g = np.split(np.arange(9), 3)print('g=',g)'''按照下标位置进行划分[array([0, 1]), array([2, 3, 4, 5]), array([6, 7, 8])]'''h = np.split(np.arange(9), [2, -3])print('h=',h)l_0 = np.arange(6).reshape((2, 3))l_1 = np.arange(6, 12).reshape(2, 3)print('l_0=',l_0)print('l_1=',l_1)'''vstack是指沿着纵轴拼接两个array，verticalhstack是指沿着横轴拼接两个array，horizontal更广义的拼接用concatenate实现，horizontal后的两句依次等效于vstack和hstackstack不是拼接而是在输入array的基础上增加一个新的维度'''m = np.vstack((l_0, l_1))p = np.hstack((l_0, l_1))q = np.concatenate((l_0, l_1))r = np.concatenate((l_0, l_1), axis=-1)s = np.stack((l_0, l_1))print('np.vstack((l_0, l_1))=',m)print('np.hstack((l_0, l_1))=',p)print('np.concatenate((l_0, l_1))=',q)print('np.concatenate((l_0, l_1), axis=-1) = ',r)print('np.stack((l_0, l_1)) = ',s)'''按指定轴进行转置array([[[ 0,  3],        [ 6,  9]],       [[ 1,  4],        [ 7, 10]],       [[ 2,  5],        [ 8, 11]]])'''t = s.transpose((2, 0, 1))print('s.transpose((2, 0, 1)) = ',t)'''默认转置将维度倒序，对于2维就是横纵轴互换array([[ 0,  4,  8],       [ 1,  5,  9],       [ 2,  6, 10],       [ 3,  7, 11]])'''u = a[0].transpose()    # 或者u=a[0].T也是获得转置print('u = a[0].transpose() = ',u)'''逆时针旋转90度，第二个参数是旋转次数array([[ 3,  2,  1,  0],       [ 7,  6,  5,  4],       [11, 10,  9,  8]])'''v = np.rot90(u, 3)print('np.rot90(u, 3) = ',v)'''沿纵轴左右翻转array([[ 8,  4,  0],       [ 9,  5,  1],       [10,  6,  2],       [11,  7,  3]])'''w = np.fliplr(u)print('np.fliplr(u) = ',w)'''沿水平轴上下翻转array([[ 3,  7, 11],       [ 2,  6, 10],       [ 1,  5,  9],       [ 0,  4,  8]])'''x = np.flipud(u)print('np.flipud(u) = ',x)'''按照一维顺序滚动位移array([[11,  0,  4],       [ 8,  1,  5],       [ 9,  2,  6],       [10,  3,  7]])'''y = np.roll(u, 1)print('np.roll(u, 1)', y)'''按照指定轴滚动位移array([[ 8,  0,  4],       [ 9,  1,  5],       [10,  2,  6],       [11,  3,  7]])'''z = np.roll(u, 1, axis=1)print('np.roll(u, 1, axis=1)',z)

数学运算import numpy as np# 绝对值，1a = np.abs(-1)# sin函数，1.0b = np.sin(np.pi/2)# tanh逆函数，0.50000107157840523c = np.arctanh(0.462118)# e为底的指数函数，20.085536923187668d = np.exp(3)# 2的3次方，8f = np.power(2, 3)# 点积，1*3+2*4=11g = np.dot([1, 2], [3, 4])# 开方，5h = np.sqrt(25)# 求和，10l = np.sum([1, 2, 3, 4])# 平均值，5.5m = np.mean([4, 5, 6, 7])# 标准差，0.96824583655185426p = np.std([1, 2, 3, 2, 1, 3, 2, 0])

对位运算import numpy as npa = np.array([    [1, 2, 3],    [4, 5, 6]])b = np.array([    [1, 2, 3],    [1, 2, 3]])'''维度一样的array，对位计算array([[2, 4, 6],       [5, 7, 9]])'''a + b'''array([[0, 0, 0],       [3, 3, 3]])'''a - b'''array([[ 1,  4,  9],       [ 4, 10, 18]])'''a * b'''array([[1, 1, 1],       [4, 2, 2]])'''a / b'''array([[ 1,  4,  9],       [16, 25, 36]])'''a ** 2'''array([[  1,   4,  27],       [  4,  25, 216]])'''a ** bc = np.array([    [1, 2, 3],    [4, 5, 6],    [7, 8, 9],    [10, 11, 12]])d = np.array([2, 2, 2])'''广播机制让计算的表达式保持简洁d和c的每一行分别进行运算array([[ 3,  4,  5],       [ 6,  7,  8],       [ 9, 10, 11],       [12, 13, 14]])'''c + d'''array([[ 2,  4,  6],       [ 8, 10, 12],       [14, 16, 18],       [20, 22, 24]])'''c * d'''1和c的每个元素分别进行运算array([[ 0,  1,  2],       [ 3,  4,  5],       [ 6,  7,  8],       [ 9, 10, 11]])'''c - 1

线性代数模块（linalg）在深度学习相关的数据处理和运算中，线性代数模块（linalg）是最常用的之一。结合numpy提供的基本函数，可以对向量，矩阵，或是说多维张量进行一些基本的运算。
import numpy as npa = np.array([3, 4])print('a=',a)# 求范数，默认二范数，平方和开平方print('np.linalg.norm(a) = ',np.linalg.norm(a))# 求范数，一范数，绝对值求和print('np.linalg.norm(a,ord=1) = ',np.linalg.norm(a,ord=1))# 求范数，无穷范数，绝对值中的最大者print('np.linalg.norm(a,ord=np.inf) = ',np.linalg.norm(a,ord=np.inf))b = np.array([    [1, 2, 3],    [4, 5, 6],    [7, 8, 9]])c = np.array([1, 0, 1])# 矩阵和向量之间的乘法np.dot(b, c)                    # array([ 4, 10, 16])np.dot(c, b.T)                  # array([ 4, 10, 16])np.trace(b)                     # 求矩阵的迹，15np.linalg.det(b)                # 求矩阵的行列式值，0np.linalg.matrix_rank(b)    # 求矩阵的秩，2，不满秩，因为行与行之间等差d = np.array([    [2, 1],    [1, 2]])'''对正定矩阵求本征值和本征向量本征值为u，array([ 3.,  1.])本征向量构成的二维array为v，array([[ 0.70710678, -0.70710678],       [ 0.70710678,  0.70710678]])是沿着45°方向eig()是一般情况的本征值分解，对于更常见的对称实数矩阵，eigh()更快且更稳定，不过输出的值的顺序和eig()是相反的'''u, v = np.linalg.eig(d)# Cholesky分解并重建l = np.linalg.cholesky(d)'''array([[ 2.,  1.],       [ 1.,  2.]])'''np.dot(l, l.T)e = np.array([    [1, 2],    [3, 4]])# 对不镇定矩阵，进行SVD分解并重建U, s, V = np.linalg.svd(e)S = np.array([    [s[0], 0],    [0, s[1]]])'''array([[ 1.,  2.],       [ 3.,  4.]])'''np.dot(U, np.dot(S, V))

随机模块（random）随机模块包含了随机数产生和统计分布相关的基本函数，Python本身也有随机模块random，不过功能更丰富。
import numpy as npimport numpy.random as random# 设置随机数种子，随机数确定random.seed(42)print('Random number with seed 42: ', random.random())# 产生一个1x3，[0,1)之间的浮点型随机数# array([[ 0.37454012,  0.95071431,  0.73199394]])# 后面的例子就不在注释中给出具体结果了print('random.rand(1, 3) = ',random.rand(1, 3))# 产生一个[0,1)之间的浮点型随机数print('Random number with no seed: ', random.random())# 下边4个没有区别，都是按照指定大小产生[0,1)之间的浮点型随机数array，不Pythonic…print('random.random((3, 3))=',random.random((3, 3)))print('random.sample((3, 3))=',random.sample((3, 3)))print('random.random_sample((3, 3))=',random.random_sample((3, 3)))print('random.ranf((3, 3))=',random.ranf((3, 3)))# 产生10个[1,6)之间的浮点型随机数5*random.random(10) + 1random.uniform(1, 6, 10)# 产生10个[1,6)之间的整型随机数random.randint(1, 6, 10)# 产生2x5的标准正态分布样本result = random.normal(size=(5, 2))print('random.normal(size=(5, 2))=', result)# 产生5个，n=5，p=0.5的二项分布样本random.binomial(n=5, p=0.5, size=5)a = np.arange(10)# 从a中有回放的随机采样7个random.choice(a, 7)# 从a中无回放的随机采样7个random.choice(a, 7, replace=False)# 对a进行乱序并返回一个新的arrayb = random.permutation(a)# 对a进行in-place乱序random.shuffle(a)# 生成一个长度为9的随机bytes序列并作为str返回# '\x96\x9d\xd1?\xe6\x18\xbb\x9a\xec'random.bytes(9)

Matplotlib2D图表Matplotlib中最基础的模块是pyplot。先从最简单的点图和线图开始，比如我们有一组数据，还有一个拟合模型，通过下面的代码图来可视化：
import numpy as npimport matplotlib as mplimport matplotlib.pyplot as plt# 通过rcParams设置全局横纵轴字体大小mpl.rcParams['xtick.labelsize'] = 24mpl.rcParams['ytick.labelsize'] = 24np.random.seed(42)# x轴的采样点x = np.linspace(0, 5, 100)# 通过下面曲线加上噪声生成数据，所以拟合模型就用y了……y = 2*np.sin(x) + 0.3*x**2y_data = y + np.random.normal(scale=0.3, size=100)# figure()指定图表名称plt.figure('data')# '.'标明画散点图，每个散点的形状是个圆plt.plot(x, y_data, '.')# 画模型的图，plot函数默认画连线图plt.figure('model')plt.plot(x, y)# 两个图画一起plt.figure('data &amp; model')# 通过'k'指定线的颜色，lw指定线的宽度# 第三个参数除了颜色也可以指定线形，比如'r--'表示红色虚线# 更多属性可以参考官网：http://matplotlib.org/api/pyplot_api.htmlplt.plot(x, y, 'k', lw=3)# scatter可以更容易地生成散点图plt.scatter(x, y_data)# 将当前figure的图保存到文件result.pngplt.savefig('result.png')# 一定要加上这句才能让画好的图显示在屏幕上plt.show()

对比图表点和线图表只是最基本的用法，有的时候我们获取了分组数据要做对比，柱状或饼状类型的图或许更合适。
import numpy as npimport matplotlib as mplimport matplotlib.pyplot as pltmpl.rcParams['axes.titlesize'] = 20mpl.rcParams['xtick.labelsize'] = 16mpl.rcParams['ytick.labelsize'] = 16mpl.rcParams['axes.labelsize'] = 16mpl.rcParams['xtick.major.size'] = 0mpl.rcParams['ytick.major.size'] = 0# 包含了狗，猫和猎豹的最高奔跑速度，还有对应的可视化颜色speed_map = &#123;    'dog': (48, '#7199cf'),    'cat': (45, '#4fc4aa'),    'cheetah': (120, '#e1a7a2')&#125;# 整体图的标题fig = plt.figure('Bar chart &amp; Pie chart')# 在整张图上加入一个子图，121的意思是在一个1行2列的子图中的第一张ax = fig.add_subplot(121)ax.set_title('Running speed - bar chart')# 生成x轴每个元素的位置xticks = np.arange(3)# 定义柱状图每个柱的宽度bar_width = 0.5# 动物名称animals = speed_map.keys()# 奔跑速度speeds = [x[0] for x in speed_map.values()]# 对应颜色colors = [x[1] for x in speed_map.values()]# 画柱状图，横轴是动物标签的位置，纵轴是速度，定义柱的宽度，同时设置柱的边缘为透明bars = ax.bar(xticks, speeds, width=bar_width, edgecolor='none')# 设置y轴的标题ax.set_ylabel('Speed(km/h)')# x轴每个标签的具体位置，设置为每个柱的中央ax.set_xticks(xticks+bar_width/2)# 设置每个标签的名字ax.set_xticklabels(animals)# 设置x轴的范围ax.set_xlim([bar_width/2-0.5, 3-bar_width/2])# 设置y轴的范围ax.set_ylim([0, 125])# 给每个bar分配指定的颜色for bar, color in zip(bars, colors):    bar.set_color(color)# 在122位置加入新的图ax = fig.add_subplot(122)ax.set_title('Running speed - pie chart')# 生成同时包含名称和速度的标签labels = ['&#123;&#125;\n&#123;&#125; km/h'.format(animal, speed) for animal, speed in zip(animals, speeds)]# 画饼状图，并指定标签和对应颜色ax.pie(speeds, labels=labels, colors=colors)plt.show()

在Matplotlib中，画图时有两个常用概念，一个是平时画图蹦出的一个窗口，这叫一个figure。Figure相当于一个大的画布，在每个figure中，又可以存在多个子图，这种子图叫做axes。顾名思义，有了横纵轴就是一幅简单的图表。在上面代码中，先把figure定义成了一个一行两列的大画布，然后通过fig.add_subplot()加入两个新的子图。subplot的定义格式很有趣，数字的前两位分别定义行数和列数，最后一位定义新加入子图的所处顺序，当然想写明确些也没问题，用逗号分开即可。
3D图表Matplotlib中也能支持一些基础的3D图表，比如曲面图，散点图和柱状图。这些3D图表需要使用mpl_toolkits模块。1、访问 Unofficial Windows Binaries for Python Extension Packages，下载两个文件：

pyproj-1.9.5.1-cp36-cp36m-win_amd64.whl
basemap-1.1.0-cp36-cp36m-win_amd64.whl 

2、假设下载到了D盘下，那么在D盘下打开命令行，执行
pip install pyproj-1.9.5.1-cp36-cp36m-win_amd64.whlpip install basemap-1.1.0-cp36-cp36m-win_amd64.whl

ps：相关pip命令pip list，查看安装列表pip uninstall package_name，删除包
3、示例代码
import matplotlib.pyplot as pltimport numpy as np# 3D图标必须的模块，project='3d'的定义from mpl_toolkits.mplot3d import Axes3D     np.random.seed(42)n_grids = 51            # x-y平面的格点数 c = n_grids / 2         # 中心位置nf = 2                  # 低频成分的个数# 生成格点x = np.linspace(0, 1, n_grids)y = np.linspace(0, 1, n_grids)# x和y是长度为n_grids的array# meshgrid会把x和y组合成n_grids*n_grids的array，X和Y对应位置就是所有格点的坐标X, Y = np.meshgrid(x, y)# 生成一个0值的傅里叶谱spectrum = np.zeros((n_grids, n_grids), dtype=np.complex)# 生成一段噪音，长度是(2*nf+1)**2/2noise = [np.complex(x, y) for x, y in np.random.uniform(-1,1,((2*nf+1)**2/2, 2))]# 傅里叶频谱的每一项和其共轭关于中心对称noisy_block = np.concatenate((noise, [0j], np.conjugate(noise[::-1])))# 将生成的频谱作为低频成分spectrum[c-nf:c+nf+1, c-nf:c+nf+1] = noisy_block.reshape((2*nf+1, 2*nf+1))# 进行反傅里叶变换Z = np.real(np.fft.ifft2(np.fft.ifftshift(spectrum)))# 创建图表fig = plt.figure('3D surface &amp; wire')# 第一个子图，surface图ax = fig.add_subplot(1, 2, 1, projection='3d')# alpha定义透明度，cmap是color map# rstride和cstride是两个方向上的采样，越小越精细，lw是线宽ax.plot_surface(X, Y, Z, alpha=0.7, cmap='jet', rstride=1, cstride=1, lw=0)# 第二个子图，网线图ax = fig.add_subplot(1, 2, 2, projection='3d')ax.plot_wireframe(X, Y, Z, rstride=3, cstride=3, lw=0.5)plt.show()

3D散点图3D的散点图也是常常用来查看空间样本分布的一种手段，并且画起来比表面图和网线图更加简单。
import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3Dnp.random.seed(42)# 采样个数500n_samples = 500dim = 3# 先生成一组3维正态分布数据，数据方向完全随机samples = np.random.multivariate_normal(    np.zeros(dim),    np.eye(dim),    n_samples)# 通过把每个样本到原点距离和均匀分布吻合得到球体内均匀分布的样本for i in range(samples.shape[0]):    r = np.power(np.random.random(), 1.0/3.0)    samples[i] *= r / np.linalg.norm(samples[i])upper_samples = []lower_samples = []for x, y, z in samples:    # 3x+2y-z=1作为判别平面    if z &gt; 3*x + 2*y - 1:        upper_samples.append((x, y, z))    else:        lower_samples.append((x, y, z))fig = plt.figure('3D scatter plot')ax = fig.add_subplot(111, projection='3d')uppers = np.array(upper_samples)lowers = np.array(lower_samples)# 用不同颜色不同形状的图标表示平面上下的样本# 判别平面上半部分为红色圆点，下半部分为绿色三角ax.scatter(uppers[:, 0], uppers[:, 1], uppers[:, 2], c='r', marker='o')ax.scatter(lowers[:, 0], lowers[:, 1], lowers[:, 2], c='g', marker='^')plt.show()


图像显示Matplotlib也支持图像的存取和显示，并且和OpenCV一类的接口比起来，对于一般的二维矩阵的可视化要方便很多。
import matplotlib.pyplot as plt# 读取图片并显示plt.figure('A image')result_img = plt.imread('result.png')plt.imshow(result_img)# Z是上小节生成的随机图案，img0就是Z，img1是Z做了个简单的变换img0 = Zimg1 = 3*Z + 4# cmap指定为'gray'用来显示灰度图fig = plt.figure('Auto Normalized Visualization')ax0 = fig.add_subplot(121)ax0.imshow(img0, cmap='gray')ax1 = fig.add_subplot(122)ax1.imshow(img1, cmap='gray')plt.show()

这段代码中第一个例子是读取一个本地图片并显示，第二个例子中直接把上小节中反傅里叶变换生成的矩阵作为图像拿过来，原图和经过乘以3再加4变换的图直接绘制了两个形状一样，但是值的范围不一样的图案。显示的时候imshow会自动进行归一化，把最亮的值显示为纯白，最暗的值显示为纯黑。这是一种非常方便的设定，尤其是查看深度学习中某个卷积层的响应图时。
源码分享https://github.com/voidking/udacity-python/tree/master/numpy
https://github.com/voidking/udacity-python/tree/master/matplotlib
书签给深度学习入门者的Python快速教程 - 基础篇给深度学习入门者的Python快速教程 - numpy和Matplotlib篇机器学习中的数学(5)-强大的矩阵奇异值分解(SVD)及其应用
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>python</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell实用脚本</title>
    <url>/dev-shell-script-collection/</url>
    <content><![CDATA[前言好多shell脚本，写过就扔了，感觉很可惜。本文会不断更新，用于记录自我感觉良好的脚本。以后再遇到相似的需求，方便进行参考查找。
如果想要系统学习shell脚本编程，推荐学习阮一峰前辈的《Bash 脚本教程》。shell小技巧，可以参考《Linux shell 的实用小技巧》。


短脚本查看系统版本lsb_release -a

查看命令属于哪个包1、centos
yum makecache fastyum whatprovides lsb_release

2、ubuntu
apt-get install -y apt-fileapt-file updateapt-file search ifconfig

创建用户创建voidking用户，并添加sudo权限：
useradd -m voidking -s /bin/bashpasswd voidkingadduser voidking sudo

生成密钥ssh-keygenssh-keygen -C "voidking@qq.com" -f ./voidking_rsa
第一条命令执行完之后，.ssh目录下生成了 id_rsa 和 id_rsa.pub。第二条命令执行完之后，当前目录下生成了 voidking_rsa 和 voidking_rsa.pub，注释内容为 voidking@qq.com 。
使密钥生效ssh-copy-id -i ~/.ssh/id_rsa.pub voidking@hostnamessh-copy-id -i ~/.ssh/id_rsa.pub voidking@hostname -p 22ssh voidking@hostname
ssh-copy-id 这个命令做的事情，是把 id_rsa.pub 中的内容，追加到 hostname:/home/voidking/.ssh/authorized_keys 文件中。authorized_keys文件权限为600。
压缩与解压压缩和解压tar.gz文件：
tar -czvf filename.tar.gz filenametar -xzvf filename.tar.gz

压缩和解压zip文件：
zip filename.zip filenameunzip filename.zip

加密压缩和解压zip文件：
zip -e filename.zip filenameunzip -P xxxxxx filename.zipfor i in *.zip;do unzip -P xxxxxx $i;done

解压中文名zip文件：
brew updatebrew install unarunar -e GBK 中文名.zipunar -e GBK -p xxxxxx 中文名.zipfor i in *.zip;do unar -e GBK -p xxxxxx $i;done

删除空行过滤hostlist.txt中的空行：
cat hostlist.txt |tr -s '\n'cat hostlist.txt |sed '/^$/d'cat hostlist.txt |awk '&#123;if($0!="")print&#125;'cat hostlist.txt |awk '&#123;if(length!=0) print $0&#125;'grep -v "^$" hostlist.txt# 终极方法（linux和windows空行都适用）grep -v -e '^[[:space:]]*$' hostlist.txt

过滤windows换行符在windows里编辑好的文件，上传到linux后发现多了^M。以过滤hostlist.txt中的^M为例：
sed -i 's/^M//g' hostlist.txt
注意，直接复制粘贴上面的命令是无效的。^M的输入方式是 Ctrl + V ，然后 Ctrl + M 。
去除空格去除test.txt文本中的空格：
cat test.txt | tr -d ' '

空格转换行把test.txt文本中的空格变成换行符。
cat test.txt | tr ' ' '\n'cat test.txt | sed 's/ /\n/g'

utf8 bom 转 utf8使用macos中编译运行windows下创建的java项目，报错 Error:(1, 1) java: 非法字符: ‘\ufeff’。BOM（byte order mark）是为 UTF-16 和 UTF-32 准备的，用于标记字节序（byte order）。微软在 UTF-8 中使用 BOM 是因为这样可以把 UTF-8 和 ASCII 等编码明确区分开，但这样的文件在 Windows 之外的操作系统里会带来问题。那么，怎么把utf8 bom编码文件批量转换为utf8编码文件呢？使用下面的脚本。
# 当前目录下递归所有文件grep -r -i -l $'^\xEF\xBB\xBF' . | xargs sed -i 's/^\xEF\xBB\xBF//g'# 当前目录下所有文件grep -i -l $'^\xEF\xBB\xBF' * | xargs sed -i 's/^\xEF\xBB\xBF//g'# macosbrew install gnu-sedgrep -r -i -l $'^\xEF\xBB\xBF' . | xargs gsed -i 's/^\xEF\xBB\xBF//g'grep -i -l $'^\xEF\xBB\xBF' * | xargs gsed -i 's/^\xEF\xBB\xBF//g'

GBK编码转UTF8打开一个文件，发现中文显示乱码，大概率编码问题。使用下面的命令进行转码：
iconv -f GBK -t UTF-8 inputfile &gt; outputfile

读取某一列读取第一列，读取最后一列。
echo "www.voidking.com" | awk -F'.' '&#123;print $1&#125;'echo "www.voidking.com" | awk -F'.' '&#123;print $3&#125;'echo "www.voidking.com" | awk -F'.' '&#123;print $NF&#125;'

第一列换到最后一列已知namelist.txt：
haojin 70 80voidking 90 100

需求：第一列name，在显示时放到最后一列。
cat namelist.txt | awk '&#123;for(i=2;i&lt;=NF;i++)printf("%s ", $i);print $1&#125;'

循环读取单列文本已知hostlist.txt为：
www.baidu.comwww.voidking.com

需求：批量查询主机名或者主机IP
脚本：
for i in `cat hostlist.txt`;do host $i;done

文本比较需求：两个姓名列表，需要对比出两个文件中相同的姓名和不同的姓名。
脚本：
cat file1 &gt; file.txtcat file2 &gt;&gt; file.txtcat file.txt | sort |uniq -c | sort -n &gt; result.txt

ssh执行远程命令执行远程命令很简单，直接ssh后面跟着命令就可以了。
ssh root@192.168.56.100 "echo helloworld"

那如果远程命令里面包含双引号怎么办？变成单引号，或者添加转义。
ssh root@192.168.56.100 "echo 'helloworld'"ssh root@192.168.56.100 "echo \"helloworld\""

那如果需要远程命令里使用变量怎么办？添加转义。
ssh root@192.168.56.100 "host=\$(hostname);echo \"\$&#123;host&#125;\""

批量添加开机启动命令已知主机列表hosts.txt内容为：
192.168.56.101192.168.56.102

需求：给主机列表中的机器添加开机启动命令
脚本：
for i in `cat hosts.txt`; do ssh $i "echo '/home/voidking/start.sh' | sudo tee -a /etc/rc.local";done

curl不输出错误和进度# 不输出错误和进度curl -s "https://www.voidking.com"curl -sX GET "https://www.voidking.com"# 不产生任何输出curl -s -o /dev/null "https://www.voidking.com"
更多内容参考 curl的用法指南。
curl post请求带参数1、application/x-www-form-urlencoded请求：
id=1ip=10.0.0.1curl -X POST "http://rap2api.taobao.org/app/mock/241888/updateip" -d "id=$&#123;id&#125;&amp;ip=$&#123;ip&#125;"

2、application/json请求：
curl -X POST "http://rap2api.taobao.org/app/mock/241888/updateip" -H "Content-type: application/json" -d '&#123;"id":"'$&#123;id&#125;'","ip":"'$&#123;ip&#125;'"&#125;' # orcurl -X POST "http://rap2api.taobao.org/app/mock/241888/updateip" -H "Content-type: application/json" -d@data.json# data.json是大文件curl -X POST "http://rap2api.taobao.org/app/mock/241888/updateip" -H "Content-type: application/json" -H "Expect:" -d@data.json

其中data.json中的内容为：
&#123;  "id":1,  "ip":"10.0.0.1"&#125;

3、multipart/form-data请求：
curl -X POST http://rap2api.taobao.org/app/mock/241888/updateip -F "id=$&#123;id&#125;" -F "filename=@file.tar.gz"

curl 设置超时curl -m 15 -s "https://www.voidking.com"

EPEL源EPEL（ExtraPackagesforEnterpriseLinux）是基于Fedora的一个项目，为RedHat系的操作系统提供额外的高质量软件包。yum install epel-release
安装epel源之后，可以安装很多原本 No package xxx available 的软件，比如jq：yum install jq
联合查询使用shell，能否实现类似于SQL的联合查询？必须可以。
已知file1的内容为：
1 realname2 nickname
file2的内容为：
voidking nicknamehaojin realnamehankin nicknamejinhao realnamevk nickname

需求：根据file1和file2的第二列，把file1和file2合并成一个文件。
2 voidking nickname1 haojin realname2 hankin nickname1 jinhao realname2 vk nickname

这个需求使用awk命令来实现。NR，表示awk开始执行程序后所读取的数据行数。FNR，与NR功用类似，不同的是awk每打开一个新文件，FNR便从0重新累计。NR==FNR：用于在读取两个或两个以上的文件时，判断是不是在读取第一个文件。awk处理多个文件的语法：
awk -F 分隔符 'BEGIN &#123; 初始化 &#125; &#123; 循环执行部分 &#125; END &#123; 结束处理 &#125;' file_list1 file_list2
其中BEGIN和END可以省略，-F也可以使用默认，循环执行部分，是按行对文件进行处理的。
脚本：
awk -F " " 'NR==FNR&#123;a[$2]=$0;next&#125;&#123;print a[$2]" "$1&#125;' file1 file2 \| awk '&#123;print $1" "$3" "$2&#125;'
由NR=FNR为真时，判断当前读入的是第一个文件file1，执行第一个花括号内的内容。把file1中每行记录都存入数组a，并使用file1的第2个字段作为下标。
由NR=FNR为假时，判断当前读入了第二个文件file2，执行第二个花括号内的内容。file2中的每行，根据file2的第2个字段打印数组a中的内容，同时打印file2中的第一列。
求交集已知file1内容为：
haojinvoidkingvk

file2内容为：
haoshuai 95 93 80vk 99 99 100haojin 100 100 99baidu 100 100 100voidking 99 99 99

需求：file1第一列和file2第一列求交集，显示file2中交集的内容。
awk '&#123;if(NR==FNR)&#123;a[$1]=$1&#125;else if($1 in a)&#123;print $0&#125;&#125;' file1 file2# orawk '&#123;if(NR==FNR)a[$1]=$1;else if($1 in a)print $0&#125;' file1 file2

每两行合成一行已知ip-port.txt内容为：
127.0.0.180127.0.0.18080192.168.56.1013306

需求：把ip和对应端口放在同一行。
127.0.0.1 80127.0.0.1 8080192.168.56.101 3306

脚本：
sed -n "N;s/\n/ /p" ip-port.txtawk 'NR%2&#123;printf "%s ",$0;next;&#125;1' ip-port.txtawk 'ORS=NR%2?FS:RS' ip-port.txtawk '&#123; ORS = (NR%2 ? FS : RS) &#125; 1' ip-port.txtawk '&#123; ORS = (NR%2 ? "," : RS) &#125; 1' ip-port.txt

删除10天前的日志需求：找出10天前的日志并删除。脚本：
find /usr/local/tomcat/logs/ -type f -mtime +10 -exec rm -rfv &#123;&#125; \;find /usr/local/tomcat/logs/ -type f -mtime +10 | xargs rm -rfv

计算一列的和已知fruit.txt内容为：
apple 10orange 7banana 0watermelon 1
第一列是水果名称，第二列是水果数量。
需求1：计算水果的总数。
awk '&#123;sum += $2&#125;;END &#123;print sum&#125;' fruit.txtcat fruit.txt | awk '&#123;sum += $2&#125;;END &#123;print sum&#125;'

需求2：计算存在多少种水果。
cat fruit.txt | awk '&#123;if ($2&gt;0) (sum += 1); else (sum += 0)&#125;;END&#123;print sum&#125;'

重定向0 标准输入1 标准输出，默认指向屏幕2 错误输出，默认指向屏幕/dev/null 黑洞
# 标准输出重定向到文件ls &gt;out.txtcat out.txt# 等同于ls 1&gt;out.txtcat out.txt# 错误输出重定向到文件ls 2&gt;out.txtcat out.txtls xxx 2&gt;out.txtcat out.txt# 标准输出和错误输出都重定向到文件(ls xxx || ls) &gt;out.txt 2&gt;&amp;1cat out.txt# 等同于(ls xxx || ls) &amp;&gt;out.txtcat out.txt# 标准输出和错误输出都丢弃(ls xxx || ls) &amp;&gt;/dev/null# 等同于(ls xxx; ls) &amp;&gt;/dev/null

输出到屏幕和文件输出内容同时到屏幕和文件：
echo "hello" | tee test.log

清空文件内容需求：清空text.txt文件中的内容脚本：
echo "" &gt; test.txtecho -n "" &gt; test.txtcat /dev/null &gt; test.txt:&gt; test.txt

测试mtu值MTU是Maximum Transmission Unit的缩写，表示最大传输单元，MTU的单位是字节。大部分网络设备的MTU都是1500。把本机的MTU设成比网关的MTU小或相同，就可以减少丢包。如果本机的MTU比网关的MTU大，大的数据包就会被拆开来传送，这样会产生很多数据包碎片，增加丢包率。把数据包长度加上数据包头28字节，就得到MTU的值。
ping -c 3 -s 1472 -M do www.baidu.comping -c 3 -s 1473 -M do www.baidu.com

获取脚本绝对路径scriptpath=$(cd "$(dirname "$0")"; pwd)

时间和时间戳# 输出时间date# 输出时间并格式化date "+%Y-%m-%d %H:%M:%S"# 时间转时间戳（秒）date "+%s"# 时间转时间戳（微秒）microsecond=$(($(date "+%s%N")/1000000))# 时间戳（秒）转时间date -d @1612351314 "+%Y-%m-%d %H:%M:%S"

根据端口找进程已知某进程监听22端口，怎样找到该进程的pid？怎样找到该进程启动命令？
lsof -i:22netstat -npt | grep ":22"netstat -nlpt | grep ":22"ps -ef |grep $pid

查看外网出口IPcurl myip.ipip.net
cp须知unalias cp #避免cp命令被aliascp -f #强制覆盖cp -R #递归拷贝所有文件。对特殊文件（管道文件、块设备文件、字符设备文件）会进行创建而不是拷贝。cp -r #递归拷贝所有文件。所有source文件当做普通文件。cp -rf public/* voidking #递归拷贝所有文件，不包括隐藏文件cp -rf public/. voidking #递归拷贝所有文件，包括隐藏文件

匹配排除.和..当前目录下，一定存在两个目录：.和..。有一些操作我们需要排除这两个目录，怎样匹配排除它们呢？
ls -als -a | xargsls -a | wc -lls -a | grep -vw '\.'ls -a | grep -vw '[.]'ls -a | grep -v '^.$' | grep -v '^..$'

cp排除目录需求：源目录为dirA，目标目录dirB，复制dirA下所有目录&amp;文件到dirB，排除目录log方法一：不包含隐藏文件
cd dirAls | grep -v log | xargscp -r `ls | grep -v log | xargs` pathto/dirB

方法二：包含隐藏文件
cd dirAls -a | grep -vw '\.' | grep -v log | xargscp -r `ls -a | grep -vw '\.' | grep -v log | xargs` pathto/dirB

rm排除目录需求：想要删除dirA目录下的所有目录和文件，除了.git目录
cd dirAls -a | grep -vw '\.' | grep -vw '\.git' | xargsrm -rf `ls -a | grep -vw '\.' | grep -vw '\.git' | xargs`

tar排除目录需求：打包目录dirA下所有目录&amp;文件，排除目录dirA/log和dirA/data
tar -czvf dirA.tar.gz dirA --exclude dirA/log --exclude dirA/data

tar文件拆分与合并使用sz传输大文件，有时候会被中断。这时我们可以把文件进行拆分，下载后再进行合并。
tar -czf - bigfile.tar.gz | split -b 50m -d - bigfile.tar.gz.cat bigfile.tar.gz.* | tar -xzf -md5sum bigfile.tar.gz

启动python web服务器使用sz传输大文件，有时候会被中断。这时我们可以启动一个web服务，把大文件作为静态资源下载。
python -m SimpleHTTPServer 9999
然后浏览器输入ip:port，即可下载文件。
断点续传参考 rsync
rsync -P source destination

-P是两个参数的集合：–partial 和 –progress
–partial：保留部分传输的文件，也就是实现断点续传功能
–progress：显示进度

长脚本文件拆分需求1：大文件拆分成小文件，每50行拆分成一个文件。脚本1：
#!/bin/bashlinenum="50"bigfile="bigfile.txt"datadir="files"prefix="smallfile."mkdir -p $&#123;datadir&#125;split -l $&#123;linenum&#125; $&#123;bigfile&#125; -d -a 2 $&#123;datadir&#125;/$&#123;prefix&#125;

需求2：大文件拆分成小文件，方便按比例进行变更。脚本2：
#!/bin/bashpercent="50"#percent="34"bigfile="bigfile.txt"datadir="file"prefix="smallfile."rm -rf $&#123;datadir&#125;/$&#123;prefix&#125;*mkdir -p $&#123;datadir&#125;content=$(cat $&#123;bigfile&#125;)sum=$(echo "$&#123;content&#125;" | wc -l)linenum=$(($&#123;sum&#125;*$&#123;percent&#125;/100))split -l $&#123;linenum&#125; $&#123;bigfile&#125; -d -a 2 $&#123;datadir&#125;/$&#123;prefix&#125;

还原history万万没想到，centos4.3的history -c命令，不止会清除当前登录的操作历史记录，还会清除 .bash_history 中的内容。
如果不小心清除了 .bash_history 中的内容，该怎么办？如果屏幕上还残留着history的历史记录，那么还有得救。拷贝屏幕上的内容，到 history.txt，假设内容为：
244486  2021-01-08 17:35:18 cd haojin244487  2021-01-08 17:36:01 vim main.py244488  2021-01-08 17:38:33 python main.py

怎么恢复成标准的 .bash_history 格式呢？使用如下脚本：
#!/bin/bashcat /dev/null &gt; bash_historywhile read linedo  time=$(echo $line | awk '&#123;print $2" "$3&#125;')  #cmd=$(echo $line | awk '&#123;$1="";$2="";$3="";print $0&#125;')  cmd=$(echo $line | awk -F " "  '&#123;for (i=4;i&lt;=NF;i++)printf("%s ", $i);print ""&#125;')  timestamp=$(date -d "$time" +%s)  echo "#"$timestamp &gt;&gt; bash_history  echo $cmd &gt;&gt; bash_historydone &lt; history.txt

执行完成，使用 bash_history 替换 .bash_history 即可。
执行SQL语句需求：mysql数据库，获取数据库vk中的app表中所有记录的name，写入到 name.txt 文件。
脚本：
#!/bin/bashget_all_name="select name from app where app.deleted=0;"all_name=$(mysql -h192.168.56.100 -uroot -pmypassword -s -e "use vk;$&#123;get_all_name&#125;")echo "$&#123;all_name&#125;" &gt; name.txt

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>shell</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring概述</title>
    <url>/dev-spring-start/</url>
    <content><![CDATA[名词解释简单来说，Spring是一个轻量级的控制反转（IoC）和面向切面（AOP）的容器框架。
Spring框架是Rod Johnson开发的，2003年发布了Spring框架的第一个版本。Spring是一个从实际开发中抽取出来的框架，因此它完成了大量开发中的通用步骤，从而大大提高了企业应用的开发效率。
Spring为企业应用的开发提供了一个轻量级的解决方案。其中依赖注入、基于AOP的声明式事务管理、多种持久层的整合与优秀的Web MVC框架等最为人们关注。Spring可以贯穿程序的各层之间，但它并不是要取代那些已有的框架，而是以高度的开发性与它们紧密地整合，这也是Spring被广泛应用的原因之一。
Spring使用最基本的JavaBean来完成以前只可能由EJB完成的事情。然而，Spring的用途不仅限于服务器端的开发。从简单性、可测试性和松耦合性的角度而言，任何Java应用都可以从Spring中受益。
官网http://spring.io

下载方法一http://repo.spring.io搜索spring-framework，选择下载即可。
方法二1)打开eclipse-help-Install New Software…2)Add…，弹出Add Repository。4)对话框里Name随意，Location输入：http://springide.org/updatesite/ ，点击OK。5)选择Core/Spring IDE，Next。
导入包Spring4的包，官方没有给出下载，只给出了Maven的引用方法，个人感觉非常好。Spring3及以前的包，可以使用Maven引用，也可以下载后导入jar包。
spring-framework-.zip解压后,将spring-framework-文件夹的dist目录下的jar包导入工程中。
分层架构Spring框架的主要优势之一是其分层架构，分层架构允许选择使用任何一个组件，同时为J2EE应用程序开发提供集成的框架。Spring框架的功能可以用在任何J2EE服务器中，大多数功能也适用于不受管理的环境。Spring的核心要点是：支持不绑定到特定J2EE服务的可重用业务和数据访问对象。这样的对象可以在不同J2EE环境（Web或EJB）、独立应用程序、测试环境之间重用。
组成Spring 框架的每个模块（或组件）都可以单独存在，或者与其他一个或多个模块联合实现。每个模块的功能如下：

核心容器：核心容器提供Spring 框架的基本功能。核心容器的主要组件是BeanFactory，它是工厂模式的实现。BeanFactory使用控制反转（IOC）模式将应用程序的配置和依赖性规范与实际的应用程序代码分开。

Spring 上下文：Spring 上下文是一个配置文件，向Spring 框架提供上下文信息。Spring 上下文包括企业服务，例如JNDI 、EJB、电子邮件、国际化、校验和调度功能。

Spring AOP ：通过配置管理特性，Spring AOP 模块直接将面向方面的编程功 能集成到了Spring 框架中。所以，可以很容易地使Spring 框架管理的任何对象支持AOP 。Spring AOP 模块为基于Spring 的应用程序中的对象提供了事务管理服务。通过使用Spring AOP ，不用依赖EJB 组件，就可以将声明性事务管理集成到应用程序中。

Spring DAO ：JDBC DAO抽象层提供了有意义的异常层次结构，可用该结构来管理异常处理和不同数据库供应商抛出的错误消息。异常层次结构简化了错误处理，并且极大地降低了需要编写的异常代码数量（例如打开和关闭连接）。Spring DAO 的面向JDBC 的异常遵从通用的DAO 异常层次结构。

Spring ORM ：Spring 框架插入了若干个ORM 框架，从而提供了ORM 的对象关系工具，其中包括JDO 、Hibernate 和iBatisSQLMap 。所有这些都遵从Spring 的通用事务和DAO异常层次结构。

Spring Web：为基于Web的应用程序提供上下文。它建立在应用程序上下文模块之上，简化了处理多份请求及将请求参数绑定到域对象的工作。Spring框架支持Jakarta Struts的集成。

Spring Web MVC：是一个全功能Web应用程序的MVC实现。通过策略接口实现高度可配置，MVC容纳了大量视图技术，其中包括JSP、Velocity、Tiles、iText和POI。


依赖注入Spring的核心机制是依赖注入（Dependency Inversion），也称为控制反转。
工厂模式Human.javapackage com.voidking.factory;public interface Human &#123;	void eat();	void walk();&#125;

Chinese.javapackage com.voidking.factory;public class Chinese implements Human &#123;	@Override	public void eat() &#123;		// TODO Auto-generated method stub		System.out.println("中国人很会吃！");	&#125;	@Override	public void walk() &#123;		// TODO Auto-generated method stub		System.out.println("中国人健步如飞！");	&#125;&#125;
American.javapackage com.voidking.factory;public class American implements Human &#123;	@Override	public void eat() &#123;		// TODO Auto-generated method stub		System.out.println("美国人吃西餐！");	&#125;	@Override	public void walk() &#123;		// TODO Auto-generated method stub		System.out.println("美国人经常坐车！");	&#125;&#125;

Factory.javapackage com.voidking.factory;public class Factory &#123;	public Human getHuman(String name)	&#123;		if(name.equals("Chinese"))		&#123;			return new Chinese();		&#125;else if (name.equals("American")) &#123;			return new American();		&#125;else &#123;			throw new IllegalArgumentException("参数不正确");		&#125;	&#125;&#125;

Test.javapackage com.voidking.factory;public class Test &#123;	public static void main(String[] args) &#123;		Human human=null;		human= new Factory().getHuman("Chinese");		human.eat();		human.walk();				human= new Factory().getHuman("American");		human.eat();		human.walk();	&#125;&#125;

依赖注入应用上面工厂模式中，甲组件需要乙组件的对象的时候，无需直接创建其实例，而是通过工厂获得，只要创建一个工厂即可。而Spring容器则提供了更好的办法，开发人员不用创建工厂，可以直接使用Spring提供的依赖注入方式。可以把上例修改为使用Spring容器来创建对象。
引入Spring的jar包spring.jar、spring-source.jar、commons-logging.jar。
applicationContext.xml在src文件夹下，新建文件applicationContext.xml，内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--  - Middle tier application context definition for the image database.  --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"		xmlns:context="http://www.springframework.org/schema/context"		xmlns:tx="http://www.springframework.org/schema/tx"		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;	&lt;bean id="chinese" class="com.voidking.factory.Chinese"&gt;&lt;/bean&gt;	&lt;bean id="american" class="com.voidking.factory.American"&gt;&lt;/bean&gt;	&lt;/beans&gt;

修改Test.javapackage com.voidking.factory;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class Test &#123;	public static void main(String[] args) &#123;		/*		Human human=null;		human= new Factory().getHuman("Chinese");		human.eat();		human.walk();				human= new Factory().getHuman("American");		human.eat();		human.walk();		*/				ApplicationContext ctx = new FileSystemXmlApplicationContext("src/applicationContext.xml");		Human human = null;		human =(Human)ctx.getBean("chinese");		human.eat();		human.walk();		human = (Human)ctx.getBean("american");		human.eat();		human.walk();	&#125;&#125;
所谓依赖注入，就是在运行的过程中，如果需要调用另一个对象协助时，无需在代码中创建被调用者，而是依赖于外部的注入。Spring的依赖注入对调用者和被调用者几乎没有任何要求，完全支持POJO之间依赖关系的管理。依赖注入通常有两种：
设置注入设置注入是通过set方法注入被调用者的实例。这种方法简单、直观，很容易理解，因而Spring的依赖注入被大量使用。
Human.javapackage com.voidking.dependencyinversion;public interface Human &#123;	void speak();&#125;

Languige.javapackage com.voidking.dependencyinversion;public interface Languige &#123;	public String kind();&#125;

Chinese.javapackage com.voidking.dependencyinversion;public class Chinese implements Human &#123;		private Languige lan;	@Override	public void speak() &#123;		// TODO Auto-generated method stub		System.out.println(lan.kind());	&#125;	public void setLan(Languige lan) &#123;		this.lan = lan;	&#125;&#125;

English.javapackage com.voidking.dependencyinversion;public class English implements Languige &#123;	@Override	public String kind() &#123;		// TODO Auto-generated method stub		return "中国人也会说英语！";	&#125;&#125;

applicationContext.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--  - Middle tier application context definition for the image database.  --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"		xmlns:context="http://www.springframework.org/schema/context"		xmlns:tx="http://www.springframework.org/schema/tx"		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;	&lt;bean id="chinese" class="com.voidking.dependencyinversion.Chinese"&gt;		&lt;property name="lan" ref="english"&gt;&lt;/property&gt;	&lt;/bean&gt;		&lt;bean id="english" class="com.voidking.dependencyinversion.English"&gt;&lt;/bean&gt;&lt;/beans&gt;
各个Bean之间的依赖关系放在配置文件中完成，而不是用代码体现。通过配置文件，Spring能精确地为每个Bean注入属性。注意，配置文件的Bean的class属性值，不能是接口，必须是真正的实现类。
Spring会自动接管每个Bean定义里的property元素定义。Spring会在执行无参数的构造器并创建默认的Bean实例后，调用对应的set方法为程序注入属性值。
每个Bean的id属性是该Bean的唯一标识，程序通过id属性访问Bean。而且各个Bean之间的依赖关系也通过id属性关联。
Test.javapackage com.voidking.dependencyinversion;import org.springframework.context.ApplicationContext;import org.springframework.context.support.FileSystemXmlApplicationContext;public class Test &#123;	public static void main(String[] args) &#123;		ApplicationContext ctx = new FileSystemXmlApplicationContext("src/applicationContext.xml");		Human human = null;		human =(Human)ctx.getBean("chinese");		human.speak();	&#125;&#125;


构造注入在构造实例时，已经为其完成了属性的初始化，利用构造函数来设置依赖注入的方法，成为构造注入。在前面dependencyinversion工程的基础上修改。
修改Chinese.javapackage com.voidking.dependencyinversion2;public class Chinese implements Human &#123;		private Languige lan;		public Chinese() &#123;		super();		// TODO Auto-generated constructor stub	&#125;	public Chinese(Languige lan) &#123;		super();		this.lan = lan;	&#125;	@Override	public void speak() &#123;		// TODO Auto-generated method stub		System.out.println(lan.kind());	&#125;&#125;

修改applicationContext.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!--  - Middle tier application context definition for the image database.  --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"		xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"		xmlns:context="http://www.springframework.org/schema/context"		xmlns:tx="http://www.springframework.org/schema/tx"		xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd				http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd				http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"&gt;	&lt;bean id="chinese" class="com.voidking.dependencyinversion2.Chinese"&gt;		&lt;constructor-arg ref="english"&gt;&lt;/constructor-arg&gt;	&lt;/bean&gt;		&lt;bean id="english" class="com.voidking.dependencyinversion2.English"&gt;&lt;/bean&gt;&lt;/beans&gt;
设置注入和构造注入，区别在于创建Human实例中的Languige属性的时间不同。（呃，前面命名的时候搞错了，Language写成了Languige，领会精神。。。）设置注入是先创建一个默认的Bean实例，然后调用对应的set方法注入依赖关系；而构造注入则在创建Bean实例时，已经完成了依赖关系的注入。
Spring核心接口BeanFactoryBean工厂，由org.springframework.beans.factory.BeanFactory接口定义。
BeanFactory采用工厂设计模式。这个接口负责创建和分发Bean，但与其他工厂模式的实现不同，它们只分发一种类型的对象。BeanFactory是一个通用的工厂，可以创建和分发各种类型的Bean。
在Spring中有几种BeanFactory的实现，其中最常用的是org.springframework.bean.factory.xml.XmlBeanFactory。它根据XML文件中的定义装载Bean。
要创建XMLBeanFactory，需要传递一个java.io.InputStream对象给构造函数。InputStream对象提供XML文件给工厂。例如，下面的例子使用一个java.io.FileInputStream对象把Bean XML定义文件给XMLBeanFactory：
BeanFactory factory = new XmlBeanFactory(new FileInputStream("applicationContext.xml"));
这行代码告诉BeanFactory从XML文件中读取Bean的定义信息，但是现在BeanFactory没有实例化Bean，Bean被延迟加载到BeanFactory中，就是说BeanFactory会立即把Bean定义信息加载进来，但是Bean只有在需要的时候才被实例化。
为了从BeanFactory得到Bean，只要简单地调用getBean()方法，把需要的Bean的名字当做参数传递进去就行了。由于得到的是Object类型，所以要进行强制类型转化。
MyBean myBean = (MyBean)factory.getBean("myBean");
当getBean()方法被调用时，工厂就会实例化Bean，并使用依赖注入开始设置Bean的属性。这样就在Spring容器中开始了Bean的生命周期。
ApplicationContext应用上下文，由org.springframework.context.ApplicationContext接口定义，是BeanFactory的子接口。
BeanFactory对简单应用来说已经很好了，但是为了获得Spring框架的强大功能，需要使用Spring更高级的容器——ApplicationContext。
表面上，ApplicationContext和BeanFactory差不多。两者都是载入Bean定义信息，装配Bean，根据需要分发Bean。但是ApplicationContext提供了更多功能：1、应用上下文提供了文本解析工具，包括对国际化的支持。2、应用上下文提供了载入文本资源的通用方法，如载入图片。3、应用上下文可以向注册为监听器的Bean发送事件。
由于它提供了附加功能，几乎所有的应用系统都选择ApplicationContext，而不是BeanFactory。
在ApplicationContext的诸多实现中有三个常用的实现：
ApplicationContext context = new FileSystemXmlApplicationContext("c:/foo.xml");ApplicationContext context = new FileSystemXmlApplicationContext("foo.xml");ApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(request.getSession().getServletContext());
FileSystemXmlApplicationContext只能在指定的路径中寻找foo.xml文件，而FileSystemXmlApplicationContext可以在整个类路径中寻找foo.xml。
ApplicationContext与BeanFactory的另一个重要区别是单实例Bean如何被加载。BeanFactory延迟加载所有Bean，直到getBean()被调用时，Bean才被创建。ApplicationContext则聪明一点，它会在上下文启动后预载入所有的单实例Bean。通过预载入单实例Bean，确保需要的时候它们已经准备好了，应用程序不需要等待它们被创建。
Spring基本配置在Spring容器中拼接Bean叫做装配。装配Bean实际上是告诉容器需要哪些Bean，以及容器如何使用依赖注入，将它们配合起来。
使用XML装配理论上，Bean装配可以从任何配置资源获得。但实际上，XML是最常见的Spring应用系统配置源。
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans...&gt;	&lt;bean id="chinese" class="com.voidking.factory.Chinese"&gt;&lt;/bean&gt;	&lt;bean id="american" class="com.voidking.factory.American"&gt;&lt;/bean&gt;	&lt;/beans&gt;
在XML文件定义Bean，上下文定义文件的根元素是。有多个子元素，每个元素定义了一个Bean（任何一个Java对象）如何被装配到Spring容器中。
添加一个Bean在Spring中对一个Bean的最基本配置包括Bean的id和它的全称类名。向Spring容器中添加一个Bean只需要向XML文件中添加一个元素。
当通过Spring容器创建一个Bean时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。
1、原型模式与单实例模式：Spring中的Bean默认情况下是单实例模式。在容器分配Bean的时候，它总是返回同一个实例。但是，如果每次向ApplicationContext请求一个Bean的时候需要得到一个不同的实例，需要将Bean定义为原型模式。
&lt;bean id="chinese" class="com.voidking.factory.Chinese" singleton="false"&gt;&lt;/bean&gt; //原型模式Bean
2、request或session：对于每次HTTP请求或HttpSession，使用request或session定义的Bean都将产生一个新实例，即每次HTTP请求或HttpSession将会产生不同的Bean实例。只有在Web应用中使用Spring时，该作用域有效。
3、golbal session：每个全局的HttpSession对应一个Bean实例。典型情况下，仅在使用portlet context的时候有效。只有在Web应用中使用Spring时，该作用域才有效。
当一个Bean实例化的时候，有事需要做一些初始化的工作，然后才能使用。同样，当Bean不再需要，从容器中删除时，需要按顺序做一些清理工作。因此，Spring可以在创建和拆卸Bean的时候调用Bean的两个生命周期方法。
在Bean的定义中设置自己的init-method，这个方法在Bean被实例化时马上被调用。同样，也可以设置自己的destroy-method，这个方法在Bean从容器中删除之前调用。
一个典型的例子是连接池Bean：
public class MyConnectionPool&#123;	...	public void initailize()&#123;&#125;	public void close()&#123;&#125;	....&#125;
Bean的定义如下：
&lt;bean id="connectionPool" class="com.voidking.test.MyConnectionPool" init-method="initialize" destroy-method="close"&gt;&lt;/bean&gt;
MyConnectionPool被实例化后，initialize方法马上被调用，给Bean初始化的机会。在Bean从容器中删除前，close方法将释放数据库连接。
源代码分享https://github.com/voidking/factory.git
https://github.com/voidking/dependencyinversion.git
https://github.com/voidking/dependencyinversion2.git
参考文档《Java EE基础实用教程》，郑阿奇主编

J2EE 领域的一些技术框架结构图http://www.oschina.net/question/28_47106

Caused by:java.lang.ClassNotFoundException: org.apache.commons.logging.LogFactoryhttp://blog.csdn.net/liuxilil/article/details/5734079

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>thinkphp和angularjs整合</title>
    <url>/dev-thinkphp-and-angularjs/</url>
    <content><![CDATA[前言为了前后端分离的更彻底，便于前后端独立开发，小太阳项目，计划使用thinkphp+angular。后端专注写接口，前端负责页面渲染。


项目分割项目分成三个子系统：业主端、物业端、CMS端。每个子系统分别有前端和后端，前端使用angular，后端使用thinkphp。自此，产生了六个子项目，分别命名为owner-fd、owner-bd、manager-fd、manager-bd、cms-fd和cms-bd。接下来，我们以cms-fd和cms-bd为例，来说明angular和thinkphp之间的交互。
添加业主信息业务逻辑：在添加业主信息页面，填写业主信息的表单，填写完成后单击“确认添加”按钮，发送http请求给后端。后端把获取到的数据存到数据库中，并且返回值给前端，前端提示成功或失败。
angular部分1、入口html
&lt;!--cms-fd/index.html--&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;head&gt;    &lt;meta charset="UTF-8"&gt;    &lt;link rel="stylesheet" href="public/libs/bootstrap/dist/css/bootstrap.min.css"&gt;    &lt;link rel="stylesheet" href="public/libs/layer/skin/layer.css"&gt;    &lt;link rel="stylesheet" href="public/css/index.css"&gt;    &lt;title&gt;CMS系统&lt;/title&gt;&lt;/head&gt;&lt;body ng-app="myApp"&gt;    &lt;ul class="navigator nav nav-pills" ng-controller="MainCtroller"&gt;        &lt;li role="presentation" ng-class="&#123;active:'home' == currentTab&#125;"&gt;            &lt;a ui-sref="home" ng-click="changeTab('home')"&gt;首页&lt;/a&gt;        &lt;/li&gt;        &lt;li role="presentation" ng-class="&#123;active:'ownerList' == currentTab&#125;"&gt;            &lt;a ui-sref="ownerList" ng-click="changeTab('ownerList')"&gt;业主信息列表&lt;/a&gt;        &lt;/li&gt;        &lt;li role="presentation" ng-class="&#123;active:'ownerAdd' == currentTab&#125;"&gt;            &lt;a ui-sref="ownerAdd" ng-click="changeTab('ownerAdd')"&gt;添加业主信息&lt;/a&gt;        &lt;/li&gt;    &lt;/ul&gt;    &lt;div ui-view style="width: 500px;margin: 50px auto 0"&gt;&lt;/div&gt;&lt;script src="public/libs/angular/angular.min.js"&gt;&lt;/script&gt;&lt;script src="public/libs/angular-ui-router/release/angular-ui-router.min.js"&gt;&lt;/script&gt;&lt;script src="public/libs/oclazyload/dist/ocLazyLoad.min.js"&gt;&lt;/script&gt;&lt;script src="public/libs/jquery/dist/jquery.min.js"&gt;&lt;/script&gt;&lt;script src="public/libs/layer/layer.js"&gt;&lt;/script&gt;&lt;script src="public/js/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;

2、入口js
/* *cms-fd/public/js/index.js*/var myApp = angular.module('myApp',['ui.router','oc.lazyLoad']);myApp.config(function ($stateProvider,$urlRouterProvider) &#123;    $urlRouterProvider.when('','/home');    $stateProvider.state('home',&#123;        url:'/home',        templateUrl: 'views/home.html',        resolve:&#123;            loadMyCtrl:['$ocLazyLoad',function ($ocLazyLoad) &#123;                return $ocLazyLoad.load(&#123;                    name:'homeController',                    files:['public/js/home.js']                &#125;)            &#125;]         &#125;    &#125;);    $stateProvider.state('ownerList',&#123;        url:'/ownerList',        templateUrl:'views/owner/list.html',        resolve:&#123;            loadMyCtrl:function ($ocLazyLoad) &#123;                return $ocLazyLoad.load(&#123;                    name:'ownerListController',                    files:['public/js/owner/list.js']                &#125;)            &#125;        &#125;    &#125;);    $stateProvider.state('ownerAdd',&#123;        url: '/ownerAdd',        templateUrl: 'views/owner/add.html',        resolve:&#123;            loadMyCtrl:function ($ocLazyLoad) &#123;                return $ocLazyLoad.load(&#123;                    name:'ownerAddController',                    files:['public/js/owner/add.js']                &#125;)            &#125;        &#125;    &#125;);    $stateProvider.state('ownerEdit',&#123;        url: '/owner/edit/:ownerId',        templateUrl: 'views/owner/edit.html',        resolve:&#123;            loadMyCtrl:function ($ocLazyLoad) &#123;                return $ocLazyLoad.load(&#123;                    name:'ownerEditController',                    files:['public/js/owner/edit.js']                &#125;)            &#125;        &#125;    &#125;);    &#125;);myApp.controller('MainCtroller',function($scope,$location)&#123;    //console.log($location.url());    var url = $location.url();    $scope.currentTab = url.substr(1);    $scope.changeTab = function(tabname)&#123;          $scope.currentTab = tabname;    &#125;;  &#125;);

3、添加业主信息页面
&lt;!--cms-fd/views/owner/add.html--&gt;&lt;div id="home" ng-controller="ownerAddController"&gt;    &lt;h2&gt;添加业主信息&lt;/h2&gt;    &lt;form role="form"&gt;        &lt;div class="form-group"&gt;            &lt;label for=""&gt;用户名&lt;/label&gt;            &lt;input name="username" type="text" class="form-control username" id="" ng-model="username"&gt;        &lt;/div&gt;        &lt;div class="form-group"&gt;            &lt;label for=""&gt;密码&lt;/label&gt;            &lt;input name="password" type="password" class="form-control password" id="" ng-model="password"&gt;        &lt;/div&gt;        &lt;div class="form-group"&gt;            &lt;label for=""&gt;邮箱&lt;/label&gt;            &lt;input name="password" type="email" class="form-control email" id="" ng-model="email"&gt;        &lt;/div&gt;        &lt;div class="form-group"&gt;            &lt;label for=""&gt;昵称&lt;/label&gt;            &lt;input name="nickname" type="text" class="form-control nickname" id="" ng-model="nickname"&gt;        &lt;/div&gt;        &lt;button type="submit" class="btn btn-primary submit" ng-click="submit()"&gt;确认添加&lt;/button&gt;    &lt;/form&gt;&lt;/div&gt;

3、添加业主信息页面js
/* *cms-fd/public/js/owner/add.js*/angular.module('myApp').controller('ownerAddController', function ($scope,$http,$httpParamSerializer) &#123;     $scope.submit = function()&#123;        var param = &#123;            username: $scope.username,            password: $scope.password,            email: $scope.email,            nickname: $scope.nickname        &#125;;        $http(&#123;            method:'POST',            url:'/cms-bd/index.php/Home/Owner/add',            headers:&#123;                'Content-Type':'application/x-www-form-urlencoded'            &#125;,            dataType: 'json',            data: $httpParamSerializer(param)        &#125;).then(function successCallback(response) &#123;            console.log(response.data);            layer.msg(response.data.ext);        &#125;, function errorCallback(response) &#123;            console.log(response.data);        &#125;);    &#125;&#125;);

thinkphp部分在cms-bd/Application/Home/Controller中新建OwnerController.class.php，编写add函数。
// 增加业主public function add()&#123;    if(!$_POST['username'] || !$_POST['password'] || !$_POST['email'] || !$_POST['nickname'])&#123;        $result = array(            'code' =&gt; '0',            'ext' =&gt; '参数不足'         );        echo json_encode($result,JSON_UNESCAPED_UNICODE);        return;    &#125;    $data['username'] = $_POST['username'];    $data['password'] = md5($_POST['password']);    $data['email'] = $_POST['email'];    $data['nickname'] = $_POST['nickname'];    $data['create_at'] = date('Y-m-d H:i:s');    $data['update_at'] = date('Y-m-d H:i:s');    $owner = D('owner');    if($owner-&gt;create($data))&#123;        $id = $owner-&gt;add();        if($id)&#123;            $owner_temp = $owner-&gt;where("id='$id'")-&gt;find();            $result = array(                'code'=&gt; '0',                'ext'=&gt; 'success',                'obj'=&gt;$owner_temp            );            echo json_encode($result,JSON_UNESCAPED_UNICODE);        &#125;    &#125;&#125;

查看业主信息列表和删除业主信息业务逻辑：进入业主信息列表页时，发送http请求给后端，获取到业主信息列表，然后显示到业主信息列表页上。单击某条记录后面的“删除”按钮，弹出确认提示框。确认删除，则发送http请求给后端，获取返回值，如果删除成功，则从页面移除该条记录。
angular部分1、业主信息列表页面
&lt;!--cms-fd/views/owner/list.html--&gt;&lt;div id="owner-list" ng-controller="ownerListController"&gt;    &lt;h2&gt;业主列表&lt;/h2&gt;    &lt;ul&gt;        &lt;li ng-repeat="owner in ownerList"&gt;            &lt;span&gt;用户名：&#123;&#123;owner.username&#125;&#125;，昵称：&#123;&#123;owner.nickname&#125;&#125;&lt;/span&gt;            &lt;button ng-click="edit(owner.id)"&gt;修改&lt;/button&gt;            &lt;button ng-click="delete(owner.id,$index)"&gt;删除&lt;/button&gt;        &lt;/li&gt;    &lt;/ul&gt; &lt;/div&gt;

2、业主信息列表页js
/* *cms-fd/public/js/owner/list.js*/angular.module('myApp').controller('ownerListController', function ($scope,$http,$httpParamSerializer,$state) &#123;     $http(&#123;        method: 'POST',        url: '/cms-bd/index.php/Home/Owner/listAll',        headers:&#123;            'Content-Type':'application/x-www-form-urlencoded'        &#125;,        dataType: 'json',        data: $httpParamSerializer(&#123;&#125;)    &#125;).then(function successCallback(response)&#123;        console.log(response.data);        $scope.ownerList = response.data;    &#125;, function errorCallback(response)&#123;        console.log(response.data);    &#125;);    $scope.edit = function(ownerId)&#123;        $state.go('ownerEdit', &#123;ownerId: ownerId&#125;);    &#125;    $scope.delete = function(ownerId,index)&#123;        var layerIndex = layer.confirm('确认删除？', &#123;            btn: ['是的','取消'] //按钮        &#125;, function()&#123;            $http(&#123;                method:'POST',                url:'/cms-bd/index.php/Home/Owner/delete',                headers:&#123;                    'Content-Type':'application/x-www-form-urlencoded'                &#125;,                dataType: 'json',                data: $httpParamSerializer(&#123;ownerId: ownerId&#125;)            &#125;).then(function successCallback(response) &#123;                console.log(response.data);                if(response.data.code == '0')&#123;                    $scope.ownerList.splice(index,1);                &#125;                layer.close(layerIndex);            &#125;, function errorCallback(response) &#123;                console.log(response.data);                layer.close(layerIndex);            &#125;);                    &#125;, function()&#123;            //layer.msg('取消');        &#125;);    &#125;&#125;);

thinkphp部分添加listAll函数和delete函数。
// 业主列表public function listAll()&#123;    $owner = D('owner');    $resultArr = $owner-&gt;where('state=0')-&gt;order('update_at desc,id desc')-&gt;select();    echo json_encode($resultArr,JSON_UNESCAPED_UNICODE);&#125;// 删除业主public function delete()&#123;    $ownerId = $_POST['ownerId'];    $data['state'] = 1;    $owner = D('owner');    $success = $owner-&gt;where("id='$ownerId'")-&gt;save($data);    if($success)&#123;        $result = array(            'code'=&gt; '0',            'ext'=&gt; 'success'        );        echo json_encode($result);    &#125;else &#123;        $result = array(            'code'=&gt; '1',            'ext'=&gt; 'fail'        );        echo json_encode($result);    &#125;&#125;

修改业主信息业务逻辑：在业主信息列表页，单击某条记录后的“修改”按钮，跳转到修改业主信息页面。修改完成后，单击“确认修改”按钮，跳转回业主信息列表页。
angular部分1、修改业主信息页面
&lt;!--cms-fd/views/owner/edit.html--&gt;&lt;div id="owner-edit" ng-controller="ownerEditController"&gt;    &lt;h2&gt;修改业主信息&lt;/h2&gt;    &lt;form role="form"&gt;        &lt;div class="form-group"&gt;            &lt;label for=""&gt;用户名&lt;/label&gt;            &lt;input name="username" type="text" class="form-control username" id="" ng-model="owner.username"&gt;        &lt;/div&gt;        &lt;div class="form-group"&gt;            &lt;label for=""&gt;密码&lt;/label&gt;            &lt;input name="password" type="password" class="form-control password" id="" ng-model="owner.password"&gt;        &lt;/div&gt;        &lt;div class="form-group"&gt;            &lt;label for=""&gt;邮箱&lt;/label&gt;            &lt;input name="password" type="email" class="form-control email" id="" ng-model="owner.email"&gt;        &lt;/div&gt;        &lt;div class="form-group"&gt;            &lt;label for=""&gt;昵称&lt;/label&gt;            &lt;input name="nickname" type="text" class="form-control nickname" id="" ng-model="owner.nickname"&gt;        &lt;/div&gt;        &lt;button type="submit" class="btn btn-primary submit" ng-click="submit()"&gt;确认修改&lt;/button&gt;    &lt;/form&gt;&lt;/div&gt;

2、修改业主信息js
/* *cms-fd/public/js/owner/edit.js*/angular.module('myApp').controller('ownerEditController', function ($scope,$http,$httpParamSerializer,$stateParams,$state) &#123;     $http(&#123;        method:'POST',        url:'/cms-bd/index.php/Home/Owner/findById',        headers:&#123;            'Content-Type':'application/x-www-form-urlencoded'        &#125;,        dataType: 'json',        data: $httpParamSerializer(&#123;ownerId: $stateParams.ownerId&#125;)    &#125;).then(function successCallback(response) &#123;        console.log(response.data);        $scope.owner = response.data.obj;    &#125;, function errorCallback(response) &#123;        console.log(response.data);    &#125;);    $scope.submit = function()&#123;        $http(&#123;            method:'POST',            url:'/cms-bd/index.php/Home/Owner/edit',            headers:&#123;                'Content-Type':'application/x-www-form-urlencoded'            &#125;,            dataType: 'json',            data: $httpParamSerializer($scope.owner)        &#125;).then(function successCallback(response) &#123;            console.log(response.data);            $state.go('ownerList');        &#125;, function errorCallback(response) &#123;            console.log(response.data);        &#125;);    &#125;&#125;);

thinkphp部分添加findById和edit两个函数。
// 根据id查找业主public function findById()&#123;    $ownerId = $_POST['ownerId'];    $owner = D('owner');    $ownerObj = $owner-&gt;where("id='$ownerId'")-&gt;find();    if($ownerObj)&#123;        $result = array(            'code'=&gt; '0',            'ext'=&gt; 'success',            'obj'=&gt; $ownerObj        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;else&#123;        $result = array(            'code'=&gt; '1',            'ext'=&gt; '没有找到记录'        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;  &#125;// 修改业主public function edit()&#123;    if(!$_POST['id'] || !$_POST['username'] || !$_POST['password'] || !$_POST['email'] || !$_POST['nickname'])&#123;        $result = array(            'code' =&gt; '0',            'ext' =&gt; '参数不足'         );        echo json_encode($result,JSON_UNESCAPED_UNICODE);        return;    &#125;    $id = $_POST['id'];    $data['username'] = $_POST['username'];    $data['password'] = md5($_POST['password']);    $data['email'] = $_POST['email'];    $data['nickname'] = $_POST['nickname'];    $data['update_at'] = date('Y-m-d H:i:s');    $owner = D('owner');    $success = $owner-&gt;where("id='$id'")-&gt;save($data);    if($success)&#123;        $owner_temp = $owner-&gt;where("id='$id'")-&gt;find();        $result = array(            'code'=&gt; '0',            'ext'=&gt; 'success',            'obj'=&gt;$owner_temp        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;else &#123;        $result = array(            'code'=&gt; '1',            'ext'=&gt; '用户不存在'        );        echo json_encode($result,JSON_UNESCAPED_UNICODE);    &#125;&#125;


thinkphp关闭右下角Trace信息thinkphp默认开启调试模式，返回值时总会跟着一个小图标，默认在页面的右下角小图标。在部署阶段，需要把它关闭。1、在入口文件index.php加入
define("APP_DEBUG", false);

2、在Application/Common/config.php 配置文件中加入
'SHOW_PAGE_TRACE' =&gt; false

3、删除Application下的Runtime文件夹。
后记增删查改跑通，这个demo也算是比较完整了。在实际开发的时候，很多地方还要做调整。比如导航栏的一些坑、更好页面布局、更友好的提示和跳转、安全性校验、数据库表设计等等等等。
angular非常容易产生页面缓存，如果遇到很奇葩的坑，比如修改了某个页面，但是刷新无效。不要犹豫，先清下浏览器缓存。
书签Php 5.6 “Automatically populating $HTTP_RAW_POST_DATA is deprecatedhttps://github.com/piwik/piwik/issues/6465
PHP 5.6: “Automatically populating $HTTP_RAW_POST_DATA is deprecated and will be removed in a future version.”https://www.bram.us/php-5-6-automatically-populating-http_raw_post_data-is-deprecated-and-will-be-removed-in-a-future-version/
angularjs 请求后端接口请求了两次http://jingyan.baidu.com/article/49ad8bce42a2415834d8fa97.html
AngularJs + angular-ui-router + bootstrap 实现基础导航栏http://blog.csdn.net/a416311458/article/details/51497230
Angular结合Bootstrap3的导航菜单http://www.tuicool.com/articles/ayqqmi
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>angularjs</category>
        <category>php</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>angularjs</tag>
        <tag>php</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu系统批量自动安装</title>
    <url>/dev-ubuntu-auto-install/</url>
    <content><![CDATA[前言《Ubuntu 14.04.5 Server物理机安装》一文中，我们安装了一台Ubuntu Server服务器，整个过程花费了很多时间。令人难过的是，还有15台机器需要安装！本来打算每天安装个一两台，慢慢来，今天老师提醒说为什么不使用脚本呢？对啊，为什么不试试脚本呢！这是一个思路。突然想起师兄曾说，机房的机器系统安装都是通过网络，这也是一个很好的思路啊！
按照上面两个思路，那就研究下批量安装Ubuntu系统的方法！


原理篇历史参考PXE、kickstart与preseed简介、Linux装机利器Cobbler简述和ubuntu 14.04 无人职守全自动安装-基础知识中，郝同学简单归纳了批量装机的发展。
历史上，很多同学都遇到过和我同样的问题，机器太多，需要挨个装机，简直就是折磨！
于是，为了降低批量装机的难度，出现了PXE技术，它将操作系统远程下载到本地运行，有了这个技术，我们就不需要再挨个机器插U盘安装系统。
有了PXE技术，依然需要在安装的过程中不停地与机器进行交互，设置选项，费时费力。为了减轻同学们的工作量，RedHat推出了kickstart，在安装操作系统前将其中出现的各种问题的应答内容提前写好，使整个操作系统的安装可以自动完成。Debian系的Ubuntu等感觉kickstart对自己不够友善，不能完全满足自己的要求，于是推出了preseed。
再后来，因为kickstart难度系数太高，RedHad又推出了cobbler，把批量装机的难度降低到了小学水平。
PXEPXE是Intel公司开发的将操作系统远程下载到本地运行的一种技术。
本地网卡ROM中包含有PXE客户端软件。网卡启动时会发出DHCP请求，从PXE服务器端获得动态IP地址、网关及TFTP服务器信息后，它会自动下载一个用于引导操作系统的启动软件包到本地内存（不同的操作系统使用不同的PXE引导文件）中，再通过此软件加载操作系统启动文件，从而开始操作系统的安装工作。
PXE的详细介绍请参考自动化运维之-PXE实现系统批量自动安装和PXE网络装机攻略。
kickstart与preseed在我们手动安装操作系统时，需要回答各种提示问题，而针对某种特定应用时，这种回答完全有章可循，如果我们能在安装操作系统时将其中出现的各种问题的应答内容提前写好，那么整个操作系统的安装就可以自动完成。
kickstart是RedHat公司针对自动安装RedHat、Fedora与CentOS这3种同一体系的操作系统而制定的问答规范。它一般会以.cfg作为文件后缀名，不仅可以自动应答一些简单问题，还可以指定操作系统需要安装的各种软件包，更可以在操作系统完装完成后自动执行一些脚本，这些脚本可以让我们直接配置系统。
通常，kickstart配置文件通过命令行工具system-config-kickstart生成。当然，我们更喜欢在CentOS图形界面环境下生成用于定制操作系统安装的配置文件。
preseed则是Debian/Ubuntu操作系统自动安装的问答规范，同样可以预定义Ubuntu如何安装，其配置更多通过手动处理。
cobblerRedHat在2008年发布了网络安装服务器套件 cobbler（补鞋匠），它集成了PXE、DHCP、HTTP、TFTP、kickstart等服务，相对之前的 kickstart ，能够更加快捷、方便的批量布署redhat、centos类系统。
选择由上面的基础概念我们了解到，可选择的技术组合有：

PXE+DHCP+HTTP+TFTP+kickstart
PXE+DHCP+HTTP+TFTP+preseed
PXE+DHCP+HTTP+TFTP+kickstart+preseed
PXE+cobbler
PXE+cobbler+preseed

本文，我们选择PXE+DHCP+HTTP+TFTP+kickstart+preseed，主要参考PXE无人值守网络安装Ubuntu14.04 、 PXE+kickstart自动安装ubuntu14.04 和 在 Ubuntu 14.04 中配置 PXE 服务器。
实践篇PXE服务器PXE服务器选择我们手动安装好的那一台，系统是Ubuntu 14.04.5 Server (64-bit)版，当前IP为172.16.0.213。
配置为PXE服务器后网段为10.0.0.0/8，IP为10.0.0.100。
DHCP1、安装isc-dhcp-serversudo apt-get update
sudo apt-get install isc-dhcp-server -y
2、查看网卡和ipip add或者ifconfig，查看正在使用的局域网网卡，假设为eth0。
3、指定dhcp网卡sudo vim /etc/default/isc-dhcp-server拉到最底部，修改为：
INTERFACES="eth0"

4、配置dhcp服务sudo vim /etc/dhcp/dhcpd.conf在文件末尾添加：
subnet 10.0.0.0 netmask 255.0.0.0 &#123;    range 10.0.0.101 10.0.0.200;    option subnet-mask 255.0.0.0;    option routers 10.0.0.100;    option broadcast-address 10.255.255.255;    filename "pxelinux.0";    next-server 10.0.0.100;&#125;

子网和掩码可以根据自己的需要设置。
filename &quot;pxelinux.0&quot;;，指定PXE启动文件名。next-server 10.0.0.100;，指定PXE服务器IP地址，TFTP服务器IP地址。
5、重启服务service isc-dhcp-server restart
备注：也可以安装DNSmasq，DNSmasq实际上是一个集成工具，包含了DNS、DHCP、TFTP服务器。
TFTP主要参考Tftpd-hpa
1、安装tftpd-hpaapt-get install tftpd-hpa -y
2、给根目录添加读写权限sudo chmod 777 /var/lib/tftpboot/
3、测试tftp
apt-get install tftp -ycd ~tftp 127.0.0.1get version.info

4、tftpd开启关闭命令sudo /etc/init.d/tftpd-hpa start
sudo /etc/init.d/tftpd-hpa stop
apache21、安装apache2sudo apt-get install apache2 -y
web根目录是 /var/www/html/
2、测试apache2curl 127.0.0.1
3、重启命令sudo /etc/init.d/apache2 restart
文件准备1、上传ubuntu-14.04.5-server-amd64.iso到用户目录。使用xftp上传，或者使用scp命令，这里使用scp命令。打开git bash，执行：scp ubuntu-14.04.5-server-amd64.iso test@172.16.0.213:~
2、挂载ubuntu-14.04.5-server-amd64.iso到ubuntu目录。在用户目录执行：sudo mkdir /var/www/html/ubuntu
sudo mount ubuntu-14.04.5-server-amd64.iso /var/www/html/ubuntu
3、拷贝部分文件到tftpsudo cp -r /var/www/html/ubuntu/install/netboot/* /var/lib/tftpboot/
4、拷贝seed文件到web根目录sudo cp /var/www/html/ubuntu/preseed/ubuntu-server.seed /var/www/html/
5、编辑seed文件sudo vim /var/www/html/ubuntu-server.seed
在文件末尾添加：
d-i live-installer/net-image string http://10.0.0.100/ubuntu/install/filesystem.squashfsd-i pkgsel/include string openssh-server

（1）因为在ubuntu12.10版本以后，安装一些包会依赖于预配置的文件系统，这就是导致使用kickstart方式无法成功安装的原因。（2）自动安装ssh服务。
kickstartks.cfg中保存的是安装系统过程中默认的系统配置，没有这个文件就需要安装中对系统手动交互设置。kickstart则是方便编辑这个文件的，不用它的话也可以手工编辑。
kickstart需要GUI界面，我因为是安装的server，所以需要安装桌面（如果是desktop版本就不需要）。
1、安装图形界面sudo apt-get install ubuntu-desktop -y
过程非常久，请先去继续读论文。
2、安装kickstartsudo apt-get install system-config-kickstart -y
3、使用屏幕键盘连接主机，进入图形界面sudo startx，或者直接重启sudo reboot
4、点击右上角“Search your computer and online resources”，搜索kickstart，启动kickstart。
5、然后，按照图示选择kickstart的配置。
附：上图的长图合成工具为 美图秀秀网页版
6、保存ks.cfg后，查看ks.cfg内容为：
#Generated by Kickstart Configurator#platform=AMD64 or Intel EM64T#System languagelang en_US#Language modules to installlangsupport en_US#System keyboardkeyboard us#System mousemouse#System timezonetimezone Asia/Shanghai#Root passwordrootpw --disabled#Initial useruser test --fullname "test" --iscrypted --password $1$AKq0i3Yu$Tunuha7bYwq5uUV62F2nF0#Reboot after installationreboot#Use text mode installtext#Install OS instead of upgradeinstall#Use Web installationurl --url http://10.0.0.100/ubuntu#System bootloader configurationbootloader --location=mbr #Clear the Master Boot Recordzerombr yes#Partition clearing informationclearpart --all --initlabel #System authorization infomationauth  --useshadow  --enablemd5 #Network informationnetwork --bootproto=dhcp --device=eth0#Firewall configurationfirewall --disabled --trust=eth0 --ssh #Do not configure the X Window Systemskipx

7、移动ks.cfg到web根目录sudo mv ks.cfg /var/www/html/
8、修改txt.cfgsudo vim /var/lib/tftpboot/ubuntu-installer/amd64/boot-screens/txt.cfg，原txt.cfg为：
default installlabel install        menu label ^Install        menu default        kernel ubuntu-installer/amd64/linux        append vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiet label cli        menu label ^Command-line install        kernel ubuntu-installer/amd64/linux        append tasks=standard pkgsel/language-pack-patterns= pkgsel/install-language-support=false vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiet

修改为：
default installlabel install        menu label ^Install        menu default        kernel ubuntu-installer/amd64/linux        append ks=http://10.0.0.100/ks.cfg preseed/url=http://10.0.0.100/ubuntu-server.seed netcfg/get_nameservers=10.0.0.100 vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiet label cli        menu label ^Command-line install        kernel ubuntu-installer/amd64/linux        append tasks=standard pkgsel/language-pack-patterns= pkgsel/install-language-support=false vga=788 initrd=ubuntu-installer/amd64/initrd.gz --- quiet

pxelinux.cfg编辑pxelinux.cfg配置文件sudo vim /var/lib/tftpboot/pxelinux.cfg/default
# D-I config version 2.0include ubuntu-installer/amd64/boot-screens/menu.cfgdefault ubuntu-installer/amd64/boot-screens/vesamenu.c32prompt 0timeout 60
timeout默认是0，改为60（6秒后自动选择install选项）。
收尾1、重新配置IPsudo vim /etc/network/interfaces，修改eth0的IP为10.0.0.100：
# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto eth0iface eth0 inet staticaddress 10.0.0.100gateway 10.0.0.100netmask 255.0.0.0

2、重启eth0sudo ifdown eth0，sudo ifup eth0
3、重启dhcpsudo service isc-dhcp-server restart
4、重新挂载镜像sudo mount ubuntu-14.04.5-server-amd64.iso /var/www/html/ubuntu
5、检查各个服务ps aux | grep dhcp
ps aux | grep apache
ps aux | grep tftp
6、把PC和PXE服务器连接到同一个交换机，测试一下PC能否获取到IP。
7、PC浏览器访问 http://10.0.0.100/ubuntu/ ，测试能否正常访问Web服务。
安装篇安装步骤1、把PXE服务器和需要安装系统的主机（下文统一称为目标主机）连接到同一个交换机。
2、目标主机开机启动进入BIOS，首选启动项选择PXE，保存退出。
3、然后，目标主机就会自动获取IP地址，连接PXE服务器，进入到安装界面。
4、在自动网络配置的时候失败，报错“Network autoconfiguration failed”，多次尝试依然失败。Alt+F2，进入命令行界面，ip add，查看到已经获取到IP地址。
Alt+F1，切换回安装界面，这时需要手动配置，一次不行就再来一次。

5、安装过程中，分区后卡住，需要手动选择确认分区。
6、之后，无需任何操作，直到安装成功。
7、测试ssh服务ssh test@localhost，顺利登录。
以上安装过程，已经省去了很多交互步骤，但是依然比较麻烦，主要存在两个问题：一个是自动配置网络的问题，一个是需要分区确认的问题。下面尝试解决这两个问题。
网络问题1、对于网络配置问题，在14.04 server PXE installation fails at “Configure the network” page 找到了可能的答案，也许是/var/lib/tftpboot/pxelinux.cfg/default 文件的问题，修改为：
# D-I config version 2.0include ubuntu-installer/amd64/boot-screens/menu.cfgdefault linuxlabel linux  menu default  menu label Linux  kernel ubuntu-installer/amd64/linux  append ks=http://10.0.0.100/ks.cfg preseed/url=http://10.0.0.100/ubuntu-server.seed vga=normal initrd=ubuntu-installer/amd64/initrd.gz --prompt 0timeout 60
问题依旧。最好再改回原来的/var/lib/tftpboot/pxelinux.cfg/default文件配置，因为这样启动时通过DHCP获取IP的时间明显变长了，有时还会出现无法获取IP以至于无法启动安装的情况。如果没有获取到IP，记得及时按下ctrl+alt+del，进行重启，不然要等很久才能开始第二次尝试。
2、莫非是dhcp配置的问题？参考14.04 server PXE installation fails at “Configure the network” page修改网卡配置为：
# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto eth0iface eth0 inet staticaddress 10.0.0.100netmask 255.0.0.0gateway 10.0.0.100broadcast 10.255.255.255dns-nameservers 10.0.0.100

重启网络，sudo ifdown eth0，sudo ifup eth0。重启dhcp，sudo service isc-dhcp-server restart。问题依旧。
3、参考Install And Configure PXE Server On Ubuntu 14.04 LTS，sudo vim /etc/dhcp/dhcpd.conf，在最后添加： 
allow booting;allow bootp;option option-128 code 128 = string;option option-129 code 129 = text;next-server 10.0.0.100;filename "pxelinux.0";

重启dhcp，sudo service isc-dhcp-server restart。问题依旧。
4、莫非是因为没有安装DNS？参考《Ubuntu14.04配置DNS Server》，安装好DNS。问题依旧。
5、参考preseeds，sudo vim /var/www/html/ubuntu-server.seed，在尾部添加：
d-i netcfg/choose_interface select autod-i netcfg/get_hostname string $hostname
问题依旧。
6、删除步骤第5次尝试的内容，参考，sudo vim /var/www/html/ubuntu-server.seed，在尾部添加：
d-i netcfg/choose_interface select eth0d-i netcfg/dhcp_timeout string 60d-i netcfg/get_hostname string ubuntud-i netcfg/get_domain string ubuntu-domain
问题依旧。
7、删除步骤第6次尝试的内容，参考基于PXE和preseed安装Ubuntu-14.04 Server 64位操作系统，sudo vim /var/www/html/ubuntu-server.seed，在尾部添加：
d-i netcfg/choose_interface select eth0d-i netcfg/dhcp_failed noted-i netcfg/dhcp_options select Do not configure the network at this timed-i netcfg/get_hostname string ubuntud-i netcfg/get_domain string ubuntu-domain
问题依旧。
8、参考附录 B. 使用预置自动进行安装，sudo vim /var/www/html/ubuntu-server.seed，在尾部添加：
# If you prefer to configure the network manually, uncomment this line and# the static network configuration below.d-i netcfg/disable_dhcp boolean trued-i netcfg/disable_autoconfig boolean trued-i netcfg/use_autoconfig boolean false# If you want the preconfiguration file to work on systems both with and# without a dhcp server, uncomment these lines and the static network# configuration below.d-i netcfg/dhcp_failed noted-i netcfg/dhcp_options select Configure network manually# Static network configuration.## IPv4 exampled-i netcfg/get_ipaddress string 10.0.0.134d-i netcfg/get_netmask string 255.0.0.0d-i netcfg/get_gateway string 10.0.0.100d-i netcfg/get_nameservers string 10.0.0.100d-i netcfg/confirm_static boolean true
问题依旧。感觉netcfg这个系列的命令根本没有生效！
附录 B. 使用预置自动进行安装一文中说，例如，为网卡设置静态地址。它使加载了预置文件以后网络预置再运行一次，这需要将下面的命令包含在 “preseed/run” 脚本里面：kill-all-dhcp; netcfg
于是在Is it possible to download a bash script and execute it from a preseed file?和kill-all-dhcp中找到了使用脚本的方法。（1）创建脚本sudo vim /var/www/html/run.sh写入内容为：
#!/bin/sh# Killall for dhcp clients.kill-all-dhcp;netcfg;for client in dhclient udhcpc pump dhcp6c; do        pid=$(pidof $client) || true        [ "$pid" ] || continue        if kill -0 $pid 2&gt;/dev/null; then                kill -TERM $pid                sleep 1                # Still alive? Die!                if kill -0 $pid 2&gt;/dev/null; then                        kill -KILL $pid                fi        fidone

（2）变更权限sudo chmod a+x /var/www/html/run.sh
（3）在ubuntu-server.seed文件中添加一行：
d-i preseed/run string run.sh
问题依旧，但是Alt+F2进入命令行，发现获取的IP确实没有了。
9、莫非，是因为DHCP的网段问题？折腾了一个多小时，PXE服务器地址换成192.168.34.1，DHCP换成了192.168.34.0网段，然而并没有什么用。
最终，我猜测这个锅是ubuntu14的，或者是电脑硬件的。在askubuntu上进行了提问，但是没有得到满意的回复。
分区问题1、参考Ubuntu Kickstart installation using LVM waits for input，修改ks.cfg文件。
sudo vim /var/www/html/ks.cfg，添加：
preseed partman-lvm/confirm_nooverwrite boolean true
问题依旧。
2、sudo vim /var/www/html/ks.cfg，添加：
preseed partman-lvm/confirm_nooverwrite boolean truepreseed partman-lvm/device_remove_lvm boolean truepreseed partman/confirm_write_new_label boolean truepreseed partman/confirm boolean truepreseed partman/confirm_nooverwrite boolean true

问题依旧。
3、删除ks.cfg中添加的内容，参考Automated Kickstart Partitioning，sudo vim /var/www/html/ubuntu-server.seed，在末尾加上：
d-i partman/confirm_write_new_label boolean trued-i partman/choose_partition select Finish partitioning and write changes to diskd-i partman/confirm boolean true

分区成功，吼吼吼！折腾了一整天，总算有点成就，泪流满面。。。让我安静的哭一会。。。
后记配置Ubuntu批量自动安装的过程中，发现最重要的两个文件是/var/www/html/ks.cfg 和 /var/www/html/ubuntu-server.seed，因为他们两个是控制交互的。
折腾的过程中学到了很多东西，而最终的成果，除了网络需要手动配置之外，其他都很满意。我会继续尝试解决网络配置的问题，有了进展，再更新本文。
书签PXE无人值守网络安装Ubuntu14.04
KICKSTART无人值守安装
COBBLER无人值守安装
Cobbler+preseed自动化安装Ubuntu系统
Ubuntu 16.04.2 LTS PXE全自动安装
u盘全自动安装 ubuntu server 12.04
CentOS/Ubuntu制作自动安装iso实操
Installation/UnattendedCD
PXELINUX
第二章、安裝伺服器與 kickstart 大量部署用戶端電腦
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>ubuntu</category>
        <category>OS</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>ubuntu</tag>
        <tag>pxe</tag>
      </tags>
  </entry>
  <entry>
    <title>Kolla安装OpenStack多节点</title>
    <url>/dev-ubuntu16-kolla-openstack-multinode/</url>
    <content><![CDATA[前言《Ubuntu16使用Kolla安装OpenStack》一文中，使用kolla安装了单节点的openstack。
在实际的部署中，当然要安装多节点的openstack，本文就来研究一下在多个节点上使用kolla安装部署openstack的方法。


环境VirtualBox虚拟机三台，系统为ubuntu-16.04.4-server-amd64，分别作为控制节点、网络节点和计算节点，用户名为voidking/root，密码为voidking。控制节点4核8G内存40G存储，主机名为controller，eth0的IP为192.168.56.110，eth1为nat上网网卡，eth2为neutron服务网络。网络节点2核4G内存40G存储，主机名为network，eth0的IP为192.168.56.111，eth1为nat上网网卡，eth2为neutron服务网络。计算节点2核4G内存40G存储，主机名为compute，eth0的IP为192.168.56.112，eth1为nat上网网卡，eth2为neutron服务网络。
准备网络设置在控制节点上，执行以下操作：
1、切换到root用户sudo -i
2、vim /etc/network/interfaces，设置网卡为：
# This file describes the network interfaces available on your system# and how to activate them. For more information, see interfaces(5).source /etc/network/interfaces.d/*# The loopback network interfaceauto loiface lo inet loopback# The primary network interfaceauto eth0iface eth0 inet staticaddress 192.168.56.110netmask 255.255.255.0auto eth1iface eth1 inet dhcpauto eth2iface eth2 inet manualup ifconfig $IFACE 0.0.0.0 upup ifconfig $IFACE promisc

3、启用网卡ifup eth2
4、修改/etc/hosts，添加：
192.168.56.110  controller192.168.56.111  network192.168.56.112  compute

网络节点和计算节点参考控制节点配置即可。需要注意的是，hosts文件在OpenStack安装完成后会被ansible修改，建议保留ansible创建的那一份，原因参考《OpenStack计算节点的奇葩问题》。
python在三台机器上安装pythonsudo apt -y install python-simplejson不安装的话，在使用ansible的时候会报错/bin/sh: 1: /usr/bin/python: not found。
安装docker1、在三台机器上安装dockercurl -SSL https://get.docker.io | bash
或者：apt install docker.io
2、为docker和kolla创建配置文件
mkdir -p /etc/systemd/system/docker.service.dvim /etc/systemd/system/docker.service.d/kolla.conf

修改为：
[Service]MountFlags=shared

3、重启docker
systemctl daemon-reloadsystemctl restart docker

4、查看docker信息docker info
如果报错的话，参考《Ubuntu16使用Kolla安装OpenStack》解决。
加速镜像拉取使用 Docker 的时候，需要经常从官方获取镜像，但是由于显而易见的网络原因，拉取镜像的过程非常耗时，严重影响使用 Docker 的体验。因此DaoCloud推出了加速器工具解决这个难题，通过智能路由和缓存机制，极大提升了国内网络访问 Docker Hub 的速度，目前已经拥有了广泛的用户群体，并得到了 Docker 官方的大力推荐。
1、访问DaoCloud官网，注册一个账号。
2、访问配置 Docker 加速器，可以获得一个专属加速地址（每次访问都会获得不同的地址）。
3、参考Docker 加速器，创建或修改 /etc/docker/daemon.json，内容为：
&#123;    "registry-mirrors": [        "http://2fd0f33c.m.daocloud.io"    ],    "insecure-registries": []&#125;

4、重启docker
systemctl daemon-reloadsystemctl restart docker

PS：也可以使用阿里云的镜像加速器。
密钥登录1、在控制节点生成密钥ssh-keygen，连续回车即可。
2、将公钥写入三台机器
ssh-copy-id -i .ssh/id_rsa.pub -p 22 voidking@192.168.56.110ssh-copy-id -i .ssh/id_rsa.pub -p 22 voidking@192.168.56.111ssh-copy-id -i .ssh/id_rsa.pub -p 22 voidking@192.168.56.112

3、在三台机器把voidking用户添加进sudo免密，方便以后的操作sudo vim /etc/sudoers，添加
voidking ALL = NOPASSWD: ALL


控制节点主要参考OpenStack, Ansible, and Kolla on Ubuntu 16.04、kolla queens on centos7.4和Kolla-Ansible’s documentation!。
安装依赖1、安装并升级pip
apt-get updateapt-get install python-pippip install --upgrade pip

2、安装依赖apt-get -y install python-dev libffi-dev gcc libssl-dev python-selinux
3、安装ansible
apt-get install software-properties-commonapt-add-repository ppa:ansible/ansibleapt-get updateapt-get install ansible

4、vim /etc/ansible/ansible.cfg，添加如下：
line 10, add[defaults]host_key_checking=Falsepipelining=Trueforks=100

安装Kolla-ansible1、安装kolla-ansiblepip install kolla-ansible
报错：ImportError: cannot import name main，参考升级pip后出现ImportError: cannot import name main，编辑/usr/bin/pip文件，如下修改：
# line 9, changefrom pip import __main__if __name__ == '__main__':    sys.exit(__main__._main())

报红：oslo-config 6.4.0 has requirement PyYAML&gt;=3.12, but you’ll have pyyaml 3.11 which is incompatible.忽略。
2、拷贝globals.yml和passwords.yml到/etc/kolla目录cp -r /usr/local/share/kolla-ansible/etc_examples/kolla /etc/
3、拷贝all-in-one和multinode清单文件到当前目录cp /usr/local/share/kolla-ansible/ansible/inventory/* .
4、生成kolla密码kolla-genpwd我们部署中使用的密码存储在/etc/kolla/passwords.yml文件中。此文件中的所有密码都是空白的，必须手动填写或运行随机密码生成器。
5、配置multinode文件vim multinode，如下修改：
# line 3, change[control]192.168.56.110 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true# line 12, change[network]192.168.56.111 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true# line 17, change[inner-compute]192.168.56.112 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true# line 21, change[external-compute]192.168.56.112 ansible_ssh_user=voidking ansible_ssh_pass=voidking ansible_sudo=voidking ansible_sudo_pass=voidking ansible_become_user=root ansible_become_pass=voidking ansible_become=true# line 28, comment[monitoring]#monitoring01# line 36, comment[storage]#storage01

6、测试连通ansible -i multinode -m ping all报错：ERROR! to use the ‘ssh’ connection type with passwords, you must install the sshpass program安装sshpass：apt install sshpass然后重新测试连通。
配置globals.yml1、查看globals.yml配置grep -vE &#39;^$|^#&#39; /etc/kolla/globals.yml
2、vim /etc/kolla/globals.yml，如下修改：
# line 15,uncommentkolla_base_distro: "centos"# line 18,uncommentkolla_install_type: "binary"# line 21,uncomment and changeopenstack_release: "queens"# line 31,changekolla_internal_vip_address: "192.168.56.120"# line 85,uncomment and changenetwork_interface: "eth0"# line 100,uncomment and changeneutron_external_interface: "eth2"# line 331,uncommentdesignate_backend: "bind9"designate_ns_record: "sample.openstack.org"# line 340,uncomment and changenova_compute_virt_type: "qemu"# othertempest_image_id:tempest_flavor_ref_id:tempest_public_network_id:tempest_floating_network_name:

kolla_internal_vip_address为192.168.56.120，它是一个和OpenStack宿主机内网连接网络（eth0 192.168.56.110）同一个网段的未使用IP。network_interface为eth0，意思是openstack内部网络使用eth0网卡。neutron_external_interface为eth2，意思是openstack的虚拟机外部网络使用eth2网卡。因为是在虚拟机中安装openstack，所以nova_compute_virt_type设置为qemu。
PS：实际上，kolla_internal_vip_address最好设置为192.168.56.110，原因参考《OpenStack计算节点的奇葩问题》。
部署1、初始化kolla-ansible -i ./multinode bootstrap-servers时间很久，请耐心等待。
2、预检查kolla-ansible -i ./multinode prechecks

3、拉取镜像kolla-ansible -i ./multinode pull这一步的时间特别久，挺耐心等待。如果拉取失败，就多尝试几次。这里郝同学取巧一下，直接把《Ubuntu16使用Kolla安装OpenStack》一文中的images拷贝到控制节点、网络节点和计算节点。
（1）打包所有imagesdocker save $(docker images | grep -v REPOSITORY | awk &#39;BEGIN{OFS=&quot;:&quot;;ORS=&quot; &quot;}{print $1,$2}&#39;) -o kolla.tar
（2）导入所有imagesdocker load -i kolla.tar
4、查看镜像docker images
5、部署kolla-ansible -i ./multinode deploy
测试使用openstack1、在控制节点安装openstack客户端pip install python-openstackclient python-glanceclient python-neutronclient --ignore-installed
2、生成admin-openrc.sh等kolla-ansible post-deploy
3、使admin环境生效source /etc/kolla/admin-openrc.sh
4、查看计算服务openstack compute service list
5、查看网络服务openstack network agent list
初始化配置1、执行init-runonce脚本. /usr/local/share/kolla-ansible/init-runonce
执行初始化之前，可以参考openstack 之 Kolla部署指南，设置一下外部网络。这样，就可以从路由器给虚拟机分配IP，安装完虚拟机就可以宿主机互相ping通。比如：
EXT_NET_CIDR='192.168.56.0/24'EXT_NET_RANGE='start=192.168.56.200,end=192.168.56.240'EXT_NET_GATEWAY='192.168.56.1'
这里配置的网络范围，对应globals.yml中配置的neutron_external_interface，也就是eth2网卡。
2、根据提示，创建实例
openstack server create \    --image cirros \    --flavor m1.tiny \    --key-name mykey \    --nic net-id=25e6c0ef-6a0a-481c-a08a-46f7ef67ad3e \    demo1

3、给demo1实例分配浮动IP
source /etc/kolla/admin-openrc.shopenstack network listopenstack floating ip create public1openstack server add floating ip demo1 10.0.2.157

4、查看demo1openstack server list
5、访问horizon服务curl 192.168.56.120 -L
在浏览器访问 http://192.168.56.120 ，使用admin账号登录，密码在passwords.yml文件中查看。less /etc/kolla/passwords.yml | grep keystone_admin_password
至此，使用kolla安装部署多节点openstack成功。
网络配置网络节点关于网络的配置，主要参考Kolla配置实例网络。
1、在网络节点编辑/etc/network/interfaces，添加：
auto br-exiface br-ex inet staticaddress 10.0.2.1netmask 255.255.255.0

2、启用br-exifup br-ex
3、添加路由
ip netnsip netns exec qrouter-9dbabbdd-cc45-42c3-b9e0-9dbbc03e66f1 ip addroute add -net 10.0.0.0/24 gw 10.0.2.153 dev br-ex

重启后路由失效，如果想要永久生效，那就在/etc/network/interfaces文件的尾部添加：
up route add -net 10.0.0.0/24 gw 10.0.2.153 dev br-ex

4、在网络节点连通demo1
ping 10.0.2.157 -c3ping 10.0.0.3 -c3

5、设置demo1上网
iptables -I INPUT -i eth2 -j ACCEPTiptables -I INPUT -i br-ex -j ACCEPTiptables -t nat -A POSTROUTING -s 10.0.2.0/24 -o eth1 -j MASQUERADEiptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth1 -j MASQUERADE

设置永久生效参考《Linux配置SNAT上网》。
控制节点1、添加路由route add -net 10.0.2.0/24 gw 192.168.56.110 dev eth0同样的，想要路由永久生效，也要添加到interfaces文件的尾部。
2、在控制节点连通demo1ping 10.0.2.157 -c3
3、连接demo1ssh cirros@10.0.2.157
4、测试外网连通ping 8.8.8.8 -c3
清除OpenStack安装OpenStack，会对宿主机的网络有很大的影响。安装完成后，如果网络瘫痪，不要怕，还有补救措施：清除已经安装部署的OpenStack环境，然后重新配置，重新部署。清除OpenStack的命令如下：kolla-ansible destroy -i ./multinode  --yes-i-really-really-mean-it
后记本文的网络设置不合理，但是也能正常使用。因为已经安装部署完成，所以就不再更改了，在此做一下补充说明。本文中eth0作为管理网卡，eth1作为上网网卡，eth0作为OpenStack宿主机间的内网网卡，eth2作为OpenStack的虚拟机外网网卡。这里eth0复用了，既作为管理网卡，又作为OpenStack内网网卡。更好的做法是，再添加一块网卡作为OpenStack的内网网卡，使每个网卡只有一个职责。
在物理机中安装OpenStack的话，可以参考《Ubuntu16手动安装OpenStack——neutron篇》。控制节点一个网卡，用来上网和管理；网络节点三个网卡，一张用来上网和管理，一张用来OpenStack宿主机内网连接，一张用来OpenStack虚拟机外网连接；计算节点两个网卡，一张用来上网和管理，一张用来OpenStack宿主机内网连接。
还有，在物理机安装OpenStack时，要关闭其他虚拟化工具，比如VirtualBox或者VMware，否则会无法创建实例，查看日志tail -n 20 /var/lib/docker/volumes/kolla_logs/_data/nova/nova-compute.log，出现KVM Error – ioctl(KVM_CREATE_VM) failed: 16 Device or Resource busy问题。
书签Kolla’s documentation!
Kolla让OpenStack部署更贴心
Kolla安装Ocata单节点
kolla部署openstack ocata版
Install and configure OpenStack Ocata with Kolla as a standalone
Kolla OpenStack系统视频课程
利用kolla快速搭建openstack-pike多节点
]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>ansible</tag>
        <tag>openstack</tag>
        <tag>kolla</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu16手动安装OpenStack——swift篇</title>
    <url>/dev-ubuntu16-manual-openstack-swift/</url>
    <content><![CDATA[目标紧接着《Ubuntu16手动安装OpenStack——cinder篇》，本文，我们来研究一下swift的安装配置。主要参考OpenStack Queens : Configure Swift 和 Object Storage Install Guide。
cinder和swift都是关于存储的组件，那么它们有什么区别呢？cinder的存储，就像是普通硬盘。可以方便快捷地本地存取修改数据，还可以按需添加减少硬盘。swift的存储，就像是百度云盘。只能存取数据，不能在云端进行修改，适用于备份。如果非要修改，那么需要下载到本地修改，修改完再上传。在openstack实际应用中，swift常用来存储镜像这种不需要经常修改的文件。


swift简介OpenStack Object Storage 是一个多租户对象存储系统。它具有高度可扩展性，可以通过RESTful HTTP API以低成本管理大量非结构化数据。
代理服务器（swift-proxy-server）接受OpenStack Object Storage API和原始HTTP请求，上传文件，修改元数据和创建容器。它还为Web浏览器提供文件或容器列表。为了提高性能，代理服务器可以使用通常使用memcache部署的可选缓存。
帐户服务器（swift-account-server）管理使用对象存储定义的帐户。
容器服务器（swift-container-server）在对象存储中管理容器或文件夹的映射。
对象服务器（swift-object-server）管理存储节点上的实际对象，例如文件。
Various periodic processes在大型数据存储上执行内务处理任务。复制服务可确保群集的一致性和可用性。其他定期流程包括审计员，更新者和收割者。
WSGI中间件处理身份验证，通常是OpenStack Identity。
swift client允许用户通过命令行客户端进行授权，然后为admin用户、经销商用户或swift用户向REST API提交命令。
swift-init初始化环文件构建的脚本，将守护程序名称作为参数并提供命令。详细文档在这里。
swift-recon一种客户端工具，用于检索由swift-recon中间件收集的有关群集的各种指标和遥测信息。
swift-ring-builder存储环构建和重新平衡实用程序。详细文档在这里。
架构一般来说，swift至少需要三个存储节点，如下结构。
之前的安装中，我们只使用了两个节点，一个控制节点，一个计算节点。本文中，我们把swift安装在控制节点和计算节点，领会精神。如果要增加存储节点，修改Ring files，然后参照计算节点配置即可。
控制节点安装：
Swift ProxySwift-AccountSwift-ContainerSwift-Object

计算节点安装：
Swift ProxySwift-AccountSwift-ContainerSwift-Object

控制节点root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
服务证书和端点1、使admin环境生效. admin-openrc
2、添加swift用户openstack user create --domain default --project service --password openstack swift
3、把admin角色添加给swift用户openstack role add --project service --user swift admin
4、创建swift服务openstack service create --name swift --description &quot;OpenStack Object Storage&quot; object-store
5、创建服务端点
openstack endpoint create --region RegionOne object-store public http://controller:8080/v1/AUTH_%\(tenant_id\)sopenstack endpoint create --region RegionOne object-store internal http://controller:8080/v1/AUTH_%\(tenant_id\)s openstack endpoint create --region RegionOne object-store admin http://controller:8080/v1

安装配置Swift Proxy1、安装swift-proxyapt-get -y install swift swift-proxy python-swiftclient python-keystonemiddleware python-memcache
2、创建swift配置目录mkdir /etc/swift
3、vi /etc/swift/proxy-server.conf，新建proxy-server.conf内容如下：
# create new[DEFAULT]bind_ip = 0.0.0.0bind_port = 8080user = swift[pipeline:main]pipeline = catch_errors gatekeeper healthcheck proxy-logging cache container_sync bulk ratelimit authtoken keystoneauth container-quotas account-quotas slo dlo versioned_writes proxy-logging proxy-server[app:proxy-server]use = egg:swift#proxyallow_account_management = trueaccount_autocreate = true# Keystone auth info[filter:authtoken]paste.filter_factory = keystonemiddleware.auth_token:filter_factorywww_authenticate_uri = http://controller:5000auth_url = http://controller:5000memcached_servers = controller:11211auth_type = passwordproject_domain_name = defaultuser_domain_name = defaultproject_name = serviceusername = swiftpassword = openstackdelay_auth_decision = true[filter:keystoneauth]use = egg:swift#keystoneauthoperator_roles = admin,SwiftOperator[filter:healthcheck]use = egg:swift#healthcheck[filter:cache]use = egg:swift#memcachememcache_servers = controller:11211[filter:ratelimit]use = egg:swift#ratelimit[filter:domain_remap]use = egg:swift#domain_remap[filter:catch_errors]use = egg:swift#catch_errors[filter:cname_lookup]use = egg:swift#cname_lookup[filter:staticweb]use = egg:swift#staticweb[filter:tempurl]use = egg:swift#tempurl[filter:formpost]use = egg:swift#formpost[filter:name_check]use = egg:swift#name_check[filter:list-endpoints]use = egg:swift#list_endpoints[filter:proxy-logging]use = egg:swift#proxy_logging[filter:bulk]use = egg:swift#bulk[filter:slo]use = egg:swift#slo[filter:dlo]use = egg:swift#dlo[filter:container-quotas]use = egg:swift#container_quotas[filter:account-quotas]use = egg:swift#account_quotas[filter:gatekeeper]use = egg:swift#gatekeeper[filter:container_sync]use = egg:swift#container_sync[filter:xprofile]use = egg:swift#xprofile[filter:versioned_writes]use = egg:swift#versioned_writes

4、vi /etc/swift/swift.conf，新建swift.conf内容为：
# create new (it is shared among Swift Nodes - any words you like)[swift-hash]swift_hash_path_suffix = swift_shared_pathswift_hash_path_prefix = swift_shared_path

5、修改权限chown -R swift. /etc/swift
配置Ring files1、创建rings
swift-ring-builder /etc/swift/account.builder create 12 2 1 swift-ring-builder /etc/swift/container.builder create 12 2 1 swift-ring-builder /etc/swift/object.builder create 12 2 1

12、2、1这三个参数，分别代表part_power、replicas、min_part_hours。part_power是以2为底数的指数的幂，即2^ part_power，所得的值表示总共的partition的数目。如果设置为2，则2^2=4，表示总共有4个partition。
replicas表示每个object在swift中储存的数目。
min_part_hours表示一个partiton能够再次更改的最小时间。防止没有进行同步便进行下次更改。
2、添加存储节点
swift-ring-builder /etc/swift/account.builder add r0z0-172.16.0.105:6002/device0 100swift-ring-builder /etc/swift/container.builder add r0z0-172.16.0.105:6001/device0 100 swift-ring-builder /etc/swift/object.builder add r0z0-172.16.0.105:6000/device0 100swift-ring-builder /etc/swift/account.builder add r1z1-172.16.0.106:6002/device1 100 swift-ring-builder /etc/swift/container.builder add r1z1-172.16.0.106:6001/device1 100 swift-ring-builder /etc/swift/object.builder add r1z1-172.16.0.106:6000/device1 100

3、平衡存储
swift-ring-builder /etc/swift/account.builder rebalanceswift-ring-builder /etc/swift/container.builder rebalance swift-ring-builder /etc/swift/object.builder rebalance

4、更改权限chown swift. /etc/swift/*.gz
5、重启swift-proxysystemctl restart swift-proxy
计算节点root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
磁盘分区1、《Ubuntu16手动安装OpenStack——cinder篇》一文中，因为计算节点（存储节点）的sdb用于cinder服务了，所以我们需要在计算节点再添加一块硬盘sdc，用于swift服务。
2、查看硬盘fdisk -l
3、对sdc进行分区fdisk /dev/sdc

输入 m 显示所有命令提示。
输入 p 显示硬盘分割情形。
输入 a 设定硬盘启动区。
输入 n 设定新的硬盘分割区。输入 e 硬盘为[延伸]分割区(extend)，输入 p 硬盘为[主要]分割区(primary)。
输入 t 改变硬盘分割区属性。
输入 d 删除硬盘分割区属性。
输入 q 结束不存入硬盘分割区属性。
输入 w 结束并写入硬盘分割区属性。

4、命令行输入n，添加一个新的分区；接下来选择p，设置一个主分区（e为扩展分区）；接下来分区号选择1；再接下来设置起止扇区号，选择默认值即可（2048到max）；最后输入w，确认写入硬盘分区。
安装配置1、下载安装相关组件apt-get -y install swift swift-account swift-container swift-object xfsprogs
2、使用xfs格式化空闲磁盘mkfs.xfs -i size=1024 -s size=4096 /dev/sdc1
3、创建device1文件夹mkdir -p /srv/node/device1
4、挂载/dev/sdc1到device1mount -o noatime,nodiratime,nobarrier /dev/sdc1 /srv/node/device1
5、修改权限chown -R swift. /srv/node
6、vi /etc/fstab，设置开机挂载
# add to the end/dev/sdc1  /srv/node/device1  xfs  noatime,nodiratime,nobarrier 0 0

7、从控制节点（swift-proxy）拷贝文件到计算节点scp voidking@172.16.0.105:/etc/swift/*.gz /etc/swift/
8、修改权限chown swift. /etc/swift/*.gz
9、vi /etc/swift/swift.conf，新建swift.conf内容如下：
# set the value which is set on Proxy Node[swift-hash]swift_hash_path_suffix = swift_shared_pathswift_hash_path_prefix = swift_shared_path

10、vi /etc/swift/account-server.conf，如下修改：
# line 2: make sure the value is followsbind_ip = 0.0.0.0bind_port = 6002

11、vi /etc/swift/container-server.conf，如下修改：
# line 2: make sure the value is followsbind_ip = 0.0.0.0bind_port = 6001

12、vi /etc/swift/object-server.conf，如下修改：
# line 2: make sure the value is followsbind_ip = 0.0.0.0bind_port = 6000

13、vi /etc/rsyncd.conf，新建rsyncd.conf内容如下：
# create newpid file = /var/run/rsyncd.pidlog file = /var/log/rsyncd.loguid = swiftgid = swift# IP address of this Nodeaddress = 172.16.0.106[account]path            = /srv/noderead only       = falsewrite only      = nolist            = yesincoming chmod  = 0644outgoing chmod  = 0644max connections = 25lock file =     /var/lock/account.lock[container]path            = /srv/noderead only       = falsewrite only      = nolist            = yesincoming chmod  = 0644outgoing chmod  = 0644max connections = 25lock file =     /var/lock/container.lock[object]path            = /srv/noderead only       = falsewrite only      = nolist            = yesincoming chmod  = 0644outgoing chmod  = 0644max connections = 25lock file =     /var/lock/object.lock[swift_server]path            = /etc/swiftread only       = truewrite only      = nolist            = yesincoming chmod  = 0644outgoing chmod  = 0644max connections = 5lock file =     /var/lock/swift_server.lock

14、vi /etc/default/rsync，如下修改：
# line 8: changeRSYNC_ENABLE=true

15、重启rsync并设置开机启动systemctl restart rsync
systemctl enable rsync
16、重启其他swift服务并设置开机启动
for ringtype in account container object; do     systemctl restart swift-$ringtype    systemctl enable swift-$ringtype    for service in replicator updater auditor; do        if [ $ringtype != 'account' ] || [ $service != 'updater' ]; then            systemctl start swift-$ringtype-$service            systemctl enable swift-$ringtype-$service        fi    donedone

至此，一个存储节点配置成功，下面再配置一个swift存储节点在控制节点上。
控制节点root用户为了避免权限问题，建议切换到root用户进行操作（否则要加很多sudo）。sudo -i
磁盘分区1、在控制节点再添加一块硬盘sdb，用于swift服务。
2、参考计算节点的分区方法，给sdb分区。
安装配置1、下载安装相关组件apt-get -y install swift swift-account swift-container swift-object xfsprogs
2、使用xfs格式化空闲磁盘mkfs.xfs -i size=1024 -s size=4096 /dev/sdb1
3、创建device0文件夹mkdir -p /srv/node/device0
4、挂载/dev/sdc1到device1mount -o noatime,nodiratime,nobarrier /dev/sdb1 /srv/node/device0
5、修改权限chown -R swift. /srv/node
6、vi /etc/fstab，设置开机挂载
# add to the end/dev/sdb1  /srv/node/device0  xfs  noatime,nodiratime,nobarrier 0 0

7、修改权限chown swift. /etc/swift/*.gz
8、vi /etc/swift/account-server.conf，如下修改：
# line 2: make sure the value is followsbind_ip = 0.0.0.0bind_port = 6002

9、vi /etc/swift/container-server.conf，如下修改：
# line 2: make sure the value is followsbind_ip = 0.0.0.0bind_port = 6001

10、vi /etc/swift/object-server.conf，如下修改：
# line 2: make sure the value is followsbind_ip = 0.0.0.0bind_port = 6000

11、vi /etc/rsyncd.conf，新建rsyncd.conf内容如下：
# create newpid file = /var/run/rsyncd.pidlog file = /var/log/rsyncd.loguid = swiftgid = swift# IP address of this Nodeaddress = 172.16.0.105[account]path            = /srv/noderead only       = falsewrite only      = nolist            = yesincoming chmod  = 0644outgoing chmod  = 0644max connections = 25lock file =     /var/lock/account.lock[container]path            = /srv/noderead only       = falsewrite only      = nolist            = yesincoming chmod  = 0644outgoing chmod  = 0644max connections = 25lock file =     /var/lock/container.lock[object]path            = /srv/noderead only       = falsewrite only      = nolist            = yesincoming chmod  = 0644outgoing chmod  = 0644max connections = 25lock file =     /var/lock/object.lock[swift_server]path            = /etc/swiftread only       = truewrite only      = nolist            = yesincoming chmod  = 0644outgoing chmod  = 0644max connections = 5lock file =     /var/lock/swift_server.lock

12、vi /etc/default/rsync，如下修改：
# line 8: changeRSYNC_ENABLE=true

13、重启rsync并设置开机启动systemctl restart rsync
systemctl enable rsync
14、重启其他swift服务并设置开机启动
for ringtype in account container object; do     systemctl restart swift-$ringtype    systemctl enable swift-$ringtype    for service in replicator updater auditor; do        if [ $ringtype != 'account' ] || [ $service != 'updater' ]; then            systemctl start swift-$ringtype-$service            systemctl enable swift-$ringtype-$service        fi    donedone

至此，控制节点的swift存储也配置完成。
使用以下操作在控制节点执行。
服务角色和用户1、使admin环境生效. admin-openrc
2、创建一个swiftservice服务openstack project create --domain default --description &quot;Swift Service Project&quot; swiftservice
3、创建SwiftOperator角色openstack role create SwiftOperator
4、创建user01用户，密码为openstackopenstack user create --domain default --project swiftservice --password openstack user01
5、给user01添加SwiftOperator角色openstack role add --project swiftservice --user user01 SwiftOperator
客户端1、安装swift-clientapt-get -y install python-openstackclient python-keystoneclient python-swiftclient
2、vi ~/swift-openrc，创建环境配置文件swift-openrc，内容为：
export OS_PROJECT_DOMAIN_NAME=defaultexport OS_USER_DOMAIN_NAME=defaultexport OS_PROJECT_NAME=swiftserviceexport OS_USERNAME=user01export OS_PASSWORD=openstackexport OS_AUTH_URL=http://controller:5000/v3export OS_IDENTITY_API_VERSION=3export PS1='[\u@\h \W(swift)]\$ '

3、使环境生效. swift-openrc
4、查看swift状态swift stat
5、创建一个containeropenstack container create test_container
openstack container list
6、vim test.txt，新建test.txt，内容为“hello openstack”。
7、上传test.txt文件到test_containeropenstack object create test_container test.txt
8、查看test_container中的文件openstack object list test_container
9、下载test.txt文件
rm test.txtllopenstack object save test_container test.txt ll

10、删除test_container中的test.txt文件
openstack object list test_containeropenstack object delete test_container test.txtopenstack object list test_container

11、删除test_container
openstack container list openstack container delete test_container openstack container list

]]></content>
      <categories>
        <category>专业</category>
        <category>运维</category>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ubuntu</tag>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>发展方向</title>
    <url>/essay-direction-of-development/</url>
    <content><![CDATA[吐槽：还没来得及回忆，大学就已经过去了一半。
两年里，接触了很多计算机方面的知识，C/C++、汇编、oracle、java、linux、数据库、数据结构、jsp、php、ssh、设计模式、个人网站搭建、安卓、微信……以及最近在学的.net、单片机、网络安全、加密解密、软件破解、软件工程等等。太多的方向，涉猎算是足够了，是时候选择一个方向深入研究了！毕竟全才几乎等于庸才！
经过一段时间的思考，我决定选择深入研究java，这门业界公认的最优美语言。原因嘛，很充分！最重要的一点是，学习java，让我感觉很流畅，很舒服；其次，它开源，可以让我深入研究学习，直到我可以自己设计出java；然后，java应用范围广，就业前景很好，以后转安卓、大数据、云计算也方便；还有，它拥有最多的开源项目，开源框架，可供我一直学习下去！也许还有其他原因，暂时就想到这些，嗯，就这样。
决定了方向，全世界都会为我让路？NO！那就自己开路！

目标：可以自己设计出java，设计出类似ssh的开源框架！
途径：阅读源码，思考，写demo！
近期计划：重新思考做过的项目 –&gt; 读java源码 –&gt; 读ssh框架源码 –&gt; 写出类似ssh的框架。

参考文档：开源项目阅读步骤来源：javaeye
开源项目已阅读了不少，总结下来按照下面的steps来操作比较恰当：
1）阅读features。以此来搞清楚该项目有哪些特性
2）思考。想想如果自己来做有这些features的项目该如何构架
3）下载并安装demo或sample。通过demo或sample直观地感受这个项目
4）搜集能得到的doc，尽快地掌握如何使用这个项目
5）如果有介绍项目架构的文档，通过它了解项目的总体架构，如果没有，通过api-doc了解源码包的结构
6）分两遍来阅读源码。第一遍以应用为线索，以总体结构为基础，阅读在应用中使用到的类和方法，但不用过深挖掘细节，对于嵌套调用，只用通过函数名了解最上层函数的意义，这一遍的目的在于把大致结构了然于心。第二遍就是阅读类和方法的实现细节，以第一遍的阅读为基础，带着疑问去阅读那些自己难以实现的模块。
7）总结。回味这个项目设计上的精妙，用到了哪些设计模式，能在哪些领域可以借鉴等等。

源码阅读思考来源：360doc最近有做源码阅读的事情，觉得有些费尽，做了一些思考。
一个大项目的源代码，不要过份详细的阅读。大项目，其代码量基本上是可以吓死人的。过份的关注细节，常常会拘泥于细节，而忽略了整体框架。当你能够看清框架的时候，亦花费了太多的时间。
因此，阅读一个大项目的源代码，其目的不在于欣赏代码细节，而在于迅速看清项目整体框架的大概面貌：都有那些模块，这些模块是干嘛的（不关心具体怎么干），模块之间的通讯机制大概是怎样的，然后在考虑子模块，通常只要掌握两级子模块就够了。花上1，2天的时间掌握这一切，就达到了阅读大项目源码的目的。因为一旦你掌握了框架，你就可以按照这个框架实现这个项目，虽然和原项目全然不同，但是完成的需求却是一样的。
在软件中，架构才是本质。
也许你指望详细阅读大项目源代码能看到高质量的代码，但是，大项目通常都是团队的劳动成果，每个人的不同水平造就了代码质量的高高低低，一个人在不同时间不同环境的代码质量也是不同的。要指望在大片源码面前找到高质量，简直是天方夜谭。
也许你要从阅读源码中掌握某项技术细节，比如bsp，又或者换装，那么，最好的建议是查找相关的技术文档以及文档上所附带的samplecode，这种samplecode一般不会附带任何干扰，简洁得只是为了证明该技术而存在的。如果没有这些东西，而只能从大项目源码中找的话，你提前先了解了框架，能更快的查找和定位到表达该技术的文件。但是通常都会比较不幸，因为你为了明白这一技术，通常要先理解混入其中的另一技术。
最后谈谈怎样才能阅读到高质量的源代码。何谓高质量？是指算法出人一表（比如某种o(1)的排序法）？还是采用了极端深奥的语言特性将某实现完美表达（比如模板的灵活运用）？无论是哪种，最好的来源是书，如《STL详解》，或者《inside XX》这样的东西。书的作者通常就是这些高质量代码的作者，他会带领你探索这些源码背后的真相。

如何阅读Java源码 阅读java的真实体会来源：中国互联
刚才在论坛不经意间，看到有关源码阅读的帖子。回想自己前几年，阅读源码那种兴奋和成就感，不禁又有一种激动。

源码阅读，我觉得最核心有三点：技术基础+强烈的求知欲+耐心。

说到技术基础，我打个比方吧，如果你从来没有学过Java，或是任何一门编程语言如C++，一开始去啃《Core Java》，你是很难从中吸收到营养的，特别是《深入Java虚拟机》这类书，别人觉得好，未必适合现在的你。
虽然Tomcat的源码很漂亮，但我绝不建议你一开始就读它。我文中会专门谈到这个，暂时不展开。
强烈的求知欲，我认为是阅读源码的最核心驱动力。我见到绝大多数程序员，对学习的态度，基本上就是这几个层次(很偏激哦)：1、只关注项目本身，不懂就baidu一下。2、除了做好项目，还会阅读和项目有关的技术书籍，看wikipedia。3、除了阅读和项目相关的书外，还会阅读IT行业的书，比如学Java时，还会去了解函数语言，如LISP。4、找一些开源项目看看，大量试用第三方框架，还会写写demo。5、阅读基础框架、J2EE规范、Debug服务器内核。大多数程序都是第1种，到第5种不光需要浓厚的兴趣，还需要勇气：我能读懂吗？其实，你能够读懂的。
耐心，真的很重要。因为你极少看到阅读源码的指导性文章或书籍，也没有人要求或建议你读。你读的过程中经常会卡住，而一卡主可能就陷进了迷宫。这时，你需要做的，可能是暂时中断一下，再从外围看看它：如API结构、框架的设计图。
我就说说如何读Java源码，以及我曾经的阅读感悟。
Java源码初接触如果你进行过一年左右的开发，喜欢用eclipse的debug功能。好了，你现在就有阅读源码的技术基础。
我建议从JDK源码开始读起，这个直接和eclipse集成，不需要任何配置。
可以从JDK的工具包开始，也就是我们学的《数据结构和算法》Java版，如List接口和ArrayList、LinkedList实现，HashMap和TreeMap等。这些数据结构里也涉及到排序等算法，一举两得。
面试时，考官总喜欢问ArrayList和Vector的区别，你花10分钟读读源码，估计一辈子都忘不了。
然后是core包，也就是String、StringBuffer等。
如果你有一定的Java IO基础，那么不妨读读FileReader等类。我建议大家看看《Java In A Nutshell》，里面有整个Java IO的架构图。Java IO类库，如果不理解其各接口和继承关系，则阅读始终是一头雾水。
Java IO 包，我认为是对继承和接口运用得最优雅的案例。如果你将来做架构师，你一定会经常和它打交道，如项目中部署和配置相关的核心类开发。
读这些源码时，只需要读懂一些核心类即可，如和ArrayList类似的二三十个类，对于每一个类，也不一定要每个方法都读懂。像String有些方法已经到虚拟机层了(native方法)，如hashCode方法。
当然，如果有兴趣，可以对照看看JRockit的源码，同一套API，两种实现，很有意思的。
如果你再想钻的话，不妨看看针对虚拟机的那套代码，如System ClassLoader的原理，它不在JDK包里，JDK是基于它的。JDK的源码Zip包只有10来M，它像是有50来M，Sun公司有下载的，不过很隐秘。我曾经为自己找到、读过它很兴奋了一阵。
Java Web开发源码在阅读Tomcat等源码前，一定要有一定的积累。我的切实体会，也可以说是比较好的阶梯是：1、写过一些Servlet和JSP代码。注意，不是用什么Struts，它是很难接触到Servlet精髓的。用好Struts只是皮毛。2、看过《Servlet和JSP核心编程》3、看过Sun公司的Servlet规范4、看过http协议的rfc，debug过http的数据包
如果有以上基础，我也不建议你开始读Tomcat源码。
我建议你在阅读Tomcat源码前，读过Struts源码，Struts源码比WebWork要简单得多。这个框架是可以100%读懂的，至少WebWork我没有100%读懂。我曾经因为读懂了Struts源码，自己写过一个 Web框架。
当然，在读Struts框架前，最好看过它的MailReader等demo，非常非常不错的。
如果你做过一些Struts项目，那么读它时就更得心应手了。
在读Struts前，建议看看mvnforum的源码，它部分实现了Struts的功能，虽然这个BBS做得不敢恭维。
如果你读过Struts，再开始考虑Tomcat源码阅读吧。
不过，我还是不建议直接读它，先读读onJava网站上的系列文章《How Tomcat Works》吧，它才是Tomcat的最最简易版。它告诉你HttpServletRequest如何在容器内部实现的，Tomcat如何通过Socket来接受外面的请求，你的Servlet代码如何被Tomcat容器调用的(回调)。
学习JSP，一定要研读容器将JSP编译后的Servlet源码。
为什么我总是称呼Tomcat为容器，而不是服务器？这个疑问留给大家吧。
如果你一定要读Tomcat，那么就读Jetty吧。至少它是嵌入式，可以直接在eclispe里面设置断点debug。虽然Tomcat也有嵌入式版本。
Java数据库源码阅读我建议，先读读Sun的JDBC规范。
我想你一定写过JDBC的代码，那么这时候可以开始阅读源码了。
如果了解JDBC规范(接口)，那么它的实现，JDBC Driver就一定要开始了解，我的建议是，读读mysql的jdbc驱动，因为它开源、设计优雅。在读mysql的JDBC驱动源码时，建议看看 mysql的内幕，官方正好有本书，《Mysql Internals》，我五年前读过一部分。比如你可以知道mysql的JDBC驱动，如何通过socket数据包(connect、query)，给这个C++开发的mysql服务器交互的。
通过上面的阅读，你可以知道，你的业务代码、JDBC规范、JDBC驱动、以及数据库，它们是如何一起协作的。
如果你了解这些内幕，那么你再学习Hibernate、iBatis等持久化框架时，就会得心应手的。
读过JDBC驱动，那么下一步一定要读读数据库了。而正好有一个强大的数据库是用Java开发的，Hsqldb。它是嵌入式数据库，比如用在桌面客户端软件里，如Mail Client。
Java通讯及客户端软件我强烈推荐即时通讯软件wildfire和Spark。你可以把wildfire理解成MSN服务器，Spark理解成MSN客户端。它们是通过XMPP协议通讯的。
我曾经在一个项目中，定制过Spark，当然也包括服务端的一些改动。所以它们的源码我都读过。
我之所以推荐它们。是因为：1、XMPP够轻量级，好理解2、学习Socket通讯实现，特别是C/S架构设计3、模块化设计。它们都是基于module的，你既可以了解模块化架构，还可以了解模块化的技术支撑：Java虚拟机的ClassLoader的应用场景。4、Event Driven架构。虽然GUI都是Event驱动的，但Spark的设计尤其优雅这么说吧，读它们的源码，你会为做一名程序员而自豪，因为无论是他们的架构设计还是代码,都太漂亮了。
Java企业级应用当然了，就是Hibernate、Spring这类框架。
在读Spring源码前，一定要先看看Rod Johnson写的那边《J2EE Design and Development》，它是Spring的设计思路。注意，不是中文版，中文版完全被糟蹋了。
在读Hibernate源码前，一定要读读Gavin King写的那本《Hibernate in Action》，同时，应该再读读Martin Fowler写的《企业应用架构模式》，它专门谈到持久化框架的设计思路。当你觉得这两本书读透了,再去看它们源码吧。
而且，在读源码前，你会发现它们用到很多第三方Jar包，二三十个，你最好把那些Jar包先一个个搞明白。
说到企业应用，一定会涉及到工作流。我当年读过jBPM的源码，网上有介绍jBPM内核的文章(银狐)。我感觉它的内核也就两千行，不要害怕。我曾经阅读jBPM源码的博客。
当然了，读工作流源码，前提是一定要对其理论模型有深入的了解，以及写过一些demo、或做过一些项目。
我上面介绍的这些，是我自己读过的，也适合一般人阅读。
我也读过一些非Java源码，感觉不错，也推荐给大家：
dojo源码 它的架构设计得很优雅，仿Java的import和extends。但实际应用起来一塌糊涂。我们当年基于这个开发了自己的框架，不过我不是主力。
Flex源码 Flex 08年底刚刚开源后，我就用它做过一个中型项目，应该说是国内的技术先行者。当时市面没有有深度的书，也没有开源项目。我纯粹是看Flex的Help文档和源码，把项目搞定的。两三年过去了，现在觉得系统设计得蛮优雅的。
好了，先介绍到这里。
上面说到的这些Java源码，我都是4年前、甚至更早读过的。技术变化这么快，像互联网的高速发展，催生很多高性能、分布式数据库，如hadoop。我一看，发现自己已经落伍了。
这几年，想必已经出现了很多优秀的框架，大家不妨分享出来。  

阅读开源项目源代码的方法来源：IT宅
最近在研究一个开源项目的源代码，庞大的类库和复杂的调用关系，看的有毫无头绪。
偶然间从网上看到了一篇不错的介绍如何读懂他人写的代码的文章，觉得非常不错，IT宅在这里分享给大家：阅读他人的程式码以下是内容的摘录：
1、读懂程式码，使心法皆为我所用程式码是别人写的，只有原作者才真的了解程式码的用途及涵义。许多程式人心里都有一种不自觉的恐惧感，深怕被迫去碰触其他人所写的程式码。但是，与其抗拒接收别人的程式码，不如彻底了解相关的语言和惯例，当成是培养自我实力的基石。
1.1、读懂别人写的程式码，让你收获满满
1.2、先了解系统架构与行为模式，再细读倘若撰写程式码是程式人的重要技艺之一，那么读懂别人的程式码，接着加以修改，也势必是另一个重要的技艺。从程式码的启始点开始读起，一来要循序读完所有的程式码旷日费时，二来透过这种方式来了解系统，很难在脑中构建出系统的面貌，进而了解到系统真正的行为。所以，阅读程式码的重点，不在于读完每一行程式码，而是在于有效率地透过探索及阅读，从而了解系统的架构及行为模式。以便在你需要了解任何片段的细节实作时，能够很快在脑上对映到具体的程式码位置，直到那一刻，才是细读的时机。
1.3、熟悉沟通语言与惯例用语
1.4、掌握程式码撰写者的心态与习惯
2、摸清架构，便可轻松掌握全貌在本文中，我们的重点放在：要了解一个系统，最好是采取由上至下的方式。先试着捕捉系统架构性的观念，不要过早钻进细节，因为那通常对于你了解全貌，没有多大的帮助。阅读程式码不需要从第一行读起，我们的目的并不是在于读遍每一段程式码。学会分析绘制系统架构图。
2.1、阅读程式码的目的，在于了解全貌而非细节我们在阅读文学作品通常是采循序的方式，也就是从第一页开始，一行一行地读下去，依循作者为你铺陈的步调，逐渐进到他为你准备好的世界里。阅读程式码却大大不同。我们很少从第一行开始读起，因为除非它是很简单的单执行绪程式，否则很少这么做。因为要是这么做，就很难了解整个系统的全貌。是的，我们这边提到了一个重点，阅读程式码的目的在于了解系统的全貌，而不是在于只是为了地毯式的读遍每一段程式码。
2.2、由上而下厘清架构后，便可轻易理解组成关系如果你想要跳脱困境，不想浪费大量时间阅读程式码，却始终只能捕捉到对系统片段认识，就必须转换到另一种观点来看待系统。从个别的类别行为着手，是由下至上（自下而上）的方法;在阅读程式码时，却应该先采由上至下（自上而下）的方式。对程式码的阅读来说，由上至下意谓着，你得先了解整个系统架构。
2.3、了解架构，必须要加上层次感不要忘了，我们采取的是由上而下的方式，要先摸清楚主建筑结构，至于壁纸的花色怎么处理，那是到了尾声时才会做的事。
2.4、探索架构的第一件事：找出系统如何初始化系统如何初始化是很重要的一件事，因为初始化是为了接下来的所有事物而做的准备。要了解一个系统，最好是采取由上至下的方式。先试着捕捉系统架构性的观念，不要过早钻进细节，因为那通常对于你了解全貌，没有多大的帮助。
3、优质工具在手，读懂程式非难事系统的复杂度往往超过人脑的负荷。阅读程式码的时候，你会需要更多工具提供协助。使用好的整合式开发环境（ IDE）的或文字编辑器，就能提供最基本的帮助。
善于使用各种优秀的IDE，方便跟踪阅读。3.1、善用文字编辑器或IDE中，加速解读程式码3.2、grep是一个基本而极为有用的工具3.3、gtags可建立索引，让搜寻更有效率3.4、再搭配htags制作的HTML文件，更是如虎添翼
4、望文生义，进而推敲组件的作用先建立系统的架构性认识，然后透过名称及命名惯例，就可以推测出各组件的作用。例如：当Winamp尝试着初始化一个插件时，它会呼叫这个结构中的初始化函式，以便让每个插件程式有机会初始化自己。当Winamp打算结束自己或结束某个插件的执行时，便会呼叫退出函式。必须熟悉常用的软件词汇，熟悉各种命名习惯，方便推敲类或者方法的含义。学会阅读和使用UML类图。
4.1、好的说明文件难求，拼凑故事的能力很重要你可以利用熟悉或者自己发明的表示工具，描述你所找到的情境。甚至可以只利用简单的列表，直接将它们列出。只要能够达到记录的目的，对程式码阅读来说，都能够提供帮助。或者，你也可以利用基于UML中的类别图，合作图，循序图之类的表示方法，做出更详细的描述。
4.2、探索架构的第一步─ ─找到程式的入口
4.3、系统多会采用相同的架构处理插件程式
4.4、随着实务经验，归纳常见的架构模式
4.5、善用名称可加速了解“望文生义”很重要，我们看到函式的名称，就可以猜想到它所代表的作用。
5、找到程式入口，再由上而下抽丝剥茧根据需要决定展开的层数，或展开特定节点，并记录树状结构，然后适度忽略不需要了解的细节─这是一个很重要的态度。因为你不会一次就需要所有的细节，阅读都是有目的的，每次的阅读也许都在探索程式中不同的区域。探索系统架构的第一步，就是找到程式的入口点。找到入口点后，多半采取由上而下（自上而下）的方式，由最外层的结构，一层一层逐渐探索越来越多的细节。
5.1、展开的同时，随手记录树状结构
5.2、无法望文生义的函式，先试着预看一层对于某些不明作用的函式叫用，不是望其文便能生其义的。当我们看到“itunesdb_init_cc （ ） ”这个名称时，我们或许能从“ itunesdb_init ”的字眼意识到这个函式和苹果所采用的的iTunes数据库的初始化有关，但“循环”却实在令人费解。为了理解这一层某个子动作的真实意义，有时免不了要往前多看一层。
5.3、根据需要了解的粒度，决定展开的层数适度地忽略不需要了解的细节，是一个很重要的态度，因为你不会一次就需要所有的细节，阅读都是有目的的。每次的阅读也许都在探索程式中不同的区域;而每次探索时，你都可以增补树状结构中的某个子结构。渐渐地，你就会对这个程式更加的了解。
6、阅读的乐趣：透过程式码认识作者即便每个人的写作模式多半受到他人的影响，程式人通常还是会融合多种风格，而成为自己独有的特色，如果你知道作者程式设计的偏好，阅读他的程式码就更得心应手。建立架构观点的认识是最重要的事情。虽然这一系列的文章前提为“阅读他人的程式码” ，但我们真正想做的工作，并不在于彻底地详读每一行程式码的细节，而是想要透过重点式的程式码“摘读” ，达到对系统所需程度的了解。
6.1、阅读程式码是新时代程式人必备的重要技能由上而下的阅读方式，是因为我们重视架构更胜于细节。
6.2、好的名称能够摘要性地点出实体的作用
6.3、转换立场，理解作者的思考方式
6.4、从程式码着手认识作者独有的风格，进而见贤思齐
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>《超越Java》</title>
    <url>/hobby-beyond-java/</url>
    <content><![CDATA[

题记：没有语言可以永远保持领先地位，Java统治的时代将会结束，这不是“会不会”的问题，而是“什么时候”的问题。

不久前，我以为，Java会是最有前途的编程语言！不久前，我以为，Node.js非常强大！不久前，我以为，编程很苦！
现在，我发现，Java可以超越！现在，我发现，Node.js在很多方面比不上Fib.js！现在，我发现，编程依旧很苦！
之前写过一篇《发展方向的思考》，现在看来，如此幼稚。那么，我的发展方向又在哪里呢？不再定下什么具体的语言，或者前端后端之类。我的发展方向，在于掌握学习的能力！没有什么语言和技术是不会过时的，我要掌握的，是一种快速有效学习的能力！比如，接触一门新的语言、新的工具，能够在一周或者更短的时间内上手！
简而言之四个字：学会学习！


Java从哪里来？到哪里去？1991年，sun公司的James Gosling领导的绿色计划，着力开发一种分布式系统结构，使其能够在各种消费性电子产品上运行，比如机顶盒。刚开始的时候使用C++，后来发现C++的各种不足，非常蛋疼，于是研发了Oak（橡树）来代替C++。
1994年，因特网迅速发展，工业界对适合在网络异构环境下使用的语言有一种非常急迫的需求。这时James决定对Oak进行小规模的改造，于是，1995年Java诞生。（名字取义自开发团队最喜欢喝的咖啡产地——Java。）
Java拥有巨大潜力，发展至今，已经成为全世界最流行的编程语言，未来也将无处不在。但是，它不可能一直保持领先地位，终究会被其他更优秀的语言取代。
Java的现状1、Java已经结束了领导趋势（大概在2005年），不再是创新的源头。2、Java不止一个接班者，未来Java仍然是无处不在的语言。3、Java已经远离它的基础，大型企业的问题获取很容易解决，但是简单的问题反而很难解决。Ruby on Rails 在某些例子中，效率远远高于Java。4、复杂，门槛高。建立一个简单的web应用程序，使用最普遍的框架，你必须学会一箩筐的知识。5、不自然的延伸，比如AOP或依赖注入。6、Java泛型的实现不足取。
1、Java社区很多很活跃。2、拥有最多的商业厂商和项目。3、开源项目非常多。4、可移植性好。（JVM比Java更重要）
什么是分布式系统？“分布式的”意味着计算的成本或性能取决于数据和控制的通信。
如果一个系统的部件局限在一个地方，它就是集中式的：如果它的部件在不同地方，部件之间要么不存在或仅存在有限的合作，要么存在紧密的合作，它是分散式的。
当一个分散式系统不存在或仅存在有限的合作时，它就被称作网络的；否则它就被称作分布式的，表示在不同地方的部件之间存在紧密的合作。在给出分布式系统具体定义的模型中，分布式系统可以用硬件、控制、数据这三个维度加以检验。
分布式系统=分布式硬件+分布式控制+分布式数据
分布式系统有很多不同的定义，但其中没有一个是令人满意或者能够被所有人接受的。介绍分布式系统，对它的特点的下列大致的描述足够了：
一个分布式系统是一些独立的计算机的集合，但是对这个系统的用户来说，系统就象一台计算机一样。
这个定义有两个方面的含义：第一，从硬件角度来讲，各个计算机都是自治的；第二，从软件角度来讲，用户将整个系统看作是一台计算机。这两者都是必需的，缺一不可。
POJO和EJBPOJO（Plain Old Java Objects）简单的Java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称。
使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接. 其中有一些属性及其getter setter方法的类,没有业务逻辑，有时可以作为VO(value -object)或dto(Data Transform Object)来使用.当然,如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。
JavaBean定义：一种用Java语言写的可重用组件（是具有某种功能，或者处理某个业务的对象）。
特点：共有类、无参构造、私有属性（共有的get、set方法）、可以有方法，但不作为业务逻辑
优点：Write once，run anywhere，reuse everywhere。（WORA）
EJB（Enterprise JavaBean）定义：EJB 从技术上而言不是一种”产品”，而是一种描述了构建应用组件要解决的标准。可扩展 (Scalable)、分布式 (Distributed)、事务处理 (Transactional)、数据存储 (Persistent)、安全性 (Secure)。EJB有EntityBean、SessionBean、MessageDrivernBean三种。
EJB的详解参见点滴之水的博客，讲的非常好。
Java纯面向对象？Java的基本类型并非继承自Object，所以Java是混种语言，而非纯面向对象语言。当初基本类型的引入，完全是为了吸引C++开发者。
系统编程语言系统编程语言，顾名思义，这个语言和操作系统联系很密切。比如C++，它可以精确的控制每个内存单元。但是在应用程序的开发中，根本不需要处理这些底层的细节，比如使用Java开发一个超级玛丽游戏。因此，按照我的理解，系统编程语言是可以处理操作系统细节的编程语言。
面向对象编程的三大特点封装、继承和多态。为什么是这三大特点，而不是别的？我想，是因为，面向对象编程语言先出现，之后大家才总结出来这三大特点。而不是定好了三大特点，才开始设计面向对象编程语言。
以下内容引用自Veda原型
封装封装是对象和类概念的主要特性。
封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
继承面向对象编程(OOP)语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。
通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。
要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。在某些OOP语言中，一个子类可以继承多个基类。但是一般情况下，一个子类只能有一个基类，要实现多重继承，可以通过多级继承来实现。
继承概念的实现方式有三类：实现继承、接口继承和可视继承。1、实现继承是指使用基类的属性和方法而无需额外编码的能力；2、接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；3、可视继承是指子窗体（类）使用基窗体（类）的外观和实现代码的能力。
在考虑使用继承时，有一点需要注意，那就是两个类之间的关系应该是“属于”关系。例如，Employee 是一个人，Manager 也是一个人，因此这两个类都可以继承 Person 类。但是 Leg 类却不能继承 Person 类，因为腿并不是一个人。
抽象类仅定义将由子类创建的一般属性和方法，OO开发范式大致为：划分对象→抽象类→将类组织成为层次化结构(继承和合成) →用类与实例进行设计和实现几个阶段。
多态多态性（polymorphism）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。
实现多态，有二种方式，覆盖，重载。1、覆盖(override)，是指子类重新定义父类的虚函数的做法。2、重载(overload)，是指允许存在多个同名函数，而这些函数的参数表不同（或许参数个数不同，或许参数类型不同，或许两者都不同）。
其实，重载的概念并不属于“面向对象编程”，重载的实现是：编译器根据函数不同的参数表，对同名函数的名称做修饰，然后这些同名函数就成了不同的函数（至少对于编译器来说是这样的）。
比如有两个同名函数：function func(p:integer):integer;和function func(p:string):integer;。那么编译器做过修饰后的函数名称可能是这样的：int_func、str_func。对于这两个函数的调用，在编译器间就已经确定了，是静态的（记住：是静态）。也就是说，它们的地址在编译期就绑定了（早绑定），因此，重载和多态无关！真正和多态相关的是“覆盖”。当子类重新定义了父类的虚函数后，父类指针根据赋给它的不同的子类指针，动态（记住：是动态！）的调用属于子类的该函数，这样的函数调用在编译期间是无法确定的（调用的子类的虚函数的地址无法给出）。因此，这样的函数地址是在运行期绑定的（晚绑定）。结论就是：重载只是一种语言特性，与多态无关，与面向对象也无关！引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”
那么，多态的作用是什么呢？我们知道，封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。
面向对象和基于对象的区别它们最大的区别在于：基于对象，没有继承！
OOP和AOP以下内容来自丁成云的博客
面向对象的编程（OOP）方法是在面向过程的编程方法基础上进行的改进，而面向方面编程（AOP）方法又是在面向对象编程（OOP）方法的基础上进行改进而来的一种创新的软件开发方法。
区别：面向领域不同。AOP和OOP是面向不同领域的两种设计思想。
OOP（面向对象编程）针对问题领域中以及业务处理过程中存在的实体及其属性和操作进行抽象和封装，面向对象的核心概念是纵向结构的，其目的是获得更加清晰高效的逻辑单元划分。
而AOP则是针对业务处理过程中的切面进行提取，例如，企业开发中经常会面临的种种非功能性需求（操作日志、权限控制、性能监测等等），用面向对象的思路，将业务操作对象的核心功能和对它的其他服务性功能代码分离，即某一个操作在各个模块中都有涉及，这个操作就可以看成“横切”存在于系统当中。在许多情况下，这些操作都是与业务逻辑相关性不强或者不属于逻辑操作的必须部分，而面向对象的方法很难对这种情况做出处理。 
AOP则将这些操作与业务逻辑分离，使程序员在编写程序时可以专注于业务逻辑的处理，而利用AOP将贯穿于各个模块间的横切关注点自动耦合进来。 
AOP所面对的是处理过程中的某个步骤或阶段，对不同的阶段领域加以隔离，已获得逻辑过程中各部分之间低耦合性的隔离效果，其与面向方面编程在目标上有着本质的差异。 
AOP的核心思想就是将应用程序中的业务逻辑处理部分同对其提供支持的通用服务，即所谓的“横切关注点”进行分离，这些“横切关注点”贯穿了程序中的多个纵向模块的需求。
关系：AOP是OOP的延续和补充。
AOP与OOP并不是相互竞争的两种技术,人们不是为了代替OOP而提出AOP,事实上AOP与OOP两者互相之间是一个很好的补充和完善。
OOP面向对象编程关注的是将需求功能“垂直”划分为不同的并且相对独立,封装良好的类,并让它们有着属于自己的行为。至于对象间的关系则依靠继承和多态等来定义，即OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。
而AOP技术则恰恰相反，它利用一种称为“横切”的技术，将OOP构建的庞大的类体系结构进行进一步的“水平”切割，并将那些影响了多个类的公共行为封装到一个可重用模块，封装成“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。 
AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。
面向方面编程则是希望能够将OOP构建的庞大的类体系结构进行进一步的“水平”切割,将通用需求功能从不相关的类当中分离出来, 封装成方面。
SOA面向服务架构。
REST表述性状态转移（英文：Representational State Transfer，简称REST）是Roy Fielding博士在2000年他的博士论文中提出来的一种软件架构风格。它是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。
复杂的问题驱动更高的抽象机器语言 -&gt;  汇编 -&gt; 结构化编程（C） -&gt; 面向对象编程（Java） -&gt; ?
元编程元编程（Metaprogramming）是指某类计算机程序的编写，这类计算机程序编写或者操纵其他程序（或者自身）作为它们的数据，或者在运行时完成部分本应在编译时完成的工作。很多情况下比手工编写全部代码相比工作效率更高。编写元程序的语言称之为元语言，被操作的语言称之为目标语言。一门语言同时也是自身的元语言的能力称之为反射。
泛型编程泛型编程（Generic Programming）最初提出时的动机很简单直接：发明一种语言机制，能够帮助实现一个通用的标准容器库。
四个准则下一个成功的编程语言必须满足四个主要的四个准则：1、需要建立一个明显的社区。只有让采用者安心，他才会去使用此技术。2、需要具备可移植性，Java虚拟机已经提高了后继语言的门槛。3、需要提供经济上的动力。目前，生产力对我来说，看起来就像是经济上的动机，但还是有一些其他的动机在引诱着我，像无线运算以及数据搜索。4、它需要展示技术优点，这才是最重要的一点。
知识欠缺Ruby、Perl、AOP（aspect-oriented programming）、Ruby on Rails、Python、Smalltalk、ObjC、Subversion……
结束语这是一本冲击思维，开启世界的书！上面的摘录，无法展现本书的十之一二。
本书并非是评判java的不足，而是从某种高度上讲述了java以及另外几种语言的优缺点、适合领域，并谈了下一代语言要具备什么特点。值得每个程序员认真读一下！
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《囚徒健身》</title>
    <url>/hobby-convict-conditioning/</url>
    <content><![CDATA[囚徒健身俯卧撑双腿始终要并拢，躯干、髋部、双腿始终要成一条直线。在动作最高点时，双臂要伸直，但不要让肘部完全锁定，而要使其微弯，以免关节不舒服。 
深蹲站起时慢慢完全伸直双腿。下蹲过程中身体稍前倾，用肌肉力量有控制地下蹲。在深蹲到最低点时，实际是“坐着”。

引体向上使用最容易的抓握方式，怎么舒服怎么来。起始姿势中，肘部微微弯曲，肩部保持收紧。借助肌肉力量把身体上拉至下巴超过横杆，而非惯性。
举腿训练过程收缩腹部。在举腿练习的最低点，用肌肉力量控制腿部抬起，而非惯性。
桥脊柱应该形成凹面，背部必须形成优美的弧形。髋部应该远离地面。双臂与双腿应该伸直。呼吸应该又深又平缓，自然的呼吸是掌握桥的标志。
倒立撑蹬起时双手离墙30厘米左右，双手与肩同宽。倒立时肘部保持自然姿势，舒服即可。身体略微向前弯曲，双脚比头部更靠后。只有双脚脚跟接触墙壁。
心态原理篇努力锻炼很重要，但耐心同样重要。我总是建议新手：不管你多强，都要从第一个动作开始。没错，六艺中每个单独的系列，都应该从第一式开始。切勿直接跳到第三、第四、第五式甚至是第六式。一定要从最简单的动作开始，然后逐渐增加强度。给自己留出至少四周的时间，然后再全力以赴地锻炼。或许两个月，直到你快要开始厌烦为止。
很多人会想，这太慢了。他们都坚信，最初几式的动作太简单，不需要在上面浪费时间。但大多数训练者（尤其是年轻小伙子）都会高估自己的能力。我见到许多自以为是、没有耐心的人跳过前几式，最后或者因为各种疼痛半途而废， 或者发现自己突然 “碰到一堵墙” 。
从长远来看，从零点起步更有益处。这不仅可以强化你的关节，重启你的神经系统，提高你的协调能力、平衡能力、反应能力和节奏感，还能更好地发展你的核心区力量，激发你挑战更难动作的动力。
通过体操变得真正强壮，这不应该是几个毛头小子玩的时尚，而应该是让你受益一辈子的东西。如此来看，为了打下足以受用一生的身体基础，仅投入短短的几个月，这并不算很久吧？
当然，如果你真的够强（而不是自认为够强），那么你不必从第一式开始。但从第一式开始，从来不是、也绝不会是浪费时间。
我教过的许多家伙都会问：“要多久才能升级到下一式？”这根本就是个错误的问题，他们应该问：“现在做的练习，能让我受益多久？”
我总是要对人不断地解释：前几式是后几式成功的关键，它们不是要被你踩在脚下的敌人，而是不会辜负你的朋友。在每一式上都花些时间，乐在其中，直到问心无愧地达到升级标准。
我不可能给出一个铁打的进度表，比如“一月一式”。每个人的情况不同，而且一般说来，在十式中达到升级标准所需的时间会越来越长。你越强壮，就越难变得更强壮，这一点人人平等。我认识一些壮得令人生畏的训练者，单单为了改进某个练习的某个细微之处（比如手的姿势、动作速度），他们就可能会花几个月的时间。
为什么要如此缓慢、保守呢？这有个极好的理由，就是“训练势头”。简单地说，这意味着如果你在训练中更慢地向前推进，你实际上会比急于求成者更快达到目标。听着像悖论，但这就是事实。
健身界前辈深谙此理，因此他们常常会说“榨干每个动作的营养”、“蓄势待发”等话。聪明的举重教练会对毛躁的年轻选手说这样一句老话：“杠铃又不会跑掉。”不要执著于数字，你的身体并不理解数字，也不在乎你做的动作是不是更高级、更酷，你的身体只理解你的努力。
可惜，现代人根本不理解这些，刚开始练，他们就想挑战极限。这部分地是当今文化的问题：我们生活在“现在就要”的社会里，今天的孩子并不把耐心当作美德——大人也一样。
简单来说，训练越努力，效果越好。因此许多训练者就以为，让自己变碍结实强壮的最快方式就是尽他们所能地卖力锻炼。可是，超大强度的训练存在不少弊端——尤其是对那些普通训练者来说，它会耗尽你的能量，吞噬你的训练动力，让你的关节吃尽苦头。
刚开始这样训练时，你很可能大有斩获，不过这只能持续几周，最多几个月。之后，这些收获将由于身体的抗议而慢慢停止。人体内可以用来培养肌肉和力量的能量就那么多，如果训练得真正艰苦，又不用药物，那么这些能量将很快耗尽。
适度训练的效果虽然不能和极限训练的相比，但还是有些效果，并且会在更长的时间内积少成多。几个月之后，适度训练者的肌肉和力量反倒会比早早透支的极限训练者更好。
对我的所有学生，我都建议2秒下、2秒上、在结束姿势中暂停1秒的练习节奏。你应该在所有系列中保持这一速度，至少到第五式。以2-l-2式的节奏练习，好处很多。首先，这样有助于保护关节，培养健康的软组织——只有强壮的关节才能更好地应付爆发式的动作。其次，这有助于培养训练者的控制力、协调性，还有强力的身心连接。再次，慢动作有助于你更快地变强变大，因为没有惯性捣乱，压力会完全地施加在肌肉和关节上，这会强迫它们不断发展。
最后，慢动作会使那些看起来很轻松的动作变得很难。（20秒做10次俯卧撑与l分钟做10次俯卧撑，哪个更难？）这意味着你可以利用那些危险极小的治疗性动作，收获更多的健康和力量，并培养训练势头，让后面几式变得更容易。
但是，你无需永远保持这个节奏。如果你是一步步锻炼过来的，那么在第五式之后把动作做得快一点儿也不错。事实证明，在最后的几式中，要完美地保持这一节奏也几乎不再可能。
我不建议超出自己的能力、不顾自身的安全、用邋遢的动作像白痴一样训练。但这并不是说你不应该努力训练，你应该努力。只要关节和肌肉准备就绪，你就应该全力以赴。
努力训练是实现目标的关键所在，但在自身体重训练的语境中，“努力”并不意味着精疲力竭。将注意力集中到你所能做的难度最高的动作上，但是如果你的动作开始走形，就应该立即结束该组练习。在做高难度的练习时，你可以通过使用“部分幅度”或“暂停休息”的方法（在短暂休息后再做一两次）多做几次。但不要冒进，要保证安全。在体操训练中，练到彻底“力竭”并不是好主意，你应该让肢休保留一定的能量，以能控制自己的身体。练到力竭特别不安全，尤其是在倒立动作（如倒立撑）和悬垂动作（如举腿和引体向上）中。总要留有余力，不要“弹尽粮绝” 。
大多数健美与力量训练计划都有“循环”或“周期”之类的概念。其实就是在训练期中调节强度，这就意味着训练有时容易，有时适中，有时很难。在健美与力量举训练中通常需要这样做，因为重量训练会刺激关节，损耗人体的免疫系统，但正确的自身体重训练不会如此。健美人士需要不时减少训练重量，否则就会身体就会透支甚至出问题。这种“降级”对体操高手来说并无必要。你无需调节强度，而应该一直致力于练习十式中你能做到的难度最高的动作，只要你已经遵循“慢工出细活”中的建议。
动作姿势完美。大病小病全无。没有受伤或没有觉察到受伤的预兆。已经满足初级标准所要求的反复次数。
如何在十式中从上一式升级到下一式？说起来很简单，先达到初级标准，然后每周或每两周（难度更高的动作可能需要三到四周）增加一次反复。如果能够一直坚持这样做，那你很快就能够在任何动作中做到一组十次；然后开始每次做两个锻炼组。
给你的两个锻炼组不断增加次数，久而久之，很快就能达到中级标准，然后再增加第三个锻炼组，但是只有当该练习的升级标准这样要求（大多数练习无此要求）时才如此。继续增加次数（保证动作标准），坚持一段时间，直到满足升级标准，再升级到该系列的下一式。
如果能够严格遵循这个简单的升级方法，那么你最终都能做到每一艺的第十式，即梦寐以求的最终式。你可以得意片刻，因为你已经跻身于让人一见难忘的训练者之列。但是技艺无止境，强壮之路永无尽头。当你达到最终式时，你可以看看“更上一层楼”的部分，那里有关于如何进一步提高的建议。
最后，要有信念。不要失望、沮丧或生气，坚持长期训练，适应它并感受它带给你的益处。信任你的身体。
不瞒大家，我过去做过许多大运动量的训练，部分原因是我想把注意力从监狱生活中转移开。但是，你真的不需要进行几个小时不间断的训练，如果只是为了追求力量，那就更不必如此。
我通常建议训练者只做寥寥的几组，而这常常令一些人感到困惑——他们视体操为一种耐力练习，而我视之为一种力量训练。能让你变得更强壮的是强度，而非运动量。
当然，大运动量的训练也能慢慢地提升你的力量，使你在很长一段时间之后，能做难度更高的动作。但是不管某些自大的训练者如何宣称，强度与运动量本身就是相互排斥的。也就是说，鱼与熊掌不可兼得。
如果你练习自己能做到的最难的动作，那你将只能坚持很短的时间，继续下去的话就会累倒在地。如果你可以持续练习几个小时，那说明你正在做的并不是你当前的极限动作。你应该尝试更难的练习！
如果你想找一个说明运动量与运动强度相互排斥的好例子，就去看看百米短跑选手。尽管他们的运动持续的时间很短，但百米跑选手的身体要比马拉松选手的更强壮，块头也更大。
这是因为冲刺跑比马拉松的强度大。马拉松消耗的能量更多，运动量更大，但它不仅不能促进、反而会限制力量与肌肉的发展。
你真的只需做几个锻炼组。为此很多训练者觉得不踏实，尤其是那些习惯了在健身房练到精疲力竭、浑身酸痛的健美爱好者。
但你需要知道，促使肌肉发展的刺激，只发生在很短的时间内，且不能累积。就是说，在刺激力量发展的方面，各组练习没有逐渐增加的效果。
举个例子，如果你在一组练习中卧推100千克，然后再卧推10千克，那么你的身体并不认为它需要发展出能应付110千克的力量。
自身体重训练也一样：如果为了适应、完善动作，三组甚至四组也可以接受；但若是为了获得力量与肌肉，那么一组就可以有很大收获——我通常建议练习两组，这样更有了“双保险”。
更多的训练不仅会不必要地耗费体力，也会延长身体的恢复时间，并可能令关节不适。努力训练，但不要“力竭”，总是至少储存一次反复的能量。
一个很好的判断方法是，当你的动作开始严重走形时，就结束这一组练习。如果你感觉需要突破这一点，那应该减小动作幅度，或者短暂休息一下，再做几次高质量的、姿势完美的动作；也可以只练习反向阶段（即从结束姿势回到起始姿势的阶段）的动作，但这应该是高级训练者在特定条件下才可以考虑的。
自身体重训练更加本真，因为它锻炼人体的方式正是人类在进化中所适应的方式。因此，没那么多“微创”，也没那么多力竭的感觉——你无需让自己完全虚脱。
如果想变得更强，那就要像短跑选手那样，而不要像马拉松选手那样。热身，然后冲刺！竭尽全力做少量的几组，不要无休止地锻炼，不要无端增加次数。
至于组间休息多久，那要看你的目标。想要达到终极耐力，休息时间就要尽可能短。 
有些家伙会使用秒表，好让自己逐渐减少组间休息的时间。另一种监测组间休息时间的方式是数呼吸次数，这种方法虽然没有使用秒表那么准确，但好处是有助于训练者关注自己的呼吸节奏—这是学会控制呼吸的第一步。
如果你想要练出力量和肌肉，就必须有足够的休息时间，以便在做下一组练习时能够全力以赴。这没有什么规定，完全要看你的个人情况。有人认为两个锻炼组之间的休息要足够短，或许在学校里他们就是这么学的，或许他们没有像正视重量训练那样正视自身体重训练。不管什么原因，这种想法都是错的。力量体操会耗尽肌肉内的糖分，使身体乏力。
如果你发现自己需要在组间休息5分钟才能恢复大部分气力，那就休息5分钟。
只是要注意，如果你需要休息5分钟以上，那么身体就会开始冷却——这时可以在屋里走走，伸展一下正在锻炼的肌肉，从而保持肌肉内的血液循环。
如果能直接应用以上这些关于身体智慧的原则，那么你就稳妥地走上了快速进步的大道——停滞最少、伤痛最少。
但这需要你对之前的锻炼情况有清楚的了解，因为所谓进步，就是超越你在过去的成就。可惜人的头脑是脆弱的、不完美的东西。记忆经常受时间、情绪、动机以及身体状况等因素的影响，因此训练者对每一次锻炼情况的记忆并不可靠。这是个问题，因为你需要很清楚地记住自己的表现，才能分析最近的进度，并且知道接下来需要挑战什么。很幸运，已有一种方法可以帮助我们彻底克服以上这些问题了。
我即将要展示的神奇技术，好用得令人难以置信，所以我得在此好好地吹捧一下。作为平台，它天衣无缝地结合了文本与图像，可以为你提供最大的自由与创造空间，而且还不依赖于外接电源或内部电池。病毒、木马、电磁脉冲都无法使之瘫痪，黑客也无法在远程将其黑掉。此外，即使科技有新的发展，它也不会过时，不会不能用。还有，它易于上手，我敢保证，正在阅读本书的人已经成功使用该方法多年了。 
也许这个神奇技术最大的优点是：几乎随处可得，且只需一丁点儿钱。你已经知道这个令人惊叹的技术是什么了，对不对？没错，就是纸和笔。
在训练之后尽快用纸和笔记录下自己的训练内容，下一次训练之前你只需简单地浏览训练记录，就知道这次需要实现或挑战什么了。
不要写在散页的纸上，既容易乱，也容易丢失。你需要一个日记本，不需要华而不实或漂亮可爱的本子，因为训练日记会被到处放，所以简单结实即可。
对训练的记录应该快速、有效。如果记录过程拖沓繁冗，你就不大可能坚持下去。
训练日记的内容不外乎锻炼日期、所做的练习以及相应的组数与次数等细节，必要时也可以附上一些相关的评注——当然，这不是必需的。
条目简单明了，可以写成“1x20“，而不是“1组：20次”。也可以使用一些简单的符号——什么样的都行，只要你容易理解并记住就好。
有些家伙真的从写训练日记中自得其乐，他们样样不漏，包括对练习技巧的新想法、强度水平、心理感受以及饮食效果等细节。我得承认，我的训练日记有时候更像《魔戒》中的一个章节，而不像简洁的诗歌——这样做可以让我从漫长而枯燥的监狱生活中暂时解脱出来。如果你不想这样，那大可不必浪费这么多笔墨。条目简短、整齐、准确，就非常不错了。
不管你信不信，监狱中最好的训练者并不像野兽般训练。是的，他们努力训练，全力以赴，其中很多人更是整天训练——但如果他们不控制节奏，就很难变得更强更硬。
在过与不及的微妙界线上，他们尽可能地运用自己从经验中收获的身体智慧，指导自己。就像约翰尼·卡什（Johnny Cash）所说的：“刀锋上前行。”你可以从中得到启发。开始时耐心一些，了解自己正在练习的动作，领会其中的细微之处，直到爱上它们。
一旦准备好，就努力训练，但不要让你的进取之心超过身体的适应能力和潜能。注意姿势规范，此外最重要的是，为肌肉和软组织留出它们所需的宝贵的休息时间。训练要循序渐进，不失智慧，并要在训练日记中记录自己的进步。好好热身，不要练太多组，充足地休息——如果你真想变得更强大的话。
如果能配合六艺，把这些古老的普遍原则学以致用，那么你将获得在梦中都无法获得的长远的成功。现在万事俱备，你只需再加入一些特定的训练计划就可以了。
训练计划墙壁俯卧撑 -&gt; 膝盖俯卧撑 -&gt; 标准俯卧撑 -&gt; 窄距俯卧撑 -&gt; 单臂半俯卧撑 -&gt; 单臂俯卧撑平卧抬膝   -&gt; 平卧屈举腿 -&gt; 平卧蛙举腿 -&gt; 悬垂屈膝   -&gt; 悬垂屈举腿   -&gt; 悬垂蛙举腿折刀深蹲   -&gt; 半深蹲     -&gt; 标准深蹲   -&gt; 窄距深蹲   -&gt; 单腿半深蹲   -&gt; 单腿深蹲半引体向上 -&gt; 标准引体   -&gt; 窄距引体   -&gt; 偏重引体   -&gt; 单臂半引体   -&gt; 单臂引体直桥       -&gt; 高低桥     -&gt; 标准桥     -&gt; 行桥       -&gt; 合桥         -&gt; 铁板桥靠墙顶立   -&gt; 乌鸦式     -&gt; 靠墙侧立   -&gt; 半倒立     -&gt; 标准倒立     -&gt; 窄距倒立
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>幽默笑话</title>
    <url>/hobby-joke/</url>
    <content><![CDATA[军训教官：“如果你的同学突然晕倒，应立即采取什么措施？” 我：“先抽一巴掌，看是不是装的！！！”
我现在还在上学，大二了，有次假期回家，老妈不停在旁边念叨:你看隔壁小徐，前几天都把女朋友带回来了；你小学同学刘什么，都准备结婚了；王老二和你差不多大吧？人家……我顿时就头大，就问，老妈你到底想表达什么？老妈楞了一下，笑说，我只是想告诉你，好好学习，现在交女朋友还太早……
初中物理老师在给新生上第一堂课时，没有像其他老师那样做自我介绍，而是一脚踹开了教室的门，说了句雷死人的话……逆我者，死！！

坐火车，一妹子睡觉有点热醒了，就自己脱了衣服用手扇扇风。看见了旁边睡熟中的弟弟，毫不犹豫就把自己刚脱下来的衣服直接就给盖上了。瞬间弟弟就热醒了。 我真是蒙了！！！
10086:你好，先生，请问你是本鸡的鸡主吗？我想开个玩笑:不是，我刚从公交车上偷来的…对方沉默了五秒后说:那好，祝你生活愉快工作顺利早日劳改…说完就挂了。我擦，这哥们的咒怨毒啊…
今天和闺蜜，男友一起吃饭，我突发性质问男友，我是不是温柔体贴，善良可爱，男友无比真诚的回答说是的，闺蜜说男友良心被狗吃了，男友头也不抬的说二十一世纪最重要的是什么，是保命啊。。。
初中的时候，我一女同学不懂事，觉得班里那些不爱学习的非主流小混混很帅，还暗恋一个，那个也不怎么爱上课，作业不写，考试成绩也是倒数，整天无所事事，但确实长得蛮帅的，同学也是真心喜欢他，最后我也没能拦住她，她还是去告白了，我就听到了最扯的拒绝理由，那男的说“我们还是以学习为重吧。。。”
幽灵：上帝，我下次投胎想和天使一样全身洁白，并且带着一对翅膀，但我仍然想吸血。 上帝：那你投胎做护舒宝吧。
第一天说你是猪，你不承认，被扁，不诚实。第二天说你是猪，你说你是，被扁，不谦虚。第三天说你是猪，你不说话，被暴扁，是猪还这么拽。
我都睡着了，有个妹纸打电话给我，喊我快登QQ，她有事给我讲，她就把电话挂了。我登上QQ，她发了一句“在？”我回了一句 “嗯。” 她又发了一句“晚安。”我瞬间睡不着了！！！！
刚给谈了四年的女友发：你爱我吗？一分钟后女友打来电话，女友：刚是你给我发的短信？lz：对啊。女友：你吃多了没事干吧。lz：就是想起来了给你发个短信。女友：你是不是给别的女人发，发到我手机上了？lz：………。现在正在各种解释中。
看别人都问老公爱不爱，昨天闲了也问“老公，你爱不爱我？”“爱”“你到底爱不爱我！？”“爱”“你爱不爱我？”“老婆，我没存私房钱，我没得撒子要交代的，我们睡觉吧。”
有次在广场乘凉，旁边有一个小男孩很调皮不听他妈妈的话，他妈妈没办法了给娃他爸眼神示意了一下，估计就是让他打两下，吓唬一下小孩。。娃他爸二话不说上去把小孩打了一顿，把小孩打的哇哇之哭。。然后。。。然后娃她妈过去踢了娃他爸几脚，狠狠地打了几下。。。为什么受伤的总是男人。。
刚才开安全会议，说到带安全帽的好处，举到个案例，说有个人几十米高空坠下，由于带了安全帽，脑袋一点事情都没有。我当时惊叹，这安全帽果然强大。结果他顿了顿说到，就是脖子摔断了，我一身冷汗啊。。。
老公今天去吃饭，我给他打电话，对话如下:“老公你干嘛呢”“嗯，废话，不喝酒叫老爷们啊！”“你怎么了？”“老子一会回家了！别催了！” “卧槽，老公你怎么了！” “挂了！就这样，麻烦！” …. 然后我拿着手机凌乱.. 一会老公来了条短信，媳妇儿，我装装逼，回家跪搓衣板啊 ..　
今天要出差，儿子大哭，我好感动，感觉到做父亲的骄傲，忽然听儿子边哭边说，把iPad留下，，，，，，，瞬间感到当爹太失败了
彭宇主持芝麻开门，排了三次开场，观众不满，彭宇安慰道：“其实，我们这是在为下下期节目录制开场。你们有没有发现，我拍了那么多期节目，一直没有换过衣服？其实，我连内裤都没有换过。”
“你的运气真好，这袋咸水鸭已经放这儿两年多了都没人拿走。”
“追不上宝宝，你可以追我们的导演啊？但是她结婚了你不介意吧？”
“像我这样完美型的都没有机会，你就更没希望了。”
我是这么教育七岁66斤的儿子的: 小时候人家看你胖，会说:“小肥仔过来，好可爱额！”长大了人家看你胖，会说：“滚开，死胖子！”从此他就每天起来跑步了！
今天听邻居跟他儿子对话如下，熊孩子：爸，将来有钱了我就买个飞机，天天送你上班。邻居：你都买的起飞机了，还tm让我上班？ 我当场笑趴了……
盛大员工可凭经验自动加工资！据盛大离职员工曝，盛大的工资体系是业界盛传的“经验值体系”，即你进公司有个初始等级，然后每天上班加经验，参与各种项目有项目经验值。经验值累计到一定程度升级，然后系统自动加工资！
今天上思修课，是两个班一起上的，老师讲到男女择偶观，一班妹纸站起来回答说喜欢诚实勇敢，有上进心，不抽烟不喝酒等等的。我们班一萌妹纸接了一句：我滴妈呀，这是要奔着我爸去的呀！我们全班凌乱了。
学长跟我们说：“你们是不是觉得很怕期末考试，不知道老师会出什么，我跟你们说，老师更为难，因为老师根本不知道你们会什么！”
微博上有人发：再也不想单身了，多么希望有个人可以跟我一起吃饭的时候抢菜吃，白天抢电脑，晚上抢被子。神回复：早上抢刮胡刀……
初中的时候，我的二货同桌有一天自习课闲的蛋疼，准备在班里找个女朋友。于是他拿出班里的名单，划掉前32个男的，又在女生里排除掉最不熟的和得罪过的。折腾了一番最终剩下两个女生，他挑来挑去最终挑出来一个，下课直接去表白，结果成功了，成功了，成功了……谁能给我解释一下这是为什么？
大学里，一次班会大家讨论喜欢什么类型的女生，轮到我时我说喜欢清纯唯美的，这时俩二货接着喊道我喜欢制服丝袜的，我喜欢国产精品的……然后班里就沸腾了……都怪我这头没起好……
宿舍有个内蒙人，说放假回家就去放羊！二货舍友就问：你会放羊吗？内蒙舍友答：我们内蒙人天生会放羊，认羊跟认人一样，每只羊长得不一样，都熟悉了！二货舍友接着问：你们都那么熟了还咋吃啊？蒙古小伙想了下：挑关系不好的吃……
大年初八了，该拜的都拜了，一会儿找个没人的地方，对着镜子，给自己磕几个响头，然后对自己说一声：“爷，您辛苦了！去年您真的很不容易，今年对自己再好点！”
现在社会变化的太快了！以前妈妈给我五块钱，我能从超市拿一盒饼干，两包牛奶，两袋面包，还有糖什么的，现在根本就不行了，超市基本都装上摄像头了！社会发展太快了！
如果你实在是饿了可以打电话给我，我随便吃点零食嚼给你听啊
两只老虎，两只老虎，谈恋爱，谈恋爱，两只都是公的，两只都是公的，真变态。
lz带着四岁儿子和3岁侄女去kfc 打滑梯玩，儿子被别的小女孩一把从 滑梯上拽下来了，没多高摔的不重我 就没去管。儿子就一边哭一边回头 喊：你等着！我让我妹妹过来打你！ 然后跑到他妹妹那诉苦，只见我侄女 撸胳膊挽袖子，上去一把把那小女孩也给拽下来了，我。。。。
楼主高中老师，教的其中一个班特别活跃，尤其是后排几个男生经常起哄。我课下叫了其中一个男生问，你们班主任的课也敢这么起哄啊。他回答，那得分情况，要是月初刚发工资那几天看老班红光满面的就敢起哄，要是月末看见他在办公室吃泡面 就不敢了。我拍拍他肩膀说，孩子们，我觉得你们能成大器！
大学里有一个天然呆的男同学！ 平时不大说话，憨憨的。大一时我们寝室有个女生暗恋他，好不容易约他出来。………………池畔，杨柳青青，紫藤花开，大好春光，女生脸微红，低头，摆弄衣角:“嗯……”男生恍然大悟，点点头:“要借多少？” 然后就没有然后了！
昨天遇到一对可爱的母女、母亲下楼时摔骨折被120送医院，女儿闻讯哭着赶来，一边哭一边说“妈妈你在 哪里摔倒的，有没有人扶你？我怕你讹人家啊！”妈妈痛苦的回话“我不是那样的人啊”都骨折还这么逗！
家有二货老妈一枚，老妈对老爸说，下辈子我还要做你老婆。老爸瞟了老妈一眼：下辈子我当屎壳郎也不做你老公！老妈笑嘻嘻的说：那我当粪球…粪球…粪球你怎么想…
地铁上听见一对情侣对话：“我发消息，为啥不马上回啊？人家多着急你造吗？”“可我马上回，你又马上回我，我再马上回你，这就没完啦。你得这么想：这就是网球比赛，你抽过来，我抽回去，你再回一记扣杀，没动静了，说明你得一分啊！”“哦…” 女孩若有心思点了点头，我和几个乘客也点了点头…
看见公园的老榕树上用刀刻着的那句熟悉的”永不分开”，我转向妻子:”老婆，你还记得这吗?”妻子面带微笑:”当然记得，当年你刻下的。”我难抑心中甜蜜:”这么多年啦，我们果真没有分开。”妻子低下头，思绪仿佛也回到了多年前:”是啊，当时知道你连出门约会都带着刀，谁特么敢分啊？”
由于工作需要，嫂子有三个手机号，所以在我的通讯录里存的是嫂子1，嫂子2，嫂子3，某天朋友看到了，那羡慕的语气到现在都忘不了：“你哥真牛逼”。
我草！（此评论虽然才两个字，但语法严谨，用词工整，结构巧妙，琅琅上口，可谓言简意赅，足见评论人扎实的文字功底，以及信手扭来写作技巧和惨绝人寰的创造能力，实在佩服佩服，再加上以感叹号收尾，实在是点睛之笔）
默默无闻地走了
今天去商场买洗漱用品，出门口碰到个卖袜子的小贩，吆喝卖袜子，十元三双，正好家里换洗袜子不够了，就过去掏出十元钱说来三双，小贩楞楞的看着我，突然说，你怎么不讲价呢？我心想，这还能便宜！然后欣喜的说:大哥，能便宜点吗？小贩回到:不能！！！！我艹，瞬间一万只草泥马在脑中奔腾。
今天有一个小屁孩在小区门口放鞭炮，专扔路人脚下面。我走过去问：小朋友你家大人呢？这么调皮。他以非常挑衅的口吻对我说：我自己出来的。于是我就心安理得的把他揍了一顿。
谢贤比coco大49岁，黄秋生比Jessie大23岁，马景涛比吴佳妮大20岁，刘东强比奶茶妹大19岁，吴奇隆比刘诗诗大17岁。我终于明白真爱迟迟不肯出现的原因，因为我还没有钱。
今天做公车，遇见一吊死男，站在一特开放的妹子旁边，妹子坐在那里，可以看到深深的沟。就在这时我看到那个吊死男神情有点不对，拿着手机鼓捣了一会儿对着妹子的沟，心想这货挺有经验，知道关快门声音。谁知紧随其后的是亮瞎我双眼的闪光灯。我说伙计，你是想拍多清楚？
朋友是个妻管严，那知不知怎么老婆惹了他，他爆怒：“再惹我，形同此纸。”然后把手里的纸撕碎了。 老婆二话不说，一巴掌拍到他身上：“我就惹你了，看你怎么着我吧？”说着，双手叉腰，怒目而视。 谁知朋友憋了半天，来了句：“你……你这不算惹我。”
前几天，lz看报道说，过几年中国由于男女比例不协调，大量男生找不到老婆，将出现大批男光棍。届时老婆将成为奢侈品。当lz骄傲的说给我gay蜜听后，我gay蜜冷艳一笑，“说的我们好像都喜欢女生一样。。。谁剩下还不一定呢。”lz:。。。
刚才跟一已婚男聊天，聊到女人，他说女人结婚前都爱撒娇，我说那结婚后应该就不会了吧？只见他深深吸了口烟，两眼含着泪花对我说:“结了婚就开始撒野了！”
昨天去火车站，看见一瞎子摆摊算命的，好奇，遂多看了几眼，这时瞎子说话了：“帅锅，别看了！过来我来给你算一挂。”我听了顿时就内牛满面了，尼玛！全世界那么多人都没看见我的帅！被一个瞎子看见了！！
以前暗恋一女神，一直不敢表白。有一天女神qq号突然上线了，我那个激动啊，随后女神发了条动态，说她姥姥过世了，好伤心，于是我就琢磨该怎么安慰安慰，想着想着他妈的手一抖点了个赞！！
我发现了一个特别有名的道理。
“发射用英语怎么说？”“biu”
如果你的大学没有遇见一个能说能笑能扯淡有意思有活力又文质彬彬懂礼貌又温柔又体贴又善解人意又乐观向上又热情洋溢可逗比可文艺的江苏徐州人，那你的大学还有什么意义？
南京的天气真调皮！
世界上最遥远的距离并不是生与死、也不是相爱不知，而是《火影忍者》第1集和大结局之间的距离。
虽然我姓郝，但我是一个坏人。
记得读高中时候班上有个逗比同学，被教导主任抓到谈恋爱，班主任开班会时狠狠的批评了他，并要求他写检讨，念给全班同学听。这哥们儿一听急了，愤然拍案而起：难道爱一个人有错吗？
每次和男朋友吵架，他就把手轻轻放在我头上，我自然而然的就乖了下来，以为是他爱我的一种方式，就没多问！有一天忍不住了，就问他，为什么我那么生气的时候，你摸我头一下我就不气了呢？那二货给我指着屏幕里的魔兽世界，看，这个技能，安抚野兽～～～～别拦我，我要弄死他
你那么吊，你请我们吃饭吧？
我问一个学霸数学如何考到190，他说不写前两个填空就行了
长得丑怎么啦，我自己又看不到，恶心的是你们。
养个儿子…跟玩游戏差不多，建个账号，起个名字，然后开始升级，不停的砸钱，砸钱，砸钱，一年升一级，等以后等级起来了，装备也神了，却被一个叫儿媳妇的盗号了…养个女儿…就象种一盆稀世名花，小心翼翼，百般呵护，晴天怕晒，雨天怕淋，夏畏酷暑冬畏严寒，操碎了心，盼酸了泪，好不容易一朝花开，惊艳四座，却被一个自称小婿的人整盆端走，真是情何以堪啊！为人父母容易吗。。。。
一直对发型不满意的人，有一个共同点：不肯承认这是脸的问题。。。
太阳当空照，花儿对我笑，小鸟说早早早，你有病啊起得这么早……
以后我有了孩子，就整天逼他玩手机，在他耳边唠叨：“还不去玩游戏？怎么又在写作业了？……”在逆反心理的作用下，他会经常背着我学习，会偷偷看题目……每次他被我训斥了，都会略带哭腔地说：“爸，求你了，就让我再写两页作业吧！”
岁月是把杀猪刀，知识就是把剃头刀。岁月只是对那些长得好看的人无情，而那些不好看的人，岁月拿他们一点儿办法都没有。
有一天可乐和咖啡在聊天。可乐问咖啡：“你觉得我们俩谁更长寿啊？”咖啡慢悠悠地回答说：“我也不知道啊，这要看你平时作息正不正常，有没有运动……”聊着聊着，可乐就没气了。
今天接到一个推销电话，对方说：“您好，先生，能打扰您一分钟吗？”我说：“不行，至少十分钟，已经很久没有人给我打电话了。”
一哥们带了一个榴莲在办公室吃，一妹纸嗲嗲地说：“我也想吃！”哥们儿很豪迈地说：“随便想，没关系！”
程序猿问科比：“你为什么这么成功？ ”科比：“你知道洛杉矶凌晨四点是什么样子吗？ ”程序猿：“知道，一般那个时候我还在写代码，怎么了？”科比：“额…….”
女神：你能让这个论坛的人都吵起来，我今晚就跟你走。程序猿：PHP语言是最好的语言！论坛炸锅了，各种吵架。女神：服了你了，我们走吧，你想干啥都行。程序猿：今天不行，我一定要说服他们，PHP语言是最好的语言。
我是一个苦b的程序员，今晚加班到快通宵了，困得快睁不开眼了，女上司很关心，问我要不要吃宵夜。我没好气地说，宵夜就算了，能让我睡一觉就行了。女上司红着脸说了句讨厌啊，然后坐在我身边不动，好像距离我很近，搞得我很紧张，难道她发现我的程序出了bug？
老公一定要找程序员！！！！！！钱多话少死的早
老婆给当程序员的老公打电话：“下班顺路买一斤包子带回来，如果看到卖西瓜的，就买一个。”当晚，程序员老公手捧一个包子进了家门……老婆怒道：“你怎么就买了一个包子？！”老公答曰：“因为看到了卖西瓜的。”
某人发帖子：“各位JR，我想做一个程序猿，请问有什么要注意的……”某猿：“等我下班跟你细说……”然后……就没有然后了我问程序员朋友借了1000，他说再多借你24吧，凑个整
程序员A: “我吃鱼香肉丝盖饭, 你吃什么?”程序员B: “宫保鸡丁盖饭.”程序员A 在点菜单写上：鱼香肉丝盖饭 1宫保鸡丁盖饭 1程序员B: “我还是要牛肉面吧!”程序员A 更正点菜单:鱼香肉丝盖饭 1// 宫保鸡丁盖饭 1牛肉面 1
我是一个程序猿，一天我坐在路边一边喝水一边苦苦检查bug，这时一个乞丐在我边上坐下了，开始要饭，我觉得他可怜，就给了他一块钱，然后接着调试程序。他可能生意不好，就无聊的看看我在干什么，然后过了一会，他幽幽说，这里少了一个分号。我惊奇的问：“你也懂这行啊” 乞丐说：“我以前就是做这个的。”
某程序员退休后决定练习书法，于是重金购买文房四宝。一日，饭后突生雅兴，一番研墨拟纸，并点上上好檀香。定神片刻，泼墨挥毫，郑重地写下一行字：hello world！
“搞IT太辛苦了，想换一行怎么办？”“敲一下Enter键。”
程序员不喜欢乾隆的第八个儿子，因为八阿哥 bug
一女同学在食堂吃饭时，一程序猿凑到旁边，“同学，我能和你说话不，我已经一个月没和女生说话了。
两个程序员在聊天：“我昨天碰到个辣妹。我把她带回家，马上就开始如饥似渴地亲吻，她就坐在我的键盘上，然后……”“你在家里也有台电脑？CPU是什么型号的？”
程序员的读书历程：x 语言入门 —&gt; x 语言应用实践 —&gt; x 语言高阶编程 —&gt; x 语言的科学与艺术 —&gt; 编程之美 —&gt; 编程之道 —&gt; 编程之禅—&gt; 颈椎病康复指南。
——男朋友写代码不理我，于是我悄悄删掉了所有注释，删了他邮箱里的资料，把笔记本上的注解都涂黑了。结果他知道后就要和我分手，我很伤心。。。但他的朋友告诉我，他没有砍死你才说明他是真的爱你。。。——你别TM编了，程序员哪来的女朋友！——SB，谁告诉你我是女的了！
如果男朋友工作从周一忙到周日跟你说不了几句话，该理解还是该伤心？最佳答案：你男朋友是程序员吧！放心程序员是不会有外遇的。。。
一位IT工作者的真实读书进阶路径：《计算机导论》《C语言从入门到精通》《计算机系统机构》《数据结构》《JAVA从入门到精通》《JAVAEE从入门到精通》《系统架构从入门到精通》《佛经》《老子》《颈椎病康复指南》《腰椎间盘突出日常护理》《腱鞘炎的预防与防治》《高血压降压宝典》《强迫症的自我恢复》《精神病症状学》《钢铁是怎样练成的》……《活着》
生活要想好，赶紧上淘宝要销路，找百度老乡见老乡，购物去当当发家致富靠劳动，勤俭持家靠京东孩子只生一个好，安全只用360
众里寻他千百度，蓦然回首，啥也没有！
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笑话</tag>
      </tags>
  </entry>
  <entry>
    <title>2014CS复试全面回忆</title>
    <url>/hobby-kaoyan-2014-recall/</url>
    <content><![CDATA[本文转载自：http://www.cskaoyan.com/thread-241053-1-2.html2014 CS复试全面回忆 上机真题 面试血泪史
编译原理：填空20分第一个问题忘了，第二个问题是给出几个产生式，问句柄和规约所用到的产生式，第三个问题是三重数组求内存所在的地址，初试为零，第四个考察数据流 有表达式，什么的  问的很奇葩  表示完全不知道解答题1 写能被4整除的所以二进制数的正则表达式， 000属于表达式    111000属于表达式，1001不属于表达式， NFA化为DFA 然后最小化2 S→xSyS|ySxS|空串      第一问要求根据给定文法写出长度小于6的全部串（6个的不包跨在内）  第二问（x(xy|yx)y(xy|yx)|y(xy|yx)x(xy|yx)）*要求判断给定的正则表达式是否符合文法要求  若符合 回答是 否则 给出反例      我回答的不是3给出语句S→do S1 while B  写出带回填的翻译语句


离散数学1第一题 要求证明所以的马都是同一种颜色   x=1的时候马显然是同一种颜色  假设X=n的时候N匹马都是同一种颜色  那个X=n+1的时候  将N+1排序 X1,,,xn匹马是同一种颜色  X2,,,xn+1是同一种颜色  则n+1匹马是同一种颜色2等价类的问题，设有5个元素，问能产生多少个等价关系使得会产生3个等价类， 然后再给出一个结论 用 m  n表示3很基本的谓词逻辑证明题、4第一问要求说明在什么样的情况下 G是欧拉图   第二问是证明哈密顿图5根据ABCDEF字母的出现百分比 要求画出最优树 并标出各结点的前缀码6证明对于一个顶点数大于1的简单无向图中，必然存在一个点v 使G-v依然连通7证明一个式子在布尔代数的条件下成立   式子忘记了 然后写出这个结论的对偶式
上机题写一个函数  Node *set_intersection(Node *h1,conse Node *h2)     讲两个链表的元素的交集 建成一个新的链表要求只写函数 不需要main函数 和测试函数
上机 B组貌似我们组是最慢的组第一个是陈林老师 貌似是教软件工程的  老师人很nice刚进去就问什么专业的   我说网络工程  要我说一下本科的学的网络有关的科目 并且解释一下第二个问题是编译原理的   自底向上 和自顶向下第三个问题是做个什么项目 说一下第四个是学没学过软件工程 我直接说没学过  然后问了别的  就随便扯了一些第五个 是让我半分钟看一张A4纸的文章  我完全不知道讲什么 当时很紧张  就看到了关键词internet  和 telephone 就开始随便扯
第二个老师吴小兵老师  人也很nice  感觉人很帅 用的苹果电脑  哈哈  问了很多数据结构的问题第一个问题 忘了第二个问题 问什么是红黑树第三个  问了一个算法问题  我完全不知道 就告诉老师不知道第四个问了决策树第五个问了数据结构的快速排序的时间复杂度   他的下届  然后问了他为什么比别的排序算法快 我没答上来第六个问了  给你N元钱  买一平方一米的  11   22 3*3 的土地 然后问 买到最少的块数怎么算   我们组里人讨论了一下  是动态规划问题   不是贪心算法第七个  what is your  favorite sport   然后我说了羽毛球  
第三个老师胡昊老师  很看着很和善  全程微笑  就是我已经被虐出来心里阴影了英语问题   说一下自己的毕业设计  说一下其中的难点 我说了半天 老师一句没听懂   然后老师就用对话的方式问我第一个问题  知道冯诺依曼结构吧  用过QQ吧  给我用冯诺依曼体系结构讲一个QQ的运行原理  直接跪了 要求换题第二个问题 知道聊天的时候 一个窗口的信息复制到另一个窗口 用的是什么原理  又跪了第三个问题  又回去了  问我 QQ两人远程 是怎么互相发消息的  我已经开始有心里阴影了第四个是C++的问题  一个是指针未初始化的问题  一个是const *char p和const char *p 的区别第五个问了 molloc free delete 这些申请空间或者释放空间 在那些具体的软件里用过然后虐心的问了我  这两个在课本的什么地方讲过  我真心无奈了  我真不记得了最后一个问题 已经虐了 都不记得是什么了  反正直接崩溃了   出来直接由阴影了   

面试之后感觉跪到家了我是下午E组的
第一个老师是聂长海感觉很和蔼，就像一直在和你聊天，自己也比较放松了1.问一下你的项目经历  我没有……2.软件工程的概念3.用英语描述一下你的未来之后叫我出去喊人进来再进来房间之后，不知怎么感觉非常紧张第二个老师1.用英语说一下群的概念  我立刻跪了……  后来用中文说了一下2.问了一下数据库所有安全性都可保证，但数据是否依旧有泄漏的危险3.数据库的四种性质，并解释一下一致性4.用英文说一下你最失败/伤心的经历第三个老师感觉自己脑抽了，基本没回答上题来1.1000！有多少位，想个算法  我说了一个 但他说不是结果2.27个人，3个空瓶换1瓶，问最少要多少瓶能满足一人一瓶   后来才知道可以先欠一瓶……我答了19瓶……唉……3.用英语说一下你最觉得最有意思的一门课
之后晕晕乎乎就出来了，感觉懵了，连老师名字也忘记看了，好像太紧张了只记得这些，还有一些忘了……

好吧。。我也来说下面试C组一.1.问了软件工程过程，貌似还记得不少，说了很多，需求分析，然后什么什么到最后的维护2.追问软件工程那个阶段所花时间多3.说下快速排序算法。  说出来了，然后让说了下原理，想了下回答道分治与递归4.英文介绍所做的项目（一个团队怎么完成一个项目）5.英文随便说一些东西
二（感觉回答比较好的一个）1.问了C++面向对象的特点 脱口而出2.问了操作系统线程和进程的区别 准备过3.问了java能不能进行类的多继承 脱口而出。。4.抽了一道题 4,4,10,10 怎样得出24  没到半分钟算出来了5.抽了道英语题 建议怎样使用软件之后老师还问我喜欢什么研究方向 然后又闲聊了一会
三抽了2到题和一道算法题，一道英文题1.windows内存管理  说啊说 知道的不管对不对都说2.图形题 三个点不在一条直线上，问能画几条线 使三个点到这条线的距离都一样  没思路3.对几万个员工年龄进行排序   一开始回答的快速排序，然后说啊说，中间还追问了快排的时间复杂度   然后提醒下了年龄，瞬间想到基数排序 说啊说4.老师让用英文介绍自己做过的一个项目（好像是临时加的吧，问出这个问题老师和研究生都笑了）  搞的我好郁闷，老师一直在旁边说，说2句，就说2句。哎坑坑爹爹的说了几句
然后over~

面试时这样的，每个老师都至少要问一个英文问题，要回避自我介绍（为了保证公平性，曹老师说的），每个人要被三个老师面，大约每个老师面10分钟，问3~5个问题，总计一个人30分钟左右。貌似今年面试总共是119人，分成上午和下午，上午60人，下午59人。上午和下午又各分成5组，一组12人。一次进三个人，不过因为每个老师面的速度不太一样，所以到后来顺序有点乱。我是下午的D组的第一个老师，不知道叫啥，普通话不标准，被坑了。问了专业，好像和他的方向不太一样。所以他开始临场编题目（我猜的）。1、问了我防火墙，吓，我知道这个名词啊，问我防火墙应该布置在网络中的哪层，胡吹一通，反正我知道你也不懂，哈哈哈。。。2、开始问编译原理，我知道这是你的老本行，问了编译型和解释型的区别3、问代码量，做过啥项目，随便吹吹4、问了脏读脏写，但是那坑爹的口音，我听成了章（zhang）读，章写，尼玛。。。完全没答出来，还以为是什么新术语，最后才反应过来，想说的时候，老师居然说就到这吧。。。一坨汗。。。老师不应该持证（普通话证）上岗的吗。。。5、老师说好的英文题呢。。。无语中。。。第二个老师 刘奇志挺好的一个老师，慢条斯理的。1、本科什么专业2、毕设做的什么3、平时有做过什么大的课程设计吗4、有什么感兴趣的方向5、一小段专业英文文字的翻译，大概七八行的样子第三个老师 戴新宇1、做过什么项目2、知道什么叫hypothesis test吗3、一道智力题，两个5,6L的杯子，称3L水，先量1L,再量2L,然后3L就搞定了4、pagerank算法的原理，大概讲下图，矩阵*向量，收敛之类的就okay5、一段英文文字翻译，用两三句话概括
补充：三个老师都问了有木有联系导师，学渣当然木有啦。。。逃（

我也是说B组第一个是胡小兵老师坐对面看了我一眼，开始问我离散的问题第一，什么是集合，什么是函数【我答了映射到一组数据之类第二，什么样的映射才是函数第三，英语题，你要是能考上要做什么第四，你知道np问题么【我问是不是p和np，他说是，然后我说不会，我觉得我不该问问题不止这些但是一紧张就……了
第二个老师是陈林老师，人真的好第一，你哪门学得最好【初试四门第二，做项目多么，毕设做了么，写代码多么【问得很细第三，我回答了很多我学的一般，问我知道指针么……我说知道，就问我指针滥用有什么不好的后果，我回答内存泄露，让写了个小代码说明什么是内存泄露，写错了，老师提醒之下想起来了，说意思对第四，知道什么是红黑树么第五，给了一小段文章，两分钟英语总结，AI的内容，20秒准备，扯了几句，本来要说三十秒的，不知道说的什么，后来就说没话说了
第三个老师胡昊老师是被虐了第一，问我什么是数据，我扯半天没说出，又问什么是数据结构，我说我也忘了，再问什么是程序，我已经……不知道啥了第二，给了一段程序让看有没有错，我说没有就换下一个题了，现在看是有了第三，说说你哪门考得最好，哪门最差为什么，英语题第四，数据结构有哪些类型，这个时候脑子已经不转了，提示才想起来树和链表第五，问知不知道树在用到的哪些软件里边有应用，我真不知总体来说老师人都很好，模式其实不是一开始想的站在教室里面对老师就是三个老师坐在各自的地方你去找他们说话

上午D组胡昊：（被虐）

英语题：最感兴趣最喜欢的科目
什么是抽象数据类型
什么是程序，然后举个例子，比如说炒菜用程序怎么实现（炒你妹啊！！）
单步调试遇到过什么问题（我可以说就没怎么用过么。。。本人动手能力比较差）
综合型题目：在网页中输入一个网址然后回车，问在网络中是怎么实现网页请求的，说出整个过程（回答的乱七八糟，只说出了DNS）詹德川：（问题较多）
英语题：can you describe the process of HTTP?(第一遍没听懂，第二遍老师一个单词一个单词念给我听。。囧，最后只说出了http全名)接着又让我用英文说说其他的协议
特征值的问题
大数定律和中心极限定理
数据库的ACID并且分别解释
快速排序和归并排序的时间复杂度，哪个用的多，为什么
编译中的：LR文法并解释还有好多记不得了戴新宇：（自然语言处理，190的个子，挺帅的）
给你10个文章，如何找出两篇内容相似的
学过什么语言，c++中的struct和类的区别
编译中follow集的作用（只说了自底向上时用来归约）
二维数组的两种存储方法（按行和按列），按列存储时如何访问（按列访问），为什么？（当时没反应过来，说按列存储就按列访问啊，结果晚上睡觉时想到应该说局部性原理的。。）
英文题：你觉得对女生学计算机的看法是什么（本人是女生。。），并说说你为什么选择南大，还让组织了一分钟，最后还是语无伦次，老师都笑了。。


我也说说我的把~我是上午C组的刚进去第一个谢磊老师，人很好，他的问题都是智力题    第一题：实现智能书架要用到什么技术，说说你自己的想法。    第二题：五个药罐子，每颗药丸1g，其中有一瓶受潮里面每粒药变为2g，问如何只称一次找出受潮的药罐。    第三题：三个空瓶换一瓶汽水，有27个人，问最少买几瓶汽水才能保证每个人都能喝到汽水。    第四题：can you talk about a moving star?anything about it is ok….好像是这样的….第二个老师不记得谁，签名没认出来…    第一题：学过什么语言，说说他们之间的区别    第二题：做过什么项目…..我问能否说课程设计，他说可以。    第三题：talk about your favorite sports.第三个老师，也没认出来….     第一题：学过软件工程吗？我说没，然后他问你我什么专业，之后说了些专业课程之类的   第二题：死锁的四个必要条件   第三题：做过什么大的项目没有，或者课程设计也可以(刚刚第二个已经问过….)    第四题：给一张纸，是一篇英文，关于data structure…看一分钟纸还给他，然后用英语说说讲了什么..支吾了半天….说的很烂   总体上感觉还好，老师都会给一些你会的让你答,不过感觉口语答的超烂…..

我也来回忆一下，（E）组的
第一个老师（聂长海）好老师啊，笑咪咪的，很可爱1、操作系统有什么功能2、学了软件工程吧，（嗯），来谈谈，学过软件工程有什么想法3、用英语介绍一下自己的最喜爱的课程然后就跟我聊聊生活方面的了。。。
第二个老师  詹德川（手拿ipad），还是很可爱啊
1、你的名字跟我一个高中同学一样，不过他是个男生2、用英语描述一下ipad3、知不知道傅里叶公式4、罗素悖论知道不5、数据库学过吧（恩），怎么样（不好），软件工程学过吧（恩），恩么样（不好），你是不是学计算机的（恩，是的），老师无语。。。。轻虐6、一型文法知道不，（忘记了），那0型文法呢（答了一些），那o型文法自动机与图灵机等价不（不知道）
第三个 （名字忘记了），虐死
1、来我们先问个发散型问题，镜子跟眼睛的问题（上年也有人问过），我答了，显然他楞了一下，知道我是知道答案的，接着问为什么，我说是眼珠动的缘故吗？他说，这跟眼珠有什么关系（囧）2、来我们问个数学问题，10个蓝球，8个绿球，6个白球，2个黑球，问至少摸多少球，有4个球同色3、现在有I Love  china三个单词，用一种复杂度最少的算法，变成china love i4、现在有一个工人给我打工七天，我有一根金条（老师很形象，说像德芙巧克力的金条，可以掰），每天要付工人1/7的金条，只能掰两次，问怎么办（算了很长时间，没算出来，问老师，给了提示，还是没算出来，老师说，都给提示了，怎么还算不出来，囧，被鄙视）5、假如现在有个智能报纸，看你怎么设计（囧，前面那兄弟问的是智能书架，还是没逃过智能这一关）6、用英语谈谈自己最喜欢的课程，尼玛，一紧张，说了句，debugging，老师笑了，老师说，详细点，我说compling，老师和旁边的师兄都笑了

我是上午D组，也来说说第一个，胡昊老师：
  第一个问题，用英语介绍一下你最喜欢的课程  第二个：给看了两行代码，有关指针的，问对不对          然后问了const几种用法的区别和内存泄露  第三个：问了一个程序从运行开始的过程，第一条指令地址怎么得到，如何取，等等  第四个：网页浏览显示的原理，具体说说
第二个老师：戴新宇老师他的问题很有开放性，比较难答：先是智力题，6升杯和5升杯；量三升然后问了假设检验的原理然后英语问题是看一段英语文章然后用英语概括开放性问题：编写一个股票预测软件，说说思想，我回答的很烂。。。。就记得这么多了。。。
第三个老师：詹德川老师 lamda组的他问题很多很杂1.抛无数次硬币，发生连续100次都是正面的概率是多少2.上一个问题给出答案构造性证明3.大数定理中心极限定理4.幺元的定义5。三型文法的定义6.用英语论述http协议 给跪了  说得不好  让换了一个阅读论文说大意题  大概说的是模式识别7。A的秩是ra B的秩是rb 问AB的秩是多少还有几个记不住了。。。
总结一下，老师爱问概率，编译，OS的内容 离散较难只会问概念什么的，英语实在说的不好可以换看文
章说大意，一般老师都会让换。有会的尽量说，不是完全贴切题目也可以说，老师比较愿意你说他听，
相关的你都可以扯扯，一般老师都会很愿意听。智力题一般都是第一个，智力题做过的话最好也装作没
做过，用笔写写然后说出答案，一般老师如果认为你是自己做出来的，对你的印象会较好，问题也会稍
难，大概情况就是这样。

几天了，一直没时间。现在来分享一下~我是下午A组的
T1：上来就跟我说他是搞算法的，差点吓尿。1.说说离散数学中什么是二元关系，什么是对称，什么是传递，什么是偏序，什么是全序，什么是闭包（闭包的三个性质）。2.堆排序，堆的存储结构，堆排序的时间复杂度，堆排序的过程。3.图的问题，怎么判断一个图中是否有环，深度优先遍历的过程。4.英语说堆排序的过程。
T2. 全程笑面。。。艹！1.说说你做过的项目，用到什么技术，你做了什么2.英语问题，问你自己（没跟别人一起的）做过什么项目。项目中出现什么问题，怎么解决？3.问我怎么去做一个网页搜索~ 瞎吹关键字什么的，就问我具体过程，我说不知道，就问我如果让你做，你会用到什么技术4.忘了。。。。
T3.1.读一段，然后翻译，关于社区网络，个人隐私什么的。2.操作系统的层次结构，4个必要条件3.问我感兴趣的方向，我说大数据，就一直问。。 问我大数据跟数据挖掘真的有关系吗。。（问的我可怂）4.后面已忘记。。。
感谢王道~ 也希望能帮助到下一届的学弟学妹~~

E组（没有记老师的名字）第一个老师：1、智力题：两个圆，半径分别为1和2，小圆分别在大圆的内部和外部紧贴大圆，问绕大圆一圈后，小圆自己
绕了几圈？（没回答上来）2、一个树状结构，每个节点都有数字，问你怎么在不借助任何结点的情况下将这棵树转化为双向链表？（完全不知道了）3、忘了。4、用英语介绍毕业设计（瞎说的）
第二个老师1、知道哪些优化算法？（很不幸，紧张过头，后来才想起一大堆）2、现在先进的技术介绍，比如云计算？（这尼玛，我哪有时间关注，没办法，只好跟老师大讲特讲了我一个研究生同学在研究的东西，反正我也不懂，就这么使劲地扯）3、做过的项目介绍。（幸好本科期间做过一个项目，这时候终于用上了）4、不知道什么问题了，反正我就扯了在学校怎么对编程开始感兴趣的。5、一张A4纸，两分钟阅读上面的英语后，然后要求给他讲讲英文主要表达的是什么，跟我们现在的哪些技术有关？当时只看到shape matching 于是我就说道模式匹配，联想到了现在的指纹识别与脸部识别等等。
第三个老师1、怎样证明两个集合相等？（A是B的子集，同时B是A的子集）2、怎样证明两个集合中的元素个数相等？（当时我懵了，开始说阶相同就OK啦，可是不对，然后弱弱地问了老师可不可以编程统计来实现，老师抬头一笑百媚生，笑眯眯地说不行，我立马跪了，说智商还不够）3、还是跟集合有关，可是忘了是什么了，只知道我没学过，然后换题。4、数据结构中，解释一下二路归并排序怎么工作的，然后时间复杂度是多少？（so easy）5、英文题：As we all know operating system is very important,then please explain why we need OS?(只记得当时语无伦次，能扯就扯，毫无节操)6、操作系统的三态？什么时候处于其中的哪一态？若是涉及与外存，增加了什么态？

大家的都好难啊，我的简单不少。。。南大虽然今年复试刷人不多，但还是把自己的面试题发上来吧，希望后面的学弟学妹们可以参考下。下午A组：高宇老师（问的不难，人也很好）：1.解释下栈和队列，相同和区别。2.栈和队列的应用。3.接上题,队列在图的广度优先遍历中的作用。解释图的广度优先遍历及复杂度。4.数组和链表的区别。5.接上题，二分查找只能应用在哪个数据结构上面，用英语描述下二分查找。
路通老师（有点小虐）：

有项目和竞赛经历吗？答：没有（被鄙视了）。。。。英语题：what is computer science?还没说两句，接着问what is the difference between computer science and mathematics?（口语各种结巴。。。）
内存泄露。
计算机体结构中的知识在实际应用中的体现。
说说多线程的应用。这里还问到了守护线程，貌似是linux中的知识，各种不会。。。。
图形和图像的区别。貌似还问到了先验概率和后验概率。

王崇骏老师（虐的灵魂出窍了）：上来看看我的初试成绩，直接来一句：你是学计算机的嘛。。。。。我：是的。。（这么问的原因不详，可能是初试专业课分比较低）。1.翻译一个abstract，文章不难，但是当时有点紧张，翻译的结结巴巴的。2.问我打算研究什么方向，我说数据结构和算法。他说是以后，然后我就随口说了个云计算和大数据。汪老师问：什么是云计算，什么是大数据，他们有什么关系？云计算和现在的计算方式有什么区别？都是这个方面的问题，问到最后我已经说不出啥来了。结束的时候王老师说：如果你真的要从事这方面的研究，得好好补补课了。。。。。。

]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS设置</title>
    <url>/hobby-macos-settings/</url>
    <content><![CDATA[系统相关用户名系统偏好设置，用户与群组，点按锁按钮以进行修改。右键用户，高级选项。修改账户名称为vk，这个名称是shell中显示的用户名。修改全名为voidking，这个名称是mac系统显示的名称。个人目录，修改为 /Users/vk ，这个目录是新的home目录。
修改完成后点击“好”，系统重启，然后整个系统恢复到出厂状态。


密码系统偏好设置，用户与群组，更改密码。
触控板系统偏好设置，触控板，光标与点按。勾选 轻点来点按，勾选 辅助点按，跟踪速度调整为喜欢的速度。 
电脑名称系统偏好设置，共享，电脑名称，编辑。
开机声音1、关闭开机声音
sudo nvram BootAudio=%00sudo nvram SystemAudioVolume=%80

2、打开开机声音
sudo nvram BootAudio=%01sudo nvram -d SystemAudioVolume

WindowServer占用资源过多系统偏好设置，辅助功能，显示，勾选减弱动态效果和减少透明度
临时设置不关闭屏幕sudo supmset -g | grep sleeppmset -a displaysleep 30pmset -g | grep sleeppmset -a displaysleep 10pmset -g | grep sleep

菜单快捷键右上角苹果按钮，点击会出现“睡眠”、“重新启动…”、“关机…”等菜单选项，这些选项可以设置对应的快捷键。以设置“睡眠”快捷键为例：右上角苹果按钮，系统偏好设置，键盘，快捷键，App快捷键，加号，菜单标题输入“睡眠”，键盘快捷键按下“control+command+S”。以上，就设置好了睡眠的快捷键。
查看文件使用mac系统的Finder，可以查看“我的所有文件”，但是这是假的，点击这个选项只能看到最近使用的一些文件。
解决办法：打开Finder，command＋逗号，出现Finder偏好设置，边栏，设备中勾选硬盘。然后在侧边栏中，就可以打开硬盘，看到所有文件了。
当然， /etc 这种文件夹是看不到的。
设置默认文件排序打开Finder，点击家目录，command＋J，选择排序方式（种类），用做默认。家目录下的所有目录，都会继承这种默认排序方式。
禁止生成 .DS_Store.DS_Store(Desktop Services Store)文件目的在于存贮目录的自定义属性，例如显示方式为图标还是列表。
禁止：defaults write com.apple.desktopservices DSDontWriteNetworkStores -bool TRUE开启：defaults delete com.apple.desktopservices DSDontWriteNetworkStores
注意：禁止生成 .DS_Store 后，已经存在的 .DS_Store 不受影响。
清除最近项目点击左上角苹果图标，最近使用的项目，清除菜单。
但是，上面的方法并不会清除“最近项目”这个目录下的文件记录，这是因为“最近项目”是spotlight管理的。解决办法：1、点击左上角苹果图标，系统偏好设置，聚焦，隐私，点击+号。2、选择目录A，点击选取。3、再看“最近项目”，已经不再显示目录A里的文件。需要注意的是，如果从隐私里去掉目录A，那么目录A里的文件还会慢慢出现在“最近项目”。
如果想要改变“最近项目”目录筛选文件的规则，按照如下方法处理：1、给“最近项目”添加一个搜索条件，让其只显示最近三天内打开或修改过的项目2、在“最近项目”窗口中点击工具栏的齿轮按钮然后选择“显示搜索条件”3、在搜索项目里选择“上次打开日期”4、然后设定好相应的搜索条件，点击“存储”5、最后为其命名，切记勾选“添加到边栏”再点击“存储”6、边栏就会新增这个只显示最近 3 天项目的选项，然后把原来的“最近项目”从边栏移除掉。
打不开软件从网络下载的软件，安装时提示：打不开“xxx”，因为它来自身份不明的开发者。
解决办法：系统偏好设置，安全性和隐私，点锁按钮以进行更改，任何来源，允许来自任何来源。
安装字体1、从windows系统 C:\Windows\Fonts 目录中拷贝需要的字体。2、command+shift+G，输入 /Library/Fonts，前往。3、字体放入 Fonts 目录。
启动sftp1、系统偏好设置，共享，勾选远程登录
2、测试sftp localhost
目录规划${HOME}目录下，创建以下目录：

tmp：在该目录中执行命令、测试脚本等，随时可删。
scripts：成熟的脚本放在该目录下。
git：在该目录中存放git仓库。

读写ntfsmac不借助第三方软件，也是可以读写ntfs文件系统的移动硬盘的。1、查看移动硬盘名称在桌面上查看硬盘名称，或者通过diskutil list命令查看硬盘名称。
2、修改fstab配置比如硬盘名称为WD，那么在/etc/fstab中添加配置：
LABEL=WD none ntfs rw,auto,nobrowse

3、重新插入硬盘推出硬盘，再重新插入，发现桌面不再显示该硬盘，没关系。
4、读写移动硬盘
df -hcd /Volumes/WDopen .

5、推出移动硬盘方法一：
cd ..open .# 界面点击推出移动硬盘
方法二：
cd ..diskutil unmount /Volumes/WDdiskutil unmount force /Volumes/WD

软件相关shell1、打开shellcommand＋space，输入“terminal”。或者 Launchpad，其他，终端。为了方便使用，可以把终端放到Dock。
2、个性设置在home目录下创建 .bash_profile 文件，内容为：
# llalias ll="ls -l"# for colorexport CLICOLOR=1# \h:\W \u\$export PS1='\[\033[01;33m\]\u@\h\[\033[01;31m\] \W\$\[\033[00m\] '# grepalias grep='grep --color=always'
更好的方式是，使用ohmyzsh。
更多关于shell的内容，可以参考《Shell实用脚本》。
ohmyzshOh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with thousands of helpful functions, helpers, plugins, themes, and a few things that make you shout…”Oh My ZSH!”
sh -c "$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"# orsh -c "$(wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -)"

安装完ohmyzsh后，默认使用的shell配置文件是 .zshrc ，在最后添加：
# bash_profilesource ~/.bash_profile
平时添加环境配置，依然在 .bash_profile 中添加，这样就保持了和linux配置的一致性。
在 .zshrc 或者 .bash_profile 中添加一些设置后，也许会提示：
zsh compinit: insecure directories, run compaudit for list.Ignore insecure directories and continue [y] or abort compinit [n]?

解决办法：
compaudit | xargs chmod g-w,o-w

brewbrew 全称Homebrew，是Mac OSX上的软件包管理工具。
安装brew：
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"# 国内安装失败的话，建议换下面的脚本/bin/zsh -c "$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)"

更换homebrew源：
cd "$(brew --repo)" &amp;&amp; git remote set-url origin git://mirrors.ustc.edu.cn/brew.gitcd "$(brew --repo homebrew/core)" &amp;&amp; git remote set-url origin git://mirrors.ustc.edu.cn/homebrew-core.gitcd "$(brew --repo homebrew/cask)" &amp;&amp; git remote set-url origin git://mirrors.ustc.edu.cn/homebrew-cask.gitbrew update# 还原cd "$(brew --repo)" &amp;&amp; git remote set-url origin https://github.com/Homebrew/brew.gitcd "$(brew --repo homebrew/core)" &amp;&amp; git remote set-url origin https://github.com/Homebrew/homebrew-core.gitcd "$(brew --repo homebrew/cask)" &amp;&amp; git remote set-url origin https://github.com/Homebrew/homebrew-cask.gitbrew update
更多内容参考Homebrew/Linuxbrew 镜像使用帮助。
使用国内brew源如果出现下面这种问题：tar: Error opening archive: Failed to open ‘xxx.catalina.bottle.tar.gz’
那么需要暂时改回默认的brew源：
unset HOMEBREW_BREW_GIT_REMOTEunset HOMEBREW_CORE_GIT_REMOTEunset HOMEBREW_BOTTLE_DOMAIN

iterm2安装iterm2
配置rzsz1、安装iterm2-zmodem
brew install wgetbrew install lrzszgit clone https://github.com/aikuyun/iterm2-zmodem.gitcd iterm2-zmodemcp iterm2-* /usr/local/bincd /usr/local/binchmod +x iterm2-*

2、iterm2配置项 
Profiles-&gt;OpenProfiles-&gt;EditProfiles-&gt;Advanced-&gt;Tirgger，添加
Regular expression:  /*/*B0100Action: Run Silent CoprocessParameters: /usr/local/bin/iterm2-send-zmodem.shInstant: trueRegular expression:  /*/*B00000000000000Action: Run Silent CoprocessParameters: /usr/local/bin/iterm2-recv-zmodem.shInstant: true

clone session1、Iterm2-&gt;Preferences-&gt;Profiles-&gt;Working Directory勾选 Reuse previous session’s directory
2、编辑 .ssh/config 文件，添加
host *ControlMaster autoControlPath ~/.ssh/master-%r@%h:%pServerAliveInterval 60

3、重新打开终端，第一次登录需要密码。第二次登录同一台机器，就不需要密码了，nice。
更换主题和背景色更换主题：Iterm2-&gt;Preferences-&gt;Appearance-&gt;General-&gt;Theme更换背景色：Iterm2-&gt;Preferences-&gt;Profiles-&gt;Colors-&gt;Color Presets
gitgit配置参考《常用git命令》。
sublimesublime破解方法：
1、vim /etc/hosts，添加
127.0.0.1 www.sublimetext.com127.0.0.1 license.sublimehq.com

2、sublime中输入license
----- BEGIN LICENSE -----Member J2TeaMSingle User LicenseEA7E-1011316D7DA350E 1B8B0760 972F8B60 F3E64036B9B4E234 F356F38F 0AD1E3B7 0E9C5FADFA0A2ABE 25F65BD8 D51458E5 3923CE8087428428 79079A01 AA69F319 A1AF29A4A684C2DC 0B1583D4 19CBD290 217618CD5653E0A0 BACE3948 BB2EE45E 422D2C87DD9AF44B 99C49590 D2DBDEE1 75860FD28C8BB2AD B2ECE5A4 EFC08AF2 25A9B864------ END LICENSE ------

该方法已失效。
ssh config登录远程服务器，需要ssh username@host -p port在记忆这些信息是很麻烦的，因此我们需要一个简单的方法。
1、创建 .ssh/config 文件，内容为
Host jumpboxHostName jumpbox.voidking.comUser voidkingPort 2345IdentityFile ~/.ssh/id_rsaHost bastionhostHostName 45.68.78.134User rootPort 3456IdentityFile ~/.ssh/id_rsa

2、配置authorized_keys
sudo curl -L https://raw.githubusercontent.com/beautifulcode/ssh-copy-id-for-OSX/master/install.sh | shssh-copy-id -i ~/.ssh/id_rsa.pub jumpboxssh-copy-id -i ~/.ssh/id_rsa.pub bastionhost

3、登录服务器 
ssh jumpboxssh bastionhost

加解密文件zip -er resources.zip resources.mdunzip resources.zip

mysql1、安装启动mysql
brew install mysqlmysql.server start

2、mysqlclient连接mysql
mysql -uroot

3、使用sequelpro连接mysql报错： MySQL said: Authentication plugin ‘caching_sha2_password’ cannot be loaded: dlopen(/usr/local/mysql/lib/plugin/caching_sha2_password.so, 2): image not found
解决：参考MySQL重置密码，设置密码。
mysqlclient1、安装mysqlclient
brew install mysql-connector-c
2、编辑 .zshrc 添加路径
# mysqlexport PATH="/usr/local/Cellar/mysql-client/8.0.19/bin:$PATH"

java1、访问Java SE Downloads页面，下载dmg文件并安装
2、编辑 .bash_profile 文件，添加
JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-14.0.1.jdk/Contents/HomeCLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.PATH=$JAVA_HOME/bin:$PATH:.export JAVA_HOMEexport CLASSPATHexport PATH

3、测试安装
source .bash_profilejava --version

pyenv参考CentOS安装配置pyenv。不同的是，本节是在macos环境中使用pyenv。1、安装pyenvbrew install pyenv
2、配置pyenv在 .bash_profile 中添加
export PYENV_ROOT="$HOME/.pyenv"export PATH="$PYENV_ROOT/shims:$PATH"if command -v pyenv 1&gt;/dev/null 2&gt;&amp;1; then eval "$(pyenv init -)"fi

使配置生效：
source ~/.bash_profile

3、安装python3.6.10
pyenv install -lpyenv install -v 3.6.10pyenv rehash

如果安装很慢，这里提供一个小技巧：提前下载安装包。
mkdir ~/.pyenv/cachecd ~/.pyenv/cachewget https://www.python.org/ftp/python/3.6.10/Python-3.6.10.tar.xz

4、切换python版本
pyenv versionspyenv global 3.6.10pyenv rehashpython -V

5、切换为原版本
pyenv global systempyenv rehashpython -V

nvm1、参考Node Version Manager，安装nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.36.0/install.sh | bash
如果下载脚本报错，就本地创建install.sh，从网页拷贝内容到install.sh后执行。
2、编辑 .bash_profile ，添加内容：
export NVM_DIR="$HOME/.nvm"[ -s "$NVM_DIR/nvm.sh" ] &amp;&amp; \. "$NVM_DIR/nvm.sh"  # This loads nvm[ -s "$NVM_DIR/bash_completion" ] &amp;&amp; \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

3、使配置生效
source .bash_profilenvm

4、安装使用指定版本
export NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/nodenvm -hnvm ls-remotenvm install v10.16.3nvm listnvm use v10.16.3nvm alias default v10.16.3

puerpuer是一个前端工具，能够在任意目录启动web静态服务，并且实时刷新。
1、全局安装puernpm install puer -g
2、启动服务
cd /path/to/workspacepuer

svrx是puer的进化版，同样好用。1、全局安装svrxnpm install @svrx/cli -g
2、启动服务
cd /path/to/workspacesvrx

解压zip压缩和解压zip文件：
zip filename.zip filenameunzip filename.zip

加密压缩和解压zip文件：
zip -e filename.zip filenameunzip -P xxxxxx filename.zipfor i in *.zip;do unzip -P xxxxxx $i;done

解压中文名zip文件：
brew updatebrew install unarunar -e GBK 中文名.zipunar -e GBK -p xxxxxx 中文名.zipfor i in *.zip;do unar -e GBK -p xxxxxx $i;done

解压rarbrew install unrarunrar x package-name.rar

修改md5修改单个文件md5：echo -e -n &quot;\x00&quot; &gt;&gt; 你的文件
批量修改文件的md5：find . -type f -exec bash -c &#39;echo -e -n &quot;\x00&quot; &gt;&gt; {}&#39; \;
处理带有空格的文件名：
find . -type f &gt; filename.txtwhile read line;do echo $line &amp;&amp; echo -e -n "\x00" &gt;&gt; "$line";done &lt; filename.txt

命令行发邮件邮件系统有三个组成部分：邮件用户代理（MUA，Mail User Agent）；邮件传送代理（MTA，Mail Transport Agent）；邮件分发代理（MDA，Mail Deliver Agent）。macos自带mail（mailx）命令，这是一个MUA，与之配合的是sendmail，一个MTA。但是，sendmail不支持使用外部MDA发邮件，因此需要把sendmail替换成msmtp。
1、安装msmtp
brew install msmtp

2、配置使用msmtpsudo vim /etc/mail.rc，添加：
set sendmail=/usr/local/bin/msmtp

3、配置msmtpvim ~/.msmtprc，内容为：
defaultsaccount defaulthost smtp.163.comport 25from quizthink@163.comauth logintls offuser quizthink@163.compassword xxxxxx

4、修改 .msmtprc 权限chmod 600 ~/.msmtprc
5、发送邮件echo &quot;Hello world&quot; | mail -s &quot;test&quot; voidking@qq.com
screenscreen是后台运行脚本的神器。
1、使用新的screen运行脚本screen ./main.sh
2、把当前screen放入后台control+A D
3、查看screenscreen -ls
4、返回screenscreen -r 23500.ttys005.B000000349215A
frp前提：参考《使用frp进行内网穿透》配置好frp服务端。本节中，配置macos的内网穿透，
1、下载macos用的frp，这里下载frp_0.31.1_darwin_amd64.tar.gz。
2、解压并配置 frpc.ini
[common]server_addr = 120.77.36.182server_port = 7000token = 12345678[ssh]type = tcplocal_ip = 127.0.0.1local_port = 22remote_port = 3422

3、启动frpc客户端
./frpc -c frpc.ini# control+Cbrew install screenscreen ./frpc -c frpc.ini# control+A+D

4、启用远程登录系统偏好设置，共享，勾选远程登录。
5、测试
ssh localhostssh vk@120.77.36.182 -p 3422

6、临时禁用mac休眠关闭屏幕后，mac很快会进入休眠模式，无法再远程登录mac，因此需要临时禁用mac休眠。pmset noidle
docker参考Docker on Mac with Homebrew，安装配置docker。
1、安装dockerbrew cask install docker
2、初始化配置启动台，点击docker图标，按照提示进行初始化配置。
3、查看安装结果docker --version
stretchlyStretchly is a cross-platform Electron app that reminds you to take breaks when working on your computer.这款软件界面友好，设置简单，提醒也很nice。唯一缺点是软件比较大，70M。
brew update &amp;&amp; brew install --cask stretchly
或者下载dmg软件包进行安装。如果下载不下来，建议使用FDM进行下载。
virtualboxvirtualbox配置win10文件夹共享：1、启动win10虚拟机2、virtualbox菜单栏，Devices，Insert Guest Additions CD images3、win10内，点击CD驱动器里的VBoxWindowAddions.exe进行插件安装4、virtualbox win10虚拟机设置，共享文件夹5、添加共享文件，共享文件夹路径选择宿主机(Mac)上的一个路径，共享文件夹名称随意，挂载点填入X:6、win10虚拟机内出现了X盘，用于共享
gnu-sedmac（类unix系统）使用bsd sed，而各种linux发行版用的是linux sed。因此，mac sed的用法和linux sed的用法会有一些差异，这就带来很多不便，解决办法是给mac安装linux sed。
1、安装gnu-sedbrew install gnu-sed
2、.bash_profile添加配置
export PATH="/usr/local/opt/gnu-sed/libexec/gnubin:$PATH"

3、使配置生效source .bash_profile
快捷cd目录1、macos中安装autojumpbrew update &amp;&amp; brew install autojump
2、.bash_profile中添加配置
# autojump[ -f /usr/local/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/local/etc/profile.d/autojump.sh

3、使配置生效source .bash_profile
4、使用j dirname然后配合tab补全，回车跳转目录。
PS：linux中可以通过配置CDPATH变量实现快捷cd目录.bash_profile添加：
# workdirCDPATH=".:~:~/git"

ffmpeg《m3u8视频下载方法》一文中提到ffmpeg是一个很好用的视频格式转换工具，在macos上安装和使用也很方便。
1、安装ffmpegbrew install ffmpeg
安装报错 tar: Error opening archive: Failed to open ‘…–bdw-gc-8.0.4_2.catalina.bottle.tar.gz’解决办法：export HOMEBREW_BOTTLE_DOMAIN=&#39;&#39;
2、flv转mp4ffmpeg -i filename.flv filename.mp4
好用的软件
Chrome
iterm2
sublime
wps
百度云盘
Skim
draw.io
youtube-dl
you-get
FDM
Movist
sequelpro
Mounty
postman
typora
Stretchly
幕享
splashtop
JSON Viewer
Meld

小技巧使用命令打开目录和文件1、在finder中打开当前目录open .
2、使用默认程序打开指定文件open README.md
切换窗口1、command + tab2、三指左右滑动3、三指上滑
快速预览选中文件或者文件夹，点击空格即可预览文件，点击上下左右可以预览其他文件。
隔空投送接收方：打开隔空投送功能，同时接收人选择仅限联系人或所有人。
发送方：1、打开要发送的文件，然后点按 App 窗口中的“共享”按钮 。或者，在“访达”中按住 Control 键点按相应文件，然后从快捷键菜单中选取“共享”。2、从列出的共享选项中，选取“隔空投送”。3、从“隔空投送”表单中选取一位接收者。
或者打开“隔空投送”窗口，然后将文件拖移到接收者：1、在“访达”窗口的边栏中选择“隔空投送”。或者从菜单栏中选取“前往”&gt;“隔空投送”。2、“隔空投送”窗口随即会显示附近的“隔空投送”用户。将一个或多个文稿、照片或其他文件拖移到窗口中显示的接收者。
详情参考 在 Mac 上使用“隔空投送”。
传送速度非常快，网络条件不错的情况下，可以达到几百MB每秒。
]]></content>
      <categories>
        <category>爱好</category>
        <category>电脑</category>
      </categories>
  </entry>
  <entry>
    <title>Hibernate关系映射</title>
    <url>/dev-hibernate-orm/</url>
    <content><![CDATA[前言Hibernate关系映射的主要任务是实现数据库关系表与持久化类之间的映射。
一对一关联（共享主键方式）在注册某个论坛会员的时候，往往不但要填写登录账户和密码，还要填写其他的详细信息，这两部分信息通常会放在不同的表中。共享主键方式就是限制两个数据表的主键使用相同的值，通过主键形成一对一映射关系。
建立表命令建立login表和detail表：
create table login(id int4 primary key not null,username varchar(20) not null,password varchar(20) not null);create table detail(id int4 primary key auto_increment not null,truename varchar(8),email varchar(50));

登陆表和详细信息表属于典型的一对一关联关系，可按共享主键方式进行。在Hibernate概述中实例的基础上，接着开发。

Login.java在包com.voidking.hibernate.model中，新建类Login，代码如下：
package com.voidking.hibernate.model;public class Login implements java.io.Serializable &#123;	// Fields	private Integer id;	private String username;	private String password;	private Detail detail;			// Constructors	/** default constructor */	public Login() &#123;	&#125;	/** full constructor */	public Login(String username, String password, Detail detail) &#123;		this.username = username;		this.password = password;		this.detail = detail;		&#125;	// Property accessors	public Integer getId() &#123;		return this.id;	&#125;	public void setId(Integer id) &#123;		this.id = id;	&#125;	public String getUsername() &#123;		return this.username;	&#125;	public void setUsername(String username) &#123;		this.username = username;	&#125;	public String getPassword() &#123;		return this.password;	&#125;	public void setPassword(String password) &#123;		this.password = password;	&#125;		public Detail getDetail()&#123;		return this.detail;	&#125;	public void setDetail(Detail detail)&#123;		this.detail = detail;	&#125;&#125;
Login.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Login" table="login"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="ID" /&gt;            &lt;generator class="foreign"&gt;            	&lt;param name="property"&gt;detail&lt;/param&gt;            &lt;/generator&gt;        &lt;/id&gt;        &lt;property name="username" type="java.lang.String"&gt;            &lt;column name="USERNAME" length="20" not-null="true" /&gt;        &lt;/property&gt;        &lt;property name="password" type="java.lang.String"&gt;            &lt;column name="PASSWORD" length="20" not-null="true" /&gt;        &lt;/property&gt;		&lt;!--constrained="true"表明当前的主键上存在一个外键约束--&gt;        &lt;one-to-one name="detail" class="com.voidking.hibernate.model.Detail" constrained="true"&gt;&lt;/one-to-one&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

Detail.javapackage com.voidking.hibernate.model;public class Detail implements java.io.Serializable &#123;	// Fields	private Integer id;	private String truename;	private String email;	private Login login;			// Constructors	/** default constructor */	public Detail() &#123;	&#125;	/** full constructor */	public Detail(String truename, String email, Login login) &#123;		this.truename = truename;		this.email = email;		this.login = login;			&#125;	// Property accessors	public Integer getId() &#123;		return this.id;	&#125;	public void setId(Integer id) &#123;		this.id = id;	&#125;	public String getTruename() &#123;		return this.truename;	&#125;	public void setTruename(String truename) &#123;		this.truename = truename;	&#125;	public String getEmail() &#123;		return this.email;	&#125;	public void setEmail(String email) &#123;		this.email = email;	&#125;		public Login getLogin()&#123;		return this.login;	&#125;	public void setLogin(Login login)&#123;		this.login = login;	&#125;&#125;

Detail.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Detail" table="detail"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="ID" /&gt;            &lt;generator class="identity" /&gt;        &lt;/id&gt;        &lt;property name="truename" type="java.lang.String"&gt;            &lt;column name="TRUENAME" length="8" /&gt;        &lt;/property&gt;        &lt;property name="email" type="java.lang.String"&gt;            &lt;column name="EMAIL" length="50" /&gt;        &lt;/property&gt;		&lt;!--cascade=all，表示主控类的所有操作，对关联类也执行同样操作--&gt;        &lt;one-to-one name="login" class="com.voidking.hibernate.model.Login" cascade="all" lazy="false"&gt;&lt;/one-to-one&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

hibernate.cfg.xml&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;     &lt;hibernate-configuration&gt;    &lt;session-factory&gt;         &lt;!-- Database connection settings --&gt;    &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;    &lt;property name="connection.url"&gt;jdbc:mysql://localhost/xscj&lt;/property&gt;    &lt;property name="connection.username"&gt;scott&lt;/property&gt;    &lt;property name="connection.password"&gt;tiger&lt;/property&gt;             &lt;!-- JDBC connection pool (use the built-in) --&gt;    &lt;!-- &lt;property name="connection.pool_size"&gt;1&lt;/property&gt; --&gt;             &lt;!-- SQL dialect --&gt;    &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;             &lt;!-- Echo all executed SQL to stdout --&gt;    &lt;property name="show_sql"&gt;true&lt;/property&gt;             &lt;!-- Enable Hibernate's automatic session context management --&gt;    &lt;!--&lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;--&gt;             &lt;!-- Drop and re-create the database schema on startup --&gt;    &lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt;             &lt;!-- Disable the second-level cache --&gt;    &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;         &lt;mapping resource="com/voidking/hibernate/model/Kcb.hbm.xml"/&gt;    &lt;mapping resource="com/voidking/hibernate/model/Login.hbm.xml"/&gt;    &lt;mapping resource="com/voidking/hibernate/model/Detail.hbm.xml"/&gt;       &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;

SharePrimaryKey.javapackage com.voidking.hibernate.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.hibernate.model.Detail;import com.voidking.hibernate.model.Login;public class SharePrimaryKey&#123;	public static void main(String[] args) &#123;		Configuration cfg = new Configuration();        SessionFactory sf = cfg.configure().buildSessionFactory();		Session session = sf.openSession();				// 创建事务对象		Transaction ts=session.beginTransaction();		//共享主键方式		Detail detail=new Detail();		Login login=new Login();		login.setUsername("yanhong");		login.setPassword("123");		detail.setTruename("严红");		detail.setEmail("yanhong@126.com");		//相互设置关联		login.setDetail(detail);		detail.setLogin(login);		//这样完成后就可以通过Session对象调用session.save(detail)来持久化该对象		session.save(detail);				ts.commit();				session.close();		sf.close();	&#125;&#125;

运行以Java Application运行，查看数据库，可以发现，数据成功插入。
唯一外键方式唯一外键方式就是一个表的外键和另一个表的唯一主键形成一对一的映射关系，这种一对一的关系其实就是多对一关联关系的一种特殊情况而已。
唯一外键的情况很多，比如，每个人对应一个房间。很多情况下，可以是几个人住在同一个房间里面，就是多对一的关系。但是如果让一个人住一个房间，就变成了一对一的关系了，这就是前面说的一对一关系其实是多对一关系的一种特殊情况。
创建表命令创建表person和room：
create table person(id int primary key auto_increment not null ,name varchar(20) not null,room_id int(4) );create table room(id int(4) primary key auto_increment not null,address varchar(100) not null);

Person.javapackage com.voidking.hibernate.model;public class Person implements java.io.Serializable &#123;	// Fields	private Integer id;	private String name;	private Room room;				// Constructors	/** default constructor */	public Person() &#123;	&#125;	/** minimal constructor */	public Person(String name) &#123;		this.name = name;	&#125;	/** full constructor */	public Person(String name, Room room) &#123;		this.name = name;		//this.roomId = roomId;		this.room = room;			&#125;	// Property accessors	public Integer getId() &#123;		return this.id;	&#125;	public void setId(Integer id) &#123;		this.id = id;	&#125;	public String getName() &#123;		return this.name;	&#125;	public void setName(String name) &#123;		this.name = name;	&#125;		public Room getRoom()&#123;		return this.room;	&#125;	public void setRoom(Room room)&#123;		this.room = room;	&#125;&#125;

Person.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Person" table="Person"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="id" /&gt;            &lt;generator class="native" /&gt;        &lt;/id&gt;        &lt;property name="name" type="java.lang.String"&gt;            &lt;column name="name" length="20" not-null="true" /&gt;        &lt;/property&gt;        &lt;many-to-one name="room" class="com.voidking.hibernate.model.Room"  column="room_id" cascade="all" unique="true"&gt;&lt;/many-to-one&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

Room.javapackage com.voidking.hibernate.model;public class Room implements java.io.Serializable &#123;	// Fields	private Integer id;	private String address;	private Person person;	// Constructors	/** default constructor */	public Room() &#123;	&#125;	/** full constructor */	public Room(String address) &#123;		this.address = address;		//this.person = person;	&#125;	// Property accessors	public Integer getId() &#123;		return this.id;	&#125;	public void setId(Integer id) &#123;		this.id = id;	&#125;	public String getAddress() &#123;		return this.address;	&#125;	public void setAddress(String address) &#123;		this.address = address;	&#125;		public Person getPerson()&#123;		return this.person;	&#125;	public void setPerson(Person person)&#123;		this.person = person;	&#125;&#125;

Room.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Room" table="Room"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="id" /&gt;            &lt;generator class="native" /&gt;        &lt;/id&gt;        &lt;property name="address" type="java.lang.String"&gt;            &lt;column name="address" length="100" not-null="true" /&gt;        &lt;/property&gt;        &lt;one-to-one name="person" class="com.voidking.hibernate.model.Person" property-ref="room"/&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

hibernate.cfg.xml&lt;mapping resource="com/voidking/hibernate/model/Person.hbm.xml"/&gt; &lt;mapping resource="com/voidking/hibernate/model/Room.hbm.xml"/&gt;

OneForeign.javapackage com.voidking.hibernate.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.hibernate.model.Person;import com.voidking.hibernate.model.Room;public class OneForeign&#123;	public static void main(String[] args) &#123;		Configuration cfg = new Configuration();        SessionFactory sf = cfg.configure().buildSessionFactory();		Session session = sf.openSession();				// 创建事务对象		Transaction ts=session.beginTransaction();		//唯一外键方式		Person person=new Person();		person.setName("liumin");		Room room=new Room();		room.setAddress("NJ-S1-328");		person.setRoom(room);		session.save(person);				ts.commit();				session.close();		sf.close();	&#125;&#125;

运行以Java Application运行，查看数据库，可以发现，数据成功插入。
关于外键在创建表person时，我们并没有设置room_id为外键，但是，当我们运行这个项目的之后。使用desc person;命令可以发现，room_id变成了外键。可见，Hibernate不仅可以改变数据库中表的数据，也可以改变数据库中表的属性。理论上，也可以创建删除表。曾经开发时，使用JPA直接生成表，根本不用操作数据库，很方便。
多对一单向关联只要把上例中的一对一的唯一外键关联实例稍微修改，就可以变成多对一。
Person.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Person" table="Person"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="id" /&gt;            &lt;generator class="native" /&gt;        &lt;/id&gt;        &lt;property name="name" type="java.lang.String"&gt;            &lt;column name="name" length="20" not-null="true" /&gt;        &lt;/property&gt;        &lt;many-to-one name="room" class="com.voidking.hibernate.model.Room"  column="room_id" cascade="all"&gt;&lt;/many-to-one&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

Room.javapackage com.voidking.hibernate.model;public class Room implements java.io.Serializable &#123;	private Integer id;	private String address;	//setter和getter方法&#125;

Room.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Room" table="Room"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="id" /&gt;            &lt;generator class="native" /&gt;        &lt;/id&gt;        &lt;property name="address" type="java.lang.String"&gt;            &lt;column name="address" length="100" not-null="true" /&gt;        &lt;/property&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

ManyToOne.javapackage com.voidking.hibernate.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.hibernate.model.Person;import com.voidking.hibernate.model.Room;public class ManyToOne&#123;	public static void main(String[] args) &#123;		Configuration cfg = new Configuration();        SessionFactory sf = cfg.configure().buildSessionFactory();		Session session = sf.openSession();				// 创建事务对象		Transaction ts=session.beginTransaction();		Room room=new Room();		room.setAddress("NJ-S1-328");		Person person=new Person();		person.setName("liumin");				person.setRoom(room);		session.save(person);				ts.commit();				session.close();		sf.close();	&#125;&#125;

一对多双向关联上面的例子中，多对一单向关联是从多控制一，也就是说，从多可以知道一，但从一不知道多。如果一也只知道多，那么就变成了双向一对多（或多对一）关联。
Room.javapackage com.voidking.hibernate.model;import java.util.HashSet;import java.util.Set;public class Room implements java.io.Serializable &#123;	// Fields	private Integer id;	private String address;		private Set person = new HashSet();	// Constructors	/** default constructor */	public Room() &#123;	&#125;	/** full constructor */	public Room(String address) &#123;		this.address = address;		//this.person = person;	&#125;	// Property accessors	public Integer getId() &#123;		return this.id;	&#125;	public void setId(Integer id) &#123;		this.id = id;	&#125;	public String getAddress() &#123;		return this.address;	&#125;	public void setAddress(String address) &#123;		this.address = address;	&#125;	public Set getPerson() &#123;		return person;	&#125;	public void setPerson(Set person) &#123;		this.person = person;	&#125;&#125;

Room.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Room" table="Room"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="id" /&gt;            &lt;generator class="native" /&gt;        &lt;/id&gt;        &lt;property name="address" type="java.lang.String"&gt;            &lt;column name="address" length="100" not-null="true" /&gt;        &lt;/property&gt;		&lt;set name="person" inverse="false" cascade="all"&gt;			&lt;key column="room_id"&gt;&lt;/key&gt;			&lt;one-to-many class="com.voidking.hibernate.model.Person"/&gt;		&lt;/set&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

cascade取值
all：表示所有操作在关联层级上进行连锁操作。
save-update：表示只有save和update操作进行连锁操作。
delete：表示只有delete操作进行连锁操作。
all-delete-orphan：在删除当前持久化对象时，它相当于delete；在保存或更新当前持久化对象时，它相当于save-update。另外它还可以删除与当前持久化对象断开关联关系的其他持久化对象。

OneToMany.javapackage com.voidking.hibernate.test;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.hibernate.model.Person;import com.voidking.hibernate.model.Room;public class OneToMany&#123;	public static void main(String[] args) &#123;		Configuration cfg = new Configuration();        SessionFactory sf = cfg.configure().buildSessionFactory();		Session session = sf.openSession();				// 创建事务对象		Transaction ts=session.beginTransaction();		Person person1=new Person(); 		Person person2=new Person();		Room room=new Room();		room.setAddress("NJ-S1-328");		person1.setName("李方方");		person2.setName("王艳");		person1.setRoom(room);		person2.setRoom(room);		//这样完成后就可以通过Session对象		//调用session.save(person1)和session.save(person)		//会自动保存room		session.save(person1);		session.save(person2);				ts.commit();				session.close();		sf.close();	&#125;&#125;

多对多单向关联学生和课程就是多对多的关系，一个学生可以选择多门课程，而一门课程又可以被多个学生选择。多对多关系在关系数据库中不能直接表现，还必须依赖一张连接表。由于是单向的，也就是说一方可以知道另一方，反之不行。这里以从学生知道选择了哪些课程为例实现多对多单向关联。
创建表命令create table student(id int primary key auto_increment not null ,snumber varchar(10) not null,sname varchar(10),sage int);create table course(id int primary key auto_increment not null,cnumber varchar(10) not null,cname varchar(20));create table stu_cour(sid int not null,cid int not null,primary key (sid,cid));

Student.javapackage com.voidking.hibernate.model;import java.util.HashSet;import java.util.Set;public class Student implements java.io.Serializable &#123;	// Fields	private Integer id;	private String snumber;	private String sname;	private Integer sage;	private Set courses = new HashSet();	// Constructors	/** default constructor */	public Student() &#123;	&#125;	/** minimal constructor */	public Student(String snumber) &#123;		this.snumber = snumber;	&#125;	/** full constructor */	public Student(String snumber, String sname, Integer sage) &#123;		this.snumber = snumber;		this.sname = sname;		this.sage = sage;	&#125;	// Property accessors	public Integer getId() &#123;		return this.id;	&#125;	public void setId(Integer id) &#123;		this.id = id;	&#125;	public String getSnumber() &#123;		return this.snumber;	&#125;	public void setSnumber(String snumber) &#123;		this.snumber = snumber;	&#125;	public String getSname() &#123;		return this.sname;	&#125;	public void setSname(String sname) &#123;		this.sname = sname;	&#125;	public Integer getSage() &#123;		return this.sage;	&#125;	public void setSage(Integer sage) &#123;		this.sage = sage;	&#125;		public Set getCourses()&#123;		return courses;	&#125;	public void setCourses(Set courses)&#123;		this.courses = courses;	&#125;&#125;

Student.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Student" table="student"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="ID" /&gt;            &lt;generator class="identity" /&gt;        &lt;/id&gt;        &lt;property name="snumber" type="java.lang.String"&gt;            &lt;column name="SNUMBER" length="10" not-null="true" /&gt;        &lt;/property&gt;        &lt;property name="sname" type="java.lang.String"&gt;            &lt;column name="SNAME" length="10" /&gt;        &lt;/property&gt;        &lt;property name="sage" type="java.lang.Integer"&gt;            &lt;column name="SAGE" /&gt;        &lt;/property&gt;        &lt;set name="courses" table="stu_cour" lazy="true" cascade="all"&gt;        	&lt;key column="SID"&gt;&lt;/key&gt;        	&lt;many-to-many class="com.voidking.hibernate.model.Course" column="CID"/&gt;        &lt;/set&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

Course.javapackage com.voidking.hibernate.model;public class Course implements java.io.Serializable &#123;	// Fields	private Integer id;	private String cnumber;	private String cname;	// Constructors	/** default constructor */	public Course() &#123;	&#125;	/** minimal constructor */	public Course(String cnumber) &#123;		this.cnumber = cnumber;	&#125;	/** full constructor */	public Course(String cnumber, String cname) &#123;		this.cnumber = cnumber;		this.cname = cname;	&#125;	// Property accessors	public Integer getId() &#123;		return this.id;	&#125;	public void setId(Integer id) &#123;		this.id = id;	&#125;	public String getCnumber() &#123;		return this.cnumber;	&#125;	public void setCnumber(String cnumber) &#123;		this.cnumber = cnumber;	&#125;	public String getCname() &#123;		return this.cname;	&#125;	public void setCname(String cname) &#123;		this.cname = cname;	&#125;&#125;
Course.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Course" table="course"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="ID" /&gt;            &lt;generator class="identity" /&gt;        &lt;/id&gt;        &lt;property name="cnumber" type="java.lang.String"&gt;            &lt;column name="CNUMBER" length="10" not-null="true" /&gt;        &lt;/property&gt;        &lt;property name="cname" type="java.lang.String"&gt;            &lt;column name="CNAME" length="20" /&gt;        &lt;/property&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

hibernate.cfg.xml&lt;mapping resource="com/voidking/hibernate/model/Student.hbm.xml"/&gt; &lt;mapping resource="com/voidking/hibernate/model/Course.hbm.xml"/&gt;

ManyToManySingle.javapackage com.voidking.hibernate.test;import java.util.HashSet;import java.util.Set;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.hibernate.model.Course;import com.voidking.hibernate.model.Student;public class ManyToManySingle&#123;	public static void main(String[] args) &#123;		Configuration cfg = new Configuration();        SessionFactory sf = cfg.configure().buildSessionFactory();		Session session = sf.openSession();				// 创建事务对象		Transaction ts=session.beginTransaction();		//多对多单向关联		Course cour1=new Course();		Course cour2=new Course();		Course cour3=new Course();		cour1.setCnumber("101");		cour1.setCname("计算机基础");		cour2.setCnumber("102");		cour2.setCname("数据库原理");		cour3.setCnumber("103");		cour3.setCname("计算机原理");		Set courses=new HashSet();		courses.add(cour1);		courses.add(cour2);		courses.add(cour3);		Student stu=new Student();		stu.setSnumber("081101");		stu.setSname("李方方");		stu.setSage(21);		stu.setCourses(courses);		session.save(stu);		ts.commit();				session.close();		sf.close();	&#125;&#125;

多对多双向关联学会多对多单向关联后，只要同时实现两个互逆的多对多单向关联便可轻而易举地实现多对多双向关联。在上面的例子中只要修改课程的代码就可以了。
Course.javapackage com.voidking.hibernate.model;import java.util.HashSet;import java.util.Set;public class Course implements java.io.Serializable &#123;	// Fields	private Integer id;	private String cnumber;	private String cname;	private Set stus = new HashSet();	// Constructors	/** default constructor */	public Course() &#123;	&#125;	/** minimal constructor */	public Course(String cnumber) &#123;		this.cnumber = cnumber;	&#125;	/** full constructor */	public Course(String cnumber, String cname) &#123;		this.cnumber = cnumber;		this.cname = cname;	&#125;	// Property accessors	public Integer getId() &#123;		return this.id;	&#125;	public void setId(Integer id) &#123;		this.id = id;	&#125;	public String getCnumber() &#123;		return this.cnumber;	&#125;	public void setCnumber(String cnumber) &#123;		this.cnumber = cnumber;	&#125;	public String getCname() &#123;		return this.cname;	&#125;	public void setCname(String cname) &#123;		this.cname = cname;	&#125;	public Set getStus() &#123;		return stus;	&#125;	public void setStus(Set stus) &#123;		this.stus = stus;	&#125;&#125;

Course.hbm.xml&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;&lt;hibernate-mapping&gt;    &lt;class name="com.voidking.hibernate.model.Course" table="course"&gt;        &lt;id name="id" type="java.lang.Integer"&gt;            &lt;column name="ID" /&gt;            &lt;generator class="identity" /&gt;        &lt;/id&gt;        &lt;property name="cnumber" type="java.lang.String"&gt;            &lt;column name="CNUMBER" length="10" not-null="true" /&gt;        &lt;/property&gt;        &lt;property name="cname" type="java.lang.String"&gt;            &lt;column name="CNAME" length="20" /&gt;        &lt;/property&gt;        &lt;set name="stus" table="stu_cours" lazy="true" cascade="all"&gt;        	&lt;key column="cid"&gt;&lt;/key&gt;        	&lt;many-to-many class="com.voidking.hibernate.model.Student" column="sid"&gt;&lt;/many-to-many&gt;        &lt;/set&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

ManyToManyDouble.javapackage com.voidking.hibernate.test;import java.util.HashSet;import java.util.Set;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.hibernate.model.Course;import com.voidking.hibernate.model.Student;public class ManyToManyDouble&#123;	public static void main(String[] args) &#123;		Configuration cfg = new Configuration();        SessionFactory sf = cfg.configure().buildSessionFactory();		Session session = sf.openSession();				// 创建事务对象		Transaction ts=session.beginTransaction();		//多对多单向关联		Course cour1=new Course();		Course cour2=new Course();		Course cour3=new Course();		cour1.setCnumber("101");		cour1.setCname("计算机基础");		cour2.setCnumber("102");		cour2.setCname("数据库原理");		cour3.setCnumber("103");		cour3.setCname("计算机原理");		Set courses=new HashSet();		courses.add(cour1);		courses.add(cour2);		courses.add(cour3);		Student stu=new Student();		stu.setSnumber("081101");		stu.setSname("李方方");		stu.setSage(21);		stu.setCourses(courses);		session.save(stu);		ts.commit();				session.close();		sf.close();	&#125;&#125;


小结我靠，Hibernate关系映射好复杂！根本没有明显规律，能不能愉快地玩耍了！
参考文档《Java EE基础实用教程》，郑阿奇主编
初识Hibernate——关系映射：http://blog.csdn.net/laner0515/article/details/12905711
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate概述</title>
    <url>/dev-hibernate-start/</url>
    <content><![CDATA[名词解释Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装（未完全封装），使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 
Hibernate可以应用在任何使用JDBC的场合，既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的J2EE架构中取代CMP，完成数据持久化的重任。
对目前的JavaEE信息化系统而言，通常采用面向对象分析和面向对象设计的过程。系统从需求分析到系统设计都是按面向对象方式进行。但是到详细设计阶段，由于数据持久化需要保存到关系数据库，不得不自底向上修改设计方案，又回到了按照过程进行编程的老路上来，这是非常令人沮丧的。
但人们的智慧是无穷的，遇到问题总会想办法解决，而不是与之妥协或绕道而走。Hibernate的问世解决了这个问题，Hibernate是一个面向Java环境的对象/关系映射工具，它可将对象模型表示的对象映射到基于SQL的关系数据模型中。这样就不用再为怎样用面向对象的方法进行数据持久化而大伤脑筋了。

官网http://hibernate.org
下载http://sourceforge.net/projects/hibernate/files/hibernate3/
导入包解压缩hibernate-distribution-.zip。导入hibernate-distribution-GA/lib/required目录中的jar包。hibernate3.jar       核心类库antlr-2.7.6.jar      代码扫描器,用来翻译HQL语句commons-collections-3.1.jar    Apache Commons包中的一个，包含了一些Apache开发的集合类，功能比java.util.*强大dom4j-1.6.1.jar      一个Java的XML API，类似于jdom，用来读写XML文件的javassist-3.4.GA.jar    Javassist 字节码解释器jta-1.1.jar     标准的JTA API。slf4j-api-1.5.2.jarslf4j-nop-1.5.2.jar 
ORM对象/关系映射ORM（Object-Relation Mapping）是用于将对象与对象之间的关系对应到数据库表与表之间的关系一种模式。
简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将Java程序中的对象自动持久化到关系数据库中。对象和关系数据是业务实现的两种表现形式，业务实体在内存中表现为对象，在数据库中表现为关系数据。内存中的对象之间存在着关联和继承关系。而在数据库中，关系数据无法直接表达多对多关联和继承关系。因此，ORM系统一般以中间件的形式存在，主要实现程序对象到关系数据库数据的映射。
一般的ORM包括四个部分：对持久类对象进行CRUD操作的API、用来规定类和类属性相关查询的语言或API、规定mapping metadata的工具，以及可以让ORM实现同事务对象一起进行dirty checking、lazy association fetching和其他优化操作的技术。
目前，很多厂商和开源社区都提供了持久层框架的实现，但其中Hibernate的轻量级ORM模型逐步确立了在Java ORM架构中的领导地位。
Hibernate体系结构Hibernate作为模型层/数据访问层。它通过配置文件（hibernate.cfg.xml或hibernate.properties）和映射文件（*.hbm.xml）把Java对象或持久化对象（Persistent Object，PO）映射到数据库中的数据表，然后通过操作PO，对数据库中的表进行各种操作。实际上，PO由POJO和映射文件生成。
POJO、JavaBean和POPOJO = pure old java object or plain ordinary java object or what ever。POJO中文可以翻译成：普通Java类，具有一部分get/set方法的那种类就可以称作POJO。
JavaBean则比POJO复杂很多，JavaBean是一种组件技术，就好像你做了一个扳子，而这个扳子会在很多地方被拿去用，这个扳子也提供多种功能(你可以拿这个扳子扳、锤、撬等等)，而这个扳子就是一个组件。很显然POJO也是JavaBean的一种。一般在web应用程序中建立一个数据库的映射对象时，我们只能称它为POJO。JavaBean必须满足如下规范：1）必须有一个零参数的默认构造函数2）必须有get和set方法，类的字段必须通过get/set方法来访问。 
PO = persisent object 持久对象。实际上，PO必须对应数据库中的entity，所以和POJO有所区别。比如说POJO是由new创建，由GC回收。但是PO是数据库insert创建，由数据库delete删除的。基本上持久对象生命周期和数据库密切相关。另外持久对象往往只能存在一个数据库Connection之中，Connnection关闭以后，持久对象就不存在了，而POJO只要不被GC回收，总是存在的。由于存在诸多差别，因此PO在代码上肯定和POJO不同，起码PO相对于POJO会增加一些用来管理数据库entity状态的属性和方法。而ORM追求的目标就是要PO在使用上尽量和POJO一致，对于程序员来说，他们可以把PO当做POJO来用，而感觉不到PO的存在。所以我们项目中的entity可以看作是POJO，其实Hibernate最后作持久，是把PO持久化的，主要的机制是：1、编写POJO2、编译POJO3、直接运行，在运行期，由Hibernate的CGLIB动态把POJO转换为PO。
应用实例Hibernate的配置文件是实体对象与数据库关系表之间相互转换的重要依据。一般而言，一个映射配置文件对应着数据库中一个关系表，关系表之间的关系也在映射文件中进行配置。
建立数据库和表使用MySQL，scott用户。在xscj数据库中建立kcb，表结构如下：



项目名
列名
数据类型
可空
默认值
说明



课程号
KCH
定长字符型（char3）
×
无
主键


课程名
KCM
不定长字符串型（varchar12）
√
无



开学学期
KXXQ
整数型（smallint）
√
无
只能为1~8


学时
XS
整数型（int）
√
0



学分
XF
整数型（int）
√
0



create table kcb(kch char(3) not null primary key,kcm varchar(12),kxxq smallint check(kxxq&gt;=1 and kxxq&lt;=8),xs int default 0,xf int default 0);

新建项目新建Dynamic Web Project，命名为hibernate。
添加hibernate开发能力右击项目名，Properties，Java Build Path，Libraries，Add Library…，User Library，Next，User Libraries…，New…，输入“hibernate”，OK，Add External JARs…，选中需要的jar文件，打开，OK。
POJO对象和映射文件新建包com.voidking.hibernate.model，在包中新建POJO，命名为Kcb，代码如下：
package com.voidking.hibernate.model;public class Kcb &#123;	private String kch;	private String kcm;	private short kxxq;	private Integer xs;	private Integer xf;	public Kcb() &#123;	&#125;	public String getKch() &#123;		return kch;	&#125;	public void setKch(String kch) &#123;		this.kch = kch;	&#125;	public String getKcm() &#123;		return kcm;	&#125;	public void setKcm(String kcm) &#123;		this.kcm = kcm;	&#125;	public short getKxxq() &#123;		return kxxq;	&#125;	public void setKxxq(short kxxq) &#123;		this.kxxq = kxxq;	&#125;	public Integer getXs() &#123;		return xs;	&#125;	public void setXs(Integer xs) &#123;		this.xs = xs;	&#125;	public Integer getXf() &#123;		return xf;	&#125;	public void setXf(Integer xf) &#123;		this.xf = xf;	&#125;		&#125;
在包中新建文件Kcb.hbm.xml，内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt; &lt;hibernate-mapping&gt;&lt;!-- name指定POJO类，table指定对应数据库的表 --&gt;    &lt;class name="com.voidking.hibernate.model.Kcb" table="kcb"&gt;    	&lt;!-- name指定主键，type主键类型 --&gt;        &lt;id name="kch" type="java.lang.String"&gt;        	&lt;column name="kch" length="3"&gt;&lt;/column&gt;        	&lt;!-- 主键生成策略 --&gt;        	&lt;generator class="assigned"&gt;&lt;/generator&gt;        &lt;/id&gt;                &lt;!-- POJO属性及表中字段对应的属性 --&gt;        &lt;property name="kcm" type="java.lang.String"&gt;        	&lt;column name="kcm" length="12"&gt;&lt;/column&gt;        &lt;/property&gt;                &lt;property name="kxxq" type="java.lang.Short"&gt;        	&lt;column name="kxxq"&gt;&lt;/column&gt;        &lt;/property&gt;                &lt;property name="xs" type="java.lang.Integer"&gt;        	&lt;column name="xs"&gt;&lt;/column&gt;        &lt;/property&gt;                &lt;property name="xf" type="java.lang.Integer"&gt;        	&lt;column name="xf"&gt;&lt;/column&gt;        &lt;/property&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

hibernate.cfg.xml在src中新建hibernate.cfg.xml或者hibernate.properties，内容如下：
&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC        "-//Hibernate/Hibernate Configuration DTD 3.0//EN"        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;     &lt;hibernate-configuration&gt;    &lt;session-factory&gt;         &lt;!-- Database connection settings --&gt;    &lt;property name="connection.driver_class"&gt;com.mysql.jdbc.Driver&lt;/property&gt;    &lt;property name="connection.url"&gt;jdbc:mysql://localhost/xscj&lt;/property&gt;    &lt;property name="connection.username"&gt;scott&lt;/property&gt;    &lt;property name="connection.password"&gt;tiger&lt;/property&gt;             &lt;!-- JDBC connection pool (use the built-in) --&gt;    &lt;!-- &lt;property name="connection.pool_size"&gt;1&lt;/property&gt; --&gt;             &lt;!-- SQL dialect --&gt;    &lt;property name="dialect"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt;             &lt;!-- Echo all executed SQL to stdout --&gt;    &lt;property name="show_sql"&gt;true&lt;/property&gt;             &lt;!-- Enable Hibernate's automatic session context management --&gt;    &lt;!--&lt;property name="current_session_context_class"&gt;thread&lt;/property&gt;--&gt;             &lt;!-- Drop and re-create the database schema on startup --&gt;    &lt;!-- &lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt; --&gt;             &lt;!-- Disable the second-level cache --&gt;    &lt;property name="cache.provider_class"&gt;org.hibernate.cache.NoCacheProvider&lt;/property&gt;         &lt;mapping resource="com/voidking/hibernate/model/Kcb.hbm.xml"/&gt;             &lt;/session-factory&gt;&lt;/hibernate-configuration&gt;

创建测试类新建包com.voidking.hibernate.test，新建类Test，代码如下：
package com.voidking.hibernate.test;import java.util.List;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.hibernate.model.Kcb;public class Test &#123;	public static void main(String[] args)&#123;		//创建Session对象		Configuration cfg = new Configuration();        SessionFactory sf = cfg.configure().buildSessionFactory();		Session session = sf.openSession();				//创建事务对象		Transaction ts=session.beginTransaction();		Kcb kc = new Kcb();		kc.setKch("198");		kc.setKcm("机电");		kc.setKxxq(new Short((short) 5));		kc.setXf(new Integer(5));		kc.setXs(new Integer(59));				//保存对象		session.save(kc);		ts.commit();		Query query = session.createQuery("from Kcb where kch=198");		List list = query.list();		Kcb kcl=(Kcb)list.get(0);		System.out.println(kcl.getKcm());		session.close();		sf.close();			&#125;&#125;

导入数据库驱动导入mysql-connector-java-*-bin.jar。
运行错误运行Test.java为Java Application，出现错误。Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: javax/persistence/EntityListeners原因是缺少hibernate-jpa-*-api-*.Final.jar，导入该包，问题解决。
提示运行错误解决了，但是控制台仍然有提示信息。
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".SLF4J: Defaulting to no-operation (NOP) logger implementationSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
经过搜索，解决办法如下：
Placing one (and only one) of slf4j-nop.jar, slf4j-simple.jar, slf4j-log4j12.jar, slf4j-jdk14.jar or logback-classic.jar on the class path should solve the problem.
之前下载的hibernate压缩包里没有slf4j-nop.jar，就没有导入。单独下载该jar文件，导入，问题解决。
再次运行错误其实，报错是应该的，因为两次插入的数据完全相同，而主键要求唯一。这时，应该怎么配置，才能在不改变代码的情况下不断运行呢？经测试，只要在hibernate.cfg.xml配置文件中，把注释中的这一句释放出来，就可以了。
&lt;property name="hbm2ddl.auto"&gt;create&lt;/property&gt;

各文件的作用POJO和映射配置文件POJO中的属性和表中的字段是一一对应的。那么通过什么方法把它们一一映射起来呢？就是*.hbm.xml映射文件。该配置文件大致分为3个部分：1、类、表映射配置
&lt;class name="com.voidking.hibernate.model.Kcb" table="kcb"&gt;
2、id映射配置
&lt;id name="kch" type="java.lang.String"&gt;	&lt;column name="kch" length="3"&gt;&lt;/column&gt;	&lt;generator class="assigned"&gt;&lt;/generator&gt;&lt;/id&gt;
Hibernate的主键生成策略分为三大类：Hibernate对主键id赋值、应用程序自身对id赋值、由数据库对id赋值。

assigned：应用程序自身对id赋值。
native：由数据库对id赋值。
hilo：通过hi/lo算法实现的主键生成机制，需要额外的数据库表保存主键生成历史状态。
seqhilo：与hi/lo类似，通过hi/lo算法实现的主键生成机制，只是主键历史状态保存在sequence中，适用于支持sequence的数据库，比如Oracle。
increment：主键按数值顺序递增。
identity：采用数据库提供的主键生成机制，如SQL Server、MySQL中的自增主键生成机制。
sequence：采用数据库提供的sequence机制生成主键，如Oracle sequence。
uuid.hex：由Hibernate基于128位唯一值产生算法，根据当前设备IP、时间、JVM启动时间、内部自增量等4个参数生成十六进制数值（编码长度为32位的字符串表示）作为主键。即使是在多实例并发运行的情况下，这种算法在最大程度上保证了产生id的唯一性。
uuid.string：与uuid.hex类似，只是对生成的主键进行编码（长度16位）。在某些数据库中可能出现问题。
foreign：使用外部表的字段作为主键。
select：Hibernate3引入的主键生成机制，主要针对遗留系统的改造工程。

由于常用的数据库，如SQL Sever、MySQL等，都提供了易用的主键生成机制（如auto-increase字段）。可以在数据库提供的主键生成机制上，采用generator class=”native”的主键生成方式。
3、属性、字段映射配置
&lt;property name="kcm" type="java.lang.String"&gt;	&lt;column name="kcm" length="12"&gt;&lt;/column&gt;&lt;/property&gt;

4、关系配置表与表之间的关系，会被映射成类与类之间的关系，它们的关系的具体体现也会在该配置文件中配置。
hibernate.cfg.xmlHibernate配置文件主要用于配置数据库连接和Hibernate运行时所需要的各种属性，配置文件一般默认为hibernate.cfg.xml，Hibernate初始化期间会自动在classpath中寻找这个文件，并读取其中的配置信息，为后期数据库操作做好准备。
HibernateSessionFactorypackage com.voidking.hibernate.util;import org.hibernate.HibernateException;import org.hibernate.Session;import org.hibernate.cfg.Configuration;import org.hibernate.service.ServiceRegistry;import org.hibernate.service.ServiceRegistryBuilder;/** * Configures and provides access to Hibernate sessions, tied to the * current thread of execution.  Follows the Thread Local Session * pattern, see &#123;@link http://hibernate.org/42.html &#125;. */public class HibernateSessionFactory &#123;    /**      * Location of hibernate.cfg.xml file.     * Location should be on the classpath as Hibernate uses       * #resourceAsStream style lookup for its configuration file.      * The default classpath location of the hibernate config file is      * in the default package. Use #setConfigFile() to update      * the location of the configuration file for the current session.        */	private static final ThreadLocal&lt;Session&gt; threadLocal = new ThreadLocal&lt;Session&gt;();    private static org.hibernate.SessionFactory sessionFactory;	    private static Configuration configuration = new Configuration();    private static ServiceRegistry serviceRegistry; 	static &#123;    	try &#123;			configuration.configure();			serviceRegistry = new ServiceRegistryBuilder().applySettings(configuration.getProperties()).buildServiceRegistry();			sessionFactory = configuration.buildSessionFactory(serviceRegistry);		&#125; catch (Exception e) &#123;			System.err.println("%%%% Error Creating SessionFactory %%%%");			e.printStackTrace();		&#125;    &#125;    private HibernateSessionFactory() &#123;    &#125;		/**     * Returns the ThreadLocal Session instance.  Lazy initialize     * the &lt;code&gt;SessionFactory&lt;/code&gt; if needed.     *     *  @return Session     *  @throws HibernateException     */    public static Session getSession() throws HibernateException &#123;        Session session = (Session) threadLocal.get();		if (session == null || !session.isOpen()) &#123;			if (sessionFactory == null) &#123;				rebuildSessionFactory();			&#125;			session = (sessionFactory != null) ? sessionFactory.openSession()					: null;			threadLocal.set(session);		&#125;        return session;    &#125;	/**     *  Rebuild hibernate session factory     *     */	public static void rebuildSessionFactory() &#123;		try &#123;			configuration.configure();			serviceRegistry = new ServiceRegistryBuilder().applySettings(configuration.getProperties()).buildServiceRegistry();			sessionFactory = configuration.buildSessionFactory(serviceRegistry);		&#125; catch (Exception e) &#123;			System.err.println("%%%% Error Creating SessionFactory %%%%");			e.printStackTrace();		&#125;	&#125;	/**     *  Close the single hibernate session instance.     *     *  @throws HibernateException     */    public static void closeSession() throws HibernateException &#123;        Session session = (Session) threadLocal.get();        threadLocal.set(null);        if (session != null) &#123;            session.close();        &#125;    &#125;	/**     *  return session factory     *     */	public static org.hibernate.SessionFactory getSessionFactory() &#123;		return sessionFactory;	&#125;	/**     *  return hibernate configuration     *     */	public static Configuration getConfiguration() &#123;		return configuration;	&#125;&#125;
上面的实例中，我并没有使用这个类，如果使用它的话，Test.java文件可以修改如下：
package com.voidking.hibernate.test;import java.util.List;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.Transaction;import org.model.Kcb;import com.voidking.hibernate.util.HibernateSessionFactory;public class Test &#123;   public static void main(String[] args) &#123;	// 调用HibernateSessionFactory的getSession方法创建Session对象	Session session=HibernateSessionFactory.getSession();	// 创建事务对象	Transaction ts=session.beginTransaction();	Kcb kc=new Kcb();                       	// 创建POJO类对象	kc.setKch("198");                        	// 设置课程号	kc.setKcm("机电");                       	// 设置课程名	kc.setKxxq(new Short((short) 5));			 	// 设置开学学期	kc.setXf(new Integer(5));				 	// 设置学分	kc.setXs(new Integer(59));				 	// 设置学时	// 保存对象	session.save(kc);	ts.commit();                             	// 提交事务	Query query=session.createQuery("from Kcb where kch=198");	List list=query.list();	Kcb kc1=(Kcb) list.get(0);	System.out.println(kc1.getKcm());	HibernateSessionFactory.closeSession();		 	// 关闭Session   &#125;&#125;
HibernateSessionFactory类是自定义的SessionFactory，名字可以根据自己的喜好来决定。在Hibernate中，Session负责完成对象持久化操作。该文件负责创建Session对象，以及关闭Session对象。从HibernateSessionFactory文件可以看出，Session对象的创建大致需要以下3个步骤：1、初始化Hibernate配置管理类Configuration。2、通过Configuration类实例创建Session的工厂类SessionFactory。3、通过SessionFactory得到Session实例。
Hibernate核心接口Hibernate核心接口一共有5个：Configuration、SessionFactory、Session、Transaction和Query。这5个接口在任何开发中都会用到。通过这些接口，不仅可以对持久化对象进行存取，还能够进行事务控制。
ConfigurationConfiguration接口负责Hibernate的配置信息。Hibernate运行时需要一些底层实现的基本信息。这些信息包括：数据库URL、数据库用户名、数据库用户密码、数据库JDBC驱动类、数据库dialect。用于对特定数据库提供支持，其中包含了针对特定数据库特性的实现，如Hibernate数据库类型到特定数据库类型的映射等。使用Hibernate必须首先提供这些基础信息以完成初始化工作，为后续操作做好准备。这些属性在Hibernate配置文件hibernate.cfg.xml中加以设定，当调用：
Configuration config = new Configuration().configure();
Hibernate会自动在目录下搜索hibernate.cfg.xml文件，并将其自动读取到内存中作为后续操作的基础配置。
SessionFactorySessionFactory负责创建Session实例，可以通过Configuration实例构建SessionFactory。
Configuration config = new Configuration().configure();SessionFactory sessionFactory = config.buildSessionFactory();
Configuration实例config会根据当前数据库的配置信息，构造SessionFactory实例并返回。SessionFactory一旦构造完毕，即被赋予特定的配置信息。也就是说，以后config的任何变更将不会影响到已经创建的SessionFactory实例sessionFactory。如果应用中需要访问多个数据库，针对每个数据库，应分别对其创建对应的SessionFactory实例。SessionFactory保存了对应当前数据库配置的所有映射关系，同时也负责维护当前的二级数据缓存和Statement Pool。由此可见，SessionFactory的创建过程非常复杂、代价高昂。由于SessionFactory采用了线程安全的设计，可由多个线程并发调用。大多数情况下，应用中针对一个数据库共享一个SessionFactory实例即可。
SessionSession是Hibernate持久化操作的基础，提供了众多持久化方法，如save、update、delete等。通过这些方法，透明地完成对象的增加、删除、修改、查找等操作。同时，值得注意的是，Hibernate Session的设计是非线程安全的，即一个Session实例同时只可由一个线程使用。同一个Session实例的多线程并发调用将导致难以预知的错误。Session实例由SessionFactory构建：
Configuration config = new Configuration().configure();SessionFactory sessionFactory = config.buildSessionFactory();Session session = sessionFactory.openSession();
之后可以调用Session提供的save、get、delete等方法完成持久层操作。
TransactionTransaction是Hibernate中进行事务操作的接口，Transaction接口是对实际事务实现的一个抽象，这些实现包括JDBC的事务、JTA中的UserTransaction，甚至可以是CORBA事务。之所以这样设计是可以让开发者能够使用一个统一的操作界面，使得自己的项目可以在不同的环境和容器之间方便地移植。事务对象通过Session创建。
Transaction ts = session.beginTransaction();



Query在Hibernate 2.X中，find()方法用于执行HQL语句。Hibernate 3.X废除了find()方法，取而代之的是Query接口，它们都用于执行HQL语句。Query和HQL是分不开的。
Query query = session.createQuery("from Kcb where kch=198");

Query query = session.createQuery("from Kcb where kch=?");query.setString(0,"要设置的值");

Query query = session.createQuery("from Kcb where kch=:kchValue");query.setString("kchValue","要设置的值");
由于上例中的kch为String类型，所以设置的时候用setString，如果是int类型就要用setInt。还有一种通用的设置方法，就是setParameter方法，不管什么类型的参数都可以应用。
query.setParameter(0,"要设置的值");query.setParameter("kchValue","要设置的值");

Query还有一个list()方法，用于取得一个List集合的示例，此示例中包括可能是一个Object集合，也可能是Object数组集合。
Query query = session.createQuery("form Kcb where kch=198");List list = query.list();

HQL查询HQL是Hibernate Query Language的缩写。HQL的语法很像SQL，但HQL是一种面向对象查询语言。SQL的操作对象是数据表和列等数据对象，而HQL的操作对象是类、实例、属性等。HQL的查询依赖于Query类，每个Query实例对应一个查询对象。
基本查询1、查询所有课程信息
Session session=HibernateSessionFactory.getSession();Transaction ts=session.beginTransaction();Query query=session.createQuery("from Kcb");List list=query.list();ts.commit(); HibernateSessionFactory.closeSession();
2、查询某门课程信息
Session session=HibernateSessionFactory.getSession();Transaction ts=session.beginTransaction();Query query=session.createQuery("from Kcb order by xs desc");query.setMaxResults(1);//设置最大检索数目为1Kcb kc = (Kcb)query.uniqueResult();ts.commit(); HibernateSessionFactory.closeSession();
3、查询满足条件的课程信息
Session session=HibernateSessionFactory.getSession();Transaction ts=session.beginTransaction();Query query=session.createQuery("from Kcb where kch=001");List list=query.list();ts.commit(); HibernateSessionFactory.closeSession();

条件查询1、按指定参数查询
Session session=HibernateSessionFactory.getSession();Transaction ts=session.beginTransaction();Query query=session.createQuery("from Kcb where kcm=?");query.setParameter(0,"计算机基础");List list=query.list();ts.commit(); HibernateSessionFactory.closeSession();

2、使用范围运算查询
Session session=HibernateSessionFactory.getSession();Transaction ts=session.beginTransaction();Query query=session.createQuery("from Kcb where (xs between 40 and 60) and kcm in('计算机基础','数据结构')");List list=query.list();ts.commit(); HibernateSessionFactory.closeSession();

3、使用比较运算符查询
Session session=HibernateSessionFactory.getSession();Transaction ts=session.beginTransaction();Query query=session.createQuery("from Kcb where xs &gt; 50 and kcm is not null");List list=query.list();ts.commit(); HibernateSessionFactory.closeSession();

4、使用字符串匹配运算查询
Session session=HibernateSessionFactory.getSession();Transaction ts=session.beginTransaction();Query query=session.createQuery("from Kcb where kch like '%001%' and kcm like '计算机%'");List list=query.list();ts.commit(); HibernateSessionFactory.closeSession();

分页查询在页面上显示数据结果时，如果数据太多，一个页面无法全部显示，这是务必要对查询结果进行分页显示。为了满足分页查询的需要，Hibernate的Query实例提供了两个有用的方法：setFirstResult(int firstResult)和setMaxResult(int maxResult)。
Session session=HibernateSessionFactory.getSession();Transaction ts=session.beginTransaction();Query query=session.createQuery("from Kcb");int pageNow=1;int pageSize=5;query.setFirstResult((pageNow-1)*pageSize);query.setMaxResult(pageSize);List list=query.list();ts.commit(); HibernateSessionFactory.closeSession();
通常情况下，pageNow会作为一个参数传进来，这样就可以得到想要显示的页数的结果集了。
参考文档《Java EE基础实用教程》，郑阿奇主编关于对POJO PO 的理解：http://fluagen.blog.51cto.com/146595/36396/
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>hibernate</tag>
      </tags>
  </entry>
  <entry>
    <title>Hibernate与Struts2整合应用</title>
    <url>/dev-hibernate-struts2-integration/</url>
    <content><![CDATA[应用实例：学生选课系统。要求：学生登录系统后，可以查看、修改个人信息，查看个人选课情况，选定课程及退选课程。
建立数据库和表郝同学仍然使用MySQL数据库，scott用户。在xscj数据库中建立登录表、学生表、专业表、课程表，以及学生课程表即连接表。
create table dlb(id int not null primary key,xh char(6) not null ,kl varchar(20));create table xsb(xh char(6) not null primary key,xm varchar(8) not null,xb bit not null check(xb=0 or xb=1),cssj datetime ,zy_id int,zxf int default 0 check(0&lt;=zxf&lt;160),bz varchar(500),zp longblob);create table zyb(id int not null auto_increment primary key,zym varchar(12) not null,rs int default 0,fdy varchar(8));create table kcb(kch char(3) not null primary key,kcm varchar(12),kxxq smallint check(kxxq&gt;=1 and kxxq&lt;=8),xs int default 0,xf int default 0);create table xs_kcb(xh char(6),kch char(6),primary key(xh,kch));

创建Web项目新建Dynamic Web Project，命名为struts2_hibernate。
添加Hibernate开发能力右击项目名，Properties，Java Build Path，Libraries，Add Library…，User Library，Next，User Libraries…，New…，输入“hibernate”，OK，Add External JARs…，选中需要的jar文件，打开，OK。
自动生成POJO类和映射文件新建JPA工程新建JPA Project，输入一个工程名，Next，Next，走到一个界面，提示At least one user library must be selected.。勾选User Library中hibernate之后，显示The class &#39;javax.persistence.Convert&#39; is required to be in the selected libraries.莫非Hibernate的某些包没包含？研究了所有的包，发现，确实没有含有Convert这个类的。估计又是版本问题，真麻烦！
Back，Back，在JPA version中选择v1.0。Next，Next，勾选hibernate，Finish。
右击工程名，JPA Tools，Generate Entities from Tables…。选择Connection，激活连接，勾选Tables，Finish（或者一路Next，Finish）。
查看src文件夹，发现需要的POJO类已经生成，拷贝到需要的工程下即可。
但是，问题来了：POJO类有了，但是没有*.hbm.xml文件！
聪明的小伙伴肯定想到了，使用myeclipse生成POJO和*.hbm.xml，然后全部拷贝到eclipse的工程下。我只想说，同时安装eclipse和myeclipse，还换着用，这是有多无聊！
自己写？当然可以！但是人家myeclipse的POJO类和*.hbm.xml都可以自动生成，eclipse凭什么不可以？下面我们就研究一下方法。
Hibernate Tools插件第一招Help，Eclipse Marketplace…，在find中输入“Hibernate”，搜索到的选项中有Hibernate Tools（Indigo）3.4.X，单击Install。安装过程中，报错中断：
'Installing Software ' has encountered a problem.An error occurred while collecting items to be installed
本人的Eclipse是Luna版本（当前最新版），怀疑是兼容问题。重来，搜索到的选项中有JBoss Tools（Luna），单击Install。安装过程中选择Hibernate Tools安装，最终，依然报错，还能不能愉快地玩耍了！
第二招我们来到JBoss Tools官网，然后找到下载界面。可以看到，官方给出了三种下载方式：Eclipse Marketplace，Update Site和Artifacts。
刚才我们无意中使出第一招，失败了，让我们试试第二招。
Help ，Install New Software… ，Work with：http://download.jboss.org/jbosstools/updates/stable/luna/ ，然后选择Hibernate Tools，Next。
慢，非常慢，完全受不了这个速度。。。
第三招第三招是我喜欢的方式：离线安装。感觉很靠谱，来试试看。首先下载所需的zip文件，这里郝同学选择的是Update site (including sources) bundle of all Hibernate Tools。下载下来文件名为jbosstools-4.2.3.Final_2015-03-26_23-05-30-B264-updatesite-hibernatetools.zip。
Help ， Install New Software… ， Add… ， Archive… 。选中下载的文件，选择需要安装的插件，Next。啊勒，我靠，为什么还是这么慢！仔细观察一下进度条的提示，在Fetching什么玩意，貌似明白了什么。点击停止，然后把Contact all update sites during install to find requred software前面的勾去掉，再次Next。果然，进度马上就跑起来了！但是，跑着跑着就停了！进度条提示Connot perform operation.Computing alternate solutions,may take a while:，这个a while有点长啊！-_-|||，还能怎么办？放大招吧！下载Update site (including sources) bundle of all JBoss Core Tools，然后全部安装。我就不信了，全部的工具都在这，你还缺少依赖？
我去，这下更不得了，需要下载好多好多依赖的包，彻底醉了。。。
只勾选Hibernate Tools，试一试，成功！不容易啊！T_T
使用官方教程：http://tools.jboss.org/features/hibernate.html
这篇文章写得更详细：Step by step auto code generation for POJO domain java classes and hbm using Eclipse Hibernate plugin
这篇文章写得也不错：How to generate Hibernate mapping files &amp; annotation with Hibernate Tools
Window，Open Perspective，Hibernate。
Add Configuration…，选中Project，Database connection ，Setup… Propery file，Setup… Configuration file（并且进行一些配置）。然后，然后，然后就出现了错误！！！[Classpath]: Could not parse configuration:/hibernate.cfg.xml，试了各种方法，都没法解决这个问题，这是要闹哪样啊！
多么奇葩的问题，本以为还要花费一番功夫。半小时后，莫名其妙的好了！好了。。。
重新来一遍，完整的：
Window，Open Perspective，Hibernate。
Add Configuration…，选中Project（struts2_hibernate），选择Database connection，Setup… Propery file，Setup… Configuration file（需要进行一些配置）。
这时，会提示缺少MySQL驱动，在Classpath选项卡中配置一下就好了。
File，New，Hibernate Reverse Engineering File（reveng.xml），选中struts2_hibernate，Next，选择Console configuration，Refresh，
在工具栏中，有三个三角号（绿色圆底），其中一个三角号的右下角有Hibernate的小标志。点击它的下拉菜单，Hibernate Code Generation Configurations…。New，在Main选项卡中选择Console configuration，选择Output directory，勾选Reverse engineer from JDBC Connection。在Exporters选项卡中勾选Domain code（.java）和Hibernate XML Mappings（.hbm.xml）。Run。
观察struts2_hibernate工程下的文件，可以发现，我们需要的POJO类和*.hbm.xml文件都有了！
断网配置本地dtd文件刚才完整操作的时候，断网了，无法解析hibernate.cfg.xml文件，看来需要配置个本地dtd文件才可以。这里需要配置hibernate-configuration-3.0.dtd，最好也配置一下hibernate-mapping-3.0.dtd，这两个文件在hibernate3.jar中可以找到。配置好之后，问题完美解决。选中一些表，Include…，Finish。
下面是Struts2验证框架出现同样问题时的解决办法，从《Struts2概述》摘录，方便查阅：
1、解压xwork-core-*.jar包，找到xwork-validator-1.0.dtd。
2、eclipse，Window，Preferences，XML，XML Catelog，Add，File System…，选中刚才解压的xwork-validator-1.0.dtd，打开，
3、Location已经选好D:\jar\struts2\xwork-validator-1.0.dtd，Key type选择Public ID，Key填-//OpenSymphony Group//XWork Validator Config 1.0//EN，Alternative web address填http://struts.apache.org/dtds/xwork-validator-1.0.dtd。（本地dtd不存在时回去web上去找dtd）
4、StrutsAction-validation.xml需要修改如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE validators PUBLIC        "-//OpenSymphony Group//XWork Validator Config 1.0//EN"        "D:\jar\struts2\xwork-validator-1.0.dtd"&gt;&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="name"&gt;		&lt;field-validator type="requiredstring"&gt;			&lt;!--去空格--&gt;			&lt;param name="trim"&gt;true&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;姓名是必须的&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

*.hbm.xml文件修改Xsb.hbm.xml&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2015-5-23 0:27:57 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt;    &lt;class name="Xsb" table="xsb" catalog="xscj"&gt;        &lt;id name="xh" type="string"&gt;            &lt;column name="xh" length="6" /&gt;            &lt;generator class="assigned" /&gt;        &lt;/id&gt;        &lt;property name="xm" type="string"&gt;            &lt;column name="xm" length="8" not-null="true" /&gt;        &lt;/property&gt;        &lt;property name="xb" type="boolean"&gt;            &lt;column name="xb" not-null="true" /&gt;        &lt;/property&gt;        &lt;property name="cssj" type="timestamp"&gt;            &lt;column name="cssj" length="19" /&gt;        &lt;/property&gt;        &lt;property name="zyId" type="java.lang.Integer"&gt;            &lt;column name="zy_id" /&gt;        &lt;/property&gt;        &lt;property name="zxf" type="java.lang.Integer"&gt;            &lt;column name="zxf" /&gt;        &lt;/property&gt;        &lt;property name="bz" type="string"&gt;            &lt;column name="bz" length="500" /&gt;        &lt;/property&gt;        &lt;property name="zp" type="binary"&gt;            &lt;column name="zp" /&gt;        &lt;/property&gt;                &lt;many-to-one name="zyb" class="com.voidking.struts2_hibernate.model.Zyb" fetch="select" cascade="all" lazy="false"&gt;        	&lt;column name="zy_id"&gt;&lt;/column&gt;        &lt;/many-to-one&gt;                &lt;set name="kcs" table="xs_kcb" lazy="false" cascade="save-update"&gt;        	&lt;key column="xh"&gt;&lt;/key&gt;        	&lt;many-to-many class="com.voidking.struts2_hibernate.model.Kcb" column="kch"&gt;&lt;/many-to-many&gt;        &lt;/set&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;
Kcb.hbm.xml&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN""http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd"&gt;&lt;!-- Generated 2015-5-23 0:27:57 by Hibernate Tools 3.4.0.CR1 --&gt;&lt;hibernate-mapping&gt;    &lt;class name="Kcb" table="kcb" catalog="xscj"&gt;        &lt;id name="kch" type="string"&gt;            &lt;column name="kch" length="3" /&gt;            &lt;generator class="assigned" /&gt;        &lt;/id&gt;        &lt;property name="kcm" type="string"&gt;            &lt;column name="kcm" length="12" /&gt;        &lt;/property&gt;        &lt;property name="kxxq" type="java.lang.Short"&gt;            &lt;column name="kxxq" /&gt;        &lt;/property&gt;        &lt;property name="xs" type="java.lang.Integer"&gt;            &lt;column name="xs" /&gt;        &lt;/property&gt;        &lt;property name="xf" type="java.lang.Integer"&gt;            &lt;column name="xf" /&gt;        &lt;/property&gt;        &lt;set name="xss" table="xs_kcb" lazy="true" inverse="true"&gt;        	&lt;key column="kch"&gt;&lt;/key&gt;        	&lt;many-to-many class="com.voidking.struts2_hibernate.model.Xsb"&gt;&lt;/many-to-many&gt;        &lt;/set&gt;    &lt;/class&gt;&lt;/hibernate-mapping&gt;

Dao层组件实现DlDao.javapackage com.voidking.struts2_hibernate.dao;import com.voidking.struts2_hibernate.model.Dlb;public interface DlDao &#123;	public Dlb validate(String xh,String kl);&#125;

DlDaoImp.javapackage com.voidking.struts2_hibernate.dao.imp;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.struts2_hibernate.dao.DlDao;import com.voidking.struts2_hibernate.model.Dlb;public class DlDaoImp implements DlDao &#123;	@Override	public Dlb validate(String xh, String kl) &#123;		// TODO Auto-generated method stub		try &#123;			Configuration cf = new Configuration();			SessionFactory sf = cf.buildSessionFactory();			Session session = sf.openSession();						Transaction ts = session.beginTransaction();			Query query = session.createQuery("from Dlb where xh=? and kl=?");			query.setParameter(0, xh);			query.setParameter(1, kl);			query.setMaxResults(1);			Dlb dlb =(Dlb)query.uniqueResult();						ts.commit();			session.close();			sf.close();						if(dlb!=null)&#123;				return dlb;			&#125;else&#123;				return null;			&#125;		&#125; catch (Exception e) &#123;			// TODO: handle exception			e.printStackTrace();		&#125;		return null;	&#125;&#125;

XsDao.javapackage com.voidking.struts2_hibernate.dao;import com.voidking.struts2_hibernate.model.Xsb;public interface XsDao &#123;	public Xsb getOneXs(String xh);		public void update(Xsb xs);&#125;

XsDaoImp.javapackage com.voidking.struts2_hibernate.dao.imp;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.struts2_hibernate.dao.XsDao;import com.voidking.struts2_hibernate.model.Xsb;public class XsDaoImp implements XsDao &#123;	@Override	public Xsb getOneXs(String xh) &#123;		// TODO Auto-generated method stub		try &#123;			Configuration cf = new Configuration();			SessionFactory sf = cf.buildSessionFactory();			Session session = sf.openSession();			Transaction ts = session.beginTransaction();			Query query = session.createQuery("from xsb where xh=?");			query.setParameter(0, xh);			query.setMaxResults(1);			Xsb xs = (Xsb)query.uniqueResult();			ts.commit();			session.close();			sf.close();					&#125; catch (Exception e) &#123;			// TODO: handle exception			e.printStackTrace();		&#125;		return null;	&#125;	@Override	public void update(Xsb xs) &#123;		// TODO Auto-generated method stub		try &#123;			Configuration cf = new Configuration();			SessionFactory sf = cf.buildSessionFactory();			Session session = sf.openSession();			Transaction ts = session.beginTransaction();						session.update(xs);						ts.commit();			session.close();			sf.close();		&#125; catch (Exception e) &#123;			// TODO: handle exception			e.printStackTrace();		&#125;	&#125;&#125;
写完这个文件，我突然发现，写一个HibernateSessionFactory类当做工具真的太必要了！不然的话，每次我想用Session的时候，都要
Configuration cf = new Configuration();SessionFactory sf = cf.buildSessionFactory();Session session = sf.openSession();
每次都重新new一个Configuration，建立一个SessionFactory，一定加大了系统的开销。而且，一个数据库对应一个SessionFactory就够了！
myeclipse自动生成的HibernateSessionFactory类，感觉有点复杂，自己写一个吧！
MySessionFactory.javapackage com.voidking.struts2_hibernate.util;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration; //在使用hibernate开发项目，请一定保证只有一个SessionFactory//一个数据库对应一个SessionFactory 对象.final public class MySessionFactory &#123;     private static SessionFactory sessionFactory=null;         private MySessionFactory()&#123;             &#125;         static&#123;                 sessionFactory =new Configuration().configure("/hibernate.cfg.xml").buildSessionFactory();     &#125;         public static SessionFactory getSessionFactory()&#123;        return sessionFactory;    &#125;     &#125;

重写DlDaoImp.javapackage com.voidking.struts2_hibernate.dao.imp;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.struts2_hibernate.dao.DlDao;import com.voidking.struts2_hibernate.model.Dlb;import com.voidking.struts2_hibernate.util.MySessionFactory;public class DlDaoImp implements DlDao &#123;	@Override	public Dlb validate(String xh, String kl) &#123;		// TODO Auto-generated method stub		try &#123;			Session session = MySessionFactory.getSessionFactory().openSession();						Transaction ts = session.beginTransaction();			Query query = session.createQuery("from Dlb where xh=? and kl=?");			query.setParameter(0, xh);			query.setParameter(1, kl);			query.setMaxResults(1);			Dlb dlb =(Dlb)query.uniqueResult();						ts.commit();			session.close();						if(dlb!=null)&#123;				return dlb;			&#125;else&#123;				return null;			&#125;		&#125; catch (Exception e) &#123;			// TODO: handle exception			e.printStackTrace();		&#125;		return null;	&#125;&#125;

重写XsDaoImp.javapackage com.voidking.struts2_hibernate.dao.imp;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import com.voidking.struts2_hibernate.dao.XsDao;import com.voidking.struts2_hibernate.model.Xsb;import com.voidking.struts2_hibernate.util.MySessionFactory;public class XsDaoImp implements XsDao &#123;	@Override	public Xsb getOneXs(String xh) &#123;		// TODO Auto-generated method stub		try &#123;			Session session = MySessionFactory.getSessionFactory().openSession();			Transaction ts = session.beginTransaction();			Query query = session.createQuery("from xsb where xh=?");			query.setParameter(0, xh);			query.setMaxResults(1);			Xsb xs = (Xsb)query.uniqueResult();			ts.commit();			session.close();					&#125; catch (Exception e) &#123;			// TODO: handle exception			e.printStackTrace();		&#125;		return null;	&#125;	@Override	public void update(Xsb xs) &#123;		// TODO Auto-generated method stub		try &#123;			Session session = MySessionFactory.getSessionFactory().openSession();			Transaction ts = session.beginTransaction();						session.update(xs);						ts.commit();			session.close();		&#125; catch (Exception e) &#123;			// TODO: handle exception			e.printStackTrace();		&#125;	&#125;&#125;
ZyDao.javapackage com.voidking.struts2_hibernate.dao;import java.util.List;import com.voidking.struts2_hibernate.model.Zyb;public interface ZyDao &#123;	public Zyb getOneZy(Integer zyId);	public List getAll();&#125;

ZyDaoImp.javapackage com.voidking.struts2_hibernate.dao.imp;import java.util.List;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.Transaction;import com.voidking.struts2_hibernate.dao.ZyDao;import com.voidking.struts2_hibernate.model.Zyb;import com.voidking.struts2_hibernate.util.MySessionFactory;public class ZyDaoImp implements ZyDao &#123;	@Override	public Zyb getOneZy(Integer zyId) &#123;		try &#123;			Session session = MySessionFactory.getSessionFactory().openSession();			Transaction ts = session.beginTransaction();						Query query = session.createQuery("from zyb where id=?");			query.setParameter(0, zyId);			query.setMaxResults(1);			Zyb zy = (Zyb)query.uniqueResult();						ts.commit();			session.close();						return zy;		&#125; catch (Exception e) &#123;			// TODO: handle exception			e.printStackTrace();		&#125;		return null;	&#125;	@Override	public List getAll() &#123;		// TODO Auto-generated method stub		try &#123;			Session session = MySessionFactory.getSessionFactory().openSession();			Transaction ts = session.beginTransaction();						List list = session.createQuery("from zyb").list();						ts.commit();			session.close();			return list;					&#125; catch (Exception e) &#123;			e.printStackTrace();		&#125;		return null;	&#125;&#125;

KcDao.javapackage com.voidking.struts2_hibernate.dao;import java.util.List;import com.voidking.struts2_hibernate.model.Kcb;public interface KcDao &#123;	public Kcb getOneKc(String kch);	public List getAll();&#125;

KcDaoImp.javapackage com.voidking.struts2_hibernate.dao.imp;import java.util.List;import org.hibernate.HibernateException;import org.hibernate.Query;import org.hibernate.Session;import org.hibernate.Transaction;import com.voidking.struts2_hibernate.dao.KcDao;import com.voidking.struts2_hibernate.model.Kcb;import com.voidking.struts2_hibernate.util.MySessionFactory;public class KcDaoImp implements KcDao &#123;	@Override	public Kcb getOneKc(String kch) &#123;		// TODO Auto-generated method stub		try &#123;			Session session = MySessionFactory.getSessionFactory().openSession();			Transaction ts = session.beginTransaction();						Query query = session.createQuery("from kcb where kch=?");			query.setParameter(0, kch);			query.setMaxResults(1);			Kcb kc = (Kcb)query.uniqueResult();						ts.commit();			session.close();			return kc;					&#125; catch (Exception e) &#123;			e.printStackTrace();		&#125;		return null;	&#125;	@Override	public List getAll() &#123;		// TODO Auto-generated method stub		try &#123;			Session session = MySessionFactory.getSessionFactory().openSession();			Transaction ts = session.beginTransaction();			List list = session.createQuery("from kcb order by kch").list();			ts.commit();			session.close();			return list;		&#125; catch (HibernateException e) &#123;			// TODO Auto-generated catch block			e.printStackTrace();		&#125;				return null;	&#125;&#125;

struts.xml&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;	&lt;constant name="struts.multipart.saveDir" value="/tmp"/&gt;    &lt;package name="default"  extends="struts-default"&gt;    	&lt;action name="login" class="com.voidking.struts2_hibernate.action.LoginAction"&gt;			&lt;result name="success"&gt;/main.jsp&lt;/result&gt;			&lt;result name="error"&gt;/login.jsp&lt;/result&gt;		&lt;/action&gt;		&lt;action name="xsInfo" class="org.action.XsAction"&gt;			&lt;result name="success"&gt;/xsInfo.jsp&lt;/result&gt;		&lt;/action&gt;		&lt;action name="getImage" class="com.voidking.struts2_hibernate.action.XsAction" method="getImage"&gt;&lt;/action&gt;		&lt;action name="updateXsInfo" class="com.voidking.struts2_hibernate.action.XsAction" method="updateXsInfo"&gt;			&lt;result name="success"&gt;/updateXsInfo.jsp&lt;/result&gt;		&lt;/action&gt;		&lt;action name="updateXs" class="com.voidking.struts2_hibernate.action.XsAction" method="updateXs"&gt;			&lt;result name="success"&gt;/updateXs_success.jsp&lt;/result&gt;		&lt;/action&gt;		&lt;action name="getXsKcs" class="com.voidking.struts2_hibernate.action.XsAction" method="getXsKcs"&gt;			&lt;result name="success"&gt;/xsKcs.jsp&lt;/result&gt;		&lt;/action&gt;		&lt;action name="deleteKc" class="com.voidking.struts2_hibernate.action.XsAction" method="deleteKc"&gt;			&lt;result name="success"&gt;/deleteKc_success.jsp&lt;/result&gt;		&lt;/action&gt;		&lt;action name="getAllKc" class="com.voidking.struts2_hibernate.action.KcAction"&gt;			&lt;result name="success"&gt;/allKc.jsp&lt;/result&gt;		&lt;/action&gt;		&lt;action name="selectKc" class="com.voidking.struts2_hibernate.action.XsAction" method="selectKc"&gt;			&lt;result name="success"&gt;/selectKc_success.jsp&lt;/result&gt;			&lt;result name="error"&gt;/selectKc_fail.jsp&lt;/result&gt;		&lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;

web.xml&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app id="WebApp_9" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;	&lt;welcome-file-list&gt;		&lt;welcome-file&gt;/login.jsp&lt;/welcome-file&gt;	&lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;

界面交互Action类和jsp界面，在此省略。详情请见源代码。
严重错误部署，运行，404错误。进入Tomcat的Manager App界面，start项目，报错如下：
SEVERE:Exception starting filter struts2java.lang.ClassNotFoundException: org.apache.struts2.dispatcher.FilterDispatcher
我勒个去，怎么就找不到过滤器了！换成org.apache.struts2.dispatcher.ng.filter.StrutsPrepareFilter试试，报同样的错：
SEVERE:Exception starting filter struts2java.lang.ClassNotFoundException: org.apache.struts2.dispatcher.ng.filter.StrutsPrepareFilter
这个工程，和之前写的struts2工程有什么差别？struts2中，我直接把jar包放到了WebContent/WEB-INF/lib里面，而在这个项目中，我把jar包放到了WebContent/WEB-INF/lib/struts2里。删除一层目录试试，问题完美解决。
很多错误输入学号，密码，点击登录，报错如下：
HTTP Status 500 - type Exception reportmessage description The server encountered an internal error that prevented it from fulfilling this request.exception java.lang.reflect.InvocationTargetException	sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)	sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)	……	root cause 	……
root caose下面的内容是重点，要么是lib中缺少jar文件，要么某个类写错了，要么配置文件错误……总之各种错误，根据提示定位修改即可。
源代码分享https://github.com/voidking/struts2_hibernate.git
小结太复杂了，根本没法愉快的玩耍！改了几十个错误！！！尤其是Hibernate中POJO类和*.hbm.xml对应的部分，太难搞了！记得JPA似乎简单一点，等到复习到那部分再深入研究。最终，程序跑起来了，但是很多功能都没法用，各种not mapped，实在搞不下去了，能力有限啊。。。
发现：在JavaSE中，可以通过引入jar包的方式使用外部类。但是在JavaEE中，也就是Web工程中，需要拷贝jar包到lib文件夹中才可以使用外部类。分析：发布到Tomcat中的工程，根本没有记录引用外部类的文件，也就是说，找不到外部jar包。而lib文件夹中的jar包，应该是默认寻找外部类的地方。
参考文档《Java EE基础实用教程》，郑阿奇主编

在Eclipse中从数据库表自动生成hibernate的java实体类http://www.shangxueba.com/jingyan/2453455.htmlhttp://blog.csdn.net/zheng2008hua/article/details/6274659

Hibernate初始化时的Could not parse configurationhttp://blog.csdn.net/mydeman/article/details/6134820

如何理解Hibernate中的HibernateSessionFactory类http://www.cnblogs.com/dyllove98/archive/3243769.html

org.hibernate.MappingException:An association from the table * refers to an unmapped class:http://blog.csdn.net/jayqean/article/details/5608330

org.hibernate.HibernateException: Unable to instantiate default tuplizerhttp://www.cnblogs.com/chuyuhuashi/archive/2423235.html

]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>hibernate</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习入门</title>
    <url>/dev-machine-learning-start/</url>
    <content><![CDATA[前言机器学习标志着计算机科学、数据分析、软件工程和人工智能领域内的重大技术突破。AlphaGo 战胜人类围棋冠军、人脸识别、语音识别、图片识别、大数据挖掘、自动驾驶等等，都和机器学习密切相关。
机器学习其实很简单，而且很有趣。
机器学习是什么？我们生活在一个有人类和计算机的世界，人类和计算机的一大不同点是，人类能从过去的经验中学习，而计算机只能执行指令，它们需要被编程。现在的问题是，我们能让计算机从过去的经验中学习吗？答案是我们能这么做。这就是机器学习的目的，教会计算机利用过往的经验完成指定任务。当然，对计算机来说，过去的经验就是被记录的数据。


先修条件和要求1、掌握中级编程知识，可以通过“编程入门”纳米学位、其他编程入门课程项目或其他软件开发实战经验获得，相关知识包括：

字符串、数值和变量
语句、操作符和表达式
列表、元组和字典
条件、循环
过程、对象、模块和库
故障诊断和调试
调研和文档
解决问题
算法和数据结构

2、掌握中级统计学知识，可以通过优达学城的统计学入门课程获得，相关知识包括：

总体，样本
均数、中间值、众数
标准误差
方差，标准差
正态分布
精度和准确度

3、掌握中级微积分和线性代数知识，这些知识可以通过线性代数复习课获得，相关知识包括:

导数
积分
级数展开
通过特征向量和特征值进行矩阵运算

我们为你准备了一些学习扩展资料，点击这里查看。
决策树假设我们是苹果或谷歌应用商店，我们的目标是为用户推荐应用。对每个用户，我们向其推荐最有可能下载的应用。我们有一张用来制定推荐规则的数据表。我们有6个用户信息，包括性别、年龄和下载过的应用。从表中可以看出，年龄比性别更适合用来预测用户会下载什么应用。经过分析，我们可以得到一个决策树。现在我们一旦我们有了新用户，就可以将决策树应用于他们的数据，并向他们推荐决策树得出的应用。
显然，我们并不总能得到与数据良好匹配的决策树，我们将学习一个算法，用来帮助我们找到和数据最匹配的决策树。
朴素贝叶斯我们再来看下一个例子，我们将搭建一个垃圾邮件检测分类器。我们有100封邮件，其中已经手工标记出了25封垃圾邮件，剩下的75封被称为非垃圾邮件。现在我们来思考一封垃圾有家可能会显示出什么特征，并对这些特征进行分析。例如，可能有一个特征包含单词“cheap”，认为一封包含了单词cheap的邮件可能是垃圾邮件，是合理的。我们来分析这一判定，我们发现25封垃圾邮件中有20封包含单词“cheap”，其余75封正常邮件的5封包含单词“cheap”。我们暂时不理会剩下的不含“cheap”的邮件，只关注那些包含cheap的邮件。请问，如果有一封邮件包含单词“cheap”，那么它是垃圾邮件的概率是多少？答：80%。即，如果一封邮件包含单词“cheap”，那么它的垃圾邮件的概率为80%，于是我们把这个特征的关联概率设为80%，并用它来标记新邮件是否为垃圾邮件。我们也可以检查其他特征，尝试找出它们的关联概率。比如我们查看邮件是否包含拼写错误，发现包含拼写错误的邮件为垃圾邮件的概率为70%。接着查看缺少标题的邮件，发现它们是垃圾邮件的概率为90%。当我们收到新邮件，我们可以结合这些特征来猜测新邮件是否是垃圾邮件，这个算法叫做朴素贝叶斯算法。
梯度下降假如我们现在正身处山顶（珠穆朗玛峰），我们的目标是抵达山底，应该采取什么策略？我们可以一步一步来。我们查看四周可以走的许多选项，在其中找到下降距离最大的方向，下降一步。然后重复这个步骤，查看四周，找到下降距离最大的方向，下降一步。重复此步骤，直到完成下山。这个算法，叫做梯度下降。你可以把这座山想象成要解决的问题，把山底当做对问题的解答。我们解决这个问题的过程，就是总是顺着指向答案的方向小步前进。
线性回归假设我们正在研究房地产市场，我们的任务是预测给定面积的房屋的价格。这里有一栋较小的房子售价为$70000，一栋较大的房子售价为$160000，我们希望估计一栋中等面积的房子的价格，应该如何来做？图中的蓝色数据点，是我们收集的过去的房屋数据。我们可以看到这些数据点似乎排成一条直线，我们可以画出一条对拟合数据的直线。根据这条直线，我们可以预测中等房子的价格为$120000。这个方法叫做线性回归。
你可以把线性回归想象成一个画家，他检查数据并画出穿过数据区域的最佳拟合直线。你或许会问，我们如何找到这条线？我们来看一个例子，我们尝试找出这三个点的最佳拟合直线。我们假设自己是计算机，因此不能直接用视觉来判断。我们随机地画一条直线，检查这条直线的效果如何，为此我们需要计算误差。我们将检查这三个点与拟合直线的距离，我们把这三个距离之和，称为误差。现在四处移动这条线，看是否能减小误差。移动后，再次计算误差。如果误差变大，则说明方向错误。如果误差变小，则说明方向正确。我们发现误差变小了，因此决定采用这次移动。如果重复几次这个步骤，我们总能继续减小误差，最终得到一条拟合曲线作为很好的解决方案。这种最小化误差的通用方法叫做梯度下降（gradient descent）。
在实际使用中，我们并不希望使用数值为负的距离，我们会使用数据点到拟合直线的距离的平方，而不是距离本身。这种方法叫做最小二乘法（least squares）。
我们再次回到珠穆朗玛峰顶，尝试找出到达山底的下降路径。在这个背景里，我们所处的位置越高，代表当前的误差越大，下降高度就意味着减小误差。我们该怎么做？我们查看四周，寻找能下降更多高度的路径，这等价于四处移动拟合直线来最大程度减小误差。举例来说，这个方向似乎就是高度下降最大的方向，我们朝着这个方向前进一步，这等价于沿着能够最大程度减小误差的方向移动拟合曲线，即移动直线让它更加接近这三个点。现在我们减小了误差，也就是更加靠近了山底。然后我们重复以上的过程，查看四周并判断能够最大程度下降的方向。或者等价地，能够使拟合直线更加靠近数据点的方向。然后我们不断地重复此过程，寻找高度下降最大的方向，或者使拟合直线更加靠近数据点的方向，不断减小误差直到其达到最小值，也就得到了最佳拟合直线。
逻辑回归假设我们是一所大学的招生办公室，正在决定录取哪些学生。根据如下两条信息，我们将录取或拒绝他们。录取考试成绩，和他们的课程成绩。例如，学生1考试成绩为9，课程成绩为8，这名学生最终被录取了。还有一名学生2，考试成绩为3，课程成绩为4，最终没有被录取。现在有一位新提交申请的学生3，考试成绩为7，课程成绩为6，我们是否应该录取他？为此，我们首先把他们的数据画在坐标系中，x轴代表考试成绩，y轴代表课程成绩。为决定是否录取学生3，我们尝试在录取数据中寻找规律。为此我们检查曾经申请过的学生，被录取或拒绝的数据。录取的点代表过去被录取的学生，红色的点代表曾经被拒绝的学生。我们来仔细查看数据，红色的点和绿色的点似乎可以被一条线很好地分开。在这条线上方的大部分点是绿色的，而下方的大部分点是红色的，但有些数据点例外。我们以这条线为模型，每当接到新的学生申请，我们把他们的成绩画在坐标图上。如果数据点是在这条线的上方，那么预测他们会被录取；如果数据点在下方，则预测他们会被拒绝。学生3的数据坐标为(7,6)，位于直线上方，因此我们判断这个学生会被录取。这种方法叫做逻辑回归（Logistic Regression）。
现在的问题是，我们如何找到这条能最好地分割数据点的线？来看一个简单的例子，如何画出一条线以最好地区分绿色数据点和红色数据点？计算机无法依靠视觉来画出这条线，所以我们从画一条像这样随机的线开始。有了这条线，我们再随机地规定，位于线上方的点为绿色，下方的点为红色。然后就像线性那样，我们先计算这条线的效果。一个简单的测量误差的标准是出错的数目，即被错误归类的数据点的数量。这条线错判了两个点，一个红色的点和一个绿色的点。仍然和线性回归类似，我们移动这条线，通过梯度下降算法，最小化错误数量。实际使用中，为了正确地使用梯度下降算法，我们需要最小化的并不是错误数目。取而代之的是，能代表错误数目的对数损失函数（log loss function）。
最初6个数据，有4个被正确分类，它们是两个红色和两个绿色；2个被错误分类，它们是一个红色和一个绿色。误差函数会对这两个被错误归类的数据点施加很大的惩罚，而对四个被正确分类的数据点施加很小的惩罚。现在四处移动这条线以将误差降到最小。移动直线后，可以看到有些误差减小了，有些增加了，但总体上，误差之和变小了，因为我们正确归类了之前被错判的两个点。这个过程的意图是，找到能最小化误差函数的最佳拟合曲线。我们如何最小化误差函数？依旧是使用梯度下降算法。我们再次回到珠穆朗玛峰，我们所在的位置很高，因此此时有很大的误差，我们探索四周寻找下降最大的方向。或者等价的，寻找能通过移动直线最大程度减小误差的方向。我们决定沿着这个方向前进一步，减小了函数误差。重复这个步骤，沿着最大程度减小误差的方向前进一步。到达了山底，则说明我们已经将误差减少到了最小值。
支持向量机SVM我们更进一步学习把数据一分为二的艺术。我们看这6个点，似乎有很多条线可以分开它们。例如，这条蓝色的和黄色的。请问，那条线可以把数据更好地分开？看这条蓝色的线，似乎它是失败的，它太靠近这两个点了。如果我们想要最小化误差，它会误分到一个或多个点。这条黄线似乎是一个更好的划分，考虑到它能够来自于所有的点进行划分。所以，似乎最好的线是这条黄色的。现在的问题是，我们如何能够找到这条黄色的线？在找这条黄色的线之前，让我们事实上来找一个度量方式，它可以告诉我们黄色的线更好。那么，第一件事情就是观察这些远离边界的点，它们对于我们的决定并不重要，所以让我们忘掉这些点，只考虑那些离边界近的点。事实上，我们真正要关注的是点到两条直线的距离。什么让我们知道了黄的线更好呢？这条黄色的线更好，是因为它距离这些点更远。那么，我们观察这四个点的距离，最小的距离就是我们度量点离直线到底有多近。这意味着我们必须要考虑的，就是这四个距离的最小值，那是我们度量线离点到底有多近的方式。我们称这个度量为距离。
所以我们得出结论，黄色的线更好。因为在黄线中，这些距离中最小的距离，比蓝线中最小的距离大。这就是我们需要处理的函数，这四个距离中的最小值。我们的目标是使这个最小值尽可能的大，换句话说，我们需要最大化这个距离。我们能够怎么最大化这个距离呢？没错，梯度下降。这里也有其他方法能够使用，之后的课上会学到。这个方法叫做支持向量机，支持，是因为靠近边界的点被称为支撑。
神经网络我们更加仔细地观察这个模型，这个模型接受或者拒绝学生。比如有一个学生4，他在这次考试成绩中得到了9分，但他的课程成绩是1。根据我们的模型，这个学生应该被接受。因为他在这条线的上面，但是这似乎不对，因为这个学生有一个非常低的课程成绩，不应该被接受。所以想要用一条直线来区分这里的数据，已经不合适了。也许真实的数据，应该像那些低的考试成绩或者低的课程成绩的都不应该被接受，所以这条线已经不能分离这些点了。那么，我们该怎么做呢？也许是一个圆，也许是两条线。
让我们试一下两条线，我们能够怎么找到这两条线呢？我们可以通过梯度下降来最小化一个和之前相似的对数损失函数。这被称为神经网络（neural network）。
现在问题是，为什么这被称为神经网络？比如我们在一台非常慢的电脑上工作，一个时间只能处理一件事，请问这个区域的点被两条线区分开了吗？我们必须把它分成两个单独的问题。第一个问题是，这个点在蓝线之上吗？第二个问题是，这个点在黄线之上吗？第三个问题是，第一个问题和第二个问题的答案都是“yes”吗？假设我们把(1,8)作为输入，可以得到如下结果：我们把这三个问题合成到一起，就得到了一个神经网络。把“and”节点看成和前两个节点相同，可以得到最终神经网络的样子。左边，我们叫做输入层；中间，我们叫做隐藏层，会帮助我们计算；右边，我们叫做输出层。
这是一个简单的神经网络，但是能够看出如何在中间增加更多的节点或增加更多的层，帮助我们映射更加复杂的问题，甚至在三维空间或者更高维的空间。神经网络是非常强的机器学习算法，其被使用在大多数人工智能项目中，比如面部识别、语音识别、下棋和驾驶。我们称它为神经网络是因为这些节点像大脑里的神经元，神经元会把输入和其他神经元的输出以一种神经脉冲的形式，决定是否激活这个神经脉冲。在我们的情况中，神经元把输入和其他神经元的输出以数字的形式，决定返回一个0或1。
核函数现在我们学习另外一种非常强大的方法，来分开平面上的点。假设我们有4个点像这样排列，我们想要分开它们，似乎一条线不能完成这个任务，因为它们已经在一条线上面。我们要跳出思维定式，一个方式是用一个曲线来分开它们，另外的方式事实上是在平面外考虑。想象一下这些点正在一个三维的空间中，有4个点在平面上，对于第三个维度，我们增加一个额外的z轴。如果我们能够找到一个方式来提升这两个绿色的点，那么我们就能够用平面分开它们。那么哪一个是更好的解决办法？在一个平面里用一条曲线分开这些点，还是在空间里用平面分开它们？实际上，这两个其实是相同的办法。这种方法被称为核方法（kernel method），在支持向量机中它被很好的使用。
我们接下来学习曲线办法的更多细节。首先我们把坐标放在点上，我们需要的是一种办法，能够从红色的点中区分出绿色的点。如果点的坐标是(x,y)，也许我们需要一个方程，变量是x和y。对于绿色的点，给我们一个大的值；对于红色的点，给我们一个小的值。或者是相反的情况。那么下面哪个方程能够解决这个问题呢？这不是一个简单的问题，我们先来做一个表格。这些等式中，哪一个能够分离绿色的点和红色的点？x+y对于每个点都是结果3，无法分离；x的平方，对于红色点的结果有大有小，绿色点的结果也有大有小，无法分离；xy对于红色点结果为0，绿色的点结果为2，可以分离。因为这是一个函数，红色的点给我们一个值，绿色的点又给我们另外一个值，这个函数能够区分开红色和绿色。这里我们有4个点，坐标是(x,y)，还有一个坐标的乘积xy。对于红色的点，我们有乘积xy=0；对于绿色的点，我们有乘积xy=2。什么能够分开0和2呢？那就是1，所以我们用式子xy=1就能分开它们。那么，xy=1是什么？这个和y=1/x是一样的。y=1/x的图，就是上面的双曲线。
接下来我们看看在三维空间中发生了什么。我们有4个点，有一个额外的z轴（用于表示高度）。我们把xy加入我们的核心需求中，换句话说，我们考虑一个二维到三维的映射，把平面上坐标是(x,y)的点映射到了空间中，坐标为(x,y,xy)。所以，以一个不同的方式，它仍然能够分离这些点，因为它把绿色的点升高到了2，把红色的点留在下面。现在什么可以区分这些点呢？一个平面。这就是在三维空间中可视化核方法的一种方式。
K均值聚类假设我们有一些披萨店，我们想把他们中的三个放到这个城市里。研究发现吃披萨的人大都住在这些地方，我们需要知道哪里是放置他们最优的地方。这些房子能够很好地分成三组，红色、蓝色和黄色。在这三个组里每个放一个披萨店似乎行得通，但是电脑并不知道怎么做这个，所以我们需要一个算法来做这件事。我们随机选择三个地方作为披萨店，它们在星标的地方。每一个房子都会去离他们最近的披萨店，也就是说，黄色房子会去黄色的披萨店，蓝色房子会去蓝色的披萨店，红色房子会去红色的披萨店。但是现在，黄色房子离黄色披萨店很远。如果移动黄色披萨店到它们的顾客中心，是有意义的，对于蓝色和红色披萨店也一样。那么，让我们移动每一个披萨店到它们的顾客中心。每一次移动披萨店后，离房子最近的披萨店随之发生变化，房子的颜色变成最近的披萨店的颜色。现在，我们有了一个优化的方案。迭代这个过程，我们从随机的解，逼近了理想的解，也就是把披萨店放在顾客住的房子的中心。这个算法叫做K均值聚类（K-Means Clustering）。当我们知道聚类数量的时候，K均值聚类非常实用。现在留下一个问题，如果我们不知道聚类数量，该怎么办？
层次聚类这里有一个方式，让我们给房子分组，不需要提前知道聚类的详细数量。比如房子被排列成这样：如果两个房子很近，那么它们应该由共同的披萨店服务。按照这个理念，我们来分组这些房子。把最近两个房子分到一组，重复这个步骤，直到最近的两个房子的距离超过某个界限，这个界限将会控制我们想要这些聚类分开多远。这个算法叫做分层聚类。上面的例子可以看出，当我们不知道数目，但是知道想要这些聚类离得多远的时候，分层聚类很实用。
后记我们学习了很多被用在机器学习中的主要算法，使用线性回归来预测房屋价格，使用朴素贝叶斯来检测垃圾邮件，使用决策树来推荐应用。我们学会了使用逻辑回归和支持向量机来创建一个模型，使用神经网络和核方法来改善模型。我们学会了使用聚类算法，在一个城市中如何定位一个披萨店。还有更多的算法，等待我们以后去学习。如果给你一个数据集，你怎么知道该挑选哪种算法呢？我们需要学习比较它们，基于运行时间、准确率等等。我们还能够把算法组合在一起使用。
书签优达学城-机器学习工程师（中/英）https://cn.udacity.com/course/machine-learning-engineer-nanodegree--nd009
Udacity GitHub 机器学习项目https://github.com/udacity/machine-learning/
优达学城论坛https://discussions.youdaxue.com/c/nd009-machine-learning-engineer-cafe
Latest MLND: Café topics - Udacity Discussion Forumhttps://discussions.udacity.com/c/nd009-cafe
Coursera-机器学习https://www.coursera.org/learn/machine-learning/home/welcome
Coursera-机器学习基础：案例研究https://www.coursera.org/learn/ml-foundations/home/welcome
Machine Learning Examples - MATLAB &amp; Simulinkhttps://cn.mathworks.com/solutions/machine-learning/examples.html?s_eid=PSM_da
MATLAB数据分析与挖掘实战——图书配套资料下载http://www.tipdm.org/ts/578.jhtml
BdRace数睿思_数据挖掘竞赛平台http://www.tipdm.org/datarace/index.html
机器学习公开课汇总
微软“机器学习”系列文章（需翻墙）http://www.msra.cn/zh-cn/research/machine-learning-group/default.aspx
机器学习(Machine Learning)&amp;深度学习(Deep Learning)资料(Chapter 1)https://github.com/ty4z2008/Qix/blob/master/dl.md
从0到1：我是如何在一年内无师自通机器学习的？http://www.leiphone.com/news/201609/SJGulTsdGcisR8Wz.html
Deep Learning Tutorialshttp://deeplearning.net/tutorial/
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习工程师求职面试</title>
    <url>/dev-ml-interview/</url>
    <content><![CDATA[前言本文转载自优达学城《机器学习工程师》
简历项目在工作申请和应聘中，简历是必备品。一份好的简历，必须契合岗位需求。在这个项目中，你需要找到一条招聘信息，然后根据岗位的职责要求，更改你的简历。一旦你完成此项目，你就成功学会了定向寻找的方法，你就可以随时去找工作了！


项目资源1、项目评审标准。优达学城的项目导师将根据此评审标准检查你的项目。2、项目检查表。提交项目前，你可以对照这个检查表检查你的项目。3、职业资源中心。在这里找到更多关于如何改进你的简历的贴士。
简历模板从零开始编写你自己的简历，这样你的简历一定是独一无二的

Resume Genius: Resume Templates
Resume Builder

技巧在介绍你参与过的项目和工作经验时，尽量使用点列表（bullet points）：

用动词开头
包含数字
强调结果
伯克利大学动词表（适用于简历和求职信）

简历项目提交说明：此项目目前仅提供英文审阅服务，你需要用英文完成项目。
项目导师会根据该评估准则（与你制作简历时遵循的清单相符）对你的简历项目进行审核。
提交说明1、在优达学城职业资源中心找到一个招聘岗位，要么是你现在就可以申请的，要么是你在纳米学位毕业后会申请的。判断这个岗位是否适合你。（注：如果你初步判断有75%的可能可以达到该工作要求，那么你就可能就是一个很好的候选人，你就该去试一下！）2、根据这个岗位的具体要求，修改完善你的简历。3、在提交时，在“给审核人留言”一项中复制并粘贴岗位内容，或是直接放置链接。4、参考：在简历中删除敏感信息，例如你的电话号码。5、提交 pdf 版本的简历。
分享简历优达学城与雇主合作，雇主可以通过你的专业资料与优达学城学员和毕业生联系。 一旦你完成了简历审核，请务必将你已审核的简历更新到你的个人资料中！
求职信项目在这个项目中，你需要撰写一封求职信来描述你所具备的各项技能。更重要的是在信中陈述你对这份工作的热情。我们建议你针对一个你在网上找到工作描述来撰写这封求职信。我们希望所有的学生能够通过练习撰写求职信来学习如何把你的技能与工作职位的要求联系起来。
说明：此项目目前仅提供英文审阅服务，你需要用英文完成项目。
项目导师会根据该评估准则（与你制作简历时遵循的清单相符）对你的简历项目进行审核。
提交准备好提交求职信后，你需要：
1、删除/匿名化你的求职信上的所有个人联系人信息，以防泄漏隐私。2、创建 PDF 格式的简历，这样你的简历在不同操作系统/软件/屏幕中有一致的版面样式。3、点击下方的“提交项目”按钮，并根据说明操作。4、在“告知审核员”中，请包括任何有关你的职业目标（如申请的工作或领域），或任何有意偏离评估准则情况的详细信息。
注意：我们最多需要一周的时间来对项目进行评分，但多数情况下无需一周。项目评审完成后，你会收到电子邮件。如果你在提交项目时遇到问题，或者想查看提交状态，请发送电子邮件至 support@youdaxue.com。
GitHub个人资料项目你的GitHub个人资料展示你创建的项目，并让他人了解你的工作风格和提交频率。通过展示你对 GitHub 的熟悉程度，其他开发人员和招聘经理能够知道你拥有他们需要能力，你就是他们正在寻找的人。你的代码库应表明你认真对待项目，并且能够编写干净、格式正确的代码。请查看 GitHub 上的这篇出色的博客文章，了解如何用 GitHub 帮助你持续学习，发展职业生涯。
为何要完成此 GitHub 个人资料项目？GitHub 越来越多地被用作招聘平台以及潜在雇主查看你的作品的方式。它还是与其他开发人员建立联系和展示你的技能的好地方。
我应该做什么？你应该以招聘人员或用人部门经理的眼光查看你的 GitHub 个人资料，重点关注你的个人资料、项目和代码如何将你描绘成公司的潜在候选人或项目的协作者。
为此，你需要更新你的 GitHub 个人资料，让其显得专业并适合用于求职。你还要完善项目，让它们方便招聘人员和对你的工作感兴趣的任何其他人浏览。因此，你需要添加自述文件和格式正确的提交说明。
如何完成此 GitHub 个人资料项目？在纳米学位课程的此阶段，我们假设你掌握了 Git 和 GitHub 的基础知识：如何克隆代码库，如何初始化代码库，如何提交并提供说明，以及如何向 GitHub 上传代码库。如果不了解这些基础知识，请查看我们的如何使用 Git 和 GitHub 课程。
首先通读 Udacity GitHub 个人资料检查表大致了解 GitHub 个人资料的目标和任务。
查看整个检查表；勾选已完成的每一项。对于未完成的项，修复并更新 GitHub 个人资料。建议你阅读此博客文章，了解有关 GitHub 这个在线平台的更多详细信息。还建议你查看职业资源中心，获取有关更新 GitHub 个人资料的更多指导。
如何在 GitHub 上创建 readme 文档？如果对如何在 GitHub 上创建 readme 文档不熟悉，可按照下面的说明开始创建：1、单击某个项目并滚动到下面的文件列表。如果尚未创建自述文件，将会看到类似这样的图像：2、单击添加自述文件按钮。3、在自述文件中，解释项目的目标，有关如何使用或查看项目的说明，以及寻求何种类型的协作。自述文件是使用 Markdown 编写的；请查看 GitHub 的 Markdown 指南了解详细信息。
完善个人资料的途径？GitHub 能够快速、直观地显示你的代码库活动。因此，强烈建议开发人员显示活动。你在此项目中完成的任务只是一个开端。GitHub会突出显示你在上一年的活动，因此我们有两条长期建议：1、每天提交细微的增量更改。像下图这样的绿色提交图表表明你正积极地向项目中添加内容。2、向开源代码库供稿。对于招聘人员，这是一个重要的积极信号。它表明你能够很好地与他人合作，并且更重要的是，它表明你真的对编码充满热情，愿意在业余时间不计报酬地做这件事。如果想知道如何开始，请查看 GitHub 指南。
GitHub项目提交你的 GitHub 主页是呈现给潜在雇主的“关键证据”，证明你会是一个很好的职位候选人，因为他们可以从中看到你过往工作的细节。 许多招聘人员使用 GitHub 搜寻候选者，许多纳米学位毕业生都因为他们在 GitHub 上的活跃记录获得了工作机会。 此外，通常，你与其他程序员使用 GitHub 合作完成项目的——这将显示你能够在工作中与工程团队的其他成员合作。
在此项目中，我们将指导你如何从招聘经理或人事部门经理的角度审视你的的 GitHub 主页，重点关注你的个人资料、项目和代码，以及它们如何能证明你是公司的潜在候选人或项目需要的工程师。虽然这个项目和其他职业发展项目一样是可选的，但我们建议所有学生都能完成此项目。
说明：此项目目前仅提供英文审阅服务，你需要用英文完成项目作业。
提交说明1、在你已经连续编程至少两周后再提交此项目，这样审阅者才能向你提供有效的点评。2、在项目提交页面中输入你的 GitHub 个人主页（https://github.com/username）。
项目资源1、项目评审标准。优达学城项目导师会依据此评审标准审阅你的项目。2、项目检查表。对照此检查表，检查你是否已经满足项目要求。3、职业资源中心。你可以找到关于如何改善你的个人主页的进一步的信息。
领英个人资料项目你已经创建（或更新）了领英个人资料，它简明、清晰，精彩地讲述了你最好的一面，接下来你就可以提交它以供评审了！
这是一个可选项目。仅当你希望获得有关领英个人资料的反馈时，才应提交。这最适合想要找工作或想改进其领英个人资料的学生。
为何要完成此领英个人资料项目？领英是世界上最大的在线职业社交网络，在全球拥有 3 亿用户。最重要的是，它不仅仅是一份传统简历！领英还让你能够在线推销自己的成就，同时增强自己的职业社交网络。
95% 以上的招聘人员使用领英作为招聘工具。你的简历只能概述你的职业生涯，而 领英却可以生动地描绘你的情况，无论你有何背景。由于许多行业领导者都是领英社区的积极投稿人，因此 领英还让你有机会创建个人品牌，让潜在雇主与你联系并获得有关行业趋势的见解。
我应该做什么？你的领英个人资料应该帮助你在使用正确关键字的搜索结果中突显出来，并指示你不仅有相应的资质，而且积极上进。为了实现这些目标，请记住 3-30-180 规则。它是指招聘人员只在你的领英个人资料上花很短的时间。招聘人员花 3 秒钟来决定是否继续查看你的个人资料，花30 秒钟阅读第一遍，然后花 180 秒钟决定是否与你联系。有关 3-30-180 规则的更多信息，请参阅优达学城的这篇博客文章。
如何完成此领英个人资料项目？首先通读 优达学城领英个人资料检查表，大致了解领英个人资料的目标和任务。还应检查同行的个人资料，了解如何推介你自己和你的技能。
如果是从头开始创建领英个人资料，请转到下一部分。如果是更新领英个人资料，可以跳到拥有领英个人资料后部分。
如果是从头开始创建领英个人资料创建一个帐户，并登录领英。
拥有领英个人资料后查看整个优达学城领英个人资料检查表；勾选已完成的每一项。对于未完成的项，修复并更新你的 领英个人资料。勾选所有项后，移到下一部分。有关更多指导，请查看职业资源中心获取更多建议和资源。
领英项目提交在这个项目中，你将站在招聘经理或者人力部门的角度来审视自己的领英个人资料，将着重点放在自己的工作经验，教育背景以及兴趣爱好上，向他人展示你是一个有潜力，有合作力的应聘者。虽然这个项目和其他职业发展项目一样是可选的，但我们推荐所有学员更新自己的领英个人资料，展示你新掌握的技能。
说明：此项目目前仅提供英文审阅服务，你需要用英文完成项目作业。
反馈优达学城项目导师会根据该标准（与你制作领英简介时遵循的清单相符）对你的领英简介项目进行审核。
提交准备好提交领英个人资料后：
1、若要提交，请点击下方的“提交项目”按钮，并根据说明操作。2、在“告知评审员”中，请包括任何有关你的职业目标（如预期工作领域）的详细信息。
注意：我们最多需要一周的时间来对项目进行评分，但多数情况下无需一周。项目评审完成后，你会收到电子邮件。如果你在提交项目时遇到问题，或者想查看提交状态，请发送电子邮件至 support@youdaxue.com。
技术面试项目对于此实战项目，你需要回答五个技术面试问题，这些问题涉及的是技术面试课程中讨论的各种主题。你应该用 Python 写出清晰高效的答案，并用文字解释代码的效率和设计理由。我们将安排合格的审核者检查你的答案，并针对任何精彩之处或欠缺的方面做出反馈：你的解决方案是最高效的吗？你很好地解释了你的想法吗？你的代码简洁易懂吗？
请回答以下问题：
问题 1: 假设有两个字符串 s 和 t，请判断 t 的变形词是否是 s 的子字符串。例如：如果 s = “udacity”，t = “ad”，则函数返回 True。你的函数定义应该为：“question1(s, t)”，并返回布尔值 True 或 False。 
问题 2: 设有字符串 a，请找到 a 中存在的最长回文子字符串。你的函数定义应该类似于“question2(a)”，并返回字符串。 
问题 3: 假设有个无向图 G，请找出 G 中的最小生成树。最小生成树是指连通图表中的所有顶点且边的总权值最小的子图。你的函数应该以邻接表为输入，并返回一个邻接表，表的格式如下：{‘A’:[(‘B’,2)],’B’:[(‘A’,2),(‘C’,5)],’C’:[(‘B’,5)]}。顶点表示为唯一字符串。函数定义应为“question3(G)”。 
问题 4: 请在二分查找树中找到两个节点之间的最近共同祖先。最近共同祖先是指同时为两个节点的祖先且离根最远的节点。例如，根节点是树上所有节点的共同祖先，但是如果两个节点都是根节点左侧子节点的子孙，则该左侧子节点可能是最低共同祖先。你可以假设两个节点都在树中，该树本身遵守的是 BST 规则。函数定义应该为“question4(T, r, n1, n2)”，其中 T 是用矩阵表示的树，列表的索引等于该节点中存储的整数，1 表示子节点，r 是表示根节点的非负整数，n1 和 n2 是表示这两个节点的非负整数，二者没有特定的顺序。例如，一个测试条件可以为 question4([[0,1,0,0,0],[0,0,0,0,0],[0,0,0,0,0],[1,0,0,0,1],[0,0,0,0,0]],3,1,4)，答案应为 3。 
问题 5: 从单链表中找到倒数第 m 个元素。例如，如果单链表中有 5 个元素，则倒数第 3 个元素也是正数地 3 个元素。该函数的定义应为“question5(ll, m)”，其中 ll 是链表中的第一个节点，m 是“倒数第 m 个元素”。你应该复制粘贴下面的 Node 类，并用它来表示链表中的节点。请返回该位置的节点对应的值。
class Node(object):  def __init__(self, data):    self.data = data    self.next = None

技术面试项目提交对于此项目，请回答五个技术面试问题，内容涵盖了技术面试课程中讨论的各种话题。请用 Python 写出简洁高效的答案，并用文字解释下代码的效率和设计理由。我们会安排一位合格的审阅人员检查你的答案，并对其中的亮点或不足之处做出反馈——你的解决方案是效率最高的吗？清晰地解释了自己的思路了吗？你的代码简洁、易于读懂吗？
提交说明1、对于每个问题，请用 Python（版本 2）写出解决方案。所有解决方案的函数名称都应为“question1”、“question1”等等。可以根据需要创建其他辅助函数或类。代码解决方案必须放在称为“solutions.py”的文件内。
2、在同一 .py 文件中，请为每个解决方案提供至少 3 个测试案例。对于每个测试案例，请写出函数调用，输入值为你要测试的内容，并输出到控制台上，例如“print question1()”。在下一行，注释掉你预期会从该函数调用中获得的输出。至少有两个测试案例必须是极端情况，例如输入为 null 值、空输入值、非常大的值等等。
3、在单独的文本文件（称为“explanations.txt”）里写上每个问题的说明。不用详细解释所提供的代码，但是请说明代码中各个决策背后的原因。例如，为何使用该数据结构？同时还需要解释下解决方案的效率（时间效率和空间效率）。
4、将 Python 文件和文本文件压缩为 .zip 文件，然后提交了。
请参阅此处的评估标准！
机器学习模拟面试具体内容看视频。
坚持练习！你在该课程中完成的面试准备练习只是牛刀小试，我们会鼓励你进行更多练习。我们还准备了以下资源列表，可供你进行其他练习。而且如果你还知道其他资源，请不吝告知。并非所有资源都适合你所申请的工作，因此请务必在开始练习前进行调查！
书籍
《程序员面试金典》
《Elements of Programming Interviews》

Web 资源
Project Euler
Matasano 公司的加密挑战赛
编程面试问题列表

在线实践平台
LeetCode
CodeKata
Coderust
Interview Cake
Codewars
HackerRank
职业资源中心

不断练习的过程中，你要尽量全面地模仿真正的面试。例如你应该尝试与朋友一起练习行为问题，而不是一个人闷头练习。还要尝试使用计时方法，以确保给出的答案条理清晰，简明扼要。对于技术问题，你要尝试使用白板或在线文本编辑器，而非 IDE 和编译器进行编码。
现在我们开始面试排练！
面试项目提交雇主通过面试来判断你是否适合这份工作，以及是否已经做好准备。面试不是一场考试，而是你和雇主之间的对话。建立你自己的策略，为面试到来的那一天做好准备吧！
说明：此项目目前仅提供英文审阅服务，你需要用英文完成项目作业。
提交说明1、在下面的招聘网站中，选择一个你想要在毕业后去应聘的职位。

The Udacity Career Network on AfterCollege
FirstJob
R-users
kaggle
Jr.DevJobs
LaunchCode
Whitetruffle
AngelList
HIRED
Dice

2、假装你在接受一场真正的面试，回答下方的面试问题。3、将你的回答保存为 .pdf 或 .txt 格式提交。4、提交时，将你选择的招聘启事的的链接复制粘贴到给审阅者的补充说明（Notes to reviewer）中。
面试问题（共 7 个）想象你在面试中回答以下问题，用你认为适当的两三段话解释和说明你的答案。对于编码答案，请解释你在编写代码时所作的相关选择。
问题 1 – 我们采用 A/B 测试方法测试了我们公司产品页面上两种不同风格的注册按钮。100 名访客访问了 A 页面，其中有 20 名点击了按钮；然而，70 名访客访问了 B 页面，且仅有 15 名点击了按钮。那么你能肯定地说 A 或 B 页面是更好的选择吗？为什么？
问题 2 - 你能否设计一个计划，仅靠观察推文来对 Twitter 用户进行分组？你没有任何可用的人口、地理或其他识别信息，只能利用他们发布的纯文本消息及每条消息的时间戳。
在 JSON 格式中，它们是这样的：
&#123;    "user_id": 3,    "timestamp": "2016-03-22_11-31-20",    "tweet": "It's #dinner-time!"&#125;

假设你收到一些这样的推文流，请描述一下收集和分析它们的过程，你会采用什么转换/算法，你如何训练和测试你的模型及展示结果。
问题 3 - 在分类设置中，给定一个加标签示例数据集及你尝试拟合的机器学习模型，说明检测和防止过拟合的策略。
问题 4 - 你的团队正在为你们的旗舰 3D 建模工具设计下一代用户体验。特别是，你的任务是实现一个智能上下文菜单，它能够学习建模者的菜单选项使用，然后显示最有益的选项。例如，我经常使用“编辑”&gt;“表面”&gt;“光滑表面”（Edit &gt; Surface &gt; Smooth Surface），而我希望只要右击就会出现一个“光滑表面”选项，就像“剪切”、“复制”和“粘贴”一样。注意并不是所有命令在所有上下文下均有意义，例如我需要选择一个表面才对它进行光滑处理。那么，你如何设计一个能够执行这种行为的学习系统/代理。
问题 5 - 通过一个情景举例说明正则化对学习好的模型的必要性，以及提供一个正则化没有意义的情景。
问题 6 -你附近的杂货店想向顾客有针对性地发放对他们来说有用的优惠券。假设你可以访问每位顾客的购买历史和店铺商品目录，你将设计怎样一个系统，来决定发放哪些优惠券？你如何衡量这个系统的性能？
问题 7 - 选择一个公司，然后描述你想应聘的该公司内的机器学习工程师职位（假设有）。现在，如果你已成功应聘，并从今天开始任职，在你看来，你的职位在下一年会有怎样的发展？你的长期职业目标是什么，这个职位如何帮助你实现长期目标？
提交当你准备提交项目，点击下方“提交项目”，上传一份 PDF 文件。如果有任何与提交项目相关的疑问，或想查看提交状态，请向我们发送电子邮件询问（support@youdaxue.com）。
项目资源项目评审标准。优达学城的项目导师会依据此评审标准审阅你的项目。你可以在提交前自行检查自己是否已达到所有标准。职业资源中心。你可以在这里找到更多有关准备面试的资源和贴士。
接下来面试练习并不是只在你求职时才需要做的事情， 在你的整个职业生涯中，你都需要继续提高自己的面试技巧。抓住每一个机会，思考和与人交流你的职业目标。在申请一个职位之前，请思考清楚自己为什么要申请——这将极大地帮助你为面试做好准备。
书签Interview Guide: Machine Learninghttps://career-resource-center.udacity.com/interview-courses-and-guides/machine-learning
职业资源中心 - 简历https://career-resource-center.udacity.com/resume
职业资源中心 - 求职信https://career-resource-center.udacity.com/cover-letters
LinkedIn and GitHub Profileshttps://career-resource-center.udacity.com/linkedin-github-profiles
]]></content>
      <categories>
        <category>专业</category>
        <category>机器学习</category>
        <category>udacity</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>函数式编程之Scheme入门</title>
    <url>/dev-scheme-start/</url>
    <content><![CDATA[前言Lisp是Fortran语言之后第二古老的高级编程语言，自成立之初已发生了很大变化。如今，最广为人知的通用的是Lisp方言：Common Lisp和Scheme。
Common Lisp和Scheme有什么不同呢？个人认为，Common Lisp和Scheme，就像狮子和家犬。狮子更加强大，难以驯服；家犬更加小巧，容易驯服。而选择哪一种，取决于实际需要。鉴于郝同学只是需要学习一下函数式编程的思想，所以Scheme足够了。
PS：MIT 的两本著名教材 SICP（Structure and Interpretation of Computer Programs）和  HTDP（How to Design Programs）都是以Scheme为基础的。


安装mit-scheme1、进入mit-scheme官网，下载对应平台的mit-scheme（下文以windows为例）。
2、安装下载的mit-scheme（下文简称scheme）。
3、双击scheme快捷方式，如果出现如下界面，表明安装成功。
PS：如果打开scheme的时候报错“Requested allocation is too large. Try with smaller argument to –heap”。那么，在程序的快捷方式上右键，属性，在“目标”里加上--heap 512。 
4、把安装路径加入环境变量。例如，我的scheme安装路径为C:\Program Files (x86)\MIT-GNU Scheme，那么，在path中加入C:\Program Files (x86)\MIT-GNU Scheme\bin。同时，新建系统变量MITSCHEME_LIBRARY_PATH，值为C:\Program Files (x86)\MIT-GNU Scheme\lib。
5、测试scheme。打开命令行，输入mit-scheme，弹出如下界面，表明安装配置成功。
6、退出scheme。在scheme命令窗口输入(exit)，选择y，退出scheme命令窗口。
hello world在scheme命令窗口中输入代码非常麻烦，光标不能回退和上下移动，所以比较简单的方法就是运行已经写完的文件。
方法一1、新建hello.scm文件，内容如下：
;The first program(begin    (display "Hello, World!")    (newline))

2、运行hello.scm。mit-scheme -load hello.scm，效果如下：
PS：如果此时报错“Requested allocation is too large. Try with smaller argument to –heap”，那么，修改命令为mit-scheme --heap 128 -load hello.scm。
方法二打开mit-scheme窗口后，(cd &quot;e:\\temp&quot;)，(load &quot;hello.scm&quot;)。
基本语法数据类型Scheme中的简单数据类型包含 boolean（布尔类型），number（数字类型），character（字符类型） 和 symbol（标识符类型）。
复合数据类型是以组合的方式通过组合其它数据类型数据来获得。包括string、vector、dotted pair、list等。
数据类型详解：http://www.kancloud.cn/wizardforcel/teach-yourself-scheme/147165
代码结构函数式编程只用“表达式”，不用“语句”。
“表达式”（expression）是一个单纯的运算过程，总是有返回值；“语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。
原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。”语句”属于对系统的读写操作，所以就被排斥在外。当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。
基本格式：(function_name arg0,arg1,...)
示例：
(display "Hello, World!")(newline)(exit)(number? 42)(eqv? 42 42)(&gt;= 4.5 3)

迄今为止我们提供的Scheme示例程序都是s-表达式。这对所有的Scheme程序来说都适用：程序是数据。
Scheme运行一个列表形式的代码结构时，首先要检测列表第一个元素，或列表头。如果这个列表头是一个过程，则代码结构的其余部分则被当成将传递给这个过程的参数集，而这个过程将接收这些参数并运算。
如果这个代码结构的列表头是一个特殊的代码结构，则将会采用一种特殊的方式来运行。常见的特殊的代码结构有begin， define和 set!。
begin可以让它的子结构可以有序的运算，而最后一个子结构的结果将成为整个代码结构的运行结果。define会声明并会初始化一个变量。set! 可以给已经存在的变量重新赋值。
过程（函数）定义匿名过程我们已经见过了许多系统过程，比如，cons， string-&gt;list等。用户可以使用代码结构lambda来创建自定义的过程。例如，下面定义了一个过程可以在它的参数上加上2：
(lambda (x) (+ x 2))

第一个子结构，(x)，是参数列表。其余的子结构则构成了这个过程执行体。这个过程可以像系统过程一样，通过传递一个参数完成调用：
((lambda (x) (+ x 2)) 5)


一般定义如果我们希望能够多次调用这个相同的过程，我们可以每次使用lambda重新创建一个复制品，但我们有更好的方式。我们可以使用一个变量来承载这个过程：
(define add2  (lambda (x) (+ x 2)))

只要需要，我们就可以反复使用add2为参数加上2：
(add2 4) =&gt;  6(add2 9) =&gt;  11
定义过程还可以有另一种简单的方式，直接用define而不使用lambda来创建：
(define (add2 x)       (+ x 2))

过程的参数lambda 过程的参数由它的第一个子结构（紧跟着lambda标记的那个结构）来定义。add2是一个单参数或一元过程，所以它的参数列表是只有一个元素的列表(x)。标记x作为一个承载过程参数的变量而存在。在过程体中出现的所有x都是指代这个过程的参数。对这个过程体来说x是一个局部变量。
我们可以为两个参数的过程提供两个元素的列表做参数，通常都是为n个参数的过程提供n个元素的列表。下面是一个可以计算矩形面积的双参数过程。它的两个参数分别是矩形的长和宽。
(define area  (lambda (length breadth)    (* length breadth)))
我们看到area将它的参数进行相乘，系统过程*也可以实现相乘。我们可以简单的这样做：
(define area *)

apply过程apply过程允许我们直接传递一个装有参数的list 给一个过程来完成对这个过程的批量操作。
(define x '(1 2 3))(apply + x)

通常，apply需要传递一个过程给它，后面紧接着是不定长参数，但最后一个参数值一定要是list。它会根据最后一个参数和中间其它的参数来构建参数列表。然后返回根据这个参数列表来调用过程得到的结果。例如:
(apply + 1 2 3 x)

顺序执行我们使用begin这个特殊的结构来对一组需要有序执行的子结构来进行打包。许多Scheme的代码结构都隐含了begin。例如，我们定义一个三个参数的过程来输出它们，并用空格间格。一种正确的定义是：
(define display3  (lambda (arg1 arg2 arg3)    (begin      (display arg1)      (display " ")      (display arg2)      (display " ")      (display arg3)      (newline))))
在Scheme中，lambda的语句体都是隐式的begin代码结构。因此，display3语句体中的begin不是必须的，不写时也不会有什么影响。
display3更简化的写法是：
(define display3  (lambda (arg1 arg2 arg3)    (display arg1)    (display " ")    (display arg2)    (display " ")    (display arg3)    (newline)))

条件语句if最基本的结构就是if：
(if 测试条件    then-分支    else-分支)
如果测试条件运算的结果是真(非#f的任何其它值)，then分支将会被运行(即满足条件时的运行分支)。否则，else分支会被运行。else分支是可选的。
(define p 80)(if (&gt; p 70)     'safe    'unsafe)(if (&lt; p 90)    'low-pressure) ;no ``else'' branch

when 和 unless当我们只需要一个基本条件语句分支时（”then”分支或”else”分支），使用when 和 unless会更方便。
(define a 10)(define b 20)(when (&lt; a b)    (display "a是")    (display a)    (display "b是")    (display b)    (display "a小于b" ) )
先判断a是否小于b，这个条件成立时会输出倒序的5条信息。
同样的功能还可以像下面这样用unless来写(unless和when的意思正好相反)：
(define a 10)(define b 20)(unless (&gt;= a b)   (display "a是")   (display a)   (display "b是")   (display b)   (display "a小于b" ) )
并不是所有的Scheme环境都提供when和unless。如果你的Scheme中没有，你可以用宏来自定义出when和unless。
使用if实现相同的程序会是这样：
(define a 10)(define b 20)(if (&lt; a b)    (begin        (display "a是")        (display a)        (display "b是")        (display b)        (display "a小于b" ) ))
先判断a是否小于b，这个条件成立时会输出正序的5条信息。
在mit-scheme下，中文会显示乱码，为方便查看，建议修改成英文。
cond多重if结构为：
(define c #\c)(if (char&lt;? c #\c) -1    (if (char=? c #\c) 0        1))
这样的结构都可以使用cond来这样写：
(cond ((char&lt;? c #\c) -1)    ((char=? c #\c) 0)    (else 1))
cond就是这样的一种多分支条件结构。每个从句都包含一个判断条件和一个相关的操作。第一个判断成立的从句将会引发它相关的操作执行。如果任何一个分支的条件判断都不成立则最后一个else分支将会执行(else分支语句是可选的)。
cond的分支操作都是begin结构。
case当cond结构的每个测试条件是一个测试条件的分支条件时，可以缩减为一个case表达式。
(define c #\c)(case c    ((#\a) 1)    ((#\b) 2)    ((#\c) 3)    (else 4))
分支头值是#\c 的分支将被执行。
and 和 orScheme提供了对boolean值进行逻辑与and和逻辑或or运算的结构。(我们已经见过了布尔类型的求反运算not过程。)
当所有子结构的值都是真时，and的返回值是真，实际上，and的运行结果是最后一个子结构的值。如果任何一个子结构的值都是假，则返回#f。
(and 1 2)  =&gt;  2(and #f 1) =&gt;  #f
而or会返回它第一个为值为真的子结构的结果。如果所有的子结构的值都为假，or则返回#f。
(or 1 2)  =&gt;  1(or #f 1) =&gt;  1
and和or都是从左向右运算。当某个子结构可以决定最终结果时，and和or会忽略剩余的子结构，即它们是“短路”的。
(and 1 #f expression-guaranteed-to-cause-error)(or 1 #f expression-guaranteed-to-cause-error)

词法变量Scheme的变量有一定的词法作用域，即它们在程序代码中只对特定范围的代码结构可见。
(define x 9)(define add2 (lambda (x) (+ x 2)))(add2 3)(add2 x)
这里有一个全局变量x，值一直为9；还有一个局部变量x，就是在过程add2中那个字母x。
而set!代码结构可修改变量的赋值。
(set! x 20)
上面代码将全局变量x的值9修改为20，因为对于set!全局变量是可见的。如果set!是在add2过程体内被调用，那修改的就是局部变量x：
(define add2  (lambda (x)    (set! x (+ x 2))    x))
这里set!在局部变量x上加上2，并且会返回局部变量x的新值。(从结果来看，我们无法区分这个过程和先前的add2过程)。
(define counter 0)(define bump-counter  (lambda ()    (set! counter (+ counter 1))    counter))
bump-counter是一个没有参数的过程(没有参数的过程也称作thunk)。 它没有引入局部变量和参数，这样就不会隐藏任何值。在每次调用时，它会修改全局变量counter的值，让它增加1，然后返回它当前的值。下面是一些bump-counter的成功调用示例:
(bump-counter) =&gt;  1(bump-counter) =&gt;  2(bump-counter) =&gt;  3

let 和 let*并不是一定要显式的创建过程才可以创建局部变量。有个特殊的代码结构let可以创建一列局部变量以便在其结构体中使用:
(let ((x 1)      (y 2)      (z 3))    (list x y z))=&gt;  (1 2 3)
和lambda一样，在let结构体中，局部变量x（赋值为1）会暂时隐藏全局变量x（赋值为20）。
局部变量x、y、z分别被赋值为1、2、3，这个初始化的过程并不作为let过程结构体的一部分。因此，在初始化时对x的引用都指向了全局变量x，而不是局部变量x。
(let ((x 1)      (y x))  (+ x y))=&gt;  21

在初始化区域中，可以用先创建的变量来为后创建的变量赋值，let*结构就可以这样做：
(let* ((x 1)       (y x))  (+ x y))=&gt;  2

这个例子完全等价于下面这个let嵌套的程序，更深了说，实际上就是let嵌套的缩写。
(let ((x 1))  (let ((y x))    (+ x y)))=&gt;  2

我们也可以把一个过程做为值赋给变量：
(let ((cons (lambda (x y) (+ x y))))  (cons 1 2))=&gt;  3
在这个let构结体中，变量cons将它的参数进行相加。而在let结构的外面，cons还是用来创建点对。
fluid-let一个词法变量如果没有被隐藏，在它的作用域内一直都为可见状态。有时候，我们有必要将一个词法变量临时的设置为一个固定的值，为此我们可使用fluid-let结构。
(fluid-let ((counter 99))  (display (bump-counter)) (newline)  (display (bump-counter)) (newline)  (display (bump-counter)) (newline))

这和let看起来非常相像，但并不是暂时的隐藏了全局变量counter的值，而是在fluid-let执行体中临时的将全局变量counter的值设置为了99直到执行体结束。因此执行体中的三句display产生了结果
100 101 102

当fluid-let表达式计算结束后，全局变量counter会恢复成之前的的值。
注意fluid-let和let的效果完全不同。fluid-let不会和let一样产生一个新的变量。它会修改已经存的变量的值绑定，当fluid-let结束时这个修改也会结束。
递归一个过程体中可以包含对其它过程的调用，特别的是也可以调用自己。
(define factorial (lambda (n)    (if (= n 0) 1        (* n (factorial (- n 1))))))
这个递归过程用来计算一个数的阶乘。如果这个数是0，则结果为1。对于任何其它的值n，这个过程会调用其自身来完成n-1阶乘的计算，然后将这个子结果乘上n并返回最终产生的结果。
互递归过程也是可以的。下面判断奇偶数的过程相互进行了调用。
(define is-even? (lambda (n)    (if (= n 0) #t        (is-odd? (- n 1)))))(define is-odd? (lambda (n)    (if (= n 0) #f        (is-even? (- n 1)))))
这里提供的两个过程的定义仅作为简单的互递归示例。Scheme已经提供了简单的判断过程even?和odd?。
letrec如果希望将上面的过程定义为局部的，我们需要使用letrec结构。
(letrec ((local-even? (lambda (n)                        (if (= n 0) #t                            (local-odd? (- n 1)))))         (local-odd? (lambda (n)                       (if (= n 0) #f                           (local-even? (- n 1)))))) (list (local-even? 23) (local-odd? 23)))
用letrec创建的词法变量不仅可以在letrec执行体中可见而且在初始化中也可见。letrec是专门为局部的递归和互递归过程而设置的。(这里也可以使用define来创建两个子结构的方式来实现局部递归)
命名let使用letrec定义递归过程可以实现循环。如果我们想显示10到1的降数列，可以这样写：
(letrec ((countdown (lambda (i)                      (if (= i 0) 'liftoff                          (begin                            (display i)                            (newline)                            (countdown (- i 1))))))) (countdown 10))
这会在控制台上输出10到1，并会返回结果liftoff。
Scheme允许使用一种叫“命名let”的let变体来更简洁的写出这样的循环:
(let countdown ((i 10)) (if (= i 0) 'liftoff      (begin        (display i)        (newline)        (countdown (- i 1)))))
注意在let的后面立即声明了一个变量用来表示这个循环。这个程序和先前用letrec写的程序是等价的，可以将“命名let”看成一个对letrec结构进行扩展的宏。
迭代上面定义的countdown函数事实上是一个递归的过程。Scheme只有通过递归才能定义循环，不存在特殊的循环或迭代结构。
尽管如此，上述定义的循环是一个“真”循环，与其他语言实现它们的循环的方法完全相同。也就是说，Scheme十分注意确保上面使用过的递归类型不会产生过程调用/返回开销。
Scheme通过一种消除尾部调用（tail-call elimination）的过程完成这个功能。如果你注意观察countdown的步骤，你会注意到当递归调用出现在countdown主体内时，就变成了“尾部调用”，或者说是最后完成的事情——countdown的每次调用要么不调用它自身，要么当它调用自身时把这个动作留在最后。对于一个Scheme语言的实现来说（解释器），这会使递归不同于迭代。因此，尽管用递归去写循环吧，这是安全的。
这是又一个有用的尾递归程序的例子：
(define list-position  (lambda (o l)    (let loop ((i 0) (l l))      (if (null? l) #f          (if (eqv? (car l) o) i              (loop (+ i 1) (cdr l)))))))

list-position发现了o对象在列表l中第一次出现的索引。如果在列表中没有发现对象，过程将会返回#f。
这又是一个尾部递归过程，它将自身的参数列表就地反转，也就是使现有的列表内容产生变异，而没有分配一个新的列表：
(define reverse!  (lambda (s)    (let loop ((s s) (r '()))      (if (null? s) r      (let ((d (cdr s)))            (set-cdr! s r)        (loop d s))))))
reverse!是一个十分有用的过程，它在很多Scheme方言中都能使用。
用自定义过程映射整个列表有一种特殊类型的迭代，对列表中每个元素，它都会重复相同的动作。Scheme为这种情况提供了两种程序：map和for-each。
map程序为给定列表中的每个元素提供了一种既定程序，并返回一个结果的列表。例如：
(map add2 '(1 2 3))=&gt;  (3 4 5)

for-each程序也为列表中的每个元素提供了一个程序，但返回值为空。
(for-each display  (list "one " "two " "buckle my shoe"))

这个由map和for-each用在列表上的程序并不一定是单参数程序。举例来说，假设一个n参数的程序，map会接受n个列表，每个列表都是由一个参数所组成的集合，而map会从每个列表中取相应元素提供给程序。例如：
(map cons '(1 2 3) '(10 20 30))=&gt;  ((1 . 10) (2 . 20) (3 . 30))(map + '(1 2 3) '(10 20 30))=&gt;  (11 22 33)

输入输出Scheme的输入/输出程序，可以从输入端口读取或者写入到输出端口。端口可以关联到控制台，文件和字符串。
读取Scheme的读取程序带有一个可选的输入端口参数。如果端口没有特别指定，则默认为当前端口（一般是控制台）。
读取的内容可以是一个字符，一行数据或是S表达式。当每次执行读取时，端口的状态就会改变，因此下一次就会读取当前已读取内容后面的内容。如果没有更多的内容可读，读取程序将返回一个特殊的数据（文件结束符或EOF对象），这个对象只能用eof-object?函数来判断。
read-char程序会从端口读取下一个字符。read-line程序会读取下一行数据，并返回一个字符串（不包括最后的换行符），read程序则会读取下一个S表达式。
写入Scheme的写入程序接受一个要被写入的对象和一个可选的输出端口参数。如果未指定端口，则默认为当前端口（一般为控制台）。
写入的对象可以是字符或是S表达式。
write-char程序可以向输出端口写入一个给定的字符（不包括#\）。write和display程序都可以向端口写入一个给定的S表达式，唯一的区别是：write程序会使用机器可读型的格式而display程序却不用。例如，write用双引号表示字符串，用#\句法表示字符，但display却不这么做。
newline程序会在输出端口输出一个换行符。
文件端口如果端口是标准的输入和输出端口，Scheme的I/O程序就不需要端口参数。但是，如果你明确需要这些端口，则current-input-port和current-output-port这些零参数程序会提供这个功能，例如：
(display 9)(display 9 (current-output-port))
拥有相同的效果。
一个端口通过打开文件和这个文件关联在一起。open-input-file程序会接受一个文件名作为参数，并返回一个和这个文件关联的新的输入端口。open-output-file程序会接受一个文件名作为参数，并返回一个和这个文件关联的新的输出端口。如果打开一个不存在的输入文件，或者打开一个已经存在的输出文件，程序都会出错。
已经在一个端口执行完输入或输出后，需要使用close-input-port或close-output-port程序将它关闭。
在下述例子中，假如文件io.txt文件只包含一个单词hello。
(define i (open-input-file "io.txt"))(read-char i)(define j (read i))j

假如文件greeting.txt在下述程序运行前不存在：
(define o (open-output-file "greeting.txt"))(display "hello" o)(write-char #\space o)(display 'world o)(newline o)(close-output-port o)
现在greeting.txt文件将会包含“hello world”。
文件端口的自动打开和关闭
Scheme提供了call-with-input-file和call-with-output-file过程，这些过程会照顾好打开的端口并在你使用完后将端口关闭。
call-with-input-file程序接受一个文件名参数和一个过程。这个过程被应用在一个已打开的文件输入端口。当程序结束时，它的结果会在保证端口关闭后返回。
(call-with-input-file "io.txt"  (lambda (i)    (let* ((a (read-char i))           (b (read-char i))           (c (read-char i)))      (list a b c))))=&gt;  (#\h #\e #\l)
call-with-output-file程序会对输出文件提供类似的服务。
字符串端口一般来说将字符串与端口相关联是很方便的。因此，open-input-string程序将一个给定的字符串和一个端口关联起来。读取这个端口的程序将读出下述字符串：
(define i (open-input-string "hello world"))(read-char i)=&gt;  #\h(read i)=&gt;  ello(read i)=&gt;  world
open-output-string创建了一个输出端口，最终可以用于创建一个字符串：
(define o (open-output-string))(write 'hello o)(write-char #\, o)(display " " o)(display "world" o)
现在你可以使用get-output-string程序得到保留在字符串端口o中的字符串：
(get-output-string o)=&gt;  "hello, world"
字符串端口不需要显式地去关闭。
加载文件load程序可以加载包含Scheme代码的文件，load一个文件意味着按顺序求值文件中每一个Scheme表达式。load中的路径参数是相对当前Scheme工作目录计算的，该工作目录一般是调用Scheme可执行文件时的目录。
一个文件可以加载其他的文件，这在包含许多文件的大项目中十分有用。但是，除非使用绝对路径，否则load参数中的文件位置将依赖于执行Scheme的当前目录。而提供绝对路径名并不是很方便，因为我们更愿意把项目文件作为一个单元（保留它们的相对路径名）在很多不同机器中运行。
宏在Scheme中，对宏的处理与C语言类似，也分为两步：第一步是宏展开，第二步则是编译展开之后的代码。这样，通过宏和基本的语言构造，可以对Scheme语言进行扩展——C语言的宏则不具备扩展语言的能力。
宏通过define-macro来定义。例如，如果你的Scheme缺少条件表达式when，你就可以以下述宏定义when：
(define-macro when  (lambda (test . branch)    (list 'if test      (cons 'begin branch))))
这样定义的when转换器能够把一个when表达式转换为等价的if表达式。
(when (&lt; (pressure tube) 60)   (open-valve tube)   (attach floor-pump tube)   (depress floor-pump 5)   (detach floor-pump tube)   (close-valve tube))
上面的when表达式，在宏展开后为：
(apply  (lambda (test . branch)    (list 'if test      (cons 'begin branch)))  '((&lt; (pressure tube) 60)      (open-valve tube)      (attach floor-pump tube)      (depress floor-pump 5)      (detach floor-pump tube)      (close-valve tube)))

这个转换产生了一个列表：
(if (&lt; (pressure tube) 60)    (begin      (open-valve tube)      (attach floor-pump tube)      (depress floor-pump 5)      (detach floor-pump tube)      (close-valve tube)))

Scheme将会对这个表达式进行求值，就像它对其他表达式所做的一样。
再来看unless的宏定义：
(define-macro unless  (lambda (test . branch)    (list 'if          (list 'not test)          (cons 'begin branch))))

另外，我们可以调用when放进unless定义中：
(define-macro unless  (lambda (test . branch)    (cons 'when          (cons (list 'not test) branch))))
宏表达式可以引用其他的宏。
结构我们可以使用Scheme提供的复合数据结构（如向量和列表），来表示一种“结构”。例如：我们正在处理与树木相关的一组数据。数据中的元素包括：高度，周长，年龄，树叶形状和树叶颜色共5个字段。这样的数据可以表示为5元向量，这些字段可以利用vector-ref访问，或使用vector-set!修改。
我们使用Scheme的宏defstruct去定义一个结构，基本上你可以把它当作一种向量，不过它提供了很多方法诸如创建结构实例、访问或修改它的字段等等。因此，我们的树结构应这样定义：
(defstruct tree height girth age leaf-shape leaf-color)
这样它自动生成了一个名为make-tree的构造过程，以及每个字段的访问方法，命名为tree.height，tree.girth等等。构造方法的使用方法如下：
(define coconut   (make-tree 'height 30             'leaf-shape 'frond             'age 5))
这个构造函数的参数以成对的形式出现，字段名后面紧跟着其初始值。这些字段能以任意顺序出现，或者不出现——如果字段的值没有定义的话。
访问过程的调用如下所示：
(tree.height coconut) =&gt;  30(tree.leaf-shape coconut) =&gt;  frond(tree.girth coconut) =&gt;  &lt;undefined&gt;
tree.girth存取程序返回一个未定义的值，因为我们没有为coconut这个tree结构指定girth的值。
修改过程的调用如下所示：
(set!tree.height coconut 40)(set!tree.girth coconut 10)
如果我们现在重新调用访问过程去访问这些字段，我们会得到新的值：
(tree.height coconut) =&gt;  40(tree.girth coconut) =&gt;  10

默认初始化我们可以在定义结构时进行一些初始化的设置，而不是在每个实例中都进行初始化。因此，我们假定leaf-shape和leaf-color在默认情况下分别为frond和green。我们可以在调用make-tree时通过显式的初始化来覆盖掉这些默认值，或者在创建一个结构实例后使用上面提到的字段修改过程：
(defstruct tree height girth age                (leaf-shape 'frond)                (leaf-color 'green))(define palm (make-tree 'height 60))(tree.height palm) =&gt;  60(tree.leaf-shape palm) =&gt;  frond(define plantain   (make-tree 'height 7             'leaf-shape 'sheet))(tree.height plantain) =&gt;  7(tree.leaf-shape plantain) =&gt;  sheet(tree.leaf-color plantain) =&gt;  green

关联表关联表是Scheme一种特殊形式的列表。列表的每一个元素都是一个点对，其中的car（左边的元素）被称为键，cdr（右边的元素）被称为和该键关联的值。例如：
((a . 1) (b . 2) (c . 3))

系统接口Scheme程序经常需要与底层操作系统进行交互。
检查和删除文件file-exists?会检查它的参数字符串是否是一个文件。delete-file接受一个文件名字符串作为参数并删除相应的文件。这些程序并不是Scheme标准的一部分，但是在大多数Scheme实现中都能找到它们。用这些过程操作目录（而不是文件）并不是很可靠，操作结果与具体的Scheme实现有关。
file-or-directory-modify-seconds过程接受一个文件名或目录名为参数，并返回这个目录或文件的最后修改时间。时间是从格林威治标准时间1970年1月1日0点开始记时的。例如：
(file-or-directory-modify-seconds "hello.scm")=&gt;  893189629
假定hello.scm文件最后一次修改的时间是1998年4月21日的某个时间。
调用操作系统命令system函数把它的参数字符串当作操作系统命令来执行。如果命令成功执行并返回0，则它会返回真，如果命令执行失败并返回某非0值，则它会返回假。命令产生的任何输出都会进入标准的输出。
(system "ls");lists current directory(define fname "spot")(system (string-append "test -f " fname)) ;tests if file `spot' exists(system (string-append "rm -f " fname)) ;removes `spot'
最后两个命令等价于：
(file-exists? fname)(delete-file fname)

环境变量过程getenv返回操作系统环境变量的设定值，如：
(getenv "HOME")=&gt;  "/home/dorai"(getenv "SHELL")=&gt;  "/bin/bash"


对象和类http://www.kancloud.cn/wizardforcel/teach-yourself-scheme/147175
源码分享https://github.com/voidking/scheme-start.git
书签函数式编程初探
函数式编程入门教程
Lisp教程
Scheme语言简明教程
MIT/GNU Scheme Documentation
Racket官网
符号: 抽象、语义
编程语言的基石——Lambda calculus
]]></content>
      <categories>
        <category>专业</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
        <tag>形式语义学</tag>
        <tag>lisp</tag>
        <tag>scheme</tag>
      </tags>
  </entry>
  <entry>
    <title>英语学习方法</title>
    <url>/en-learning-method-of-english/</url>
    <content><![CDATA[理论磨刀不误砍柴工，了解一下英语学习的理论，能够少走一些弯路，找到自己应该坚持的方向。
赖世雄说英语讲得非常棒、非常流利是英语学习者的一个梦想。有人说，学英语就一定要在英语系国家住个三五年，赖世雄告诉你这个是完全不对的。比如在国外生活了很多年的华侨，英语流利度仍然不够，还有很多人从来没出过国，但是他们的英语讲得非常流利。口语是一个人的门面，口语是沟通的桥梁，所以学英语的第一步是学说，先有语言后才有文字。


1、会话法。用正确的声音源（地道老外讲的话）把资料书的内容完全消化，然后丢开书，自己一个人分裂练习多个角色，反复操练。用回忆，尽量不要看书，很流利之后可以自己造句，直至内容完全吸收。
2、描述法，随身携带很小的汉英字典。见到什么就描述什么，不会的单词就查（不用英汉字典，因为汉字不会说的时候查汉英字典更方便）
3、翻译法，口语翻译，比如看电视的时候，听见任何对白都给它翻译成英文，将任何进入大脑的中文都翻译成英文。不会的马上查。学校开会很无聊，把老师和校长的讲话都翻译成英文。
视频链接：https://pan.baidu.com/s/1osQw7w2_u8ZQn6LVAYS7uA 密码：d0du
英语思维篇简单的说，用英语思维，就是看你能否用英语来理解英语。要达到英文思维的水平，最起码的，就是像中国人读中文一样：一段话从前看到后，就读懂了。（当然，我指通俗读物中的文字，过于弯弯绕的，中文也未必能一眼读懂）不需要从英文翻译到中文，从中文翻译到汉语拼音，更不需要翻译到一幅幅图片，你就是读懂了。
为什么大多数人始终没有培养出英语思维？原因一：很多人背单词的时候，只顾着背英文词汇与中文释义之间的一一对应关系，这是绝大多数人学不好英文的根本原因之一。
解决办法：果断抛弃英汉词典，只用英英字典。你学习justify这个词，看到的释义是这样：

To justify a decision, action, or idea means to show or prove that it is reasonable or necessary.

再看到justify，你不会想到“使…合理化”，也未必能把这整句柯林斯释义复述出来，但是拿把枪顶你脑门上逼你解释的话，你一定会联想到decision, prove, reasonable, necessary 这些关键词。够了！当你能够用简单的英语单词来关联复杂的英语单词，在你的脑中，英语词汇就不再是一个单词绑上一个释义这样几千个孤立的知识点，而是能够构成网络和体系，就像中文对你而言一样。真的不用担心你没法一字一句把释义记下来，就像我问你中文“逻辑”是什么意思，“抽象”是什么意思，你能给出准确解释么，你当然不能，你又不是人肉字典。
原因二：不敢脱离翻译去看原文，一旦没有翻译，就哭着喊着臣妾做不到啊。结果，就是你永远把英语当成一门学问在学，而无法当作一个技能在用。很多人会说，我也想用啊，我想先学好了再用。正是这样的想法，导致无数人学了十几年英语，依然只知道读新概念，还要单词从A背到C，再从A背到C，再从A背到C……
你知道问题在哪里么？因为“学”和“用”之间，本就没有一条黑白分明的界限，不是说你花100天去专心学习，到了101天，啊，见证奇迹的时刻，你突然可以开始用了。
大家都学过中文，有谁是把几万个汉字和成语都先掌握了，再去看书读报的？会开车的话，谁又是把车技练得跟舒马赫一样再上路的？学英文难道不是一个道理么，如果你已经熟悉了三四千个单词，那么你就应该大胆开始阅读原文，并且果断抛弃中文译文。你以为自己在双语阅读的时候，根本就是在汉语阅读而已嘛。
除非是关系你饭碗或者生命的阅读材料，否则不用怕读不懂，不用怕理解错，你想象一下自己小时候是怎么一点点学会看中文书的，不也是从连蒙带猜开始的么；但是你读了几十几百篇，自然就读出了感觉，读出了自信，是不是这个道理？说到底，英语思维，或者用英语思考和理解，本身不是什么大不了的事情，一个愿意付出努力和坚持，并且方法得当的语言学习者，经过一段时间的训练就能达到这样的水平。
解决办法：连蒙带猜地读，大量的读。
克拉申说“会用任何语言流利交流的前提是必须能用这种语言思考，做不到的就永远不能正常交流。”这是结论，没有英文思维，永远也听不懂正常速度的英文，永远也听不了长句子。
模仿儿童学习语言的方式：猜测–形成条件反射–建立语言区–实现语言思维。成人学习语言的过程：学习–记忆–记忆区–知识。
克拉申创立的S.L.A.（Second Language Acquisition）：简单来说，语言的掌握，无论是第一语言还是第二语言，都是在“可理解的”真实语句发生（即我们前面探讨的有效的声音，也就是可以懂意思的外语）下实现的；都是在放松的不反感的条件下接受的；它不需要“有意识地”学习，训练和使用语法知识；它不能一夜速成，开始时会比较慢，说的能力比听的能力实现得晚。所以最好的方法就是针对以上语言实现的特点来设计的。他的理论由以下五大支柱组成，被他称为五个“假说”。五个假说不分先后，但分量不同。
1）习得-学得差异假设（The Acquisition-Learning Hy-pothesis）2）监检假设（The Monitor Hypothesis）3）输入假设（The Input Hypothesis）4）情感过滤假设（The Affective Filter Hypothesis）5）自然顺序假设（The Natural Order Hypothesis） 
沉默期有一个非常重要的“沉默期”(Silent period)的概念，克拉申认为，无论成人或儿童，在掌握说话能力前，都会有一个相当长的沉默期，直到听懂的量达到一定程度而有足够的自信时，才可能说话。这一沉默期是正常的同时也是必要的。所以大家不要急着上来就想说，说的能力要来得慢，同时它是自然到来的。
“先听说，不读写”这是一个外国语言学家不太讨论（因为对他们来说是常识）而中国同学却常常误解问题，即听说读写之间的关系。对于中国同学来说，认为这四个方面的区别比较明显，而且我们常常把“听说”归在一类，把“读写”归在一类。这和中文的特殊性有关。中文的“听、说、读、写”是分家的，大家会“听说”交流后，并不会认字，要去“学习”认字。因为中国的汉字确实是需要通过“学习”的方法掌握，也就是主要用记忆的方法。不学习，汉字是无法掌握的。而英文，和许多其他的拼音文字一样，读音和文字是紧密相连的。会了“听说”，只要掌握了读音规律，拼写自然就会了。所以严格来讲，外国小孩上学不学习“认字”，而是学“拼音规律”。英文叫做Phonics。
我们已经明确了“建立英文思维主要是建立英文声音的思维”这个概念，结合“二语悉得”的理论，再根据母语掌握的规律，可以先明确这一理念：“先听说，后读写。”大家笑了，就这呀！早就听过这个老生常谈了，而且知道母语学习都是这个顺序。其实很多人并不真正明白它的含义，也不照着做。它的实际含义是叫你在你学会“听说”之前，不要急着学“读写”。所以本人说得过分一点，把它称为：“先听说，不读写”。到高阶段再说。我把著名语言学家保罗•比斯勒博士(Pimsleur)的关于“阅读”应实现于“听说”的语言能力掌握之后的论述给大家参考：“Reading has been defined as “decoding the graphicmaterial to the phonemic patterns of spoken language which have already been mastered when reading is begun.” To put it another way, reading consists of coming back to speech through the graphics symbols. In short, meanings reside in the sounds of the spoken language. Speaking a language is the necessary first step to acquiring the ability to read a language with meaning. ——Paul Pimsleur”
对大多数中国同学而言，主动回避“文字”更十分必要。因为大多数中国同学，只要上到大学程度的，多半是“视觉学习型”（Visual Learning Style）。而“听觉学习型”(Audio Learning Style)和“动作学习型” (Kinesthetic Learning Style)的同学，一般会被我国这种教育体制淘汰掉。“视觉学习型”的同学，建立英语思维时，很容易受到“文字”的干扰，忍不住看文字，甚至先想一下文字，再过度到含义。成了“声音”—“字型”—“含义”的路线。应该避免想到字型，直接将“声音”和“含义”建立联系。
“听”的原则和方法：1）千万不要着急学文字，语言掌握的关键是解决“声音”。2）不依赖语法知识和中文翻译，重点是“猜测”着听。3）在后期能听懂简单段落和简单对话时，可以模仿和重复一些句子并尝试自己说。4）最后，可以开始阅读一些与听到的对话有关的文字。注意一定要在听之后才能读，千万不能一发现听不懂马上去翻看文字来帮忙。 
背单词方法原则：建立连接，加强连接。
1、多维，可以背单词，可以背句子，可以听ESLPod，可以阅读，不排斥任何一种记忆方法。2、重复，按照艾宾浩斯遗忘曲线也好，按照早晚也好，按照循环也好，一定要重复。3、欧陆词典法，使用分类词典，闭目听选，三秒过一个单词。4、联想法，同类词 实物 拆词 近义词 反义词 父词 解释 造句。5、英英记忆法，使用英文解释英文单词。
心态对于说英语，像玩游戏一样放松，一样自信，脸皮要厚，不要怕犯错。英语是交流的工具，能听懂别人说什么，能表达出自己的思想，这才是目的。把关注点放在倾听，放在表达，而不是语法错误和词法错误。交流不是考试，有错误又怎样？别人能听明白就够了！
私人剧本法Benny Lewis创立了一种神奇的口语速成法，叫做私人剧本法。私人剧本法的核心理念是，任何有效的口语速成训练法，一定要从“与我相关”的剧本开始。想学一门新外语，就要从第一天开口。学习任何一门新外语，第一周就要制作与我密切相关的私人剧本，目的是说自己内心想要表达的话。用一个方法就可以理解私人剧本的意思，就是如果你内心渴望用中文和别人说什么，你就尽量写出英文相应的剧本。
听说听写听写，or听抄，顾名思义，就是一边放听力段子，一边写下听到的内容。听写并非考验诸位的记忆，所以放完一句，暂停掉，写下你能够听到的每一个词的全拼，如果不能听出来所有内容，就重新放一遍刚才这一句话，再听不出来就再放一遍，以此循环往复直到完整写下原文，然后再放下一句。当然，如果5遍以上还是听不出来，直接看原文，不要继续纠结了，我们的学习过程要遵循人性啊。那么5遍还没有听出来是什么原因呢？有生词？那么查之。有语音现象导致认识的词也听不出来？那说明还没有练到火候啊。语速过快？那么先从比较慢的材料开始吧。一步一步训练耳朵的熟悉度，然后再换比较快的材料。
听读一篇新的听力材料，头2、3遍一定要从头到尾连贯着听，不要逐字逐句听，这个时候不求听懂绝大部分内容，而只求听懂一个大概。这样2、3遍连贯着听下来，哪怕你只懂了几个单词，也没关系，这在听力的新手来说完全正常，根本不必责难自己（哪怕你觉得自己阅读理解的水平已经达到了《新概念》第四册都已经学完的水平、但从没练过听力）。
第二步，逐字逐句听。一开始，把一个比较长的句子一次全部听下来，可能会有困难：听到句尾，早就已经忘了开头说什么了。逐字逐句听的时候，可以把一句话拆成几个部分来听，听完一小部分，立刻口头重复，说一遍。
第二步中，遇到难点要来回多听几遍，力求听懂。但如果某一句话或句子的某1、2个单词听了4、5遍还没听出来，那就先放一放，往下听。后面的内容常常会为前面的内容提供解释。
一篇听力练习，你能听明白90%-95%的意思，就行了。这不是“不求甚解”，而是力求高效地利用时间，更重要的是保持自己学习英语的兴趣和热情。
影子跟读法影子跟读法的核心在于跟读native的对话，不纠结于一词一句的发音对错，不要打断录音，也就是不要按暂停键，强迫自己跟上native的节奏和思维，最后达到能够下意识的做出回答，绕过中文思考-英文说出的弯弯。
外语学习最重要的目的就是进行“有效的沟通”。
影子跟读所谓影子跟读，指的是跟读者滞后一小段时间，像影子一样在源语后面进行复述。具体操作就是：当源语在读第二或者第三个单词时，跟读者开始跟读第一个单词，并尽量保证使用与源语完全相同的语速、语调、语气甚至音色。影子跟读最大的妙处在于其使得语言在跟读者脑中形成了一个“闭环”：先听源语，有时还可以看着原文，在跟读动作开始前，这是一个源语输入的过程；开始跟读时，跟读者其实是借助刚刚听到和现在看到的（如果看原文）源语进行输出；当跟读者听到自己的跟读时，会对准确度和流畅度甚至还原度进行判断，这是再次输入。因此，影子跟读并非简单意义上的模仿，而是一个非常复杂的语言习得过程。其相比于普通意义上逐句跟读的好处是，由于跟读时离源语输入的时间尚短，对于语调和发音的还原将更加准确，即使不准确，也更易发觉并纠正。一篇文章至少跟读50遍！50遍！ 大家在做影子跟读的时候，最大的困难就是跟不上，此时，可借助电脑中的各种播放器的变速功能进行练习，比如Windows系统自带的MediaPlayer就在高级选项中有播放速度设定，不同水平的跟读者可以根据自己的具体情况来选择0.5-1.0甚至更高倍速来播放要跟读的音频。而到后期用原速跟读毫无压力时，则可以开启加强模式，加快音频速度进行跟读。
教程链接: http://pan.baidu.com/s/1sljF5al 密码: jxkx
在条件不允许大声跟读的情况下，可以在心中跟读。
句子读法“三剑客”那么如何去练习句子的发音呢？给大家介绍句子读法“三剑客”：连读、失去爆破、弱读。比如，on it不应读成【on】【It】，而应读成【o】【nI】【t】，同样，first time中的两个【t】应读成一个【t】；美国总统奥巴马在2008年芝加哥获胜演说中读“must be”中的【t】不读出声，读“could be”中的【d】彻底消失。因此，与其将大量精力浪费在一个孤立的音标上，倒不如学习如何读好句子，毕竟这才是根本。
发声和气息气为声之本，气乃音之帅。气息是我们发声的根源，掌握良好的气息运用方式，不但说话不累，而且可以美化音色，强身健体。

关键：肚子有两个方向，正面和侧面。吸气时，两个方向都应该被打开。而当你唱歌/读书的时候，腰的前后方向应该是收缩的，但是侧面别动，用肌肉撑住。

1、最简单易上手的训练方式，其实就是“读报纸”，用你心中觉得是播音员的方式来大声朗读（关键是大声，但不是吼叫），尽量把每个字的发音发清楚发完整。每天十分钟到半小时，三个月后发声和之前完全不一样了。咬字方面要活动开脸部肌肉，最大限度打开牙关，多张大嘴巴，下巴放松，嘴唇和舌头咬保持有力。
2、腹式呼吸训练。

在刚开始练习的时候要慢吸慢吐就像在闻花香，喉咙只是一个运送气息的管道而不是着力点，说话、唱歌时的发力点是小腹，通过小腹的支撑下，喉咙应该是放松的。
在播音发声时，气息会吸到丹田处，小腹微微紧张，把吸到丹田的气拖住。出声时，两肋和小腹形成一个“皮球”，慢慢的把气控制着放出来。
后仰三十度，小腹紧张，感觉小腹处支撑住你的气息，发出yia的音。你要感觉到声音是从丹田处出来，而不是扯嗓子。这种强控制练习提升是最快的。
打嘟嘟（唇颤音），通过打哈欠和发笑的感觉去发声。

背诵新东方有个学员现在在Duke大学，他从高一开始背《新概念英语》第三册，背到高三就背完了。高考考进了北大，进北大后，他本来不想再背了。但当他背给同学听的时候，其他同学都露出了羡慕的眼光，于是，为了这种虚荣心，他就坚持背第四册，把第三、四册都背得滚瓜烂熟，他熟到什么地步呢，有人把其中任何一句说出来，把能把上一句和下一句连接下去，而且语音非常标准，因为他是模仿着磁带来背的。后来他去了美国Duke大学，他给新东方的教师写信，老师不敢回，因为老师对他的英文有畏惧感，他的英文学得太好，只能给他回中文信，并告诉他不是不会写英文，而是想让他温习温习中文，不要忘记祖国的语言。这位学员到美国第一个星期写文章，教授把他叫过去说他的文章是剽窃的，因为他的文章写得太好了，教授说：“我20年教书没有教出这么漂亮的文章来。“这个学员说，我没有办法证明我能写出这么优秀的文章，但我告诉你，我能背108篇文章，而且背得非常熟练，你想不想听。结果，他没有背完两篇，教授就哭了起来，为什么？因为这个教授想一想自己教了20年了，居然一篇文章也没有背过，被中国学生背掉了，所以很难过……　 

学习英语唯一的正轨，不出仿效与熟诵；仿效即整句的仿效，熟诵则仿效之后必回环练习，必使能顺口而出而后已。凡能依这方法读英文的，无不成功，而且这极容易，真是学习英语的康庄大道。——林语堂

熟读成诵，每次背诵三句话，直到脱口而出。

所背的课文要典型而纯。
理解而后能背。
先听后背。
从易到难，从短到长，循序渐进。
一天之计在于晨。
注意重点句型和单词。
及时复习，多多重复。
尽量尝试不同语调，在不同环境和条件下重复。

对话1、模仿对话材料选择EnglishPod，模仿会话中的角色，进行英语对话。
2、自我对话听完某条VOA新闻后，自己和自己把这个新闻复述一遍，或者看完某篇文章以后，自己和自己把这篇文章大概说了一个什么意思叙述一遍。或者，比如最近有某个电视连续剧很好看，自己和自己把整个连续剧的故事讲一遍。比如西游记大家都看过吧？你找不到口语练习材料的时候，就对自己把西游记的故事讲一遍，比如从前有一个和尚，他要去西天取经，佛祖派他怎么怎么样，他的徒弟怎么怎么样，四个徒弟分别是谁，什么性格，于是他们出发上路了，路上有很多妖怪，都分别有什么样的妖怪，想起来哪个就叙述哪个，保证这样可以让你不间断地说上半个小时的。总而言之，就是把自己分成两个人，一个给另一个讲故事、讲笑话、讲新闻等等。
读写透析法透析法要提升中国人的英语文化水平，核心就是读懂英文原著。读懂原著，能让你睁眼看世界，品味原汁原味的英语。狭义上说，英文原著主要是指以英语为母语人士的文字著作，也包括了其他语种著作的英译版。广义上说，英文原著是一切以英语为载体的信息，包括广播、电视、歌曲、电影、有声电子书、网络视频、播客等视听信息。广义上，原著的资源十分丰富，例如全世界75%的电视节目是用英语播出的。在国内，我们也可以在网上接收到世界上很多国家的英文电台、电视台。
把英语用起来，就是在真实的生活把英语用起来，就是在真实的生活中使用这门语言，要求听、说、读、中使用这门语言，要求听、说、读、写全部实现英文原著化。听，就听实时的英语新闻，从BBC、CNN到Al Jazeera；说，就用英语聊天，从身边的熟人到网络另一端的老外；读，就读老外的英文版，从短信、邮件到大部头的专著；写，就写英文邮件、短信给亲友同事乃至生意上的伙伴。 
对一本英文原著而言，“读下去”比“学生词”的意义大得多。只有“读下去”，你才能获得英 文原著的种种好处，读不下去，一切都等于零。 
核心操作：每2页查1个生词。
首先可以跳过卷首，包括简介和评论，以免打击积极性。从原著的正文开始读，遇到生词的时候，使用电子词典查单词。每2页查1个生词，词组、短语等是与单词处于同等地位的词条，亦视为一个词。你也可根据手机、平板电脑等设备的屏幕大小自定词的数量，但总的原则是不可查太多，特别是不能每个生词都查。透析时，遇到生词认为需要查词典便可使用查词机会，而不是先挑出生词来查，也不是读完再回头找生词查。在电子词典上看懂生词解释后便可回到原著，不要试图停下来记忆单词。在每2页中无论碰到多少个生词，10个好，20个亦好，有且只需查1个（除非你找不到生词了）。这些措施都能尽可能减少查生词操作对阅读的干扰。
你不禁要问：“多查几个不行吗？”“2页才查1个太少了吧？”……没商量！你想多查生词吗？可以，但你必须有阅读量的支持。例如，你若想迅速扩充词汇量，每天掌握50个生词，你就必须读够100页。千万别以为“每2页查1个生词”太少了，如果你只读一两页，就像在学校上英语课那样，查1个还是查10个，是没有什么区别的。但现在你每天要读几十页，或者电子版的几个百分点，日后你要读成千上万页、几百本书，就很有必要控制查词量，每2页查1个和每2页查2个的差别都是巨大的。多查生词，就会厌烦，进而有半途而废的风险，这正是无数人读不懂原著，长年停留在英语蒙昧状态的致命原因：你觉得几个生词重要，还是几百本原著重要？ 每2页才有1个查词机会，而生词多，如何选择？答案：随便。可以查重现率高的词，因为查明意义就能明白书中许多地方，可以查你认为“关键”的词，如小说关键情节中的生词，还可以从“功利”出发，优先查考试中可能出现的“大纲生词”，等等。
第二天在读英文原著之前，你要在电子词典上复习查词的“历史”，但是不要超过5分钟。
中译英打开《新2》，先别看英语原文，因为都是初中程度的句子，你一看就会。先看汉语翻译，一句一句从汉语向英语口译，口译完，再看英文原文。因为这本的内容很浅显，你有很大机率口译得跟原文差不多，但别大意，最好写下来，尤其那些be动词啊，单数第三人称啊，过去式啊，倒装啊，强调啊，和原文对比，跟原文不同的地方，就是你的进步之处！做过几篇，你就发现你变牛了，你觉得一个句子，自己的写法可以，书上的写法也可以。这时你就可以整篇小文地译了，译完，整体对比。如果你觉得新２比较散，可以口译带汉译的作文范文。那个句子土了点，不过见效快，一个搭配你没真掌握绝对译不出来，想破头再看原文，记忆效果加倍！
衡中体利用真题作文，以原因或影响为切入点，使用衡中体，练习限时写作。
学习资料通用：把你的英语用起来、真题、新概念英语。单词：欧路词典（优词词根词缀、English Etymology、Collins、Collins Thesaurus、Vocabulary.com Dictionary、LDOCE5、牛津词典、英汉-汉英词典、USE THE RIGHT WORD）、沙拉查词、1368个单词就够了、Word Power Made Easy、Merriam-Webster’s Vocabulary Builder听力：点滴复读机、ESLPod、EnglishPod、粉红猪小妹、老友记、生活大爆炸口语：赖世雄美语音标、ESLPod、EnglishPod、赖世雄语法阅读：BBC、VOA、newyorker写作：Writing Academic English、On Writing Well、The Chicago Manual of Style
小结条条大路通罗马，方法只是让自己少走一些弯路，真正重要的是——坚持！有计划地坚持！所有泛泛而谈都是吹牛逼，去听，去说，去读，去写！每天完成什么，完成多少，量化，看到自己的进度，看到自己的进步！
书签清北托福备考联盟慕课
将英语变成母语
怎么在一个月内让英语听力有明显的提高？
如何在一个月内通过大学英语四级、大学英语六级考试？
我的英语学习之路–影子跟读法
句子读法“三剑客”：连读、失去爆破、弱读
英语朗读技巧（连读、失去爆破和弱读/缩读 ）精华版
怎样培养英语思维，尤其是在读英文文章的时候？-王捷
怎样培养英语思维，尤其是在读英文文章的时候？-陈名豪
The New Yorker
Collins Dictionary
老友记（Friends）（MP3+LRC）_VOA英语学习网
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>我所看过最好的《心经》解读</title>
    <url>/essay-xj-illustration/</url>
    <content><![CDATA[作者不详，voidking整理。
这人世间，有一部最短的经典。这部经典只有二百六十个字，就是佛门留给我们的《般若波罗蜜多心经》，通常则称为《心经》。 
二百六十个字是太少了。和这人间积存起来的浩如烟海的文字相比，二百六十个字能写下一些什么呢？我们又怎么能设想仅仅用二百六十个字，就能完成一部经典呢？ 
然而事情又确乎是这样。佛门就用这不足一页的文字，为我们讲说了天上人间的秘密。用我们惯常的话语来说，就把世界观、生命观、人生观和价值观等等，都依次地写在了这部经典里。这样就不能不说，这便是人世间的一个圣迹。 
我们曾经感到过一种欠缺，就是我们听说过各种各样的一家之言，却不曾聆听过佛陀的经验。这就有些不够谨慎了，要是这之中刚好含藏着什么秘密的话，我们寻寻觅觅，人生又如白驹过隙，不就错过了这样慈悲的知见？ 
那末现在，在我们陆陆续续地听说了一些佛法之后，如果我们至少也该读完一部佛经的话，或许就可以看一看这部最短的经典。


我们不会吝啬这二百六十个字吧？我们平日里徒劳地读过的文字，又何止千言万语？要是我们一生里只省下这样一点时间，说不定就能领会到佛陀的心意，由此就能到智慧的彼岸去，那又该是怎样的有幸呢？这题名里的“般若”和“波罗蜜多”的意思，就是智慧和去彼岸，便正是要领我们到智慧的彼岸去。 
我们对彼岸当然有许多怀疑。我们固然深味这人生的辛苦和悲凉，到若要寻找彼岸，又让人疑心只是一种幻想。我们已经看到了，像鸟儿被关在笼子里一样，我们其实也是被囚禁在世界和身心的樊笼里的；我们的生存环境和生命本身，就决定着我们有生老病死和喜怒哀乐等等，又哪里能找到一种办法，来度尽我们的一切苦厄呢？ 
我们找不到这种办法，是因为我们一直都不知道世界和生命的秘密。然而佛陀在经过千辛万苦的寻觅之后，却解开了这些秘密，于是才慈悲地对我们说，这种根本的办法其实是有的。 
而这种办法的精髓，也即是佛法的心要，便收在了这部经典里。　　　　所以经文的一开头便这样说：　　“观自在菩萨行深般若波罗蜜多时，照见五蕴皆空，度一切苦厄。”　　这句话就可以看作经文的第一段，是一句总论，即以观自在菩萨为例，来作一个缘起。　　菩萨就是觉悟了的人，是不是呢？我们没有觉悟，所以我们不知道彼岸的景象；这位菩萨行深般若波罗蜜多时，也就到达了智慧的彼岸，所以就能在这种智慧的状态之中观自在，照见种种我们所不知道的情景。　　原来我们也不明白，如果有彼岸的话，这彼岸会在哪里。后来听说过一些佛法之后，我们也就有些明白了，这彼岸并不在天涯海角，而正是在我们的心里。我们的 心里充满了形形色色的念头，也就像一面染上了各种颜色的镜子，是什么都映照不清楚的，这就是在此岸；而菩萨放下了心里的念头之后，就好比镜子被擦试干净了，心里所固有的智慧便立即显现出来，也就是在彼岸了。智慧是什么？智慧当然就是能量和信息。这时候菩萨所显现出来的般若智慧，就是能照见世界和生命的真相的。　 　这真相又是什么呢？真相就是五蕴皆空。也就是说，在这种照见之下，菩萨便从最精微的角度看破了这个世界，发现构成世界和生命的五种物质形态，即色、受、想、行、识五种物质表现，本来都是“空”的。这一切的本质既然都是“空”的，当然也就有办法摆脱一切苦厄。因为我们的一切苦厄，不都是对“有”而言的？好比要先有一朵花，然后才会有花开花落和风吹雨打；又要先有一副身躯和一颗识心，然后才会有生老病死和处心积虑；如果我们能把身心都还原为这种空灵的状态的话，又还会有什么苦厄呢？　　“空”自然不是空无所有。空无所有是我们的一种错觉，一种误会。天空里漂浮着一朵白云，大海上卷起来一团浪花，跟着这云朵和浪花又都消失了，但哪里又是空无所有呢？在这个物质的宇宙世界里，就连满天的繁星也是靠引力而悬浮着的，又哪里能找到一种空无所有的状态呢？　　所以经文在用一句话说完这个绪论之后，接着便要从世界的根柢说起，首先要把世界的真相为我们作一个说明。　　和所有佛经的记载一样，佛陀讲经的时候，都有特定的对象。《心经》的听讲者，就是一个叫舍利弗的弟子。这些真相虽然是对舍利弗讲述的，便也是为全体众生讲述的。　　经文的绪论用了二十五个字。那末到了第二段，讲述佛陀的世界观，则有二十六个字。　　包括呼叫弟子的名字在内，这二十六个字便是这样的：　　“舍利子，色不异空，空不异色；色即是空，空即是色。受、想、行、识，亦复如是。”　　这就是色空说了，这样的话语就是我们曾经听说过的。或许是因为有一个空字吧，在原来，我们便把它当作了佛法的虚无和消极的凭据。　　然而色又怎么不是空的呢？色就是我们通常所说的有形有象的物质，我们把这些物质不断地分割下去，先是分子和原子，后来是电子和基本粒子，愈往后走就愈是无形无象了，不就仿佛是“空”的？　　我们原来是误会了，佛法说到“空”的时候，说的也就是那种构成世界的最原初的物质。我们不是至今也没有找到这种物质？而佛陀却在两千多年以前就发现了这 种物质。这种物质太精微了，看不见也摸不着，就像空的一样；然而它又真实地存在着，并非是空无所有的；所以在另外的一些时候，佛门就把它称为真如或如来，也称为实性、实际或实体。色的世界既然是由这种“空”的实体聚合而成的，那么我们在说到世界的时候，又该说它是色呢，还是空的呢？说色说空便都不确切，当 然就只能说色空并不相异。 
这就并非虚无，也不是消极了，若不如此，便难免是偏执的。　　那末这是说“色”，说一切有形有象的物质，包括山河大地，楼房车辆，还有我们的这副身躯，在根柢上都是“空”的。　　然而“空’在聚合为这个世界的时候，又是不是只表现为“色”这样一种物质形式呢？当然又不是。其实这“色”的层次，佛法说它是一种“质碍”，不过是一种 表面而粗糙的层次。经文接着就给我们指出来，在“色”的后面，就还有“受、想、行、识”。它们同样都是“空”生出来的，不仅同样是物质和物质现象，而且是 更为深入和精微的物质形式。　 　这儿的“受”和“想”就无须多说了，和“色’的现象相比，我们的感觉和意识诚然就更为隐密。至于“行”和“识”呢，则不能望文生义，不能误会为行为和意识。“行”是什么？“行”是对“想”的进一步剖析，佛法说“行”是迁流，就说它比“想”更加精细。“识”是什么？“识”又是对“行”的进一步的探索，佛法说“识”是藏识，就说它比“行”更为隐蔽。不妨用比喻来说的话，我们不是已经知道了，在物质的后面，就还有分子、原子、电子和基本粒子？那末参照地排列起来，这种由表及里、由浅入深的排列，也便是“色、受、想、行、识”。　　这意味着什么呢？这就意味着，经文在这里给我们描绘出来的，就既是世界的模式，同时也是生命的体系。这样便让我们清楚地看到，我们的生命就是整个物质世界的一个缩影，天人也本来合一。　　你以为怎样呢？这不就是一个平常而巨大的秘密？长久以来，当我们说到世界的时候，就总是把我们自己当做主体，而把世界视为客体，好像我们是生活在世界之 外，物质的世界并不包括我们自己，我们的感觉和意识等等也不是物质的。所以我们在寻找世界的根柢的时候，就有些像一个背着孩子找孩子的女人一样，只顾着在身旁的世界里张望，却忽略了那种最原初最精微的物质，其实就在我们自己的身上。现在经佛法一提醒，事情就变得完整而清晰，这儿的“色、受、想、行、识”，便覆盖了世界和我们自己。这就使我们恍悟到了，不仅“色”的世界是物质的，还有我们自己的“受、想、行、识”，也同样是物质的。若问“识”之后又是些什么呢？“识”之后诚然就是“空”了。所以我们只消回过头来打量一下自己的生命，沿着色受想行识这样的层次逐渐深入下去，也就能得知世界的秘密。　 　这是不是就有一些玄虚？其实也不，不过是我们没有这样地试验过而已。佛法是讲信、解、行、证的，如果我们能依照佛法的指引，认真地试验一下，那末或多或少的，也就能体验到这种秘密。　　确实，我们活着，如果只停留在“色”和“受”的层次上，其粗疏就可想而知，其遗憾也不言而喻。即便是来到“想”的层次上，这“想”便再大也有限，反过来 也会限定我们自己，使我们成为一个狭小而固执的小我。但如果我们不以为自己之所“想”就天经地义，也不总是在“色”和“受”里去寻求满足和刺激，而是换一 条路径走一走，比方说安安稳稳地坐下来，设法把眼耳鼻舌都关闭起来，然后往自己的生命深处查看一下，又会怎样呢？这样一来，在我们确实地安静下来以后，即进入了佛法所说的禅定状态以后，不仅“色”和“受”的侵扰会消隐下去，就连我们的剪不断理还乱的思绪，便也是可以消解和轻减的。等到这样的功夫纯熟之后， 我们也就能进入“行”和“识”的境地。　 　“行”和“识”的境界自然就更加深远和宽阔，这里我们不妨作一个比喻。让我们先把“想”比作一篇文章好了，一个人的思想确实也就像一篇文章，是一个被限定了的整体，所以是疆界分明的，不能彼此进入的。这时候“行”是什么呢？“行”是迁流，是一种能流动的东西，便好比是文章之中的句子，同样的一个句子也就可以进入到好些不同的文章里去。至于“识”呢，在这种情况下，便自然是更加自由的单字了，所有的句子和文章便都是由它组成的。这一切也就犹如说，你如果是一团板结的物质的话，就是非常之不自由的；但如果你不是物体而是分子呢，就会自由得多了；更不用说你还是电子和基本粒子，如果到了这样的地步，又还有什么东西能阻挡你，你又还有什么地方不能去呢？　　这一切诚然有些不可思议；然而这似乎不可思议的一切，却正是佛法所发现的秘密。当年释迦牟尼王子在菩提树下证道之后，他的心灵就最终摆脱了色受想行识的重负，便和宇宙万物全息相应，便看见了三世十方的所有景象，得知了宇宙万物的一切根柢。而观自在菩萨在行深般若波罗蜜多的时候，便同样验证了这一秘密，照见了“色”和“受、想、行、识”都是“空”的。而这种“空”，自然也就是万物的本质，世界的依据。　　这样地说下来，诚然就要说到生命的规律，所以经文也就进入了第三段，用八十二个字写成了下面的文句：　　“舍利子，是诸法空相，不生不灭，不垢不净，不增不减。是故空中无色，无受想行识：无眼耳鼻舌身意，无色身香味触法；无眼界，乃至无意识界；无无明，亦无无明尽，乃至无老死，亦无老死尽；无苦集灭道，无智亦无得。” 
不用说，这儿的“诸法空相”，说的也就是世界和生命的本相，本来的面目或本来的模样。　　事物诚然有自己的本相，比方说五光十色的万花筒吧，一旦拆开来之后，不是就只有几粒细碎的玻璃？还有雪花，或者云霞，虽说是变化万千，但追寻到终极的地 方，还原为本来的面目，也不过是氢原子和氧原子而已。那末“诸法”呢？即是包括生命在内的一切物质现象，其真相又是怎样的呢？在经过了上一个段落的开示之后，我们应该意识到，色受想行识诸法的本相也就同样是“空”的。并且其空灵的程度，就绝非原子电子之类的存在可以比拟；本来都无法描述了，如果勉强地描述一下的话，这种空灵的本相，就是不生不灭、不垢不净和不增不减的。　 　什么东西会这样玄秘，能不生不灭、不垢不净和不增不减呢？我们又能在哪儿 找到这种东西呢？其实一经说破，我们就不难猛省，你只要能回过头来，审视一下你的意识就行。你不是有喜怒哀乐，还有受想行识？这样的现象不就很玄秘？而先 贤这时候就启发我们说，那末在你的喜怒哀乐和受想行识还没有发动之前，是不是还应该有一个东西？一者是所指，一者则是能指，你就想想看吧，那个可以用来化作喜怒哀乐和受想行识的东西，那又该是一种怎样的东西？这就是我们始终载负着的灵智，就是佛法所说的真如实体。这便是世界和生命的本来面目，无比精微，无比空灵，虽然是“空相”，却又是真实不虚地存在着的。　　仍然用比喻来说的话，我们就姑且把这种空相比喻为氢原子和氧原子，无形无象，也无踪 无影。然而什么时候，这原子一聚合起来，不就成了汽，成了云朵和水，最后还会凝结为冰？世界和生命的情形也一样，终极的地方是一片妙明，后来便结成了暗色，有了色受想行识。这就是无中生有了，我们的生命就是其中的一种能量体系，是色受想行识的一种集成。有了世界和生命这个“有”之后，又才有眼耳鼻舌身意和色身香味触法，乃至于生老病死和苦集灭道等等，所有这一切，便不过是能量的聚集、控制和耗散，是彼此的交流、转化和合成。缘起而性空，性空而缘起，只有空灵的本相才永恒不变，而一切的“有”，便都像泡影一样，是随缘生灭的，不能常住的。　　所以经文在这里就用了一连串的“无”，来说明诸法和万有的本性。如果我们不明白这一点，只看见“有”，不知道“无”，便会执着于“有”，即是执着于自己的得失和见解，执着于各种各样的本来就留不住的东西，若依佛法看来，也就是痴迷，就是“无明”。而这种痴迷或“无明”的状态，自然也就是一种“有”的物质状态，便会始终控制和牵引着我们，使我们永远在“有”的境况里轮回，包括只是在佛学和道法里纠缠，而不能达到“无智亦无得”的境界，回归于终极和永恒的存在。　　那末反过来，如果我们清楚了世界和生命的这种真相以后，事情又会怎样呢？应该说很显然，这样一来，我们也就找到了事物的终极的依据。我们原来不知道这种根本的秘密，没有这样的终极的依据，所以我们在讨论着这生命和人生的时候，便只能是瞎子摸象似的，一切都只能是自圆其说和自由认取，于是才众声喧哗，纵有所得和所见，也只是一些浅显的体验和相对的道理，经不住再问一下为什么，到底是不了义。现在当然就不同了，依照这种根本的秘密，对于我们今生今世的生命来说，也就能引导出一种终极的含义。　　所以紧接着，经文也就有了第四段和第五段，即分别以菩萨和诸佛的人生选择为例，来为我们说明生命和人生所能有的终极的意义。　　明白了生命的真相的菩萨们，是怎样来度过自己的一生的呢？　　上面一段的最后一句得到了一个结束语，“无智亦无得”，就是说要解放我们的心识和不计较我们的所得；这就显得不同于常理，不免让人生疑；又不要有见解， 又不能追求利益，这人生还有什么呢？这时候经文便对我们解释说，并非是什么都没有，菩萨们就是因为解除了这些束缚，才解放和超越了自己，然后才得到一个完 整的天地。　 　“以无所得故”，经文接着便这样说，“菩提萨埵依般若波罗蜜多故，心无挂碍；无挂碍故，无有恐怖，远离颠倒梦想，究竟涅盘。”　　这儿便有三个衔接着的缘故，一是无所得故，二是般若波罗蜜多故，三是无挂碍故。我们如果要了解其中的道理，就不妨从反面的情形，来体悟一下这种缘故。　　一个人设若不是“无所得”，而是要不断地有所得，那又怎么样呢？应该说很清楚，这便是我们通常所见到的情形。这所得便始终有限，同时又永无止境。这样一 来，生活就总是在别处，幸福也总是在你不在的地方，你便永远要在这样那样的所得之中游泳，到死也不会有岸，不会有片刻的安宁。而你的种种所得，又注定是留不住的，是非成败都转头空，到头来都难免风流云散，如梦幻泡影。即便再轮回一次，也还是依然故我，也只能照样的忙个不停。如果一切只能是这样地重复的话，你作为万物之灵长，这灵长之处又何在呢？不就值得人深省？　 　我们不必畏惧这个“无所得”。比方说你的一双手吧，如果你得到了一点什么东西，便 始终紧紧地把它捏在手里，再也不肯放下，害怕这样一来就会无所得，你的这双手又还会有什么用呢？又怎么能像你所希望的那样，去拥抱整个的世界呢？手如此，心灵当然也是这样。如果我们的心灵被这样那样的所得填塞得满满的，就像天空里始终布满着云絮，智慧的蓝天又怎么能够显现出来呢？所以菩萨们就不执着于自己之所得，才能够行深般若波罗蜜多，照见心灵的蓝天。照见了蓝天之后，便明白原来在心灵漂浮着的种种见解和念头，不过是一些靠不住的云絮，从此便不再被这些 云絮所迷惑，能够心无挂碍。　　我们的迷误就在于心有挂碍，一颗心始终被层出不穷的云絮遮盖着，这云絮就成了我们的自我，想不到放开，不愿意放开，乃至没法放开。在这种情况下，世界虽说只有一个，但在不同的人们来说，就注定要用自己的这一团云絮一般的心识去看待世界，然后便固执己见，给人生加上种种的目的，给世界蒙上种种的色彩。我看青山多妩媚，料青山看我也如是，这自然是境由心造；至于杯弓蛇影呢？风声鹤唳呢？也就是颠倒梦想和心怀恐惧了。所以我们也清楚，正常的人们与精神病患者之间，就不过是程度上的差别而已。随着日子的越来越繁复，诱惑和刺激也越来越深重，我们的心也就越来越浮躁。其浮躁的程度，便好比闷热而黑暗的锅子似的。这时候除了依法修行的菩萨们而外，谁又能解脱自在，远离颠倒梦想，而最终达到涅盘的境地呢？　　涅盘的意思就是圆寂。完全可以说，这圆寂二字，也就概括了佛法的秘密。想想看吧，不就只有圆满的又才是寂静的、寂静的又才是圆满的？菩萨们从无所得开始，不断解放和超越自己，到后来便心无挂碍，心灵所固有的智慧便显现出来，即是恢复了生命的本相，回归了生命的本体，这便是圆寂。到了这样的时候，菩萨们便能够不离万物，不住万物，与世界全息相应，完成了天人合一。所以最高果位的菩萨，也就是等觉菩萨和妙觉菩萨，就与三世诸佛无异，其觉受的境界便和三世诸佛是一样的。　　这种终极的境界，就是无上正等正觉，即阿耨多罗三藐三菩提。所以经文的第五段便说：　　“三世诸佛，依般若波罗蜜多故，得阿耨多罗三藐三菩提。”　　一切过去、现在和未来的佛菩萨们，便安住在这样的正觉里。在摆脱了生死的轮回和一切苦厄之后，才是不生不灭的，解脱自在的。　　话到这里似乎就说完了。余下来的最后一段，六十五个字，便要为这一切作一个结论。而这时候，在我们跟着经文一路地走过来，明白了事情的真相之后，这结论也就是十分清楚的：　　“故知般若波罗蜜多，是大神咒，是大明咒，是无上咒，是无等等咒，能除一切苦，真实不虚。故说般若波罗蜜多咒，即说咒曰：揭谛揭谛，波罗揭谛，波罗僧揭谛，菩提萨婆诃。”咒诚然就是一种真言，一种最真实、最有力的言语。那末相比之下，又还有什么言语，能比般若波罗蜜多更真实、更有力呢？现在把前面说过的一切总括起来，这一部经典的心要也就可以归结为这样一句真言：去吧去吧，到彼岸去吧，让我们都到彼岸去吧，快快的得到觉悟。　　也许你很难相信这一切？　　又也许你相信了，又还是愿意留在颠倒梦想里，认为这样才更美丽，即便坠入地狱也在所不惜？　　这当然都由你。佛法说命自我立，世界并不是神明创造的，也没有神明在支配着你，你的命运全在你自己的手里。　　但是又也许，你确实看到人生如痴人说梦，充满喧哗与骚动，却找不到你能认可的意义，那又如之何呢？那末这时候，在你上下求索又仍然归途茫茫的时候，便还有这样的一条路经留在这里。　　这便是诸佛菩萨和古往今来的高僧大德们验证过的一个秘密。能除一切苦，真实不虚。　　而我们如果要接近佛法的话，诚然就要以经典的开示为依据。依佛说则是佛法，不依佛说则不是佛法。道理也好，法门也好，便全在这里。
翻译：观自在菩萨（般若智慧已经达到自在境界的菩萨）行深般若波罗蜜多时（当他修行般若智慧达到波罗蜜多觉悟境界的时候）照见五蕴皆空（洞见色、受、想、行、识五蕴乃是人类虚空的妄想）度一切苦厄（所以菩萨要为众生解脱一切执着于生死烦恼的苦厄）
舍利子（智慧第一的舍利子啊）色不异空（你所看见的物质世界其实是你的精神世界）空不异色（你的精神世界也就是你以为的物质世界）色即是空（物质世界就是精神世界）空即是色（精神世界就是物质世界）受想行识亦复如是（人类所谓的感受、思想、行为和认识也是如此）
舍利子（智慧第一的舍利子啊）是诸法空相（其实一切法都不是法，只是人类虚空的精神幻觉）不生不灭（真实的世界不会产生，也不会灭亡）不垢不净（不会被尘埃沾污，也不需要去洁净）不增不减（任何东西都不会增加，也不会减少）是故空中无色（在真实世界里并没有物质这一概念）无受想行识（自然也就不存在人类对物质世界的感受、思想、行为和认识）无眼耳鼻舌身意（眼、耳、鼻、舌、身、意这六种感官对于真实世界没有任何意义）无色声香味触法（自然也就不存在所谓的颜色、声音、香气、味道、感觉和概念）无眼界乃至无意识界（你眼睛所看到的一切都是假象，你的意识也全部都是错觉）无无明亦无无明尽（没有前世愚昧的事情，也没有后世报应的所谓十二因缘）乃至无老死（就连生老病死也是胡说）亦无老死尽（更没有生死轮回的道理）无苦集灭道（没有生死烦恼，没有贪婪和恐惧，也没有所谓的真理）无智亦无得（既没有智慧，也得不到任何知识）以无所得故（这才是超越了人类精神的惟一真实的世界）
菩提萨埵（大慈大悲普度众生的观自在菩萨）依般若波罗蜜多故（依靠般若智慧抵达了波罗蜜多觉悟的彼岸）心无罣碍，无罣碍故（心中没有任何牵挂和妨碍，正是因为没有受到人类精神影响的缘故）无有恐怖，远离颠倒梦想（没有任何恐怖，远离那些违背自然的思想）究竟涅盘（所以菩萨观得自在，消除了一切烦恼）
三世诸佛（过去、现在和将来三世佛以及一切佛）依般若波罗蜜多故（都是依靠般若智慧达到波罗蜜多觉悟的境界）得阿耨多罗三藐三菩提（得到阿耨多罗无上三藐正等三菩提正觉成佛的境界）
故知般若波罗蜜多是大神咒（所以般若智慧波罗蜜多觉悟是不可思议的咒语）是大明咒（是普照一切的咒语）是无上咒（是最最伟大的咒语）是无等等咒（是超度一切的咒语）能除一切苦（能够解除人生的一切生死烦恼和苦厄）真实不虚（佛无妄语，自然真实）故说般若波罗蜜多咒（所以这是众生修行般若智慧抵达波罗蜜多觉悟的密咒）即说咒曰（咒语曰）揭谛揭谛（去吧去吧）波罗揭谛（走过所有的道路）波罗僧揭谛（一起去向人生的彼岸）菩提萨婆诃（欢呼觉悟吧）
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>《汇编语言（王爽）》</title>
    <url>/hobby-assembly-language-wangshuang/</url>
    <content><![CDATA[汇编语言发展至今，由以下三类指令组成：汇编指令、伪指令、其他符号。
8086CPU有20位地址总线，可以传送20位地址，达到1MB的寻址能力。
物理地址=段地址×16＋偏移地址 
8086CPU有14个寄存器：AX,BX,CX,DX;CS,DS,SS,ES;IP,SI,DI,BP,SP;PSWCS(IP)  DS,ES(BX,SI,DI,BP)  SS(SP,BP)

DEBUG功能


r命令查看、改变CPU寄存器中的内容d命令产看内存中的内容e命令改写内存中的内容u命令将内存中的机器指令翻译成汇编指令t命令执行一条机器指令a命令以汇编指令的格式在内存中写入一条机器指令p命令跳过循环和执行中断g命令,“g 0016”直接跳到cs:0016


在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应。栈也是。
汇编的一个经典栗子，看完再继续向下学习详细指令。
assume cs:code,ds:datadata segment     db 'welcome to masm!'data endscode segmentstart:   mov ax,data     mov ds,ax     mov bx,0               ;ds:bx指向data字符串     mov ax,0b800h     mov es,ax     mov si,0               ;es:si指向显存     mov cx,16s:   mov al,[bx]            ;字符赋值al     mov ah,02h             ;绿色     mov es:[si].720h,ax    ;写入第12行64列     mov ah,14h             ;绿底红色     mov es:[si].7c0h,ax    ;写入第13行64列     mov ah,71h             ;白底蓝色     mov es:[si].860h,ax    ;写入第14行64列     inc bx                 ;指向下一字符     add si,2               ;指向下一显存单元     loop s     mov ax,4c00h     int 21hcode endsend start



push指令执行步骤：1. SP=SP-2 ;   2.向SS:SP指向的字单元中送入数据。pop指令执行步骤：1. 从SS:SP指向的字单元读取数据；  2.SP=SP＋2。任意时刻，SS:SP指向栈顶元素。

mov指令mov ax,[0]    送入0mov ax,ds:[0]    送入内存中的值mov ax,[bx]    送入内存中的值mov ax,ds:[bx]    送入内存中的值

add 指令add ax,[1]把1加到ax寄存器上

sub指令sub ax,[1]把ax寄存器中的值减1

and 逻辑与指令，按位进行与运算将AL的第六位设为0：and al,10111111B

or 逻辑或指令，按位进行或运算将AL的第六位设为1：or al,01000000B大写字母的ASCII码第五位为0，小写字母的第五位为1.

使用寄存器BP，如果没有显性地给出段地址，段地址就默认在SS中。Mov ax,[bp]:(ax)=((ss)16+(bp))Mov ax,[bp+si+idata]:(ax)=((ss)16+(bp)+(si)+idata)

机器指令并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在三个地方：CPU内部，内存，端口Mov bx,[0]内存，ds:0单元Mov bx,axCPU内部，ax寄存器Mov bx,1CPU内部，指令缓冲器

8086CPU的指令，可以处理两种尺寸的数据，byte和word。所以在机器指令中要指明，指令进行的是字操作还是字节操作。

通过寄存器名指明要处理的数据的尺寸；
没有寄存器名存在的情况下，用操作符byte ptr和word ptr指明内存单元的长度


DIV除法指令：

除数：有8位和16位两种，在一个寄存器或内存单元中
被除数：默认放在AX或AX和DX中如果除数为8位，被除数则为16位，默认在AX中存放；如果除服为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。
结果：如果除数为8 位，则AL存储除法操作的商，AH存储除法操作的余数；如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。


dup操作符，与db,dw,dd等数据定义伪指令配合使用的，用来进行数据的重复。db  3  dup (&#39;abc&#39;, &#39;ABC&#39;)

offset取得标号偏移地址

转移指令：可以控制CPU执行内存中某处的代码的指令。jmp short 标号jmp 标号jmp far ptr 标号
1.只修改IP时，称为段内转移，如：jmp ax。*短转移：IP的修改范围-128——127*近转移：IP的修改范围-32768——32767    
2.同时修改CS和IP 时，称为段间转移，如：jmp 1000:0。

jcxz指令 有条件转移指令。所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都是：-128——127.
jcxz  标号（如果（cx）=0，转移到标号处执行。）操作：当（cx=0）时，（IP）=(IP)+8位位移：      8位位移=”标号”处的地址 - jcxz指令后第一个字节的地址相当于：
if((cx)==0) jmp short 标号



loop指令 循环指令所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都是：-128——127.
loop 标号（（cx）=(cx)-1,如果（cx）≠0，转移到标号处执行。）操作：1.（cx）=(cx)-1；2. 如果（cx）≠0，（IP）=(IP)+8位位移。如果（cx）=0，什么也不做（程序向下执行）相当于：
(cx)--If((cx) ≠0) jmp short 标号`



ret指令 用栈中的数据，修改IP的内容，从而实现近转移CPU执行ret指令时，1.（IP）=（（SS）*16+(SP)）2. (SP)=(SP)+2相当于：
POP IP


Retf 指令 用栈中的数据，修改CS和IP 的内容，实现远转移CPU执行retf指令时，

（IP）=（（SS）*16+(SP)）
(SP)=(SP)+2
（CS）=（（SS）*16+(SP)）
(SP)=(SP)+2相当于：POP IP POP CS





CALL 指令不能实现短转移，除此之外，和JMP指令原理相同。CPU 执行CALL指令时，1.将当前的IP或CS和IP压入栈中；2.转移
call 标号（将当前IP压栈后，转到标号处执行指令）相当于：
PUSH IPJMP near ptr 标号

call far ptr 标号  （段间转移）相当于：
push csPush IPJmp far ptr 标号

call 16位寄存器相当于： 
PUSH IPJmp 16位寄存器

call word ptr 内存单元地址相当于：
push IPJmp word ptr 内存单元地址
call dword ptr 内存单元地址相当于：
push CSpush IPJmp dword ptr 内存单元地址

call 和 ret配合使用实现子程序的机制框架如下：
Assume cs:codeCode segmentMain: :        :        Call sub1        :    Sub1: :        Call sub2        :        Ret    Sub2:        :        RetCode ends End main



mul 乘法指令;(1)两个相乘的数，要么都是8位，要么都是16位；如果是8位，一个默认放在AH中，另一个放在8位寄存器或内存字节单元中；如果是16位，一个默认在AX中，另一个放在16位寄存器或内存字单元中。(2)8位乘法，结果默认放在AX中；16位乘法，结果高位默认在DX中存放，低位在AX中存放。

标志寄存器flag作用：（1）用来存储相关指令的某些执行结果（2）用来为CPU执行相关指令提供行为依据（3）用来控制CPU的相关工作方式
第6位ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果结果为0，那么ZF=1，不为0，那么ZF=0.影响标志寄存器的指令，如：add，sub，div，inc，mul，or，and等，他们大都是运算指令；有的指令对标志寄存器没有影响，比如：mov，push，pop等，他们大都是传送指令。
第2位PF，奇偶标志位。它记录相关指令执行后，其结果的所有二进制中1的个数是否为偶数。如果1的个数为偶数，PF=1，如果为奇数，那么PF=0.
第7位SF，符号标志位。它记录相关指令执行后，其结果（实际结果（寄存器中存放的结果）并非逻辑结果）是否为负。如果结果为负，SF=1，如果非负，SF=0。CPU在执行ADD等指令的时候，包含了两种含义。将得到用同一种信息记录的两种结果，关键在于我们的程序需要哪一种结果。SF标志就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。
第0位CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高位向更高位的进位值，或从更高位的借位值。
第11位OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1，如果没有，OF=0。CF 是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。
adc带进位加法指令，它利用了CF位上记录的进位值。指令格式：adc 操作对象1，操作对象2功能：操作对象1=操作对象1+操作对象2+CF加法：1低位相加；2高位相加再加上低位相加产生的进位值下面指令和add ax,bx具有相同的结果Add al,alAdc ah,ah
sbb 带借位减法指令，它利用了CF位上记录的借位值。格式：sbb 操作对象1，操作对象2功能：操作对象1=程序对象1-程序对象2-CFSbb ax,bx实现的功能：(ax)=(ax)-(bx)-CF
cmp 比较指令，cmp的功能相当于减法指令，只是不保存结果。Cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。格式：cmp 操作对象1，操作对象2功能：计算操作对象1-操作对象2  但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。cmp ax,bx  ；无符号数的比较如果(ax)=(bx)则(ax)-(bx)=0,所以：ZF=1；如果(ax)≠(bx)则(ax)-(bx)≠0，所以：ZF=0；如果(ax)&lt;(bx)则(ax)-(bx)将产生借位，所以：CF=1；如果(ax)≥(bx)则(ax)-(bx)不必借位，所以：CF=0；如果(ax)&gt;(bx)则(ax)-(bx)既不借位，结果又不为0，所以：CF=0并且ZF=0如果(ax)≤(bx)则(ax)-(bx)既可能借位，结果可能为0，所以：CF=1或ZF=1。有符号数的比较：SF只能记录实际结果的正负，发生溢出的时候，实际结果的正负不能说明逻辑上真正结果的正负。但是逻辑上的结果的正负，才是cmp指令所求的真正结果，所以我们在考察SF的同时考察OF，就可以得知逻辑上真正结果的正负，同时就知道比较的结果。1.如果SF=1，而OF=0没有溢出，逻辑结果的正负=实际结果的正负SF=1，实际结果为负，(ax)&lt;(bx)2.如果SF=1, 而 OF=1OF=1，说明有溢出，逻辑上真正结果的正负≠实际正负SF=1，实际结果为负，如果因为溢出导致了实际结果为负，则逻辑上真正的结果必然为正。这样SF=1, OF=1，说明了(ax)&gt;(bx)。3.如果SF=0，而 OF=1     说明：(ax)&lt;(bx)OF=1，说明有溢出，逻辑结果的正负≠实际结果的正负SF=0，实际结果非负，有溢出结果非0，所以实际结果为正，如果因为溢出导致了实际结果为正，则逻辑上真正的结果必然为负。4.如果SF=0，而 OF=0没有溢出，且结果非负，所以(ax）≥(bx)
检测比较结果的条件转移指令“转移”指的是它能够修改IP，而“条件”指的是它可以根据某种条件，决定是否修改IP。这些条件转移指令通常都和CMP相配合使用，就好像call和ret指令通常相配合使用一样。常用的根据无符号数的比较结果进行转移的条件转移指令有：指令   含义            检测位Je      等于则转移      ZF=1Jne    不等于则转移    ZF=0Jb     低于则转移      CF=1Jnb    不低于则转移    CF=0Ja     高于则转移      CF=0且ZF=0Jna    不高于则转移    CF=1或ZF=1E :equal   b: below  a: above  n: not j: jump 
flag 的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si,di 的增减。DF=0   每次操作后si,di 递增DF=1   每次操作后si,di 递减Movsb 描述：mov es:[di],byte ptr ds:[si];（8086不支持这样的格式。）如果DF=0;  inc si      inc di如果DF=1； dec si      dec di功能：将ds:si指向的内存单元的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减。Movsw 将ds:si指向的内存单元的字送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2。
一般，movsb 和movsw都和rep配合使用，格式：rep movsb汇编描述：s: movsb          Loop s可见，rep的作用是根据cx的值，重复执行后面的串传送指令。8086对DF的设置：cld置0， std置1
pushf 将标志寄存器的值压栈，popf从栈中弹出数据，送入标志寄存器中。
四种内中断： 除法错误、单步执行、执行int0指令、执行int指令
中断信息中包含中断类型码，中断类型码为一个字节型数据，可以表示256种中断信息的来源，即中断源。
中断向量表，中断处理程序的入口地址列表。中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。中断向量表指定存放在内存地址0处，从0000:0000到0000:03E8的1000个段媛中存放着中断向量表。一个表项存放着一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU，这个入口地址包括段地址和偏移地址，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。
8086CPU在收到中断信息后，引发的中断过程为：1.（从中断信息中）取得中断类型码；  N2. 标志寄存器的值入栈； pushf3. 设置标志寄存器的第八位TF和第九位IF的值为0; TF=0,IF=04. CS的内容入栈 ;   push CS5. IP的内容入栈;    push IP6. 从内存地址为：中断类型码4和中断类型码4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。(IP)=(N4),(CS)=(N4+2)在最后一步完成后，CPU开始执行程序员编写的中断处理程序。
CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。
中断处理程序的编写步骤：1.保存用到的寄存器2.处理中断3.恢复用到的寄存器4.用iret指令返回
Iret指令的功能用汇编语法描述为：Pop IPPop CSPopfIret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。
CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1，则它引发的中断过程为：[1]取得中断类型码1；[2]标志寄存器入栈，TF,IF设置为0；[3]CS,IP入栈;4=(14),(CS)=(14+2)。
Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。
响应中断的特殊情况：在执行完向SS寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。因为，SS：SP联合指向栈顶，而对他们的设置应该连续完成，如果在执行完设置SS的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值，而SS改变，SP并未改变，SS:SP指向的不是正确的栈顶，将引起错误。所以CPU在执行完设置SS的指令后，不响应中断。这给连续设置SS和SP，指向正确的栈顶提供了一个时机。因此我们将设置SS和SP 的指令连续存放，使得设置SP的质量紧接着设置SS的指令执行，而在此之前，CPU不会引发中断过程。

int 指令格式：int n    n为中断类型码，它的功能是引发中断过程CPU执行INT N指令，相当于引发一个N号中断的中断过程：[1]取中断类型码n[2]标志寄存器入栈，IF=0，TF=0[3]CS、IP入栈[4]（IP）=（N4），（CS）=（N4+2）从此处转去执行N号中断的中断处理程序。

在系统的ROM中存放着一套程序，称为BIOS（基本输入输出系统），BIOS中主要包括：[1]硬件系统的检测和初始化程序；[2]外部中断和内部中断的中断例程；[3]用于对硬件设备进行I/O操作的中断例程；[4]其他和硬件系统相关的中断例程。操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。程序员在编程的时候，可以用INT 指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。

BIOS和DOS中断例程的安装：[1] 开机后，CPU一加电，初始化（CS）=0FFFFH,(IP)=0，自动从FFFF:0单元开始执行程序，FFFF：0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。[2]初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为他们是固化到ROM中的程序，一直在内存中存在。[3]硬件系统检测和初始化完成后，调用INT 19H进行操作系统的引导，从此将计算机交由操作系统控制。[4]DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。


1.在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有：[1]各种接口卡（如：网卡、显卡）上的接口芯片，他们控制接口卡进行工作[2]主板上的借口芯片，CPU通过他们对部分外设进行访问[3]其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理这些芯片中，都有一组可以由CPU读写的寄存器，他们在物理上可能处于不同的芯片中，但是他们在以下两点上相同：[1]都和CPU的总线相连，当然是通过他们所在的芯片进行的[2]CPU对他们进行读写的时候，都通过控制线向他们所在的芯片发出端口读写命令。可见，从CPU的角度，将这些寄存器都当作端口，对他们进行统一的编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。
2.端口地址和内存地址一样，通过地址总线来传送，在PC系统中，CPU最多可以定位64K个不同的端口。端口地址的范围：065535.端口的读写：:in和out指令In al ,60h     从60H号端口读入一个字节在in和out指令中，只能使用ax和al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口用ax，访问16位端口用ax。对0255以内的端口进行读写时：In  al , 20hOut 20h , a对256~65535的端口读写时，端口号放在dx中Mov  dx , 3f8hIn    al , dx      从端口3F8读入一个字节Out   dx, al      向端口3F8写入一个字节

CMOS RAM 芯片简称CMOS 芯片特征：[1]包含一个时钟和一个有128个存储单元的RAM存储器[2]靠电池供电，关机后内部时钟正常工作，RAM中信息不丢失[3]128个字节的RAM中，内部时钟占用0—0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。[4]该芯片内部有两个端口，端口地址为70H和71H。CPU通过这两个端口来读写CMOS RAM[5]70H为地址端口，存放要访问的CMOS RAM单元的地址；71H为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行，比如：读CMOS RAM的2号单元：①将2送入端口70H②从71H读出2号单元的内容

4.CMOS RAM中存放的时间信息存放时间：年、月、日、时、分、秒。这6个信息的长度都是1个字节。

SHL是逻辑左移指令，它的功能为：[1]将一个寄存器或内存单元的数据向左移位；[2]将最后移出的一位写入CF；[3]最低位用0补充。SHR逻辑右移指令，它与SHL操作相反：[1]将一个寄存器或内存单元的数据向右移位；[2]将最后移出的一位写入CF；[3]最高位用0补充。

1.外设的输入不直接送入内存和CPU，而是送入相关的借口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相应的芯片送到外设。可见，CPU通过端口和外部设备进行联系。
2.可屏蔽中断：可由标志寄存器IF位设置，如果IF=1，CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，则不响应中断。Sti ,用于设置IF=1；Cli 用于设置IF=0.中断过程：1. 取中断类型码n          2. 标志寄存器入栈，IF=0，TF=0.          3. CS、IP入栈          4. （IP）=（N4）,（CS）=（N4+2）.中断类型码是通过数据总线送入CPU 的。
3.键盘输入的处理：键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描，按下一个键时，该芯片就产生一个扫描码，称为通码。扫描码被送入主板上的相关借口芯片的寄存器中，该寄存器的端口地址为60H。松开按下的键时，也产生一个扫描码，称为断码，也被送入60H。断码=通码+80H扫描码长度为一个字节，通码的第7位为0，断码的第7位为1.
4.键盘的输入到达60H端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int9中断例程。
5.BIOS提供了int9中断例程，用来进行基本的键盘输入处理，主要工作：[1]读出60H端口中的扫描码；[2]如果是字符键的扫描码，将该扫描码和它对应的字符码（ASCII码）送入内存中的BIOS键盘缓冲区；如果是控制键和切换键的扫描码，则将其转变成状态字节，写入内存中存储状态字的单元[3]对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。0040:17单元存储状态字节，该字节记录了控制键和切换键的状态。0：右shift状态，置1表示按下1：左shift状态，置1表示按下2：ctrl状态，置1表示按下3：alt状态，置1表示按下4：scrolllock状态，置1表示scroll指示灯亮5：Numlock状态，置1表示小键盘输入的是数字6：capslock状态，置1表示输入大写字母7：insert状态，置1表示出于删除态。
6.键盘输入的处理过程：键盘产生扫描码——扫描码送入60H端口——引发9号中断——CPU执行INT9中断例程处理键盘输入。前三步都是由硬件系统完成的。
7.简单延时函数Mov dx,10hMov ax,0        S:  sub ax,1            Sbb dx,0[1]            Cmp ax,0            Jne s            Cmp dx,0            Jne s    程序实现100000H次循环。
8.指令系统总结：[1]数据传送指令：mov、push、pop、pushf、popf、xchg等，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。[2]算术运算指令：add、sub、adc、sbb。Inc、dec、cmp、imul、idiv、aaa等，这些指令实现寄存器和内存中的数据的算术运算，他们的执行结果影响标志寄存器的：sf、zf、of、cf、pf、af位[3]逻辑指令：and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr等，除了not指令外，其他的执行结果都影响标志寄存器的相关标志位。[4]转移指令：可以修改IP，或同时修改CS和IP的指令：无条件转移指令——jmp；条件转移指令——jcxz、je、jb、ja、jnb、jna；环指令：loop；过程：call，ret，retf；中断：int，iret。[5]处理机控制指令：这些指令对标志寄存器或其他处理机状态进行设置，如：cld std cli sti nop clc cmc stc hlt wait esc lock等[6]串处理指令：这些指令对内存中的批量数据进行处理，比如，movsb movsw cmps scas lods stos等，若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。
1.描述了单元长度的标号：a db 1,2,3,4       B dw 0    Mov al,a[si]    Mov ah,0    Add b,ax标号a、b是同时描述内存地址和单元长度的标号。标号a，描述了地址code：0，和从这个地址开始，以后的内存单元都是字节单元；而标号b描述了地址code：4，和从这个地址开始，以后的内存单元都是字单元。标号a,b后面没有“：”指令：mov ax,b相当于：mov ax,cs:[4]      指令：mov al,b      指令会引起编译错误，因为b代表的是字单元，al是8位寄存器。
2.在其他段中使用数据标号：如果想在代码段中，直接用数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来。否则编译器在编译的时候无法确定标号的段地址在哪一个寄存器中。
3.可以将功能子程序的入口地址存储在一个表中，他们在表中的位置和功能号相对应。对应的关系为：功能号*2=对应的功能子程序在地址表中的偏移。
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title>曾经的考研日记</title>
    <url>/hobby-kaoyan-diary/</url>
    <content><![CDATA[本文转载自：http://www.cskaoyan.com/thread-45695-1-1.html
很多事情就像是旅行一样，当你决定要出发的时候，最困难的那部分其实就已经完成了。我不能在这里变老。我要在变老之前，做一些到了80岁还会微笑的事情。我想，一个人最好的样子就是平静一点，哪怕一个人生活，穿越一个又一个城市，走过一条又一条街道，仰望一片又一片天空，见证一次又一次别离。然后在别人质疑你的时候，你可以问心无愧地对自己说，虽然每一步都走得很慢，但是我不曾退缩过。
【站长日志十三】曾经的考研日记-能让你与众不同的只有心底的那个梦想

看到很多道友都在心路历程里写考研日记，所以把以前考研时候自己写的一些东西整理了一下，分享给大家，希望对大家有所帮助。这也许是我研究生毕业前写的最后一篇站长日志了，时间过得真的太快了。
浩帆先简单介绍一下自己的情况：
2003年9月开始在中南大学计算机专业读本科。2006年9月开始准备考研，目标哈工大本部，但是复习得很不好，初试分数仅比复试线高1分，复试被刷，软院不愿意去，然后二战；2007年8月开始第二次考研复习，目标浙大，然后来了浙大CS。
总有人一直问我为什么做王道，为什么一直不遗余力地投入精力做王道，这么没有技术含量的东西为什么我做得津津有味。是的，我反感考研，反感国家这套摧毁人创造力和浪费青年人时间的教育制度，也非常不喜欢考研辅导这个行当，但是当我看着自己无力的双手时，我明白要走到目的地，有时候需要饶个大弯。
我尊重的不是考研，而是考研学生的精神，是他们的梦想，仅此而已。
下面是自己两年考研中写的一些东西，我会用红色的文字交代当时的一些简单背景，方便大家阅读。文笔不好，各位道友不要扔鸡蛋

《最后的战斗》发表于2007年01月19日 12:20(考研前一天)
太阳出来了，天气也一下暖和了明天就要考试了，辛苦了半年，为的就是明天的战斗这半年所付出的辛苦，只有我自己最清楚无论从客观上，还是主观上，今年长沙的冬天都特别冷每天当我从暖和的被子里挣扎着爬起来的时候，我就对自己说，这是我的梦想，值得我不顾一切！
前天的大雪，早晨起来，当我把我的脚印印在还是一片雪白的大地的时候，当我回头去看身后一串的脚印时，我坚信上帝不会亏待我的，我相信自己的实力可以克服一切困难！1月19日 晴恩，沉着，冷静，完成这最后的狂欢！祝福所有为考研付出了辛勤汗水的战友：）加油，男人!!  

《Hope》发表于2007年02月08日 11:01
人应该怀有期待地生活,每天我都告诉自己今天会是新的一天,应该怀着期待的心情去迎接它.
从小,我就是一个独立的人,喜欢靠自己的力量去实现自己的梦想,在以前的小世界里,我一直认为只要你努力地付出,就可以实现你想要实现的期待.
慢慢的,我才发现世界有时候不是这样的.得到和付出有时候,也许是经常不成比例的.从来我都觉得自己是胜利者,从来我在乎的东西我就会拼命地付出,不允许任何人超过我.而今,我才发现我的力量是那么的有限,我的面前有太多太多的选择,有的要坚持,有的要放弃.我真的很怀念以前简单生活,只要读书学习,什么都不用操心.
我想我是真的长大了,懂得了很多以前不懂的东西,关于生活,关于工作,关于事业,关于友情,关于亲情,也关于爱情.爸爸一直希望我不要把过多的想法写在空间里,我写这些不是为了给谁看,也不希望空间会有多少人来看,只是想记录我的感受,为了给未来留下一些脚印,等到迷路的那天再回来看看.   
对于希望,我只想说,我把握不了这个世界,把握不了我的未来,也掌控不了别人的想法和行为.惟有一点,就是我是我自己的全部.我会坚持自己的信念,镇守自己的梦想,我不求凡事都能如我所愿,不奢望得到所有我想要的事和人,但是我仍会努力,一直努力,为了等到老了的那一天不至于留下悔恨的眼泪.结果有时候不是最重要的,重要的是你全身心付出的过程.加油,男人!
恩,我不求凡事如我所愿,但愿一切问心无愧！

《从头再来,绝不言败！》发表于2007年03月27日 13:32 (从哈工大复试回来，收到了没有被录取的消息)
2007年的考研,从准备到初试,从初试到出成绩,从知道成绩到学校划线,然后再是等待复试名单,接着面试,笔试,到今天发榜,落榜。这半年，付出了太多，虽然结果和想要的不一样，但是足够了，足够了。这次我失败了，但是，我会从头再来的，绝对不认输！

《北国之行–哈尔滨工业大学》发表于2007年03月27日 13:45 (失败那天写了个总结帖)
2007年3月20日 19：11踏上去哈工大复试的路，独自远行，有些悲壮，虽然初试分不高，但仍然希望能置之死地而后生。对北方，对哈工大计算机的向往，让我选择坚持！
2007年3月20日 19:23离开中南校门的时候，突然感觉到一种留恋，有些不愿意离开，面对未来的未知，心里还是觉得忐忑。但是既然选择了远方，就必须风雨兼程。
2007年3月20日 21：50 CZ6268 麦道90 长沙-哈尔滨第一次坐飞机，不过没有机会把飞机拍下来，空姐不漂亮，呵呵，其他就没什么感觉了。不过飞机提升时的那种感觉很好。
2007年3月21日 02：31下飞机，到达哈工大门口，第一次来北方，第一次远行，在凌晨的北国寒风下，记录下了熟睡中的哈工大。
2007年3月21日 09：23半夜在学校周围的小旅馆住了一晚，报到后分到了哈工大一公寓4029房，条件比中南要差很多，但是楼管阿姨很热情，所以感觉也很好。
2007年3月23日 09：00  -  09:22   地点：格物楼复试第一部分，面试。面试我是第四组的第一个，总共有五个老师，坐中间的年纪比较大，看起来很眼熟，感觉好象是计算机院的院士。当时没带眼镜，怕紧张，所以没有看仔细。面试基本上是  一个年轻老师和我的交谈，可能感觉我的英语口语不错，所以面试基本都用英语完成了，大概15分钟左右。不过题目比较难，接近微软的面试题目的形式。老师都很亲切，没有什么很大的压力。
2007年3月24日 08：30  -  11:30   地点：正心楼44 座位号360复试第二部分，笔试。笔试不难，但内容很多，面也很广。复试要考六门，难度真的很大。
2007年3月24日下午复试完毕，和刘岩他们一起去中央大街以及松花江去玩了一个下午。
2007年3月25日早晨天公做美，下了一场大雪，第一次见到这么大这么深的雪，学中的哈工大更加的具有北国气息，大气庄重，雪，真的很美。 

《期待新生活》发表于2007年03月30日 11:06 （考研没考上，女朋友也提出了分手）今年的考研彻底挂了,调剂也没有机会了.最近确实很颓废,很低落,失败的感觉原来是这么的不爽.今年很倒霉,许多的事情都已经证明了这一点,娘的,今年怎么这么背!不可以这么消沉,也不可以因为别人的放弃,自己也去放弃自己!生活要继续,生命也要继续学会忘记吧,振作起来,振作起来…..不要再让别人为你的消沉买单了,是大人了,要学会调整心态了.2007考研,今天彻底和你说Bye Bye,2008年,哥哥我会再来的!继续加油,男人!
从现在开始,我要和昨天彻底说拜拜!从今天开始,我不会再留恋你任何的东西!从今天开始,我要做回我自己!再见!Tomrrow will be another day! 

《凤凰涅磐》转载于2007年04月08日 00:55 （很喜欢的一段话）
只要能忘记曾经，你就能自由。你就能重生。
传说，凤凰涅磐，浴火重生。给人的感觉是火焰是凤凰的养料， 500年一次，当凤凰的生命快结束时，便会集梧桐枝于自焚，在烈火中新生，其羽更丰，其音更清，其神更髓。但给我的感觉就是：它的重生，是建立在濒死的境地上。也就是说，如果弄不好，它就会坠入万劫不复之地。凤凰涅磐，是重生还是死亡？
你曾经有过短暂的让人耳晕目眩的幸福感。有种高高在上的优越感。那时，那刻，都是刻骨铭心的，都是随时想来就好比刚发生在你身边一样。所有人，所有事，都无比清晰。同样的，经过高峰之后不可避免的走向了使你身心都消沉的深谷。失败使你原本快乐的心变得怯懦，使你坚强的神经变得软弱，使你学会了逃避，学会了消沉、放纵自己。你就像一个濒死的凤凰一样，可悲而可叹。哀莫大于心死！
不要再悲伤，不再有那些蚀心焚骨的回忆，让我们在这里涅磐……没有人的一生是一帆风顺的，也没有人的感情世界是一成不变的，凤凰尚能涅磐,我们一样能做到。人都是在经历过坎柯之后,才会变得越来越坚强的。
人生是不能保存的，你一定要尽量享受它。没有爱和不能享受人生，就没有乐趣。” 有很多的事情我们无法预知,当它到来的时候也束手无策,我们痛苦,迷茫,既然它要变,我们就接受它好了,既然改变不了什么,我们只有改变自己，如果你再不改变、再不醒悟、再继续沉沦、放纵自己，你何时才能“涅磐”而我对你的希望也将一步一步的走向死亡…
生命像桥，给我们两种选择。驻足，似乎是风和日丽的恬然，前行，似乎就是苦涩的缠绵和沉溺。我选择了后者，因为我心中有一个永不凋谢的梦想。因为我知道我这一生只能活一次，所以不愿再徘徊。深刻的知道以前虚度了很多，沉沦了很久，从来相信自己是一只高贵的鸟，如凤凰般的灿丽，但我知道以前不是，现在也不是。前行。需要鼓足生命的勇气。艰难的前行。需要付出沉重的代价。涅磐，是勇士的壮举。再生之凰，骄傲、忧伤，凡尘两忘、宛若天神。
我努力在进化我自己，那么就让烈火来一次彻底的，来一次风暴式的洗礼吧！在焚烧之后，不过是涅磐或再生，那么，就让生像死一样圣洁，让死像生一样灿烂。即使是伤痕，也会美丽得让人嫉妒……
凤凰涅磐，不是死亡，而是永生…… 

《重心》发表于2007年04月09日 21:34 （考研失利的阴影持续了很久很久）
现在的生活象没有了重心天亮,天黑,生活就这样地过了一天又一天脾气也有些暴躁周围的朋友很多都考上研了,真的很为他们高兴,真的!不过自己心里却更加的失落虽说难度不一样,但是结果却是一个标准
最近倒霉的事情一件接着一件,我也只好认为上帝是在考验我所有的报复都在我最脆弱的时候无情地到来,一下子觉得这个世界冷冰冰的.不过,我真的坚强了很多很多,不知道是看淡了,看轻了,还是有些东西到了另外的一个层次了
要做到完美很难,要忍受太多的苦,为什么自己还要逞强,为什么还是不愿意去放弃!还剩下些什么,还剩下些什么!!!为什么还是执迷不悟?!我也不清楚自己在坚持什么!梦想对我,就真的这么重要吗?我很想做超人,想去保护所有我在乎的人,不想他们无助,而现实却是我离这个目标越来越远了,尽管如此,还是要前行,一直走下去,直到筋疲力尽,不可以让任何人失望,再累再累…… 

《乱了节奏》发表于2007年04月27日 13:23 （毕业设计中）
最近的生活真的很混乱,每天睡到11点,晚上两三点才舍得睡觉。毕业设计进展缓慢，心里也是比较着急的。转眼就快到5月了，已经能够嗅到大学生活结束的气味了，伤感没有，有的只是一种迷茫。
我真的恨自己的执着，有时候妥协一下，也许会活得轻松许多，为什么老是要给自己那么高的要求，又为什么老是这么贪心，上帝很公平，不会把所有好的东西都给你的。
没有节奏的生活是我最厌恶的。我的生活必须有我自己的节奏，至少现在是的，今年又将是非常辛苦的一年，我称之为涅磐，不为过。昨天妈妈打电话来，问我为什么这么久不打电话回家，问我五一回不回家。不打电话，是有愧。不回家，是不好意思。我知道，我还是让他们失望了，多少是这样的，07的考研，我想，这是我唯一遗憾的。因为让爸爸妈妈失望了，而其他的，都可以接受。失败已经过去了，失落也已经过去了，现在的我又有了勇气去面对生活。
我感谢那些伤害过我的人，虽然你们让我看到了世界的丑恶，但是也谢谢你们让我坚强，虽然这不是你们的本意。我从来都相信自己是高贵的鸟，所以可以高高的昂着头。    该和堕落说再见了    而我将继续前行    男人，加油！

《回家啦!》 发表于2007年04月30日 11:34 （考研失败后第一次回家，家真的是温暖的避风港）
回家了,熟悉的房间,熟悉的后山天气很好,阳光加上舒适的气温消魂的汤安静的房间大大的写字桌哈哈我回家啦!一切都好!

《The Olds》 发表于2007年05月05日 11:14 （记得那天在抽屉里翻出了一些高中喜欢的小东西）
第一段
孙燕姿梁静茹无印良品
第二段
人生若只如初见何事秋风悲画扇
第三段
很多人只适合初见,因为没有未来.而有些人适合一直走下去,因为看得到未来.
第四段
回到家里,熟悉的一切,抽屉里的CD盒,曾经喜欢的歌手,曾经喜欢的歌曲淡淡的有些陈旧的味道见了些很久没见的人,说了些很久没说的话,走了些很久没走的路听人讲起高中时候的我听朋友说上课的时候老师把我当做榜样用来教育他们呵呵再看看现在的自己,无神的眼光,无章的生活,迷茫的目标还要多久才能走出去The day is far awayMaybe?orActurely?

《走吧,远行的人.》发表于2007年05月05日 23:36
这个世界上有很多事情,以为明天一定可以再继续做的;有很多人以为一定可以再见到面的,因此当那么多琐碎的误会,将我们慢慢地慢慢地错开,却不曾去在意.　 于是,暂时放下手,或者暂时转过身的时候,你心中所有的,只是明日又重聚的希望.因为,你以为日子既然这样一天一天过来.当然也应该这样一天一天过去,昨天,今天,明天,每一天应该是没有什么不同的.但是,就会有那么一次,在你放手,一转身的一刹那,有的事情就完全改变了.太阳落下去,而在它重新升起以前,有些人,就从此和你永别了.
人生是个苍凉的手势,生命是一袭华美的袍,上面爬满了蚤子,这世上没有一样感情不是千疮百孔的感情.
后来我知道,必须接受生命里注定残缺和难以如愿的部分.要接受那些被禁忌的不能见到光明的东西.在这个世间.有一些无法抵达的地方,无法靠近的人,无法完成的事情,无法占有的感情,无法修复的缺陷.
因此,我便借用了忘记,可是岁月老人却无情的考验我,原来忘记是这个世界最无用的方法.因为有些人从一见面的那一刹那,就注定是你永远也不会忘记的,无论一百年也好,一千年也好,你以为自己完全忘记了,但是不知道什么时候,或者在哪,会无声无息地出现在你的脑海里,你以为自己可以一笑置之,但是还是一丝酸痛. 

《有一种责任叫做长大》转载于2007年05月12日 10:43
时渐渐，我们长大了，从瓜瓜坠地的第一声哭泣，到懵懂无知的孩提；从年少轻狂的昨天，到理智果敢的今昔。而我们的父母却在不知不觉中老去，辛勤的工作，简朴的生活，换来了我们蓬勃的生机；沧桑的面容，斑白的双鬓，是无情岁月残留下来的痕迹。  
长大，是一种责任。长大，就意味着我们要独自去面对、去承担身边的一切，无论是酸的、甜的、苦的，抑或是辣的，因为我们已经懂事，已不再是那个曾经赖在父母怀中撒娇的淘气小孩。  
小时侯，如果遇到了伤心的事，我们可以在父母面前哭个痛快，然后转身将它轻轻忘记，不留痕迹。而今，有了心事却只能埋在心底，强作笑颜，不露出丁点的蛛丝马迹，因为怕他们知道后比我们还焦急，平添一份多余的担心。  
小时侯，为了吸引身边小朋友羡慕的眼光，我们总是哭喊着缠着父母要买这买那，以满足心中那小小的欲望和虚荣心。而今，每次用完了身上的钱，总是开不了口，不知该如何启齿跟家里面要钱；胡乱花钱的时候，总有一种负罪的感觉。何曾想过，我们手中的点滴要通过他们多少个面朝黄土背朝天的辛勤劳动才能换取？  
小时侯，从来不知天高地厚，从来不懂关心与否，总是闲父母说话过于罗嗦唠叨，不耐其烦，总是听不进劝告的只字片语，我行我素。而今，当我们已身在异地他乡，才发现唠叨是一种关怀、一份爱，他们总是无厌，默然为我们驱赶了身边的一切逆流。  
小时候，总是在内心埋怨，束缚了我们太多的自由，总是努力张开翅膀，想冲破身上的樊笼，飞翔外面自由精彩的天地。而今，终于明白，家才是我们心灵停泊的唯一港湾。那里没有工作的重重压力和生活的种种烦恼，也没有钱权的勾心斗角。那里只有无尽的亲情和爱，与生俱来，割舍不断。  
从小到大，在我们身上承载了父母太多的爱和汗水，浓缩了无数的担心和泪水。现在，我们已有责任和能力去独自面对一切的挫折困境，不能再让他们来为我们分忧解愁，为我们担惊受怕。因为，他们都已在时光的脚步中逐渐苍老，经不起更多的风雨。  
路漫漫，我们长大了，有一种责任就叫长大！自己再加一句,男人更甚!

《毕业的气息》发表于2007年05月16日 09:54 （本科快毕业了）
刚照完毕业照回来,这个学期难得看到一个班的同学聚在一起.淡淡的毕业气息,从每个人的脸上都能感觉得到.从公司实习回来的,脸上都写着疲倦和无奈,尽管都拿到了人生的第一次的工作;保研和考上研的,似乎是最幸福的,依然在享受着快乐的校园生活;还剩下的,就是我这样没工作,也没考上研的人,依然还有很多的路要走,依然还要付出很多努力,才能够实现自己的梦想.恩,有梦想的人是幸福的,一直都是这样想的,一直都是这样做的.
前两天喝酒喝多了,和GJ,嫂子和表哥,大家都喝多了,其实我知道都是为了陪我喝.当时,突然想起宿舍里的几个好兄弟,就打了个电话给凯子,说喝多了,想说些肉麻的话.和每个人都说了很久,我不记得这个电话打了多久,只记得他们说要来接我,呵呵,来本部这两年,一直都是他们陪着我,被人伤的时候陪我喝酒抽烟,什么都不想做的时候陪我玩游戏,他们总能给我快乐,给我感动.以前一直觉得在长沙我很孤独,现在却发现我忽略了很多.而现在懂得,还不晚.
老大还会继续北大,光光找个好工作问题肯定不大,玮哥应该也会工作,我和凯子还要继续考研,张旭应该会回北京.现在都是大家辛苦奋斗的时候,我想我们508的,几年以后,绝对不会有混得不好的,哈哈,等候我的召唤吧,孩子们.最近喜欢上了Kelly Clarkson,FS介绍的,感觉确实不错:)

《2007-5-24 5:24》发表于2007-5-24 5:24（关于足球）
刚看完冠军杯,AC赢了,利物浦输了.对我而言,其实谁赢都一样.自从没有了Zidane,我也不会再为哪只球队去疯狂.对于这比赛,客观地,只能说该赢的没有赢,他们做得很好,真的很好,还有就是他们的坚持与不放弃.而我也注定是与失落为伍,而我也只是个等待涅磐的孩子而已.
很容易为了那些有王者气质的人或者事的倒下而感叹,去年的这个时候,当Zinade离开的时候,拼命才忍住自己的眼泪.谋事在人,成事在天,这句话越发觉得深刻.只希望Zidane不要为此留下遗憾,而他也将成为我生命里的一个唯一,不会褪去的经典.
这段时间想起了很多人,很多事,很多迷恋的东西.阿才,咸鱼,文强,川,周圆…发现原来我的人缘这么好.孙燕姿,梁静茹,无印良品,王力宏…发现原来曾经我也如此的可爱.突然很怀念高中,怀念那个学校,那个没有草的足球场地,那件17号的球衣,和那颗这辈子都没有机会再现的进球,怀念那个给了我快乐和骄傲的高中.而这些渐渐离我远去,因为生活在继续,因为生命在拓展,无论宽度还是深度.
渐渐迷上了星座,B型的狮子,惊讶发现与我是如此之相象.而骨子里隐藏的那股成王的野心,似乎愈发难以掩盖.可是现实却将我泼醒.毕业了,也失业了,也没书读了,恩,是社会青年了.很多时候犹豫过,这条路走得值得不值得.每次我依然能将自己说服.我明白梦想对我的重量,也更清楚最珍贵的东西是要靠自己的双手去创造的.所以,我选择不放弃.08年,我将继续,浙大,不会再让你溜走,我清楚,有些事情需要运气.
望着窗外微亮的天空,看着四周床上陪伴了我四年的好兄弟们,只想说,男人们,继续坚持,继续加油,一切都会如愿的.真的勇士必将永远战斗! 

《怀念Zidane。》发表于2007年07月10日 01:12
去年的这个时候。我在等待世界杯决赛的开始。那时候是一伙的人。
今年的这个时候。已经没有再在等待什么了。惟独怀念那个让我着迷的Zidane。自从他离开，我对心爱的足球也变得淡漠起来。
长沙的夏天热得让人抓狂。不过我喜欢夏天。或者是因为我是夏天出生的狮子吧。喜欢炽热的太阳以及眩目的阳光。脑子很难清醒，每天昏昏的。突然想起以前高中特别喜欢在夏天午后和同学一起去踢足球。而现在却懒散得象只毛毛虫，躲在自己阴翳的房子里。也突然觉得自己的心老了。最近特别迷车，也特别想有辆自己的车。想要BMW。感觉很俗。不过其实俗的，低级趣味的追求往往最真实。
我还是喜欢深夜里的自己，仿佛灵魂回归了身体，安静得象另外一个人。夜晚除去自己的外壳，看着干净的自己，能感到无比的轻松。冲杯果汁，开着些颓颓的音乐，偶尔点根烟，其实不是为了抽，只是喜欢这样的感觉。敲着键盘，就能让整颗心沉淀下来。静静地听自己心的声音。心会说话。
Zidane也是一个干净的人，我依然保留着自己对他的着迷。他身上有太多我喜欢的优点。优雅也许是法国人的招牌。而他也许是优雅的招牌。我一直欣赏这样的男人，低调，执着，忠于自己的梦想，严肃而又不失浪漫，在实现自己事业的时候，也能把自己的家庭照顾得很好。这样的男人。很棒。怀念Zidane,不只是怀念一个经典,而是去憧憬一个未来的我。男人,加油前行。

《男人,加油。》  发表于2007年07月22日 17:50 （第二次考研复习开始）又想起了去年的这个时候。在家。伴着一场雨开始考研复习。今天长沙也刮起了大风，下起了大雨。久违的清爽让人脑子顿时清醒。接近一个月的混乱生活。不过脑子始终没有停止思考。最近看了很多事，见了很多人，说了很多话。从他们身上学到了很多东西。谢谢他们给我的建议，鼓励以及支持。我很幸运。每每在转折的时候都会有一个人把我带离黑暗，这次也如此。
出国的打算也泡汤了。其实挺向往日本。尽管心里有些抵触。但东京工大着实勾起了我的欲望。在中南的四年让人感觉到平淡。所以要离开。哈工大很好，但复试去了之后，还是感觉那氛围完全不适合我，所以要换。有些时候心里还是会羡慕周围那些调剂了的战友，毕竟也算有了着落。而我，飘啊飘，还真的象个无业游民。每天看着后街那乱七八糟的布局。真的感觉自己是被流放的。不过我就是我，不会低头，不会妥协，想要的就一定要得到，而且要最好的，否则还不如不要。
去年的复习真的很辛苦，接近四个月每天起早贪黑。依然清楚地记得自己一个人走在早晨大雪里的情景。复试被刷也让我真的感觉到老天很无聊。捉弄我这样认真的人。不过老爸也说了，我是该受受挫了。什么事情都太顺，对男人没什么好处。我就暂且是当做老天在考验我好了。
明天去看看爷爷奶奶。25号回来。然后收心看书。想清楚了。就应该开始行动。如果杭州真有老大说的那么好。我一定好好加油。考上浙大。
以后不会经常上网上Q了。手机号码没变，有事情电话联系。各位在外工作的朋友要加油赚钱，读研的朋友要认真学习，哈哈。以后要带着小弟我。涅磐吧。总有一天我有属于我的天。男人。加油。继续前行。 

《给自己的一些话 》 发表于2007年08月26日 23:56 （推荐：最伟大的推销员）
我不是为了失败才来到这个世界上的，我的血管里也没有失败的血液在流动。我不是牧羊人鞭打的羔羊，我是凶猛威武的狮子。我不与羊群为伍，我不想听失意者的哭泣，抱怨者的牢骚，这是羊群中才会有的瘟疫，我自然不能被它传染。失败者的屠宰场不是我命运的归宿。
坚持不懈，直到成功。
生命的奖赏永远在旅途的终点，而非起点，或者起点附近。我不知道要走多少步才能达到目标，踏上第一步的时候，我就知道我可能会失败。但成功永远都藏在拐角后面，除非拐了弯，否则我永远都不知道成功离我还有多远。
我绝不考虑失败。我的字典里没有放弃、不可能、办不到、没办法、成问题、行不通、没希望、退缩……这类愚蠢的字眼。我要尽量避免绝望，一旦受到它的威胁，我就要坚强和勇敢起来向它挑战。我要辛勤耕耘，忍受苦楚。我放眼未来，勇往直前，不再理会脚下的障碍。我坚信，沙漠尽头必是绿洲。
长沙的炎热已经过去。我已经扛过了这个炎热的夏天。每天的教室生活虽然辛苦但是值得。离梦想还有距离。但要坚持到底，一定成功！ 

《别人的狂欢,我的寂寥！》 发表于2007年09月04日 20:00
反常的长沙有了秋天的味道。远离了夏天的狂烈,人也开始平静下来。每天重复地做一件事情。每天有规律的起居。很有节奏。
开学了。身边的人都陆续去学校报道了。喜悦写在脸上，写在字里行间。乱七八糟的后街，让人烦乱的生活。也想过，如果不要求那么高，也就不用辛苦多这一年了。
最近读了本书，世界上最伟大的推销员。读完只有一种感觉。要做个有力量的人。要用自己的力量为在乎的人撑起坚不可摧的保护伞。学着低调。学着用行动说话。你们的狂欢,我的寂寥。我依旧在坚持，依旧在等待，等待一切最终爆发的那一刻。谢谢李鹏,也谢谢宝宝。137！

《菩萨保佑》 发表于2008年03月03日 01:31 （考研成绩公布前两天）菩萨保佑。两年考研，两年都认真复习了。发挥也正常了。一定不要出什么乱子啊。菩萨保佑菩萨保佑，一定让我这个认真的孩子圆梦吧。bless~

《谢谢菩萨》 发表于2008年03月06日 01:31 （考研成绩公布啦！！）我都不敢相信这是我考的分数。两年的付出，冷暖自知。终于拨云见日了。继续努力！谢谢菩萨！

《写给彷徨的人们》 发表于2008年03月10日 17:01
从5号出成绩到今天，日子一直很混乱，晕眩的幸福感一直环绕着我。心情一直没有平静下来，自然也没有时间去写点东西。毕竟两年的压抑和期待，才换来了如今的爆发。
我想我是勇敢的，我想我是好样的，回头去看看这两年所走过的路，自己都觉得不可思议。高中的时候觉得浙江大学这样的学校简直就是这辈子都不可能去读的学校，而现在回头看看，其实没什么，因为我有足够的力量去挑战它了。在中南的5年，尤其是考研的这两年，学会了太多的东西，这笔财富不是书本上能学到的，很珍贵。
彷徨的人们，尤其是那些要考研的人们，不要把别人当做依靠，当做精神的动力，人只能靠自己,没有人会真正的理解我们!只有结果才能证明我们是强者!否则无论我们的心灵被摧残到什么程度都没人关心!保持一颗平常的心让人生的道路变的平坦而没有波澜!!让生活的重心都放在学习和工作上，不要让你的生命苍白和无趣!成就了未来成就了希望!!一个好的心态就是成功的关键!坚持到底,一定会成功!
以后还有很长的路要走.还要好好加油,好好复试,等拿到录取通知书了.再好好记录这两年的一切.我为自己留下些脚印,等到迷路的时候再回头来看看.男人,继续努力! 

《总算拨云见日.》 发表于2008年04月10日 21:02   
录取名单总算出来了.一切也最终尘埃落定.总算考上了.也总算拨云见日了.本以为现在的我会有多么地兴奋和快乐,可是当一切变成结果的时候,我却只是微笑地告诉自己,成功了,又可以去面对一个新的未来了.
写下这些文字的时候,过去所经历的一点一滴,都还是那么清晰.我想很多人看到的都是我现在成功的一面,而这背后我所经历的所有辛酸,只有我自己知道.多少个煎熬的夜晚,多少个刺骨的早晨,多少次与自己的斗争……冷暖自知!考前我就想过,我一定尽力而为,但绝对不奢求结果如我所愿.但是我知道,我是幸运的,我成功了.
谢谢爸爸妈妈,谢谢他们给了我一个健康的身体和聪明的脑袋,谢谢他们的理解和支持,更谢谢他们给了我一个无比温馨的家,让我可以安心的去与困难战斗.谢谢宝宝,两个人一直互相鼓励互相帮助,宝宝也公费了,真好.
谢谢高中和本科的同学们,经常发信息鼓励和问候我,谢谢.你们对我的好,我真的很感动,谢谢你们,我的好朋友们!谢谢在6楼一起奋斗的战友们,因为你们,我才战胜了孤独和寂寞.谢谢所有关心和支持我的人!
这次虽然考上了,但是这次的浙大之行,让我感觉到了外面的世界这么的大,厉害的人这么的多,以后的路还很长,所以不能骄傲要继续加油!男人,继续加油!谨以此文纪念我的考研生活!
]]></content>
      <categories>
        <category>爱好</category>
        <category>读书</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>励志</tag>
      </tags>
  </entry>
  <entry>
    <title>图书管理系统之Spring JPA</title>
    <url>/dev-bookmanage-persist/</url>
    <content><![CDATA[前言这一个小系列的项目实战，郝同学会尽可能解释清楚每一个细节。有些内容在以前的文章中已经写过，这次就当复习了。
Maven父工程新建工程1、打开Eclipse，File，New，Maven Project，勾选Create a simple project，Next。


2、填写Group Id和Artifact Id，Packaging选择pom。如下图：解释：Maven是一个四维的仓库，里面存在着无数的jar包。四维向量分别是GroupId、ArtifactID、Version、Packaging，创建Maven工程的时候，需要输入这四个参数，其中Version默认为0.0.1-SNAPSHOT，Packaging默认为jar。上图相当于命令：
mvn archetype:create -DgroupId=com.voidking.book -DartifactId=book-persist
然后把pom.xml中的packaging改成pom。其中需要注意的是，在根目录下无法使用mvn命令，比如“E:\”。
pom.xml详解pom.xml文件，是Maven的核心。
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;	&lt;groupId&gt;com.voidking.book&lt;/groupId&gt;	&lt;artifactId&gt;book-parent&lt;/artifactId&gt;	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;	&lt;packaging&gt;pom&lt;/packaging&gt;		&lt;!--聚合模块，一条命令就能构建三个模块--&gt;	&lt;modules&gt;		&lt;!--module的值是以当前POM为主目录的相对路径--&gt;		&lt;module&gt;../book-persist&lt;/module&gt;		&lt;module&gt;../book-logic&lt;/module&gt;		&lt;module&gt;../book-ui&lt;/module&gt;		&lt;!--使用继承的话，parent也要加入这里--&gt;		&lt;!--（但是个人实验证明，不加也可以）--&gt;		&lt;module&gt;book-parent&lt;/module&gt;	&lt;/modules&gt;		&lt;properties&gt;		&lt;!--自定义属性值，一般用于统一版本--&gt;		&lt;struts.version&gt;2.3.1&lt;/struts.version&gt;		&lt;springframework.version&gt;3.2.4.RELEASE&lt;/springframework.version&gt;	&lt;/properties&gt;	&lt;!--dependencyManagement中配置的元素既不会给parent引入依赖，--&gt;	&lt;!--也不会给它的子模块引入依赖，仅仅是它的配置是可继承的。--&gt;	&lt;!--pluginManagement类似，它是用来进行插件管理的。--&gt;	&lt;dependencyManagement&gt;		&lt;!--在父POM中声明依赖--&gt;		&lt;dependencies&gt;			&lt;!-- struts2框架 --&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;				&lt;artifactId&gt;struts2-core&lt;/artifactId&gt;				&lt;version&gt;$&#123;struts.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;				&lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt;				&lt;version&gt;$&#123;struts.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;				&lt;artifactId&gt;struts2-json-plugin&lt;/artifactId&gt;				&lt;version&gt;$&#123;struts.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.apache.struts&lt;/groupId&gt;				&lt;artifactId&gt;struts2-convention-plugin&lt;/artifactId&gt;				&lt;version&gt;$&#123;struts.version&#125;&lt;/version&gt;			&lt;/dependency&gt;						&lt;!-- sql server 驱动 --&gt;			&lt;dependency&gt;				&lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;				&lt;artifactId&gt;sqljdbc4&lt;/artifactId&gt;				&lt;version&gt;1.1.1&lt;/version&gt;			&lt;/dependency&gt;						&lt;!-- mysql驱动 --&gt;			&lt;dependency&gt;				&lt;groupId&gt;mysql&lt;/groupId&gt;				&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;				&lt;version&gt;5.1.30&lt;/version&gt;			&lt;/dependency&gt;						&lt;!-- Oracle驱动 --&gt;			&lt;dependency&gt;				&lt;groupId&gt;com.oracle&lt;/groupId&gt;				&lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;				&lt;version&gt;10.2.0.3.0&lt;/version&gt;			&lt;/dependency&gt;						&lt;!-- Hibernat 4 --&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.hibernate&lt;/groupId&gt;				&lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;				&lt;version&gt;4.2.7.Final&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.hibernate&lt;/groupId&gt;				&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;				&lt;version&gt;5.0.1.Final&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.hibernate&lt;/groupId&gt;				&lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;				&lt;version&gt;4.2.6.Final&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;junit&lt;/groupId&gt;				&lt;artifactId&gt;junit&lt;/artifactId&gt;				&lt;version&gt;4.11&lt;/version&gt;				&lt;scope&gt;test&lt;/scope&gt;			&lt;/dependency&gt;			&lt;!-- Spring 核心库 --&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.springframework&lt;/groupId&gt;				&lt;artifactId&gt;spring-context&lt;/artifactId&gt;				&lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.springframework&lt;/groupId&gt;				&lt;artifactId&gt;spring-core&lt;/artifactId&gt;				&lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.springframework&lt;/groupId&gt;				&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;				&lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.springframework&lt;/groupId&gt;				&lt;artifactId&gt;spring-orm&lt;/artifactId&gt;				&lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.springframework&lt;/groupId&gt;				&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;				&lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.springframework&lt;/groupId&gt;				&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;				&lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;			&lt;/dependency&gt;						&lt;!-- Spring MVC 库 --&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.springframework&lt;/groupId&gt;				&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;				&lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.springframework&lt;/groupId&gt;				&lt;artifactId&gt;spring-web&lt;/artifactId&gt;				&lt;version&gt;$&#123;springframework.version&#125;&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt; org.aspectj&lt;/groupId&gt;				&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;				&lt;version&gt; 1.6.11&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;				&lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;				&lt;version&gt;1.4.1.RELEASE&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;org.slf4j&lt;/groupId&gt;				&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;				&lt;version&gt;1.7.5&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;log4j&lt;/groupId&gt;				&lt;artifactId&gt;log4j&lt;/artifactId&gt;				&lt;version&gt;1.2.17&lt;/version&gt;			&lt;/dependency&gt;			&lt;!-- 数据库连接池 --&gt;			&lt;dependency&gt;				&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;				&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;				&lt;version&gt;1.4&lt;/version&gt;			&lt;/dependency&gt;			&lt;dependency&gt;				&lt;groupId&gt;javax.servlet&lt;/groupId&gt;				&lt;artifactId&gt;servlet-api&lt;/artifactId&gt;				&lt;version&gt;2.5&lt;/version&gt;			&lt;/dependency&gt;		&lt;/dependencies&gt;	&lt;/dependencyManagement&gt;&lt;/project&gt;

Persist层工程新建工程1、File，New，Maven Project，勾选Create a simple project，Next。
2、填写Group Id和Artifact Id，Packaging选择jar。
pom.xml详解&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;	&lt;!--groupId和version省略了，因为使用了继承。--&gt;	&lt;!--还有一些继承的元素，详见之前总结的《Maven之pom.xml》--&gt;	&lt;artifactId&gt;book-persist&lt;/artifactId&gt;		&lt;!--写出parent的坐标和相对路径--&gt;	&lt;parent&gt;		&lt;groupId&gt;com.voidking.book&lt;/groupId&gt;		&lt;artifactId&gt;book-parent&lt;/artifactId&gt;		&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;		&lt;relativePath&gt;../book-parent/pom.xml&lt;/relativePath&gt;	&lt;/parent&gt;	&lt;!--真实依赖--&gt;	&lt;dependencies&gt;		&lt;!--只有子模块配置了继承的元素，才会真正的有效，否则不加载--&gt;		&lt;!--主要配置groupId和artifactId--&gt;		&lt;dependency&gt;				&lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;			&lt;artifactId&gt;sqljdbc4&lt;/artifactId&gt;			&lt;!--这里并没有指定version，因为继承了parent的version。--&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;mysql&lt;/groupId&gt;			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- Oracle驱动 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;com.oracle&lt;/groupId&gt;			&lt;artifactId&gt;ojdbc14&lt;/artifactId&gt;			&lt;!--当然，也可以覆盖父类的version。--&gt;			&lt;version&gt;10.2.0.3.0&lt;/version&gt;		&lt;/dependency&gt;		&lt;!-- Hibernat 4 框架 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.hibernate&lt;/groupId&gt;			&lt;artifactId&gt;hibernate-core&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.hibernate&lt;/groupId&gt;			&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.hibernate&lt;/groupId&gt;			&lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;			&lt;scope&gt;provided&lt;/scope&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;junit&lt;/groupId&gt;			&lt;artifactId&gt;junit&lt;/artifactId&gt;			&lt;scope&gt;test&lt;/scope&gt;		&lt;/dependency&gt;		&lt;!-- Spring 核心库 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-core&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-beans&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-orm&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-aop&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-tx&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- Spring MVC 库 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework&lt;/groupId&gt;			&lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.aspectj&lt;/groupId&gt;			&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.springframework.data&lt;/groupId&gt;			&lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- 日志打印 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;org.slf4j&lt;/groupId&gt;			&lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;log4j&lt;/groupId&gt;			&lt;artifactId&gt;log4j&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;!-- 数据库连接池 --&gt;		&lt;dependency&gt;			&lt;groupId&gt;commons-dbcp&lt;/groupId&gt;			&lt;artifactId&gt;commons-dbcp&lt;/artifactId&gt;		&lt;/dependency&gt;	&lt;/dependencies&gt;&lt;/project&gt;
聚合和继承的关系从上面两个pom.xml文件中，我们看到，模块聚合是写在父工程中的，而模块的继承则是写在子工程中的。
区别 ：1、对于聚合模块来说，它知道有哪些被聚合的模块，但那些被聚合的模块不知道这个聚合模块的存在。2、对于继承关系的父POM来说，它不知道有哪些子模块继承于它，但那些子模块都必须知道自己的父POM是什么。
共同点 ：1、聚合POM与继承关系中的父POM的packaging都是pom。2、聚合模块与继承关系中的父模块除了POM之外都没有实际的内容。注：在现有的实际项目中，一个POM既是聚合POM，又是父POM，这么做主要是为了方便。
新建包新建包com.voidking.book.entity、com.voidking.book.repository、com.voidking.book.service、com.voidking.book.service.impl。这样命名，比较规范。
其中，entity是数据映射层（有人习惯命名为domain，郝同学还是喜欢entity）；repository是一个独立的层，介于领域层与数据映射层（数据访问层）之间。它的存在让领域层感觉不到数据访问层的存在，它提供一个类似集合的接口提供给领域层进行领域对象的访问。Repository是仓库管理员，领域层需要什么东西只需告诉仓库管理员，由仓库管理员把东西拿给它，并不需要知道东西实际放在哪；service对业务逻辑层提供的访问接口；service.impl是对访问接口的实现。
entity包在entity包下，新建Admin.java文件，内容如下。
package com.voidking.book.entity;import javax.persistence.Column;import javax.persistence.Entity;import javax.persistence.GeneratedValue;import javax.persistence.Id;import javax.persistence.Table;@Entity@Table(name="admin")public class Admin &#123;		@Id	@GeneratedValue	private Long id;		@Column(length=20,nullable=false)	private String name;		@Column(length=20,nullable=false)	private String pwd;	public Long getId() &#123;		return id;	&#125;	public void setId(Long id) &#123;		this.id = id;	&#125;	public String getName() &#123;		return name;	&#125;	public void setName(String name) &#123;		this.name = name;	&#125;	public String getPwd() &#123;		return pwd;	&#125;	public void setPwd(String pwd) &#123;		this.pwd = pwd;	&#125;		public Admin() &#123;		super();	&#125;	public Admin(String name, String pwd) &#123;		super();		this.name = name;		this.pwd = pwd;	&#125;	@Override	public int hashCode() &#123;		final int prime = 31;		int result = 1;		result = prime * result + ((id == null) ? 0 : id.hashCode());		return result;	&#125;	@Override	public boolean equals(Object obj) &#123;		if (this == obj)			return true;		if (obj == null)			return false;		if (getClass() != obj.getClass())			return false;		Admin other = (Admin) obj;		if (id == null) &#123;			if (other.id != null)				return false;		&#125; else if (!id.equals(other.id))			return false;		return true;	&#125;		&#125;
1、@Entity注解标识实体Bean。2、@Table(name=数据库表名)注解，标识该实体Bean映射到关系型数据库中的表名3、如果不指定则JPA实现会自动生成默认的表名称。4、@Id注解标识主键。5、@GeneratedValue注解标识主键生成策略，@GeneratedValue(strategy=GenerationType.AUTO)是默认策略，相当于@GeneratedValue或者省略。

TABLE：使用一个特定的数据库表格来保存主键。 
SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列。（适用于oracle） 
IDENTITY：主键由数据库自动生成（主要是自动增长型，适用于sqlserver，mysql数据库中）
AUTO：主键由程序控制。 

6、@Column注解有name、unique、nullable、length参数。若不写@Column注解，则一切使用@Column注解的默认值。
在entity下，新建BookBase.java、BookKind.java、ReaderBase.java、ReaderKind.java、BorrowInfo.java，内容分别如下。
package com.voidking.book.entity;/** * BookBase *  */@Entity@Table(name="bookbase")public class BookBase &#123;	@Id	@GeneratedValue(strategy=GenerationType.AUTO)	private Long id;		@Column(length=100,nullable=false)	private String name;		@Column(length=100,nullable=false)	private String author;		@Column(length=100,nullable=false)	private String press;		@Column(length=50,nullable=true)	private String publishdate;		private Float price;		private Integer page;	@Column(length=100,nullable=true)	private String keyword;		@Column(length=50,nullable=true)	private String registerdate;		@Column(length=2,nullable=false)	private String borrowed;		@Lob	private String notice;		@ManyToOne(cascade=CascadeType.REFRESH)	@JoinColumn(name="bookkind")	private BookKind bookkind;		//setter和getter方法省略	&#125;
详细代码请移步https://github.com/voidking/bookmanage.git
1、JPA定义了one-to-one、one-to-many、many-to-one、many-to-many 4种关系。
对于数据库来说，通常在一个表中记录对另一个表的外键关联；对应到实体对象，持有关联数据的一方称为owning-side，另一方称为inverse-side。
为了编程的方便，我们经常会希望在inverse-side也能引用到owning-side的对象，此时就构建了双向关联关系。 在双向关联中，需要在inverse-side定义mappedBy属性，以指明在owning-side是哪一个属性持有的关联数据。
对关联关系映射的要点如下：



关系类型
Owning-Side
Inverse-Side



one-to-one
@OneToOne
@OneToOne(mappedBy=”othersideName”)


one-to-many/many-to-one
@ManyToOne
@OneToMany(mappedBy=”othersideName”)


many-to-many
@ManyToMany
@ManyToMany(mappedBy=”othersideName”)


关联关系还可以定制延迟加载和级联操作的行为（owning-side和inverse-side可以分别设置）：通过设置fetch=FetchType.LAZY 或 fetch=FetchType.EAGER来决定关联对象是延迟加载或立即加载。
通过设置cascade={options}可以设置级联操作的行为，其中options可以是以下组合：

CascadeType.MERGE 级联更新
CascadeType.PERSIST 级联保存
CascadeType.REFRESH 级联刷新
CascadeType.REMOVE 级联删除
CascadeType.ALL 级联上述4种操作

2、@JoinColumn(name=”bookkind”)注释本表中指向另一个表的外键。如果不指定name，它会自动帮你生成你指向这个类的类名加上下划线再加上id的列,也就是默认列名是:bookkind_id。
repository包在repository包下，新建AdminRepository.java，内容如下。
package com.voidking.book.repository;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Repository;import com.voidking.book.entity.Admin;@Repositorypublic interface AdminRepository extends JpaRepository&lt;Admin,Long&gt;&#123;	Admin findByNameAndPwd(String name,String pwd);&#125;
Repository（资源库）：通过用来访问领域对象的一个类似集合的接口，在领域与数据映射层之间进行协调。这个叫法就类似于我们通常所说的DAO，在这里，我们就按照这一习惯把数据访问层叫RepositorySpring Data给我们提供几个Repository，基础的Repository提供了最基本的数据访问功能，其几个子接口则扩展了一些功能。它们的继承关系如下：

Repository：仅仅是一个标识，表明任何继承它的均为仓库接口类，方便Spring自动扫描识别 
CrudRepository：继承Repository，实现了一组CRUD相关的方法 
PagingAndSortingRepository：继承CrudRepository，实现了一组分页排序相关的方法 
JpaRepository：继承PagingAndSortingRepository，实现一组JPA规范相关的方法 
JpaSpecificationExecutor：比较特殊，不属于Repository体系，实现一组JPA Criteria查询相关的方法 
我们自己定义的XxxxRepository需要继承JpaRepository，这样我们的XxxxRepository接口就具备了通用的数据访问控制层的能力。 

1、CrudRepository&lt;T, ID extends Serializable&gt;：这个接口提供了最基本的对实体类的添删改查操作 
T save(T entity);//保存单个实体 Iterable&lt;T&gt; save(Iterable&lt;? extends T&gt; entities);//保存集合 T findOne(ID id);//根据id查找实体 boolean exists(ID id);//根据id判断实体是否存在 Iterable&lt;T&gt; findAll();//查询所有实体,不用或慎用! long count();//查询实体数量 void delete(ID id);//根据Id删除实体 void delete(T entity);//删除一个实体 void delete(Iterable&lt;? extends T&gt; entities);//删除一个实体的集合 void deleteAll();//删除所有实体,不用或慎用!

2、PagingAndSortingRepository&lt;T, ID extends Serializable&gt;：这个接口提供了分页与排序功能 
Iterable&lt;T&gt; findAll(Sort sort);//排序 Page&lt;T&gt; findAll(Pageable pageable);//分页查询（含排序功能）

3、JpaRepository&lt;T, ID extends Serializable&gt;：这个接口提供了JPA的相关功能
List&lt;T&gt; findAll();//查找所有实体 List&lt;T&gt; findAll(Sort sort);//排序 查找所有实体 List&lt;T&gt; save(Iterable&lt;? extends T&gt; entities);//保存集合 void flush();//执行缓存与数据库同步 T saveAndFlush(T entity);//强制执行持久化 void deleteInBatch(Iterable&lt;T&gt; entities);//删除一个实体集合


1、简单条件查询:查询某一个实体类或者集合按照Spring data 定义的规则，查询方法以find|read|get开头 
2、涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性以首字母大写其余字母小写为规定。例如：定义一个Entity实体类class User｛    private String firstname;    private String lastname;｝使用And条件连接时，应这样写：findByLastnameAndFirstname(String lastname,String firstname);条件的属性名称与个数要与参数的位置与个数一一对应。
新建BookBaseRepository.java、BookKindRepository.java、ReaderBaseRepository.java、ReaderKindRepository.java、BorrowInfoRepository.java，详细代码请移步https://github.com/voidking/bookmanage.git
service包在service包中，新建BaseService.java，内容如下。
package com.voidking.book.service.impl;import java.io.Serializable;import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.repository.JpaRepository;public interface BaseService&lt;T,ID extends Serializable&gt; &#123;	public boolean isExists(ID id);		public T save(T t);		public void delete(ID id);		public void delete(T t);		public List&lt;T&gt; findAll();		public Page&lt;T&gt; findAll(Pageable pageable);		public Page&lt;T&gt; findAll(int page,int size);		public long count();		public T findOne(ID id);		void setJpaRepository(JpaRepository&lt;T, ID&gt; repository);&#125;
新建AdminService.java，内容如下。
package com.voidking.book.service.impl;import com.voidking.book.entity.Admin;public interface AdminService extends BaseService&lt;Admin,Long&gt; &#123;		Admin findByNameAndPwd(String name,String pwd);&#125;
问：我们只要entity包、repository包，就可以提供对logic层的服务了，为什么加一个service包呢？答：信息隐藏，封装实现细节！有了service负责给logic提供服务，那么，我们就不知道底层是用repository还是其他方法实现。
新建BookBaseService.java、BookKindService.java、ReaderBaseService.java、ReaderKindService.java、BorrowInfoService.java，详细代码请移步https://github.com/voidking/bookmanage.git
service.impl包在service.impl包下，新建BaseServiceImpl.java，内容如下。
package com.voidking.book.service.impl;import java.io.Serializable;import java.util.List;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.data.jpa.repository.JpaRepository;import com.voidking.book.service.BaseService;public class BaseServiceImpl&lt;T,ID extends Serializable&gt; implements BaseService&lt;T, ID&gt;&#123;	protected JpaRepository&lt;T, ID&gt; repository;		public boolean isExists(ID id) &#123;				return repository.exists(id);	&#125;	public T save(T t) &#123;				return repository.save(t);	&#125;	public void setJpaRepository(JpaRepository&lt;T, ID&gt; repository) &#123;				this.repository = repository;	&#125;	public void delete(ID id) &#123;				this.repository.delete(id);	&#125;	public void delete(T t) &#123;				this.repository.delete(t);			&#125;	public List&lt;T&gt; findAll() &#123;				return this.repository.findAll();	&#125;	public Page&lt;T&gt; findAll(Pageable pageable) &#123;				return this.repository.findAll(pageable);	&#125;	public long count() &#123;				return this.repository.count();	&#125;	public T findOne(ID id) &#123;				return this.repository.findOne(id);	&#125;	public Page&lt;T&gt; findAll(int page, int size) &#123;				return this.repository.findAll(new PageRequest(page, size));	&#125;&#125;
新建AdminServiceImpl.java，内容如下。
package com.voidking.book.service.impl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.jpa.repository.JpaRepository;import org.springframework.stereotype.Service;import com.voidking.book.entity.Admin;import com.voidking.book.repository.AdminRepository;import com.voidking.book.service.AdminService;@Servicepublic class AdminServiceImpl extends BaseServiceImpl&lt;Admin, Long&gt; implements AdminService&#123;	private AdminRepository adminRepository;	@Autowired	@Override	public void setJpaRepository(JpaRepository&lt;Admin, Long&gt; adminRepository) &#123;		super.repository = adminRepository;		this.adminRepository=(AdminRepository) adminRepository;	&#125;	public Admin findByNameAndPwd(String name, String pwd) &#123;		return this.adminRepository.findByNameAndPwd(name, pwd);	&#125;	&#125;
1、Spring2.5引入了@Autowired注释，它可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。不过，现在更推荐使用@Resource。
2、Spring不但支持自己定义的@Autowired注解，还支持几个由JSR-250规范定义的注解，它们分别是@Resource、@PostConstruct以及@PreDestroy。@Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按byName自动注入罢了。
新建BookBaseServiceImpl.java、BookKindServiceImpl.java、ReaderBaseServiceImpl.java、ReaderKindServiceImpl.java、BorrowInfoServiceImpl.java，详细代码请移步https://github.com/voidking/bookmanage.git
spring-persist.xml在src/test/resources文件夹下，新建spring-persist.xml文件，内容如下。
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans"	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"	xmlns:cache="http://www.springframework.org/schema/cache"	xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p"	xmlns:jpa="http://www.springframework.org/schema/data/jpa" xmlns:task="http://www.springframework.org/schema/task"	xmlns:tx="http://www.springframework.org/schema/tx"	xsi:schemaLocation="http://www.springframework.org/schema/aop 	http://www.springframework.org/schema/aop/spring-aop-3.2.xsd    http://www.springframework.org/schema/task     http://www.springframework.org/schema/task/spring-task-3.2.xsd    http://www.springframework.org/schema/beans     http://www.springframework.org/schema/beans/spring-beans.xsd    http://www.springframework.org/schema/cache     http://www.springframework.org/schema/cache/spring-cache-3.2.xsd    http://www.springframework.org/schema/tx     http://www.springframework.org/schema/tx/spring-tx-3.2.xsd    http://www.springframework.org/schema/context     http://www.springframework.org/schema/context/spring-context-3.2.xsd 	http://www.springframework.org/schema/data/jpa	http://www.springframework.org/schema/data/jpa/spring-jpa.xsd"&gt;	&lt;context:component-scan base-package="com.voidking.book" /&gt;	&lt;!-- 数据库属性文件 --&gt;	&lt;bean id="propertyConfigure"		class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;		&lt;property name="location" value="classpath:database-conn.properties" /&gt;	&lt;/bean&gt;	&lt;!-- 配置MySQL数据源 --&gt;	&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"		destroy-method="close"&gt;		&lt;property name="driverClassName" value="$&#123;database.driver&#125;" /&gt;		&lt;property name="url" value="$&#123;database.uri&#125;" /&gt;		&lt;property name="username" value="$&#123;database.username&#125;" /&gt;		&lt;property name="password" value="$&#123;database.password&#125;" /&gt;	&lt;/bean&gt;	&lt;!-- JPA 配置 --&gt;	&lt;jpa:repositories base-package="com.voidking.book.repository"&gt;&lt;/jpa:repositories&gt;	&lt;bean id="entityManagerFactory"		class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;		&lt;property name="dataSource" ref="dataSource" /&gt;		&lt;property name="packagesToScan" value="com.voidking.book.entity" /&gt;		&lt;property name="jpaVendorAdapter"&gt;			&lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"&gt;				&lt;property name="showSql" value="$&#123;hibernate.show_sql&#125;" /&gt;				&lt;property name="databasePlatform" value="$&#123;hibernate.dialect&#125;" /&gt;				&lt;!--  &lt;property name="database" value="$&#123;database.name&#125;" /&gt;--&gt;			&lt;/bean&gt;		&lt;/property&gt;		&lt;property name="jpaProperties"&gt;			&lt;props&gt;				&lt;prop key="hibernate.hbm2ddl.auto"&gt;update&lt;/prop&gt;				&lt;prop key="hibernate.connection.useUnicode"&gt;true&lt;/prop&gt;				&lt;prop key="hibernate.connection.characterEncoding"&gt;UTF-8&lt;/prop&gt;				&lt;prop key="hibernate.connection.charSet"&gt;UTF-8&lt;/prop&gt;			&lt;/props&gt;		&lt;/property&gt;	&lt;/bean&gt;	&lt;!-- 事务处理 --&gt;	&lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;		&lt;property name="entityManagerFactory" ref="entityManagerFactory" /&gt;		&lt;property name="jpaDialect"&gt;			&lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaDialect"&gt;&lt;/bean&gt;		&lt;/property&gt;	&lt;/bean&gt;	&lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt;		&lt;tx:attributes&gt;			&lt;!-- hibernate4必须配置为开启事务 否则 getCurrentSession()获取不到 --&gt;			&lt;tx:method name="find*" propagation="REQUIRED" read-only="true" /&gt;			&lt;tx:method name="update*" propagation="REQUIRED" /&gt;			&lt;tx:method name="delete*" propagation="REQUIRED" /&gt;			&lt;tx:method name="save*" propagation="REQUIRED" /&gt;			&lt;tx:method name="*" propagation="SUPPORTS" /&gt;		&lt;/tx:attributes&gt;	&lt;/tx:advice&gt;	&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;	&lt;!-- 事务处理配置完毕 --&gt;	&lt;aop:aspectj-autoproxy expose-proxy="true" /&gt;	&lt;aop:config expose-proxy="true"&gt;		&lt;aop:pointcut id="baseBizMethods"			expression="execution(public * com.voidking.book.service.impl.*.*(..))" /&gt;		&lt;aop:advisor pointcut-ref="baseBizMethods" advice-ref="txAdvice" /&gt;	&lt;/aop:config&gt;&lt;/beans&gt;
1、如果配置了context:component-scan那么context:annotation-config标签就可以不用在xml中配置了，因为前者包含了后者。在xml配置了前者后，spring可以自动去扫描base-pack下面或者子包下面的java文件，如果扫描到有@Component、@Controller、@Service等这些注解的类，则把这些类注册为bean。
2、PropertyPlaceholderConfigurer用于Spring从外部属性文件中载入属性，并使用这些属性值替换Spring 配置文件中的占位符变量（${varible}）。 
3、Spring配置文件中关于事务配置总是由三个组成部分，分别是DataSource、TransactionManager和代理机制这三部分，无论哪种配置方式，一般变化的只是代理机制这部分。
database-conn.properties在src/test/resources文件夹下，新建database-conn.properties文件，内容如下。
database.name=MYSQLdatabase.driver=com.mysql.jdbc.Driverdatabase.uri=jdbc:mysql://localhost:3306/bookdatabase.username=rootdatabase.password=voidking #hibernatehibernate.dialect=org.hibernate.dialect.MySQL5Dialecthibernate.show_sql=true
在mysql数据库中，新建book数据库。
log4j.properties在src/test/resources文件夹下，新建log4j.properties文件，内容如下。
log4j.rootCategory=INFO, stdout###. \u5b9a\u4e49\u540d\u4e3a stdout \u7684\u8f93\u51fa\u7aef\u7684\u7c7b\u578b log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout log4j.appender.stdout.layout.ConversionPattern=[Project] %p [%t] %C.%M(%L) | %m%n log4j.appender.stdout.encoding=UTF-8### .spring \u914d\u7f6e log4j.logger.org.springframework=ERROR ### . hibernate \u914d\u7f6e log4j.logger.org.hibernate=ERROR
log4j启动时，默认会寻找source folder下的log4j.xml配置文件，若没有，会寻找log4j.properties文件。然后加载配置。配置文件放置位置正确，不用在程序中手动加载log4j配置文件。如果将配置文件放到了config文件夹下，在build Path中设置下就好了。
单元测试在src/test/java文件夹下，新建包com.voidking.book.service，新建AdminServiceTest.java文件，内容如下。
package com.voidking.book.service;import org.junit.Before;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AdminServiceTest &#123;	private AdminService adminService;	@Before	public void prepare()&#123;		ApplicationContext ctx = new ClassPathXmlApplicationContext("spring-persist.xml");		this.adminService = ctx.getBean(AdminService.class);			&#125;	@Test	public void testAdminService()&#123;			&#125;&#125;

上面的测试，主要用来加载配置文件，检验配置文件是否正确，以及数据库的连接是否正常。
后记@Repository、@Service、@Controller和@Component都可以不用在xml文件里进行显式配置，他们都会被默认注册为Spring Bean。
参考文档JPA入门例子(采用JPA的hibernate实现版本)http://blog.csdn.net/hmk2011/article/details/6289151
Spring声明式事务配置管理方法http://www.cnblogs.com/rushoooooo/archive/2155960.html
@Repository、@Service、@Controller 和 @Componenthttp://blog.csdn.net/ye1992/article/details/19971467
Spring组件扫描&lt;context:component-scan/&gt;使用详解http://blog.csdn.net/a9529lty/article/details/8251003
 &lt;context:component-scan&gt;使用说明http://blog.csdn.net/chunqiuwei/article/details/16115135
使用注解来构造IoC容器http://www.cnblogs.com/xdp-gacl/p/3495887.html
使用Spring Data JPA 简化 JPA 开发http://www.ibm.com/developerworks/cn/opensource/os-cn-spring-jpa/
实用的代码规范–SpringSide Coding Standardshttp://blog.chinaunix.net/uid-9354-id-2425025.html
Repository（资源库）模式http://blog.csdn.net/happinessmoon/article/details/7708785http://www.cnblogs.com/dudu/archive/repository_pattern.html
@GeneratedValuehttp://blog.csdn.net/fancylovejava/article/details/7438660
JPA常用注解http://1194867672-qq-com.iteye.com/blog/1730513
@JoinColumn详解http://blog.sina.com.cn/s/blog_64e8d29b0100z7hx.html
hibernate的注解属性mappedBy详解http://shenyuc629.iteye.com/blog/1681225
JPA概要http://www.cnblogs.com/holbrook/archive/2839842.html
主键中mappedBy的具体使用及其含义http://blog.sina.com.cn/s/blog_697b968901016s7f.html
简单的Spring JPA实现例子http://blog.csdn.net/kongxx/article/details/5653370
spring mvc的jpa JpaRepository数据层访问方式汇总http://jishiweili.iteye.com/blog/2088265
Spring @Autowired详解http://my.oschina.net/u/138995/blog/181626?fromerr=x1lK5xJq
Spring注解http://www.360doc.cn/article/495229_37264450.html
Spring注解讲解http://www.douban.com/note/71602488/
Spring及springmvc注解(annotation)使用详解http://www.360sdn.com/springmvc/2013/0627/407.html
context:component-scan使用说明http://blog.csdn.net/chunqiuwei/article/details/16115135
Spring配置之PropertyPlaceholderConfigurerhttp://bjyzxxds.iteye.com/blog/427437
Spring事务Transaction配置的五种注入方式详解http://blog.csdn.net/yaerfeng/article/details/28390773
log4j，如何“自动加载”？http://www.cnblogs.com/alipayhutu/archive/3028249.html
log4j.properties配置与加载应用http://blog.csdn.net/javaloveiphone/article/details/7994313
log4j.properties路径问题http://blog.csdn.net/caomiao2006/article/details/22062001
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>maven</tag>
        <tag>jpa</tag>
      </tags>
  </entry>
  <entry>
    <title>考研英语</title>
    <url>/en-kaoyan-english/</url>
    <content><![CDATA[前言使用百词斩，背了三个月的单词，却放弃了6月份的六级考试。虽然单词量有了，但是对于实际做题，用处却不大。
背了很久的考研词汇，今天做了一篇考研阅读理解，却被虐哭了。越发感觉到，单词，似乎没有想象中重要。
穷则思变，更新一下英语的学习方法吧！
学习英语，不外乎听说读写。考研初试，只考读写，就先从这两方面下手。听，六级前准备；说，复试前准备。


阅读阅读要领1、以句子为中心，学会分析句子结构，提高看懂句子的能力！
2、做真题，通过阅读背单词，记住单词在文章中的义项就够了！
3、文章没有研读熟悉（10遍以上）之前不要核对答案。

促使你反复去思考文章。
促使你反复研读文章。
促使你带着问题研读文章。
促使你做题思路与命题思路接轨。

4、核对答案，请同学帮忙，只告诉你错了几题。
5、100篇文章读一遍，不如10篇文章读十遍。争取每篇真题研读30遍，六个正字！
6、阅读顺序：

第1遍，分析句子结构，找出主句。


批注格式：生词，横线；可省略（比如形容词副词性从句），括号；可拆分（比如名词性从句），斜杠。


第2遍，搞清楚句中每个单词在文中的义项。（专有名词除外）
第3~30遍，目标做到词词都熟悉，句句都能不假思索地给别人讲清楚。熟悉句子结构；不熟的单词，闭眼记忆，用手指在身上写几遍；每阅读一遍，都把题目做一遍或思考一遍，比较一下与自己上次选的答案是否一致。

7、做笔记做好用铅笔，以便修改或擦掉。
8、真题解析书，我们只看两部分，一是文章，二是试题解析。我们只能对给定的文章进行分析，根据给定的文章选出正确答案，我们必须自己去悟！
9、滚动研读时，脑子里要快速反应出单词的意思、句子的意思及句子的结构。
10、句子结构 &gt; 句子大概意思 &gt; 句子具体意思
划分句子巧妙创建断点句子语义的完整性是判断断点的唯一标准。
Do you remember all those years / when scientists argued that smoking would kill us / but the doubters insisted that we didn‘t know for sure？
That sex ratio will be favored / which maximizes the number of descendants / an individual will have and hence the number of gene copies / transmitted.
适当加词是不是，有没有，能不能
理顺句子结构What is harder to establish is / whether the productivity revolution that  / businessmen assume they are presiding over / is for real. 
句子概述简单句简单句=主语+动词。所有的句子都可以看做由简单句变化而来。
主语1、名词，可以用名字呼唤。John works hard.The child is cute.
2、代词She is beautiful.It is good.
3、动名词，动词变的名词。（发生过）Working with him is fun.Studing English is interesting.
4、不定式（未发生）To buy something is my plan this afternoon.To study abroad is my dream.

短语是由两个以上单词构成的字群。动名词短语：Working with him不定式短语：To buy something


短语作主语时，主语过大，使用it作虚主语，真主语移动到句尾。It is fun to work with him.It is my plan to study abroad with my girlfriend who is very pretty.


不定式由 to+动词原形 构成，在句中起名词、形容词和副词的作用。

5、名词从句（戴慧怡），句子变的名词。戴：That引导That she loves me is true.That he studies hard is true.That he does’t agree with me makes me angry.慧：Whether引导Is she beautiful ?Whether she is beautiful remains to be seen.怡：疑问词引导Where will he go ?Where he will go remains to be seen.

主语过大时，使用it。It makes me angry that he doesn’t agree with me.

6、名词短语名词短语=疑问词+不定式短语。Where to livewhat to do

why例外：Why did he cry ?Why he cries is something we don’t know.

7、介词短语介词又叫做前置词，通常置于名词之前。它是一种虚词，不需要重读，在句中不单独作任何句子成分，只表示其后的名词或相当于名词的词语与其他句子成分的关系。
介词之后出现的名词、代词或其他相当于名词的结构、短语或从句叫介词宾语。介词短语是指介词和介词宾语构成的短语。介词短语的构成主要有下面的形式： 

介词＋名词。如：The headmaster lives near the school校长住在学校附近。 

介词＋名词性从句。如：I am curious as to what she will say.我很想知道她想说什么。 

介词＋代词。如：What do you know about him ?关于他，你都知道些什么？ 

介词＋动名词短语或其复合结构。如：He is interested in swimming.他对游泳感兴趣。The painter is keen on collecting coins那位画家喜欢收集硬币。There are no risk of you being late你不会迟到的。 

介词＋连接词或连接副词引导的从句或不定式。如：Your success will largely depend upon how you do it.你成功与否将主要取决于你怎样做。The teacher gave us a talk on how to study English .老师给我们做了一个如何学英语的讲座。 

介词＋数词。如：Six from twelve is six12减6等于6。 

介词＋形容词。如：We know her of old我们老早就认识了她。 

介词＋副词。如：They worked all day and had a hurried luch in between .他们工作了一整天，中间匆匆吃了一顿饭。


介词短语在句中可作多种句子成分： 

作主语。如：From the library to the teaching building is a 5 minutes’ walk.从图书馆到教学楼要走五分钟。

作表语。如：Are you for the plan?你赞成这个计划吗？I was at my grandma’s yesterday.我昨天在我奶奶家。 

作宾语。如：He gave me until tomorrow.他给我的期限是到明天。The dog came out from behind the tree.．狗从树后出来。（behind the tree 作介词from 的宾语） 

作定语。如：She is a woman of strong character.她是位性格坚强的女人。The expert will give us a lecture on how to improve soil.这个专家将给我们作一个如何改良土壤的讲座。 

作补语。如：He woke up and found himself in hospital他醒来发现自己在医院里。（in hospital作宾补）As a doctor ,he is always patient with the patients作为一个医生，他一贯对患者很耐心。（As a doctor 作主补） 

作状语。如：I wil be free on Tuesday morning.星期二上午我有空。（时间状语）We’ll meet at the station .我们将在火车站碰面。（地点状语）She covered her face with her hands and cried她用双手捂着脸哭。（方式状语）He left home and worked in a big city for the sake o f money .他为了赚钱，离家到一个大城市工作。（目的状语）The tree died from want of water .这棵树因缺水而死。（原因状语）In spite of all his effort ,he failed尽管他很努力，但还是失败了。（让步状语）No living thing can live without water.生物离开水都无法生存。（条件状语）With the words, he came into the room他说着话就进来了。（伴随状语）To a great extent, it is not fair .在很大程度上，这是不公平的。（程度状语）In general her works have been good, but this one is dreaful.总的来说，她的作品很不错，不过这篇很糟。?( in general 作评注性状语)It doesn’t seem ugly to me , on the contrary, I think it’s very beautiful.我觉得它不丑，恰恰相反，我觉得它很美。（on the cntrary作连接性状语）


一般疑问句一般疑问句=倒置的简单句。

He is nice.Is he nice ?

They aren’t happy about it.Aren’t they happy about it ?

They can handle the problem.Can they handle the problem ?

He left early.Did he leave early ?



无论问句以肯定还是否定起首，回答时，只要认为肯定，就用yes回答；若认为否定，就用no回答。Q：Is he happy ?A：Yes,he is.  是的，他很快乐。


Q：Isn’t he happy ?A1：Yes,he is.  不，他很快乐。A2：No,he isn’t.  是的，他不快乐。

特殊疑问句特殊疑问句=倒置的简单句。

You will go where ?Where you will go ?Where will you go ?

He is who ?Who he is ?Who is he ?

You live where ?Where you live ?Where do you live ?

You saw whom then ?Whom you saw then ?Whom did you see then ?

He why cried ?Why he cried ?Why did he cry ?


祈使句祈使句=省略主语You的简单句。

You must run now.Run !Don’t run !

You must be quiet now.Be quiet !Don’t be quiet !

You must open the door now.Open the door.Don’t open the door.

Don’t ever try it.= Never try it.


感叹句感叹句=How/What+倒置的简单句。
HowHow + adj./adv. + 主语 + 动词

HowHow he studied hard.How hard he studied !

HowHow he is a great man.How great a man he is !


WhatWhat + 名词 + 主语 + 动词

WhatWhat he is a great man.What a great man he is !

WhatWhat he has a beautiful car.What a beautiful car he has !


复合句复合句=含有从句的简单句。从句不能单独成句，须由关联词引导，但它也有主语和动词。
名词性从句引导名词性从句的连接词有三种：

从属连词that，whether，if，as if等，只有连接的功能，不在从句中充当句子成分。
连接代词who，what，which，whose，whom 以及wh—ever。
连接副词when，where，why，because，how。

连接代词和连接副词不但有连接的功能，同时还在从句中充当一定的句子成分，如主语、宾语、表语等。
主语从句
一个主语从句的谓语动词用单数。
通常为保持句子平衡，用it作形式主语，而将主语从句放于句尾。
由that引导的从句，that虽没意义只起连接作用，但不能省略。
Wh-引导的从句，引导词放在句首，从句用陈述语序。

表语从句表语是用来说明主语的身份、性质、品性、特征和状态的，表语常由名词、形容词、副词、介词短语、不定式、动词的-ing、从句来充当，它常位于系动词之后。如果句子的表语也是由一个句子充当的，那么这个充当表语的句子就叫做表语从句。

表示“是否”时，表语从句的引导词只用whether。
That引导表语从句时，通常不省略，但在口语中也可省略或“，”代替that。

宾语从句宾语从句可分为三类：动词宾语从句、介词宾语从句和形容词宾语从句。

介词宾语从句中that不省略。
and连接的几个从句，第二个从句以后的that不能省略。
在“动词+it+宾语补足语+宾语从句”结构中，that不省略。

同位语从句同位语从句是解释说明某一名词内容和实质的从句，常用引导词有that，whether，who，why等；常见的解释说明的名词有fact，news，idea，order，hope等。

that引导同位语从句，虽然在句中无意义，但是不可以省略。
引导同位语从句表示“是否” 时，只用whether。
定语从句的先行词在从句中可以充当一定的句子成分，而同位语从句所补充说明的名词或代词在同位语从句中不作任何成分。

形容词性从句（定语从句）1、限定修饰：一般名词若本身并未具特殊性，可用形容词从句加以限定修饰，以加强其特殊性。限定修饰的形容词从句，其关系代词前不加逗号。He is a boy who works hard.
2、非限定修饰：专有名词（如Tom）及独一性名词（如father），之后接形容词从句，该关系代词前一定要加逗号。此时该形容词从句就称为非限定修饰语。换言之，专有名词或独一性名词本身就具有特殊性，不必再用形容词从句加以限定。I met John , who is my classmate.
3、关系代词种类和功能：



关系代词
主格
宾格



代替人
who
whom


代替事物
which
which


代替整个句子
which
which


4、关系代词使用原则：

关系代词前要有先行词（表人或事物的名词）。
关系代词在所引导的形容词从句中要做主语、宾语或be动词的补语。
否则关系代词前一定要有介词。

5、thatthat可做关系代词，取代who，whom或witch，但使用时有两个条件：

that前不准有逗号，换言之，that仅出现在限定修饰的形容词从句中。
that之前不可有介词。

某些情况下只可以用that：

序数词之后
避免与疑问词重复
最高级之后
“the very+名词”之后
all之后
“the only+名词”之后
句中若有两个相同关系代词引导的形容词从句出现时，为避免重复，第二个关系代词通常用that取代。
关系代词若做be动词的补语，表示某人的身份时，要用that。
两个名词性质不一，但却共用一个关系代词时，关系代词要用that。

副词性从句（状语从句）1、时间状语从句常用引导词：when（在…时）, as（当…时）, while（在…期间）, as soon as（一……就……）, before（在…之前）, after（在…之后）, since（自从…以来） , not…until（直到…才）
特殊引导词：the minute, the moment, the second, every time, the day，the instant（ 瞬间，顷刻）, immediately , directly（不久，立即）, no sooner … than（一…就…）, hardly …when（刚一…就…） , scarcely … when（几乎没有……的时候）
当用no sooner … than，hardly …when，scarcely … when作为引导词的时候，从句要部分倒装。
I didn’t realize how special my mother was until I became an adult.直到我成为了一个成年人我才意识到我的母亲是多么的特殊。
While John was watching TV, his wife was cooking.当约翰看电视时，他的妻子正在做饭。
The children ran away from the orchard(果园), the moment they saw the guard.孩子们一看到守卫就逃出了果园。
No sooner had I arrived home than it began to rain.还没等我到家就开始下雨了。
Every time I listen to your advice, I get into trouble.每当我听取你的建议时，我就会惹上麻烦。
2、地点状语从句常用引导词：where
特殊引导词：wherever, anywhere, everywhere
Generally, air will be heavily polluted where there are factories.一般来说，有工厂的地方空气污染就严重。
Wherever you go, you should work hard.无论你去哪里，你都应该努力工作。
Where there is no rain, farming is difficult or impossible.在没有雨水的地方，耕作是困难的或根本不可能的。
They were good persons. Where they went, there they were warmly welcomed.他们都是好人。因此他们走到哪里都受到热烈欢迎。
You should have put the book where you found it.你应该把书放回原来的地方。
Where the Communist Party of China goes, there the people are liberated.哪里有了中国共产党，哪里的人民就得解放。
Wherever the sea is , you will find seamen.有海就有海员。
3、原因状语从句常用引导词：because, since, as
特殊引导词：seeing that, now that, in that, considering that, given that.
My friends dislike me because I’m handsome and successful.我的朋友都不喜欢我，因为我又英俊又成功。
Now that everybody has come, let’s begin our conference.既然每个人都到了，让我们开始我们的会议吧。
The higher income tax is harmful in that it may discourage people from trying to earn more.更高的收入税是有害的，因为它或许会阻碍人们努力赚钱。
4、条件状语从句常用引导词：if, unless,whether(whether…or not)
特殊引导词：as/so long as, only if, providing/provided that, supposing that, in case that, on condition that
We’ll start our project if the president agrees.如果总统同意，我们将开始我们的项目
You will certainly succeed so long as you keep on trying.只要你继续努力，你一定会成功的。
Provided that there is no opposition, we shall hold the meeting here.如果没有人反对，我们就在这里开会。
5、目的状语从句常用引导词：so that, in order that
特殊引导词：lest, in case, for fear that，in the hope that, for the purpose that, to the end that
The boss asked the secretary to hurry up with the letters so that he could sign them.老板要求秘书快写函件以便他能在上面签字。
The teacher raised his voice on purpose that the students in the back could hear more clearly.为了让后面的学生听得更清楚，老师有意地提高了他的声音。注意，由for引导的是一个并列句，不是原因状语从句，但有表原因的意思，是并列连词
6、让步状语从句常用引导词：though, although, even if, even though
特殊引导词： as(用在让步状语从句中必须要倒装)，while ( 一般用在句首 )，no matter …， in spite of the fact that, whatever, whoever, wherever, whenever, however, whichever
Much as I respect him, I can’t agree to his proposal.尽管我很尊敬他， 但是我却不同意他的建议。
The old man always enjoys swimming even though the weather is rough.老人都很喜欢游泳，即使天气很恶劣。
No matter how hard he tried, she could not change her mind.不论他如何努力，她都不会改变她的主意。
He won’t listen whatever you may say.他不会听你说什么。
7、比较状语从句常用引导词：as(同级比较), than(不同程度的比较)
特殊引导词：the more … the more … ; just as …， so…; A is to B what/as X is to Y; no … more than; not so much A as B
She is as bad-tempered as her mother.她和她妈妈一样脾气很坏。
The house is three times as big as ours.这房子是我们的三倍大。
The more you exercise, the healthier you will be.你运动的越多，你就越健康。
Food is to men what oil is to machine.食物之于人，犹如油之于机器。。
8、方式状语从句常用引导词：as, as if, how
特殊引导词：the way
When in Rome, do as the Romans do.入国问禁，入乡随俗。
She behaved as if she were the boss.她表现得好像她是老板。
Sometimes we teach our children the way our parents have taught us.有时，我们用父母教导我们的方式教导我们的孩子。
9、结果状语从句常用引导词：so … that, such … that
特殊引导词：such that, to the degree that, to the extent that, to such a degree that
He got up so early that he caught the first bus.他很早起床以便赶上第一班公共汽车
It’s such a good chance that we must not miss it.这是一个好机会，千万不能错过它
To such a degree was he excited that he couldn’t sleep last night.他激动到这个程度，以至于他昨晚睡不着
并列句并列句=三种符号或并列连词连接的两个或以上简单句。
三种符号
破折号（——）He is versatile – he masters five different languages and plays the piano very well.

冒号（:）He has finally made his goal known to us : he wants to be a scientist.

分号（;）He is nice ; quite often he is seen helping others.


并列连词基本并列连词有三个：and，or，but。可以连接并列的单词、短语或句子。
连词短语由基本并列连词发展而来，也可以连接并列的单词、短语或句子。

both…and… 一方面，同时也
either…or… 或者，或者
neither…nor… 既非，也非
not…but… 并非，而是
not only…but also… 不仅，而且

as well as与rather than，也视为并列连词，可连接并列的单词、短语或句子。这两个并列连词连接主语时，该句动词随第一个主语做变化。
五大句型五大句型，以动词为分类依据。

动词及物与否判定方法：我他。他被我。放入英语动词，无毛病，则为及物动词，否则为不及物动词。 

完全及物动词（c.vt.）I love her.
不完全及物动词（i.vt.）I made her happy.
完全不及物动词（c.vi.）He slept.
不完全不及物动词（c.vt.）He is good.
授予动词（d.v.）I gave him a book.
写作想到写作，眼泪流下来。难搞的一比，还好我找到了写作的方法，人才！
句子成分顺序词序就是词或句子成分在句子中的排列顺序。英语里的词和句子成分在句子里的位置比较固定。现将句子成分和虚词在陈述句中的一般位置举例说明如下：
1)主语的位置 在陈述句基本结构的最前面。如： We help each other.我们互相帮助。
2)谓语动词的位置 在主语之后。如：We go to school every day.我们每天上学。
3)表语的位置 在连系动词之后。如：It’s fine today.今天天气很好。
4)宾语的位置 在及物动词或介词之后。如：I like this place.我喜欢这个地方。(及物动词的宾语的位置)
There are many trees in this place.这地方有许多树。(介词的宾语的位置)
5)定语的位置 单词作定语，一般放在被修饰语的前面，短语和从句作定语则放在被修饰语的后面。如：The school library has many books on agriculture.校图书馆有许多关于农业的书。(many和on agriculture，都修饰books，many在books的前面，on agriculture则在它的后面)
6)状语的位置 修饰形容词或副词的状语放在被修饰语之前；修饰动词的状语有的放在动词之前，有的放在动词之后。如动词有宾语，状语一般须放在宾语之后。如：The Summer Palace is very beautiful.颐和园非常美丽。(very为状语，修饰形容词beautiful，放在beautiful之前)
I know him well.我十分了解他。(well为状语，修饰动词 know，放在know之后)
The students often go on a picnic.这些学生经常出去野餐。(often为状语，修饰动词go，放在它的前面)
We take exercise every day.我们每天都运动。(every day为状语，修饰动词take，在宾语exercise之后)
7)冠词的位置 冠词在名词之前。如：I met a friend at the bus-stop.我在公共汽车站遇到一位朋友。
8)介词的位置 介词一般也放在名词或代词之前。如：There is a map of China on the wall.墙上有一幅中国地图。
9)连词的位置 连词一般放在同类的词、短语或从句之间。如：They worked quickly and efficiently.他们工作速度快，效率高。
He works just as hard as everyone else although he is over sixty.他尽管六十多岁了，仍和大家一样努力工作。
10)感叹词的位置 感叹词常放在句子最前面。如：Oh，it’s you!啊，是你呀!
非连续成分了解英语句子中非连续成分的运用无论对于正确理解英语句子的意思，还是用正确汉语来表达英语句子的意思都是至关重要的。
我们都知道，英语大多数陈述句都采用SVO这种线性结构(linear structure)，各成分之间的语法关系是靠语序来体现的，为了准确地表达句子中各成分之间的语法关系，避免歧义，人们在写英语句子时一般要遵循相邻原则(principle of adjacency)，即语法关系密切的两个成分应处于相邻的位置。但是，在实际运用中有时人们并不遵循这一原则，两个应该相邻成分之间被其它成分分隔，构成含非连续成分(discontinuous constituents)的句式。例如：1、A wild yell of jubilation to their surprise, went up suddenly from two dozen throats and pandemonium of joy ensued.
2、But here on the same road you might have seen among these heavy men a being lithe…
3、Indeed, if readers find the introduction hard going, they should read just the last section, then plunge into the body of the book, and return to Chapter I when puzzles arise about the general nature of the field.
4、As soon as they were gone, Elisabeth walked out to recover her spirits, or in other words, to dwell, without interpretation on those subjects that deaden then more.
上面几个都是含非连续成分的句子，但非连续成分的构成情况各不相同。例1句子中的主语A wild yell of jubilation和谓语went up被状语to their surprise分隔，构成主谓非连续成分，例2中谓语动词might have seen和宾语a being被状语among these heavy men分隔，构成动宾语非连续成分。例3中的中心词puzzles和修饰语被分句的谓语arise分隔，构成名词中心词和后置修饰非连续成分。例4不定式动词to dwell和该动词词组的小品词分隔，构成动词副词小品词非连续成分。
在上面四种非连续成分中，最多见的是中心词和后置修饰语非连续成分，这种连续成分比较复杂。除上面例3讲的中心词和介词短语修饰语以外，还有以下各种情况。
1、中心词是句子的主语，其修饰语是关系分句，这个关系分句的主语又是关系代词，这种关系分句往往可与中心词分隔。例如：Some things have been done that ought to have been done long ago.
2、中心词是主语或宾语，同时被两个后置修饰语修饰，其中一个修饰语把中心词和另一个修饰语分隔。例如：I’ve got something important to say.There is a man downstairs who wants to see you.The enterprises and property in China of the Japanese aggressors and the chief traitors were confiscated.Is there anything you want that you have not?从这几个例句看，造成非连续成分产生的可能是形容词，副词后置修饰语，介词短语后置修饰语,关系分句后置修饰语等。
3、中心词是主语或宾语，状语或插入成分把中心词和修饰语分隔。例如：There are a lot of people at the bus stop waiting for the bus.They found a room there to put up for the night.“Here is the man, “ he said, “who told us the good news yesterday.”at the bus stop, there都是状语，he said是插入成分，它们把中心词和修饰语分隔，产生了非连续成分。
4、中心词位于句首，而修饰它的后置修饰语又需置于谓语之后，两者不得不分开。这种情况多见于疑问代词作中心词的句子中。例如：What did he want to say about it?Who is there to be criticized?
研究上面所举的所有例句，我们可以发现，英语句子中的非连续成分主要由两个原因造成的，一个是插入语导致产生非连续成分，另一个是为了使句子结构平衡，防止句子产生头重脚轻而产生了非连续成分。含非连续成分的英语句子的运用，有时与修辞因素有关，即运用非连续成分是为了提高英语句子的修辞表达效果。含非连续成分的英语句子主要有以下几种修辞作用。
1、保持句子结构平稳由于用文字传递信息的需要，构成句子的各种成分可能会较复杂地交织在一起，这就不可避免地会导致句子结构不平衡的问题，违背句子末端加重(end weight)的原则。例如：News that the rebels threatened to blow up the city came.这个句子语法上应该是对的，但修辞效果无从谈起，句子的主语很长，谓语部分只有一个词，太短，句子头重脚轻，失去平衡。现在我们来看下列几例：When a subject was accused of a crime important enough to interest the king, public notice was given that on an appointed day the fate of the accused person would be decided in the king’s arena.
We watched on TV the two astronauts walking on the moon.
I know of a place on that mountain where we can find this kind of plant.这几个都是含非连续成分的句子，由于非连续成分的运用，按正常语序的句子所产生的弊端随之消失。句子结构平稳自然，语义严密，修辞效果显而易见。
2、避免句子意思混淆使用非连续成分有时可以避免句子意思混淆，请看下列例句：As I approached the stream I saw a tall man hastening toward me beyond it.
Once married, the church considers that a couple has signed up for a lifetime contrast.这两个句子的意思混淆，不合逻辑，原因是beyond it和once married这两个成分在句子中的位置不当。现在我们把它们改成如下形式：As I approached the stream, I saw a tall man beyond it hastening toward me.The church considers that a couple, once married, has signed for a lifetime contrast.这两个都是含非连续成分的句子，第一个句子中宾语和宾语补足语被分隔，第二个句子中分句的主语和谓语被分隔，但两个句子都意思清楚，完全合乎逻辑，非连续成分在某些情况下的优点，在此也可见一斑了。
3、使行文精炼，结构紧凑，言简意赅。使用非连续成分有时并非为了句子结构平稳，也不是为了避免句子意思混淆，而是为了使行文精炼，句子结构紧凑，语言表达言简意赅。这类非连续成分多数是插入型非连续成分，即插入成分把本来应该相连的两个成分分隔。例如：I shall propose several sorts of formulations and propose that such sub-collection structures of terms are a resource in the sensitivity to topic of the selection of place formulations.
从语法上讲in the sensitivity to topic完全可以省略，但句子所含的信息量会随之减少，而这一信息在交际中却是十分必要的。运用非连续成分我们不但不觉得句子罗嗦，而且还觉得行文精确，结构紧凑，言简意赅。再如：With the establishment during the last century and the flourishing during the present of a modern tradition in American literature, the authority of English opinion and usage has diminished.
显然，在这个句子中，非连续成分的运用与句子结构平衡有否无关，during the last century和during the present的运用主要是为了增加信息量，使信息更有效地传递。它们的运用并不给人冗赘的感觉，而是行文清晰精炼，结构严谨，语义表达确切严密。不过，使用英语非连续成分切忌弄巧成拙，以免引起不必要的误解。例如：The only person beside the teacher who knew the matter was the monitor.
在这个句子中，beside the teacher的位置会导致句子的意思产生歧义，因为who knew the matter可理解为修饰person，也可理解为修饰teacher，实际上beside the teacher是状语，应置句首：Beside the teacher the only person who knew the matter was the monitor.再如：Who is the man reading a newspa-pe-r next to the woman?
该句中，next to the woman可理解为man的后置修饰语，也可理解为newspa-pe-r的后置修饰语，句子是歧义句，意思含糊不清。应该换一种含非连续成分的句子来表达：Who is the man next to the woman reading a newspa-pe-r? 这个句子没有歧义，非连续成分的运用使句子语义表达清楚，这才是非连续成分运用的目的之一。
小作文审题思维捕捉话题和交际目的关键词根据交际目的确定写作格式根据交际目的选择框架表达根据话题构思填充内容寻找写作具体内容的方法是：从who、what、when、why、how五个角度对话题进行提问。如果得到的答案还不足以扩充出充分的内容，可以就寻找到的关键词进行第二轮提问。寻找到关键词后，只要将这些词与套语结合，扩充出通顺的句子，写做任务就算完成了。
行文思维引言的写作1、直入主题，直接点明想要采取的行为。2、铺垫导入，简要交代写信的背景或吸引对方注意、缓和语气。
发展部分的写作1、回顾写作目的的情绪基础以及情绪的诱因。2、具体说明写作目的的相关信息。3、两种方式的组合使用。
结尾部分的写作1、提出希望。2、使用致谢、敦促收信人早日回信等客套语。3、两种方式组合使用。
大作文审题思维研读写作指令，明确写作要求根据图画和文字信息，把握图片主旨1、将图片信息网真题话题类型习惯性引申

彻底批判
褒扬推广
揭示利弊

2、分析文字信息的内涵3、综合剖析图画形象
行文思维开头段写作1、描写单个形象时，按照从左到右从上到下的方位顺序进行描写。2、描写体现共性的多个形象时，仅对体香共性的细节进行描写，若多个形象动作类似可以进行合并描写。3、描写体现对比关系的多个形象时，对体现主旨的事物间的差异进行描写，对具有类似行为的形象可以合并描写。
主旨段写作主题句写作：1、用一句话将图片反映的内容概括出来。有时，可以加入how，why，where，what等维度。2、先概括图片浅层信息，再深入分析，采用逐渐深入的方式推导出主题句。
段落扩展方式：1、若话题为被彻底批判的热点现象时，需要围绕现象的“问题”展开论述，往往需要涉及问题的具体表现、影响、原因，相对应的段落扩展方式是举例论证和因果论证。2、若话题为值得褒扬的热点现象或人生哲理，需要围绕现象或这里的“价值”展开，可能设计的段落扩展方式是让步/正反道理论证、定义论证、举例论证、类比论证、因果论证等。3、若话题为有利有弊的热点现象，现象的“价值”和“问题”均需涉及，两部分的详略可根据论点侧重“利大于弊”还是“弊大于利”进行适当安排。常见的段落扩展方式为：举例论证和因果论证。4、段落扩展不一定是单一方式的运用，很可能是多种方式的综合。
结尾段写作总结法、建议法、反问法、引语法等。
文章的衔接1、利用上下文语域和含义之间的联系，形成自然衔接2、合理运用衔接词3、使用特定的句型实现上下文的衔接。
参考文档考研英语复习23问23答http://yunpan.cn/ccKViDKDzt65B  访问密码 b042
教你轻松一遍读懂英语句子http://yunpan.cn/ccKjsjFeMUJ5Y  访问密码 9bf5
]]></content>
      <categories>
        <category>英语</category>
      </categories>
      <tags>
        <tag>考研</tag>
        <tag>英语</tag>
      </tags>
  </entry>
  <entry>
    <title>Struts2概述</title>
    <url>/dev-struts2-start/</url>
    <content><![CDATA[名词解释Struts：它通过采用 Java Servlet/JSP 技术，实现了基于JavaEE Web应用的MVC设计模式的应用框架，是MVC经典设计模式中的一个经典产品。
Struts2：它是Struts的下一代产品，是在Struts和WebWork的技术基础上进行了合并的全新的Struts2框架。其全新的Struts2的体系结构与Struts的体系结构差别巨大。Struts2以WebWork为核心，采用拦截器的机制来处理用户的请求，这样的设计也使得业务逻辑控制器能够与ServletAPI完全脱离开，所以Struts2可以理解为WebWork的更新产品。
MVC模式的提出改变了程序设计的思路，但代码的规范性还是很差，而Struts框架则具有组件的模块化、灵活性和重用性的优点，同时也简化了基于MVC的Web应用程序的开发，从应用的角度来说，Struts有三大块：Struts核心类、Struts配置文件及Struts标签库。
Struts本身就实现了MVC模式，就Struts的发展来说，从以前的Struts1到现在的Struts2，其目的是为了给程序员一个好的框架来开发应用软件。

官网http://struts.apache.org/index.html
下载http://struts.apache.org/download
下载的下载 struts-*-all.zip 解压后，有四个文件夹：1、apps。包含基于Struts2的示例应用，是学习Struts2非常有用的资料。2、docs。包含Struts2的相关文档，如Struts2快速入门、Struts2文档、API文档等资料。3、lib。包含Struts2框架的核心类库，以及Struts2的第三方插件类库。其中有5个是必须的：struts2-core-*.jar、xwork-*.jar、 ognl-*.jar、commons-logging-*.jar、freemarker-*.jar。还有3个包也要注意导入，不导入运行Tomcat时候可能会出现异常。分别是：commons-io-*.jar、commons-fileupload-*.jar和javassist-*.ga.jar。整合Spring与Struts时，在Struts的lib目录中找到struts2-spring-plugin-*.jar，引入到工程中。4、src。包含Struts2框架的全部源代码。
MVC简介MVC包含三个基础部分：Model、View和Controller，这三个部分以最小的耦合协同工作，以增加程序的可扩展性和可维护性。在JSP demo设计中，首先JSP页面作为View，Servlet作为Controller，而JavaBean作为Model。具体来说，MVC具有以下优点：1、多个视图可以对应一个模型。按MVC设计模式，一个模型对应多个视图，可以减少代码的复制及代码的维护量，一旦模型发生改变，也易于维护。
2、模型返回的数据与现实逻辑分离。模型数据可以应用任何显示技术，例如，使用JSP页面、Velocity模板或者直接产生Excel文档等。
3、应用被分为三层，降低了各层之间的耦合，提供了应用的可扩展性。
4、控制层的概念也很有效，由于它把不同的模型和不同的视图组合在一起，完成不同的请求，因此控制层可以说是包含了用户请求权限的概念。
5、MVC更符合软件工程化管理的精神。不同的层各司其职，每一层的组件具有相同的特征，有利于通过工程化和工具化产生管理程序代码。
Struts2体系结构Struts2的基本流程如下：1、Web浏览器请求一个资源。2、过滤器Dispatcher查找请求，确定适当的Action。3、拦截器自动对请求应用通用功能，如验证和文件上传等操作。4、Action的execute方法通常用来存储和重新获得信息（通过数据库）。5、结果被返回到浏览器。可能是HTML、图片、PDF或其他。
其实，Struts2框架的应用着重在控制上。简单的流程是：页面-&gt;控制器-&gt;页面。最重要的控制器的取数据与处理后传数据的问题。
Struts2实例开发建立一个Web项目新建Dynamic Web Project，命名为“struts2”。
加载Struts2基本类库右击项目名，Properties，Java Build Path，Libraries，Add Library…，User Library，Next，User Libraries…，New…，输入“struts2”，OK，Add External JARs…，选中5个必须的jar文件，打开，OK。
右击项目名，Properties，Java Build Path，Libraries，Add Library…，User Library，Next，选中“struts2”，Finish。
配置web.xml文件在WebContent/WEB-INF中新建文件web.xml，内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app id="WebApp_9" version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"&gt;	&lt;welcome-file-list&gt;		&lt;welcome-file&gt;/hello.jsp&lt;/welcome-file&gt;	&lt;/welcome-file-list&gt;    &lt;filter&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;filter-class&gt;org.apache.struts2.dispatcher.FilterDispatcher&lt;/filter-class&gt;    &lt;/filter&gt;    &lt;filter-mapping&gt;        &lt;filter-name&gt;struts2&lt;/filter-name&gt;        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;    &lt;/filter-mapping&gt;&lt;/web-app&gt;
创建hello.jsp在WebContent中新建hello.jsp，内容如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Struts2应用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;form action="struts.action" method="post"&gt;		请输入姓名：&lt;input type="text" name="name" /&gt;&lt;br/&gt;		&lt;input type="submit" value="提交"/&gt;	&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;
Action实现类新建包com.voidking.struts2.action，新建类StrutsAction，代码如下：
package com.voidking.struts2.action;import java.util.Map;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class StrutsAction extends ActionSupport&#123;	private String name;		public String getName()	&#123;		return name;			&#125;		public void setName(String name)	&#123;		this.name=name;	&#125;		public String execute() throws Exception	&#123;		if(!name.equals("HelloWorld"))		&#123;			Map request = (Map)ActionContext.getContext().get("request");			request.put("name", getName());			return "success";		&#125;else &#123;			return "error";		&#125;	&#125;&#125;
在写代码的时候，郝同学发现，当输入类ActionSupport时，不会出现代码提示。于是，郝同学直接把刚才的Struts的5个主要类库拷贝到了WebContent/lib下，果然出现了代码提示。估计是因为eclipse在编辑时不会扫描通过Java Build Path添加的类库，而会扫描lib中的类库。
创建并配置struts.xml文件在src中新建文件struts.xml，内容如下：
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;    &lt;package name="default" namespace="/" extends="struts-default"&gt;        &lt;default-action-ref name="index" /&gt;        &lt;action name="struts" class="com.voidking.struts2.action.StrutsAction"&gt;            &lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;            &lt;result name="error"&gt;/hello.jsp&lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;
创建welcome.jsp在WebContent中新建文件welcome.jsp，代码如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@ taglib uri="/struts-tags" prefix="s" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;欢迎&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	hello&lt;s:property value="#request.name"/&gt;!&lt;/body&gt;&lt;/html&gt;
部署和运行发布，启动Tomcat，访问http://localhost:8080/struts2/ 或者 http://localhost:8080/struts2/hello.jsp 
PS：在调试过程中，如果修改了项目中的.java文件或者配置文件，就必须重新启动Tomcat服务器，而修改了JSP文件则只需要刷新页面即可。
Struts2实例分析工作流程用户发送一个请求后，web.xml中配置的FilterDispatcher就会过滤该请求。如果请求是以.action结尾，该请求就会被转入Struts2框架处理。Struts2框架接收到.action请求后，将根据.action请求前面的“*”来决定调用哪个业务。
Struts2框架中的配置文件struts.xml会起映射作用，它会根据“*”来决定调用用户定义的哪个Action类。例如在上面项目中，请求为struts.action，所以，在struts.xml中有个Action类的name为“struts”，这表示该请求与这个Action来匹配，就会调用该Action中class属性指定的Action类。
但是，在Struts2中，用户定义的Action类并不是业务拦截器，而是Action代理，其并没有和Servlet耦合。所以Struts2框架提供了一系列拦截器，它负责将HttpServletRequest请求中的请求参数解析出来，传入到用户定义的Action类中。然后再调用其execute()方法处理用户请求，处理结束后，会返回一个值，这时，Struts2框架的struts.xml文件又起到映射作用，会根据其返回的值来决定跳转到哪一个页面。如在上面项目中，如果返回的是SUCCESS，就会跳到welcome.jsp页面；如果是ERROR，就会回到原页面。
各文件详解web.xmlweb.xml中定义了一个过滤器，那么，过滤器是什么？
过滤器是用户请求和处理程序之间的一层处理程序。它可以对用户请求和处理程序响应的内容进行处理，通常用于权限控制、编码转换等场合。它先于与之相关的servlet或JSP页面运行在服务器上。过滤器可附加到一个或多个servlet或JSP页面上，并且可以检查进入这些资源的请求信息。在这之后，过滤器可以作如下的选择：1、以常规的方式调用资源（即，调用servlet或JSP页面）。2、利用修改过的请求信息调用资源。3、调用资源，但在发送响应到客户机前对其进行修改。4、阻止该资源调用，代之以转到其他的资源，返回一个特定的状态代码或生成替换输出。
在Servlet作为过滤器使用时，它可以对客户的请求进行处理。处理完成后，它会交给下一个过滤器处理，这样，客户的请求在过滤链里逐个处理，直到请求发送到目标为止。例如，某网站里有提交“修改的注册信息”的网页，当用户填写完修改信息并提交后，服务器在进行处理时需要做两项工作：判断客户端的会话是否有效；对提交的数据进行统一编码。这两项工作可以在由两个过滤器组成的过滤链里进行处理。当过滤器处理成功后，把提交的数据发送到最终目标；如果过滤器处理不成功，将把视图派发到指定的错误页面。
Servlet过滤器是在Java Servlet规范中定义的，它能够对过滤器关联的URL请求和响应进行相关检查和修改。Servlet过滤器能够在Servlet被调用之后检查response对象，修改response的Header对象和response内容。Servlet过滤器过滤的URL资源可以是Servlet、JSP、HTML文件，或者是整个路径下的任何资源。多个过滤器可以构成一个过滤器链，当请求过滤器关联的URL时，过滤器就会逐个发生作用。
所有过滤器必须实现java.Servlet.Filter接口，这个接口中含有3个过滤器类必须实现的方法：1、init(FilterConfig)：Servlet过滤器的初始化方法，Servlet容器创建Servlet过滤器实例后将调用这个方法。2、doFilter(ServletRequest,ServletResponse,FilterChain)：完成实际的过滤操作，当用户请求与过滤器关联的URL时，Servlet容器将先调用过滤器doFilter方法，返回响应之前也会调用此方法。FilterChain参数用于访问过滤器链上的下一个过滤器。3、destroy()：Servlet容器在销毁过滤器实例前调用该方法，这个方法可以释放Servlet过滤器占用的资源。
过滤器类编写完成后，必须要在web.xml中进行配置，格式如下：
&lt;filter&gt;	&lt;!--自定义的名称--&gt;	&lt;filter-name&gt;过滤器名&lt;/filter-name&gt;	&lt;!--自定义的过滤器类，注意，如果写在包下，要加包名--&gt;	&lt;filter-class&gt;过滤器对应类&lt;/filter-class&gt;	&lt;init-param&gt;		&lt;!--类中参数名称--&gt;		&lt;param-name&gt;参数名称&lt;/param-name&gt;		&lt;!--对应参数的值--&gt;		&lt;param-value&gt;参数值&lt;/param-value&gt;	&lt;/init-param&gt;&lt;/filter&gt;
过滤器必须和特定的URL关联才能发挥作用，过滤器的关联方式有3种：与一个URL关联、与一个URL目录下的所有资源关联、与一个Servelet关联。
&lt;filter-mapping&gt;	&lt;!--这里与上面配置的名称要相同--&gt;	&lt;filter-name&gt;过滤器名&lt;/filter-name&gt;	&lt;!--与一个URL资源关联--&gt;	&lt;url-pattern&gt;xxx.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;
&lt;filter-mapping&gt;	&lt;!--这里与上面配置的名称要相同--&gt;	&lt;filter-name&gt;过滤器名&lt;/filter-name&gt;	&lt;!--与一个URL目录下所有资源关联--&gt;	&lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;
&lt;filter-mapping&gt;	&lt;!--这里与上面配置的名称要相同--&gt;	&lt;filter-name&gt;过滤器名&lt;/filter-name&gt;	&lt;!--与一个Servlet关联--&gt;	&lt;url-pattern&gt;Servlet名称&lt;/url-pattern&gt;&lt;/filter-mapping&gt;

struts.xmlstruts.xml是Struts2框架的核心配置文件，主要用于配置开发人员编写的action。struts.xml文件通常放在Web应用程序的WEB-INF/classes目录下（src目录下也可以，src目录下编译生成的文件默认放在WEB-INF/classes目录下），该目录下的struts.xml将被Struts2框架自动加载。
struts.xml是一个XML文件，文件前面是XML的头文件，然后是标签，位于Struts2配置的最外层，其他标签都是包含在它里面的。
package元素Struts2的包类似于Java中的包，将action、result、result类型、拦截器和拦截器栈组织为一个逻辑单元，从而简化了维护工作，提高了重用性。
与Java中的包不同的是，Struts2中的包可以扩展另外的包，从而“继承”原有包的所有定义，并可以添加自己包的特有配置，以及修改原有包的部分配置。从这一点上看，Struts2中的包更像Java中的类。
package有以下几个常用属性：1、name：该属性是必选的，指定包的名字，这个名字将作为引用该包的键。注意，包的名字必须是唯一的，在一个struts.xml文件中不能出现两个同名的包。2、extends：该属性是可选的，允许一个包继承一个或多个先前定义的包。3、abstract：该属性是可选的，将其设置为true，可以把一个包定义为抽象的。抽象包不能有action定义，它只能作为“父”包，被其他包所继承。注意，以为Struts2的配置文件是从上到下处理的，所以父包应该在子包前面定义。4、namespace：该属性是可选的，将保存的action配置为不同的名称空间。如果接收到一个请求为/space/main.action，框架将首先查找/space名称空间，如果找到了，则执行main.action；如果没有找到，则到默认的名称空间（name=”default”）中继续查找。
如果接收到一个请求为/main.action，框架将首先查找“/”名称空间，如果找到了，则执行main.action；如果没有找到，则到默认的名称空间（name=”default”）中继续查找。
Action元素Struts2的核心功能是Action。对于开发人员来说，使用Struts2框架，主要的编码工作就是编写Action类。而开发好Action类后，就需要配置Action映射，以告诉Struts2框架，针对某个URL的请求应该交由哪个Action进行处理。
当一个请求匹配到某个Action名字时，框架就使用这个映射来确定如何处理请求。
&lt;action name="struts" class="com.voidking.struts2.action.StrutsAction"&gt;	&lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;	&lt;result name="error"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;
在上面代码中，如果一个请求映射到struts时，就会执行该Action配置的class属性对应的Action类。然后根据Action类的返回值决定跳转的方向。其实一个Action类中不一定只能有execute()方法。如果一个请求要调用Action类中的其他方法，就需要在Action配置中加以配置。例如，如果在com.voidking.struts2.action.StrutsAction中有另外一个方法为：
public String find() throws Exception&#123;return SUCCESS;&#125;
如果想要调用这个方法，就必须在Action中配置method属性，其配置方法为：
&lt;action name="find" class="com.voidking.struts2.action.StrutsAction" method="find"&gt;	&lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;	&lt;result name="error"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;


result元素一个result元素代表一个可能的输出。当Action类中的方法执行完成时，返回一个字符串型的结果代码，框架根据这个结果代码选择对应的result，向用户输出。
&lt;result name="逻辑视图名" type="视图结果类型" &gt;	&lt;param name="参数名"&gt;参数值&lt;/param&gt;&lt;/result&gt;
param中的name属性有两个值：1、location：指定逻辑视图。2、parse：是否允许在实际视图名中使用OGNL表达式，默认参数为true。实际上通常不需要写这个param标签，而是直接在中指定物理视图位置。
result中的name属性有如下值：1、success：表示请求处理成功，该值也是默认值。2、error：表示请求处理失败。3、none：表示请求处理完成后不跳转到任何界面。4、input：表示输入时如果验证失败应该跳转到什么地方。5、login：表示登录失败后跳转的目标。
type（非默认类型）属性支持的结果类型有以下几种：1、chain：用来处理Action链。2、chart：用来整合JFreeChart的结果类型。3、dispatcher：用来转向页面，通常处理JSP，该类型也为默认类型。4、freemarker：处理FreMarker模板。5、httpheader：控制特殊HTTP行为的结果类型。6、jsf：JSF整合的结果类型。7、redirect：重定向到一个URL。8、redirect-action：重定向到一个action。9、stream：想浏览器发送InputStream对象，通常用来处理文件下载，还可用于返回Ajax数据。10、tiles：与Tiles整合的结果类型。11、velocity：处理Velocity模板。12、xslt：处理XML/XSML模板。13、plaintext：显示原始文本文件，如文件源代码。
ActionSupport类在Struts2中，Action与容器已经做到完全解耦，不再继承某个类或实现某个接口，也就是说，上面的实例中，StrutsAction完全可以不继承ActionSupport类。但是，在特殊情况下，为了降低编程的工作难度，充分利用Struts2提供的功能，定义Action时会继承ActionSupport类，该类位于xwork2提供的包com.opensymphony.xwork2中。下面是ActionSupport实现的接口：
public class ActionSupport implements Action,Validateable,ValidationAware,TextProvider,LocaleProvider,Serializable&#123;&#125;
Action接口同样位于com.opensymphony.xwork2包，定义了一些常量和一个execute()方法。
public interface Action&#123;	public static final String SUCCESS = "success";	public static final String NONE = "none";	public static final String ERROR = "error";	public static final String INPUT = "input";	public static final String LOGIN = "login";	public String execute() throws Exception;&#125;
接口ValidationAware的实现类ValidationAwareSupport定义了三个集合成员，这些集合用户存储运行时的错误或者消息。ValidationAware的众多方法主要完成对这些成员的存储操作和判断集合中是否有元素的操作，ActionSupport仅仅实现对这些方法的简单调用。
Struts2数据验证及验证框架数据验证上面的实例中，即使用户输入空的name，服务器也会处理用户请求。但是，如果是注册时，用户注册了空的用户名和密码，并且保存到数据库中，如果后面要根据用户输入的用户名和密码来查询数据，这些空的输入就可能会引起异常。（PS：可以使用JavaScript在客户端验证）Action类继承了ActionSupport类，该类实现的接口中有Validateable，定义了validate()方法。所以只要在用户自定义的Action类中重写该方法就可以实现验证功能，修改ActionSupport如下：
package com.voidking.struts2.action;import java.util.Map;import com.opensymphony.xwork2.ActionContext;import com.opensymphony.xwork2.ActionSupport;public class StrutsAction extends ActionSupport&#123;	private String name;		public String getName()	&#123;		return name;			&#125;		public void setName(String name)	&#123;		this.name=name;	&#125;		public String execute() throws Exception	&#123;		if(!name.equals("HelloWorld"))		&#123;			Map request = (Map)ActionContext.getContext().get("request");			request.put("name", getName());			return SUCCESS;		&#125;else &#123;			return ERROR;		&#125;	&#125;		public void validate()	&#123;		//如果姓名为空，则把错误信息添加到Action类的fieldErrors		if(this.getName()==null || this.getName().trim().equals(""))		&#123;			addFieldError("name", "姓名是必须的！");		&#125;			&#125;&#125;
validate()方法会在execute()方法之前执行，执行该方法之后，Action类的fieldErrors中已经包含了数据校验错误信息，将把请求转发到input逻辑视图出，所以要在配置中加入以下代码：
&lt;action name="struts" class="com.voidking.struts2.action.StrutsAction"&gt;	&lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;	&lt;result name="error"&gt;/hello.jsp&lt;/result&gt;	&lt;result name="input"&gt;/hello.jsp&lt;/result&gt;&lt;/action&gt;

经过测试，我们发现，当输入为空时，界面上并不会有任何提示！废话，根本就没有在界面上设置显示错误的区域好不来！修改hello.jsp如下：
&lt;%@ page language="java" contentType="text/html; charset=UTF-8"    pageEncoding="UTF-8"%&gt;&lt;%@taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Struts2应用&lt;/title&gt;&lt;/head&gt;&lt;body&gt;	&lt;form action="struts.action" method="post"&gt;		请输入姓名：&lt;input type="text" name="name" /&gt;&lt;br/&gt;		&lt;input type="submit" value="提交"/&gt;		&lt;s:fielderror fieldName="name"/&gt;	&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;


验证框架上面的校验通过重写validate方法实现，这种方法虽然可以达到预期效果，但是如果不是一个输入框，而是2、3个甚至更多，那就要在validate方法中做出很多判断，而且这些判断的语句基本相同。所以Struts2提供了校验框架，只需要增加一个校验配置文件，就可以完成对数据的校验。Struts2提供了大量的数据校验框架，包括表单域校验器和非表单域校验器两种。
必填字符串校验器在包com.voidking.struts2.action中，新建文件StrutsAction-validation.xml，内容如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE validators PUBLIC        "-//OpenSymphony Group//XWork Validator Config 1.0//EN"        "http://www.opensymphony.com/xwork/xwork-validator-config-1.0.dtd"&gt;&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="name"&gt;		&lt;field-validator type="requiredstring"&gt;			&lt;!--去空格--&gt;			&lt;param name="trim"&gt;true&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;姓名是必须的&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;
如果想对StrutsAction中find()方法进行验证，命名应该为StrutsAction-find-validation.xml。
经过测试，完全没有效果，而且会报出警告！java.io.FileNotFoundException: http://www.opensymphony.com/xwork/xwork-validator-1.0.dtd
经过查找资料，原来是这个url已经过时了，opensymphony这个组织貌似已经停止运营了，但其主要的开源项目，也都基本找到了新东家，比如struts交由Apache来运营了，改成下面这个写法就没问题：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE validators PUBLIC        "-//OpenSymphony Group//XWork Validator Config 1.0//EN"        "http://struts.apache.org/dtds/xwork-validator-1.0.dtd"&gt;&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="name"&gt;		&lt;field-validator type="requiredstring"&gt;			&lt;!--去空格--&gt;			&lt;param name="trim"&gt;true&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;姓名是必须的&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;
关闭网络连接，再次测试，果然又不可以了！晕，还非得联网？难道不可以使用本地的文件吗！1、解压xwork-core-*.jar包，找到xwork-validator-1.0.dtd。
2、eclipse，Window，Preferences，XML，XML Catelog，Add，File System…，选中刚才解压的xwork-validator-1.0.dtd，打开，
3、Location已经选好D:\jar\struts2\xwork-validator-1.0.dtd，Key type选择Public ID，Key填-//OpenSymphony Group//XWork Validator Config 1.0//EN，Alternative web address填http://struts.apache.org/dtds/xwork-validator-1.0.dtd。（本地dtd不存在时回去web上去找dtd）
4、StrutsAction-validation.xml需要修改如下：
&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE validators PUBLIC        "-//OpenSymphony Group//XWork Validator Config 1.0//EN"        "D:\jar\struts2\xwork-validator-1.0.dtd"&gt;&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="name"&gt;		&lt;field-validator type="requiredstring"&gt;			&lt;!--去空格--&gt;			&lt;param name="trim"&gt;true&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;姓名是必须的&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

必填校验器&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="name"&gt;		&lt;field-validator type="required"&gt;			&lt;!--去空格--&gt;			&lt;param name="trim"&gt;true&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;姓名是必须的&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

整数校验器&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="age"&gt;		&lt;field-validator type="int"&gt;			&lt;param name="min"&gt;18&lt;/param&gt;			&lt;param name="max"&gt;100&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;年龄必须在18至100之间&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

日期校验器&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="date"&gt;		&lt;field-validator type="date"&gt;			&lt;param name="min"&gt;1980-01-01&lt;/param&gt;			&lt;param name="max"&gt;2016-01-01&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;日期必须在1980-01-01到2016-01-01之间&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

邮件地址校验器&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="email"&gt;		&lt;field-validator type="email"&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;必须输入有效的电子邮件地址&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

网址校验器&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="url"&gt;		&lt;field-validator type="url"&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;必须输入有效的网址&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

字符串长度校验器&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="password"&gt;		&lt;field-validator type="stringlength"&gt;			&lt;param name="minLength"&gt;8&lt;/param&gt;			&lt;param name="maxLength"&gt;16&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;密码长度必须在8到16位之间&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

正则表达式校验器&lt;validators&gt;&lt;!--需要校验的字段的字段名--&gt;	&lt;field name="xh"&gt;		&lt;field-validator type="regex"&gt;			&lt;param name="expression"&gt;&lt;![CDATA[(\d&#123;6&#125;)]]&gt;&lt;/param&gt;			&lt;!--错误提示信息--&gt;			&lt;message&gt;学号必须是6位数字&lt;/message&gt;		&lt;/field-validator&gt;	&lt;/field&gt;&lt;/validators&gt;

Struts2标签库Struts2标签库，大大简化了JSP页面输出逻辑的实现。借助Struts2标签库，完全可以避免在JSP页面中使用Java脚本代码。虽然Struts2把所有的标签都定义在URI为/struts-tags的命名空间下，但依然可以对Struts2标签进行简单的分类。1、UI标签。用于生成HTML元素，分为表单标签和非表单标签。2、非UI标签。用于数据访问和逻辑控制。3、Ajax标签。用于Ajax支持。
OGNL表达式OGNL是Object Graphic Navigation Language（对象图导航语言）的缩写，是一个开源项目。OGNL是一种功能强大的EL（Expression Language，表达式语言），可以通过简单的表达式来访问Java对象中的属性。
标准的OGNL会设定一个根对象（root对象）。假设使用标准OGNL表达式来求值（不是Struts2 OGNL），如果OGNL上下文有两个对象foo对象和bar对象，同时foo对象被设置为根对象，则利用下面的OGNL表达式求值。
#foo.blah	//返回foo.getBlah()#bar.blah	//返回bar.getBlah()blah		//返回foo.getBlah()，因为foo是根对象

在Struts2框架中，值栈（Value Stack）就是OGNL的根对象。假设值栈中存在两个对象实例Man和Animal，这两个对象实例都有一个name属性，Animal有一个species属性，Man有一个salary属性。假设Animal在值栈的顶部，Man在Animal后面，下面的代码片段能够更好地理解OGNL表达式。
species		//调用animal.getSpecies()salary		//调用man.getSalary()name		//调用animal.getName()
如果要获得Man的name值，需要如下代码：
man.name
Struts2允许在值栈中使用索引，实例代码如下：
[0].name	//调用animal.getName()[1].name	//调用man.getName()
Struts2中的OGNL Context是ActionContext，Context Map包括：application、session、值栈（root）、request、parameters、attr。
由于值栈是Struts2中ONGL的根对象。如果用户需要访问值栈中的对象，则可以通过如下代码访问值栈中的属性：
$&#123;foo&#125;	//获得值栈中foo的属性
如果访问其他Context中的对象，由于不是根对象，在访问时需要加#前缀。1、application对象：用来访问ServletContext，如#application.userName或者#application[“userName”]，相当于调用Servlet的getAttribute(“userName”)。2、session对象：用来访问HttpSession，如#session.userName或者#session[“userName”]，相当于调用session.getAttribute(“userName”)。3、request对象：用来访问HttpServletRequest属性的Map，如#request.userName或者#request[“userName”]，相当于调用request.getAttribute(“userName”)。StrutsAction中有如下代码：
Map request = (Map)ActionContext.getContext().get("request");request.put("name",getName);
这就是先得到的request对象，然后把值放进去，该例的welcome.jsp中有：
&lt;s:property value="#request.name"/&gt;
其中#request.name相当于调用了request.getAttribute(“name”)。
如果需要一个集合元素时，可以使用OGNL中集合相关的表达式。使用如下代码生成一个List对象：
&#123;e1,e2,e3,...&#125;
使用如下代码生成一个Map对象：
#&#123;key:value1,key2:value2,...&#125;
对于集合类型，OGNL表达式可以使用in和not in两个元素符号。其中，in表达式用来判断某个元素是否在指定的集合对象中；not in判断某个元素是否不在指定的集合对象中，代码如下所示：
&lt;s:if test="'foo' in &#123;'foo','bar'&#125;"&gt;	...&lt;s:/if&gt;
或
&lt;s: if test="'foo' not in &#123;'foo','bar'&#125;"&gt;	...&lt;s:/if&gt;
除了in和not in之外，OGNL还允许使用某个规则获得集合对象的自己，常用的有以下3个相关操作符。

?:获得所有符合逻辑的元素。
^:获得符合逻辑的第一个元素。
$:获得符合逻辑的最后一个元素。Person.relatives.&#123;?#this.gender=='male'&#125;
该代码可以获得Person的所有性别为male的relatives集合。

数据标签数据标签属于非UI标签，主要用于提供各种数据访问相关的功能。

property：用于输出某个值。
set：用于设置一个新变量。
param：用于设置参数，通常用于bean标签和action标签的子标签。
bean：用于创建一个JavaBean实例。如果指定id属性，则可以将创建的JavaBean实例放入Stack Context中。
action：用于JSP页面直接调用一个Action。
date：用于格式化输出一个日期。
debug：用于在页面上生成一个调试链接，当单击该链接时，可以看到当前值栈和Stack Context中的内容。
il8n：用于指定国际化资源文件的baseName。
include：用于在JSP页面中包含其他的JSP或Servlet资源。
push：用于将某个值放入值栈的栈顶。
text：用于输出国际化。
url：用于生成一个URL地址。

控制标签控制标签也属于非UI标签，主要用于完成流程的控制，以及对值栈的控制。

if、elseif、else：用于控制选择输出的标签。
append：用于将多个集合拼接成一个新的集合。
generator：用于将一个字符串按指定的分隔符分隔成多个字符串，临时生成的多个字符串可以使用iterator标签来迭代输出。
iterator：用于将ihelloworld迭代输出。
merge：用于将多个集合拼接成一个新的集合，但与append的拼接方式不同。
sort：用于对集合进行排序。
subset：用于截取集合的部分元素，形成新的子集合。

表单标签大部分表单标签和HTML表单元素是一一对应的关系，表单元素中的name属性值会映射到程序员定义的Action类中。
在上面的实例中，属性name的值“name”在StrutsAction的成员变量中就有setName()和getName()的定义，这样Struts2框架就可以把它们关联起来。实际上，表单元素的名字封装着一个请求参数，而请求参数被封装到Action类中，根据其set方法赋值，再根据其get方法取值。
如果有这样一个JavaBean类，类名为User，该类有两个属性：一个是username，一个是password。并分别生成它们的getter和setter方法，在JSP页面的表单中可以这样为表单元素命名：
&lt;s:textfield name="user.username" label="用户名"/&gt;&lt;s:textfield name="user.password" label="密码"&gt;
这时可以在Action类中直接定义user对象user属性，并生成其getter和setter方法，这样就可以用user.getUsername()和user.getPassword()方法访问表单提交的username和password的值。
下面介绍和HTML表单元素不是一一对应的几个重要的表单标签：

checkboxlist：可以一次创建多个复选框，相当于HTML标签的多个&lt;input type=”checkbox” …/&gt;，它根据list属性指定的集合来申请多个复选框。因此，该标签需要指定一个list属性。

combobox：生成一个单行文本框和下拉列表框的组合。两个表单元素只能对应一个请求参数，只有单行文本框里的值才会才包含请求参数，下拉列表框只是用于辅助输入，并没有name属性，故不会产生请求参数。

datetimepicker：用于生成一个日期、时间下拉列表框。当使用该日期、时间列表框选择某个日期、时间时，系统会自动将选中日期、时间输出指定文本框中。在使用该标签时，要在HTML的head部分加入&lt;s:head/&gt;，因为datetimepicker标签中有一个日历小控件，其中包含JavaScript代码。

select：用于生成一个下拉列表框，通过为该元素指定list属性的值，来生成下拉列表框的选项。

radio：用法与checkboxlist用法很相似，唯一的区别就是checkboxlist生成的是复选框，而radio生成的是单选框。

head：用于生成HTML页面的head部分。如果需要在页面中使用Ajax组件，就需要在head标签中加入theme=”ajax”属性。这样就可以将标准Ajax的头信息包含到页面中。


非表单标签非表单标签主要用于在界面中生成一些非表单的可视化元素。这些标签不经常用到：

a：生成超链接。
actionerror：输出Action实例的getActionMessage()方法返回的消息。
component：生成一个自定义组件。
div：生成一个div片段。
fielderror：输出表单域的类型转化错误、校验错误提示。
tablePanel：生成HTML页面的Tab页。
tree：生成一个树形结构。
treenode：生成树形结构的节点。

Struts2拦截器Struts2框架的绝大部分功能是通过拦截器来完成的。当FilterDispatcher拦截到用户请求后，大量拦截器将会对用户请求进行处理，然后才调用用户自定义的Action类中的方法来处理请求。可见，拦截器是Struts2的核心所在。当需要扩展Struts2功能时，只需要提供相应的拦截器，并将它配置在Struts2容器即可。反之，如果不需要某个功能，也只需要取消该拦截器即可。
Struts2内建的大量拦截器都是以name-class对的形式配置在struts-default.xml文件中，其中name是拦截器的名称，class指定该拦截器的实现类。从前面的实例中可以看出，配置struts.xm时，继承了strut-default包，这样就可以应用里面定义的拦截器。否则，就必须自己定义这些拦截器。
拦截器配置拦截器在struts.xml中配置，格式为：
&lt;interceptor name="拦截器名" class="拦截器实现类"&gt;&lt;/interceptor&gt;
有些时候，在拦截器实现类中会定义一些参数，那么在配置拦截器时就需要为其传入拦截器参数。
&lt;interceptor name="myInterceptor" class="com.voidking.struts2.tool.MyInterceptor"&gt;	&lt;param name="参数名"&gt;参数值&lt;/param&gt;&lt;/interceptor&gt;
通常情况下，往往多个拦截器一起使用来进行过滤，这时就会把需要的拦截器组成一个拦截器栈。
&lt;interceptor-stack name="拦截器栈名"&gt;	&lt;interceptor-ref name="拦截器一"&gt;&lt;/interceptor-ref&gt;	&lt;interceptor-ref name="拦截器二"&gt;&lt;/interceptor-ref&gt;	&lt;interceptor-ref name="拦截器三"&gt;&lt;/interceptor-ref&gt;&lt;/interceptor-stack&gt;
在配置拦截器栈时，用到的拦截器必须是已经存在的拦截器，即已经配置好的拦截器。拦截器栈也可以引用拦截器栈，实质上就是把引用的拦截器栈中的拦截器包含到了该拦截器栈中。
当在struts.xml中配置一个包时，可以为其指定默认的拦截器，如果为包指定了某个拦截器，则该拦截器会对每个Action起作用，但是如果显式地为某个Action配置了拦截器，则默认的拦截器将不会起作用。默认拦截器用元素来定义。
&lt;package name="包名"&gt;	&lt;interceptors&gt;		&lt;interceptor name="拦截器一" class="拦截器实现类"&gt;&lt;/interceptor&gt;		&lt;interceptor name="拦截器二" class="拦截器实现类"&gt;&lt;/interceptor&gt;		&lt;interceptor-stack name="拦截器栈名"&gt;			&lt;interceptor-ref name="拦截器一"&gt;&lt;/interceptor-ref&gt;			&lt;interceptor-ref name="拦截器二"&gt;&lt;/interceptor-ref&gt;		&lt;/interceptor-stack&gt;	&lt;/interceptors&gt;	&lt;default-interceptor-ref name="拦截器名或拦截器栈名"&gt;&lt;/default-interceptor-ref&gt;&lt;/package&gt;

拦截器实现类Struts2框架提供了很多拦截器，但总有一些功能需要程序员自定义拦截器来完成，比如权限控制等。Struts2提供了一些接口或类供程序员自定义拦截器。如Struts2提供了com.opensymphony.xwork2.interceptor.Interceptor接口，程序员只要实现该接口就可以完成拦截器实现类。该接口代码如下：
import java.io.Serializable;import com.opensymphony.xwork2.ActionInvocation;public interface Interceptor extends Serializable&#123;	void init();	String intercept(ActionInvocation invocation) throws Exception;	void destroy();&#125;

init()：该方法在拦截器被实例化之后、拦截器被执行之前调用。该方法只被执行一次，主要用于初始化资源。
intercept(ActionInvocation invocation)：该方法用于实现拦截的动作。该方法有个参数，该参数调用其invoke方法，将控制权交给下一拦截器，或者交给Action类的方法。
destroy()：该方法与init()方法对应，拦截器实例被销毁之前调用，用于销毁在init方法中打开的资源。

除了Intercept接口外，Struts2还提供了AbstractInterceptor类，该类提供了init方法和destroy方法的空实现。在一般的拦截器中，都会继承该类，因为一般实现的拦截器是不需要打开资源的，故无需实现这两个方法，继承该类会更简洁。
实例应用在上面的实例中，添加功能：在输入框输入“hello”，不能通过，返回当前页面。新建包com.voidking.struts2.tool，新建类MyInterceptor，代码如下：
package com.voidking.struts2.tool;import com.opensymphony.xwork2.Action;import com.opensymphony.xwork2.ActionInvocation;import com.opensymphony.xwork2.interceptor.AbstractInterceptor;import com.voidking.struts2.action.StrutsAction;public class MyInterceptor extends AbstractInterceptor&#123;	@Override	public String intercept(ActionInvocation arg0) throws Exception &#123;		// 得到StrutsAction类对象		StrutsAction action=(StrutsAction)arg0.getAction();		// 如果Action类的name属性值为“hello”，则返回错误页面		if(action.getName().equals("hello"))		&#123;			return Action.ERROR;		&#125;		return arg0.invoke();	&#125;&#125;
struts.xml修改如下：
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC    "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN"    "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt;    &lt;package name="default" namespace="/" extends="struts-default"&gt;        	&lt;interceptors&gt;    		&lt;interceptor name="myInterceptor" class="com.voidking.struts2.tool.MyInterceptor"&gt;&lt;/interceptor&gt;    	&lt;/interceptors&gt;    	&lt;default-interceptor-ref name=""&gt;&lt;/default-interceptor-ref&gt;    	        &lt;default-action-ref name="index" /&gt;        &lt;action name="struts" class="com.voidking.struts2.action.StrutsAction"&gt;            &lt;result name="success"&gt;/welcome.jsp&lt;/result&gt;            &lt;result name="error"&gt;/hello.jsp&lt;/result&gt;            &lt;result name="input"&gt;/hello.jsp&lt;/result&gt;                        &lt;!-- 拦截配置在result后面 --&gt;            &lt;!-- 使用系统默认拦截器栈 --&gt;            &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;            &lt;!-- 配置拦截器 --&gt;            &lt;interceptor-ref name="myInterceptor"&gt;&lt;/interceptor-ref&gt;                    &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;
Struts框架提供了
XML代码提示eclipse，Window，Preferences，XML，XML Files，Editor，Content Assist。Auto activation delay(ms):，设置为200。Prompt when these characters are inserted:，添加&quot;-abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ。
小结校验错误有提示fielderror，那么校验成功的提示该怎么搞？
参考文档《Java EE基础实用教程》，郑阿奇主编Servlet过滤器介绍之原理分析：http://zhangjunhd.blog.51cto.com/113473/20629/struts2和servlet区别：http://blog.csdn.net/qiluluwawa/article/details/8619568
]]></content>
      <categories>
        <category>专业</category>
        <category>开发</category>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>eclipse</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
</search>
