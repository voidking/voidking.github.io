<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.4.2"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://www.voidking.com").hostname,root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1,cdn:{enable:!0,url:"//qiniu-cdn.voidking.com/doc/search.xml"}},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="前言本章任务：  了解MetaGPT中Agent的概念 实现一个单动作Agent 实现一个多动作Agent 实现一个复杂Agent：技术文档助手"><meta property="og:type" content="article"><meta property="og:title" content="基于MetaGPT实现一个订阅智能体：第三章 MetaGPT框架组件介绍"><meta property="og:url" content="https://www.voidking.com/dev-ai-agent-based-on-metagpt-3/index.html"><meta property="og:site_name" content="好好学习的郝"><meta property="og:description" content="前言本章任务：  了解MetaGPT中Agent的概念 实现一个单动作Agent 实现一个多动作Agent 实现一个复杂Agent：技术文档助手"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.voidking.com/img/ai-agent-based-on-metagpt/role.png?imageView2/0/w/800"><meta property="article:published_time" content="2024-01-13T08:00:00.000Z"><meta property="article:modified_time" content="2024-01-13T08:00:00.000Z"><meta property="article:author" content="好好学习的郝"><meta property="article:tag" content="python"><meta property="article:tag" content="chatgpt"><meta property="article:tag" content="aigc"><meta property="article:tag" content="metagpt"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.voidking.com/img/ai-agent-based-on-metagpt/role.png?imageView2/0/w/800"><link rel="canonical" href="https://www.voidking.com/dev-ai-agent-based-on-metagpt-3/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>基于MetaGPT实现一个订阅智能体：第三章 MetaGPT框架组件介绍 | 好好学习的郝</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="好好学习的郝" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">好好学习的郝</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">一个计算机技术爱好者与学习者</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/voidking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.voidking.com/dev-ai-agent-based-on-metagpt-3/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="好好学习的郝"><meta itemprop="description" content="一个计算机技术爱好者与学习者"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="好好学习的郝"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> 基于MetaGPT实现一个订阅智能体：第三章 MetaGPT框架组件介绍</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2024-01-13 08:00:00" itemprop="dateCreated datePublished" datetime="2024-01-13T08:00:00+00:00">2024-01-13</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/" itemprop="url" rel="index"><span itemprop="name">engineering</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/engineering/aigc/" itemprop="url" rel="index"><span itemprop="name">aigc</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="前言"><span class="post-title-index">1.</span><a href="#前言" class="headerlink" title="前言"></a> 前言</h1><p>本章任务：</p><ul><li>了解MetaGPT中Agent的概念</li><li>实现一个单动作Agent</li><li>实现一个多动作Agent</li><li>实现一个复杂Agent：技术文档助手</li></ul><span id="more"></span><h1 id="MetaGPT中Agent的概念"><span class="post-title-index">2.</span><a href="#MetaGPT中Agent的概念" class="headerlink" title="MetaGPT中Agent的概念"></a> MetaGPT中Agent的概念</h1><p>MetaGPT中对于智能体的定义如下：</p><blockquote><p>智能体（Agent） = 大语言模型（LLM）+ 观察 + 思考 + 行动 + 记忆</p></blockquote><p>这个公式概括了智能体的功能本质。为了理解每个组成部分，让我们将其与人类进行类比：</p><ul><li>大语言模型（LLM）：LLM作为智能体的“大脑”部分，使其能够处理信息，从交互中学习，做出决策并执行行动。</li><li>观察：这是智能体的感知机制，使其能够感知其环境。智能体可能会接收来自另一个智能体的文本消息、来自监视摄像头的视觉数据或来自客户服务录音的音频等一系列信号。这些观察构成了所有后续行动的基础。</li><li>思考：思考过程涉及分析观察结果和记忆内容并考虑可能的行动。这是智能体内部的决策过程，其可能由LLM进行驱动。</li><li>行动：这些是智能体对其思考和观察的显式响应。行动可以是利用 LLM 生成代码，或是手动预定义的操作，如阅读本地文件。此外，智能体还可以执行使用工具的操作，包括在互联网上搜索天气，使用计算器进行数学计算等。</li><li>记忆：智能体的记忆存储过去的经验。这对学习至关重要，因为它允许智能体参考先前的结果并据此调整未来的行动。</li></ul><p>在MetaGPT中定义的一个agent运行示例如下：<br><img src="https://cdn.voidking.com/img/ai-agent-based-on-metagpt/role.png?imageView2/0/w/800"></p><ul><li>一个agent在启动后他会观察自己能获取到的信息，加入自己的记忆中</li><li>下一步进行思考，决定下一步的行动，也就是从Action1，Action2，Action3中选择执行的Action</li><li>决定行动后，紧接着就执行对应行动，得到这个环节的结果</li></ul><p>而在MetaGPT内 Role 类是智能体的逻辑抽象。一个 Role 能执行特定的 Action，拥有记忆、思考并采用各种策略行动。基本上，它充当一个将所有这些组件联系在一起的凝聚实体。</p><p>MetaGPT中对于多智能体的定义如下：</p><blockquote><p>多智能体 = 智能体 + 环境 + SOP + 评审 + 路由 + 订阅 + 经济</p></blockquote><h1 id="实现一个单动作Agent"><span class="post-title-index">3.</span><a href="#实现一个单动作Agent" class="headerlink" title="实现一个单动作Agent"></a> 实现一个单动作Agent</h1><h2 id="本节任务"><span class="post-title-index">3.1.</span><a href="#本节任务" class="headerlink" title="本节任务"></a> 本节任务</h2><p>利用MetaGPT框架实现一个生成代码的 Role，名为SimpleCoder。基于这个Role创建的Agent能够根据我们的需求来生成代码。</p><h2 id="需求分析"><span class="post-title-index">3.2.</span><a href="#需求分析" class="headerlink" title="需求分析"></a> 需求分析</h2><p>要实现一个 SimpleCoder ，我们需要分析这个 Role 它需要哪些能力</p><ul><li>能够接受用户输入的需求</li><li>记忆用户的需求</li><li>根据自己已知的信息和需求来编写代码</li></ul><h2 id="实现Role的思路"><span class="post-title-index">3.3.</span><a href="#实现Role的思路" class="headerlink" title="实现Role的思路"></a> 实现Role的思路</h2><p>要自己实现一个最简单的Role，只需要重写Role基类的 <code>_init_</code> 与 <code>_act</code> 方法</p><p>1、在 <code>_init_</code> 方法中，声明 Role 的name（名称）profile（人设）<br>2、使用 <code>self._init_action</code> 函数为Role配备期望的动作<br>3、在<code>_act</code>方法中，我们需要编写智能体具体的行动逻辑，智能体将从最新的记忆中获取人类指令，运行配备的动作，最后返回一个完整的消息。</p><p>在 MetaGPT 中，类 Action 是动作的逻辑抽象。用户可以通过简单地调用 <code>self._aask</code> 函数 来获取 LLM 的回复。<br><code>self._aask</code> 函数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_aask</span>(<span class="params">self, prompt: <span class="built_in">str</span>, system_msgs: <span class="type">Optional</span>[<span class="built_in">list</span>[<span class="built_in">str</span>]] = <span class="literal">None</span></span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Append default prefix&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> system_msgs:</span><br><span class="line">        system_msgs = []</span><br><span class="line">    system_msgs.append(<span class="variable language_">self</span>.prefix)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> <span class="variable language_">self</span>.llm.aask(prompt, system_msgs)</span><br></pre></td></tr></table></figure><p>它将调用你预设好的 LLM 来根据输出的提示词生成回答。</p><h2 id="实现SimpleWriteCode动作"><span class="post-title-index">3.4.</span><a href="#实现SimpleWriteCode动作" class="headerlink" title="实现SimpleWriteCode动作"></a> 实现SimpleWriteCode动作</h2><p>simple_write_code.py 文件中，实现SimpleWriteCode的动作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> metagpt.actions <span class="keyword">import</span> Action</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleWriteCode</span>(<span class="title class_ inherited__">Action</span>):</span><br><span class="line"></span><br><span class="line">    PROMPT_TEMPLATE = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Write a python function that can &#123;instruction&#125; and provide two runnnable test cases.</span></span><br><span class="line"><span class="string">    Return ```python your_code_here ``` with NO other texts,</span></span><br><span class="line"><span class="string">    your code:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="string">&quot;SimpleWriteCode&quot;</span>, context=<span class="literal">None</span>, llm=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, context, llm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, instruction: <span class="built_in">str</span></span>):</span><br><span class="line"></span><br><span class="line">        prompt = <span class="variable language_">self</span>.PROMPT_TEMPLATE.<span class="built_in">format</span>(instruction=instruction)</span><br><span class="line"></span><br><span class="line">        rsp = <span class="keyword">await</span> <span class="variable language_">self</span>._aask(prompt)</span><br><span class="line"></span><br><span class="line">        code_text = SimpleWriteCode.parse_code(rsp)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> code_text</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_code</span>(<span class="params">rsp</span>):</span><br><span class="line">        pattern = <span class="string">r&#x27;```python(.*)```&#x27;</span></span><br><span class="line">        <span class="keyword">match</span> = re.search(pattern, rsp, re.DOTALL)</span><br><span class="line">        code_text = <span class="keyword">match</span>.group(<span class="number">1</span>) <span class="keyword">if</span> <span class="keyword">match</span> <span class="keyword">else</span> rsp</span><br><span class="line">        <span class="keyword">return</span> code_text</span><br></pre></td></tr></table></figure><p>SimpleWriteCode 继承自 Action，重写了<code>__init__</code> 和 <code>run</code> 方法。<br><code>__init__</code> 方法用来初始化这个Action，而<code>run</code>方法决定了我们对传入的内容到底要做什么样的处理。<br>在<code>__init__</code>方法中，我们声明了这个这个动作的名称，行动前的一些前置知识context，要使用的llm。<br>在<code>run</code>方法中，我们需要声明当采取这个行动时，我们要对传入的内容做什么样的处理。<code>run</code>运行完成，返回代码内容。</p><h2 id="实现SimpleCoder角色"><span class="post-title-index">3.5.</span><a href="#实现SimpleCoder角色" class="headerlink" title="实现SimpleCoder角色"></a> 实现SimpleCoder角色</h2><p>simple_coder.py 文件中，实现SimpleCoder角色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> metagpt.roles <span class="keyword">import</span> Role</span><br><span class="line"><span class="keyword">from</span> metagpt.schema <span class="keyword">import</span> Message</span><br><span class="line"><span class="keyword">from</span> metagpt.logs <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> simple_write_code <span class="keyword">import</span> SimpleWriteCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleCoder</span>(<span class="title class_ inherited__">Role</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        name: <span class="built_in">str</span> = <span class="string">&quot;Alice&quot;</span>,</span></span><br><span class="line"><span class="params">        profile: <span class="built_in">str</span> = <span class="string">&quot;SimpleCoder&quot;</span>,</span></span><br><span class="line"><span class="params">        **kwargs,</span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, profile, **kwargs)</span><br><span class="line">        <span class="variable language_">self</span>._init_actions([SimpleWriteCode])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_act</span>(<span class="params">self</span>) -&gt; Message:</span><br><span class="line">        logger.info(<span class="string">f&quot;<span class="subst">&#123;self._setting&#125;</span>: ready to <span class="subst">&#123;self._rc.todo&#125;</span>&quot;</span>)</span><br><span class="line">        todo = <span class="variable language_">self</span>._rc.todo <span class="comment"># todo will be SimpleWriteCode()</span></span><br><span class="line"></span><br><span class="line">        msg = <span class="variable language_">self</span>.get_memories(k=<span class="number">1</span>)[<span class="number">0</span>] <span class="comment"># find the most recent messages</span></span><br><span class="line"></span><br><span class="line">        code_text = <span class="keyword">await</span> todo.run(msg.content)</span><br><span class="line">        msg = Message(content=code_text, role=<span class="variable language_">self</span>.profile, cause_by=<span class="built_in">type</span>(todo))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure><p>SimpleCoder继承自 Role，重写了 <code>__init__</code> 和 <code>_act</code> 方法。<br><code>__init__</code> 方法用来初始化这个Role，而<code>_act</code>方法决定了当这个角色行动时它的具体行动逻辑<br>在 <code>__init__</code> 方法中声明了这个Role的name（名称），profile（人设），并且调用<code>self._init_actions</code>配备刚才写好的Action SimpleWriteCode<br>调用<code>self._init_actions</code>之后，SimpleWriteCode就会被加入到代办<code>self._rc.todo</code>中。<br>在<code>_act</code>方法中，智能体调用todo.run()方法，执行Action。</p><p>当调用Action时，我们需要获取用户的输入来作为instruction传递给Action，这里就涉及到我们该如何获取用户之前传递给agent的信息，在MetaGPT中，当用户与Agent交互时，所有的内容都会被存储在Agent自有的Memory中。<br>在MetaGPT中，Memory类是智能体的记忆的抽象。当初始化时，Role初始化一个Memory对象作为<code>self._rc.memory</code>属性，它将在之后的_observe中存储每个Message，以便后续的检索。简而言之，Role的记忆是一个含有Message的列表。</p><p>当需要获取记忆时（获取LLM输入的上下文），我们可以使用self.get_memories。函数定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_memories</span>(<span class="params">self, k=<span class="number">0</span></span>) -&gt; <span class="built_in">list</span>[Message]:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;A wrapper to return the most recent k memories of this role, return all when k=0&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">self</span>._rc.memory.get(k=k)</span><br></pre></td></tr></table></figure><p>在SimpleCoder中，我们只需要获取最近的一条记忆，也就是用户下达的需求，将它传递给Action即可。</p><p>然后我们调用LLM，拿到LLM的输出，最后我们将拿到的信息封装为MetaGPT中通信的基本格式 Message 返回。</p><h2 id="运行单动作Agent"><span class="post-title-index">3.6.</span><a href="#运行单动作Agent" class="headerlink" title="运行单动作Agent"></a> 运行单动作Agent</h2><p>1、定义一个入口脚本 main.py</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from metagpt.logs import logger</span><br><span class="line">from simple_coder import SimpleCoder</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    msg = <span class="string">&quot;write a function that calculates the sum of a list&quot;</span></span><br><span class="line">    role = SimpleCoder()</span><br><span class="line">    logger.info(msg)</span><br><span class="line">    result = await role.run(msg)</span><br><span class="line">    logger.info(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>2、配置好LLM（第一章中已完成）<br>参考<a href="https://www.voidking.com/dev-ai-agent-based-on-metagpt-1/">《基于MetaGPT实现一个订阅智能体：第一章 前期准备》</a>，给MetaGPT配置一个LLM。</p><p>3、运行Agent</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><p>以上，我们就实现了一个简单的单动作Agent。</p><h1 id="实现一个多动作Agent"><span class="post-title-index">4.</span><a href="#实现一个多动作Agent" class="headerlink" title="实现一个多动作Agent"></a> 实现一个多动作Agent</h1><h2 id="为什么需要多动作Agent？"><span class="post-title-index">4.1.</span><a href="#为什么需要多动作Agent？" class="headerlink" title="为什么需要多动作Agent？"></a> 为什么需要多动作Agent？</h2><p>我们注意到一个智能体能够执行一个动作，但如果只有这些，实际上我们并不需要一个智能体。通过直接运行动作本身（输入提示词调用LLM），我们可以得到相同的结果。智能体的力量，或者说Role抽象的惊人之处，在于动作的组合（以及其他组件，比如记忆，但我们将把它们留到后面的部分）。通过连接动作，我们可以构建一个工作流程，使智能体能够完成更复杂的任务。</p><h2 id="本节任务-1"><span class="post-title-index">4.2.</span><a href="#本节任务-1" class="headerlink" title="本节任务"></a> 本节任务</h2><p>假设现在我们不仅希望用自然语言编写代码，而且还希望生成的代码立即执行，那么一个拥有多个动作的智能体可以满足我们的需求。<br>让我们称之为RunnableCoder，一个既写代码又立即运行的Role。我们需要两个Action：SimpleWriteCode 和 SimpleRunCode</p><h2 id="实现SimpleWriteCode动作-1"><span class="post-title-index">4.3.</span><a href="#实现SimpleWriteCode动作-1" class="headerlink" title="实现SimpleWriteCode动作"></a> 实现SimpleWriteCode动作</h2><p>与上文中 simple_write_code.py 一致，不用变化。</p><h2 id="实现SimpleRunCode动作"><span class="post-title-index">4.4.</span><a href="#实现SimpleRunCode动作" class="headerlink" title="实现SimpleRunCode动作"></a> 实现SimpleRunCode动作</h2><p>一个动作可以调用LLM，也可以不调用LLM。<br>在SimpleRunCode的情况下，不涉及调用LLM。我们只需启动一个子进程来运行代码并获取结果。</p><p>在Python中，我们通过标准库中的subprocess包来fork一个子进程，并运行一个外部的程序。</p><p>simple_run_code.py 文件中，实现SimpleRunCode的动作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">from</span> metagpt.actions <span class="keyword">import</span> Action</span><br><span class="line"><span class="keyword">from</span> metagpt.logs <span class="keyword">import</span> logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleRunCode</span>(<span class="title class_ inherited__">Action</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name=<span class="string">&quot;SimpleRunCode&quot;</span>, context=<span class="literal">None</span>, llm=<span class="literal">None</span></span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, context, llm)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, code_text: <span class="built_in">str</span></span>):</span><br><span class="line">        result = subprocess.run([<span class="string">&quot;python3&quot;</span>, <span class="string">&quot;-c&quot;</span>, code_text], capture_output=<span class="literal">True</span>, text=<span class="literal">True</span>)</span><br><span class="line">        code_result = result.stdout</span><br><span class="line">        logger.info(<span class="string">f&quot;<span class="subst">&#123;code_result=&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> code_result</span><br></pre></td></tr></table></figure><h2 id="实现RunnableCoder角色"><span class="post-title-index">4.5.</span><a href="#实现RunnableCoder角色" class="headerlink" title="实现RunnableCoder角色"></a> 实现RunnableCoder角色</h2><p>runnable_coder.py 文件中，实现RunnableCoder角色</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> metagpt.roles <span class="keyword">import</span> Role</span><br><span class="line"><span class="keyword">from</span> metagpt.schema <span class="keyword">import</span> Message</span><br><span class="line"><span class="keyword">from</span> metagpt.logs <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> simple_write_code <span class="keyword">import</span> SimpleWriteCode</span><br><span class="line"><span class="keyword">from</span> simple_run_code <span class="keyword">import</span> SimpleRunCode</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RunnableCoder</span>(<span class="title class_ inherited__">Role</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params"></span></span><br><span class="line"><span class="params">        self,</span></span><br><span class="line"><span class="params">        name: <span class="built_in">str</span> = <span class="string">&quot;Alice&quot;</span>,</span></span><br><span class="line"><span class="params">        profile: <span class="built_in">str</span> = <span class="string">&quot;RunnableCoder&quot;</span>,</span></span><br><span class="line"><span class="params">        **kwargs,</span></span><br><span class="line"><span class="params">    </span>):</span><br><span class="line">        <span class="built_in">super</span>().__init__(name, profile, **kwargs)</span><br><span class="line">        <span class="variable language_">self</span>._init_actions([SimpleWriteCode, SimpleRunCode])</span><br><span class="line">        <span class="variable language_">self</span>._set_react_mode(react_mode=<span class="string">&quot;by_order&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="keyword">def</span> <span class="title function_">_act</span>(<span class="params">self</span>) -&gt; Message:</span><br><span class="line">        logger.info(<span class="string">f&quot;<span class="subst">&#123;self._setting&#125;</span>: 准备 <span class="subst">&#123;self._rc.todo&#125;</span>&quot;</span>)</span><br><span class="line">        todo = <span class="variable language_">self</span>._rc.todo</span><br><span class="line"></span><br><span class="line">        msg = <span class="variable language_">self</span>.get_memories(k=<span class="number">1</span>)[<span class="number">0</span>] </span><br><span class="line">        result = <span class="keyword">await</span> todo.run(msg.content)</span><br><span class="line"></span><br><span class="line">        msg = Message(content=result, role=<span class="variable language_">self</span>.profile, cause_by=<span class="built_in">type</span>(todo))</span><br><span class="line">        <span class="variable language_">self</span>._rc.memory.add(msg)</span><br><span class="line">        <span class="keyword">return</span> msg</span><br></pre></td></tr></table></figure><p>用 <code>self._init_actions</code> 初始化所有 Action<br>用 <code>self._set_react_mode</code> 方法来设定我们action执行的先后顺序。将 react_mode 设置为 “by_order”，这意味着 Role 将按照 <code>self._init_actions</code> 中指定的顺序执行 Action。<br><code>_act</code> 定义每个action执行前后的处理逻辑。</p><p>此外，RunnableCoder继承自Role的run方法也很关键，它使得多个action都能被调用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">async def run(self, with_message=None):</span><br><span class="line">    <span class="string">&quot;&quot;</span><span class="string">&quot;Observe, and think and act based on the results of the observation&quot;</span><span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> with_message:</span><br><span class="line">        msg = None</span><br><span class="line">        <span class="keyword">if</span> isinstance(with_message, str):</span><br><span class="line">            msg = Message(with_message)</span><br><span class="line">        <span class="keyword">elif</span> isinstance(with_message, Message):</span><br><span class="line">            msg = with_message</span><br><span class="line">        <span class="keyword">elif</span> isinstance(with_message, list):</span><br><span class="line">            msg = Message(<span class="string">&quot;\n&quot;</span>.<span class="built_in">join</span>(with_message))</span><br><span class="line">        <span class="keyword">if</span> not msg.cause_by:</span><br><span class="line">            msg.cause_by = UserRequirement</span><br><span class="line">        self.put_message(msg)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> not await self._observe():</span><br><span class="line">        <span class="comment"># If there is no new information, suspend and wait</span></span><br><span class="line">        logger.debug(f<span class="string">&quot;&#123;self._setting&#125;: no news. waiting.&quot;</span>)</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line"></span><br><span class="line">    rsp = await self.react()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Reset the next action to be taken.</span></span><br><span class="line">    self._rc.todo = None</span><br><span class="line">    <span class="comment"># Send the response message to the Environment object to have it relay the message to the subscribers.</span></span><br><span class="line">    self.publish_message(rsp)</span><br><span class="line">    <span class="built_in">return</span> rsp</span><br></pre></td></tr></table></figure><h2 id="运行多动作Agent"><span class="post-title-index">4.6.</span><a href="#运行多动作Agent" class="headerlink" title="运行多动作Agent"></a> 运行多动作Agent</h2><p>1、定义一个入口脚本 main.py</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import asyncio</span><br><span class="line">from metagpt.logs import logger</span><br><span class="line">from runnable_coder import RunnableCoder</span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    msg = <span class="string">&quot;write a function that calculates the sum of a list&quot;</span></span><br><span class="line">    role = RunnableCoder()</span><br><span class="line">    logger.info(msg)</span><br><span class="line">    result = await role.run(msg)</span><br><span class="line">    logger.info(result)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>2、配置好LLM（第一章中已完成）<br>参考<a href="https://www.voidking.com/dev-ai-agent-based-on-metagpt-1/">《基于MetaGPT实现一个订阅智能体：第一章 前期准备》</a>，给MetaGPT配置一个LLM。</p><p>3、运行Agent</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python main.py</span><br></pre></td></tr></table></figure><p>以上，我们就实现了一个多动作Agent。<br>本节的完整代码，请参阅<a target="_blank" rel="noopener" href="https://github.com/voidking/hexo-storage/tree/main/ai-agent-based-on-metagpt/muliti-action-agent">ai-agent-based-on-metagpt/muliti-action-agent</a>。</p><h1 id="实现一个复杂Agent：技术文档助手"><span class="post-title-index">5.</span><a href="#实现一个复杂Agent：技术文档助手" class="headerlink" title="实现一个复杂Agent：技术文档助手"></a> 实现一个复杂Agent：技术文档助手</h1><h2 id="本节任务-2"><span class="post-title-index">5.1.</span><a href="#本节任务-2" class="headerlink" title="本节任务"></a> 本节任务</h2><p>怎么让大模型为我们写一篇技术文档？<br>可能想到的是，我们告诉大模型：“请帮我生成关于Mysql的技术文档”，他可能很快地就能帮你完成这项任务，但是受限于大模型自身的token限制，我们无法实现让他一次性就输出我们希望的一个完整的技术文档。<br>当然我们可以将我们的技术文档拆解成一个一个很小的需求，然后一个一个的提问，但是这样来说不仅费时，而且还需要人工一直去跟他交互，比较麻烦。<br>而使用智能体，就可以解决这个问题。</p><h2 id="需求分析-1"><span class="post-title-index">5.2.</span><a href="#需求分析-1" class="headerlink" title="需求分析"></a> 需求分析</h2><p>因为token限制的原因，我们先通过 LLM 大模型生成教程的目录，再对目录按照二级标题进行分块，对于每块目录按照标题生成详细内容，最后再将标题和内容进行拼接，解决 LLM 大模型长文本的限制问题。</p><h2 id="需求实现"><span class="post-title-index">5.3.</span><a href="#需求实现" class="headerlink" title="需求实现"></a> 需求实现</h2><p>1、实现 WriteDirectory 动作，根据用户需求生成文章大纲<br>2、实现 WriteContent 动作，根据传入的子标题来生成内容<br>3、实现 TutorialAssistant 角色，重写<code>_think</code>、<code>_act</code>、<code>_react</code>方法，添加角色特有方法 <code>_handle_directory</code></p><p>本节完整代码，请参阅<a target="_blank" rel="noopener" href="https://github.com/voidking/hexo-storage/tree/main/ai-agent-based-on-metagpt/doc-agent">ai-agent-based-on-metagpt/doc-agent</a>。<br>关于代码的解释，请参阅<a target="_blank" rel="noopener" href="https://deepwisdom.feishu.cn/wiki/KhCcweQKmijXi6kDwnicM0qpnEf">《MetaGPT智能体开发入门》教程</a>，写的非常详细了。</p><h1 id="本章作业"><span class="post-title-index">6.</span><a href="#本章作业" class="headerlink" title="本章作业"></a> 本章作业</h1><p>经过上面的学习，我想你已经对 MetaGPT 的框架有了基本了解，现在我希望你能够自己编写这样一个 agent</p><ul><li>这个 Agent 拥有三个动作 打印1 打印2 打印3（初始化时 init_action([print,print,print])）</li><li>重写有关方法（请不要使用act_by_order，我希望你能独立实现）使得 Agent 顺序执行上面三个动作</li><li>当上述三个动作执行完毕后，为 Agent 生成新的动作 打印4 打印5 打印6 并顺序执行，（之前我们初始化了三个 print 动作，执行完毕后，重新 init_action([…,…,…])，然后顺序执行这个新生成的动作列表)</li></ul><p>如果完成上面的任务，那这次作业已经可以算完成了，这个作业可以用多种思路去解决，比如我可以直接写死一整套的逻辑，甚至都不需要引入llm来完成这个工作，我希望大家通过这个作业来感受 MetaGPT 中 Agent 的行动逻辑，run-&gt;react-&gt;think-&gt;act 的这样一个过程，但你也可以试着在中间的某个环节中加入llm的交互，来尝试减少硬编码的工作，就像【实现一个更复杂的Agent：技术文档助手】中，我们实际上是让llm帮我们设计了 action 列表的内容。你也可以在此基础上做出更多的尝试，关于这个 Agent 我们还有更多可以思考的地方。</p><p>目前为止我们设计的所有思考模式都可以总结为是链式的思考（chain of thought），能否利用 MetaGPT 框架实现树结构的思考（tree of thought）图结构的思考（graph of thought）？试着实现让 ai 生成树结构的动作列表，并按照树的遍历方式执行他们，如果你实现，这将是加分项。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 好好学习的郝</li><li class="post-copyright-link"> <strong>原文链接：</strong> <a href="https://www.voidking.com/dev-ai-agent-based-on-metagpt-3/" title="基于MetaGPT实现一个订阅智能体：第三章 MetaGPT框架组件介绍">https://www.voidking.com/dev-ai-agent-based-on-metagpt-3/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本文采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议，转载请注明出处！源站会即时更新知识点并修正错误，欢迎访问~</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/python/" rel="tag"># python</a> <a href="/tags/chatgpt/" rel="tag"># chatgpt</a> <a href="/tags/aigc/" rel="tag"># aigc</a> <a href="/tags/metagpt/" rel="tag"># metagpt</a></div><div class="post-nav"><div class="post-nav-item"><a href="/dev-github-actions-pypi-release/" rel="prev" title="GitHub Actions实现PyPI发版"><i class="fa fa-chevron-left"></i> GitHub Actions实现PyPI发版</a></div><div class="post-nav-item"> <a href="/dev-linux-limit-user-command/" rel="next" title="好好学Linux：限制用户命令">好好学Linux：限制用户命令<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="footer-ads" style="margin-top:10px"></div><div class="comments" id="gitalk-container"></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-text">1. 前言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#MetaGPT%E4%B8%ADAgent%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">2. MetaGPT中Agent的概念</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%95%E5%8A%A8%E4%BD%9CAgent"><span class="nav-text">3. 实现一个单动作Agent</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E8%8A%82%E4%BB%BB%E5%8A%A1"><span class="nav-text">3.1. 本节任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="nav-text">3.2. 需求分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0Role%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="nav-text">3.3. 实现Role的思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0SimpleWriteCode%E5%8A%A8%E4%BD%9C"><span class="nav-text">3.4. 实现SimpleWriteCode动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0SimpleCoder%E8%A7%92%E8%89%B2"><span class="nav-text">3.5. 实现SimpleCoder角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%8D%95%E5%8A%A8%E4%BD%9CAgent"><span class="nav-text">3.6. 运行单动作Agent</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%9A%E5%8A%A8%E4%BD%9CAgent"><span class="nav-text">4. 实现一个多动作Agent</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%A4%9A%E5%8A%A8%E4%BD%9CAgent%EF%BC%9F"><span class="nav-text">4.1. 为什么需要多动作Agent？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E8%8A%82%E4%BB%BB%E5%8A%A1-1"><span class="nav-text">4.2. 本节任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0SimpleWriteCode%E5%8A%A8%E4%BD%9C-1"><span class="nav-text">4.3. 实现SimpleWriteCode动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0SimpleRunCode%E5%8A%A8%E4%BD%9C"><span class="nav-text">4.4. 实现SimpleRunCode动作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0RunnableCoder%E8%A7%92%E8%89%B2"><span class="nav-text">4.5. 实现RunnableCoder角色</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E5%A4%9A%E5%8A%A8%E4%BD%9CAgent"><span class="nav-text">4.6. 运行多动作Agent</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%8D%E6%9D%82Agent%EF%BC%9A%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3%E5%8A%A9%E6%89%8B"><span class="nav-text">5. 实现一个复杂Agent：技术文档助手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E8%8A%82%E4%BB%BB%E5%8A%A1-2"><span class="nav-text">5.1. 本节任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-1"><span class="nav-text">5.2. 需求分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9C%80%E6%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-text">5.3. 需求实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E4%BD%9C%E4%B8%9A"><span class="nav-text">6. 本章作业</span></a></li></ol></div></div><div class="sidecar-ads" style="margin-top:10px"><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="好好学习的郝" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">好好学习的郝</p><div class="site-description" itemprop="description">一个计算机技术爱好者与学习者</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">776</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">33</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">269</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:voidking@qq.com" title="E-Mail → mailto:voidking@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://github.com/voidking" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/voidking" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/voidking" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i> Zhihu</a></span></div></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 – <span itemprop="copyrightYear">2026</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">好好学习的郝</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="footer-beian"> <a href="http://beian.miit.gov.cn/" target="_blank">苏ICP备14021030号</a>&nbsp;|&nbsp; <img src="/images/beian.png" alt=""> <a target="_blank" href="http://www.beian.gov.cn/">苏公网安备 32032202000223号</a></div></div></footer></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><link rel="stylesheet" href="https://cdn.staticfile.net/gitalk/1.7.2/gitalk.min.css"><script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('https://cdn.staticfile.net/gitalk/1.7.2/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID: '5a238b8c32b1e4dd2156',
      clientSecret: 'bfb5d518626f6fdc7da0351d1e0cd37ab75c6361',
      repo: 'gitalk-comments',
      owner: 'voidking',
      admin: ['voidking'],
      id: 'f742124b16e2b2908ec8fc3d88a0aa68',
      title: '基于MetaGPT实现一个订阅智能体：第三章 MetaGPT框架组件介绍',
      body: '欢迎留言，互相交流学习~',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script></body></html>