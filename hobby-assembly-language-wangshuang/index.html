<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:new URL("https://www.voidking.com").hostname,root:"/",scheme:"Gemini",version:"7.7.1",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!0,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{appID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},path:"search.xml",motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}}}</script><meta name="description" content="汇编语言发展至今，由以下三类指令组成：汇编指令、伪指令、其他符号。 8086CPU有20位地址总线，可以传送20位地址，达到1MB的寻址能力。 物理地址&#x3D;段地址×16＋偏移地址  8086CPU有14个寄存器：AX,BX,CX,DX;CS,DS,SS,ES;IP,SI,DI,BP,SP;PSWCS(IP)  DS,ES(BX,SI,DI,BP)  SS(SP,BP)  DEBUG功能   r命令查"><meta property="og:type" content="article"><meta property="og:title" content="《汇编语言（王爽）》"><meta property="og:url" content="https://www.voidking.com/hobby-assembly-language-wangshuang/index.html"><meta property="og:site_name" content="好好学习的郝"><meta property="og:description" content="汇编语言发展至今，由以下三类指令组成：汇编指令、伪指令、其他符号。 8086CPU有20位地址总线，可以传送20位地址，达到1MB的寻址能力。 物理地址&#x3D;段地址×16＋偏移地址  8086CPU有14个寄存器：AX,BX,CX,DX;CS,DS,SS,ES;IP,SI,DI,BP,SP;PSWCS(IP)  DS,ES(BX,SI,DI,BP)  SS(SP,BP)  DEBUG功能   r命令查"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2013-11-26T10:03:10.000Z"><meta property="article:modified_time" content="2013-11-26T10:03:10.000Z"><meta property="article:author" content="好好学习的郝"><meta property="article:tag" content="笔记"><meta property="article:tag" content="读书"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.voidking.com/hobby-assembly-language-wangshuang/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0}</script><title>《汇编语言（王爽）》 | 好好学习的郝</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?b759ac2a7fa45129e3ef060bf68259f0";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="好好学习的郝" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-meta"><div><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">好好学习的郝</span><span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">好好学习，天天向上！</h1></div><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-fw fa-home"></i> 首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i> 关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i> 标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i> 分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i> 归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i> 搜索</a></li></ul></nav><div class="site-search"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"> <input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="搜索..." spellcheck="false" type="text" id="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"></div></div><div class="search-pop-overlay"></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div> <a href="https://github.com/voidking" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115 130 115 142 142 250 250 250 0Z"></path><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content"><div class="posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.voidking.com/hobby-assembly-language-wangshuang/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="好好学习的郝"><meta itemprop="description" content="学而不思则罔，思而不学则殆！"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="好好学习的郝"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"> 《汇编语言（王爽）》</h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i></span> <span class="post-meta-item-text">发表于</span> <time title="创建时间：2013-11-26 18:03:10" itemprop="dateCreated datePublished" datetime="2013-11-26T18:03:10+08:00">2013-11-26</time></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-folder-o"></i></span> <span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%88%B1%E5%A5%BD/" itemprop="url" rel="index"><span itemprop="name">爱好</span></a></span> ， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%88%B1%E5%A5%BD/%E8%AF%BB%E4%B9%A6/" itemprop="url" rel="index"><span itemprop="name">读书</span></a></span></span><span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span> <span class="post-meta-item-text">阅读次数：</span><span id="busuanzi_value_page_pv"></span></span></div></header><div class="post-body" itemprop="articleBody"><p>汇编语言发展至今，由以下三类指令组成：汇编指令、伪指令、其他符号。</p><p>8086CPU有20位地址总线，可以传送20位地址，达到1MB的寻址能力。</p><p>物理地址=段地址×16＋偏移地址</p><p>8086CPU有14个寄存器：<br><code>AX,BX,CX,DX;CS,DS,SS,ES;IP,SI,DI,BP,SP;PSW</code><br>CS(IP) DS,ES(BX,SI,DI,BP) SS(SP,BP)</p><blockquote><p>DEBUG功能</p></blockquote><blockquote><p>r命令查看、改变CPU寄存器中的内容<br>d命令产看内存中的内容<br>e命令改写内存中的内容<br>u命令将内存中的机器指令翻译成汇编指令<br>t命令执行一条机器指令<br>a命令以汇编指令的格式在内存中写入一条机器指令<br>p命令跳过循环和执行中断<br>g命令,“g 0016”直接跳到cs:0016</p></blockquote><a id="more"></a><p>在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应。栈也是。</p><p>汇编的一个经典栗子，看完再继续向下学习详细指令。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">assume</span> <span class="built_in">cs</span>:code,<span class="built_in">ds</span>:data</span><br><span class="line">data <span class="meta">segment</span></span><br><span class="line">     <span class="built_in">db</span> <span class="string">'welcome to masm!'</span></span><br><span class="line">data ends</span><br><span class="line">code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">start:</span>   <span class="keyword">mov</span> <span class="built_in">ax</span>,data</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">bx</span>,<span class="number">0</span>               <span class="comment">;ds:bx指向data字符串</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0b800h</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">si</span>,<span class="number">0</span>               <span class="comment">;es:si指向显存</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">cx</span>,<span class="number">16</span></span><br><span class="line"><span class="symbol">s:</span>   <span class="keyword">mov</span> <span class="built_in">al</span>,[<span class="built_in">bx</span>]            <span class="comment">;字符赋值al</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">02h</span>             <span class="comment">;绿色</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">si</span>].<span class="number">720h</span>,<span class="built_in">ax</span>    <span class="comment">;写入第12行64列</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">14h</span>             <span class="comment">;绿底红色</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">si</span>].<span class="number">7c0h</span>,<span class="built_in">ax</span>    <span class="comment">;写入第13行64列</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="number">ah</span>,<span class="number">71h</span>             <span class="comment">;白底蓝色</span></span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">es</span>:[<span class="built_in">si</span>].<span class="number">860h</span>,<span class="built_in">ax</span>    <span class="comment">;写入第14行64列</span></span><br><span class="line">     <span class="keyword">inc</span> <span class="built_in">bx</span>                 <span class="comment">;指向下一字符</span></span><br><span class="line">     <span class="keyword">add</span> <span class="built_in">si</span>,<span class="number">2</span>               <span class="comment">;指向下一显存单元</span></span><br><span class="line">     <span class="keyword">loop</span> s</span><br><span class="line">     <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">4c00h</span></span><br><span class="line">     <span class="keyword">int</span> <span class="number">21h</span></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><hr><p><strong>push</strong>指令执行步骤：1. <code>SP=SP-2</code> ; 2.<code>向SS:SP指向的字单元中送入数据</code>。<br><strong>pop</strong>指令执行步骤：1. <code>从SS:SP指向的字单元读取数据</code>； 2.<code>SP=SP＋2</code>。<br>任意时刻，SS:SP指向栈顶元素。</p><hr><p><strong>mov</strong>指令<br><code>mov ax,[0]</code> 送入0<br><code>mov ax,ds:[0]</code> 送入内存中的值<br><code>mov ax,[bx]</code> 送入内存中的值<br><code>mov ax,ds:[bx]</code> 送入内存中的值</p><hr><p><strong>add</strong> 指令<br><code>add ax,[1]</code>把1加到ax寄存器上</p><hr><p><strong>sub</strong>指令<br><code>sub ax,[1]</code>把ax寄存器中的值减1</p><hr><p><strong>and</strong> 逻辑与指令，按位进行与运算<br>将AL的第六位设为0：<code>and al,10111111B</code></p><hr><p><strong>or</strong> 逻辑或指令，按位进行或运算<br>将AL的第六位设为1：<code>or al,01000000B</code><br>大写字母的ASCII码第五位为0，小写字母的第五位为1.</p><hr><p>使用寄存器BP，如果没有显性地给出段地址，段地址就默认在SS中。<br><code>Mov ax,[bp]</code>:(ax)=((ss)<em>16+(bp))<br><code>Mov ax,[bp+si+idata]</code>:(ax)=((ss)</em>16+(bp)+(si)+idata)</p><hr><p>机器指令并不关心数据的值是多少，而关心指令执行前一刻，它将要处理的数据所在的位置。指令在执行前，所要处理的数据可以在三个地方：CPU内部，内存，端口<br><code>Mov bx,[0]</code>内存，ds:0单元<br><code>Mov bx,ax</code>CPU内部，ax寄存器<br><code>Mov bx,1</code>CPU内部，指令缓冲器</p><hr><p>8086CPU的指令，可以处理两种尺寸的数据，<strong>byte和word</strong>。所以在机器指令中要指明，指令进行的是字操作还是字节操作。</p><ol><li>通过寄存器名指明要处理的数据的尺寸；</li><li>没有寄存器名存在的情况下，用操作符<strong>byte ptr和word ptr</strong>指明内存单元的长度</li></ol><hr><p><strong>DIV</strong>除法指令：</p><ol><li>除数：<br>有8位和16位两种，在一个寄存器或内存单元中</li><li>被除数：<br>默认放在AX或AX和DX中<br>如果除数为8位，被除数则为16位，默认在AX中存放；<br>如果除服为16位，被除数则为32位，在DX和AX中存放，DX存放高16位，AX存放低16位。</li><li>结果：<br>如果除数为8 位，则AL存储除法操作的商，AH存储除法操作的余数；<br>如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。</li></ol><hr><p><strong>dup</strong>操作符，与db,dw,dd等数据定义伪指令配合使用的，用来进行数据的重复。<br><code>db 3 dup (&#39;abc&#39;, &#39;ABC&#39;)</code></p><hr><p><strong>offset</strong>取得标号偏移地址</p><hr><p>转移指令：可以控制CPU执行内存中某处的代码的指令。<br><code>jmp short 标号</code><br><code>jmp 标号</code><br><code>jmp far ptr 标号</code></p><p>1.只修改IP时，称为段内转移，如：<code>jmp ax</code>。<br>*短转移：IP的修改范围<code>-128——127</code><br>*近转移：IP的修改范围<code>-32768——32767</code></p><p>2.同时修改CS和IP 时，称为段间转移，如：<code>jmp 1000:0</code>。</p><hr><p><strong>jcxz</strong>指令 有条件转移指令。<br>所有的有条件转移指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都是：<code>-128——127</code>.</p><p><code>jcxz 标号</code><br>（如果（cx）=0，转移到标号处执行。）<br>操作：当（cx=0）时，（IP）=(IP)+8位位移：<br> 8位位移=”标号”处的地址 - jcxz指令后第一个字节的地址<br>相当于：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span><span class="params">((cx)</span></span>==<span class="number">0</span>) jmp short 标号</span><br></pre></td></tr></table></figure><hr><p><strong>loop</strong>指令 循环指令<br>所有的循环指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都是：<code>-128——127</code>.</p><p><code>loop 标号</code><br>（（cx）=(cx)-1,如果（cx）≠0，转移到标号处执行。）<br>操作：<br>1.（cx）=(cx)-1；<br>2. 如果（cx）≠0，（IP）=(IP)+8位位移。如果（cx）=0，什么也不做（程序向下执行）<br>相当于：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(cx)--</span><br><span class="line"><span class="function"><span class="title">If</span><span class="params">((cx)</span></span> ≠<span class="number">0</span>) jmp short 标号`</span><br></pre></td></tr></table></figure><hr><p><strong>ret</strong>指令 用栈中的数据，修改IP的内容，从而实现近转移<br>CPU执行ret指令时，<br>1.<code>（IP）=（（SS）*16+(SP)）</code><br>2. <code>(SP)=(SP)+2</code><br>相当于：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">POP </span><span class="built_in">IP</span></span><br></pre></td></tr></table></figure><hr><p><strong>Retf</strong> 指令 用栈中的数据，修改CS和IP 的内容，实现远转移<br>CPU执行retf指令时，</p><ol><li><code>（IP）=（（SS）*16+(SP)）</code></li><li><code>(SP)=(SP)+2</code></li><li><code>（CS）=（（SS）*16+(SP)）</code></li><li><code>(SP)=(SP)+2</code><br>相当于：<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POP<span class="built_in"> IP </span></span><br><span class="line">POP CS</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>CALL</strong> 指令不能实现短转移，除此之外，和JMP指令原理相同。<br>CPU 执行CALL指令时，<br>1.<code>将当前的IP或CS和IP压入栈中</code>；<br>2.<code>转移</code></p><p><code>call 标号</code>（将当前IP压栈后，转到标号处执行指令）<br>相当于：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUSH IP</span><br><span class="line">JMP near ptr 标号</span><br></pre></td></tr></table></figure><p><code>call far ptr 标号</code> （段间转移）<br>相当于：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push cs</span><br><span class="line">Push IP</span><br><span class="line">Jmp far ptr 标号</span><br></pre></td></tr></table></figure><p><code>call 16位寄存器</code><br>相当于：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUSH IP</span><br><span class="line">Jmp 16位寄存器</span><br></pre></td></tr></table></figure><p><code>call word ptr 内存单元地址</code><br>相当于：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push IP</span><br><span class="line">Jmp word ptr 内存单元地址</span><br></pre></td></tr></table></figure><p><code>call dword ptr 内存单元地址</code><br>相当于：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">Jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure><p>call 和 ret配合使用实现子程序的机制<br>框架如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">Assume</span> <span class="built_in">cs</span>:code</span><br><span class="line">Code <span class="meta">segment</span></span><br><span class="line"><span class="symbol">Main:</span> :</span><br><span class="line">        :</span><br><span class="line">        <span class="keyword">Call</span> sub1</span><br><span class="line">        :</span><br><span class="line"><span class="symbol">    Sub1:</span> :</span><br><span class="line">        <span class="keyword">Call</span> sub2</span><br><span class="line">        :</span><br><span class="line">        <span class="keyword">Ret</span></span><br><span class="line"><span class="symbol">    Sub2:</span></span><br><span class="line">        :</span><br><span class="line">        <span class="keyword">Ret</span></span><br><span class="line">Code ends </span><br><span class="line">End main</span><br></pre></td></tr></table></figure><hr><p><strong>mul</strong> 乘法指令;<br>(1)两个相乘的数，要么都是8位，要么都是16位；如果是8位，一个默认放在AH中，另一个放在8位寄存器或内存字节单元中；如果是16位，一个默认在AX中，另一个放在16位寄存器或内存字单元中。<br>(2)8位乘法，结果默认放在AX中；16位乘法，结果高位默认在DX中存放，低位在AX中存放。</p><hr><p>标志寄存器flag作用：<br>（1）用来存储相关指令的某些执行结果<br>（2）用来为CPU执行相关指令提供行为依据<br>（3）用来控制CPU的相关工作方式</p><p>第6位ZF，零标志位。它记录相关指令执行后，其结果是否为0。如果结果为0，那么ZF=1，不为0，那么ZF=0.影响标志寄存器的指令，如：add，sub，div，inc，mul，or，and等，他们大都是运算指令；有的指令对标志寄存器没有影响，比如：mov，push，pop等，他们大都是传送指令。</p><p>第2位PF，奇偶标志位。它记录相关指令执行后，其结果的所有二进制中1的个数是否为偶数。如果1的个数为偶数，PF=1，如果为奇数，那么PF=0.</p><p>第7位SF，符号标志位。它记录相关指令执行后，其结果（实际结果（寄存器中存放的结果）并非逻辑结果）是否为负。如果结果为负，SF=1，如果非负，SF=0。CPU在执行ADD等指令的时候，包含了两种含义。将得到用同一种信息记录的两种结果，关键在于我们的程序需要哪一种结果。SF标志就是CPU对有符号数运算结果的一种记录，它记录数据的正负。在我们将数据当作有符号数来运算的时候，可以通过它来得知结果的正负。如果我们将数据当作无符号数来运算，SF的值则没有意义，虽然相关的指令影响了它的值。</p><p>第0位CF，进位标志位。一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高位向更高位的进位值，或从更高位的借位值。</p><p>第11位OF，溢出标志位。一般情况下，OF记录了有符号数运算的结果是否发生了溢出。如果发生溢出，OF=1，如果没有，OF=0。CF 是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。</p><p>adc带进位加法指令，它利用了CF位上记录的进位值。<br>指令格式：adc 操作对象1，操作对象2<br>功能：操作对象1=操作对象1+操作对象2+CF<br>加法：1低位相加；2高位相加再加上低位相加产生的进位值<br>下面指令和add ax,bx具有相同的结果<br>Add al,al<br>Adc ah,ah</p><p>sbb 带借位减法指令，它利用了CF位上记录的借位值。<br>格式：sbb 操作对象1，操作对象2<br>功能：操作对象1=程序对象1-程序对象2-CF<br>Sbb ax,bx实现的功能：(ax)=(ax)-(bx)-CF</p><p>cmp 比较指令，cmp的功能相当于减法指令，只是不保存结果。Cmp指令执行后，将对标志寄存器产生影响。其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果。<br>格式：cmp 操作对象1，操作对象2<br>功能：计算操作对象1-操作对象2 但并不保存结果，仅仅根据计算结果对标志寄存器进行设置。<br>cmp ax,bx ；无符号数的比较<br>如果(ax)=(bx)则(ax)-(bx)=0,所以：ZF=1；<br>如果(ax)≠(bx)则(ax)-(bx)≠0，所以：ZF=0；<br>如果(ax)&lt;(bx)则(ax)-(bx)将产生借位，所以：CF=1；<br>如果(ax)≥(bx)则(ax)-(bx)不必借位，所以：CF=0；<br>如果(ax)&gt;(bx)则(ax)-(bx)既不借位，结果又不为0，所以：CF=0并且ZF=0<br>如果(ax)≤(bx)则(ax)-(bx)既可能借位，结果可能为0，所以：CF=1或ZF=1。<br>有符号数的比较：SF只能记录实际结果的正负，发生溢出的时候，实际结果的正负不能说明逻辑上真正结果的正负。但是逻辑上的结果的正负，才是cmp指令所求的真正结果，所以我们在考察SF的同时考察OF，就可以得知逻辑上真正结果的正负，同时就知道比较的结果。<br>1.如果SF=1，而OF=0<br>没有溢出，逻辑结果的正负=实际结果的正负<br>SF=1，实际结果为负，(ax)&lt;(bx)<br>2.如果SF=1, 而 OF=1<br>OF=1，说明有溢出，逻辑上真正结果的正负≠实际正负<br>SF=1，实际结果为负，如果因为溢出导致了实际结果为负，则逻辑上真正的结果必然为正。<br>这样SF=1, OF=1，说明了(ax)&gt;(bx)。<br>3.如果SF=0，而 OF=1 说明：(ax)&lt;(bx)<br>OF=1，说明有溢出，逻辑结果的正负≠实际结果的正负<br>SF=0，实际结果非负，有溢出结果非0，所以实际结果为正，如果因为溢出导致了实际结果为正，则逻辑上真正的结果必然为负。<br>4.如果SF=0，而 OF=0<br>没有溢出，且结果非负，所以(ax）≥(bx)</p><p>检测比较结果的条件转移指令<br>“转移”指的是它能够修改IP，而“条件”指的是它可以根据某种条件，决定是否修改IP。这些条件转移指令通常都和CMP相配合使用，就好像call和ret指令通常相配合使用一样。<br>常用的根据无符号数的比较结果进行转移的条件转移指令有：<br>指令 含义 检测位<br>Je 等于则转移 ZF=1<br>Jne 不等于则转移 ZF=0<br>Jb 低于则转移 CF=1<br>Jnb 不低于则转移 CF=0<br>Ja 高于则转移 CF=0且ZF=0<br>Jna 不高于则转移 CF=1或ZF=1<br>E :equal b: below a: above n: not j: jump</p><p>flag 的第10位是DF，方向标志位。在串处理指令中，控制每次操作后si,di 的增减。<br>DF=0 每次操作后si,di 递增<br>DF=1 每次操作后si,di 递减<br>Movsb 描述：mov es:[di],byte ptr ds:[si];（8086不支持这样的格式。）<br>如果DF=0; inc si inc di<br>如果DF=1； dec si dec di<br>功能：将ds:si指向的内存单元的字节送入es:di中，然后根据标志寄存器DF位的值，将si和di递增或递减。<br>Movsw 将ds:si指向的内存单元的字送入es:di中，然后根据标志寄存器DF位的值，将si和di递增2或递减2。</p><p>一般，movsb 和movsw都和rep配合使用，<br>格式：rep movsb<br>汇编描述：s: movsb<br> Loop s<br>可见，rep的作用是根据cx的值，重复执行后面的串传送指令。<br>8086对DF的设置：cld置0， std置1</p><p>pushf 将标志寄存器的值压栈，popf从栈中弹出数据，送入标志寄存器中。</p><p>四种内中断： 除法错误、单步执行、执行int0指令、执行int指令</p><p>中断信息中包含中断类型码，中断类型码为一个字节型数据，可以表示256种中断信息的来源，即中断源。</p><p>中断向量表，中断处理程序的入口地址列表。<br>中断向量表在内存中保存，其中存放着256个中断源所对应的中断处理程序的入口。<br>中断向量表指定存放在内存地址0处，从0000:0000到0000:03E8的1000个段媛中存放着中断向量表。<br>一个表项存放着一个中断向量，也就是一个中断处理程序的入口地址，对于8086CPU，这个入口地址包括段地址和偏移地址，所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址。</p><p>8086CPU在收到中断信息后，引发的中断过程为：<br>1.（从中断信息中）取得中断类型码； N<br>2. 标志寄存器的值入栈； pushf<br>3. 设置标志寄存器的第八位TF和第九位IF的值为0; TF=0,IF=0<br>4. CS的内容入栈 ; push CS<br>5. IP的内容入栈; push IP<br>6. 从内存地址为：中断类型码<em>4和中断类型码</em>4+2的两个字单元中读取中断处理程序的入口地址设置IP和CS。(IP)=(N<em>4),(CS)=(N</em>4+2)<br>在最后一步完成后，CPU开始执行程序员编写的中断处理程序。</p><p>CPU随时都可能执行中断处理程序，所以中断处理程序必须一直存储在内存某段空间之中。</p><p>中断处理程序的编写步骤：<br>1.保存用到的寄存器<br>2.处理中断<br>3.恢复用到的寄存器<br>4.用iret指令返回</p><p>Iret指令的功能用汇编语法描述为：<br>Pop IP<br>Pop CS<br>Popf<br>Iret指令执行后，CPU回到执行中断处理程序前的执行点继续执行程序。</p><p>CPU在执行完一条指令之后，如果检测到标志寄存器的TF位为1，则产生单步中断，引发中断过程。单步中断的中断类型码为1，则它引发的中断过程为：<br>[1]取得中断类型码1；<br>[2]标志寄存器入栈，TF,IF设置为0；<br>[3]CS,IP入栈;<br><a href="IP">4</a>=(1<em>4),(CS)=(1</em>4+2)。</p><p>Debug提供了单步中断的中断处理程序，功能为显示所有寄存器中的内容后等待输入命令。</p><p>响应中断的特殊情况：在执行完向SS寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。因为，SS：SP联合指向栈顶，而对他们的设置应该连续完成，如果在执行完设置SS的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和IP的值，而SS改变，SP并未改变，SS:SP指向的不是正确的栈顶，将引起错误。所以CPU在执行完设置SS的指令后，不响应中断。这给连续设置SS和SP，指向正确的栈顶提供了一个时机。因此我们将设置SS和SP 的指令连续存放，使得设置SP的质量紧接着设置SS的指令执行，而在此之前，CPU不会引发中断过程。</p><ol><li><p>int 指令格式：int n n为中断类型码，它的功能是引发中断过程<br>CPU执行INT N指令，相当于引发一个N号中断的中断过程：<br>[1]取中断类型码n<br>[2]标志寄存器入栈，IF=0，TF=0<br>[3]CS、IP入栈<br>[4]（IP）=（N<em>4），（CS）=（N</em>4+2）<br>从此处转去执行N号中断的中断处理程序。</p></li><li><p>在系统的ROM中存放着一套程序，称为BIOS（基本输入输出系统），BIOS中主要包括：<br>[1]硬件系统的检测和初始化程序；<br>[2]外部中断和内部中断的中断例程；<br>[3]用于对硬件设备进行I/O操作的中断例程；<br>[4]其他和硬件系统相关的中断例程。<br>操作系统DOS也提供了中断例程，从操作系统的角度来看，DOS的中断例程就是操作系统向程序员提供的编程资源。<br>程序员在编程的时候，可以用INT 指令直接调用BIOS和DOS提供的中断例程，来完成某些工作。</p></li><li><p>BIOS和DOS中断例程的安装：<br>[1] 开机后，CPU一加电，初始化（CS）=0FFFFH,(IP)=0，自动从FFFF:0单元开始执行程序，FFFF：0处有一条跳转指令，CPU执行该指令后，转去执行BIOS中的硬件系统检测和初始化程序。<br>[2]初始化程序将建立BIOS所支持的中断向量，即将BIOS提供的中断例程的入口地址登记在中断向量表中。注意，对于BIOS所提供的中断例程，只需将入口地址登记在中断向量表中即可，因为他们是固化到ROM中的程序，一直在内存中存在。<br>[3]硬件系统检测和初始化完成后，调用INT 19H进行操作系统的引导，从此将计算机交由操作系统控制。<br>[4]DOS启动后，除完成其他工作外，还将它所提供的中断例程装入内存，并建立相应的中断向量。</p></li></ol><p>1.在PC机系统中，和CPU通过总线相连的芯片除各种存储器外，还有：<br>[1]各种接口卡（如：网卡、显卡）上的接口芯片，他们控制接口卡进行工作<br>[2]主板上的借口芯片，CPU通过他们对部分外设进行访问<br>[3]其他芯片，用来存储相关的系统信息，或进行相关的输入输出处理<br>这些芯片中，都有一组可以由CPU读写的寄存器，他们在物理上可能处于不同的芯片中，但是他们在以下两点上相同：<br>[1]都和CPU的总线相连，当然是通过他们所在的芯片进行的<br>[2]CPU对他们进行读写的时候，都通过控制线向他们所在的芯片发出端口读写命令。<br>可见，从CPU的角度，将这些寄存器都当作端口，对他们进行统一的编址，从而建立了一个统一的端口地址空间。每一个端口在地址空间中都有一个地址。</p><p>2.端口地址和内存地址一样，通过地址总线来传送，在PC系统中，CPU最多可以定位64K个不同的端口。端口地址的范围：0<del>65535.<br>端口的读写：:in和out指令<br>In al ,60h 从60H号端口读入一个字节<br>在in和out指令中，只能使用ax和al来存放从端口中读入的数据或要发送到端口中的数据。访问8位端口用ax，访问16位端口用ax。<br>对0</del>255以内的端口进行读写时：<br>In al , 20h<br>Out 20h , a<br>对256~65535的端口读写时，端口号放在dx中<br>Mov dx , 3f8h<br>In al , dx 从端口3F8读入一个字节<br>Out dx, al 向端口3F8写入一个字节</p><ol start="3"><li>CMOS RAM 芯片简称CMOS 芯片特征：<br>[1]包含一个时钟和一个有128个存储单元的RAM存储器<br>[2]靠电池供电，关机后内部时钟正常工作，RAM中信息不丢失<br>[3]128个字节的RAM中，内部时钟占用0—0dh单元来保存时间信息，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。BIOS也提供了相关的程序，使我们可以在开机的时候配置CMOS RAM中的系统信息。<br>[4]该芯片内部有两个端口，端口地址为70H和71H。CPU通过这两个端口来读写CMOS RAM<br>[5]70H为地址端口，存放要访问的CMOS RAM单元的地址；71H为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行，比如：读CMOS RAM的2号单元：<br>①将2送入端口70H<br>②从71H读出2号单元的内容</li></ol><p>4.CMOS RAM中存放的时间信息<br>存放时间：年、月、日、时、分、秒。这6个信息的长度都是1个字节。</p><ol start="5"><li>SHL是逻辑左移指令，它的功能为：<br>[1]将一个寄存器或内存单元的数据向左移位；<br>[2]将最后移出的一位写入CF；<br>[3]最低位用0补充。<br>SHR逻辑右移指令，它与SHL操作相反：<br>[1]将一个寄存器或内存单元的数据向右移位；<br>[2]将最后移出的一位写入CF；<br>[3]最高位用0补充。</li></ol><p>1.外设的输入不直接送入内存和CPU，而是送入相关的借口芯片的端口中；CPU向外设的输出也不是直接送入外设，而是先送入端口中，再由相应的芯片送到外设。可见，CPU通过端口和外部设备进行联系。</p><p>2.可屏蔽中断：可由标志寄存器IF位设置，如果IF=1，CPU在执行完当前指令后响应中断，引发中断过程；如果IF=0，则不响应中断。<br>Sti ,用于设置IF=1；<br>Cli 用于设置IF=0.<br>中断过程：1. 取中断类型码n<br> 2. 标志寄存器入栈，IF=0，TF=0.<br> 3. CS、IP入栈<br> 4. （IP）=（N<em>4）,（CS）=（N</em>4+2）.<br>中断类型码是通过数据总线送入CPU 的。</p><p>3.键盘输入的处理：键盘中有一个芯片对键盘上的每一个键的开关状态进行扫描，按下一个键时，该芯片就产生一个扫描码，称为通码。扫描码被送入主板上的相关借口芯片的寄存器中，该寄存器的端口地址为60H。松开按下的键时，也产生一个扫描码，称为断码，也被送入60H。<br>断码=通码+80H<br>扫描码长度为一个字节，通码的第7位为0，断码的第7位为1.</p><p>4.键盘的输入到达60H端口时，相关的芯片就会向CPU发出中断类型码为9的可屏蔽中断信息。CPU检测到该中断信息后，如果IF=1，则响应中断，引发中断过程，转去执行int9中断例程。</p><p>5.BIOS提供了int9中断例程，用来进行基本的键盘输入处理，主要工作：<br>[1]读出60H端口中的扫描码；<br>[2]如果是字符键的扫描码，将该扫描码和它对应的字符码（ASCII码）送入内存中的BIOS键盘缓冲区；如果是控制键和切换键的扫描码，则将其转变成状态字节，写入内存中存储状态字的单元<br>[3]对键盘系统进行相关的控制，比如说，向相关芯片发出应答信息。<br>0040:17单元存储状态字节，该字节记录了控制键和切换键的状态。<br>0：右shift状态，置1表示按下<br>1：左shift状态，置1表示按下<br>2：ctrl状态，置1表示按下<br>3：alt状态，置1表示按下<br>4：scrolllock状态，置1表示scroll指示灯亮<br>5：Numlock状态，置1表示小键盘输入的是数字<br>6：capslock状态，置1表示输入大写字母<br>7：insert状态，置1表示出于删除态。</p><p>6.键盘输入的处理过程：<br>键盘产生扫描码——扫描码送入60H端口——引发9号中断——CPU执行INT9中断例程处理键盘输入。<br>前三步都是由硬件系统完成的。</p><p>7.简单延时函数<br>Mov dx,10h<br>Mov ax,0<br> S: sub ax,1<br> Sbb dx,0[1]<br> Cmp ax,0<br> Jne s<br> Cmp dx,0<br> Jne s<br> 程序实现100000H次循环。</p><p>8.指令系统总结：<br>[1]数据传送指令：mov、push、pop、pushf、popf、xchg等，这些指令实现寄存器和内存、寄存器和寄存器之间的单个数据传送。<br>[2]算术运算指令：add、sub、adc、sbb。Inc、dec、cmp、imul、idiv、aaa等，这些指令实现寄存器和内存中的数据的算术运算，他们的执行结果影响标志寄存器的：sf、zf、of、cf、pf、af位<br>[3]逻辑指令：and、or、not、xor、test、shl、shr、sal、sar、rol、ror、rcl、rcr等，除了not指令外，其他的执行结果都影响标志寄存器的相关标志位。<br>[4]转移指令：可以修改IP，或同时修改CS和IP的指令：无条件转移指令——jmp；条件转移指令——jcxz、je、jb、ja、jnb、jna；环指令：loop；过程：call，ret，retf；中断：int，iret。<br>[5]处理机控制指令：这些指令对标志寄存器或其他处理机状态进行设置，如：cld std cli sti nop clc cmc stc hlt wait esc lock等<br>[6]串处理指令：这些指令对内存中的批量数据进行处理，比如，movsb movsw cmps scas lods stos等，若要使用这些指令方便地进行批量数据的处理，则需要和rep、repe、repne等前缀指令配合使用。</p><p>1.描述了单元长度的标号：<br>a db 1,2,3,4<br> B dw 0<br> Mov al,a[si]<br> Mov ah,0<br> Add b,ax<br>标号a、b是同时描述内存地址和单元长度的标号。标号a，描述了地址code：0，和从这个地址开始，以后的内存单元都是字节单元；而标号b描述了地址code：4，和从这个地址开始，以后的内存单元都是字单元。<br>标号a,b后面没有“：”<br>指令：mov ax,b<br>相当于：mov ax,cs:[4]<br> 指令：mov al,b<br> 指令会引起编译错误，因为b代表的是字单元，al是8位寄存器。</p><p>2.在其他段中使用数据标号：如果想在代码段中，直接用数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来。否则编译器在编译的时候无法确定标号的段地址在哪一个寄存器中。</p><p>3.可以将功能子程序的入口地址存储在一个表中，他们在表中的位置和功能号相对应。对应的关系为：功能号*2=对应的功能子程序在地址表中的偏移。</p></div><div><ul class="post-copyright"><li class="post-copyright-author"> <strong>本文作者：</strong> 好好学习的郝</li><li class="post-copyright-link"> <strong>本文链接：</strong> <a href="https://www.voidking.com/hobby-assembly-language-wangshuang/" title="《汇编语言（王爽）》">https://www.voidking.com/hobby-assembly-language-wangshuang/</a></li><li class="post-copyright-license"> <strong>版权声明：</strong> 本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！源站会及时更新知识点及修正错误，阅读体验也更好。欢迎分享，欢迎收藏~</li></ul></div><footer class="post-footer"><div class="post-tags"> <a href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag"># 笔记</a> <a href="/tags/%E8%AF%BB%E4%B9%A6/" rel="tag"># 读书</a></div><div class="post-nav"><div class="post-nav-item"><a href="/dev-centos-skill/" rel="prev" title="CentOS的一些技巧"><i class="fa fa-chevron-left"></i> CentOS的一些技巧</a></div><div class="post-nav-item"> <a href="/hobby-dell-bois-setting/" rel="next" title="Dell的BIOS设置">Dell的BIOS设置<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div><div class="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC8zODU3Mi8xNTEwMA=="></div></div><script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span><span class="toggle-line toggle-line-middle"></span><span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc"> 文章目录</li><li class="sidebar-nav-overview"> 站点概览</li></ul><div class="post-toc-wrap sidebar-panel"></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"> <img class="site-author-image" itemprop="image" alt="好好学习的郝" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">好好学习的郝</p><div class="site-description" itemprop="description">学而不思则罔，思而不学则殆！</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"> <a href="/archives/"><span class="site-state-item-count">622</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"> <a href="/categories/"><span class="site-state-item-count">50</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"> <a href="/tags/"><span class="site-state-item-count">198</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="mailto:voidking@qq.com" title="E-Mail → mailto:voidking@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i> E-Mail</a></span><span class="links-of-author-item"><a href="https://github.com/voidking" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i> GitHub</a></span><span class="links-of-author-item"><a href="http://weibo.com/voidking" title="Weibo → http:&#x2F;&#x2F;weibo.com&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i> Weibo</a></span><span class="links-of-author-item"><a href="https://www.zhihu.com/people/voidking" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;voidking" rel="noopener" target="_blank"><i class="fa fa-fw fa-quora"></i> Zhihu</a></span></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright"> &copy; 2014 – <span itemprop="copyrightYear">2021</span><span class="with-love"><i class="fa fa-user"></i></span> <span class="author" itemprop="copyrightHolder">好好学习的郝</span></div><div class="busuanzi-count"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span class="post-meta-item" id="busuanzi_container_site_uv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-user"></i></span><span class="site-uv" title="总访客量"><span id="busuanzi_value_site_uv"></span></span></span> <span class="post-meta-divider">|</span><span class="post-meta-item" id="busuanzi_container_site_pv" style="display:none"><span class="post-meta-item-icon"><i class="fa fa-eye"></i></span><span class="site-pv" title="总访问量"><span id="busuanzi_value_site_pv"></span></span></span></div><div class="footer-beian"> <a href="http://www.beian.miit.gov.cn/" target="_blank">苏ICP备14021030号</a>&nbsp;|&nbsp; <img src="/images/beian.png" alt=""> <a target="_blank" href="http://www.beian.gov.cn/">苏公网安备 32032202000223号</a></div></div></footer><div id="needsharebutton-float"><span class="btn"><i class="fa fa-share-alt" aria-hidden="true"></i></span></div></div><script color="0,0,255" opacity="0.5" zindex="-1" count="99" src="/lib/canvas-nest/canvas-nest.min.js"></script><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><link rel="stylesheet" href="/lib/needsharebutton/needsharebutton.css"><script src="/lib/needsharebutton/needsharebutton.js"></script><script>pbOptions={iconStyle:"box",boxForm:"horizontal",position:"bottomCenter",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-postbottom",pbOptions),flOptions={iconStyle:"box",boxForm:"horizontal",position:"topRight",networks:"Weibo,Wechat,Douban,QQZone,Twitter,Facebook"},new needShareButton("#needsharebutton-float",flOptions)</script><script>
NexT.utils.loadComments(document.querySelector('#lv-container'), () => {
  // window.livereOptions = {
  //   refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  // };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
});
</script></body></html>